language: swift
name: HumanEval_145_order_by_points
results:
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var nums_copy = [Int](nums)\n    if nums_copy.count == 0 {\n        return\
    \ nums_copy\n    }\n\n    var sums = [Int]()\n    for i in 0..<nums_copy.count\
    \ {\n        let sum = nums_copy[i]\n        if sum != 0 && sums.count < nums_copy.count\
    \ {\n            sums.append(sum)\n        }\n    }\n    \n    // Sort the sums\
    \ first\n    var indices = [Int]()\n    for i in 0..<sums.count {\n        let\
    \ idx = sums.index(of: sums[i])!\n        indices.append(idx)\n    }\n    indices.sortInPlace()\n\
    \    \n    // And finally the original array\n    var sorted_nums = [Int]()\n\
    \    for i in 0..<indices.count {\n        let idx = indices[i]\n        sorted_nums.append(nums_copy[idx])\n\
    \    }\n    return sorted_nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp0lic9hiz.swift:28:24: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let idx = sums.index(of: sums[i])!\n         \
    \              ^\n/tmp/tmp0lic9hiz.swift:28:24: note: use 'firstIndex(of:)' instead\n\
    \        let idx = sums.index(of: sums[i])!\n                       ^~~~~\n  \
    \                     firstIndex\n/tmp/tmp0lic9hiz.swift:31:13: error: value of\
    \ type '[Int]' has no member 'sortInPlace'\n    indices.sortInPlace()\n    ~~~~~~~\
    \ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sorted = nums.sorted()\n    let lookup = Int((sorted.reduce(0) { a, b\
    \ in\n        let digit = a%10 + b%10\n        return digit\n    }) / 10)\n  \
    \  let sorted = sorted.map { x in\n        if x < 0 {\n            return -x\n\
    \        } else {\n            return lookup[x]\n        }\n    }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmptz2lw6k9.swift:21:26: error: value of type 'Int' has no subscripts\n\
    \            return lookup[x]\n                   ~~~~~~^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  if nums == nil || nums.isEmpty {\n    return nums\n  }\n\n  var maxSum = nums.reduce(0)\
    \ { $0 + $1 }\n  var maxIndex = -1\n  for i in 0 ..< nums.count {\n    let sum\
    \ = nums[i]\n    if sum > maxSum {\n      maxSum = sum\n      maxIndex = i\n \
    \   }\n  }\n\n  nums[maxIndex] = nums.count\n  return nums\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp0_yekuh1.swift:12:11: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n  if nums == nil || nums.isEmpty\
    \ {\n     ~~~~ ^  ~~~\n/tmp/tmp0_yekuh1.swift:26:7: error: cannot assign through\
    \ subscript: 'nums' is a 'let' constant\n  nums[maxIndex] = nums.count\n  ~~~~^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty() { return nums }\n    var result = nums\n    let set = Set<Int>()\n\
    \    for num in result {\n        if !set.contains(num) {\n            set.insert(num)\n\
    \            result.insert(num)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpjlkxu4m5.swift:12:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums.isEmpty() { return nums }\n            ^      ~~\n\
    \                   \n/tmp/tmpjlkxu4m5.swift:17:17: error: cannot use mutating\
    \ member on immutable value: 'set' is a 'let' constant\n            set.insert(num)\n\
    \            ~~~ ^\n/tmp/tmpjlkxu4m5.swift:14:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let set = Set<Int>()\n    ^~~\n    var\n/tmp/tmpjlkxu4m5.swift:18:30:\
    \ error: missing argument for parameter 'at' in call\n            result.insert(num)\n\
    \                             ^\n                             , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var max_sum: Int = 0\n    let max_num = nums.first!\n    let len = nums.count\n\
    \    for num in nums.dropFirst() {\n        let sum = sumDigits(num)\n       \
    \ if sum > max_sum {\n            max_sum = sum\n            max_num = num\n \
    \       }\n    }\n    return nums.filter({ sumDigits($0) == max_sum }).sorted(by:\
    \ { sumDigits($0) < sumDigits($1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpz2xx01g6.swift:16:19: error: cannot find 'sumDigits' in scope\n\
    \        let sum = sumDigits(num)\n                  ^~~~~~~~~\n/tmp/tmpz2xx01g6.swift:19:13:\
    \ error: cannot assign to value: 'max_num' is a 'let' constant\n            max_num\
    \ = num\n            ^~~~~~~\n/tmp/tmpz2xx01g6.swift:13:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let max_num = nums.first!\n    ^~~\n    var\n\
    /tmp/tmpz2xx01g6.swift:22:26: error: cannot find 'sumDigits' in scope\n    return\
    \ nums.filter({ sumDigits($0) == max_sum }).sorted(by: { sumDigits($0) < sumDigits($1)\
    \ })\n                         ^~~~~~~~~\n/tmp/tmpz2xx01g6.swift:22:67: error:\
    \ cannot find 'sumDigits' in scope\n    return nums.filter({ sumDigits($0) ==\
    \ max_sum }).sorted(by: { sumDigits($0) < sumDigits($1) })\n                 \
    \                                                 ^~~~~~~~~\n/tmp/tmpz2xx01g6.swift:22:83:\
    \ error: cannot find 'sumDigits' in scope\n    return nums.filter({ sumDigits($0)\
    \ == max_sum }).sorted(by: { sumDigits($0) < sumDigits($1) })\n              \
    \                                                                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var _sum: Int = 0\n    var minSum: Int = 100000000000000\n    var minIndex:\
    \ Int = -1\n    for value in nums {\n        let digit = value\n        _sum +=\
    \ digit\n        if _sum < minSum {\n            minSum = _sum\n            minIndex\
    \ = value\n        }\n    }\n    if minSum == 0 {\n        return nums\n    }\n\
    \n    // find all values with similar sum of digits\n    var groups = Dictionary(grouping:\
    \ nums, by: { $0.truncatingRemainder(dividingBy: 10).truncatingRemainder(dividingBy:\
    \ 10) })\n    var sortedArray = [Int]()\n    for pair in groups {\n        let\
    \ index = nums.firstIndex(of: pair)!\n        if index < minIndex {\n        \
    \    continue\n        }\n        // insert at index\n        sortedArray.insert(pair,\
    \ at: index)\n    }\n    return sortedArray\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpctuoqur9.swift:28:54: error: value of type 'Int' has no member\
    \ 'truncatingRemainder'\n    var groups = Dictionary(grouping: nums, by: { $0.truncatingRemainder(dividingBy:\
    \ 10).truncatingRemainder(dividingBy: 10) })\n                               \
    \                   ~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n    var sorted = nums.sorted()\n\
    \    for index in 0..<nums.count {\n        var sum = 0\n        var sumOfDigits\
    \ = 0\n        for n in sorted {\n            sum += n\n            sumOfDigits\
    \ += Int(Double(n))\n        }\n        if sumOfDigits == 0 {\n            sumOfDigits\
    \ = 1\n        }\n        sorted = sorted ~ (index)\n        if sumOfDigits >\
    \ sorted[0] {\n            sorted = sorted ~ (index)\n        }\n    }\n    return\
    \ sorted as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp05vci_y4.swift:26:25: error: '~' is not a binary operator\n   \
    \     sorted = sorted ~ (index)\n                        ^\n/tmp/tmp05vci_y4.swift:28:29:\
    \ error: '~' is not a binary operator\n            sorted = sorted ~ (index)\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum = nums.reduce(0, +) // 0 is the initial sum of nums\n    var i =\
    \ 0\n    while i < nums.count {\n        var digit = nums[i] % 10\n        sum\
    \ += digit\n        // if current sum greater than previous ones, swap\n     \
    \   if sum > 0 {\n            // remove first element\n            swap(&nums[i],\
    \ &nums[--nums.count])\n            // add all remaining elements\n          \
    \  while i < nums.count {\n                digit = nums[i] % 10\n            \
    \    sum += digit\n                // if current sum greater than previous ones,\
    \ swap\n                if sum > 0 {\n                    // remove first element\n\
    \                    swap(&nums[i], &nums[--nums.count])\n                }\n\
    \            }\n        } else {\n            // remove first element\n      \
    \      swap(&nums[i], &nums[--nums.count])\n        }\n    }\n    return nums\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp894s_2ny.swift:20:34: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n            swap(&nums[i], &nums[--nums.count])\n    \
    \                             ^~\n/tmp/tmp894s_2ny.swift:20:18: error: cannot\
    \ pass immutable value as inout argument: 'nums' is a 'let' constant\n       \
    \     swap(&nums[i], &nums[--nums.count])\n                 ^~~~~\n/tmp/tmp894s_2ny.swift:28:42:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \          swap(&nums[i], &nums[--nums.count])\n                             \
    \            ^~\n/tmp/tmp894s_2ny.swift:28:26: error: cannot pass immutable value\
    \ as inout argument: 'nums' is a 'let' constant\n                    swap(&nums[i],\
    \ &nums[--nums.count])\n                         ^~~~~\n/tmp/tmp894s_2ny.swift:33:34:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  swap(&nums[i], &nums[--nums.count])\n                                 ^~\n\
    /tmp/tmp894s_2ny.swift:33:18: error: cannot pass immutable value as inout argument:\
    \ 'nums' is a 'let' constant\n            swap(&nums[i], &nums[--nums.count])\n\
    \                 ^~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    \n    var numsWithPoints = nums.map { $0 + $0 }\n    \n    var pointSum =\
    \ numsWithPoints.reduce(0)\n    \n    var minPointIndex = 0\n    var maxPointIndex\
    \ = numsWithPoints.count - 1\n    \n    while pointSum > 0 {\n        if pointSum\
    \ < 10 {\n            numsWithPoints[minPointIndex] += 1\n            pointSum\
    \ -= 10\n        } else {\n            numsWithPoints[minPointIndex] += 10\n \
    \           numsWithPoints[maxPointIndex] -= 10\n            pointSum -= 10\n\
    \        }\n        minPointIndex += 1\n        maxPointIndex -= 1\n    }\n  \
    \  \n    return numsWithPoints\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpx44eafj9.swift:15:43: error: missing argument for parameter #2\
    \ in call\n    var pointSum = numsWithPoints.reduce(0)\n                     \
    \                     ^\n                                          , <#(Int, Int)\
    \ throws -> Int#>\nSwift.Sequence:2:28: note: 'reduce' declared here\n    @inlinable\
    \ public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (_\
    \ partialResult: Result, Self.Element) throws -> Result) rethrows -> Result\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var _max = UInt64(0)\n    var _min = UInt64(0)\n    var _sum = UInt64(0)\n\
    \n    if nums.isEmpty {\n        return []\n    }\n    for num in nums {\n   \
    \     let digits = num.digits\n        var dSum = UInt64(0)\n        for digit\
    \ in digits {\n            dSum += UInt64(digit)\n        }\n        if dSum !=\
    \ _sum {\n            _sum = dSum\n            _max = UInt64(0)\n            _min\
    \ = UInt64(0)\n        }\n        if dSum > _sum {\n            if dSum > _max\
    \ {\n                _max = dSum\n                _max = UInt64(digits.reduce(0)\
    \ { $0 + UInt64($1) })\n            }\n            if dSum < _min {\n        \
    \        _min = dSum\n                _min = UInt64(digits.reduce(0) { $0 + UInt64($1)\
    \ })\n            }\n        }\n    }\n    let _sorted = nums.sorted { $0.digits\
    \ > $1.digits }\n    return _sorted.map { $0.digits[_min..<_max] }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpykw6rm_8.swift:20:26: error: value of type 'Int' has no member\
    \ 'digits'\n        let digits = num.digits\n                     ~~~ ^~~~~~\n\
    /tmp/tmpykw6rm_8.swift:41:36: error: value of type 'Int' has no member 'digits'\n\
    \    let _sorted = nums.sorted { $0.digits > $1.digits }\n                   \
    \             ~~ ^~~~~~\n/tmp/tmpykw6rm_8.swift:41:48: error: value of type 'Int'\
    \ has no member 'digits'\n    let _sorted = nums.sorted { $0.digits > $1.digits\
    \ }\n                                            ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n\n    let maxSum = find_max_sum(nums)\n\
    \    if maxSum == 0 {\n        return nums\n    }\n\n    var result = nums\n \
    \   let sortedPoints = find_sorted_points(nums, maxSum)\n    for point in sortedPoints\
    \ {\n        let index = find_index(nums, point, maxSum)\n        if index !=\
    \ nil {\n            result[index!] = point\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpgoxsl9q6.swift:16:18: error: cannot find 'find_max_sum' in scope\n\
    \    let maxSum = find_max_sum(nums)\n                 ^~~~~~~~~~~~\n/tmp/tmpgoxsl9q6.swift:22:24:\
    \ error: cannot find 'find_sorted_points' in scope\n    let sortedPoints = find_sorted_points(nums,\
    \ maxSum)\n                       ^~~~~~~~~~~~~~~~~~\n/tmp/tmpgoxsl9q6.swift:24:21:\
    \ error: cannot find 'find_index' in scope\n        let index = find_index(nums,\
    \ point, maxSum)\n                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let result = nums\n        .enumerated()\n        .filter { index, value\
    \ in\n            return value.sumValue > 0 && value.sumValue < UInt32(10) ==\
    \ value.sumValue\n        }\n        .map { index, value in\n            value.sumValue\n\
    \        }\n        .sorted()\n        .map { index, value in\n            index\n\
    \        }\n        .map { value in\n            value(&result)\n        }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpgpu7pfen.swift:15:57: error: adjacent operators are in non-associative\
    \ precedence group 'ComparisonPrecedence'\n            return value.sumValue >\
    \ 0 && value.sumValue < UInt32(10) == value.sumValue\n                       \
    \                                 ^            ~~\n/tmp/tmpgpu7pfen.swift:15:26:\
    \ error: value of type 'Int' has no member 'sumValue'\n            return value.sumValue\
    \ > 0 && value.sumValue < UInt32(10) == value.sumValue\n                   ~~~~~\
    \ ^~~~~~~~\n/tmp/tmpgpu7pfen.swift:15:48: error: value of type 'Int' has no member\
    \ 'sumValue'\n            return value.sumValue > 0 && value.sumValue < UInt32(10)\
    \ == value.sumValue\n                                         ~~~~~ ^~~~~~~~\n\
    /tmp/tmpgpu7pfen.swift:15:79: error: value of type 'Int' has no member 'sumValue'\n\
    \            return value.sumValue > 0 && value.sumValue < UInt32(10) == value.sumValue\n\
    \                                                                        ~~~~~\
    \ ^~~~~~~~\n/tmp/tmpgpu7pfen.swift:18:19: error: value of type 'Int' has no member\
    \ 'sumValue'\n            value.sumValue\n            ~~~~~ ^~~~~~~~\n/tmp/tmpgpu7pfen.swift:17:10:\
    \ error: type '(_, _)' cannot conform to 'Comparable'\n        .map { index, value\
    \ in\n         ^\n/tmp/tmpgpu7pfen.swift:17:10: note: only concrete types such\
    \ as structs, enums and classes can conform to protocols\n        .map { index,\
    \ value in\n         ^\n/tmp/tmpgpu7pfen.swift:17:10: note: required by referencing\
    \ instance method 'sorted()' on 'Sequence' where 'Self.Element' = '(_, _)'\n \
    \       .map { index, value in\n         ^\n/tmp/tmpgpu7pfen.swift:21:16: error:\
    \ unable to infer type of a closure parameter 'index' in the current context\n\
    \        .map { index, value in\n               ^\n/tmp/tmpgpu7pfen.swift:21:23:\
    \ error: unable to infer type of a closure parameter 'value' in the current context\n\
    \        .map { index, value in\n                      ^\n/tmp/tmpgpu7pfen.swift:25:19:\
    \ error: cannot pass immutable value as inout argument: 'result' is a 'let' constant\n\
    \            value(&result)\n                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted { a, b in\n        let digitA = String(a).characters\n\
    \        let digitB = String(b).characters\n        var sum = 0\n        for d\
    \ in digitA {\n            sum += Int(d)!\n        }\n        for d in digitB\
    \ {\n            sum += Int(d)!\n        }\n        return sum > 0 ? 1 : -1\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpn0y5_1_8.swift:17:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            sum += Int(d)!\n           \
    \            ^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var numsWithSum = nums.map() {\n        if let num = $0 {\n            let\
    \ digits = String(num).digits\n            let sumDigits = digits.reduce(0, +)\n\
    \            return sumDigits\n        }\n        return Int64(0) // for empty\
    \ list\n    }\n    return numsWithSum.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpgx2x7yqi.swift:14:38: error: value of type 'String' has no member\
    \ 'digits'\n            let digits = String(num).digits\n                    \
    \     ~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var result = [Int]()\n    for i in nums {\n        if i == -1 {\n       \
    \     return result\n        }\n        let digits = String(i).components(separatedBy:\
    \ CharacterSet.decimalDigits.inverted).flatMap { Int($0) }\n        let sum: Int\
    \ = digits.reduce(0, +)\n        if result.contains(where: { $0 == sum }) {\n\
    \            result.sort(by: { $0 < $1 })\n        } else {\n            result.append(i)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp51yn7aqd.swift:17:56: error: cannot find 'CharacterSet' in scope\n\
    \        let digits = String(i).components(separatedBy: CharacterSet.decimalDigits.inverted).flatMap\
    \ { Int($0) }\n                                                       ^~~~~~~~~~~~\n\
    /tmp/tmp51yn7aqd.swift:17:32: error: value of type 'String' has no member 'components'\n\
    \        let digits = String(i).components(separatedBy: CharacterSet.decimalDigits.inverted).flatMap\
    \ { Int($0) }\n                     ~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return Array(nums).sorted(by: { a, b in\n        let ac = a / 10\n      \
    \  let bc = b / 10\n        if ac != bc { return ac < bc }\n        let ab = a\
    \ - ac * 10\n        return ab\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpai7p4_a4.swift:17:16: error: type 'Int' cannot be used as a boolean;\
    \ test for '!= 0' instead\n        return ab\n               ^\n             \
    \  (  != 0)\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum = 0\n    var lastSum = 0\n    for v in nums {\n        sum += v\n\
    \        lastSum = sum\n    }\n    var sorted: Array<Int> = []\n    for v in nums\
    \ {\n        var newSum = sum - v\n        if newSum == lastSum {\n          \
    \  sorted.append(v)\n        } else {\n            if newSum > lastSum { sorted.append(v)\
    \ }\n        }\n    }\n    return sorted as! [Int]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmpw7p7gleu/tmpw7p7gleu.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc86629c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc86320b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc86320988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc8631f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw7p7gleu                        0x000055e2719e25a4 <unavailable> + 5540

    5    libc.so.6                          0x00002abc86815460 __libc_start_main +
    245

    6    tmpw7p7gleu                        0x000055e2719e2189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return sorted(nums, by: sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpambadoxm.swift:12:12: error: cannot find 'sorted' in scope\n  \
    \  return sorted(nums, by: sum)\n           ^~~~~~\n/tmp/tmpambadoxm.swift:12:29:\
    \ error: cannot find 'sum' in scope\n    return sorted(nums, by: sum)\n      \
    \                      ^~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == nil {\n        return nums\n    }\n    var numsSorted = [Int]()\n\
    \    let len = nums.count\n    for i in 0..<len {\n        let digitSum = nums[i].truncatingRemainder(dividingBy:\
    \ 10)\n        switch digitSum {\n        case 0:\n            numsSorted.append(nums[i])\n\
    \        case 1:\n            numsSorted.append(nums[i])\n        case 2:\n  \
    \          numsSorted.append(nums[i])\n        case 3:\n            numsSorted.append(nums[i])\n\
    \        case 4:\n            numsSorted.append(nums[i])\n        case 5:\n  \
    \          numsSorted.append(nums[i])\n        case 6:\n            numsSorted.append(nums[i])\n\
    \        case 7:\n            numsSorted.append(nums[i])\n        case 8:\n  \
    \          numsSorted.append(nums[i])\n        case 9:\n            numsSorted.append(nums[i])\n\
    \        default:\n            numsSorted.append(nums[i])\n        }\n    }\n\
    \    return numsSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp1mhtobfi.swift:12:13: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if nums == nil {\n       ~~~~\
    \ ^  ~~~\n/tmp/tmp1mhtobfi.swift:18:32: error: value of type 'Int' has no member\
    \ 'truncatingRemainder'\n        let digitSum = nums[i].truncatingRemainder(dividingBy:\
    \ 10)\n                       ~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    func cmp(left: Int, right: Int) -> Bool {\n        let left = Int(left, radix:\
    \ 10)\n        let right = Int(right, radix: 10)\n        let sum = left + right\n\
    \        return sum < 0 ? true : sum == 0 ? false : left < right\n    }\n    return\
    \ nums.sorted(by: cmp)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpaj4rp8jv.swift:13:20: error: initializer 'init(_:radix:)' requires\
    \ that 'Int' conform to 'StringProtocol'\n        let left = Int(left, radix:\
    \ 10)\n                   ^\nSwift.FixedWidthInteger:2:23: note: where 'S' = 'Int'\n\
    \    @inlinable public init?<S>(_ text: S, radix: Int = 10) where S : StringProtocol\n\
    \                      ^\n/tmp/tmpaj4rp8jv.swift:14:21: error: initializer 'init(_:radix:)'\
    \ requires that 'Int' conform to 'StringProtocol'\n        let right = Int(right,\
    \ radix: 10)\n                    ^\nSwift.FixedWidthInteger:2:23: note: where\
    \ 'S' = 'Int'\n    @inlinable public init?<S>(_ text: S, radix: Int = 10) where\
    \ S : StringProtocol\n                      ^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let numsSum = nums.reduce(0, +)\n    return nums.sorted()\n        .sorted(by:\
    \ { $0.0 % 10 > $1.0 % 10 || ($0.0 < $1.0 && $0.0 < numsSum) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpobykh2bj.swift:14:26: error: value of type 'Int' has no member\
    \ '0'\n        .sorted(by: { $0.0 % 10 > $1.0 % 10 || ($0.0 < $1.0 && $0.0 < numsSum)\
    \ })\n                      ~~ ^\n/tmp/tmpobykh2bj.swift:14:38: error: value of\
    \ type 'Int' has no member '0'\n        .sorted(by: { $0.0 % 10 > $1.0 % 10 ||\
    \ ($0.0 < $1.0 && $0.0 < numsSum) })\n                                  ~~ ^\n\
    /tmp/tmpobykh2bj.swift:14:52: error: value of type 'Int' has no member '0'\n \
    \       .sorted(by: { $0.0 % 10 > $1.0 % 10 || ($0.0 < $1.0 && $0.0 < numsSum)\
    \ })\n                                                ~~ ^\n/tmp/tmpobykh2bj.swift:14:59:\
    \ error: value of type 'Int' has no member '0'\n        .sorted(by: { $0.0 % 10\
    \ > $1.0 % 10 || ($0.0 < $1.0 && $0.0 < numsSum) })\n                        \
    \                               ~~ ^\n/tmp/tmpobykh2bj.swift:14:67: error: value\
    \ of type 'Int' has no member '0'\n        .sorted(by: { $0.0 % 10 > $1.0 % 10\
    \ || ($0.0 < $1.0 && $0.0 < numsSum) })\n                                    \
    \                           ~~ ^\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sortedNums = [Int]()\n    var seenDigits = [Int]()\n    \n    for n in\
    \ nums {\n        seenDigits.append(0)\n    }\n    \n    for n in nums {\n   \
    \     for d in n / 10 {\n            if let idx = seenDigits.index(of: d) {\n\
    \                sortedNums[idx] += n\n            }\n        }\n    }\n    \n\
    \    return sortedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmphoa0pjoz.swift:20:20: error: for-in loop requires 'Int' to conform\
    \ to 'Sequence'\n        for d in n / 10 {\n                 ~~^~~~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  guard !nums.isEmpty else {\n    return []\n  }\n  // nums is [Int], so get\
    \ its first element and make it an Int.\n  let x = nums.first!\n  var sum = 0\n\
    \  for y in nums {\n    if y > 0 {\n      sum += y * 10\n    }\n  }\n  var result\
    \ = [Int]()\n  var index = nums.startIndex\n  for num in nums {\n    if num >\
    \ 0 {\n      result.append(index)\n    }\n    sum += num * 10\n    index++\n \
    \ }\n  // If sum is positive, sort based on its digits;\n  // otherwise, sort\
    \ based on its original order.\n  if sum > 0 {\n    result = result.sorted()\n\
    \  } else {\n    result = result.sorted{ $0 < $1 }\n  }\n  return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpy3ju6251.swift:30:10: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n    index++\n         ^~\n"
  stdout: ''
  timestamp: 1660009441
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: ascending_digits)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpabjetl49.swift:12:28: error: cannot find 'ascending_digits' in\
    \ scope\n    return nums.sorted(by: ascending_digits)\n                      \
    \     ^~~~~~~~~~~~~~~~\n/tmp/tmpabjetl49.swift:12:28: error: converting non-escaping\
    \ value to '(Int, Int) throws -> Bool' may allow it to escape\n    return nums.sorted(by:\
    \ ascending_digits)\n                           ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty() {\n        return []\n    }\n    // get sum of digits in\
    \ nums, set max sum as 9\n    let maxSum: Int = nums.reduce(0, {$0 + $1 })\n \
    \   // sort nums based on sum of digits\n    let orderedNums = nums.sorted{ $0.reduce(0,\
    \ {$0 + $1})  > $1.reduce(0, {$0 + $1})  }\n    // map original num to ordered\
    \ num\n    let resultNums = orderedNums.map { num in\n        return nums.indexOf(num)\
    \ * maxSum + num\n    }\n    return resultNums\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpig_pyt74.swift:12:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpig_pyt74.swift:18:39: error: value of type 'Int' has no member\
    \ 'reduce'\n    let orderedNums = nums.sorted{ $0.reduce(0, {$0 + $1})  > $1.reduce(0,\
    \ {$0 + $1})  }\n                                   ~~ ^~~~~~\n/tmp/tmpig_pyt74.swift:18:66:\
    \ error: value of type 'Int' has no member 'reduce'\n    let orderedNums = nums.sorted{\
    \ $0.reduce(0, {$0 + $1})  > $1.reduce(0, {$0 + $1})  }\n                    \
    \                                          ~~ ^~~~~~\n/tmp/tmpig_pyt74.swift:21:21:\
    \ error: value of type '[Int]' has no member 'indexOf'\n        return nums.indexOf(num)\
    \ * maxSum + num\n               ~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009555
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sorted = [Int]()\n    var prev = 0\n    var curr = 0\n    for v in nums\
    \ {\n        curr = (prev * 10) + v\n        prev = int(curr)\n        if sorted.contains(prev)\
    \ {\n            sorted.remove(prev)\n            sorted.append(prev)\n      \
    \  } else {\n            sorted.append(prev)\n        }\n    }\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpb6h5rjs2.swift:17:16: error: cannot find 'int' in scope\n     \
    \   prev = int(curr)\n               ^~~\n/tmp/tmpb6h5rjs2.swift:19:20: error:\
    \ no exact matches in call to instance method 'remove'\n            sorted.remove(prev)\n\
    \                   ^\nSwift.Array:10:37: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(at:)')\n    @inlinable public mutating func remove(at\
    \ index: Int) -> Element\n                                    ^\nSwift.RangeReplaceableCollection:9:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(at:)')\n   \
    \ @inlinable public mutating func remove(at position: Self.Index) -> Self.Element\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  guard let nums0 = nums as? [Int] else { return [] }\n  let sorted: [[Int]]\
    \ = []\n  while let first = nums0.first {\n    let rest = nums0.dropFirst()\n\
    \    let first = Int(first)\n    var found = false\n    for rest in rest {\n \
    \     found = found || (rest >= first)\n    }\n    if !found {\n      sorted.append([first])\n\
    \    }\n  }\n  var last = 0\n  for nums in sorted {\n    if nums.last > last {\n\
    \      last = nums.last\n    }\n  }\n  let newNums0 = nums0.map { Int($0) }\n\
    \  var newNums = nums0.map { $0 }\n  for newNums in sorted {\n    newNums += last\n\
    \  }\n  return newNums0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpi9sbsm4k.swift:12:26: warning: conditional cast from '[Int]' to\
    \ '[Int]' always succeeds\n  guard let nums0 = nums as? [Int] else { return []\
    \ }\n                         ^\n/tmp/tmpi9sbsm4k.swift:22:14: error: cannot use\
    \ mutating member on immutable value: 'sorted' is a 'let' constant\n      sorted.append([first])\n\
    \      ~~~~~~ ^\n/tmp/tmpi9sbsm4k.swift:13:3: note: change 'let' to 'var' to make\
    \ it mutable\n  let sorted: [[Int]] = []\n  ^~~\n  var\n/tmp/tmpi9sbsm4k.swift:27:13:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if nums.last > last {\n            ^\n/tmp/tmpi9sbsm4k.swift:27:13: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    if nums.last > last {\n            ^\n                 ?? <#default value#>\n\
    /tmp/tmpi9sbsm4k.swift:27:13: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    if nums.last > last {\n          \
    \  ^\n                !\n/tmp/tmpi9sbsm4k.swift:28:19: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n      last = nums.last\n\
    \                  ^\n/tmp/tmpi9sbsm4k.swift:28:19: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n      last = nums.last\n\
    \                  ^\n                       ?? <#default value#>\n/tmp/tmpi9sbsm4k.swift:28:19:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n      last = nums.last\n                  ^\n                      !\n\
    /tmp/tmpi9sbsm4k.swift:34:5: error: cannot convert value of type '[Int]' to expected\
    \ argument type 'Int'\n    newNums += last\n    ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    // create new array for output\n    var numsSorted = nums.sorted()\n\n  \
    \  // initialize a variable to hold the sum of the digits\n    var sumOfDigits\
    \ = 0\n\n    // for each element in the input\n    for i in numsSorted {\n   \
    \     // add its digits to our sum so far\n        sumOfDigits += Int(i)\n\n \
    \       // if the sum is more than 10, this means we have a new item\n       \
    \ // we need to check for\n        if sumOfDigits > 10 {\n            // save\
    \ the index of the new item\n            let index = numsSorted.index{$0 > i}\n\
    \n            // add the new item to the output\n            numsSorted.insert(numsSorted[index],\
    \ at: index)\n            sumOfDigits -= 10\n        }\n    }\n    return numsSorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpkc4dpgmo.swift:27:36: warning: 'index(where:)' is deprecated: renamed\
    \ to 'firstIndex(where:)'\n            let index = numsSorted.index{$0 > i}\n\
    \                                   ^\n/tmp/tmpkc4dpgmo.swift:27:36: note: use\
    \ 'firstIndex(where:)' instead\n            let index = numsSorted.index{$0 >\
    \ i}\n                                   ^~~~~\n                             \
    \      firstIndex\n/tmp/tmpkc4dpgmo.swift:30:54: error: value of optional type\
    \ 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value of type\
    \ 'Array<Int>.Index' (aka 'Int')\n            numsSorted.insert(numsSorted[index],\
    \ at: index)\n                                                     ^\n/tmp/tmpkc4dpgmo.swift:30:54:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            numsSorted.insert(numsSorted[index], at: index)\n       \
    \                                              ^\n                           \
    \                                ?? <#default value#>\n/tmp/tmpkc4dpgmo.swift:30:54:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            numsSorted.insert(numsSorted[index], at: index)\n       \
    \                                              ^\n                           \
    \                               !\n/tmp/tmpkc4dpgmo.swift:30:42: error: value\
    \ of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped\
    \ to a value of type 'Array<Int>.Index' (aka 'Int')\n            numsSorted.insert(numsSorted[index],\
    \ at: index)\n                                         ^\n/tmp/tmpkc4dpgmo.swift:30:42:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            numsSorted.insert(numsSorted[index], at: index)\n       \
    \                                  ^\n                                       \
    \        ?? <#default value#>\n/tmp/tmpkc4dpgmo.swift:30:42: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    numsSorted.insert(numsSorted[index], at: index)\n                       \
    \           "
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n    let len = nums.count\n\
    \    let sortedPoints = (0..<len).sorted { nums[$0] > nums[$1] }\n    var res\
    \ = nums.sorted()\n    for index in sortedPoints {\n        let tmp = res[index]\n\
    \        res[index] = res[sortedPoints[index]]\n        res[sortedPoints[index]]\
    \ = tmp\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmppwbzugo0/tmppwbzugo0.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9ee8efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9ee5e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9ee5e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9ee5e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppwbzugo0                        0x0000564fbf37e914 <unavailable> + 6420

    5    libc.so.6                          0x00002ab9eeadb460 __libc_start_main +
    245

    6    tmppwbzugo0                        0x0000564fbf37e4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty { return nums }\n    var totals = nums.reduce(into: [Int:\
    \ Int](), { $0[$1] = $0 + $1 })\n    var ordered = nums.sorted { $0 + $1 == totals[$0]!\
    \ }\n    return ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpxhw4fstp.swift:13:61: error: cannot convert value of type '[Int\
    \ : Int]' to expected argument type 'Int'\n    var totals = nums.reduce(into:\
    \ [Int: Int](), { $0[$1] = $0 + $1 })\n                                      \
    \                      ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var results = [Int]()\n    var remainder = 0\n    var sum = 0\n    for num\
    \ in nums {\n        sum += num\n        remainder = sum % 10\n        results.append(remainder)\n\
    \        sum -= remainder\n    }\n    return results\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmp0aiuen7x/tmp0aiuen7x.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf5b4e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf5b1ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf5b1dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf5b1dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0aiuen7x                        0x0000564fca90b694 <unavailable> + 5780

    5    libc.so.6                          0x00002acf5b6d2460 __libc_start_main +
    245

    6    tmp0aiuen7x                        0x0000564fca90b279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted() { $0.digits.sum < $1.digits.sum }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpc3soe82f.swift:12:31: error: value of type 'Int' has no member\
    \ 'digits'\n    return nums.sorted() { $0.digits.sum < $1.digits.sum }\n     \
    \                      ~~ ^~~~~~\n/tmp/tmpc3soe82f.swift:12:47: error: value of\
    \ type 'Int' has no member 'digits'\n    return nums.sorted() { $0.digits.sum\
    \ < $1.digits.sum }\n                                           ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let len = nums.count\n    let digits = (0..<len).map { Int($0) / 10 }\n \
    \   var sum = 0\n    for d in digits {\n        sum += d\n    }\n    var ordered\
    \ = nums.sorted()\n    if sum > 0 {\n        var i = 0\n        while i < ordered.count\
    \ {\n            if nums[i] != ordered[i] + nums[i] {\n                let j =\
    \ i\n                while j < ordered.count && ordered[j] == ordered[i] + nums[i]\
    \ {\n                    j += 1\n                }\n                ordered =\
    \ ordered[i..<j]\n                break\n            }\n            i += 1\n \
    \       }\n    }\n    return ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmppmypexzw.swift:25:23: error: left side of mutating operator isn't\
    \ mutable: 'j' is a 'let' constant\n                    j += 1\n             \
    \       ~ ^\n/tmp/tmppmypexzw.swift:23:17: note: change 'let' to 'var' to make\
    \ it mutable\n                let j = i\n                ^~~\n               \
    \ var\n/tmp/tmppmypexzw.swift:27:34: error: cannot assign value of type 'ArraySlice<Int>'\
    \ to type '[Int]'\n                ordered = ordered[i..<j]\n                \
    \          ~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var result = [Int]()\n    var idx = 0\n    let sum = nums.reduce(0) { $0\
    \ + $1 }\n    while idx < nums.count {\n        if let idx = idx+1 where sum >\
    \ nums[idx] {\n            result.append(nums[idx])\n        }\n        idx +=\
    \ 1\n    }\n    if nums.isEmpty {\n        return result\n    }\n    return result.sorted()\
    \ {\n        let a = $0\n        let b = $1\n        return a > b ? true : (b\
    \ == sum)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpkoaspq2f.swift:16:28: error: expected ',' joining parts of a multi-clause\
    \ condition\n        if let idx = idx+1 where sum > nums[idx] {\n            \
    \              ~^~~~~\n                          ,\n/tmp/tmpkoaspq2f.swift:16:12:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \        if let idx = idx+1 where sum > nums[idx] {\n           ^         ~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let numsSorted = nums\n        .sorted(by: { $0.digits.sum() < $1.digits.sum()\
    \ })\n        .sorted(by: { $0.index < $1.index })\n    return numsSorted.map\
    \ { $0.index }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmplw9bf742.swift:13:26: error: value of type 'Int' has no member\
    \ 'digits'\n        .sorted(by: { $0.digits.sum() < $1.digits.sum() })\n     \
    \                 ~~ ^~~~~~\n/tmp/tmplw9bf742.swift:13:44: error: value of type\
    \ 'Int' has no member 'digits'\n        .sorted(by: { $0.digits.sum() < $1.digits.sum()\
    \ })\n                                        ~~ ^~~~~~\n/tmp/tmplw9bf742.swift:14:26:\
    \ error: value of type 'Int' has no member 'index'\n        .sorted(by: { $0.index\
    \ < $1.index })\n                      ~~ ^~~~~\n/tmp/tmplw9bf742.swift:14:37:\
    \ error: value of type 'Int' has no member 'index'\n        .sorted(by: { $0.index\
    \ < $1.index })\n                                 ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var result = [Int]()\n    \n    var sum = 0\n    for n in nums {\n      \
    \  sum += n\n    }\n    \n    for n in nums {\n        let index = nums.index\
    \ {$0 + n == sum}\n        if index < result.count {\n            result[index]\
    \ = n\n        } else {\n            result.insert(n, at: result.count - 1)\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpq7kip71z.swift:20:26: warning: 'index(where:)' is deprecated: renamed\
    \ to 'firstIndex(where:)'\n        let index = nums.index {$0 + n == sum}\n  \
    \                       ^\n/tmp/tmpq7kip71z.swift:20:26: note: use 'firstIndex(where:)'\
    \ instead\n        let index = nums.index {$0 + n == sum}\n                  \
    \       ^~~~~\n                         firstIndex\n/tmp/tmpq7kip71z.swift:21:12:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n        if index\
    \ < result.count {\n           ^\n/tmp/tmpq7kip71z.swift:21:12: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if index < result.count {\n           ^\n                 ?? <#default value#>\n\
    /tmp/tmpq7kip71z.swift:21:12: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if index < result.count {\n  \
    \         ^\n                !\n/tmp/tmpq7kip71z.swift:22:20: error: value of\
    \ optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to\
    \ a value of type 'Array<Int>.Index' (aka 'Int')\n            result[index] =\
    \ n\n                   ^\n/tmp/tmpq7kip71z.swift:22:20: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   result[index] = n\n                   ^\n                         ?? <#default\
    \ value#>\n/tmp/tmpq7kip71z.swift:22:20: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            result[index] =\
    \ n\n                   ^\n                        !\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  if nums.isEmpty {\n    return nums\n  }\n  var sums = nums.map { $0.reduce\
    \ { 0, +$0 } }\n  return nums.sorted { sums[$0] < sums[$1] }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpli2pej_e.swift:15:38: error: consecutive statements on a line must\
    \ be separated by ';'\n  var sums = nums.map { $0.reduce { 0, +$0 } }\n      \
    \                               ^\n                                     ;\n/tmp/tmpli2pej_e.swift:15:38:\
    \ error: expected expression\n  var sums = nums.map { $0.reduce { 0, +$0 } }\n\
    \                                     ^\n/tmp/tmpli2pej_e.swift:15:28: error:\
    \ value of type 'Int' has no member 'reduce'\n  var sums = nums.map { $0.reduce\
    \ { 0, +$0 } }\n                        ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  guard !nums.isEmpty else { return nums }\n  var res = [Int]()\n  var lastSum\
    \ = nums.reduce(0, { $0 + Int($1) })\n  for i in 0..<nums.count {\n    let thisSum\
    \ = nums[i] + lastSum\n    guard lastSum >= thisSum else { return nums }\n   \
    \ res.append(thisSum)\n    lastSum -= thisSum\n  }\n  return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmp06ges6ut/tmp06ges6ut.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad36fd0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad36fa04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad36fa04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad36fa037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp06ges6ut                        0x000055791d065914 <unavailable> + 6420

    5    libc.so.6                          0x00002ad36fef9460 __libc_start_main +
    245

    6    tmp06ges6ut                        0x000055791d0654f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpwxgpglvr/tmpwxgpglvr.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a48968c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a4865fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a4865f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a4865e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxgpglvr                        0x0000561eab4463e4 <unavailable> + 5092

    5    libc.so.6                          0x00002b8a48b54460 __libc_start_main +
    245

    6    tmpwxgpglvr                        0x0000561eab445fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    switch nums.count {\n    case 0:\n        return nums\n    case 1:\n    \
    \    return nums as [Int]\n    default:\n        let sum = nums.reduce(0, {$0\
    \ + $1})\n        var sorted_nums = [Int]()\n        for num in nums {\n     \
    \       if num < 0 {\n                num *= -1\n            }\n            let\
    \ digit = num % 10\n            let index = sum % len(nums)\n            if sum\
    \ >= digit*len(nums) {\n                index = nums.count - index\n         \
    \   }\n            if index < 0 {\n                index += nums.count\n     \
    \       }\n            sum += digit*len(nums)\n            sorted_nums.append(nums[index])\n\
    \        }\n        return sorted_nums\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpt5ufjxrw.swift:22:21: error: left side of mutating operator isn't\
    \ mutable: 'num' is a 'let' constant\n                num *= -1\n            \
    \    ~~~ ^\n/tmp/tmpt5ufjxrw.swift:25:31: error: cannot find 'len' in scope\n\
    \            let index = sum % len(nums)\n                              ^~~\n\
    /tmp/tmpt5ufjxrw.swift:26:29: error: cannot find 'len' in scope\n            if\
    \ sum >= digit*len(nums) {\n                            ^~~\n/tmp/tmpt5ufjxrw.swift:32:26:\
    \ error: cannot find 'len' in scope\n            sum += digit*len(nums)\n    \
    \                     ^~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let nums_sorted = nums.sorted()\n    return nums_sorted.map { $0.digits.reduce(0,\
    \ +) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpwil9_fut.swift:13:33: error: value of type 'Int' has no member\
    \ 'digits'\n    return nums_sorted.map { $0.digits.reduce(0, +) }\n          \
    \                   ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var index = 0\n    var sum = nums[0]\n    for num in nums {\n        if num\
    \ >= 0 {\n            sum += num\n        }\n        if index == 0 {\n       \
    \     index = num\n        } else {\n            if sum > num {\n            \
    \    index--\n            }\n        }\n    }\n    var result = nums\n    if index\
    \ > 0 {\n        result = Array(0..<index).map() { i -> Int in\n            let\
    \ num1 = result[i]\n            let num2 = nums[i]\n            return num1 >\
    \ num2 ? num1 : num2\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpzbvugt5c.swift:22:22: error: cannot find operator '--' in scope;\
    \ did you mean '-= 1'?\n                index--\n                     ^~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sums = nums.map({ $0.reduce(0) })\n    return nums.sorted(by: { sums[$0]\
    \ > sums[$1] }) ?? []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmphf27v22d.swift:12:30: error: value of type 'Int' has no member\
    \ 'reduce'\n    let sums = nums.map({ $0.reduce(0) })\n                      \
    \    ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard !nums.isEmpty else { return nums }\n    let sorted = nums.sorted {\
    \ $0.digit > $1.digit }\n    return sorted.map{ $0.index }.sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpu4ugrg3i.swift:13:35: error: value of type 'Int' has no member\
    \ 'digit'\n    let sorted = nums.sorted { $0.digit > $1.digit }\n            \
    \                   ~~ ^~~~~\n/tmp/tmpu4ugrg3i.swift:13:46: error: value of type\
    \ 'Int' has no member 'digit'\n    let sorted = nums.sorted { $0.digit > $1.digit\
    \ }\n                                          ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var numsSorted = nums.sorted(by: { $0.adding($1).isOver })\n    if nums.isEmpty()\
    \ {\n        numsSorted = []\n    }\n    return numsSorted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp_0y27f9d.swift:12:43: error: value of type 'Int' has no member\
    \ 'adding'\n    var numsSorted = nums.sorted(by: { $0.adding($1).isOver })\n \
    \                                      ~~ ^~~~~~\n/tmp/tmp_0y27f9d.swift:13:13:\
    \ error: cannot call value of non-function type 'Bool'\n    if nums.isEmpty()\
    \ {\n            ^      ~~\n                   \n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let map = countMap(nums)\n    var sorted = nums\n    for point in sorted\
    \ {\n        if let index = map?[point] {\n            sorted.insert(point, at:\
    \ index)\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp7rfsqnca.swift:12:15: error: cannot find 'countMap' in scope\n\
    \    let map = countMap(nums)\n              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let nums_sorted: [Int] = nums.sorted()\n    var sum = 0\n    var index: Int\
    \ = 0\n    while index < nums.count {\n        sum += nums[index]\n        while\
    \ sum >= 10 {\n            nums_sorted.append(nums[index])\n            sum -=\
    \ nums[index]\n            index += 1\n        }\n    }\n    return nums_sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpwv9bxbgw.swift:18:25: error: cannot use mutating member on immutable\
    \ value: 'nums_sorted' is a 'let' constant\n            nums_sorted.append(nums[index])\n\
    \            ~~~~~~~~~~~ ^\n/tmp/tmpwv9bxbgw.swift:12:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let nums_sorted: [Int] = nums.sorted()\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let numsSorted = nums.sorted(by: { $0.isOdd! + $1.isOdd! })\n    return numsSorted.first!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpt48rz2k3.swift:12:43: error: value of type 'Int' has no member\
    \ 'isOdd'\n    let numsSorted = nums.sorted(by: { $0.isOdd! + $1.isOdd! })\n \
    \                                      ~~ ^~~~~\n/tmp/tmpt48rz2k3.swift:12:55:\
    \ error: value of type 'Int' has no member 'isOdd'\n    let numsSorted = nums.sorted(by:\
    \ { $0.isOdd! + $1.isOdd! })\n                                               \
    \    ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var res = nums\n    if nums.isEmpty {\n        return res\n    }\n    var\
    \ curSum = nums[0]\n    for cur in 1..<res.count {\n        var isSmaller = false\n\
    \        for prev in 0..<cur {\n            if res[prev] > res[cur] {\n      \
    \          isSmaller = true\n                break\n            }\n        }\n\
    \        if !isSmaller {\n            curSum += res[cur]\n            res[cur]\
    \ = curSum\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmpcwt5zlu8/tmpcwt5zlu8.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fb6dbdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fb6ab4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fb6ab4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fb6ab37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcwt5zlu8                        0x000055c8f8464704 <unavailable> + 5892

    5    libc.so.6                          0x00002b0fb6fa9460 __libc_start_main +
    245

    6    tmpcwt5zlu8                        0x000055c8f84642e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum = nums.reduce(0, { $0 + $1 })\n    var sums = Array(repeating: 0,\
    \ count: 10)\n    for i in 0..<10 { sums[i] = nums.reduce(0, { $0 + $1 ** (Int(i)\
    \ / Int(10)) }) }\n    return nums.indices.flatMap { i -> [Int] in\n        guard\
    \ sum >= sums[i] else { return [] }\n        return nums[nums.index(after: i)..<nums.index(after:\
    \ i)+1]\n            .sorted()\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp2avuaosj.swift:14:58: error: cannot find operator '**' in scope\n\
    \    for i in 0..<10 { sums[i] = nums.reduce(0, { $0 + $1 ** (Int(i) / Int(10))\
    \ }) }\n                                                         ^~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return nums.sorted(by: {\n    let sum = Int($0 + $1)\n    if sum == 0 {\n \
    \     return false\n    }\n    if sum < 0 {\n      return true\n    }\n    return\
    \ false\n  })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpogre1v2q/tmpogre1v2q.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b39ac4d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b39ac1cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b39ac1cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b39ac1cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpogre1v2q                        0x00005589a6727594 <unavailable> + 5524

    5    libc.so.6                          0x00002b39ac6c2460 __libc_start_main +
    245

    6    tmpogre1v2q                        0x00005589a6727179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum: Int = 0\n    for element in nums {\n        sum += element\n   \
    \ }\n    return nums.sorted { a, b in\n        sum.compare(b.sum) < 0\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmptb0mwhf7.swift:17:13: error: value of type 'Int' has no member\
    \ 'compare'\n        sum.compare(b.sum) < 0\n        ~~~ ^~~~~~~\n/tmp/tmptb0mwhf7.swift:17:23:\
    \ error: value of type 'Int' has no member 'sum'\n        sum.compare(b.sum) <\
    \ 0\n                    ~ ^~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum = 0\n    let len = nums.count\n    var result = [Int](repeating:\
    \ 0, count: len)\n    for i in 0..<len {\n        sum += nums[i]\n        result[i]\
    \ = sum % 10\n        sum = sum / 10\n    }\n    result.reverse()\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpml4jmdmq/tmpml4jmdmq.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acaee422c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acaee119b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acaee119988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acaee1187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpml4jmdmq                        0x000055f7b57bd7b4 <unavailable> + 6068

    5    libc.so.6                          0x00002acaee60e460 __libc_start_main +
    245

    6    tmpml4jmdmq                        0x000055f7b57bd399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    switch nums.count {\n    case 0:\n        return nums\n    case 1:\n    \
    \    return nums + [0]\n    case 2:\n        let first = nums[0]\n        let\
    \ second = nums[1]\n        if first < second {\n            return nums\n   \
    \     }\n        return nums + [first - second] + [1]\n    case 3:\n        let\
    \ first = nums[0]\n        let second = nums[1]\n        let third = nums[2]\n\
    \        if first < second && second < third {\n            return nums\n    \
    \    }\n        return nums + [first - second] + [second - third] + [0]\n    default:\n\
    \        let first = nums[0]\n        let second = nums[1]\n        let third\
    \ = nums[2]\n        let fourth = nums[3]\n        if first < second && second\
    \ < third\n            && third < fourth {\n            return nums\n        }\n\
    \        return nums + [first - second] + [second - third] + [third - fourth]\
    \ + [0]\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpwpw2b9dh/tmpwpw2b9dh.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53b0ffec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53b0cf5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53b0cf5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53b0cf47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwpw2b9dh                        0x000055e031b484f4 <unavailable> + 5364

    5    libc.so.6                          0x00002b53b11ea460 __libc_start_main +
    245

    6    tmpwpw2b9dh                        0x000055e031b480d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660009444
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: >)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmp3p_plyry/tmp3p_plyry.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46bd69dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46bd394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46bd394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46bd3937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3p_plyry                        0x0000557ad17ed454 <unavailable> + 5204

    5    libc.so.6                          0x00002b46bd889460 __libc_start_main +
    245

    6    tmp3p_plyry                        0x0000557ad17ed039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return sort_by_points_in_ascending_order(nums)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpbdueuobw.swift:12:12: error: cannot find 'sort_by_points_in_ascending_order'\
    \ in scope\n    return sort_by_points_in_ascending_order(nums)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let digitSum = nums.reduce(0, +) // sum of digits\n    return nums.sorted\
    \ { a, b in\n        let digitDifference = digitSum - digitSum(a) - digitSum(b)\n\
    \        return digitDifference > 0 ? 1 : 0\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp3x_1qsxp.swift:14:42: error: cannot call value of non-function\
    \ type 'Int'\n        let digitDifference = digitSum - digitSum(a) - digitSum(b)\n\
    \                                         ^\n/tmp/tmp3x_1qsxp.swift:14:56: error:\
    \ cannot call value of non-function type 'Int'\n        let digitDifference =\
    \ digitSum - digitSum(a) - digitSum(b)\n                                     \
    \                  ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  if nums.isEmpty {\n    return nums\n  }\n  var ordered: [[Int]] = nums\n  ordered.sort(by:\
    \ { (n1, n2) -> Bool in\n    let n1Sum = sumDigits(n1)\n    let n2Sum = sumDigits(n2)\n\
    \    if n1Sum > n2Sum { return false }\n    if n1Sum < n2Sum { return true }\n\
    \    return ordered.indexOf(where: { $0 == n1 }) != ordered.indexOf(where: { $0\
    \ == n2 })\n  })\n  return ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp581569wm.swift:15:26: error: cannot assign value of type '[Int]'\
    \ to type '[[Int]]'\n  var ordered: [[Int]] = nums\n                         ^\n\
    /tmp/tmp581569wm.swift:15:26: note: arguments to generic parameter 'Element' ('Int'\
    \ and '[Int]') are expected to be equal\n  var ordered: [[Int]] = nums\n     \
    \                    ^\n/tmp/tmp581569wm.swift:17:17: error: cannot find 'sumDigits'\
    \ in scope\n    let n1Sum = sumDigits(n1)\n                ^~~~~~~~~\n/tmp/tmp581569wm.swift:18:17:\
    \ error: cannot find 'sumDigits' in scope\n    let n2Sum = sumDigits(n2)\n   \
    \             ^~~~~~~~~\n/tmp/tmp581569wm.swift:23:10: error: cannot convert return\
    \ expression of type '[[Int]]' to return type '[Int]'\n  return ordered\n    \
    \     ^\n/tmp/tmp581569wm.swift:23:10: note: arguments to generic parameter 'Element'\
    \ ('[Int]' and 'Int') are expected to be equal\n  return ordered\n         ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sum = nums.reduce(0, +)\n    if sum > 0 {\n        nums.sort(by: { sum\
    \ - $0 })\n    } else {\n        nums.sort(by: { $0 - sum })\n    }\n    return\
    \ nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpbz6y467y.swift:14:23: error: contextual closure type '(Int, Int)\
    \ throws -> Bool' expects 2 arguments, but 1 was used in closure body\n      \
    \  nums.sort(by: { sum - $0 })\n                      ^\n/tmp/tmpbz6y467y.swift:14:14:\
    \ error: cannot use mutating member on immutable value: 'nums' is a 'let' constant\n\
    \        nums.sort(by: { sum - $0 })\n        ~~~~ ^\n/tmp/tmpbz6y467y.swift:14:29:\
    \ error: cannot convert value of type 'Int' to closure result type 'Bool'\n  \
    \      nums.sort(by: { sum - $0 })\n                        ~~~~^~~~\n/tmp/tmpbz6y467y.swift:16:14:\
    \ error: cannot use mutating member on immutable value: 'nums' is a 'let' constant\n\
    \        nums.sort(by: { $0 - sum })\n        ~~~~ ^\n/tmp/tmpbz6y467y.swift:16:23:\
    \ error: contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments,\
    \ but 1 was used in closure body\n        nums.sort(by: { $0 - sum })\n      \
    \                ^\n/tmp/tmpbz6y467y.swift:16:28: error: cannot convert value\
    \ of type 'Int' to closure result type 'Bool'\n        nums.sort(by: { $0 - sum\
    \ })\n                        ~~~^~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum = 0\n    var result = [Int]()\n    for n in nums {\n        let digit\
    \ = n % 10\n        sum += digit\n        switch digit {\n        case 0: result.append(n);\
    \ break\n        case 1: result.append(n + sum); break\n        case 2: result.append(n\
    \ + sum + 9); break\n        case 3: result.append(n + sum + 9 + 9); break\n \
    \       case 4: result.append(n + sum + 9 + 9 + 9); break\n        case 5: result.append(n\
    \ + sum + 9 + 9 + 9 + 9); break\n        case 6: result.append(n + sum + 9 + 9\
    \ + 9 + 9 + 9); break\n        case 7: result.append(n + sum + 9 + 9 + 9 + 9 +\
    \ 9 + 9); break\n        case 8: result.append(n + sum + 9 + 9 + 9 + 9 + 9 + 9\
    \ + 9); break\n        case 9: result.append(n + sum + 9 + 9 + 9 + 9 + 9 + 9 +\
    \ 9 + 9); break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpfke_ipfs.swift:17:9: error: switch must be exhaustive\n       \
    \ switch digit {\n        ^\n/tmp/tmpfke_ipfs.swift:17:9: note: do you want to\
    \ add a default clause?\n        switch digit {\n        ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted().map { $0.description.debugDescription }.sorted()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpu5ouoz59.swift:12:47: error: cannot convert value of type 'String'\
    \ to closure result type 'Int'\n    return nums.sorted().map { $0.description.debugDescription\
    \ }.sorted()\n                               ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n\n    let mut sorted_idxs\
    \ = nums.enumerated().sorted()\n    let mut sorted_sums = nums.enumerated().map(|(i,_)|\
    \ nums[i]).sorted()\n\n    if sorted_sums.last == 0 { sorted_idxs = sorted_idxs.reverse()\
    \ }\n\n    for i in 0..<sorted_idxs.count {\n        if sorted_idxs[i].1 != i\
    \ {\n            sorted_sums[i] += sorted_sums[i+1]\n            sorted_sums[i+1]\
    \ = 0\n        }\n    }\n\n    for i in 0..<sorted_idxs.count {\n        nums[sorted_idxs[i].0]\
    \ += sorted_sums[i]\n    }\n\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpjmyt57p8.swift:16:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut sorted_idxs\
    \ = nums.enumerated().sorted()\n            ^\n/tmp/tmpjmyt57p8.swift:16:13: note:\
    \ join the identifiers together\n    let mut sorted_idxs = nums.enumerated().sorted()\n\
    \        ~~~~^~~~~~~~~~~\n        mutsorted_idxs\n/tmp/tmpjmyt57p8.swift:16:13:\
    \ note: join the identifiers together with camel-case\n    let mut sorted_idxs\
    \ = nums.enumerated().sorted()\n        ~~~~^~~~~~~~~~~\n        mutSorted_idxs\n\
    /tmp/tmpjmyt57p8.swift:17:13: error: found an unexpected second identifier in\
    \ constant declaration; is there an accidental break?\n    let mut sorted_sums\
    \ = nums.enumerated().map(|(i,_)| nums[i]).sorted()\n            ^\n/tmp/tmpjmyt57p8.swift:17:13:\
    \ note: join the identifiers together\n    let mut sorted_sums = nums.enumerated().map(|(i,_)|\
    \ nums[i]).sorted()\n        ~~~~^~~~~~~~~~~\n        mutsorted_sums\n/tmp/tmpjmyt57p8.swift:17:13:\
    \ note: join the identifiers together with camel-case\n    let mut sorted_sums\
    \ = nums.enumerated().map(|(i,_)| nums[i]).sorted()\n        ~~~~^~~~~~~~~~~\n\
    \        mutSorted_sums\n/tmp/tmpjmyt57p8.swift:17:57: error: expected ',' separator\n\
    \    let mut sorted_sums = nums.enumerated().map(|(i,_)| nums[i]).sorted()\n \
    \                                                       ^\n                  \
    \                                     ,\n/tmp/tmpjmyt57p8.swift:16:32: error:\
    \ type 'EnumeratedSequence<[Int]>.Iterator.Element' (aka '(offset: Int, element:\
    \ Int)') cannot conform to 'Comparable'\n    let mut sorted_idxs = nums.enumerated().sorted()\n\
    \                               ^\n/tmp/tmpjmyt57p8.swift:16:32: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n    let mut\
    \ sorted_idxs = nums.enumerated().sorted()\n                               ^\n\
    /tmp/tmpjmyt57p8.swift:16:32: note: required by referencing instance method 'sorted()'\
    \ on 'Sequence' where 'Self.Element' = 'EnumeratedSequence<[Int]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Int)')"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == nil {\n        return nums\n    }\n    \n    var numsCopy = nums\n\
    \    var i = 0\n    while i < numsCopy.count {\n        var sum = 0\n        for\
    \ j in 0..<numsCopy.count {\n            sum += numsCopy[j] * 10^j\n        }\n\
    \        var temp = numsCopy[i]\n        numsCopy[i] = numsCopy[sum]\n       \
    \ numsCopy[sum] = temp\n        i += 1\n    }\n    return numsCopy\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bb5805c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bb54fc561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4bb54fc286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4bb54fc13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4bb54fbbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4bb52fbe83 <unavailable> + 188035

    6    tmpktzk5or7                        0x000055a78e3721b5 <unavailable> + 8629

    7    tmpktzk5or7                        0x000055a78e371584 <unavailable> + 5508

    8    libc.so.6                          0x00002b4bb59f1460 __libc_start_main +
    245

    9    tmpktzk5or7                        0x000055a78e371259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted { $0 + $1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp9lyzpqk6.swift:12:29: error: cannot convert value of type 'Int'\
    \ to closure result type 'Bool'\n    return nums.sorted { $0 + $1 }\n        \
    \                 ~~~^~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var res = [Int]()\n    var sum = 0\n    for x in nums {\n        sum += x\n\
    \    }\n    for x in nums {\n        res[res.index(sum)+x] = x\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpj5sf0zo_.swift:18:17: error: no exact matches in call to instance\
    \ method 'index'\n        res[res.index(sum)+x] = x\n                ^\nSwift.Array:7:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Int) -> Int\n                     \
    \      ^\nSwift.Array:9:28: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(before:)')\n    @inlinable public func index(before i: Int) -> Int\n\
    \                           ^\nSwift.RandomAccessCollection:3:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(after:)')\n    @inlinable public\
    \ func index(after i: Self.Index) -> Self.Index\n                           ^\n\
    Swift.RandomAccessCollection:4:28: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(before:)')\n    @inlinable public func index(before i: Self.Index)\
    \ -> Self.Index\n                           ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let map = [Int:Int]()\n    for n in nums {\n        map[n.toString(radix:\
    \ 10)]?++ == nil ? map[n.toString(radix: 10)]? = n : nil\n    }\n    let ordered\
    \ = [Int]()\n    for (digit, count) in map {\n        if let n = map[digit]? {\n\
    \            if let foundIndex = ordered.firstIndex(of: n), foundIndex == nil\
    \ {\n                ordered.append(n)\n            } else {\n               \
    \ if let index = ordered[foundIndex!], (ordered[index] as Int) != n {\n      \
    \              ordered[index] = n\n                }\n            }\n        }\n\
    \    }\n    return ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpw8g5rojx.swift:14:36: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        map[n.toString(radix: 10)]?++ == nil ? map[n.toString(radix:\
    \ 10)]? = n : nil\n                                   ^~\n/tmp/tmpw8g5rojx.swift:14:15:\
    \ error: value of type 'Int' has no member 'toString'\n        map[n.toString(radix:\
    \ 10)]?++ == nil ? map[n.toString(radix: 10)]? = n : nil\n            ~ ^~~~~~~~\n\
    /tmp/tmpw8g5rojx.swift:14:54: error: value of type 'Int' has no member 'toString'\n\
    \        map[n.toString(radix: 10)]?++ == nil ? map[n.toString(radix: 10)]? =\
    \ n : nil\n                                                   ~ ^~~~~~~~\n/tmp/tmpw8g5rojx.swift:18:30:\
    \ error: optional chain has no effect, expression already produces 'Int?'\n  \
    \      if let n = map[digit]? {\n                             ^\n            \
    \                 \n/tmp/tmpw8g5rojx.swift:19:71: warning: comparing non-optional\
    \ value of type 'Array<Int>.Index' (aka 'Int') to 'nil' always returns false\n\
    \            if let foundIndex = ordered.firstIndex(of: n), foundIndex == nil\
    \ {\n                                                           ~~~~~~~~~~ ^ \
    \ ~~~\n/tmp/tmpw8g5rojx.swift:20:25: error: cannot use mutating member on immutable\
    \ value: 'ordered' is a 'let' constant\n                ordered.append(n)\n  \
    \              ~~~~~~~ ^\n/tmp/tmpw8g5rojx.swift:16:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let ordered = [Int]()\n    ^~~\n    var\n/tmp/tmpw8g5rojx.swift:22:40:\
    \ error: cannot find 'foundIndex' in scope\n                if let index = ordered[foundIndex!],\
    \ (ordered[index] as Int) != n {\n                                       ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var arr = [Int]()\n    for x in nums {\n        arr = arr &+ x.digits\n \
    \   }\n    arr.sort()\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpcz4cfek3.swift:14:19: error: binary operator '&+' cannot be applied\
    \ to operands of type '[Int]' and 'SIMD2<UInt8>'\n        arr = arr &+ x.digits\n\
    \              ~~~ ^  ~~~~~~~~\n/tmp/tmpcz4cfek3.swift:14:24: error: value of\
    \ type 'Int' has no member 'digits'\n        arr = arr &+ x.digits\n         \
    \            ~ ^~~~~~\n/tmp/tmpcz4cfek3.swift:14:19: error: no '&+' candidates\
    \ produce the expected contextual result type '[Int]'\n        arr = arr &+ x.digits\n\
    \                  ^\nSwift.SIMD2:8:24: note: '&+' produces 'SIMD2<UInt8>', not\
    \ the expected contextual result type '[Int]'\n    public static func &+ (a: SIMD2<Scalar>,\
    \ b: SIMD2<Scalar>) -> SIMD2<Scalar>\n                       ^\nSwift.SIMD4:8:24:\
    \ note: '&+' produces 'SIMD4<UInt8>', not the expected contextual result type\
    \ '[Int]'\n    public static func &+ (a: SIMD4<Scalar>, b: SIMD4<Scalar>) -> SIMD4<Scalar>\n\
    \                       ^\nSwift.SIMD8:8:24: note: '&+' produces 'SIMD8<UInt8>',\
    \ not the expected contextual result type '[Int]'\n    public static func &+ (a:\
    \ SIMD8<Scalar>, b: SIMD8<Scalar>) -> SIMD8<Scalar>\n                       ^\n\
    Swift.SIMD16:8:24: note: '&+' produces 'SIMD16<UInt8>', not the expected contextual\
    \ result type '[Int]'\n    public static func &+ (a: SIMD16<Scalar>, b: SIMD16<Scalar>)\
    \ -> SIMD16<Scalar>\n                       ^\nSwift.SIMD32:8:24: note: '&+' produces\
    \ 'SIMD32<UInt8>', not the expected contextual result type '[Int]'\n    public\
    \ static func &+ (a: SIMD32<Scalar>, b: SIMD32<Scalar>) -> SIMD32<Scalar>\n  \
    \                     ^\nSwift.SIMD64:8:24: note: '&+' produces 'SIMD64<UInt8>',\
    \ not the expected contextual result type '[Int]'\n    public static func &+ (a:\
    \ SIMD64<Scalar>, b: SIMD64<Scalar>) -> SIMD64<Scalar>\n                     \
    \  ^\nSwift.SIMD3:8:24: note: '&+' produces 'SIMD3<UInt8>', not the expected contextual\
    \ result type '[Int]'\n    public static func &+ (a: SIMD3<Scalar>, b: SIMD3<Scalar>)\
    \ -> SIMD3<Scalar>\n                       ^\nSwift.SIMD2:8:24: note: '&+' produces\
    \ 'SIMD2<Int8>', not the expected contextual result type '[Int]'\n  "
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted{ $0.powi(10) + $1.powi(10) == $0.powi(10) + $1.powi(10)\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp7ihtponn.swift:12:28: error: value of type 'Int' has no member\
    \ 'powi'\n    return nums.sorted{ $0.powi(10) + $1.powi(10) == $0.powi(10) + $1.powi(10)\
    \ }\n                        ~~ ^~~~\n/tmp/tmp7ihtponn.swift:12:42: error: value\
    \ of type 'Int' has no member 'powi'\n    return nums.sorted{ $0.powi(10) + $1.powi(10)\
    \ == $0.powi(10) + $1.powi(10) }\n                                      ~~ ^~~~\n\
    /tmp/tmp7ihtponn.swift:12:57: error: value of type 'Int' has no member 'powi'\n\
    \    return nums.sorted{ $0.powi(10) + $1.powi(10) == $0.powi(10) + $1.powi(10)\
    \ }\n                                                     ~~ ^~~~\n/tmp/tmp7ihtponn.swift:12:71:\
    \ error: value of type 'Int' has no member 'powi'\n    return nums.sorted{ $0.powi(10)\
    \ + $1.powi(10) == $0.powi(10) + $1.powi(10) }\n                             \
    \                                      ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660009448
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard nums.count > 0 else { return nums }\n    let nd = nums.reduce(0) {\
    \ $0 + $1 % 10 }\n    if nd == 0 {\n        return nums\n    }\n    var arr =\
    \ [Int]()\n    let len = nums.count\n    var i = 0\n    for n in nums {\n    \
    \    let nd = n % 10\n        if nd == nd {\n            arr.append(n)\n     \
    \   } else {\n            if nd > nd {\n                arr.append(nums[i])\n\
    \                i++\n            } else {\n                arr.append(nums[len-i-1])\n\
    \                len-i--\n            }\n        }\n    }\n    return arr\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp0m556s88.swift:27:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                i++\n                 ^~\n/tmp/tmp0m556s88.swift:30:22:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \      len-i--\n                     ^~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let numSet = nums.sorted()\n    var numsSorted = nums\n    if numSet.count\
    \ == 0 {\n        return numsSorted\n    }\n    var smallest = numSet[0]\n   \
    \ var largest = numSet[0]\n    for i in 1..<numSet.count {\n        if numSet[i]\
    \ < smallest {\n            smallest = numSet[i]\n        }\n        if numSet[i]\
    \ > largest {\n            largest = numSet[i]\n        }\n    }\n    var indexes\
    \ = [0]\n    while numsSorted.count > 0 {\n        if numsSorted[0] != smallest\
    \ {\n            break\n        }\n        for i in 1..<numsSorted.count {\n \
    \           if numsSorted[i] == largest {\n                numsSorted.remove(at:\
    \ 0)\n                numsSorted.insert(numsSorted[i], at: 0)\n              \
    \  indexes.insert(i)\n                break\n            }\n        }\n    }\n\
    \    return numsSorted[indexes]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp47x6fqwi.swift:36:33: error: missing argument for parameter 'at'\
    \ in call\n                indexes.insert(i)\n                               \
    \ ^\n                                , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n/tmp/tmp47x6fqwi.swift:41:22:\
    \ error: no exact matches in call to subscript \n    return numsSorted[indexes]\n\
    \                     ^\n/tmp/tmp47x6fqwi.swift:41:22: note: found candidate with\
    \ type '(Int) -> @lvalue Int'\n    return numsSorted[indexes]\n              \
    \       ^\n/tmp/tmp47x6fqwi.swift:41:22: note: found candidate with type '(Range<Int>)\
    \ -> @lvalue ArraySlice<Int>'\n    return numsSorted[indexes]\n              \
    \       ^\n/tmp/tmp47x6fqwi.swift:41:22: note: found candidate with type '((UnboundedRange_)\
    \ -> ()) -> ArraySlice<Int>'\n    return numsSorted[indexes]\n               \
    \      ^\n/tmp/tmp47x6fqwi.swift:41:22: note: found candidate with type '((UnboundedRange_)\
    \ -> ()) -> @lvalue ArraySlice<Int>'\n    return numsSorted[indexes]\n       \
    \              ^\n/tmp/tmp47x6fqwi.swift:41:22: error: no 'subscript' candidates\
    \ produce the expected contextual result type '[Int]'\n    return numsSorted[indexes]\n\
    \                     ^\nSwift.Array:16:23: note: 'subscript(_:)' produces '@lvalue\
    \ Int', not the expected contextual result type '[Int]'\n    @inlinable public\
    \ subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23:\
    \ note: 'subscript(_:)' produces '@lvalue ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) ->\
    \ ArraySlice<Element> { get set }\n                      ^\nSwift.Collection:3:23:\
    \ note: 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual\
    \ result type '[Int]'\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get }\n                      ^\nSwift.MutableCollection:3:23:\
    \ note: 'subscript(_:)' produces '@lvalue Ar"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted {\n        if nums.isEmpty {\n            return true\n\
    \        }\n\n        let (digitSum, index) = nums.reduce(0, combine: +)\n   \
    \     return digitSum < 0 ? true : index < (digitSum % 10)\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpljlg3vli.swift:12:24: error: contextual type for closure argument\
    \ list expects 2 arguments, which cannot be implicitly ignored\n    return nums.sorted\
    \ {\n                       ^\n                        _,_ in \n/tmp/tmpljlg3vli.swift:17:44:\
    \ error: extraneous argument label 'combine:' in call\n        let (digitSum,\
    \ index) = nums.reduce(0, combine: +)\n                                      \
    \     ^   ~~~~~~~~~\n                                               \n/tmp/tmpljlg3vli.swift:17:38:\
    \ error: cannot convert value of type 'Int' to specified type '(_, _)'\n     \
    \   let (digitSum, index) = nums.reduce(0, combine: +)\n                     \
    \           ~~~~~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var result = nums\n    for i in 0 ..< result.count {\n        let sum = Int(result[i])\n\
    \        for j in i ..< result.count {\n            let jsum = Int(result[j])\n\
    \            if jsum < sum {\n                swap(&result[i], &result[j])\n \
    \           }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpmptht_xp.swift:18:22: error: overlapping accesses to 'result',\
    \ but modification requires exclusive access; consider calling MutableCollection.swapAt(_:_:)\n\
    \                swap(&result[i], &result[j])\n                ~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    \                result.swapAt(i, j)\n/tmp/tmpmptht_xp.swift:18:34: note: conflicting\
    \ access is here\n                swap(&result[i], &result[j])\n             \
    \                    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return order_by_points_(\n      nums,\n      points: nums.map(&Integer::digits),\n\
    \      compare: compare)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpjbsybnbv.swift:14:32: error: expected ',' separator\n      points:\
    \ nums.map(&Integer::digits),\n                               ^\n            \
    \                   ,\n/tmp/tmpjbsybnbv.swift:14:32: error: expected expression\
    \ in list of expressions\n      points: nums.map(&Integer::digits),\n        \
    \                       ^\n/tmp/tmpjbsybnbv.swift:12:10: error: cannot find 'order_by_points_'\
    \ in scope\n  return order_by_points_(\n         ^~~~~~~~~~~~~~~~\n/tmp/tmpjbsybnbv.swift:14:25:\
    \ error: cannot find 'Integer' in scope\n      points: nums.map(&Integer::digits),\n\
    \                        ^~~~~~~\n/tmp/tmpjbsybnbv.swift:15:16: error: cannot\
    \ find 'compare' in scope\n      compare: compare)\n               ^~~~~~~\n/tmp/tmpjbsybnbv.swift:14:20:\
    \ error: no exact matches in call to instance method 'map'\n      points: nums.map(&Integer::digits),\n\
    \                   ^\n/tmp/tmpjbsybnbv.swift:14:20: note: found candidate with\
    \ type '((Int) throws -> _) throws -> Array<_>'\n      points: nums.map(&Integer::digits),\n\
    \                   ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard let sorted_nums = nums.sorted else {\n        return nums\n    }\n\
    \    return sorted_nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpmtxduso1.swift:12:11: error: initializer for conditional binding\
    \ must have Optional type, not '() -> [Int]'\n    guard let sorted_nums = nums.sorted\
    \ else {\n          ^                 ~~~~~~~~~~~\n/tmp/tmpmtxduso1.swift:15:12:\
    \ error: function produces expected type '[Int]'; did you mean to call it with\
    \ '()'?\n    return sorted_nums\n           ^~~~~~~~~~~\n                    \
    \  ()\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  nums.sort { (p1, p2) -> (Int, Int) in\n    var p1sum = 0\n    var p2sum = 0\n\
    \    for n in nums {\n      if n >= 0 {\n        p1sum += n\n      }\n      if\
    \ n <= 0 {\n        p2sum += n\n      }\n    }\n    return p1sum == p2sum ? Int(p1sum)\
    \ - Int(p2sum) : Int(p1sum) > Int(p2sum) ? 1 : -1\n  }\n  return nums\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp_2cp3guq.swift:12:27: error: declared closure result '(Int, Int)'\
    \ is incompatible with contextual type 'Bool'\n  nums.sort { (p1, p2) -> (Int,\
    \ Int) in\n                          ^~~~~~~~~~\n                          Bool\n\
    /tmp/tmp_2cp3guq.swift:23:27: error: cannot convert return expression of type\
    \ 'Int' to return type '(Int, Int)'\n    return p1sum == p2sum ? Int(p1sum) -\
    \ Int(p2sum) : Int(p1sum) > Int(p2sum) ? 1 : -1\n           ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpwxgpglvr/tmpwxgpglvr.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a48968c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a4865fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a4865f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a4865e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxgpglvr                        0x0000561eab4463e4 <unavailable> + 5092

    5    libc.so.6                          0x00002b8a48b54460 __libc_start_main +
    245

    6    tmpwxgpglvr                        0x0000561eab445fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpwxgpglvr/tmpwxgpglvr.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a48968c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a4865fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a4865f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a4865e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxgpglvr                        0x0000561eab4463e4 <unavailable> + 5092

    5    libc.so.6                          0x00002b8a48b54460 __libc_start_main +
    245

    6    tmpwxgpglvr                        0x0000561eab445fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == nil || nums.isEmpty { return [] }\n    var total: Int = 0\n  \
    \  var results = [Int]()\n    for i in nums {\n        total += i\n        results.append(i)\n\
    \    }\n    var currentOrder = [Int]()\n    var orderChanged = false\n    for\
    \ i in results {\n        if total != 0 {\n            total -= i\n          \
    \  if current != i {\n                currentOrder.append(i)\n               \
    \ orderChanged = true\n            }\n        }\n        current = i\n    }\n\
    \    if !orderChanged {\n        return nums\n    }\n    return currentOrder\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp8sj9m5a1.swift:12:13: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if nums == nil || nums.isEmpty\
    \ { return [] }\n       ~~~~ ^  ~~~\n/tmp/tmp8sj9m5a1.swift:24:16: error: cannot\
    \ find 'current' in scope\n            if current != i {\n               ^~~~~~~\n\
    /tmp/tmp8sj9m5a1.swift:29:9: error: cannot find 'current' in scope\n        current\
    \ = i\n        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var ret = [Int]()\n    var sum = 0\n    \n    for n in nums {\n        sum\
    \ += Int(n)\n        if sum < 0 {\n            sum *= -1\n        }\n        ret.append(sum)\n\
    \    }\n    \n    ret = order_by_helper(ret)\n    \n    return ret\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmplkhiiud2.swift:23:11: error: cannot find 'order_by_helper' in scope\n\
    \    ret = order_by_helper(ret)\n          ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sums = nums.reduce(into: [Int:Int](), { $0.updateValue(Int.init($1.value),\
    \ forKey: $1.key) })\n    let sortedIndices = sums.keys.sorted()\n    return sums.values.sorted().enumerated().map\
    \ { sortedIndices.contains($0.offset) ? $0.element : nil }.filter { $0 != nil\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp5t6zd2nm.swift:12:76: error: value of type 'Int' has no member\
    \ 'value'\n    let sums = nums.reduce(into: [Int:Int](), { $0.updateValue(Int.init($1.value),\
    \ forKey: $1.key) })\n                                                       \
    \                 ~~ ^~~~~\n/tmp/tmp5t6zd2nm.swift:12:95: error: value of type\
    \ 'Int' has no member 'key'\n    let sums = nums.reduce(into: [Int:Int](), { $0.updateValue(Int.init($1.value),\
    \ forKey: $1.key) })\n                                                       \
    \                                    ~~ ^~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum: Int = 0\n    for i in nums {\n        sum += i\n    }\n    return\
    \ nums.sorted{ $0.hashValue < $1.hashValue }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmp2dg0huzn/tmp2dg0huzn.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac23a24ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac239f45b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac239f45988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac239f447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2dg0huzn                        0x0000561012976624 <unavailable> + 5668

    5    libc.so.6                          0x00002ac23a43a460 __libc_start_main +
    245

    6    tmp2dg0huzn                        0x0000561012976209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sums = (0..<nums.count).map { $0.pow(9) + $0.pow(2) }\n    // sort by\
    \ first sum digit\n    sums.sort()\n\n    // sort by index since sums are sorted\
    \ in ascending order\n    return nums.map { sums.index(of: $0.pow(9) + $0.pow(2))\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp1q90ig1b.swift:12:42: error: value of type 'Int' has no member\
    \ 'pow'\n    var sums = (0..<nums.count).map { $0.pow(9) + $0.pow(2) }\n     \
    \                                 ~~ ^~~\n/tmp/tmp1q90ig1b.swift:12:54: error:\
    \ value of type 'Int' has no member 'pow'\n    var sums = (0..<nums.count).map\
    \ { $0.pow(9) + $0.pow(2) }\n                                                \
    \  ~~ ^~~\n/tmp/tmp1q90ig1b.swift:17:41: error: value of type 'Int' has no member\
    \ 'pow'\n    return nums.map { sums.index(of: $0.pow(9) + $0.pow(2)) }\n     \
    \                                ~~ ^~~\n/tmp/tmp1q90ig1b.swift:17:53: error:\
    \ value of type 'Int' has no member 'pow'\n    return nums.map { sums.index(of:\
    \ $0.pow(9) + $0.pow(2)) }\n                                                 ~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var points = [Int]()\n\n    for num in nums {\n        points = points.filter{$0\
    \ == num}.sorted {$0 + $1} + [num]\n    }\n\n    return points\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpzxne3an_.swift:15:54: error: cannot convert value of type 'Int'\
    \ to closure result type 'Bool'\n        points = points.filter{$0 == num}.sorted\
    \ {$0 + $1} + [num]\n                                                  ~~~^~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  guard let max = max(nums) else {\n    return []\n  }\n  guard let min = min(nums)\
    \ else {\n    return []\n  }\n\n  var digits = [Int]()\n  var sum: Int = 0\n \
    \ for num in nums {\n    let digit = num / Int((max).truncatingRemainder(dividingBy:\
    \ 10)!)\n    digits.append(digit)\n    sum += digit\n  }\n  var result = [Int]()\n\
    \  for index in stride(from: 0..<digits.count, to: digits.count, by: 1) {\n  \
    \  result.append(digits[index])\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp12zdl9xa.swift:12:27: error: missing argument for parameter #2\
    \ in call\n  guard let max = max(nums) else {\n                          ^\n \
    \                         , <#[Int]?#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp12zdl9xa.swift:15:27: error: missing argument for\
    \ parameter #2 in call\n  guard let min = min(nums) else {\n                 \
    \         ^\n                          , <#[Int]?#>\nSwift.min:1:24: note: 'min'\
    \ declared here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n/tmp/tmp12zdl9xa.swift:27:30: error: cannot\
    \ convert value of type 'Range<Int>' to expected argument type 'Int'\n  for index\
    \ in stride(from: 0..<digits.count, to: digits.count, by: 1) {\n             \
    \                ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let maxSum = nums.reduce(0, {\n        (sum, item) -> Int\n        -> Int\
    \ in\n        var digitSum = item.digitSum()\n        let newSum = sum + digitSum\n\
    \        return (newSum > digitSum) ? newSum : digitSum\n    })\n    return nums.sorted\
    \ { (a, b) -> Bool in\n        let aSum = a.digitSum()\n        let bSum = b.digitSum()\n\
    \        return aSum < bSum\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp201u47cn.swift:13:24: error: single argument function types require\
    \ parentheses\n        (sum, item) -> Int\n                       ^~~\n      \
    \                 (  )\n/tmp/tmp201u47cn.swift:12:30: error: cannot convert value\
    \ of type 'Int' to expected argument type '(Int) -> Int'\n    let maxSum = nums.reduce(0,\
    \ {\n                             ^\n/tmp/tmp201u47cn.swift:15:29: error: value\
    \ of type 'Int' has no member 'digitSum'\n        var digitSum = item.digitSum()\n\
    \                       ~~~~ ^~~~~~~~\n/tmp/tmp201u47cn.swift:20:22: error: value\
    \ of type 'Int' has no member 'digitSum'\n        let aSum = a.digitSum()\n  \
    \                 ~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var result = [Int]()\n    for num in nums {\n        let count = num.digits\n\
    \        result.append(num.numer)\n        for _ in 0 ..< count {\n          \
    \  result.append(0)\n        }\n    }\n    return result.sorted()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmppksl0nfa.swift:14:25: error: value of type 'Int' has no member\
    \ 'digits'\n        let count = num.digits\n                    ~~~ ^~~~~~\n/tmp/tmppksl0nfa.swift:15:27:\
    \ error: value of type 'Int' has no member 'numer'\n        result.append(num.numer)\n\
    \                      ~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty { return nums }\n    // Find first non-negative number with\
    \ summed digits = 0.\n    var first = nums.firstIndex(where: { !$0.isZero })\n\
    \    if first >= nums.endIndex {\n        return nums\n    }\n    guard first.isZero\
    \ else {\n        first++\n    }\n    // Sum up all digits from the first non-negative\
    \ number with summed digits != 0.\n    var sum = 0\n    for i in 0..<nums.count\
    \ {\n        guard nums[i].isZero else { break } // Skip non-zero numbers.\n \
    \       sum += nums[i]\n    }\n    // Sort the rest numbers.\n    return nums.suffix(first).sorted(by:\
    \ { (a1: Int, a2: Int) -> Bool in\n        let a1_digit = Int(a1)\n        let\
    \ a2_digit = Int(a2)\n        // Sort non-negative numbers first.\n        if\
    \ a1_digit < 0 {\n            return true\n        }\n        // Sort negative\
    \ numbers second.\n        if a2_digit < 0 {\n            return false\n     \
    \   }\n        // If digits are equal, compare their sums.\n        if a1_digit\
    \ == a2_digit {\n            return sum > 0\n        }\n        // Otherwise,\
    \ compare their sums in reverse order.\n        return sum > 0\n    })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp69dtr1kx.swift:14:46: error: value of type 'Int' has no member\
    \ 'isZero'\n    var first = nums.firstIndex(where: { !$0.isZero })\n         \
    \                                 ~~ ^~~~~~\n/tmp/tmp69dtr1kx.swift:19:14: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n        first++\n\
    \             ^~\n/tmp/tmp69dtr1kx.swift:24:23: error: value of type 'Int' has\
    \ no member 'isZero'\n        guard nums[i].isZero else { break } // Skip non-zero\
    \ numbers.\n              ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var max = 0\n    var min = 9223372036854775807\n    var res: [Int] = []\n\
    \    var i = -1\n    for i in 0..<nums.count {\n        if nums[i] > max {\n \
    \           max = nums[i]\n        }\n        if nums[i] < min {\n           \
    \ min = nums[i]\n        }\n    }\n    if nums.count == 0 {\n        return nums\n\
    \    }\n    var maxNum: Int = 0\n    var minNum: Int = 0\n    var numDiff: Int\
    \ = 0\n    for i in 0..<nums.count {\n        if nums[i] > max {\n           \
    \ maxNum = nums[i]\n        }\n        if nums[i] < min {\n            minNum\
    \ = nums[i]\n        }\n        if maxNum != minNum {\n            numDiff = maxNum\
    \ - minNum\n            if numDiff > 0 {\n                res.insert(maxNum +\
    \ numDiff)\n            } else {\n                res.insert(maxNum)\n       \
    \     }\n        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpa315sd34.swift:40:44: error: missing argument for parameter 'at'\
    \ in call\n                res.insert(maxNum + numDiff)\n                    \
    \                       ^\n                                           , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n/tmp/tmpa315sd34.swift:42:34: error: missing argument\
    \ for parameter 'at' in call\n                res.insert(maxNum)\n           \
    \                      ^\n                                 , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard nums.count > 0 else {\n        return nums\n    }\n    var sortedSum:\
    \ Int = nums.reduce(0) { $0 + $1 }\n    var digitSum = [Int]()\n    for n in nums\
    \ {\n        let digit = n.truncatingRemainder(dividingBy: 10)\n        digitSum.append(digit)\n\
    \    }\n    var tmp = [Int]()\n    var index = 0\n    while index < digitSum.count\
    \ {\n        if digitSum[index] == sortedSum {\n            tmp.append(nums[index])\n\
    \        }\n        index += 1\n    }\n    tmp.sortInPlace()\n    return tmp\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpauyeqz8q.swift:18:23: error: value of type 'Int' has no member\
    \ 'truncatingRemainder'\n        let digit = n.truncatingRemainder(dividingBy:\
    \ 10)\n                    ~ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpauyeqz8q.swift:29:9:\
    \ error: value of type '[Int]' has no member 'sortInPlace'\n    tmp.sortInPlace()\n\
    \    ~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  var result = nums\n\n  if result.isEmpty {\n    return result\n  }\n\n  var\
    \ sum = 0\n\n  for index in 0..<result.count {\n    let item = result[index]\n\
    \    sum += item\n    result.remove(at: index)\n    if sum >= 10 {\n      sum\
    \ -= 10\n      result.insert(item, at: index)\n    }\n  }\n\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f8cc25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f8c91c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2f8c91c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2f8c91c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2f8c91bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2f8c71be83 <unavailable> + 188035

    6    tmpfxsmelqv                        0x0000557338e4b1c5 <unavailable> + 8645

    7    tmpfxsmelqv                        0x0000557338e4a674 <unavailable> + 5748

    8    libc.so.6                          0x00002b2f8ce11460 __libc_start_main +
    245

    9    tmpfxsmelqv                        0x0000557338e4a349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == nil || nums.isEmpty() {\n        return nums\n    }\n\n    //\
    \ find the sum of digits\n    let sum: Int? = nums.reduce(0, { $0 + Int(String($1))\
    \ })\n\n    // sort by sum\n    return nums.sorted{ sum != nil && sum! > Int(String($0))\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp3h030b__.swift:12:28: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums == nil || nums.isEmpty() {\n                      \
    \     ^      ~~\n                                  \n/tmp/tmp3h030b__.swift:17:43:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    let sum: Int? = nums.reduce(0, { $0 + Int(String($1)) })\n              \
    \                            ^\n/tmp/tmp3h030b__.swift:17:43: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    let sum:\
    \ Int? = nums.reduce(0, { $0 + Int(String($1)) })\n                          \
    \                ^\n                                          (              \
    \ ?? <#default value#>)\n/tmp/tmp3h030b__.swift:17:43: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    let sum: Int?\
    \ = nums.reduce(0, { $0 + Int(String($1)) })\n                               \
    \           ^\n                                                         !\n/tmp/tmp3h030b__.swift:20:23:\
    \ error: contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments,\
    \ but 1 was used in closure body\n    return nums.sorted{ sum != nil && sum! >\
    \ Int(String($0)) }\n                      ^\n/tmp/tmp3h030b__.swift:20:46: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \   return nums.sorted{ sum != nil && sum! > Int(String($0)) }\n             \
    \                                ^\n/tmp/tmp3h030b__.swift:20:46: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ return nums.sorted{ sum != nil && sum! > Int(String($0)) }\n               \
    \                              ^\n                                           \
    \                  ?? <#default value#>\n/tmp/tmp3h030b__.swift:20:46: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ nums.sorted{ sum != nil && sum! > Int(String($0)) }\n                      \
    \                       ^\n                                                  \
    \          !\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty() {\n        return nums\n    }\n\n    var maxSum = nums.reduce(0,\
    \ combine: {\n        var s: Int = 0\n        if $0 > $1 {\n            s = $0\n\
    \        } else {\n            s = $1\n        }\n        return s + $0\n    })\n\
    \n    var result = [Int]()\n    var index = 0\n    for n in nums {\n        if\
    \ maxSum < n {\n            maxSum = maxSum + n\n            result.append(index)\n\
    \        }\n        index = index + 1\n    }\n    return result + [nums.count]\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpppb0scds.swift:12:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpppb0scds.swift:16:29: error: extraneous argument label 'combine:'\
    \ in call\n    var maxSum = nums.reduce(0, combine: {\n                      \
    \      ^   ~~~~~~~~~\n                                \n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n\n    var sums = nums.map({\
    \ $0.reduce(0) { $0 + $1 } })\n    var sorted = nums.sorted()\n\n    for idx in\
    \ sorted.indices {\n        let digit = sums[idx]\n        sums[idx] -= digit\n\
    \        if sums[idx] == 0 {\n            sorted.remove(at: idx)\n        }\n\
    \    }\n\n    return sorted.map { $0.element }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpavavzeik.swift:16:30: error: value of type 'Int' has no member\
    \ 'reduce'\n    var sums = nums.map({ $0.reduce(0) { $0 + $1 } })\n          \
    \                ~~ ^~~~~~\n/tmp/tmpavavzeik.swift:27:28: error: value of type\
    \ 'Int' has no member 'element'\n    return sorted.map { $0.element }\n      \
    \                  ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == nil || nums.isEmpty {\n        return nums\n    }\n    var sorted\
    \ = [Int]()\n    let digits = nums.map { Int(String($0)) }\n    var currentSum\
    \ = digits.reduce(0, combine: +)\n    for index in 0..<digits.count {\n      \
    \  if digits[index] == 0 {\n            currentSum -= digits[index]\n        }\
    \ else {\n            currentSum += digits[index]\n            sorted.append(index)\n\
    \        }\n        if currentSum > 0 {\n            break\n        }\n    }\n\
    \    return sorted.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmph5criq2u.swift:12:13: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if nums == nil || nums.isEmpty\
    \ {\n       ~~~~ ^  ~~~\n/tmp/tmph5criq2u.swift:17:35: error: extraneous argument\
    \ label 'combine:' in call\n    var currentSum = digits.reduce(0, combine: +)\n\
    \                                  ^   ~~~~~~~~~\n                           \
    \           \n/tmp/tmph5criq2u.swift:17:48: error: cannot convert value of type\
    \ '(Int) -> Int' to expected argument type '(Int, Int?) throws -> Int'\n    var\
    \ currentSum = digits.reduce(0, combine: +)\n                                \
    \               ^\n/tmp/tmph5criq2u.swift:20:33: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n            currentSum -=\
    \ digits[index]\n                                ^\n/tmp/tmph5criq2u.swift:20:33:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            currentSum -= digits[index]\n                           \
    \     ^\n                                        ?? <#default value#>\n/tmp/tmph5criq2u.swift:20:33:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            currentSum -= digits[index]\n                           \
    \     ^\n                                       !\n/tmp/tmph5criq2u.swift:22:33:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            currentSum += digits[index]\n                                ^\n\
    /tmp/tmph5criq2u.swift:22:33: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n            currentSum += digits[index]\n\
    \                                ^\n                                        ??\
    \ <#default value#>\n/tmp/tmph5criq2u.swift:22:33: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n            currentSum\
    \ += digits[index]\n                                ^\n                      \
    \                 !\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: &sumOfDigits)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpqyc7ktt0.swift:12:29: error: cannot find 'sumOfDigits' in scope\n\
    \    return nums.sorted(by: &sumOfDigits)\n                            ^~~~~~~~~~~\n\
    /tmp/tmpqyc7ktt0.swift:12:28: error: cannot convert value of type '_' to expected\
    \ argument type '(Int, Int) throws -> Bool'\n    return nums.sorted(by: &sumOfDigits)\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    // Sort by first digit, if exist\n    let numsSorted = nums.sorted { $0 <\
    \ $1 }\n    // Sort by last digit, if exist\n    if let last = nums.last {\n \
    \       let lastDigit = numsSorted.reduce(0, {$0 + $1 / 10})\n        let numsSorted2\
    \ = numsSorted.sorted(by: { ($0 == lastDigit && $1 < last) || $0 > $1 })\n   \
    \     numsSorted = numsSorted2\n    }\n    return numsSorted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpiz8ih7pu.swift:18:9: error: cannot assign to value: 'numsSorted'\
    \ is a 'let' constant\n        numsSorted = numsSorted2\n        ^~~~~~~~~~\n\
    /tmp/tmpiz8ih7pu.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let numsSorted = nums.sorted { $0 < $1 }\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard nums.count > 0 else {\n        return nums\n    }\n\n    var maxSum\
    \ = -1\n    var sortedItems = nums\n    var sumOfDigits = nums.reduce(0, +)\n\
    \    var i = sortedItems.count\n    var curSum = sumOfDigits\n\n    while i >\
    \ 0 {\n        i -= 1\n        let curItem = sortedItems[i]\n        let curItemDigit\
    \ = curItem % 10\n        let curItemSum = curItemDigit * curSum\n        if curItemSum\
    \ >= maxSum {\n            if maxSum == -1 {\n                maxSum = curItemSum\n\
    \                sortedItems = sortedItems.reversed()\n            } else {\n\
    \                maxSum = max(maxSum, curItemSum)\n            }\n        } else\
    \ if curItemSum < maxSum {\n            if maxSum == -1 {\n                maxSum\
    \ = curItemSum\n                sortedItems = sortedItems.reversed()\n       \
    \     } else {\n                maxSum = min(maxSum, curItemSum)\n           \
    \ }\n        }\n        curSum /= 10\n    }\n\n    return sortedItems\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmpgu2lfd44/tmpgu2lfd44.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af975afcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af9757f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af9757f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9757f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgu2lfd44                        0x0000562ed943b6e4 <unavailable> + 5860

    5    libc.so.6                          0x00002af975ce8460 __libc_start_main +
    245

    6    tmpgu2lfd44                        0x0000562ed943b2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return order_by_points_in_reverse(nums: nums, index: 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpv17ybf2m.swift:12:12: error: cannot find 'order_by_points_in_reverse'\
    \ in scope\n    return order_by_points_in_reverse(nums: nums, index: 0)\n    \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpk89cmlzu/tmpk89cmlzu.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0934c3bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0934932b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0934932988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09349317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk89cmlzu                        0x000055e6e97ab3e4 <unavailable> + 5092

    5    libc.so.6                          0x00002b0934e27460 __libc_start_main +
    245

    6    tmpk89cmlzu                        0x000055e6e97aafc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    func sort(left: [Int], right: [Int]) -> [Int] {\n        var res: [Int] =\
    \ []\n        \n        for l in left {\n            for r in right {\n      \
    \          if l < r {\n                    res = [l, r] + res\n              \
    \  }\n            }\n        }\n        \n        return res\n    }\n    \n  \
    \  if nums.isEmpty {\n        return nums\n    }\n    \n    var tmp: Int = nums[0]\n\
    \    for n in nums {\n        tmp += n\n    }\n    \n    var res: Int = nums[0]\n\
    \    \n    for n in nums {\n        res = max(res, tmp+n)\n    }\n    \n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpbcsn2iqm.swift:41:12: error: cannot convert return expression of\
    \ type 'Int' to return type '[Int]'\n    return res\n           ^~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let digits = (0..<nums.count).map({ Int(nums[$0]) })\n    digits = digits.sorted(by:\
    \ { $0.pow < $1.pow })\n    return digits[0..<nums.count]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpdf5qdsz9.swift:13:5: error: cannot assign to value: 'digits' is\
    \ a 'let' constant\n    digits = digits.sorted(by: { $0.pow < $1.pow })\n    ^~~~~~\n\
    /tmp/tmpdf5qdsz9.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let digits = (0..<nums.count).map({ Int(nums[$0]) })\n    ^~~\n    var\n\
    /tmp/tmpdf5qdsz9.swift:13:37: error: value of type 'Int' has no member 'pow'\n\
    \    digits = digits.sorted(by: { $0.pow < $1.pow })\n                       \
    \          ~~ ^~~\n/tmp/tmpdf5qdsz9.swift:13:46: error: value of type 'Int' has\
    \ no member 'pow'\n    digits = digits.sorted(by: { $0.pow < $1.pow })\n     \
    \                                     ~~ ^~~\n/tmp/tmpdf5qdsz9.swift:14:18: error:\
    \ cannot convert return expression of type 'ArraySlice<Int>' to return type '[Int]'\n\
    \    return digits[0..<nums.count]\n           ~~~~~~^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let (min, max) = nums.minmax(by: func<(Int, Int)>({ $0.1 + $0.2 }))\n   \
    \ var nums2 = nums\n    if let (min, max) = nums.minmax(by: func<(Int, Int)>({\
    \ $0.1 + $0.2 })) {\n        nums2 = nums.filter { $0 >= min && $0 <= max }\n\
    \    }\n    return nums2.sorted(by: func<(Int, Int)>({ $0.1 + $0.2 }))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmprev4hj2o.swift:12:38: error: expected expression in list of expressions\n\
    \    let (min, max) = nums.minmax(by: func<(Int, Int)>({ $0.1 + $0.2 }))\n   \
    \                                  ^\n/tmp/tmprev4hj2o.swift:12:37: error: consecutive\
    \ statements on a line must be separated by ';'\n    let (min, max) = nums.minmax(by:\
    \ func<(Int, Int)>({ $0.1 + $0.2 }))\n                                    ^\n\
    \                                    ;\n/tmp/tmprev4hj2o.swift:12:44: error: unnamed\
    \ parameters must be written with the empty name '_'\n    let (min, max) = nums.minmax(by:\
    \ func<(Int, Int)>({ $0.1 + $0.2 }))\n                                       \
    \    ^\n                                           _: \n/tmp/tmprev4hj2o.swift:12:49:\
    \ error: unnamed parameters must be written with the empty name '_'\n    let (min,\
    \ max) = nums.minmax(by: func<(Int, Int)>({ $0.1 + $0.2 }))\n                \
    \                                ^\n                                         \
    \       _: \n/tmp/tmprev4hj2o.swift:12:53: error: consecutive statements on a\
    \ line must be separated by ';'\n    let (min, max) = nums.minmax(by: func<(Int,\
    \ Int)>({ $0.1 + $0.2 }))\n                                                  \
    \  ^\n                                                    ;\n/tmp/tmprev4hj2o.swift:12:53:\
    \ error: expected expression after unary operator\n    let (min, max) = nums.minmax(by:\
    \ func<(Int, Int)>({ $0.1 + $0.2 }))\n                                       \
    \             ^\n/tmp/tmprev4hj2o.swift:12:71: error: consecutive statements on\
    \ a line must be separated by ';'\n    let (min, max) = nums.minmax(by: func<(Int,\
    \ Int)>({ $0.1 + $0.2 }))\n                                                  \
    \                    ^\n                                                     \
    \                 ;\n/tmp/tmprev4hj2o.swift:12:71: error: expected expression\n\
    \    let (min, max) = nums.minmax(by: func<(Int, Int)>({ $0.1 + $0.2 }))\n   \
    \                                                                   ^\n/tmp/tmprev4hj2o.swift:14:41:\
    \ error: expected expression in list of expressions\n    if let (m"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: >)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmp3p_plyry/tmp3p_plyry.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46bd69dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b46bd394b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b46bd394988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46bd3937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3p_plyry                        0x0000557ad17ed454 <unavailable> + 5204

    5    libc.so.6                          0x00002b46bd889460 __libc_start_main +
    245

    6    tmp3p_plyry                        0x0000557ad17ed039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    precondition(nums.count > 0, \"nums is empty\")\n    // The length of digits\
    \ will be 8+1 since it's 8 digits in a single int.\n    // So the first digit\
    \ sum from left to right is 0.\n    var digits: [Int] = [0]\n    var sum = 0\n\
    \    for n in nums {\n        sum += n\n        digits.append(sum)\n    }\n  \
    \  var sorted_nums: [Int] = []\n    var i = 0\n    // The sum of the digit can\
    \ be calculated by adding digits in reverse order.\n    for d in reversed(self.digits)\
    \ {\n        sorted_nums.append(nums[i])\n        i += 1\n    }\n    return sorted_nums\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpd9moo5dy.swift:24:14: error: cannot find 'reversed' in scope\n\
    \    for d in reversed(self.digits) {\n             ^~~~~~~~\n/tmp/tmpd9moo5dy.swift:24:23:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n    for d in reversed(self.digits) {\n                      ^~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n\n    // Sum all digits\n\
    \    var sum = 0\n    for n in nums {\n        sum += n\n    }\n\n    // Create\
    \ an array with same number of elements as nums\n    let sums = Array(nums.map\
    \ { n in sum += n })\n\n    // Sort the sums\n    var ordered = 0\n    var j =\
    \ 0\n    for i = 1; i < sums.count; i++ {\n        let s = sums[i]\n        let\
    \ d = s - sums[ordered]\n        if d > 0 {\n            ordered += j\n      \
    \      sums[ordered] = s\n        } else {\n            j++\n        }\n    }\n\
    \    // Append all numbers from original array\n    var result: [Int] = []\n \
    \   for n in nums {\n        if n >= sums[ordered] {\n            ordered += j\n\
    \            result.append(n)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp36ld_r12.swift:28:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 1; i < sums.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp36ld_r12.swift:23:9: warning: constant 'sums' inferred to have type '[()]',\
    \ which may be unexpected\n    let sums = Array(nums.map { n in sum += n })\n\
    \        ^\n/tmp/tmp36ld_r12.swift:23:9: note: add an explicit type annotation\
    \ to silence this warning\n    let sums = Array(nums.map { n in sum += n })\n\
    \        ^\n            : [()]\n/tmp/tmp36ld_r12.swift:41:14: error: type '()'\
    \ cannot conform to 'BinaryInteger'\n        if n >= sums[ordered] {\n       \
    \      ^\n/tmp/tmp36ld_r12.swift:41:14: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n        if n >= sums[ordered] {\n\
    \             ^\n/tmp/tmp36ld_r12.swift:41:14: note: required by operator function\
    \ '>=' where 'Other' = '()'\n        if n >= sums[ordered] {\n             ^\n\
    /tmp/tmp36ld_r12.swift:29:22: error: cannot find 'i' in scope\n        let s =\
    \ sums[i]\n                     ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n    \n    var result = [Int](repeating:\
    \ 0, count: nums.count)\n    for i in 0..<nums.count {\n        \n        let\
    \ sum: Int = nums.filter({ $0 % 10 == 0 }).reduce(0) {\n            ($0 + $1 %\
    \ 10)\n        }\n        result[i] = nums.index(where: { $0 + $1 % 10 == sum\
    \ }) ?? nums.endIndex\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp637dx0pn.swift:22:39: error: contextual closure type '(Int) throws\
    \ -> Bool' expects 1 argument, but 2 were used in closure body\n        result[i]\
    \ = nums.index(where: { $0 + $1 % 10 == sum }) ?? nums.endIndex\n            \
    \                          ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum: Int = 0\n    let len = nums.count\n    for i in 0..<len {\n    \
    \    let a = nums[i]\n        let b = nums[len-i-1]\n        let c = a < b ? a\
    \ : b\n        sum += Int(c)\n    }\n    var ans = [Int](repeating: 0, count:\
    \ len)\n    var cnt = 0\n    for i in 0..<len {\n        if nums[i] == sum {\n\
    \            ans[cnt] = i\n            cnt += 1\n        }\n    }\n    return\
    \ ans as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmp5ctzjgf2/tmp5ctzjgf2.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca23e73c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca23b6ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca23b6a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca23b697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ctzjgf2                        0x000055dfb36f0814 <unavailable> + 6164

    5    libc.so.6                          0x00002aca2405f460 __libc_start_main +
    245

    6    tmp5ctzjgf2                        0x000055dfb36f03f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return order_by_points_internal(nums, {})\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpjn_r8sp0.swift:12:10: error: cannot find 'order_by_points_internal'\
    \ in scope\n  return order_by_points_internal(nums, {})\n         ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var len = nums.count\n    var sum = 0\n    for i in 0..<len {\n        sum\
    \ += nums[i]\n        nums[i] = sum\n    }\n    return nums\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpbelr042q.swift:16:13: error: cannot assign through subscript: 'nums'\
    \ is a 'let' constant\n        nums[i] = sum\n        ~~~~^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == nil || nums.count == 0 {\n        return nums\n    }\n    let\
    \ numsSlice = nums.slice()\n    let sum = numsSlice.reduce(0)\n    var sumDigs\
    \ = sum / 10\n    var index = numsSlice.startIndex\n    let pointIndex = nums.startIndex\n\
    \    while index < nums.endIndex {\n        let n = (sumDigs / 10) + nums[index]\n\
    \        if n == sumDigs {\n            sumDigs %= 10\n            pointIndex\
    \ = index\n            index = numsSlice.index(after: index)\n            continue\n\
    \        }\n        if sumDigs != 0 {\n            sumDigs--\n        } else {\n\
    \            sumDigs = 9\n            pointIndex = index\n            index =\
    \ numsSlice.index(after: index)\n        }\n    }\n    if sumDigs > 0 {\n    \
    \    numsSlice.removeSubrange(pointIndex..<numsSlice.endIndex)\n    } else {\n\
    \        numsSlice.removeSubrange(0..<pointIndex)\n    }\n    return numsSlice\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp16nnaga4.swift:12:13: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if nums == nil || nums.count\
    \ == 0 {\n       ~~~~ ^  ~~~\n/tmp/tmp16nnaga4.swift:15:26: error: value of type\
    \ '[Int]' has no member 'slice'\n    let numsSlice = nums.slice()\n          \
    \          ~~~~ ^~~~~\n/tmp/tmp16nnaga4.swift:24:13: error: cannot assign to value:\
    \ 'pointIndex' is a 'let' constant\n            pointIndex = index\n         \
    \   ^~~~~~~~~~\n/tmp/tmp16nnaga4.swift:19:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let pointIndex = nums.startIndex\n    ^~~\n    var\n/tmp/tmp16nnaga4.swift:29:20:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  sumDigs--\n                   ^~\n/tmp/tmp16nnaga4.swift:32:13: error: cannot\
    \ assign to value: 'pointIndex' is a 'let' constant\n            pointIndex =\
    \ index\n            ^~~~~~~~~~\n/tmp/tmp16nnaga4.swift:19:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let pointIndex = nums.startIndex\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n    var result = [Int]()\n\
    \    var temp: Int = 0\n    for n in nums {\n        temp = n\n        for m in\
    \ nums where n != m {\n            temp = temp & m-n\n        }\n        result.insert(temp,\
    \ n)\n    }\n    result.reverse()\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpqwl71eg8.swift:22:16: error: no exact matches in call to instance\
    \ method 'insert'\n        result.insert(temp, n)\n               ^\nSwift.Array:11:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Element, at\
    \ i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var min: Int = 0\n    var max: Int = 0\n    for i in nums {\n        let\
    \ sum = abs(i)\n        if min == 0 || sum < min {\n            min = sum\n  \
    \      }\n        if max == 0 || sum > max {\n            max = sum\n        }\n\
    \    }\n    var res = Array(repeating: 0, count: max + 1)\n    for n in nums {\n\
    \        let sum = abs(n)\n        if sum <= min {\n            // The last element\
    \ of res\n            res[sum] = n\n        } else if sum >= max {\n         \
    \   // The first element of res\n            res[0] = n\n        } else {\n  \
    \          // The middle element of res\n            res[sum - min] = n\n    \
    \    }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpz_vg4ahg/tmpz_vg4ahg.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f93760c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f93457b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f93457988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f934567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_vg4ahg                        0x000055c5809116f4 <unavailable> + 5876

    5    libc.so.6                          0x00002b3f9394c460 __libc_start_main +
    245

    6    tmpz_vg4ahg                        0x000055c5809112d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpwxgpglvr/tmpwxgpglvr.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a48968c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a4865fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a4865f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a4865e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxgpglvr                        0x0000561eab4463e4 <unavailable> + 5092

    5    libc.so.6                          0x00002b8a48b54460 __libc_start_main +
    245

    6    tmpwxgpglvr                        0x0000561eab445fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var result = [Int]()\n    var points = [Int]()\n    for n in nums {\n   \
    \     if points[Int(n % 10)] < 0 {\n            points[Int(n % 10)] = Int(n %\
    \ 10)\n        } else {\n            if points[Int(n % 10)] >= 0 {\n         \
    \       points[Int(n % 10)] += 1\n            } else {\n                points[Int(n\
    \ % 10)] = 1\n            }\n        }\n    }\n    for point in points {\n   \
    \     if point < 0 {\n            result.append(-point)\n        } else {\n  \
    \          result.append(point)\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afb46d66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb46a5d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afb46a5d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afb46a5d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afb46a5cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afb4685ce83 <unavailable> + 188035

    6    tmpcecqwc4q                        0x00005613210e42bf <unavailable> + 8895

    7    tmpcecqwc4q                        0x00005613210e3784 <unavailable> + 6020

    8    libc.so.6                          0x00002afb46f52460 __libc_start_main +
    245

    9    tmpcecqwc4q                        0x00005613210e3459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let len = nums.count\n    var ret = [Int]()\n    var sum: Int = 0\n    for\
    \ i in 0..<len {\n        sum += Int(nums[i])\n        ret.append(Int(sum))\n\
    \    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpz8s7qtb0/tmpz8s7qtb0.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ff85b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ff82abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ff82ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ff82aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz8s7qtb0                        0x000055f963100804 <unavailable> + 6148

    5    libc.so.6                          0x00002b4ff87a0460 __libc_start_main +
    245

    6    tmpz8s7qtb0                        0x000055f9631003e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sorted = nums.sorted()\n    var result = [Int]()\n    for value in sorted\
    \ {\n        if value > 0 {\n            let lastDigitSum = sumOfDigits(&value)\n\
    \            for item in result {\n                if item > 0 && lastDigitSum\
    \ == sumOfDigits(&item) {\n                    result += [item]\n            \
    \        result.insert(value, at: result.index(item) + 1)\n                  \
    \  break\n                }\n            }\n            if lastDigitSum == sumOfDigits(&value)\
    \ {\n                result += [value]\n            }\n        } else {\n    \
    \        result += [value]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp8msfyzk4.swift:16:32: error: cannot find 'sumOfDigits' in scope\n\
    \            let lastDigitSum = sumOfDigits(&value)\n                        \
    \       ^~~~~~~~~~~\n/tmp/tmp8msfyzk4.swift:16:44: error: cannot pass immutable\
    \ value as inout argument: 'value' is a 'let' constant\n            let lastDigitSum\
    \ = sumOfDigits(&value)\n                                           ^~~~~~\n/tmp/tmp8msfyzk4.swift:18:48:\
    \ error: cannot find 'sumOfDigits' in scope\n                if item > 0 && lastDigitSum\
    \ == sumOfDigits(&item) {\n                                               ^~~~~~~~~~~\n\
    /tmp/tmp8msfyzk4.swift:18:60: error: cannot pass immutable value as inout argument:\
    \ 'item' is a 'let' constant\n                if item > 0 && lastDigitSum == sumOfDigits(&item)\
    \ {\n                                                           ^~~~~\n/tmp/tmp8msfyzk4.swift:20:53:\
    \ error: no exact matches in call to instance method 'index'\n               \
    \     result.insert(value, at: result.index(item) + 1)\n                     \
    \                               ^\nSwift.Array:7:28: note: incorrect labels for\
    \ candidate (have: '(_:)', expected: '(after:)')\n    @inlinable public func index(after\
    \ i: Int) -> Int\n                           ^\nSwift.Array:9:28: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public\
    \ func index(before i: Int) -> Int\n                           ^\nSwift.RandomAccessCollection:3:28:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(after:)')\n\
    \    @inlinable public func index(after i: Self.Index) -> Self.Index\n       \
    \                    ^\nSwift.RandomAccessCollection:4:28: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(before:)')\n    @inlinable public func\
    \ index(before i: Self.Index) -> Self.Index\n                           ^\n/tmp/tmp8msfyzk4.swift:24:32:\
    \ error: cannot find 'sumOfDigits' in scope\n            if lastDigitSum == sumOfDigits(&value)\
    \ {\n                               ^~~~~~~~~~~\n/tmp/tmp8msfyzk4.swift:24:44:\
    \ error: cannot pass immutable value as inout argume"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n\n    // We sort this array\
    \ to make sure that the sum of the digits in the\n    // first place is the biggest\
    \ one\n    let sortedNums = nums.sorted(by: sort_by_digits)\n\n    // Sort digits\
    \ by their sum\n    let sortedDigits = sortedNums.map(sort_by_digits)\n\n    //\
    \ If the sum of digits of `sortedNums` is the same,\n    // then sort them based\
    \ on the original index of `sortedNums`.\n    if sortedDigits.first?.first ==\
    \ sortedDigits.last?.first {\n        return sortedNums.sorted(by: sort_by_original_index)\n\
    \    }\n\n    // If the sum of digits of `sortedNums` is different,\n    // then\
    \ sort them based on the sum of the digits in\n    // `sortedNums`.\n    return\
    \ sortedNums.sorted(by: sort_by_sum_of_digits)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpix8jgsk8.swift:18:38: error: cannot find 'sort_by_digits' in scope\n\
    \    let sortedNums = nums.sorted(by: sort_by_digits)\n                      \
    \               ^~~~~~~~~~~~~~\n/tmp/tmpix8jgsk8.swift:18:38: error: converting\
    \ non-escaping value to '(Int, Int) throws -> Bool' may allow it to escape\n \
    \   let sortedNums = nums.sorted(by: sort_by_digits)\n                       \
    \              ^\n/tmp/tmpix8jgsk8.swift:21:39: error: cannot find 'sort_by_digits'\
    \ in scope\n    let sortedDigits = sortedNums.map(sort_by_digits)\n          \
    \                            ^~~~~~~~~~~~~~\n/tmp/tmpix8jgsk8.swift:26:38: error:\
    \ cannot find 'sort_by_original_index' in scope\n        return sortedNums.sorted(by:\
    \ sort_by_original_index)\n                                     ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpix8jgsk8.swift:32:34: error: cannot find 'sort_by_sum_of_digits' in scope\n\
    \    return sortedNums.sorted(by: sort_by_sum_of_digits)\n                   \
    \              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard !nums.isEmpty else { return [] }\n    var sums = [0]\n    for num in\
    \ nums {\n        sums.append(sums[sums.count - 1] + num)\n    }\n    sums.sort\
    \ { $0.0 < $1.0 }\n    return sums.map { $0 + $1 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpch0yikzj.swift:17:20: error: value of type 'Int' has no member\
    \ '0'\n    sums.sort { $0.0 < $1.0 }\n                ~~ ^\n/tmp/tmpch0yikzj.swift:17:27:\
    \ error: value of type 'Int' has no member '0'\n    sums.sort { $0.0 < $1.0 }\n\
    \                       ~~ ^\n/tmp/tmpch0yikzj.swift:18:21: error: contextual\
    \ closure type '(Int) throws -> Int' expects 1 argument, but 2 were used in closure\
    \ body\n    return sums.map { $0 + $1 }\n                    ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: {\n        guard let num = $0 else {\n           \
    \ return true\n        }\n        let sum = num.digits\n        return sum[0]\
    \ == sum[1]\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmps_kivzo1.swift:12:28: error: contextual closure type '(Int, Int)\
    \ throws -> Bool' expects 2 arguments, but 1 was used in closure body\n    return\
    \ nums.sorted(by: {\n                           ^\n/tmp/tmps_kivzo1.swift:16:23:\
    \ error: value of type 'Int' has no member 'digits'\n        let sum = num.digits\n\
    \                  ~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var nums_sorted = [Int]()\n    for i in nums.reverse() {\n        for j in\
    \ 0..<10 {\n            if i != 0 && ((i + j) % 10 != 0) || ((i + j) % 10 == 0)\
    \ {\n                let remainder = abs(i + j) % 10\n                nums_sorted.append(remainder)\n\
    \                break\n            }\n        }\n    }\n    return nums_sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmphgofgta1.swift:13:19: error: cannot use mutating member on immutable\
    \ value: 'nums' is a 'let' constant\n    for i in nums.reverse() {\n         \
    \    ~~~~ ^\n/tmp/tmphgofgta1.swift:13:19: error: for-in loop requires '()' to\
    \ conform to 'Sequence'\n    for i in nums.reverse() {\n             ~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  var nums_copy = nums\n  var sum = 0\n  for i in nums_copy {\n    sum += i\n\
    \  }\n  var nums_sorted = nums_copy\n  nums_sorted.sortInPlaceBy { $0 + Int($1\
    \ as Double) - sum }\n  return nums_sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp3iytiv0z.swift:18:15: error: value of type '[Int]' has no member\
    \ 'sortInPlaceBy'\n  nums_sorted.sortInPlaceBy { $0 + Int($1 as Double) - sum\
    \ }\n  ~~~~~~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    \n    if nums.isEmpty { return nums }\n    \n    let digit_sum = nums.reduce(0)\
    \ { $0 + $1 }\n    \n    var numsSorted = [Int]()\n    var cur = 0\n    \n   \
    \ for x in nums {\n        let digitSum = x + digit_sum\n        \n        //\
    \ check if it already exists in sorted\n        let idx = cur\n        while idx\
    \ < numsSorted.count && digitSum < numsSorted[idx] {\n            idx += 1\n \
    \       }\n        \n        // if it does not yet exist\n        if idx == numsSorted.count\
    \ {\n            // add it at the end\n            numsSorted.append(x)\n    \
    \    } else {\n            // else add it at that index\n            numsSorted[idx]\
    \ = x\n        }\n        \n        cur += 1\n    }\n    \n    return numsSorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpw_ifgm0_.swift:26:17: error: left side of mutating operator isn't\
    \ mutable: 'idx' is a 'let' constant\n            idx += 1\n            ~~~ ^\n\
    /tmp/tmpw_ifgm0_.swift:24:9: note: change 'let' to 'var' to make it mutable\n\
    \        let idx = cur\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let numsCopy = Array(nums)\n    let numsSum = numsCopy.map({ $0 + $0 }).reduce(0)\n\
    \    let sortedNums = numsCopy.sorted {\n        let a = (numsSum - $0) < 0\n\
    \        let b = (numsSum - $0) > 0\n        return a ? b : a\n    }\n    return\
    \ sortedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpo3vb6qf2.swift:13:53: error: missing argument for parameter #2\
    \ in call\n    let numsSum = numsCopy.map({ $0 + $0 }).reduce(0)\n           \
    \                                         ^\n                                \
    \                    , <#(Int, Int) throws -> Int#>\nSwift.Sequence:2:28: note:\
    \ 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n/tmp/tmpo3vb6qf2.swift:14:38:\
    \ error: contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments,\
    \ but 1 was used in closure body\n    let sortedNums = numsCopy.sorted {\n   \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmph4e5pe6o/tmph4e5pe6o.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2cfeea9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2cfeba0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2cfeba0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2cfeb9f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph4e5pe6o                        0x000056057df6c494 <unavailable> + 5268

    5    libc.so.6                          0x00002b2cff095460 __libc_start_main +
    245

    6    tmph4e5pe6o                        0x000056057df6c079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return sort_by_sum(nums, nums.count, &nums.index)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpy0dn1q7t.swift:12:12: error: cannot find 'sort_by_sum' in scope\n\
    \    return sort_by_sum(nums, nums.count, &nums.index)\n           ^~~~~~~~~~~\n\
    /tmp/tmpy0dn1q7t.swift:12:42: error: cannot assign to value: 'index' is a method\n\
    \    return sort_by_sum(nums, nums.count, &nums.index)\n                     \
    \                    ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009442
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpwxgpglvr/tmpwxgpglvr.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8a48968c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8a4865fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8a4865f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8a4865e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxgpglvr                        0x0000561eab4463e4 <unavailable> + 5092

    5    libc.so.6                          0x00002b8a48b54460 __libc_start_main +
    245

    6    tmpwxgpglvr                        0x0000561eab445fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty() {\n        return nums\n    }\n    let numsDict = nums.reduce(into:\
    \ [Int:Int]()) { (dict, num) in\n        dict[num, default: 0] += 1\n    }\n \
    \   let sortedNums = nums.sorted { numsDict[$0]! > numsDict[$1]! }\n    return\
    \ sortedNums\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmphca64x_e.swift:12:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums.isEmpty() {\n            ^      ~~\n              \
    \     \n"
  stdout: ''
  timestamp: 1660009442
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum = 0\n    var res = Array(nums.sorted())\n    for n in nums {\n  \
    \      sum += n\n    }\n    var i = 0\n    for n in res {\n        res[i] = sum\n\
    \        sum += n % 10\n        i ++\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpg4uinzj3.swift:22:5: error: expected expression after operator\n\
    \    }\n    ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  let len = nums.count\n  var sortedPoints = [Int](repeating: 0, count: len)\n\
    \  for n in nums {\n    let sum = n.reduce(0, +)\n    sortedPoints[sum] = n\n\
    \  }\n  return sortedPoints\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpbhg350v1.swift:15:17: error: value of type 'Int' has no member\
    \ 'reduce'\n    let sum = n.reduce(0, +)\n              ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sorted = nums.sorted {\n        sumOfDigits($0) < sumOfDigits($1)\n \
    \   }\n    return sorted as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpijt5cycb.swift:13:9: error: cannot find 'sumOfDigits' in scope\n\
    \        sumOfDigits($0) < sumOfDigits($1)\n        ^~~~~~~~~~~\n/tmp/tmpijt5cycb.swift:13:27:\
    \ error: cannot find 'sumOfDigits' in scope\n        sumOfDigits($0) < sumOfDigits($1)\n\
    \                          ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var ans = [Int]()\n    for n in nums {\n        let digits = n.digits\n \
    \       ans.append(digits.reduce(0, +))\n    }\n    ans.sort()\n    return ans.map\
    \ { n in nums[Int(n)] }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpw4eplvs5.swift:14:24: error: value of type 'Int' has no member\
    \ 'digits'\n        let digits = n.digits\n                     ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sorted = Array(nums)\n    var sorting = false\n    for ind in 0..<sorted.count\
    \ {\n        if sorting {\n            sorting = false\n            var pos =\
    \ nums.count\n            for (j, i) in sorted.enumerated() {\n              \
    \  if j == i {\n                    continue\n                }\n            \
    \    if sorted[j] >= i {\n                    pos = j\n                    break\n\
    \                }\n            }\n            sorted.insert(sorted[pos], at:\
    \ ind)\n        } else {\n            if sorted[ind] == sorted[nums.count] {\n\
    \                sorting = true\n            }\n        }\n    }\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0418147c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0417e3e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0417e3e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0417e3e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0417e3dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0417c3de83 <unavailable> + 188035

    6    tmpc8kd5cg_                        0x000055e5b24f154e <unavailable> + 9550

    7    tmpc8kd5cg_                        0x000055e5b24f0804 <unavailable> + 6148

    8    libc.so.6                          0x00002b0418333460 __libc_start_main +
    245

    9    tmpc8kd5cg_                        0x000055e5b24f04d9 <unavailable> + 5337

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var results = [Int]()\n    for i in nums {\n        let sum = (i + \"\").characters.reduce(0)\
    \ { $0 + Int(String($1)) }\n        results.insert(sum, at: results.index(of:\
    \ sum))\n    }\n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpetir1xf4.swift:14:20: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String'\n        let sum = (i + \"\").characters.reduce(0)\
    \ { $0 + Int(String($1)) }\n                   ^\n/tmp/tmpetir1xf4.swift:14:56:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        let sum = (i + \"\").characters.reduce(0) { $0 + Int(String($1)) }\n\
    \                                                       ^\n/tmp/tmpetir1xf4.swift:14:56:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let sum = (i + \"\").characters.reduce(0) { $0 + Int(String($1))\
    \ }\n                                                       ^\n              \
    \                                         (               ?? <#default value#>)\n\
    /tmp/tmpetir1xf4.swift:14:56: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        let sum = (i + \"\").characters.reduce(0)\
    \ { $0 + Int(String($1)) }\n                                                 \
    \      ^\n                                                                   \
    \   !\n/tmp/tmpetir1xf4.swift:15:41: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        results.insert(sum, at: results.index(of: sum))\n     \
    \                                   ^\n/tmp/tmpetir1xf4.swift:15:41: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     results.insert(sum, at: results.index(of: sum))\n                      \
    \                  ^\n                                                       ??\
    \ <#default value#>\n/tmp/tmpetir1xf4.swift:15:41: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        results.insert(sum,\
    \ at: results.index(of: sum))\n                                        ^\n   \
    \                                                   !\n"
  stdout: ''
  timestamp: 1660009444
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let digits = nums.map{String($0)}\n    let sorted = digits[..<digits.count].sorted()\n\
    \    var res: [Int] = []\n    for i in sorted {\n        if let index = digits.firstIndex(of:\
    \ i) {\n            let rem = nums.remove(at: index)\n            if let n = rem,\
    \ !n.isEmpty {\n                res.append(n)\n                nums.append(rem)\n\
    \            }\n        }\n    }\n    return res + nums\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp_yx0t4hs.swift:17:28: error: cannot use mutating member on immutable\
    \ value: 'nums' is a 'let' constant\n            let rem = nums.remove(at: index)\n\
    \                      ~~~~ ^\n/tmp/tmp_yx0t4hs.swift:20:22: error: no exact matches\
    \ in call to instance method 'append'\n                nums.append(rem)\n    \
    \                 ^\n/tmp/tmp_yx0t4hs.swift:20:22: note: found candidate with\
    \ type '(__owned Int) -> ()'\n                nums.append(rem)\n             \
    \        ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return sort_by_points(nums: nums, by: {\n        $0.1 + $0.2 + $0.3 + $0.4\
    \ + $0.5 + $0.6 + $0.7 + $0.8 + $0.9 + $1.0 + $1.1\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpuqvyhmye.swift:12:12: error: cannot find 'sort_by_points' in scope\n\
    \    return sort_by_points(nums: nums, by: {\n           ^~~~~~~~~~~~~~\n/tmp/tmpuqvyhmye.swift:12:12:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n    return sort_by_points(nums:\
    \ nums, by: {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660010043
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return sorted(nums, by: sum_of_digits(nums))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp7zq9bcb6.swift:12:10: error: cannot find 'sorted' in scope\n  return\
    \ sorted(nums, by: sum_of_digits(nums))\n         ^~~~~~\n/tmp/tmp7zq9bcb6.swift:12:27:\
    \ error: cannot find 'sum_of_digits' in scope\n  return sorted(nums, by: sum_of_digits(nums))\n\
    \                          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sums = [Int]()\n    var num = 0\n\n    for i in nums {\n        sum +=\
    \ i\n        sums.append(sum)\n        num += i\n    }\n\n    var indexes = Array(0..<nums.count).sorted()\n\
    \    var res: [Int] = []\n\n    for i in indexes {\n        if sums[i] == 0 {\n\
    \            continue\n        }\n\n        var index = nums.count\n\n       \
    \ while index != i {\n            index--\n        }\n\n        res.append(nums[index])\n\
    \        sums.removeAtIndex(index)\n    }\n\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpkj8764et.swift:16:9: error: cannot find 'sum' in scope\n      \
    \  sum += i\n        ^~~\n/tmp/tmpkj8764et.swift:17:21: error: cannot find 'sum'\
    \ in scope\n        sums.append(sum)\n                    ^~~\n/tmp/tmpkj8764et.swift:32:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  index--\n                 ^~\n/tmp/tmpkj8764et.swift:36:14: error: value of\
    \ type '[Int]' has no member 'removeAtIndex'\n        sums.removeAtIndex(index)\n\
    \        ~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  if nums.isEmpty {\n    return nums\n  }\n  let maxSum = nums.reduce(0) { $0\
    \ + $1 }\n  return nums.sorted { $0.digits.sum > $1.digits.sum }.map { $0.digits\
    \ + maxSum - $0.digits.sum }.map { $0.value }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpmh37i086.swift:16:27: error: value of type 'Int' has no member\
    \ 'digits'\n  return nums.sorted { $0.digits.sum > $1.digits.sum }.map { $0.digits\
    \ + maxSum - $0.digits.sum }.map { $0.value }\n                       ~~ ^~~~~~\n\
    /tmp/tmpmh37i086.swift:16:43: error: value of type 'Int' has no member 'digits'\n\
    \  return nums.sorted { $0.digits.sum > $1.digits.sum }.map { $0.digits + maxSum\
    \ - $0.digits.sum }.map { $0.value }\n                                       ~~\
    \ ^~~~~~\n/tmp/tmpmh37i086.swift:16:65: error: value of type 'Int' has no member\
    \ 'digits'\n  return nums.sorted { $0.digits.sum > $1.digits.sum }.map { $0.digits\
    \ + maxSum - $0.digits.sum }.map { $0.value }\n                              \
    \                               ~~ ^~~~~~\n/tmp/tmpmh37i086.swift:16:86: error:\
    \ value of type 'Int' has no member 'digits'\n  return nums.sorted { $0.digits.sum\
    \ > $1.digits.sum }.map { $0.digits + maxSum - $0.digits.sum }.map { $0.value\
    \ }\n                                                                        \
    \          ~~ ^~~~~~\n/tmp/tmpmh37i086.swift:16:103: error: unable to infer type\
    \ of a closure parameter '$0' in the current context\n  return nums.sorted { $0.digits.sum\
    \ > $1.digits.sum }.map { $0.digits + maxSum - $0.digits.sum }.map { $0.value\
    \ }\n                                                                        \
    \                              ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sorted = nums.sorted()\n    sorted.reduce(into: [], { $0.append($1.dropLast())\
    \ })\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpnh89jys1.swift:13:44: error: value of type 'Int' has no member\
    \ 'dropLast'\n    sorted.reduce(into: [], { $0.append($1.dropLast()) })\n    \
    \                                    ~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let nums0 = nums.map { Int($0) }\n    var nums1 = nums0\n    nums1.sort()\n\
    \n    var res = nums0\n\n    var left = 0\n    while nums1.count > 0 {\n     \
    \   var right = nums1.count\n        while right > 0 && nums1[left].isLessThan(nums1[left-1])\
    \ {\n            right--\n        }\n\n        var tmp1 = nums1[left]\n      \
    \  var tmp2 = nums1[left-1]\n        while right > 0 && nums1[right-1].isLessThan(nums1[right])\
    \ {\n            nums1[right-1] = nums1[right]\n            right--\n        }\n\
    \n        nums1[left] = tmp2\n        nums1[left-1] = tmp1\n        left += right\n\
    \    }\n\n    for index in stride(from: nums0.count, to: nums1.count, by: 1) {\n\
    \        if nums0[index] > nums1[index] {\n            let tmp = nums0[index]\n\
    \            nums0[index] = nums1[index]\n            nums1[index] = tmp\n   \
    \     }\n    }\n\n    return res.map { $0 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp5wt2ijt6.swift:21:40: error: value of type 'Int' has no member\
    \ 'isLessThan'\n        while right > 0 && nums1[left].isLessThan(nums1[left-1])\
    \ {\n                           ~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5wt2ijt6.swift:22:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  right--\n                 ^~\n/tmp/tmp5wt2ijt6.swift:27:43: error: value of\
    \ type 'Int' has no member 'isLessThan'\n        while right > 0 && nums1[right-1].isLessThan(nums1[right])\
    \ {\n                           ~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5wt2ijt6.swift:29:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  right--\n                 ^~\n/tmp/tmp5wt2ijt6.swift:40:18: error: cannot assign\
    \ through subscript: 'nums0' is a 'let' constant\n            nums0[index] = nums1[index]\n\
    \            ~~~~~^\n/tmp/tmp5wt2ijt6.swift:12:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let nums0 = nums.map { Int($0) }\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var points = [Int]()\n    var temp = 0\n    var sum = 0\n    for i in 0..<nums.count\
    \ {\n        sum = sum + nums[i]\n        points.append(sum)\n    }\n    points.sort()\n\
    \    var res = [Int]()\n    for i in 0..<points.count {\n        sum = points[i]\n\
    \        for j in 0..<nums.count {\n            if sum == nums[j] {\n        \
    \        temp += 1\n            }\n        }\n        if temp > 0 {\n        \
    \    res.append(i)\n            temp = 0\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmph41rycyk/tmph41rycyk.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac25deaac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac25dba1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac25dba1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac25dba07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph41rycyk                        0x0000563d7eeec7f4 <unavailable> + 6132

    5    libc.so.6                          0x00002ac25e096460 __libc_start_main +
    245

    6    tmph41rycyk                        0x0000563d7eeec3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return nums.sorted(by: { sumOfDigits($0) < sumOfDigits($1) })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpxk3q8hzy.swift:12:28: error: cannot find 'sumOfDigits' in scope\n\
    \  return nums.sorted(by: { sumOfDigits($0) < sumOfDigits($1) })\n           \
    \                ^~~~~~~~~~~\n/tmp/tmpxk3q8hzy.swift:12:46: error: cannot find\
    \ 'sumOfDigits' in scope\n  return nums.sorted(by: { sumOfDigits($0) < sumOfDigits($1)\
    \ })\n                                             ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let numsAsStrings = nums.map(NumberFormat.decimal.string(from: self))\n \
    \   return numsAsStrings.sorted { $0.compare($1) == ComparisonResult.orderedAscending\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(order_by_points(nums: [1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmplva2ic5d.swift:12:34: error: cannot find 'NumberFormat' in scope\n\
    \    let numsAsStrings = nums.map(NumberFormat.decimal.string(from: self))\n \
    \                                ^~~~~~~~~~~~\n/tmp/tmplva2ic5d.swift:12:68: error:\
    \ cannot find 'self' in scope; did you mean to use it in a type or extension context?\n\
    \    let numsAsStrings = nums.map(NumberFormat.decimal.string(from: self))\n \
    \                                                                  ^~~~\n/tmp/tmplva2ic5d.swift:12:25:\
    \ error: generic parameter 'T' could not be inferred\n    let numsAsStrings =\
    \ nums.map(NumberFormat.decimal.string(from: self))\n                        ^\n\
    Swift.Collection:2:28: note: in call to function 'map'\n    @inlinable public\
    \ func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n     \
    \                      ^\n/tmp/tmplva2ic5d.swift:13:53: error: cannot find 'ComparisonResult'\
    \ in scope\n    return numsAsStrings.sorted { $0.compare($1) == ComparisonResult.orderedAscending\
    \ }\n                                                    ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var numsSorted = nums\n    if nums.isEmpty {\n        return numsSorted\n\
    \    }\n    var numsDigitSum = nums.reduce(0) { $0 + Int($1) }\n    var index\
    \ = 0\n    var currentSum = numsDigitSum\n    var isAscending = 0\n    while index\
    \ < nums.count {\n        let nextIndex = index + 1\n        if nextIndex == nums.count\
    \ {\n            nextIndex = 0\n        }\n        let nextSum = nums[nextIndex].toInt()\n\
    \        if currentSum > nextSum {\n            isAscending ^= 1\n           \
    \ numsDigitSum = nextSum\n        } else {\n            if numsDigitSum == nextSum\
    \ {\n                numsDigitSum = currentSum\n            } else {\n       \
    \         numsDigitSum = nextSum\n            }\n        }\n        index = nextIndex\n\
    \        currentSum += numsDigitSum\n    }\n    if isAscending {\n        return\
    \ numsSorted\n    } else {\n        return numsSorted.reversed()\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp4ey8wpzy.swift:23:13: error: cannot assign to value: 'nextIndex'\
    \ is a 'let' constant\n            nextIndex = 0\n            ^~~~~~~~~\n/tmp/tmp4ey8wpzy.swift:21:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let nextIndex = index\
    \ + 1\n        ^~~\n        var\n/tmp/tmp4ey8wpzy.swift:25:39: error: value of\
    \ type 'Int' has no member 'toInt'\n        let nextSum = nums[nextIndex].toInt()\n\
    \                      ~~~~~~~~~~~~~~~ ^~~~~\n/tmp/tmp4ey8wpzy.swift:39:8: error:\
    \ type 'Int' cannot be used as a boolean; test for '!= 0' instead\n    if isAscending\
    \ {\n       ^\n       (           != 0)\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted { $0.digit < $1.digit }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpco7s25w8.swift:12:29: error: value of type 'Int' has no member\
    \ 'digit'\n    return nums.sorted { $0.digit < $1.digit }\n                  \
    \       ~~ ^~~~~\n/tmp/tmpco7s25w8.swift:12:40: error: value of type 'Int' has\
    \ no member 'digit'\n    return nums.sorted { $0.digit < $1.digit }\n        \
    \                            ~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted { (a: Int, b: Int) -> Bool in\n        let dA = a\n  \
    \      let dB = b\n        return (dA*10 + dB) < (dB*10 + dA)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmpzltjtq58/tmpzltjtq58.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ea68efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ea65e6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ea65e6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ea65e57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzltjtq58                        0x000056377e319454 <unavailable> + 5204

    5    libc.so.6                          0x00002b2ea6adb460 __libc_start_main +
    245

    6    tmpzltjtq58                        0x000056377e319039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    \n    let sorted_nums = nums.sorted { x, y in \n        guard let x = x,\
    \ let y = y else {\n            return true\n        }\n        \n        let\
    \ x_int = (x * 10).rounded(.towardZero)\n        let y_int = (y * 10).rounded(.towardZero)\n\
    \        return x_int > y_int\n    }\n    \n    return sorted_nums\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpnviqs518.swift:18:24: error: binary operator '*' cannot be applied\
    \ to operands of type 'Int' and 'Float16'\n        let x_int = (x * 10).rounded(.towardZero)\n\
    \                     ~ ^ ~~\n/tmp/tmpnviqs518.swift:18:24: note: overloads for\
    \ '*' exist with these partially matching parameter lists: (Double, Double), (Float,\
    \ Float), (Float16, Float16), (Float80, Float80)\n        let x_int = (x * 10).rounded(.towardZero)\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var numsCopy = nums\n    let len = nums.count\n    let numsCopyLen = numsCopy.count\n\
    \    if len == 0 {\n        return numsCopy\n    }\n    var numsCopyMin: Int?\
    \ = nil\n    for i in 0..<len {\n        let sumOfDigits = numsCopy.map { Int($0)\
    \ }.reduce(0) { $0 + $1 }\n        if sumOfDigits < numsCopyMin {\n          \
    \  numsCopyMin = sumOfDigits\n        }\n    }\n    let start = numsCopy.index(of:\
    \ numsCopyMin!)!\n    var numsCopySorted = numsCopy[start..<numsCopyLen]\n   \
    \ for i in start..<numsCopyLen {\n        numsCopySorted.insert(numsCopy[i], at:\
    \ i)\n    }\n    return numsCopySorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp91ztl2y4.swift:21:26: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if sumOfDigits < numsCopyMin\
    \ {\n                         ^\n/tmp/tmp91ztl2y4.swift:21:26: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if sumOfDigits < numsCopyMin {\n                         ^\n           \
    \                          ?? <#default value#>\n/tmp/tmp91ztl2y4.swift:21:26:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if sumOfDigits < numsCopyMin {\n                         ^\n\
    \                                    !\n/tmp/tmp91ztl2y4.swift:25:26: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    let start = numsCopy.index(of:\
    \ numsCopyMin!)!\n                         ^\n/tmp/tmp91ztl2y4.swift:25:26: note:\
    \ use 'firstIndex(of:)' instead\n    let start = numsCopy.index(of: numsCopyMin!)!\n\
    \                         ^~~~~\n                         firstIndex\n/tmp/tmp91ztl2y4.swift:30:12:\
    \ error: cannot convert return expression of type 'ArraySlice<Int>' to return\
    \ type '[Int]'\n    return numsCopySorted\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var nums_sorted = [Int]()\n    var digitSums = [Int]()\n    for num in nums\
    \ {\n        digitSums.append(num.truncatingRemainder(dividingBy: 10).magnitude)\n\
    \        nums_sorted.append(num)\n    }\n    var digitSums_sorted = [Int]()\n\
    \    var curSum = 0\n    for curSum in digitSums {\n        let index = digitSums.index(of:\
    \ curSum)\n        if index != nil {\n            digitSums_sorted.append(nums_sorted[index!])\n\
    \        } else {\n            digitSums_sorted.append(0)\n        }\n    }\n\
    \    return digitSums_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp0dsl_t4p.swift:15:30: error: value of type 'Int' has no member\
    \ 'truncatingRemainder'\n        digitSums.append(num.truncatingRemainder(dividingBy:\
    \ 10).magnitude)\n                         ~~~ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp0dsl_t4p.swift:21:31:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ index = digitSums.index(of: curSum)\n                              ^\n/tmp/tmp0dsl_t4p.swift:21:31:\
    \ note: use 'firstIndex(of:)' instead\n        let index = digitSums.index(of:\
    \ curSum)\n                              ^~~~~\n                             \
    \ firstIndex\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n    var sum = nums.reduce(0,\
    \ combine: +)\n    var res = []\n    for i in 0..<nums.count {\n        if nums[i]\
    \ != 0 && sum != 0 {\n            let newSum = sum % 10 + nums[i] / 10\n     \
    \       if newSum < sum {\n                sum = newSum\n            } else {\n\
    \                sum -= nums[i]\n            }\n            res.append(nums[i])\n\
    \        }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpvf2er9yk.swift:15:26: error: extraneous argument label 'combine:'\
    \ in call\n    var sum = nums.reduce(0, combine: +)\n                        \
    \ ^   ~~~~~~~~~\n                             \n/tmp/tmpvf2er9yk.swift:16:15:\
    \ error: empty collection literal requires an explicit type\n    var res = []\n\
    \              ^~\n/tmp/tmpvf2er9yk.swift:28:12: error: cannot convert return\
    \ expression of type '[Any]' to return type '[Int]'\n    return res\n        \
    \   ^\n/tmp/tmpvf2er9yk.swift:28:12: note: arguments to generic parameter 'Element'\
    \ ('Any' and 'Int') are expected to be equal\n    return res\n           ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard !nums.isEmpty else {\n        return nums\n    }\n    var numsSorted\
    \ = [Int]()\n    var sums: [Int] = []\n    for num in nums {\n        let sum\
    \ = (num * 10).rounded(.up)\n        sums.append(sum)\n        if sums.contains(sum)\
    \ {\n            numsSorted.append(num)\n        }\n    }\n    numsSorted.sort()\n\
    \    return numsSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp0q3y90t6.swift:18:24: error: binary operator '*' cannot be applied\
    \ to operands of type 'Int' and 'Float16'\n        let sum = (num * 10).rounded(.up)\n\
    \                   ~~~ ^ ~~\n/tmp/tmp0q3y90t6.swift:18:24: note: overloads for\
    \ '*' exist with these partially matching parameter lists: (Double, Double), (Float,\
    \ Float), (Float16, Float16), (Float80, Float80)\n        let sum = (num * 10).rounded(.up)\n\
    \                       ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: NSSortDescriptor(key: \\Int.init, ascending: true))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp9qt3izy7.swift:12:28: error: cannot find 'NSSortDescriptor' in\
    \ scope\n    return nums.sorted(by: NSSortDescriptor(key: \\Int.init, ascending:\
    \ true))\n                           ^~~~~~~~~~~~~~~~\n/tmp/tmp9qt3izy7.swift:12:50:\
    \ error: no exact matches in reference to initializer \n    return nums.sorted(by:\
    \ NSSortDescriptor(key: \\Int.init, ascending: true))\n                      \
    \                           ^\n/tmp/tmp9qt3izy7.swift:12:50: note: found candidate\
    \ with type '(Builtin.IntLiteral) -> Int'\n    return nums.sorted(by: NSSortDescriptor(key:\
    \ \\Int.init, ascending: true))\n                                            \
    \     ^\n/tmp/tmp9qt3izy7.swift:12:50: note: found candidate with type '(UInt)\
    \ -> Int'\n    return nums.sorted(by: NSSortDescriptor(key: \\Int.init, ascending:\
    \ true))\n                                                 ^\n/tmp/tmp9qt3izy7.swift:12:50:\
    \ note: found candidate with type '(Float16) -> Int'\n    return nums.sorted(by:\
    \ NSSortDescriptor(key: \\Int.init, ascending: true))\n                      \
    \                           ^\n/tmp/tmp9qt3izy7.swift:12:50: note: found candidate\
    \ with type '(Float16) -> Int?'\n    return nums.sorted(by: NSSortDescriptor(key:\
    \ \\Int.init, ascending: true))\n                                            \
    \     ^\n/tmp/tmp9qt3izy7.swift:12:50: note: found candidate with type '(Float)\
    \ -> Int'\n    return nums.sorted(by: NSSortDescriptor(key: \\Int.init, ascending:\
    \ true))\n                                                 ^\n/tmp/tmp9qt3izy7.swift:12:50:\
    \ note: found candidate with type '(Float) -> Int?'\n    return nums.sorted(by:\
    \ NSSortDescriptor(key: \\Int.init, ascending: true))\n                      \
    \                           ^\n/tmp/tmp9qt3izy7.swift:12:50: note: found candidate\
    \ with type '(Double) -> Int'\n    return nums.sorted(by: NSSortDescriptor(key:\
    \ \\Int.init, ascending: true))\n                                            \
    \     ^\n/tmp/tmp9qt3izy7.swift:12:50: note: found candidate with type '(Double)\
    \ -> Int?'\n    return nums.sorted(by: NSSortDescriptor(key: \\Int.init, ascending:\
    \ true))\n   "
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var numsSorted = nums\n    if !nums.isEmpty {\n        // Find sum of all\
    \ digits\n        var sum = 0\n        for v in nums {\n            sum += v\n\
    \        }\n\n        // Sort the digits\n        var digitSum = sum\n       \
    \ var sorted = [Int]()\n        for v in nums {\n            let digit = nums.filter\
    \ { $0.isMultiple(digitSum) }\n                .first!\n                .prefixSum(digitSum)\n\
    \                .last!\n                + 1\n            numsSorted.append(digit)\n\
    \            digitSum += digit\n            sorted.append(digit)\n        }\n\
    \        // Sort the points based on index\n        numsSorted.sort(<)\n     \
    \   // Re-sort points by sum of digits\n        numsSorted.sort(by: { $0.prefixSum(digitSum).last\
    \ < $1.prefixSum(digitSum).last })\n        // Return sorted array\n        numsSorted\
    \ = sorted\n    }\n    return numsSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp78cb550w.swift:26:18: error: value of type 'Int' has no member\
    \ 'prefixSum'\n                .prefixSum(digitSum)\n                 ^~~~~~~~~\n\
    /tmp/tmp78cb550w.swift:24:53: error: missing argument label 'of:' in call\n  \
    \          let digit = nums.filter { $0.isMultiple(digitSum) }\n             \
    \                                       ^\n                                  \
    \                  of: \n/tmp/tmp78cb550w.swift:34:25: error: missing argument\
    \ label 'by:' in call\n        numsSorted.sort(<)\n                        ^\n\
    \                        by: \n/tmp/tmp78cb550w.swift:36:34: error: value of type\
    \ 'Int' has no member 'prefixSum'\n        numsSorted.sort(by: { $0.prefixSum(digitSum).last\
    \ < $1.prefixSum(digitSum).last })\n                              ~~ ^~~~~~~~~\n\
    /tmp/tmp78cb550w.swift:36:64: error: value of type 'Int' has no member 'prefixSum'\n\
    \        numsSorted.sort(by: { $0.prefixSum(digitSum).last < $1.prefixSum(digitSum).last\
    \ })\n                                                            ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == [] {\n        return []\n    }\n    let n = nums.count\n    let\
    \ k = ceil(log2(n))\n    var numsSorted = [Int]()\n    for i in 0..<k {\n    \
    \    var tmp = 0\n        for k in 0..<n {\n            tmp = tmp + Int(nums[k])\
    \ % 10\n        }\n        if tmp == nums[0] % 10 {\n            numsSorted.append(nums[0])\n\
    \        }\n        nums[0] = nums[0] - tmp\n    }\n    for i in 0..<k {\n   \
    \     var tmp = 0\n        for k in 0..<n {\n            tmp = tmp + Int(nums[k])\
    \ % 10\n        }\n        if tmp < nums[0] % 10 {\n            numsSorted.append(nums[i])\n\
    \        }\n        nums[i] = nums[i] - tmp\n    }\n    return numsSorted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpszlia3b1.swift:16:13: error: cannot find 'ceil' in scope\n    let\
    \ k = ceil(log2(n))\n            ^~~~\n/tmp/tmpszlia3b1.swift:16:18: error: cannot\
    \ find 'log2' in scope\n    let k = ceil(log2(n))\n                 ^~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    // The idea is simple: sort the array,\n    // then iterate through it, sum\
    \ the digits\n    // and insert them into new array\n    let sum = nums.sorted\
    \ { $0.digits < $1.digits }\n    var newArr: [Int] = []\n    var index = 0\n \
    \   for sum in sum {\n        newArr.append(sum.digits)\n        index++\n   \
    \ }\n    // reverse the array and append the new array elements\n    return newArr.reversed()\
    \ + Array(nums)[index..<newArr.count]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmph3mvy_ea.swift:15:32: error: value of type 'Int' has no member\
    \ 'digits'\n    let sum = nums.sorted { $0.digits < $1.digits }\n            \
    \                ~~ ^~~~~~\n/tmp/tmph3mvy_ea.swift:15:44: error: value of type\
    \ 'Int' has no member 'digits'\n    let sum = nums.sorted { $0.digits < $1.digits\
    \ }\n                                        ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == nil {\n        return nums\n    }\n    \n    if let nums0 = nums\
    \ {\n        let result1 = nums0.sorted()\n        let result2 = result1.map{\n\
    \            guard let int = $0 as? Int else { return $0 }\n            let num\
    \ = (int % 10).digit\n            guard num > 0 else { return $0 }\n         \
    \   return num\n        }\n        return Array(result2)\n    } else {\n     \
    \   return []\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpr8xncxkn.swift:12:13: warning: comparing non-optional value of\
    \ type '[Int]' to 'nil' always returns false\n    if nums == nil {\n       ~~~~\
    \ ^  ~~~\n/tmp/tmpr8xncxkn.swift:20:34: error: value of type 'Int' has no member\
    \ 'digit'\n            let num = (int % 10).digit\n                      ~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmpr8xncxkn.swift:16:8: error: initializer for conditional binding\
    \ must have Optional type, not '[Int]'\n    if let nums0 = nums {\n       ^  \
    \         ~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var nums_copy = nums.slice()\n    guard nums.isEmpty == false else { return\
    \ nums }\n    var nums_sorted = nums_copy\n    for i in 0..<nums_sorted.count\
    \ {\n        let current_sum = 0\n        for j in 0..<nums_copy.count {\n   \
    \         let current_digit = nums_copy[j]\n            if current_digit > 0 {\n\
    \                current_sum += current_digit\n            }\n        }\n    \
    \    if current_sum < 0 {\n            let j = nums_sorted.index(of: -current_sum)\n\
    \            swap(&nums_sorted[i], &nums_sorted[j])\n        }\n    }\n    return\
    \ nums_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpq6jzio54.swift:12:26: error: value of type '[Int]' has no member\
    \ 'slice'\n    var nums_copy = nums.slice()\n                    ~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty { return [] }\n    var sum = 0\n    var len = nums.count\n\
    \    var pos = 0\n    var temp = 0\n    var result = [Int]()\n    for n in nums\
    \ {\n        sum += n\n        if temp > sum {\n            temp -= sum\n    \
    \        if temp > sum {\n                sum = 0\n                pos += 1\n\
    \            }\n        } else {\n            if temp < 0 {\n                sum\
    \ += temp\n                temp = 0\n                pos += 1\n            }\n\
    \            if pos == len {\n                result.append(temp + sum)\n    \
    \            sum = 0\n                pos = 0\n            }\n        }\n    }\n\
    \    for _ in nums.indices {\n        result.append(0)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmpvmfn7zg8/tmpvmfn7zg8.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05663ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05660f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05660f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05660f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvmfn7zg8                        0x0000556b2969d834 <unavailable> + 6196

    5    libc.so.6                          0x00002b05665eb460 __libc_start_main +
    245

    6    tmpvmfn7zg8                        0x0000556b2969d419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return sort(nums).sorted { $0.digits + $1.digits < 0 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp_v_5xz6s.swift:12:12: error: cannot find 'sort' in scope\n    return\
    \ sort(nums).sorted { $0.digits + $1.digits < 0 }\n           ^~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let dict = nums.reduce([Int:Int](), { (dict, num) in\n        if let i =\
    \ dict[String(num)] {\n            dict[String(num)] = i + 1\n        } else {\n\
    \            dict[String(num)] = 1\n        }\n        return dict\n    })\n\n\
    \    let nums_sorted = nums.sorted(by: { (num1, num2) -> Bool in\n        if let\
    \ num1i = dict[String(num1)] {\n            if let num2i = dict[String(num2)]\
    \ {\n                return num1i <= num2i\n            }\n        }\n       \
    \ return false\n    })\n    return nums_sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpu2jw0u8m.swift:13:25: error: cannot convert value of type 'String'\
    \ to expected argument type 'Int'\n        if let i = dict[String(num)] {\n  \
    \                      ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: { (n1, n2) -> Bool in\n        let nsum1 = n1.reduce(0,\
    \ +)\n        let nsum2 = n2.reduce(0, +)\n        if nsum1 < nsum2 {\n      \
    \      return true\n        } else {\n            return false\n        }\n  \
    \  })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(order_by_points(nums: [1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpy1ct1rhc.swift:13:24: error: value of type 'Int' has no member\
    \ 'reduce'\n        let nsum1 = n1.reduce(0, +)\n                    ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sums: [(Int, Int)]\n    var maxSum: Int = 0\n    for num in nums {\n\
    \        sums = sums.filter { sum in\n            return sum.0 != num\n      \
    \  }\n        sums.append((num, maxSum))\n        if maxSum < num {\n        \
    \    maxSum = num\n        }\n    }\n    sums = sums.sort { $0.1 > $1.1 }\n  \
    \  var result: [Int] = []\n    for (_, sum) in sums {\n        result.append(sum)\n\
    \    }\n    return result as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp6gttlvsb.swift:23:17: error: cannot assign value of type '()' to\
    \ type '[(Int, Int)]'\n    sums = sums.sort { $0.1 > $1.1 }\n           ~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var numsSorted = [Int]()\n    var previousSum = -1\n    for i in nums {\n\
    \        if previousSum == 0 {\n            numsSorted.append(i)\n           \
    \ continue\n        }\n        \n        guard i % 10 == 0 else { continue }\n\
    \        let currentSum = i % 10\n        if currentSum > previousSum {\n    \
    \        numsSorted.append(i)\n        }\n        previousSum = currentSum\n \
    \   }\n    return numsSorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmp135ydce4/tmp135ydce4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad01d73c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad01a6ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad01a6a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad01a697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp135ydce4                        0x000055ba7080b694 <unavailable> + 5780

    5    libc.so.6                          0x00002aad01f5f460 __libc_start_main +
    245

    6    tmp135ydce4                        0x000055ba7080b279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard !nums.isEmpty else {\n        return nums\n    }\n    var sums = (0..<10).map()\
    \ {\n        return 0\n    }\n    for num in nums {\n        let newSum = sums.last!\
    \ + num\n        sums.removeLast()\n        sums.insert(newSum, at: sums.endIndex)\n\
    \    }\n    return sums.sorted().map { $0 as Int }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp7gjxr88s.swift:15:31: error: contextual type for closure argument\
    \ list expects 1 argument, which cannot be implicitly ignored\n    var sums =\
    \ (0..<10).map() {\n                              ^\n                        \
    \       _ in \n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let max = nums.max()\n    var sum = 0\n    for n in nums {\n        sum +=\
    \ n % 10\n    }\n    return nums.sorted { sum == $0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmps82_rbc6.swift:17:24: error: contextual closure type '(Int, Int)\
    \ throws -> Bool' expects 2 arguments, but 1 was used in closure body\n    return\
    \ nums.sorted { sum == $0 }\n                       ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let maxSum = nums.reduce(0, +).magnitude\n    var result = [Int]()\n    for\
    \ p in nums {\n        let sum = p.magnitude\n        if sum < maxSum {\n    \
    \        result.append(p)\n            continue\n        }\n        let index\
    \ = sum - maxSum\n        result.append(nums[index])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpfvhvl8k5.swift:21:28: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n        result.append(nums[index])\n      \
    \                     ^\n                           Int( )\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == [] {\n        return nums\n    }\n\n    let sum = 0\n    for i\
    \ in nums {\n        sum += i\n    }\n    var numsSorted = [Int]()\n\n    for\
    \ i in 0..<nums.count {\n        let index = nums.index {\n            num ->\
    \ Bool in\n            let tmp = num\n            sum += tmp\n            tmp\
    \ > 0 && tmp <= sum\n        }\n\n        if index != i {\n            numsSorted.append(nums[i])\n\
    \        }\n    }\n\n    return numsSorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmptu3lils0.swift:18:13: error: left side of mutating operator isn't\
    \ mutable: 'sum' is a 'let' constant\n        sum += i\n        ~~~ ^\n/tmp/tmptu3lils0.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let sum = 0\n    ^~~\n \
    \   var\n/tmp/tmptu3lils0.swift:26:17: error: left side of mutating operator isn't\
    \ mutable: 'sum' is a 'let' constant\n            sum += tmp\n            ~~~\
    \ ^\n/tmp/tmptu3lils0.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let sum = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  var max_digit = UInt(0)\n  var max_index = UInt(0)\n  for i in nums {\n   \
    \ guard i > 0 else {\n      return []\n    }\n    let digit = i % (100 * 1000\
    \ * 1000)\n    guard digit != 0 else {\n      return []\n    }\n    let digitSum\
    \ = Int(digit)\n    if digitSum > max_digit {\n      max_digit = digitSum\n  \
    \    max_index = i\n    }\n  }\n  let result = nums\n  result.removeFirst(at:\
    \ 0)\n  result.insert(max_index, at: 0)\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpti_e6ry3.swift:24:19: error: cannot assign value of type 'Int'\
    \ to type 'UInt'\n      max_digit = digitSum\n                  ^~~~~~~~\n   \
    \               UInt(   )\n/tmp/tmpti_e6ry3.swift:25:19: error: cannot assign\
    \ value of type 'Int' to type 'UInt'\n      max_index = i\n                  ^\n\
    \                  UInt( )\n/tmp/tmpti_e6ry3.swift:29:21: error: extraneous argument\
    \ label 'at:' in call\n  result.removeFirst(at: 0)\n                    ^~~~~\n\
    \                     \n/tmp/tmpti_e6ry3.swift:29:10: error: cannot use mutating\
    \ member on immutable value: 'result' is a 'let' constant\n  result.removeFirst(at:\
    \ 0)\n  ~~~~~~ ^\n/tmp/tmpti_e6ry3.swift:28:3: note: change 'let' to 'var' to\
    \ make it mutable\n  let result = nums\n  ^~~\n  var\n/tmp/tmpti_e6ry3.swift:30:10:\
    \ error: no exact matches in call to instance method 'insert'\n  result.insert(max_index,\
    \ at: 0)\n         ^\n/tmp/tmpti_e6ry3.swift:30:10: note: found candidate with\
    \ type '(__owned Int, Int) -> ()'\n  result.insert(max_index, at: 0)\n       \
    \  ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let digits = nums.map(num -> String? {\n        let str = String(num)\n \
    \       if let index = str.indexOf(str.startIndex, offsetBy: 0) {\n          \
    \  let substr = str.substring(from: index)\n            let num = Int(substr)\n\
    \            return String(num)\n        }\n        return nil\n    })\n    return\
    \ digits.sorted()\n        .flatMap { Int($0) }\n        .sorted()\n        .reversed()\n\
    \        .map { String($0) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp1153rtul.swift:12:27: error: cannot find 'num' in scope\n    let\
    \ digits = nums.map(num -> String? {\n                          ^~~\n/tmp/tmp1153rtul.swift:13:26:\
    \ error: cannot find 'num' in scope\n        let str = String(num)\n         \
    \                ^~~\n/tmp/tmp1153rtul.swift:12:27: error: expected type before\
    \ '->'\n    let digits = nums.map(num -> String? {\n                         \
    \ ^\n/tmp/tmp1153rtul.swift:12:34: error: expected type after '->'\n    let digits\
    \ = nums.map(num -> String? {\n                                 ^\n/tmp/tmp1153rtul.swift:12:23:\
    \ error: no exact matches in call to instance method 'map'\n    let digits = nums.map(num\
    \ -> String? {\n                      ^\n/tmp/tmp1153rtul.swift:12:23: note: found\
    \ candidate with type '((Int) throws -> _) throws -> Array<_>'\n    let digits\
    \ = nums.map(num -> String? {\n                      ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var ans = [Int]()\n    for i in nums {\n        ans = append(ans, i)\n  \
    \  }\n    ans = ans.sorted { $0 + $1 < $2 }\n    return ans\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp8c6boo51.swift:14:15: error: cannot find 'append' in scope\n  \
    \      ans = append(ans, i)\n              ^~~~~~\n/tmp/tmp8c6boo51.swift:16:22:\
    \ error: contextual closure type '(Int, Int) throws -> Bool' expects 2 arguments,\
    \ but 3 were used in closure body\n    ans = ans.sorted { $0 + $1 < $2 }\n   \
    \                  ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var maxPoints = nums.count // count the digits of the biggest number\n  \
    \  var sorted = [Int]()\n    var sums = [Int]()\n    var i = 0\n    for num in\
    \ nums {\n        sums.append(0)\n        for d in num.unicodeScalars {\n    \
    \        sums[i] += d.value\n            i += 1\n        }\n    }\n    // sort\
    \ and get biggest points\n    for i = 0; i < sums.count - 1; i++ {\n        if\
    \ sums[i] > sums[i + 1] {\n            sorted = sorted.sorted {\n            \
    \    (_, _) -> Bool in\n                let x = sums[i]\n                let y\
    \ = sums[i + 1]\n                if x != y {\n                    return x > y\n\
    \                } else {\n                    return false\n                }\n\
    \            }\n            maxPoints = i + 1\n        }\n    }\n    // add remaining\
    \ points\n    for i in 0 ..< maxPoints {\n        sorted.append(nums[i])\n   \
    \ }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpraeh0i7c.swift:24:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 0; i < sums.count - 1; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpraeh0i7c.swift:18:22: error: value of type 'Int' has no member 'unicodeScalars'\n\
    \        for d in num.unicodeScalars {\n                 ~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var maxSum: Int = 0\n    var maxIndex: Int = 0\n    for i in 0 ..< nums.count\
    \ {\n        let sum = nums.reduce(0, +) + i\n        if sum > maxSum {\n    \
    \        maxSum = sum\n            maxIndex = i\n        }\n    }\n    if maxSum\
    \ == 0 {\n        return []\n    }\n    var sorted: Array<Int> = []\n    for i\
    \ in 0 ..< nums.count {\n        let sum = nums.reduce(0, +) + i\n        if sum\
    \ == maxSum {\n            sorted = sorted + [nums[i]]\n        }\n    }\n   \
    \ sorted = sorted + [nums[maxIndex]]\n    return sorted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmpfzsf12mk/tmpfzsf12mk.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b632e7e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b632e4d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b632e4d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b632e4d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfzsf12mk                        0x0000564b4c97e6f4 <unavailable> + 5876

    5    libc.so.6                          0x00002b632e9cc460 __libc_start_main +
    245

    6    tmpfzsf12mk                        0x0000564b4c97e2d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return nums.sorted(by: ascending_sum)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpu_jbfdxi.swift:12:26: error: cannot find 'ascending_sum' in scope\n\
    \  return nums.sorted(by: ascending_sum)\n                         ^~~~~~~~~~~~~\n\
    /tmp/tmpu_jbfdxi.swift:12:26: error: converting non-escaping value to '(Int, Int)\
    \ throws -> Bool' may allow it to escape\n  return nums.sorted(by: ascending_sum)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard !nums.isEmpty else { return [] }\n\n    // We use an array of structs\
    \ here to sort them by their sum and\n    // the position of the item in the original\
    \ array.\n    var struct = Struct()\n    struct.sum = nums.reduce(0) { x, y in\n\
    \        guard let first = x, let second = y else {\n            return x + y\n\
    \        }\n        return first + second\n    }\n    struct.position = nums.count\n\
    \n    return nums.sorted { $0.sum > $1.sum }\n        .map { struct.position }\n\
    \        .sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp71nph57r.swift:16:9: error: keyword 'struct' cannot be used as\
    \ an identifier here\n    var struct = Struct()\n        ^\n/tmp/tmp71nph57r.swift:16:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var struct\
    \ = Struct()\n        ^~~~~~\n        `struct`\n/tmp/tmp71nph57r.swift:17:11:\
    \ error: expected identifier in struct declaration\n    struct.sum = nums.reduce(0)\
    \ { x, y in\n          ^\n/tmp/tmp71nph57r.swift:23:11: error: expected identifier\
    \ in struct declaration\n    struct.position = nums.count\n          ^\n/tmp/tmp71nph57r.swift:26:22:\
    \ error: expected identifier in struct declaration\n        .map { struct.position\
    \ }\n                     ^\n/tmp/tmp71nph57r.swift:16:18: error: cannot find\
    \ 'Struct' in scope\n    var struct = Struct()\n                 ^~~~~~\n/tmp/tmp71nph57r.swift:25:29:\
    \ error: value of type 'Int' has no member 'sum'\n    return nums.sorted { $0.sum\
    \ > $1.sum }\n                         ~~ ^~~\n/tmp/tmp71nph57r.swift:25:38: error:\
    \ value of type 'Int' has no member 'sum'\n    return nums.sorted { $0.sum > $1.sum\
    \ }\n                                  ~~ ^~~\n/tmp/tmp71nph57r.swift:26:14: error:\
    \ contextual type for closure argument list expects 1 argument, which cannot be\
    \ implicitly ignored\n        .map { struct.position }\n             ^\n     \
    \          _ in\n/tmp/tmp71nph57r.swift:26:14: error: cannot convert value of\
    \ type '()' to closure result type 'Int'\n        .map { struct.position }\n \
    \            ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return []\n    }\n\n    // Convert the array of\
    \ numbers to string and get it's digits.\n    // We have to use map to convert\
    \ the array of integers to string.\n    let str = nums.map { String($0) }\n  \
    \  // Get the sum of the digits and sort them.\n    // We can use reduce to accumulate\
    \ each digit of the sum.\n    let sum = str.map { $0.digits().sum() }.reduce(0,\
    \ combine: +) // Convert to Int.\n\n    return str.sorted { $0.digits().sum()\
    \ > $1.digits().sum() }\n        .map { Int($0).digits }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpleza04f8.swift:21:28: error: value of type 'String' has no member\
    \ 'digits'\n    let sum = str.map { $0.digits().sum() }.reduce(0, combine: +)\
    \ // Convert to Int.\n                        ~~ ^~~~~~\n/tmp/tmpleza04f8.swift:21:51:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = str.map {\
    \ $0.digits().sum() }.reduce(0, combine: +) // Convert to Int.\n             \
    \                                     ^   ~~~~~~~~~\n                        \
    \                              \n/tmp/tmpleza04f8.swift:23:28: error: value of\
    \ type 'String' has no member 'digits'\n    return str.sorted { $0.digits().sum()\
    \ > $1.digits().sum() }\n                        ~~ ^~~~~~\n/tmp/tmpleza04f8.swift:23:48:\
    \ error: value of type 'String' has no member 'digits'\n    return str.sorted\
    \ { $0.digits().sum() > $1.digits().sum() }\n                                \
    \            ~~ ^~~~~~\n/tmp/tmpleza04f8.swift:24:24: error: value of type 'Int?'\
    \ has no member 'digits'\n        .map { Int($0).digits }\n               ~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let zero = Int(0)\n    let n = nums.count\n    var sortedIndexes = [Int]()\n\
    \    for i in 0..<n {\n        var sum = 0\n        for j in 0..<n {\n       \
    \     if i != j {\n                sum += Int(nums[j])\n            }\n      \
    \  }\n        sortedIndexes.append(sortedIndexes[sum.truncatingRemainder(dividingBy:\
    \ n)])\n    }\n    return sortedIndexes\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpmz_2zlka.swift:22:48: error: value of type 'Int' has no member\
    \ 'truncatingRemainder'\n        sortedIndexes.append(sortedIndexes[sum.truncatingRemainder(dividingBy:\
    \ n)])\n                                           ~~~ ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum: Int = -Int.max\n    for value in nums {\n        let digit = Int(log10(Float(value)))\
    \ + 1\n        sum += (digit * value) % 10\n    }\n    return Array(nums.sorted(by:\
    \ {\n        sum < $0.0 + $1.0 ? true : false\n    }))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpuvfm2jff.swift:14:25: error: cannot find 'log10' in scope\n   \
    \     let digit = Int(log10(Float(value))) + 1\n                        ^~~~~\n\
    /tmp/tmpuvfm2jff.swift:18:13: error: binary operator '<' cannot be applied to\
    \ operands of type 'Int' and 'String'\n        sum < $0.0 + $1.0 ? true : false\n\
    \        ~~~ ^ ~~~~~~~~~~~\n/tmp/tmpuvfm2jff.swift:18:13: note: overloads for\
    \ '<' exist with these partially matching parameter lists: (Int, Int), (String,\
    \ String)\n        sum < $0.0 + $1.0 ? true : false\n            ^\n/tmp/tmpuvfm2jff.swift:18:18:\
    \ error: value of type 'Int' has no member '0'\n        sum < $0.0 + $1.0 ? true\
    \ : false\n              ~~ ^\n/tmp/tmpuvfm2jff.swift:18:25: error: value of type\
    \ 'Int' has no member '0'\n        sum < $0.0 + $1.0 ? true : false\n        \
    \             ~~ ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var sum: Int = 0\n    for n in nums {\n        sum += n\n    }\n    let n\
    \ = nums.count\n    var tmp = nums\n    var idx: Int = 0\n    while idx < n {\n\
    \        while tmp[idx] > sum {\n            idx += 1\n        }\n        tmp[idx],\
    \ tmp[idx-1] = tmp[idx-1], tmp[idx]\n        idx += 1\n    }\n    return tmp\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpes4xvcr9.swift:23:17: error: consecutive statements on a line must\
    \ be separated by ';'\n        tmp[idx], tmp[idx-1] = tmp[idx-1], tmp[idx]\n \
    \               ^\n                ;\n/tmp/tmpes4xvcr9.swift:23:17: error: expected\
    \ expression\n        tmp[idx], tmp[idx-1] = tmp[idx-1], tmp[idx]\n          \
    \      ^\n/tmp/tmpes4xvcr9.swift:23:12: warning: subscript is accessed but result\
    \ is unused\n        tmp[idx], tmp[idx-1] = tmp[idx-1], tmp[idx]\n        ~~~^~~~~\n\
    /tmp/tmpes4xvcr9.swift:17:9: warning: variable 'tmp' was never mutated; consider\
    \ changing to 'let' constant\n    var tmp = nums\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    \n    var ordered = [Int]()\n    \n    var total = 0\n    \n    for element\
    \ in nums {\n        total += element\n    }\n    \n    for element in nums {\n\
    \        ordered[nums.firstIndex(of: element)] = element\n    }\n    \n    return\
    \ ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpiw929geu.swift:22:22: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n        ordered[nums.firstIndex(of: element)] = element\n     \
    \                ^\n/tmp/tmpiw929geu.swift:22:22: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        ordered[nums.firstIndex(of:\
    \ element)] = element\n                     ^\n                              \
    \               ?? <#default value#>\n/tmp/tmpiw929geu.swift:22:22: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        ordered[nums.firstIndex(of:\
    \ element)] = element\n                     ^\n                              \
    \              !\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var result = [Int]()\n    var sorted = 0\n    for x in nums {\n        if\
    \ sorted < x {\n            sorted = x\n        }\n    }\n    var digits = Int(x.digitsDecimal())\n\
    \    for x in nums {\n        if digits < x {\n            digits = x\n      \
    \  }\n    }\n    digits.sortInPlace()\n    for x in nums {\n        if digits\
    \ == x {\n            result.append(x)\n        }\n    }\n    result.reverse()\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpic8ws9wq.swift:19:22: error: cannot find 'x' in scope\n    var\
    \ digits = Int(x.digitsDecimal())\n                     ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let digits = nums.map({ $0.digits})\n    \n    if nums.isEmpty() {\n    \
    \    return nums\n    }\n    \n    let sum = digits.reduce(0,{ (res, elem) ->\
    \ (Int, Int) -> Int in\n        return res + elem\n    })\n    \n    return nums.sorted({\
    \ $0.digits == $1.digits && $0.digits == sum})\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp2es5hh9s.swift:12:32: error: value of type 'Int' has no member\
    \ 'digits'\n    let digits = nums.map({ $0.digits})\n                        \
    \    ~~ ^~~~~~\n/tmp/tmp2es5hh9s.swift:14:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmp2es5hh9s.swift:22:24: error: missing argument label 'by:' in call\n\
    \    return nums.sorted({ $0.digits == $1.digits && $0.digits == sum})\n     \
    \                  ^\n                       by: \n/tmp/tmp2es5hh9s.swift:22:29:\
    \ error: value of type 'Int' has no member 'digits'\n    return nums.sorted({\
    \ $0.digits == $1.digits && $0.digits == sum})\n                         ~~ ^~~~~~\n\
    /tmp/tmp2es5hh9s.swift:22:42: error: value of type 'Int' has no member 'digits'\n\
    \    return nums.sorted({ $0.digits == $1.digits && $0.digits == sum})\n     \
    \                                 ~~ ^~~~~~\n/tmp/tmp2es5hh9s.swift:22:55: error:\
    \ value of type 'Int' has no member 'digits'\n    return nums.sorted({ $0.digits\
    \ == $1.digits && $0.digits == sum})\n                                       \
    \            ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return nums.sorted(by: { $0.digits.reduce(+) <  $1.digits.reduce(+) })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpn44ezxhl.swift:12:33: error: value of type 'Int' has no member\
    \ 'digits'\n    return nums.sorted(by: { $0.digits.reduce(+) <  $1.digits.reduce(+)\
    \ })\n                             ~~ ^~~~~~\n/tmp/tmpn44ezxhl.swift:12:56: error:\
    \ value of type 'Int' has no member 'digits'\n    return nums.sorted(by: { $0.digits.reduce(+)\
    \ <  $1.digits.reduce(+) })\n                                                \
    \    ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009483
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard nums.count > 0 else { return [] }\n    var numsSorted = nums\n    let\
    \ sum = nums.reduce(0) { $0 + $1 }\n    var maxIndex = -1\n    for index in stride(from:\
    \ 0, to: nums.count - 1, by: 1) {\n        let number = nums[index]\n        let\
    \ digits = String(number).map { String($0).digits(using: .decimalDigits) }\n \
    \       let sum = digits.reduce(0) { $0 + $1 }\n        if sum == max {\n    \
    \        maxIndex = index\n        }\n    }\n    if maxIndex != -1 && numsSorted.count\
    \ > maxIndex {\n        let numsSortedSorted = numsSorted.sorted { $0 > $1 }\n\
    \        numsSorted = numsSortedSorted\n    }\n    return numsSorted\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpyk3aqd_w.swift:18:54: error: value of type 'String' has no member\
    \ 'digits'\n        let digits = String(number).map { String($0).digits(using:\
    \ .decimalDigits) }\n                                          ~~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpyk3aqd_w.swift:18:69: error: cannot infer contextual base in reference\
    \ to member 'decimalDigits'\n        let digits = String(number).map { String($0).digits(using:\
    \ .decimalDigits) }\n                                                        \
    \           ~^~~~~~~~~~~~~\n/tmp/tmpyk3aqd_w.swift:20:19: error: generic parameter\
    \ 'T' could not be inferred\n        if sum == max {\n                  ^\nSwift.max:1:24:\
    \ note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.count == 0 {\n        return nums\n    }\n    let m = nums.reduce(0,\
    \ {$0 + $1}) // the middle digit\n    let d = nums.reduce(0, {$0 + $1}) // the\
    \ sum of the middle digit\n    let maxsum = nums.reduce(0, {$0 + $1})\n    return\
    \ nums.filter { num in let s = num - m; d < maxsum && s % d == 0 && num != m }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpri2uaf73.swift:18:75: warning: result of operator '&&' is unused\n\
    \    return nums.filter { num in let s = num - m; d < maxsum && s % d == 0 &&\
    \ num != m }\n                                                 ~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^  ~~~~~~~~\n/tmp/tmpri2uaf73.swift:18:50: error: missing return in closure\
    \ expected to return 'Bool'\n    return nums.filter { num in let s = num - m;\
    \ d < maxsum && s % d == 0 && num != m }\n                                   \
    \              ^\n/tmp/tmpri2uaf73.swift:18:50: note: did you mean to return the\
    \ last expression?\n    return nums.filter { num in let s = num - m; d < maxsum\
    \ && s % d == 0 && num != m }\n                                              \
    \   ^\n                                                 return \n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    // TODO(zhaochun): Improve the performance of sort_by_points.\n    \n   \
    \ // For each number, calculate the sum of its digits and store\n    // the index\
    \ of this number in arrIndexs.\n    var arrIndexs: [Int] = []\n    for i in nums\
    \ {\n        let sum = i.digits.reduce(0, +) + i.digits\n        arrIndexs.append(sum)\n\
    \    }\n\n    // Sort the numbers in arrIndexs in ascending order.\n    arrIndexs.sort()\n\
    \n    // Return the sorted array.\n    return nums[arrIndexs]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpnyudcvid.swift:18:21: error: value of type 'Int' has no member\
    \ 'digits'\n        let sum = i.digits.reduce(0, +) + i.digits\n             \
    \     ~ ^~~~~~\n/tmp/tmpnyudcvid.swift:18:45: error: value of type 'Int' has no\
    \ member 'digits'\n        let sum = i.digits.reduce(0, +) + i.digits\n      \
    \                                    ~ ^~~~~~\n/tmp/tmpnyudcvid.swift:26:16: error:\
    \ no exact matches in call to subscript \n    return nums[arrIndexs]\n       \
    \        ^\n/tmp/tmpnyudcvid.swift:26:16: note: found candidate with type '(Int)\
    \ -> Int'\n    return nums[arrIndexs]\n               ^\n/tmp/tmpnyudcvid.swift:26:16:\
    \ note: found candidate with type '(Range<Int>) -> ArraySlice<Int>'\n    return\
    \ nums[arrIndexs]\n               ^\n/tmp/tmpnyudcvid.swift:26:16: note: found\
    \ candidate with type '((UnboundedRange_) -> ()) -> ArraySlice<Int>'\n    return\
    \ nums[arrIndexs]\n               ^\n/tmp/tmpnyudcvid.swift:26:16: error: no 'subscript'\
    \ candidates produce the expected contextual result type '[Int]'\n    return nums[arrIndexs]\n\
    \               ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int', not\
    \ the expected contextual result type '[Int]'\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual result\
    \ type '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    // TODO: make more efficient\n    if nums.isEmpty {\n        return nums\n\
    \    }\n    let sortedBySum = nums.sorted {\n        if let x = $1, y = $0.reduce(0)\
    \ {\n            return x + UInt8(y - x)\n        }\n    }\n    return sortedBySum\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpqcfcmvqu.swift:17:24: error: expected 'let' in conditional\n  \
    \      if let x = $1, y = $0.reduce(0) {\n                       ^\n         \
    \              let \n/tmp/tmpqcfcmvqu.swift:17:31: error: value of type 'Int'\
    \ has no member 'reduce'\n        if let x = $1, y = $0.reduce(0) {\n        \
    \                   ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let max = 0\n    var sum = 0\n    for element in nums {\n        sum += element\n\
    \        if sum > max {\n            max = sum\n        }\n    }\n    if nums.isEmpty()\
    \ {\n        return nums\n    }\n\n    // find the first number whose sum <= max\n\
    \    var result = nums[0]\n    for element in nums {\n        sum += element\n\
    \        if sum < max {\n            break\n        }\n        result = element\n\
    \    }\n\n    // sort based on the index of result before sorting\n    let resultIndex\
    \ = 0\n    for element in nums {\n        sum += element\n        if sum < max\
    \ {\n            let index = nums.firstIndex(where: { $0 != result && $0 > element\
    \ })\n            if index != resultIndex {\n                nums.remove(at: index!)\n\
    \            }\n            break\n        }\n        resultIndex += 1\n     \
    \   result = element\n    }\n    return nums\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpad94vff7.swift:17:13: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n            max = sum\n            ^~~\n/tmp/tmpad94vff7.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = 0\n    ^~~\n \
    \   var\n/tmp/tmpad94vff7.swift:20:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpad94vff7.swift:41:22: error: cannot use mutating member on immutable\
    \ value: 'nums' is a 'let' constant\n                nums.remove(at: index!)\n\
    \                ~~~~ ^\n/tmp/tmpad94vff7.swift:45:21: error: left side of mutating\
    \ operator isn't mutable: 'resultIndex' is a 'let' constant\n        resultIndex\
    \ += 1\n        ~~~~~~~~~~~ ^\n/tmp/tmpad94vff7.swift:35:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let resultIndex = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty() {\n        return nums\n    }\n\n    // Count sum of digits.\n\
    \    var digits = nums.map({ $0.digits }).reduce(into: [Int](), { $0.append($1.digits);\
    \ $0.append($1.digits.reversed()) })\n\n    // Find the index for items with same\
    \ sum of digits and sort them by their index.\n    let indexForSameSumDigits =\
    \ (0..<nums.count).filter { i in digits[nums[i]] == digits[nums[nums[i]]] }\n\
    \    return indexForSameSumDigits.map { nums[$0] }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpjwcwhjxt.swift:12:13: error: cannot call value of non-function\
    \ type 'Bool'\n    if nums.isEmpty() {\n            ^      ~~\n              \
    \     \n/tmp/tmpjwcwhjxt.swift:17:32: error: value of type 'Int' has no member\
    \ 'digits'\n    var digits = nums.map({ $0.digits }).reduce(into: [Int](), { $0.append($1.digits);\
    \ $0.append($1.digits.reversed()) })\n                            ~~ ^~~~~~\n\
    /tmp/tmpjwcwhjxt.swift:17:64: error: unable to infer type of a closure parameter\
    \ '$1' in the current context\n    var digits = nums.map({ $0.digits }).reduce(into:\
    \ [Int](), { $0.append($1.digits); $0.append($1.digits.reversed()) })\n      \
    \                                                         ^\n"
  stdout: ''
  timestamp: 1660009444
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums == [] {\n        return []\n    }\n    var numsSorted = nums\n  \
    \  for num in numsSorted {\n        let sum = num.digitsSum()\n        switch\
    \ sum {\n        case 0: break\n        case 10:\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n        case 11:\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n        case 12:\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \      numsSorted.remove(at: numsSorted.index(of: num))\n        case 1:\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \  case 2:\n            numsSorted.remove(at: numsSorted.index(of: num))\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \  case 3:\n            numsSorted.remove(at: numsSorted.index(of: num))\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \      numsSorted.remove(at: numsSorted.index(of: num))\n        case 4:\n   \
    \         numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \      numsSorted.remove(at: numsSorted.index(of: num))\n            numsSorted.remove(\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) ==\
    \ [-1, -11, 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2,\
    \ 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423,\
    \ 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int])\
    \ == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2,\
    \ -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpxtwhcjfk.swift:54:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpxtwhcjfk.swift:74:88: error: expected '}' at end of brace statement\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])\n                                                                   \
    \                    ^\n/tmp/tmpxtwhcjfk.swift:16:27: note: to match this opening\
    \ '{'\n    for num in numsSorted {\n                          ^\n/tmp/tmpxtwhcjfk.swift:74:88:\
    \ error: expected '}' at end of brace statement\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])\n               \
    \                                                                        ^\n/tmp/tmpxtwhcjfk.swift:11:44:\
    \ note: to match this opening '{'\nfunc order_by_points(nums: [Int]) -> [Int]\
    \ {\n                                           ^\n/tmp/tmpxtwhcjfk.swift:17:23:\
    \ error: value of type 'Int' has no member 'digitsSum'\n        let sum = num.digitsSum()\n\
    \                  ~~~ ^~~~~~~~~\n/tmp/tmpxtwhcjfk.swift:21:46: error: value of\
    \ optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to\
    \ a value of type 'Array<Int>.Index' (aka 'Int')\n            numsSorted.remove(at:\
    \ numsSorted.index(of: num))\n                                             ^\n\
    /tmp/tmpxtwhcjfk.swift:21:46: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n            numsSorted.remove(at: numsSorted.index(of:\
    \ num))\n                                             ^\n                    \
    \                                        ?? <#default value#>\n/tmp/tmpxtwhcjfk.swift:21:46:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            numsSorted.remove(at: numsSorted.index(of: num))\n      \
    \                                       ^\n                                  \
    \                         !\n/tmp/tmpxtwhcjfk.swift:23:46: error: value of optional\
    \ type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Int>.Index' (aka 'Int')\n   "
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sum = nums.reduce(0, {$0 + $1 * $0})\n    return nums.sorted(by: { $0\
    \ + $1 * $0 < sum})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: Exception
  stderr: 'tmpohw5w5nk/tmpohw5w5nk.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acc2f965c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acc2f65cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acc2f65c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acc2f65b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpohw5w5nk                        0x0000556efc85f4d4 <unavailable> + 5332

    5    libc.so.6                          0x00002acc2fb51460 __libc_start_main +
    245

    6    tmpohw5w5nk                        0x0000556efc85f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    return sort_helper(nums, points: .points,\n                       cmp: OrderByPoints(nums:\
    \ nums))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpb6c7lrzm.swift:12:12: error: cannot find 'sort_helper' in scope\n\
    \    return sort_helper(nums, points: .points,\n           ^~~~~~~~~~~\n/tmp/tmpb6c7lrzm.swift:13:29:\
    \ error: cannot find 'OrderByPoints' in scope\n                       cmp: OrderByPoints(nums:\
    \ nums))\n                            ^~~~~~~~~~~~~\n/tmp/tmpb6c7lrzm.swift:12:39:\
    \ error: cannot infer contextual base in reference to member 'points'\n    return\
    \ sort_helper(nums, points: .points,\n                                     ~^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    \n    let maxSum = nums.reduce { (max, v) -> Int in\n        return max <\
    \ v ? max : v\n    }\n\n    var sorted = nums\n    for sum in 0..<maxSum {\n \
    \       sorted.sort { (a, b) -> Bool in\n            return a % 10 + b % 10 >=\
    \ sum\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp_v1ocluc.swift:13:29: error: missing argument for parameter #1\
    \ in call\n    let maxSum = nums.reduce { (max, v) -> Int in\n               \
    \             ^\n                            (<#Int#>)\nSwift.Sequence:2:28: note:\
    \ 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n                           ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let sorted = nums.sorted()\n    sorted.sort { $0 + $1 < $1 + $0 }\n    return\
    \ sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpqglkhbc3.swift:13:12: error: cannot use mutating member on immutable\
    \ value: 'sorted' is a 'let' constant\n    sorted.sort { $0 + $1 < $1 + $0 }\n\
    \    ~~~~~~ ^\n/tmp/tmpqglkhbc3.swift:12:5: note: change 'let' to 'var' to make\
    \ it mutable\n    let sorted = nums.sorted()\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \  return nums.sorted(by: sort_by_digits)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12,\
    \ 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6,\
    \ 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46,\
    \ 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\n\
    assert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98,\
    \ -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmprjzjo5y6.swift:12:26: error: cannot find 'sort_by_digits' in scope\n\
    \  return nums.sorted(by: sort_by_digits)\n                         ^~~~~~~~~~~~~~\n\
    /tmp/tmprjzjo5y6.swift:12:26: error: converting non-escaping value to '(Int, Int)\
    \ throws -> Bool' may allow it to escape\n  return nums.sorted(by: sort_by_digits)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    let nums_sorted = nums\n        .map() { $0.digitsAsString() }\n        .sorted()\n\
    \        .map { Int($0, radix: 10) }\n\n    var sums = nums_sorted.map { $0.reduce(0)\
    \ { $0 + $1} }  // accumulate sum\n    while nums_sorted.count > 0 {\n       \
    \ let last_sum = nums_sorted[0].digitsAsString()!.reduce(0) { $0 + $1} // last\
    \ sum\n        let next_sum = sums[0].reduce(0) { $0 + $1} // next sum\n     \
    \   let index = nums_sorted.indexOf({ $0.digitsAsString()!.reduce(0) { $0 + $1}\
    \ > last_sum }) // index of last sum\n        sums.swapAt(index, 0)\n        nums_sorted.remove(at:\
    \ 0)\n    }\n    return nums_sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmp4j5c2ljt.swift:13:21: error: value of type 'Int' has no member\
    \ 'digitsAsString'\n        .map() { $0.digitsAsString() }\n                 ~~\
    \ ^~~~~~~~~~~~~~\n/tmp/tmp4j5c2ljt.swift:15:14: error: unable to infer type of\
    \ a closure parameter '$0' in the current context\n        .map { Int($0, radix:\
    \ 10) }\n             ^\n"
  stdout: ''
  timestamp: 1660009452
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    var idxs = [Int]()\n    var sums = [Int]()\n    for v in nums {\n       \
    \ var digits = nums.filter{$0 >= v}.count\n        if digits == 0 {\n        \
    \    sums.append(v)\n            idxs.append(0)\n        } else {\n          \
    \  var sum = 0\n            while digits > 0 {\n                digits = digits\
    \ / 10\n                sum += v % 10\n                v = v / 10\n          \
    \  }\n            sums.append(sum)\n            idxs.append(sums.count - 1)\n\
    \        }\n    }\n    return nums[idxs]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\n\
    assert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as [Int])\nassert(order_by_points(nums:\
    \ [1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpi6ikql50.swift:24:17: error: cannot assign to value: 'v' is a 'let'\
    \ constant\n                v = v / 10\n                ^\n/tmp/tmpi6ikql50.swift:30:16:\
    \ error: no exact matches in call to subscript \n    return nums[idxs]\n     \
    \          ^\n/tmp/tmpi6ikql50.swift:30:16: note: found candidate with type '(Int)\
    \ -> Int'\n    return nums[idxs]\n               ^\n/tmp/tmpi6ikql50.swift:30:16:\
    \ note: found candidate with type '(Range<Int>) -> ArraySlice<Int>'\n    return\
    \ nums[idxs]\n               ^\n/tmp/tmpi6ikql50.swift:30:16: note: found candidate\
    \ with type '((UnboundedRange_) -> ()) -> ArraySlice<Int>'\n    return nums[idxs]\n\
    \               ^\n/tmp/tmpi6ikql50.swift:30:16: error: no 'subscript' candidates\
    \ produce the expected contextual result type '[Int]'\n    return nums[idxs]\n\
    \               ^\nSwift.Array:16:23: note: 'subscript(_:)' produces 'Int', not\
    \ the expected contextual result type '[Int]'\n    @inlinable public subscript(index:\
    \ Int) -> Element { get set }\n                      ^\nSwift.Array:17:23: note:\
    \ 'subscript(_:)' produces 'ArraySlice<Int>', not the expected contextual result\
    \ type '[Int]'\n    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element>\
    \ { get set }\n                      ^\nSwift.Collection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: 'subscript(_:)'\
    \ produces 'ArraySlice<Int>', not the expected contextual result type '[Int]'\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get set }\n                      ^\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: -4
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    if nums.isEmpty {\n        return nums\n    }\n\n    var maxSum = nums[0]\n\
    \    var maxIndex = 0\n\n    for i in 0..<nums.count {\n        let sum = nums[i]\n\
    \        if sum < 0 {\n            continue\n        }\n\n        if sum > maxSum\
    \ {\n            maxSum = sum\n            maxIndex = i\n        }\n    }\n\n\
    \    return nums.sorted(by: { sum, _ in sum < (sum - maxSum) })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: Exception
  stderr: 'tmpzhjlkr4h/tmpzhjlkr4h.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae35d856c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae35d54db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae35d54d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae35d54c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzhjlkr4h                        0x000055b2cabf0724 <unavailable> + 5924

    5    libc.so.6                          0x00002ae35da42460 __libc_start_main +
    245

    6    tmpzhjlkr4h                        0x000055b2cabf0309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    switch nums.count {\n    case 0: return [] as [Int]\n    case 1: return [nums[0]]\
    \ as [Int]\n    default:\n        // Sort the array of digits in ascending order\n\
    \        // and then apply the index sorting\n        let arr = sort_by_digits(nums)\n\
    \        return arr.map({ $0 as Int }).sorted()\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(order_by_points(nums: [1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11])\nassert(order_by_points(nums: [1234, 423, 463, 145, 2, 423, 423,\
    \ 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145,\
    \ 37, 46, 56, 463, 3457])\nassert(order_by_points(nums: [] as [Int]) == [] as\
    \ [Int])\nassert(order_by_points(nums: [1, -11, -32, 43, 54, -98, 2, -3]) == [-3,\
    \ -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums: [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\nassert(order_by_points(nums:\
    \ [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23, 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpodifwyu8.swift:18:19: error: cannot find 'sort_by_digits' in scope\n\
    \        let arr = sort_by_digits(nums)\n                  ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard nums.count > 0 else { return nums }\n    guard nums.count <= 10 else\
    \ { return nums }\n\n    var sorted = [Int]()\n    var sum = nums[0]\n    var\
    \ len = nums.count\n    var digits = nums[0] as [Int]\n\n    for i in 1..<len\
    \ {\n        sum = sum + nums[i]\n        digits.append(nums[i])\n    }\n\n  \
    \  for i in 1..<len {\n        sum = sum - digits[i]\n        if sum < 0 { //\
    \ if sum is negative\n            sum += 10\n            sorted.append(nums[i])\n\
    \        } else {\n            sorted.append(digits[i])\n        }\n    }\n\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpg3zok12_.swift:18:26: error: cannot convert value of type 'Int'\
    \ to type '[Int]' in coercion\n    var digits = nums[0] as [Int]\n           \
    \      ~~~~~~~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660009443
- exit_code: 1
  program: "\n/// Write a function which sorts the given array of integers\n/// in\
    \ ascending order according to the sum of their digits.\n/// Note: if there are\
    \ several items with similar sum of their digits,\n/// order them based on their\
    \ index in original array.\n/// For example:\n/// >>> order_by_points(nums: [1,\
    \ 11, -1, -11, -12])\n/// [-1, -11, 1, -12, 11]\n/// >>> order_by_points(nums:\
    \ [] as [Int])\n/// [] as [Int]\nfunc order_by_points(nums: [Int]) -> [Int] {\n\
    \    guard !nums.isEmpty else {\n        return nums\n    }\n    \n    var res\
    \ = [Int]()\n    for n in nums {\n        let d = abs(n)\n        let i = find(res,\
    \ d, stable: true)\n        if i == nil {\n            append(res, d)\n      \
    \  } else {\n            res[i] = min(res[i], d)\n        }\n    }\n    \n   \
    \ return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(order_by_points(nums:\
    \ [1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11])\nassert(order_by_points(nums:\
    \ [1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]) == [0, 2,\
    \ 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457])\nassert(order_by_points(nums:\
    \ [] as [Int]) == [] as [Int])\nassert(order_by_points(nums: [1, -11, -32, 43,\
    \ 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54])\nassert(order_by_points(nums:\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n\
    assert(order_by_points(nums: [0, 6, 6, -76, -21, 23, 4]) == [-76, -21, 0, 4, 23,\
    \ 6, 6])"
  status: SyntaxError
  stderr: "/tmp/tmpvrhy0fg8.swift:19:17: error: cannot find 'find' in scope\n    \
    \    let i = find(res, d, stable: true)\n                ^~~~\n/tmp/tmpvrhy0fg8.swift:21:13:\
    \ error: cannot find 'append' in scope\n            append(res, d)\n         \
    \   ^~~~~~\n"
  stdout: ''
  timestamp: 1660009443
