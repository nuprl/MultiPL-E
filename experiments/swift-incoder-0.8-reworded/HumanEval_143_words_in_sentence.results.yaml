language: swift
name: HumanEval_143_words_in_sentence
results:
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let wordArray = sentence.split(separator: \"\
    \ \") else {\n        return \"Error\"\n    }\n    var resultString = \"\"\n \
    \   \n    var resultWord = \"\"\n    var isPrime = true\n    var isDone = false\n\
    \    \n    for i in 1...wordArray.count {\n        let isPrime = true\n      \
    \  for j in 1...i {\n            if i * j == i {\n                isPrime = false\n\
    \                break\n            }\n        }\n        if isPrime {\n     \
    \       resultString += wordArray[i]\n        }\n        if i == wordArray.count\
    \ {\n            if !isDone {\n                resultString += \"and\"\n     \
    \       }\n            isDone = true\n        }\n    }\n    return resultString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8nt56mop.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let wordArray = sentence.split(separator: \" \") else {\n         \
    \ ^               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8nt56mop.swift:30:17:\
    \ error: cannot assign to value: 'isPrime' is a 'let' constant\n             \
    \   isPrime = false\n                ^~~~~~~\n/tmp/tmp8nt56mop.swift:27:9: note:\
    \ change 'let' to 'var' to make it mutable\n        let isPrime = true\n     \
    \   ^~~\n        var\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let chars = sentence.characters.map(String.init)\n\
    \    let charSet = chars.reduce([], { (res, char) -> Bool in\n        let char\
    \ = String(char)\n        if char.isLetter, !res.contains(char) {\n          \
    \  return char.isLetter ? res.append(char) : false\n        }\n        return\
    \ true\n    })\n    return charSet.map { String($0) }.joined(separator: \" \"\
    )\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnqofojr4.swift:17:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = sentence.characters.map(String.init)\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpnqofojr4.swift:18:32: error: cannot convert value of type\
    \ '[Any]' to expected argument type 'Bool'\n    let charSet = chars.reduce([],\
    \ { (res, char) -> Bool in\n                               ^\n/tmp/tmpnqofojr4.swift:20:17:\
    \ error: value of type 'String' has no member 'isLetter'\n        if char.isLetter,\
    \ !res.contains(char) {\n           ~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let wordArray = sentence.components(separatedBy: \"\
    \ \")\n    var result = \"\"\n    for i in wordArray {\n        if i.characters.count\
    \ != 2 {\n            return \"\"\n        } else {\n            for j in 2...i.characters.count\
    \ {\n                if Int(i[j])%2 != 0 {\n                    result += i[j]\n\
    \                }\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphyarniwd.swift:17:30: error: value of type 'String' has no member\
    \ 'components'\n    let wordArray = sentence.components(separatedBy: \" \")\n\
    \                    ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.characters.count == 1, \"The\
    \ input sentence must be a sentence with 1 word.\")\n\n    var newSentence = \"\
    \"\n    var temp = \"\"\n    var primeNumbers = [0]\n    for character in sentence.characters\
    \ {\n        if character == \"a\" || character == \"e\" || character == \"i\"\
    \ || character == \"o\" || character == \"u\" {\n            temp += String(character)\n\
    \            continue\n        }\n        temp += String(UnicodeScalar(Int(character))).unicodeScalars.first!.value\n\
    \        if let _ = Int(UnicodeScalar(Int(character))).unicodeScalars.first!.value,\
    \ primeNumbers.contains(Int(UnicodeScalar(Int(character))).unicodeScalars.first!.value)\
    \ {\n            primeNumbers.append(Int(UnicodeScalar(Int(character))).unicodeScalars.first!.value)\n\
    \            newSentence = newSentence + temp\n            temp = \"\"\n     \
    \   }\n    }\n    newSentence = newSentence + temp\n    return newSentence\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpsx113gem.swift:17:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    precondition(sentence.characters.count == 1, \"The\
    \ input sentence must be a sentence with 1 word.\")\n                        \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpsx113gem.swift:22:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    for character\
    \ in sentence.characters {\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpsx113gem.swift:27:38: error: no exact\
    \ matches in call to initializer \n        temp += String(UnicodeScalar(Int(character))).unicodeScalars.first!.value\n\
    \                                     ^\n/tmp/tmpsx113gem.swift:27:38: note: candidate\
    \ expects value of type 'Float16' for parameter #1 (got 'UnicodeScalar?' (aka\
    \ 'Optional<Unicode.Scalar>'))\n        temp += String(UnicodeScalar(Int(character))).unicodeScalars.first!.value\n\
    \                                     ^\n/tmp/tmpsx113gem.swift:27:38: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>'))\n\
    \        temp += String(UnicodeScalar(Int(character))).unicodeScalars.first!.value\n\
    \                                     ^\n/tmp/tmpsx113gem.swift:27:38: note: candidate\
    \ expects value of type 'Double' for parameter #1 (got 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>'))\n\
    \        temp += String(UnicodeScalar(Int(character))).unicodeScalars.first!.value\n\
    \                                     ^\n/tmp/tmpsx113gem.swift:27:38: note: candidate\
    \ expects value of type 'Float80' for parameter #1 (got 'UnicodeScalar?' (aka\
    \ 'Optional<Unicode.Scalar>'))\n        temp += String(UnicodeScalar(Int(character))).unicodeScalars.first!.value\n\
    \                                     ^\n/tmp/tmpsx113gem.swift:27:38: note: candidate\
    \ expects value of type 'Builtin.Int64' for parameter "
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.characters.count == 1,\n    \
    \    \"words_in_sentence only works on single words.\")\n    if sentence.characters.count\
    \ <= 1 {\n        return \"\"\n    }\n    let words = sentence.characters.split{$0\
    \ == \" \"}.map(String.init)\n    return words.filter{$0.characters.isPrime}.join(\"\
    \ \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqkrq2pch.swift:17:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    precondition(sentence.characters.count == 1,\n    \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpqkrq2pch.swift:19:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    if sentence.characters.count <= 1 {\n             \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpqkrq2pch.swift:22:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let words\
    \ = sentence.characters.split{$0 == \" \"}.map(String.init)\n                \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpqkrq2pch.swift:23:48:\
    \ error: value of type '[String]' has no member 'join'\n    return words.filter{$0.characters.isPrime}.join(\"\
    \ \")\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~\n/tmp/tmpqkrq2pch.swift:23:39:\
    \ error: value of type 'String' has no member 'isPrime'\n    return words.filter{$0.characters.isPrime}.join(\"\
    \ \")\n                        ~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n  // Write your code here.\n  guard let sentenceArray =\
    \ sentence.components(separatedBy: \" \") else {\n    return \"\"\n  }\n\n  var\
    \ result = \"\"\n  var primeLengthsOfWordsGivenInSentence = Int()\n  for word\
    \ in sentenceArray {\n    let word = word.trimmingCharacters(in: \" \".characters)\n\
    \    var isPrime = true\n    for _ in 0..<word.count {\n      if word % 2 == 0\
    \ {\n        isPrime = false\n        break\n      }\n      word /= 2\n    }\n\
    \n    if isPrime {\n      primeLengthsOfWordsGivenInSentence = primeLengthsOfWordsGivenInSentence\
    \ + 1\n    }\n\n    if primeLengthsOfWordsGivenInSentence == Int(word.count) {\n\
    \      result = result + word + \" \";\n    }\n  }\n  return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0xm5hoj.swift:18:38: error: value of type 'String' has no member\
    \ 'components'\n  guard let sentenceArray = sentence.components(separatedBy: \"\
    \ \") else {\n                            ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_(sentence: sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1t068zwi.swift:17:12: error: cannot find 'words_in_sentence_' in\
    \ scope\n    return words_in_sentence_(sentence: sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Write your code here\n    \n    var s = String()\n\
    \    var c = \"\"\n    var l = 0\n    for i in sentence.characters {\n       \
    \ if i.isLetter {\n            c = \"\\(sentence[\\(l)..<i+1])\"\n           \
    \ \n            if ((Int(c.characters.count)) < (Int(i)+1)) {\n              \
    \  c = c + \" \"\n            }\n            s += c\n            l = i\n     \
    \   }\n    }\n    \n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyob5o4mz.swift:22:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in sentence.characters {\n                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpyob5o4mz.swift:24:31:\
    \ error: a Swift key path must begin with a type\n            c = \"\\(sentence[\\\
    (l)..<i+1])\"\n                              ^\n/tmp/tmpyob5o4mz.swift:24:28:\
    \ error: no exact matches in call to subscript \n            c = \"\\(sentence[\\\
    (l)..<i+1])\"\n                           ^\n/tmp/tmpyob5o4mz.swift:24:28: note:\
    \ candidate has partially matching parameter list (String.Index)\n           \
    \ c = \"\\(sentence[\\(l)..<i+1])\"\n                           ^\n/tmp/tmpyob5o4mz.swift:24:28:\
    \ note: candidate has partially matching parameter list (Range<String.Index>)\n\
    \            c = \"\\(sentence[\\(l)..<i+1])\"\n                           ^\n\
    /tmp/tmpyob5o4mz.swift:24:28: note: candidate has partially matching parameter\
    \ list ((UnboundedRange_) -> ())\n            c = \"\\(sentence[\\(l)..<i+1])\"\
    \n                           ^\n/tmp/tmpyob5o4mz.swift:24:34: error: binary operator\
    \ '.<' cannot be applied to operands of type 'WritableKeyPath<_, _>' and 'SIMD2<Float16>'\n\
    \            c = \"\\(sentence[\\(l)..<i+1])\"\n                            ~~~~~^~~~~\n\
    /tmp/tmpyob5o4mz.swift:26:46: error: no exact matches in call to initializer \n\
    \            if ((Int(c.characters.count)) < (Int(i)+1)) {\n                 \
    \                            ^\nSwift.Int:7:12: note: candidate expects value\
    \ of type 'Float16' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float16)\n           ^\nSwift.Int:10:12: note: candidate expects value of type\
    \ 'Float' for parameter #1 (got 'Character')\n    public init(_ source: Float)\n\
    \           ^\nSwift.Int:12:12: note: candidate expects value of type 'Double'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Double)\n    \
    \       ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for\
    \ parameter #1 (got 'Cha"
  stdout: ''
  timestamp: 1659979033
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if word_in_sentence(word) {\n            result += word +\
    \ \" \"\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkvjhv_el.swift:19:12: error: cannot find 'word_in_sentence' in\
    \ scope\n        if word_in_sentence(word) {\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return sentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp0vj7nf6m/tmp0vj7nf6m.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21adde3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21adadab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21adada988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21adad97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0vj7nf6m                        0x000055cbb9c2c307 <unavailable> + 4871

    5    libc.so.6                          0x00002b21adfcf460 __libc_start_main +
    245

    6    tmp0vj7nf6m                        0x000055cbb9c2bf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var sentence = sentence.characters\n\n    // check\
    \ first word (should be in form of digits)\n    if let startIndex = sentence.index(of:\
    \ \"\\d+\") {\n        let firstWord = sentence.prefix(upTo: startIndex)\n   \
    \     let firstWordLength = firstWord.count\n        // if first word is digit,\
    \ then second word can be anything\n        if firstWordLength == 1 {\n      \
    \      let secondWord = sentence.suffix(from: startIndex)\n            let secondWordLength\
    \ = secondWord.count\n            if secondWordLength == 0 {\n               \
    \ return firstWord\n            }\n        }\n    }\n\n    // check all remaining\
    \ words (should be in form of letters)\n    var newSentence = \"\"\n    for i\
    \ in 1..<sentence.count {\n        let word = sentence[i..<(i + 1)]\n        //\
    \ check first word (should be in form of letters)\n        if let index = sentence.index(of:\
    \ \"[a-zA-Z]+\") {\n            let firstWord = sentence.prefix(upTo: index)\n\
    \            let firstWordLength = firstWord.count\n            // if first word\
    \ is letter, then second word can be anything\n            if firstWordLength\
    \ == 1 {\n                let secondWord = sentence.suffix(from: index)\n    \
    \            let secondWordLength = secondWord.count\n                if secondWordLength\
    \ == 0 {\n                    newSentence += firstWord\n                }\n  \
    \          }\n        }\n    }\n    return newSentence\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpgjmq_059.swift:20:46: error: invalid escape sequence in literal\n\
    \    if let startIndex = sentence.index(of: \"\\d+\") {\n                    \
    \                         ^\n/tmp/tmpgjmq_059.swift:17:29: error: 'characters'\
    \ is unavailable: Please use String directly\n    var sentence = sentence.characters\n\
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgjmq_059.swift:20:49: error: missing argument for parameter\
    \ 'where' in call\n    if let startIndex = sentence.index(of: \"\\d+\") {\n  \
    \                                              ^\n                           \
    \                     where: <#(String.Element) throws -> Bool#>\nSwift.Collection:3:28:\
    \ note: 'index(where:)' declared here\n    @inlinable public func index(where\
    \ _predicate: (Self.Element) throws -> Bool) rethrows -> Self.Index?\n       \
    \                    ^\n/tmp/tmpgjmq_059.swift:36:20: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n        let word = sentence[i..<(i + 1)]\n                 \
    \  ^~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript<R>(bounds: R) -> String where\
    \ R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpgjmq_059.swift:38:43:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        if let index = sentence.index(of: \"[a-zA-Z]+\")\
    \ {\n                                          ^\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return solutions(sentence, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp6_35jfyt.swift:17:12: error: cannot find 'solutions' in scope\n\
    \    return solutions(sentence, 0)\n           ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard sentence.characters.count == 0 || Character(sentence[sentence.startIndex])\
    \ == \" \" else { return \"\" }\n    var str = [Character]()\n    var resultString\
    \ = \"\"\n    for c in sentence.characters {\n        guard Character(c) != \"\
    \ \" else { continue }\n        var isPrime = true\n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n            if c % Int(Int(c))! != 0 {\n                isPrime = false\n\
    \                break\n            }\n        }\n        if isPrime {\n     \
    \       str.insert(c, at: 0)\n        }\n    }\n    for c in str {\n        resultString\
    \ += String(describing: c)\n    }\n    return resultString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpjk8cduf7.swift:17:55: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n    guard sentence.characters.count == 0 || Character(sentence[sentence.startIndex])\
    \ == \" \" else { return \"\" }\n                                            \
    \          ^\n                                                      extendedGraphemeClusterLiteral:\
    \ \n/tmp/tmpjk8cduf7.swift:20:23: error: 'characters' is unavailable: Please use\
    \ String directly\n    for c in sentence.characters {\n                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjk8cduf7.swift:21:25:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      guard Character(c) != \" \" else { continue }\n                       \
    \ ^\n                        extendedGraphemeClusterLiteral: \n/tmp/tmpjk8cduf7.swift:23:26:\
    \ error: cannot find 'sqrt' in scope\n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n                         ^~~~\n/tmp/tmpjk8cduf7.swift:23:38: error: no exact\
    \ matches in call to initializer \n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n                                     ^\n/tmp/tmpjk8cduf7.swift:23:38: note:\
    \ found candidate with type '(Float16) -> Int'\n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n                                     ^\n/tmp/tmpjk8cduf7.swift:23:38: note:\
    \ found candidate with type '(Float) -> Int'\n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n                                     ^\n/tmp/tmpjk8cduf7.swift:23:38: note:\
    \ found candidate with type '(Double) -> Int'\n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n                                     ^\n/tmp/tmpjk8cduf7.swift:23:38: note:\
    \ found candidate with type '(Float80) -> Int'\n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n                                     ^\n/tmp/tmpjk8cduf7.swift:23:38: note:\
    \ found candidate with type '(Builtin.Int64) -> Int'\n        for _ in 1...Int(sqrt(Double(Int(c))))+1\
    \ {\n                                 "
  stdout: ''
  timestamp: 1659979024
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return sentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp0vj7nf6m/tmp0vj7nf6m.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21adde3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21adadab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21adada988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21adad97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0vj7nf6m                        0x000055cbb9c2c307 <unavailable> + 4871

    5    libc.so.6                          0x00002b21adfcf460 __libc_start_main +
    245

    6    tmp0vj7nf6m                        0x000055cbb9c2bf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution().words_in_sentence(sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqd3wcn7d.swift:17:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().words_in_sentence(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var list = sentence.characters\n    var result = \"\
    \"\n    for index in 0..<list.count {\n        if isPrimeNumber(index) && isPrimeNumber(list.count)\
    \ {\n            list.append(\" \")\n            list.append(list.last!)\n   \
    \         var temp = list.joined()\n            list.append(temp)\n          \
    \  list.append(\" \")\n            list.append(list.last!)\n            result\
    \ = result.substringToIndex(result.startIndex.advancedBy(index))\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpg5x4gco5.swift:17:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    var list = sentence.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpg5x4gco5.swift:20:12:\
    \ error: cannot find 'isPrimeNumber' in scope\n        if isPrimeNumber(index)\
    \ && isPrimeNumber(list.count) {\n           ^~~~~~~~~~~~~\n/tmp/tmpg5x4gco5.swift:20:36:\
    \ error: cannot find 'isPrimeNumber' in scope\n        if isPrimeNumber(index)\
    \ && isPrimeNumber(list.count) {\n                                   ^~~~~~~~~~~~~\n\
    /tmp/tmpg5x4gco5.swift:23:29: error: no exact matches in call to instance method\
    \ 'joined'\n            var temp = list.joined()\n                           \
    \ ^\nSwift.Sequence:1:11: note: candidate requires that 'String.Element' (aka\
    \ 'Character') conform to 'Sequence' (requirement specified as 'Self.Element'\
    \ : 'Sequence')\nextension Sequence where Self.Element : Sequence {\n        \
    \  ^\nSwift.Sequence:1:11: note: candidate requires that 'String.Element' (aka\
    \ 'Character') conform to 'StringProtocol' (requirement specified as 'Self.Element'\
    \ : 'StringProtocol')\nextension Sequence where Self.Element : StringProtocol\
    \ {\n          ^\nSwift.BidirectionalCollection:1:11: note: candidate requires\
    \ that the types 'String.Element' (aka 'Character') and 'String' be equivalent\
    \ (requirement specified as 'Self.Element' == 'String')\nextension BidirectionalCollection\
    \ where Self.Element == String {\n          ^\n/tmp/tmpg5x4gco5.swift:27:29: error:\
    \ value of type 'String' has no member 'substringToIndex'\n            result\
    \ = result.substringToIndex(result.startIndex.advancedBy(index))\n           \
    \          ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpg5x4gco5.swift:27:64: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n            result = result.substringToIndex(result.startIndex.advancedBy(index))\n\
    \                                             ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.isValid)\n    if sentence.hasPrefix(\"\
    (\") || sentence.hasPrefix(\")\") {\n        return \"\"\n    }\n    var s = sentence\n\
    \    var result = \"\"\n    for word in s.split(separator: \" \") {\n        if\
    \ hasPrime(word: word) {\n            result += \" \" + word\n        }\n    }\n\
    \    \n    return result.trim()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp7v_tmxw2.swift:17:27: error: value of type 'String' has no member\
    \ 'isValid'\n    precondition(sentence.isValid)\n                 ~~~~~~~~ ^~~~~~~\n\
    /tmp/tmp7v_tmxw2.swift:24:12: error: cannot find 'hasPrime' in scope\n       \
    \ if hasPrime(word: word) {\n           ^~~~~~~~\n/tmp/tmp7v_tmxw2.swift:29:19:\
    \ error: value of type 'String' has no member 'trim'\n    return result.trim()\n\
    \           ~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let str = sentence.trimmingCharacters(in: .whitespaces).split(\"\
    \ \").map({ $0.trimmingCharacters(in: .whitespaces) }) else { return \"\" }\n\
    \    guard let set = str.filter { str.contains($0) } .map { str.firstIndex(of:\
    \ $0) } .map { str.distance(from: str[$0]!, to: str[$0]!) }\n        else {return\
    \ \"\"}\n    var result = \"\"\n    for idx in set {\n        if idx % 2 == 0\
    \ {\n            result += str[idx]!\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj1ozgv4f.swift:18:90: error: expected 'else' after 'guard' condition\n\
    \    guard let set = str.filter { str.contains($0) } .map { str.firstIndex(of:\
    \ $0) } .map { str.distance(from: str[$0]!, to: str[$0]!) }\n                \
    \                                                                         ^\n\
    \                                                                            \
    \             else \n/tmp/tmpj1ozgv4f.swift:18:115: error: anonymous closure argument\
    \ not contained in a closure\n    guard let set = str.filter { str.contains($0)\
    \ } .map { str.firstIndex(of: $0) } .map { str.distance(from: str[$0]!, to: str[$0]!)\
    \ }\n                                                                        \
    \                                          ^\n/tmp/tmpj1ozgv4f.swift:18:129: error:\
    \ anonymous closure argument not contained in a closure\n    guard let set = str.filter\
    \ { str.contains($0) } .map { str.firstIndex(of: $0) } .map { str.distance(from:\
    \ str[$0]!, to: str[$0]!) }\n                                                \
    \                                                                            \
    \    ^\n/tmp/tmpj1ozgv4f.swift:19:9: error: expected expression\n        else\
    \ {return \"\"}\n        ^\n/tmp/tmpj1ozgv4f.swift:17:30: error: value of type\
    \ 'String' has no member 'trimmingCharacters'\n    guard let str = sentence.trimmingCharacters(in:\
    \ .whitespaces).split(\" \").map({ $0.trimmingCharacters(in: .whitespaces) })\
    \ else { return \"\" }\n                    ~~~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpj1ozgv4f.swift:17:54:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   guard let str = sentence.trimmingCharacters(in: .whitespaces).split(\" \"\
    ).map({ $0.trimmingCharacters(in: .whitespaces) }) else { return \"\" }\n    \
    \                                                ~^~~~~~~~~~~\n/tmp/tmpj1ozgv4f.swift:17:111:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   guard let str = sentence.trimmingCharacters(in: .whitespaces).split(\" \"\
    ).map({ $0.trimmingCharacters(in: .whitespaces) }) else { return \"\" }\n    \
    \  "
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let primes = prime_factors(sentence)\n    return primes.filter\
    \ { sentence in sentence.characters.count > 0 }.map { sentence + String($0) }.joinWithSeparator(\"\
    \ \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8bwl2idc.swift:17:18: error: cannot find 'prime_factors' in scope\n\
    \    let primes = prime_factors(sentence)\n                 ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979031
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution().words_in_sentence(sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqd3wcn7d.swift:17:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().words_in_sentence(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var words = [String]()\n    \n    for _ in sentence.unicodeScalars\
    \ {\n        words.append(String())\n    }\n    \n    return words.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpxx7d4_ho/tmpxx7d4_ho.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82d88ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82d85f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82d85f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82d85f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxx7d4_ho                        0x00005574070a7657 <unavailable> + 5719

    5    libc.so.6                          0x00002b82d8aeb460 __libc_start_main +
    245

    6    tmpxx7d4_ho                        0x00005574070a7299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var sentence = sentence\n    var result: String = \"\
    \"\n    var j: Int = 0\n    var isPrime = true\n    var i: Int = 0\n    for char1\
    \ in sentence.characters {\n        switch char1 {\n        case \"a\":\n    \
    \    case \"e\":\n        case \"i\":\n        case \"o\":\n        case \"u\"\
    :\n            j = 1\n        default:\n            j = j + 1\n        }\n   \
    \     var j = j + 1\n        var isPrime = true\n        var i: Int = 0\n    \
    \    if j <= j % 2 {\n            if i % 2 == 0 {\n                isPrime = false\n\
    \            } else {\n                isPrime = true\n            }\n       \
    \ }\n        if isPrime == false {\n            for char2 in sentence.characters\
    \ {\n                switch char2 {\n                case \"a\":\n           \
    \     case \"e\":\n                case \"i\":\n                case \"o\":\n\
    \                case \"u\":\n                    if i == char1 {\n          \
    \              result = result + char2\n                        break\n      \
    \              } else {\n                        i += 1\n                    }\n\
    \                default:\n                    i += 1\n                }\n   \
    \         }\n        }\n        if i == j {\n            result = result + char1\n\
    \        }\n        if i == j && isPrime == true {\n            result = result\
    \ + char1\n        }\n        if i == j && isPrime == false {\n            result\
    \ = result + char1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp2s6f52px.swift:24:9: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n        case \"a\":\n        ^~~~~~~~~\n\
    \                  break\n/tmp/tmp2s6f52px.swift:25:9: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n        case \"e\":\n\
    \        ^~~~~~~~~\n                  break\n/tmp/tmp2s6f52px.swift:26:9: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \     case \"i\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp2s6f52px.swift:27:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case \"o\":\n        ^~~~~~~~~\n                  break\n/tmp/tmp2s6f52px.swift:46:17:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \                case \"a\":\n                ^~~~~~~~~\n                    \
    \      break\n/tmp/tmp2s6f52px.swift:47:17: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n                case \"e\":\n \
    \               ^~~~~~~~~\n                          break\n/tmp/tmp2s6f52px.swift:48:17:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \                case \"i\":\n                ^~~~~~~~~\n                    \
    \      break\n/tmp/tmp2s6f52px.swift:49:17: error: 'case' label in a 'switch'\
    \ must have at least one executable statement\n                case \"o\":\n \
    \               ^~~~~~~~~\n                          break\n/tmp/tmp2s6f52px.swift:22:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char1\
    \ in sentence.characters {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp2s6f52px.swift:44:35: error: 'characters'\
    \ is unavailable: Please use String directly\n            for char2 in sentence.characters\
    \ {\n                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/t"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    \n    var result = \"\"\n    var primes = [1]\n    \n    for char in sentence\
    \ {\n        \n        for _ in 0 ..< Int(char.unicodeScalars.count)/2 {\n   \
    \         \n            if primes.contains(&primes.last!) {\n                \n\
    \                primes.append(1)\n                \n            } else {\n  \
    \              \n                if primes.last > Int(char.unicodeScalars.count)/2\
    \ {\n                    \n                    primes.append(1)\n            \
    \        \n                } else {\n                    \n                  \
    \  primes.append(primes.last!+1)\n                    \n                }\n  \
    \              \n            }\n            \n        }\n        \n        result\
    \ += char\n        \n    }\n    \n    return result\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpvl0nbw5h.swift:28:32: error: '&' used with non-inout argument of\
    \ type 'Int'\n            if primes.contains(&primes.last!) {\n              \
    \                 ^~~~~~~~~~~~~\n                               \n/tmp/tmpvl0nbw5h.swift:28:32:\
    \ error: cannot pass immutable value as inout argument: 'last' is a get-only property\n\
    \            if primes.contains(&primes.last!) {\n                           \
    \    ^~~~~~~~~~~~\n/tmp/tmpvl0nbw5h.swift:34:27: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n                if primes.last\
    \ > Int(char.unicodeScalars.count)/2 {\n                          ^\n/tmp/tmpvl0nbw5h.swift:34:27:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n                if primes.last > Int(char.unicodeScalars.count)/2 {\n\
    \                          ^\n                               ?? <#default value#>\n\
    /tmp/tmpvl0nbw5h.swift:34:27: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n                if primes.last > Int(char.unicodeScalars.count)/2\
    \ {\n                          ^\n                              !\n/tmp/tmpvl0nbw5h.swift:48:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result += char\n                  ^\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var res = \"\"\n    let letters = Array(sentence.characters)\n\
    \    for let letter in letters {\n        if (primes?.contains?(letter) == true){\n\
    \            res = res + String(letter)\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppy53vy9s.swift:19:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let letter in letters {\n        ^\n\
    /tmp/tmppy53vy9s.swift:18:34: error: 'characters' is unavailable: Please use String\
    \ directly\n    let letters = Array(sentence.characters)\n                   \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmppy53vy9s.swift:20:13: error: cannot find 'primes' in scope\n    \
    \    if (primes?.contains?(letter) == true){\n            ^~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if let sentence = sentence.split(separator: \" \").map(String.init)\
    \ {\n        var words = [String]()\n        for word in sentence {\n        \
    \    if let word = word.lowercased(), word != \"and\" {\n                words.append(word)\n\
    \            }\n        }\n        if words.contains(where: {Int($0.length) ==\
    \ Int($0.count) && $0.isPrime}) {\n            return words.joined(separator:\
    \ \" \")\n        }\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxohcugek.swift:20:16: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n            if let word = word.lowercased(),\
    \ word != \"and\" {\n               ^          ~~~~~~~~~~~~~~~~~\n/tmp/tmpxohcugek.swift:24:42:\
    \ error: value of type 'String' has no member 'length'\n        if words.contains(where:\
    \ {Int($0.length) == Int($0.count) && $0.isPrime}) {\n                       \
    \               ~~ ^~~~~~\n/tmp/tmpxohcugek.swift:24:73: error: value of type\
    \ 'String' has no member 'isPrime'\n        if words.contains(where: {Int($0.length)\
    \ == Int($0.count) && $0.isPrime}) {\n                                       \
    \                              ~~ ^~~~~~~\n/tmp/tmpxohcugek.swift:17:8: error:\
    \ initializer for conditional binding must have Optional type, not '[String]'\n\
    \    if let sentence = sentence.split(separator: \" \").map(String.init) {\n \
    \      ^              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var outputString = \"\"\n    for wordIndex in 0..<sentence.characters.count\
    \ {\n        if isPrimeNumber(sentence.characters.count - wordIndex - 1) {\n \
    \           let wordIndex = sentence.characters.count - wordIndex - 1\n      \
    \      outputString = outputString + String(sentence.characters.suffix(wordIndex))\n\
    \        }\n    }\n    return outputString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3txvdxqo.swift:18:35: error: 'characters' is unavailable: Please\
    \ use String directly\n    for wordIndex in 0..<sentence.characters.count {\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3txvdxqo.swift:19:12: error: cannot find 'isPrimeNumber'\
    \ in scope\n        if isPrimeNumber(sentence.characters.count - wordIndex - 1)\
    \ {\n           ^~~~~~~~~~~~~\n/tmp/tmp3txvdxqo.swift:20:38: error: 'characters'\
    \ is unavailable: Please use String directly\n            let wordIndex = sentence.characters.count\
    \ - wordIndex - 1\n                                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp3txvdxqo.swift:21:59: error: 'characters'\
    \ is unavailable: Please use String directly\n            outputString = outputString\
    \ + String(sentence.characters.suffix(wordIndex))\n                          \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    if words_in_sentence.reserveCapacity() {\n        words_in_sentence.characters[words_in_sentence.length]\
    \ = sentence[0]\n        for word in sentence.split(separator: \" \") {\n    \
    \        if !words_in_sentence.isPrime(word) {\n                continue\n   \
    \         }\n            words_in_sentence.characters[words_in_sentence.length]\
    \ = word\n            words_in_sentence.length += 1\n        }\n    }\n    return\
    \ words_in_sentence.characters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5vyin4j.swift:20:26: error: value of type '(String) -> String'\
    \ has no member 'reserveCapacity'\n    if words_in_sentence.reserveCapacity()\
    \ {\n       ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpw5vyin4j.swift:21:27: error:\
    \ value of type '(String) -> String' has no member 'characters'\n        words_in_sentence.characters[words_in_sentence.length]\
    \ = sentence[0]\n        ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpw5vyin4j.swift:21:56:\
    \ error: value of type '(String) -> String' has no member 'length'\n        words_in_sentence.characters[words_in_sentence.length]\
    \ = sentence[0]\n                                     ~~~~~~~~~~~~~~~~~ ^~~~~~\n\
    /tmp/tmpw5vyin4j.swift:23:35: error: value of type '(String) -> String' has no\
    \ member 'isPrime'\n            if !words_in_sentence.isPrime(word) {\n      \
    \          ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpw5vyin4j.swift:26:31: error: value\
    \ of type '(String) -> String' has no member 'characters'\n            words_in_sentence.characters[words_in_sentence.length]\
    \ = word\n            ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpw5vyin4j.swift:26:60:\
    \ error: value of type '(String) -> String' has no member 'length'\n         \
    \   words_in_sentence.characters[words_in_sentence.length] = word\n          \
    \                               ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpw5vyin4j.swift:27:31:\
    \ error: value of type '(String) -> String' has no member 'length'\n         \
    \   words_in_sentence.length += 1\n            ~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpw5vyin4j.swift:30:30:\
    \ error: value of type '(String) -> String' has no member 'characters'\n    return\
    \ words_in_sentence.characters\n           ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var newString = \"\"\n    let charArray = sentence.characters\n\n    for\
    \ char in charArray {\n        let currentChar = String(char)\n        if isPrime(number:\
    \ Int64(currentChar)) {\n            if newString.characters.count > 0 {\n   \
    \             newString += \" \"\n            }\n            newString += currentChar\n\
    \        }\n    }\n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfskn7y0z.swift:21:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let charArray = sentence.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfskn7y0z.swift:25:12: error: cannot find 'isPrime' in scope\n   \
    \     if isPrime(number: Int64(currentChar)) {\n           ^~~~~~~\n/tmp/tmpfskn7y0z.swift:26:26:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if newString.characters.count > 0 {\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.isNotEmpty, \"Parameter sentence\
    \ cannot be empty.\")\n    let words = sentence.components(separatedBy: \" \"\
    )\n    let primes = words.map { Int($0)! }\n    return primes.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpf7xztcq0.swift:17:27: error: value of type 'String' has no member\
    \ 'isNotEmpty'\n    precondition(sentence.isNotEmpty, \"Parameter sentence cannot\
    \ be empty.\")\n                 ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpf7xztcq0.swift:18:26:\
    \ error: value of type 'String' has no member 'components'\n    let words = sentence.components(separatedBy:\
    \ \" \")\n                ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Do not write main() function.\n    // Do not read\
    \ input, instead use the arguments to the function.\n    // Do not print the output,\
    \ instead return values to the caller.\n    \n    if sentence.isEmpty {\n    \
    \    return \"\"\n    }\n    \n    let wordCount = sentence.count\n    var newWords\
    \ = \"\"\n    \n    for word in sentence.components(separatedBy: \" \") {\n  \
    \      let wordCount = word.count\n        \n        if isPrime(wordCount) {\n\
    \            newWords.append(word)\n        }\n    }\n    \n    return newWords\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj9k6aynx.swift:28:26: error: value of type 'String' has no member\
    \ 'components'\n    for word in sentence.components(separatedBy: \" \") {\n  \
    \              ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.hasPrefix(\"A valid sentence\
    \ must begin with some letters.\"))\n    precondition(sentence.hasSuffix(\"A valid\
    \ sentence must end with some letters.\"))\n    var res = \"\"\n    for i in 0..<sentence.characters.count\
    \ {\n        var j = i\n        while j != 0 && sentence.characters[j-1] == '\
    \ ' {\n            j--\n        }\n        if j == 0 {\n            res += sentence.characters[i]\n\
    \        } else {\n            res += sentence.characters[i-j ..< i]\n       \
    \ }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp0bnyr1un.swift:22:53: error: single-quoted string literal found,\
    \ use '\"'\n        while j != 0 && sentence.characters[j-1] == ' ' {\n      \
    \                                              ^~~\n                         \
    \                           \" \"\n/tmp/tmp0bnyr1un.swift:20:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in 0..<sentence.characters.count\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp0bnyr1un.swift:22:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        while\
    \ j != 0 && sentence.characters[j-1] == ' ' {\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp0bnyr1un.swift:22:34:\
    \ error: 'characters' is unavailable: Please use String directly\n        while\
    \ j != 0 && sentence.characters[j-1] == ' ' {\n                              \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp0bnyr1un.swift:23:14:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  j--\n             ^~\n/tmp/tmp0bnyr1un.swift:26:39: error: no exact matches\
    \ in call to subscript \n            res += sentence.characters[i]\n         \
    \                             ^\nSwift.String:3:12: note: candidate expects value\
    \ of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmp0bnyr1un.swift:28:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscri"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let words = sentence.split(separator: \" \").map(String.init)\
    \ else {\n        return \"No valid words\"\n    }\n    return words.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprkuwds35.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String]'\n    guard let words = sentence.split(separator:\
    \ \" \").map(String.init) else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.split(separator:\
    \ \" \").reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptpsh56vv.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.split(separator: \"\
    \ \").reversed())\n                             ^\n                          \
    \   sentence: \n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence).map({ $0\
    \ }).joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppnckv005.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence).map({ $0 }).joined()\n\
    \           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var new_sentence = \"\"\n    for let character in sentence\
    \ {\n        if character == \" \" {\n            if new_sentence.isEmpty {\n\
    \                continue\n            } else {\n                new_sentence\
    \ = new_sentence + \" \"\n            }\n        }\n        if Character.isLetter(character)\
    \ {\n            if new_sentence.isEmpty {\n                new_sentence = character\n\
    \            } else {\n                new_sentence = new_sentence + \" \" + character\n\
    \            }\n        }\n    }\n    return new_sentence\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphl65v7hv.swift:18:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let character in sentence {\n     \
    \   ^\n/tmp/tmphl65v7hv.swift:26:22: error: cannot call value of non-function\
    \ type 'Bool'\n        if Character.isLetter(character) {\n                  \
    \   ^\n/tmp/tmphl65v7hv.swift:26:12: error: instance member 'isLetter' cannot\
    \ be used on type 'Character'; did you mean to use a value of this type instead?\n\
    \        if Character.isLetter(character) {\n           ^~~~~~~~~\n/tmp/tmphl65v7hv.swift:28:32:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      new_sentence = character\n                               ^~~~~~~~~\n/tmp/tmphl65v7hv.swift:30:53:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                new_sentence = new_sentence + \" \" + character\n           \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let result = \"\"\n    for wordIndex in sentence.characters.indices\
    \ {\n        if isPrime(index: wordIndex) {\n            result += sentence[wordIndex]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpv5ltfhv9.swift:18:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    for wordIndex in sentence.characters.indices {\n  \
    \                            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpv5ltfhv9.swift:19:12: error: cannot find 'isPrime'\
    \ in scope\n        if isPrime(index: wordIndex) {\n           ^~~~~~~\n/tmp/tmpv5ltfhv9.swift:20:20:\
    \ error: left side of mutating operator isn't mutable: 'result' is a 'let' constant\n\
    \            result += sentence[wordIndex]\n            ~~~~~~ ^\n/tmp/tmpv5ltfhv9.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n\
    \    var\n/tmp/tmpv5ltfhv9.swift:20:31: error: subscript 'subscript(_:)' requires\
    \ that 'DefaultIndices<String>.Element' (aka 'String.Index') conform to 'RangeExpression'\n\
    \            result += sentence[wordIndex]\n                              ^\n\
    Swift.Collection:2:23: note: where 'R' = 'DefaultIndices<String>.Element' (aka\
    \ 'String.Index')\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard len(sentence) >= 1 else {\n        return \"\"\
    \n    }\n    guard let _ = Character.isLetter(sentence[0]) else {\n        return\
    \ \"\"\n    }\n\n    var result: String = \"\"\n    var primeString: String =\
    \ String()\n    for i in 0..<sentence.characters.count {\n        if isPrimeNumber(input:\
    \ Int(String(sentence[i])!)) {\n            primeString = primeString + String(sentence[i])\n\
    \        }\n    }\n    for i in 0..<primeString.characters.count {\n        result\
    \ = result + primeString[i]\n    }\n    return result.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpl_g283ei.swift:17:11: error: cannot find 'len' in scope\n    guard\
    \ len(sentence) >= 1 else {\n          ^~~\n/tmp/tmpl_g283ei.swift:20:29: error:\
    \ cannot call value of non-function type 'Bool'\n    guard let _ = Character.isLetter(sentence[0])\
    \ else {\n                            ^\n/tmp/tmpl_g283ei.swift:20:19: error:\
    \ instance member 'isLetter' cannot be used on type 'Character'; did you mean\
    \ to use a value of this type instead?\n    guard let _ = Character.isLetter(sentence[0])\
    \ else {\n                  ^~~~~~~~~\n/tmp/tmpl_g283ei.swift:26:27: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in 0..<sentence.characters.count\
    \ {\n                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpl_g283ei.swift:27:12: error: cannot find 'isPrimeNumber'\
    \ in scope\n        if isPrimeNumber(input: Int(String(sentence[i])!)) {\n   \
    \        ^~~~~~~~~~~~~\n/tmp/tmpl_g283ei.swift:28:48: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            primeString = primeString + String(sentence[i])\n               \
    \                                ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpl_g283ei.swift:31:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    for i in 0..<primeString.characters.count\
    \ {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpl_g283ei.swift:32:38: error: no exact matches in call\
    \ to subscript \n        result = result + primeString[i]\n                  \
    \                   ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collect"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let letters = sentence.characters.filter { $0.isLetter\
    \ }\n        else { return \"\" }\n    guard let words = letters.components(separatedBy:\
    \ \" \")\n        else { return \"\" }\n\n    var result = \"\"\n    guard let\
    \ n = numbers.firstIndex(of: letters.count),\n        let r = numbers.lastIndex(of:\
    \ letters.count),\n        let index = words.firstIndex(of: letters.count),\n\
    \        let count = words.count else { return \"\" }\n    for _ in 0..<words.count\
    \ {\n        if n > index {\n            let a = words[r]\n            let b =\
    \ words[index]\n            let c = words[count]\n            let d = words[a]\n\
    \            let e = words[b]\n            let f = words[c]\n            let g\
    \ = words[d]\n            let h = words[e]\n            let j = words[f]\n   \
    \         let k = words[g]\n            let l = words[h]\n            let m =\
    \ words[j]\n            let n = words[k]\n            let o = words[l]\n     \
    \       let p = words[m]\n            let q = words[n]\n            let r = words[o]\n\
    \            let s = words[p]\n            let t = words[q]\n            let u\
    \ = words[r]\n            let v = words[s]\n            let w = words[t]\n   \
    \         let x = words[u]\n            let y = words[v]\n            let z =\
    \ words[w]\n            let a = words[x]\n            let b = words[y]\n     \
    \       let c = words[z]\n            let d = letters[s]\n            let e =\
    \ letters[t]\n            let f = letters[u]\n            let g = letters[v]\n\
    \            let h = letters[w]\n            let j = letters[x]\n            let\
    \ k = letters[y]\n            let l = letters[z]\n            let m = letters[c]\n\
    \            let n = letters[d]\n            let o = letters[e]\n            let\
    \ p = letters[f]\n            let q = letters[g]\n            let r = letters[h]\n\
    \            let s = letters[j]\n            let t = letters[k]\n            let\
    \ u = letters[l]\n            let v = letters[m]\n            let w = letters[n]\n\
    \            let x = letters[o]\n            let y = letters[p]\n            let\
    \ z = letters[q]\n            let a = letters[r]\n            let b = letters[s]\n\
    \            let c = letters[t]\n            let d = letters[u]\n            let\
    \ e = letters[v]\n            let f = letters[w]\n            let g = letters[x]\n\
    \            let h = letters[y]\n            let j = letters[z]\n            let\
    \ k = letters[a]\n            let l = letters[b\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptqk0o_d9.swift:17:52: error: expected 'else' after 'guard' condition\n\
    \    guard let letters = sentence.characters.filter { $0.isLetter }\n        \
    \                                           ^\n                              \
    \                     else \n/tmp/tmptqk0o_d9.swift:17:54: error: anonymous closure\
    \ argument not contained in a closure\n    guard let letters = sentence.characters.filter\
    \ { $0.isLetter }\n                                                     ^\n/tmp/tmptqk0o_d9.swift:18:9:\
    \ error: expected expression\n        else { return \"\" }\n        ^\n/tmp/tmptqk0o_d9.swift:90:1:\
    \ error: expected ']' in expression list\n}\n^\n/tmp/tmptqk0o_d9.swift:89:28:\
    \ note: to match this opening '['\n            let l = letters[b\n           \
    \                ^\n/tmp/tmptqk0o_d9.swift:111:55: error: expected '}' at end\
    \ of brace statement\nassert(words_in_sentence(sentence: \"here is\") == \"is\"\
    )\n                                                      ^\n/tmp/tmptqk0o_d9.swift:27:30:\
    \ note: to match this opening '{'\n    for _ in 0..<words.count {\n          \
    \                   ^\n/tmp/tmptqk0o_d9.swift:111:55: error: expected '}' at end\
    \ of brace statement\nassert(words_in_sentence(sentence: \"here is\") == \"is\"\
    )\n                                                      ^\n/tmp/tmptqk0o_d9.swift:16:52:\
    \ note: to match this opening '{'\nfunc words_in_sentence(sentence: String) ->\
    \ String {\n                                                   ^\n/tmp/tmptqk0o_d9.swift:17:34:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard let\
    \ letters = sentence.characters.filter { $0.isLetter }\n                     \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmptqk0o_d9.swift:17:11: error: initializer for conditional binding must\
    \ have Optional type, not '((String.Element) throws -> Bool) throws -> String'\
    \ (aka '((Character) throws -> Bool) throws -> String')\n    guard let letters\
    \ = sentence.characters.filter { $0.isLetter }\n          ^        "
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(\n        1 <= sentence.length && sentence.length\
    \ <= 100, \"invalid input\"\n    )\n\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .characters\n    let alphabetArray = Array(alphabet)\n\n    func checkIfPrime(_\
    \ i: Int) -> Bool {\n        if i == 0 {\n            return false\n        }\n\
    \        if i > 1 {\n            let upperBound = pow(i, 2)\n            for j\
    \ in 1...upperBound {\n                if i != j {\n                    if j <=\
    \ i {\n                        return false\n                    }\n         \
    \       }\n            }\n        }\n        return true\n    }\n\n    var resultString\
    \ = \"\"\n    for word in sentence.split(separator: \" \") {\n        if checkIfPrime(word.length)\
    \ == false {\n            resultString += word + \" \" //\n        }\n    }\n\
    \    return resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpgzby654n.swift:18:23: error: value of type 'String' has no member\
    \ 'length'\n        1 <= sentence.length && sentence.length <= 100, \"invalid\
    \ input\"\n             ~~~~~~~~ ^~~~~~\n/tmp/tmpgzby654n.swift:18:42: error:\
    \ value of type 'String' has no member 'length'\n        1 <= sentence.length\
    \ && sentence.length <= 100, \"invalid input\"\n                             \
    \   ~~~~~~~~ ^~~~~~\n/tmp/tmpgzby654n.swift:21:49: error: 'characters' is unavailable:\
    \ Please use String directly\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .characters\n                                                ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgzby654n.swift:29:30: error: cannot find\
    \ 'pow' in scope\n            let upperBound = pow(i, 2)\n                   \
    \          ^~~\n/tmp/tmpgzby654n.swift:43:30: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'length'\n        if checkIfPrime(word.length)\
    \ == false {\n                        ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    \n    \n    return \"\"\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp0rr1coj0/tmp0rr1coj0.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba997c09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba997900b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba997900988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba9978ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0rr1coj0                        0x000055832cd77307 <unavailable> + 4871

    5    libc.so.6                          0x00002ba997df5460 __libc_start_main +
    245

    6    tmp0rr1coj0                        0x000055832cd76f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let words = sentence.components(separatedBy:\
    \ \" \") else { return \"\" }\n    var primes = Set<Int>()\n    var resultString\
    \ = \"\"\n    for word in words {\n        let word = word.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics)\n        if word == \"\" { continue }\n        guard\
    \ let number = Int(word) else { return \"\" }\n        if primes.contains(number)\
    \ {\n            resultString.append(word)\n        }\n        primes.insert(number)\n\
    \    }\n    return resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_f88e2je.swift:17:32: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = sentence.components(separatedBy: \" \")\
    \ else { return \"\" }\n                      ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp_f88e2je.swift:21:48:\
    \ error: cannot find 'CharacterSet' in scope\n        let word = word.trimmingCharacters(in:\
    \ CharacterSet.alphanumerics)\n                                              \
    \ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    let wordLengths = (words ?? []).map({ $0.characters.count })\n    let primeLengths\
    \ = primes.filter({ wordLengths.contains($0.longTerm) })\n    return primeLengths.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpgwnmrawx.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpgwnmrawx.swift:18:46: error: value of\
    \ type '[Any]' has no member 'characters'\n    let wordLengths = (words ?? []).map({\
    \ $0.characters.count })\n                                          ~~ ^~~~~~~~~~\n\
    /tmp/tmpgwnmrawx.swift:19:24: error: cannot find 'primes' in scope\n    let primeLengths\
    \ = primes.filter({ wordLengths.contains($0.longTerm) })\n                   \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.characters.count == 0 {\n        return\
    \ \"\"\n    }\n    var word = \"\"\n    for character in sentence.characters {\n\
    \        word = word + String(character)\n    }\n    return words_in_word(word:\
    \ word, sentences: sentence)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpltkq1p4s.swift:17:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    if sentence.characters.count == 0 {\n             \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpltkq1p4s.swift:21:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    for character\
    \ in sentence.characters {\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpltkq1p4s.swift:24:12: error: cannot find\
    \ 'words_in_word' in scope\n    return words_in_word(word: word, sentences: sentence)\n\
    \           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    .characters)\n    var result = \"\"\n    for letter in sentence.characters {\n\
    \        if let index = alphabet.index(of: letter) {\n            if isPrimeNumber(index:\
    \ index) {\n                result += String(letter)\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpvcue6fdu.swift:17:55: error: 'characters' is unavailable: Please\
    \ use String directly\n    let alphabet = Array(\"abcdefghijklmnopqrstuvwxyz\"\
    .characters)\n                                                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvcue6fdu.swift:19:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in sentence.characters {\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpvcue6fdu.swift:20:33: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        if let index = alphabet.index(of:\
    \ letter) {\n                                ^\n/tmp/tmpvcue6fdu.swift:20:33:\
    \ note: use 'firstIndex(of:)' instead\n        if let index = alphabet.index(of:\
    \ letter) {\n                                ^~~~~\n                         \
    \       firstIndex\n/tmp/tmpvcue6fdu.swift:21:16: error: cannot find 'isPrimeNumber'\
    \ in scope\n            if isPrimeNumber(index: index) {\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if prime_number(word) {\n            result += word\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp34bwblhv.swift:19:12: error: cannot find 'prime_number' in scope\n\
    \        if prime_number(word) {\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    func isPrime(max: Int) -> Bool {\n        return max\
    \ > 1 && max <= maxNumber\n    }\n    \n    if let _ = sentence.index(of: \" \"\
    ) where sentence.count > 1 {\n        let maxNumber = sentence.count + 1\n   \
    \     var result = \"\"\n        for word in sentence.components(separatedBy:\
    \ \" \") {\n            if let n = Int(word) {\n                if isPrime(n)\
    \ {\n                    result += word\n                }\n            }\n  \
    \      }\n        return result\n    }\n    \n    if let _ = sentence.index(of:\
    \ \" \") where sentence.count > 1 {\n        let maxNumber = sentence.count +\
    \ 1\n        var result = \"\"\n        for word in sentence.components(separatedBy:\
    \ \" \") {\n            if let n = Int(word) {\n                result += String(word)\n\
    \            }\n        }\n        return result\n    }\n    \n    return \"\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfluwc8bd.swift:21:40: error: expected ',' joining parts of a multi-clause\
    \ condition\n    if let _ = sentence.index(of: \" \") where sentence.count > 1\
    \ {\n                                      ~^~~~~\n                          \
    \            ,\n/tmp/tmpfluwc8bd.swift:34:40: error: expected ',' joining parts\
    \ of a multi-clause condition\n    if let _ = sentence.index(of: \" \") where\
    \ sentence.count > 1 {\n                                      ~^~~~~\n       \
    \                               ,\n/tmp/tmpfluwc8bd.swift:18:34: error: cannot\
    \ find 'maxNumber' in scope\n        return max > 1 && max <= maxNumber\n    \
    \                             ^~~~~~~~~\n/tmp/tmpfluwc8bd.swift:21:25: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    if let _ = sentence.index(of:\
    \ \" \") where sentence.count > 1 {\n                        ^\n/tmp/tmpfluwc8bd.swift:21:25:\
    \ note: use 'firstIndex(of:)' instead\n    if let _ = sentence.index(of: \" \"\
    ) where sentence.count > 1 {\n                        ^~~~~\n                \
    \        firstIndex\n/tmp/tmpfluwc8bd.swift:24:30: error: value of type 'String'\
    \ has no member 'components'\n        for word in sentence.components(separatedBy:\
    \ \" \") {\n                    ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpfluwc8bd.swift:34:25:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    if let\
    \ _ = sentence.index(of: \" \") where sentence.count > 1 {\n                 \
    \       ^\n/tmp/tmpfluwc8bd.swift:34:25: note: use 'firstIndex(of:)' instead\n\
    \    if let _ = sentence.index(of: \" \") where sentence.count > 1 {\n       \
    \                 ^~~~~\n                        firstIndex\n/tmp/tmpfluwc8bd.swift:37:30:\
    \ error: value of type 'String' has no member 'components'\n        for word in\
    \ sentence.components(separatedBy: \" \") {\n                    ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentenceIter(sentence.characters) +\
    \ \" \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp40wbdm9l.swift:17:12: error: cannot find 'words_in_sentenceIter'\
    \ in scope\n    return words_in_sentenceIter(sentence.characters) + \" \"\n  \
    \         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkt17580h.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.characters.map(String.init))\n\
    \                             ^\n                             sentence: \n/tmp/tmpkt17580h.swift:17:50:\
    \ error: cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return words_in_sentence(sentence.characters.map(String.init))\n        \
    \                                         ^\n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let mut stringBuilder = StringBuilder()\n    for ch\
    \ in sentence.characters {\n        if ch >= 'a' && ch <= 'z' || ch >= 'A' &&\
    \ ch <= 'Z' {\n            stringBuilder.append(ch)\n        } else {\n      \
    \      stringBuilder.append(\"-\")\n        }\n    }\n    let re = regex(r\"\\\
    b\\S+\\b\")\n    for match in re.matchesInString(stringBuilder.toString()) {\n\
    \        if let range = Range(match.range(at: 1), in: stringBuilder) {\n     \
    \       let str1 = stringBuilder.substring(with: range)\n            if str1.characters.count\
    \ == 1 {\n                stringBuilder.replaceSubrange(range, with: \"-\")\n\
    \            }\n        }\n    }\n    return stringBuilder.toString()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmplv1y_tjv.swift:17:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut stringBuilder\
    \ = StringBuilder()\n            ^\n/tmp/tmplv1y_tjv.swift:17:13: note: join the\
    \ identifiers together\n    let mut stringBuilder = StringBuilder()\n        ~~~~^~~~~~~~~~~~~\n\
    \        mutstringBuilder\n/tmp/tmplv1y_tjv.swift:17:13: note: join the identifiers\
    \ together with camel-case\n    let mut stringBuilder = StringBuilder()\n    \
    \    ~~~~^~~~~~~~~~~~~\n        mutStringBuilder\n/tmp/tmplv1y_tjv.swift:19:18:\
    \ error: single-quoted string literal found, use '\"'\n        if ch >= 'a' &&\
    \ ch <= 'z' || ch >= 'A' && ch <= 'Z' {\n                 ^~~\n              \
    \   \"a\"\n/tmp/tmplv1y_tjv.swift:19:31: error: single-quoted string literal found,\
    \ use '\"'\n        if ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' {\n  \
    \                            ^~~\n                              \"z\"\n/tmp/tmplv1y_tjv.swift:19:44:\
    \ error: single-quoted string literal found, use '\"'\n        if ch >= 'a' &&\
    \ ch <= 'z' || ch >= 'A' && ch <= 'Z' {\n                                    \
    \       ^~~\n                                           \"A\"\n/tmp/tmplv1y_tjv.swift:19:57:\
    \ error: single-quoted string literal found, use '\"'\n        if ch >= 'a' &&\
    \ ch <= 'z' || ch >= 'A' && ch <= 'Z' {\n                                    \
    \                    ^~~\n                                                   \
    \     \"Z\"\n/tmp/tmplv1y_tjv.swift:25:23: error: invalid escape sequence in literal\n\
    \    let re = regex(r\"\\b\\S+\\b\")\n                      ^\n/tmp/tmplv1y_tjv.swift:25:25:\
    \ error: invalid escape sequence in literal\n    let re = regex(r\"\\b\\S+\\b\"\
    )\n                        ^\n/tmp/tmplv1y_tjv.swift:25:28: error: invalid escape\
    \ sequence in literal\n    let re = regex(r\"\\b\\S+\\b\")\n                 \
    \          ^\n/tmp/tmplv1y_tjv.swift:17:29: error: cannot find 'StringBuilder'\
    \ in scope\n    let mut stringBuilder = StringBuilder()\n                    \
    \        ^~~~~~~~~~~~~\n/tmp/tmplv1y_tjv.swift:18:24: error: 'characters' is unavailable:\
    \ Please use S"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Write your code here\n    let words = sentence.characters.split{$0\
    \ == \" \"}.map { String($0) }\n    var sortedWords = words.sorted()\n    var\
    \ ret = \"\"\n    var count = 0\n    for word in sortedWords {\n        count\
    \ += Int(word).isPrime\n        if count == 2 {\n            ret += word\n   \
    \         count = 0\n        }\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpu51ion7z.swift:18:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let words = sentence.characters.split{$0 == \" \"}.map\
    \ { String($0) }\n                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpu51ion7z.swift:23:28: error: value of type\
    \ 'Int?' has no member 'isPrime'\n        count += Int(word).isPrime\n       \
    \          ~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for character in sentence {\n\
    \        if character == \" \" {\n            for _ in 0..<(result.characters.count\
    \ - 1) {\n                if Int(result.characters.characters[result.characters.count\
    \ - 1]) % (Int(character) - Int(result)) <= 0 {\n                    break\n \
    \               }\n            }\n        } else {\n            result += String(character)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfqhpim5c.swift:20:34: error: 'characters' is unavailable: Please\
    \ use String directly\n            for _ in 0..<(result.characters.count - 1)\
    \ {\n                                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfqhpim5c.swift:21:20: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n                if Int(result.characters.characters[result.characters.count\
    \ - 1]) % (Int(character) - Int(result)) <= 0 {\n                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979048
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    // Solution 3\n    let words\
    \ = sentence.components(separatedBy: \" \")\n    var result = \"\"\n    for word\
    \ in words {\n        let length = Int(word.count)\n        if length > 0 && isPrimeNumber(length)\
    \ == true {\n            result += \" \" + word\n        }\n    }\n    return\
    \ result.trimmingCharacters(in: .whitespacesAndNewlines)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp7kyxlwab.swift:19:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp7kyxlwab.swift:27:19: error: value of\
    \ type 'String' has no member 'trimmingCharacters'\n    return result.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n           ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp7kyxlwab.swift:27:43:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    return result.trimmingCharacters(in: .whitespacesAndNewlines)\n         \
    \                                ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n  // Your code goes here\n    return \"\"\n  }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: '/tmp/tmp__9giadb.swift:20:1: error: extraneous ''}'' at top level

    }

    ^

    '
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result: String = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        var len: Int = 2\n        for char in word {\n            len\
    \ *= Int(UnicodeScalar(char.value - 97).value)\n        }\n        if len != 0\
    \ {\n            result += word\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp0hjpad72.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.components(separatedBy: \" \"\
    )\n    let wordCount = words.count\n    let maxLen = sqrt(Double(wordCount))\n\
    \    var result = \"\"\n    var primesFound = [Bool](repeating: false, count:\
    \ maxLen)\n    for word in words {\n        var count = 0\n        for primes\
    \ in 0 ..< maxLen {\n            if primesFound[primes] || !primesFound[primes\
    \ * 2] {\n                let nextPrime = primes + 2\n                let nextPrimeIndex\
    \ = Int(pow(Double(nextPrime), Double(word.count)))\n                if nextPrimeIndex\
    \ == primes || (nextPrimeIndex >= wordCount && nextPrimeIndex <= maxLen) {\n \
    \                   count += 1\n                    if count >= primes {\n   \
    \                     primesFound[primes] = true\n                    }\n    \
    \                break\n                }\n            }\n        }\n        if\
    \ count == maxLen {\n            result += word\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxtshxf0a.swift:17:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpxtshxf0a.swift:19:18: error: cannot\
    \ find 'sqrt' in scope\n    let maxLen = sqrt(Double(wordCount))\n           \
    \      ^~~~\n/tmp/tmpxtshxf0a.swift:27:42: error: cannot find 'pow' in scope\n\
    \                let nextPrimeIndex = Int(pow(Double(nextPrime), Double(word.count)))\n\
    \                                         ^~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return solution(NIOS(sentence))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmplcgv7cx5.swift:17:12: error: cannot find 'solution' in scope\n\
    \    return solution(NIOS(sentence))\n           ^~~~~~~~\n/tmp/tmplcgv7cx5.swift:17:21:\
    \ error: cannot find 'NIOS' in scope\n    return solution(NIOS(sentence))\n  \
    \                  ^~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // init result array\n    var result = [String]()\n\
    \    // init prime counter\n    var primeCounter = 1\n    // init counter for\
    \ words\n    var counter = 1\n    // init word\n    var word = String()\n    //\
    \ loop sentence\n    for char in sentence.characters {\n        // create char\
    \ from chars index\n        let charInt = Int(char)\n        // check if char\
    \ is a space\n        if charInt <= 32 {\n            // add char to word\n  \
    \          word += String(char)\n        } else {\n            // check if counter\
    \ is prime\n            if isPrime(counter) {\n                // add current\
    \ word to result array\n                result.append(word)\n                //\
    \ reset word\n                word = String(char)\n            }\n           \
    \ // update counter for word\n            counter++\n        }\n    }\n    //\
    \ add last word\n    result.append(word)\n    // return result array\n    return\
    \ result.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp7owu6iw5.swift:26:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp7owu6iw5.swift:28:23: error: no exact matches in call to initializer \n\
    \        let charInt = Int(char)\n                      ^\nSwift.Int:7:12: note:\
    \ candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n           ^\nSwift.FixedWidthInteger:3:23: note: candidate\
    \ expects value of type 'String' for parameter #1 (got 'Character')\n    @inlinable\
    \ public init?(_ description: String)\n                      ^\n/tmp/tmp7owu6iw5.swift:35:16:\
    \ error: cannot find 'isPrime' in scope\n            if isPrime(counter) {\n \
    \              ^~~~~~~\n/tmp/tmp7owu6iw5.swift:42:20: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            counter++\n               \
    \    ^~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4k55c3ne.swift:17:60: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n    return words_in_sentence(sentence: sentence.characters.map(String.init))\n\
    \                                                           ^\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return __words_in_sentence_c99(sentence)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp9y46wyz9.swift:17:12: error: cannot find '__words_in_sentence_c99'\
    \ in scope\n    return __words_in_sentence_c99(sentence)\n           ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return NSString(string: sentence).componentsSeparatedByString(\"\
    \ \")\n        .filter({(word: String) -> Bool in\n            return word.lengthOfBytes(using:\
    \ .UTF8) > 0 && word.isPrimeNumber()\n        })\n        .map({word in\n    \
    \        return NSString(string: word).stringByTrimmingCharactersInSet(\n    \
    \            NSCharacterSet.whitespaceCharacterSet()\n            )\n        })\n\
    \        .joinWithSeparator(\" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnr0yg0er.swift:17:12: error: cannot find 'NSString' in scope\n\
    \    return NSString(string: sentence).componentsSeparatedByString(\" \")\n  \
    \         ^~~~~~~~\n/tmp/tmpnr0yg0er.swift:22:20: error: cannot find 'NSString'\
    \ in scope\n            return NSString(string: word).stringByTrimmingCharactersInSet(\n\
    \                   ^~~~~~~~\n/tmp/tmpnr0yg0er.swift:23:17: error: cannot find\
    \ 'NSCharacterSet' in scope\n                NSCharacterSet.whitespaceCharacterSet()\n\
    \                ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(\n        sentence: sentence,\n\
    \        separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpe2c4m4u3.swift:19:20: error: extra argument 'separator' in call\n\
    \        separator: \" \")\n~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let charArray = sentence.characters\n    let wordArray\
    \ = sentence.components(separatedBy: \" \")\n    var resultString = \"\"\n   \
    \ for word in wordArray {\n        if isPrime(word.characters.count) {\n     \
    \       resultString = resultString + word\n        }\n    }\n    return resultString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj4svb7ye.swift:17:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let charArray = sentence.characters\n             \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpj4svb7ye.swift:18:30: error: value of type 'String' has no member\
    \ 'components'\n    let wordArray = sentence.components(separatedBy: \" \")\n\
    \                    ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard sentence.count <= 100 else { return \"\" }\n\
    \    guard let charArray = sentence.characters, !charArray.isEmpty else { return\
    \ \"\" }\n    var result = \"\"\n    var isPrime = true\n    for char in charArray\
    \ {\n        if isPrime {\n            if char == \" \" {\n                isPrime\
    \ = false\n            } else {\n                let div = Int(String(char).unicodeScalars.first!.value\
    \ - 97)\n                if div != 0 {\n                    if div == 2 {\n  \
    \                      isPrime = false\n                    } else if div == 3\
    \ {\n                        result += String(char)\n                    } else\
    \ if div == 5 {\n                        result += String(char) + \" \"\n    \
    \                } else if div % 2 == 0 {\n                        result += String(char)\n\
    \                    } else if div % 3 == 0 {\n                        result\
    \ += String(char) + \" \"\n                    } else if div % 5 == 0 {\n    \
    \                    result += String(char) + \" \"\n                    } else\
    \ {\n                        result += String(char) + \" \"\n                \
    \    }\n                } else {\n                    isPrime = false\n      \
    \          }\n            }\n        } else {\n            if char == \" \" {\n\
    \                isPrime = true\n            } else {\n                let div\
    \ = Int(String(char).unicodeScalars.first!.value - 97)\n                if div\
    \ != 0 {\n                    if div % 2 == 0 {\n                        result\
    \ += String(char)\n                    } else if div % 3 == 0 {\n            \
    \            result += String(char) + \" \"\n                    } else {\n  \
    \                      result += String(char) + \" \"\n                    }\n\
    \                } else {\n                    isPrime = true\n              \
    \  }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp078qp7l_.swift:18:36: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let charArray = sentence.characters, !charArray.isEmpty\
    \ else { return \"\" }\n                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp078qp7l_.swift:18:11: error: initializer\
    \ for conditional binding must have Optional type, not 'String'\n    guard let\
    \ charArray = sentence.characters, !charArray.isEmpty else { return \"\" }\n \
    \         ^               ~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution().wordsInSentence(sentence: sentence)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpy_yt6xfz.swift:17:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().wordsInSentence(sentence: sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.length > 0)\n    let sentenceArray\
    \ = sentence.components(separatedBy: \" \")\n    let result = String()\n    for\
    \ word in sentenceArray {\n        if Int((word.count) + 1) >= Int(word.count)\
    \ {\n            result += \"\\(word)\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpk30ynqhz.swift:17:27: error: value of type 'String' has no member\
    \ 'length'\n    precondition(sentence.length > 0)\n                 ~~~~~~~~ ^~~~~~\n\
    /tmp/tmpk30ynqhz.swift:18:34: error: value of type 'String' has no member 'components'\n\
    \    let sentenceArray = sentence.components(separatedBy: \" \")\n           \
    \             ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var stringToTest = sentence\n\
    \    \n    stringToTest = stringToTest.lowercased()\n    let wordsArray = stringToTest.components(separatedBy:\
    \ \" \")\n    let newString = \"\"\n    for word in wordsArray {\n        let\
    \ word = word.lowercased()\n        if isPrime(word: word!, primeNumber: (wordsArray.count\
    \ + 1)) && !newString.containsString(word) {\n            newString += word\n\
    \        }\n    }\n    \n    return newString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphajvn_ni.swift:21:35: error: value of type 'String' has no member\
    \ 'components'\n    let wordsArray = stringToTest.components(separatedBy: \" \"\
    )\n                     ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence.toLower(), sentence.characters.count\
    \ == sentence.count else { return \"\" }\n    \n    let re = NSRegularExpression(pattern:\
    \ \"\\\\s+\", options: .caseInsensitive)\n    let matches = re.matches(in: sentence,\
    \ range: NSMakeRange(0, sentence.characters.count))\n    \n    var resultString\
    \ = \"\"\n    for match in matches {\n        let wordRange = match.range\n  \
    \      resultString += String(sentence.substring(with: wordRange))\n    }\n  \
    \  \n    return resultString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1mfqaie3.swift:17:35: error: value of type 'String' has no member\
    \ 'toLower'\n    guard let sentence = sentence.toLower(), sentence.characters.count\
    \ == sentence.count else { return \"\" }\n                         ~~~~~~~~ ^~~~~~~\n\
    /tmp/tmp1mfqaie3.swift:19:14: error: cannot find 'NSRegularExpression' in scope\n\
    \    let re = NSRegularExpression(pattern: \"\\\\s+\", options: .caseInsensitive)\n\
    \             ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp1mfqaie3.swift:19:61: error: cannot\
    \ infer contextual base in reference to member 'caseInsensitive'\n    let re =\
    \ NSRegularExpression(pattern: \"\\\\s+\", options: .caseInsensitive)\n      \
    \                                                     ~^~~~~~~~~~~~~~~\n/tmp/tmp1mfqaie3.swift:20:51:\
    \ error: cannot find 'NSMakeRange' in scope\n    let matches = re.matches(in:\
    \ sentence, range: NSMakeRange(0, sentence.characters.count))\n              \
    \                                    ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpp66_gpar/tmpp66_gpar.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada2edf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada2eaeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada2eaea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada2eae97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp66_gpar                        0x000055738abff307 <unavailable> + 4871

    5    libc.so.6                          0x00002ada2efdf460 __libc_start_main +
    245

    6    tmpp66_gpar                        0x000055738abfef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978892
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n\n    for c in sentence.cString(using:\
    \ String.Encoding.utf8) {\n        let letter = String(c)\n        let isPrime\
    \ = primeNumberOf(c: letter) != nil\n\n        if isPrime {\n            result\
    \ += c\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxa_y1z7k.swift:19:23: error: value of type 'String' has no member\
    \ 'cString'\n    for c in sentence.cString(using: String.Encoding.utf8) {\n  \
    \           ~~~~~~~~ ^~~~~~~\n/tmp/tmpxa_y1z7k.swift:19:45: error: type 'String'\
    \ has no member 'Encoding'\n    for c in sentence.cString(using: String.Encoding.utf8)\
    \ {\n                                     ~~~~~~ ^~~~~~~~\n/tmp/tmpxa_y1z7k.swift:21:23:\
    \ error: cannot find 'primeNumberOf' in scope\n        let isPrime = primeNumberOf(c:\
    \ letter) != nil\n                      ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    var newSentence = \"\"\n    for letter in sentence.characters {\n       \
    \ if isPrime(Int(letter)) {\n            newSentence = newSentence + String(letter)\n\
    \        }\n    }\n    return newSentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpob3a3o2e.swift:21:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpob3a3o2e.swift:22:12: error: cannot find 'isPrime' in scope\n   \
    \     if isPrime(Int(letter)) {\n           ^~~~~~~\n/tmp/tmpob3a3o2e.swift:22:20:\
    \ error: no exact matches in call to initializer \n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpob3a3o2e.swift:22:20: note: found candidate\
    \ with type '(Float16) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpob3a3o2e.swift:22:20: note: found candidate with type '(Float)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpob3a3o2e.swift:22:20:\
    \ note: found candidate with type '(Double) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpob3a3o2e.swift:22:20: note: found candidate\
    \ with type '(Float80) -> Int'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n/tmp/tmpob3a3o2e.swift:22:20: note: found candidate with type '(Builtin.Int64)\
    \ -> Int'\n        if isPrime(Int(letter)) {\n                   ^\n/tmp/tmpob3a3o2e.swift:22:20:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        if isPrime(Int(letter))\
    \ {\n                   ^\n/tmp/tmpob3a3o2e.swift:22:20: note: found candidate\
    \ with type '(String) -> Int?'\n        if isPrime(Int(letter)) {\n          \
    \         ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp3qm8spq4/tmp3qm8spq4.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6377583c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b637727ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b637727a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63772797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3qm8spq4                        0x000055801f6c1307 <unavailable> + 4871

    5    libc.so.6                          0x00002b637776f460 __libc_start_main +
    245

    6    tmp3qm8spq4                        0x000055801f6c0f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var prime = 0\n    var found\
    \ = 0\n    for ch in sentence.characters {\n        if isPrime(prime) {\n    \
    \        result += ch\n            found = 1\n        }\n        prime++\n   \
    \ }\n    if found == 0 {\n        return result\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8qla90ny.swift:20:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for ch in sentence.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp8qla90ny.swift:21:12:\
    \ error: cannot find 'isPrime' in scope\n        if isPrime(prime) {\n       \
    \    ^~~~~~~\n/tmp/tmp8qla90ny.swift:22:23: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            result += ch\n \
    \                     ^\n/tmp/tmp8qla90ny.swift:25:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n        prime++\n             ^~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_0(sentence)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphsrpv63d.swift:17:12: error: cannot find 'words_in_sentence_0'\
    \ in scope\n    return words_in_sentence_0(sentence)\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return sentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp0vj7nf6m/tmp0vj7nf6m.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21adde3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21adadab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21adada988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21adad97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0vj7nf6m                        0x000055cbb9c2c307 <unavailable> + 4871

    5    libc.so.6                          0x00002b21adfcf460 __libc_start_main +
    245

    6    tmp0vj7nf6m                        0x000055cbb9c2bf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result: [String] = []\n    var words: String\n\
    \    for s in sentence.split(separator: \" \") {\n        if s.count > 0 {\n \
    \           if words == \"\" {\n                words = s\n            } else\
    \ {\n                if isPrime(Int(words[s.startIndex..<s.endIndex])) {\n   \
    \                 result.append(words)\n                }\n                words\
    \ = s\n            }\n        }\n    }\n    if words != \"\" {\n        result.append(words)\n\
    \    }\n    return result.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpejz3pxji.swift:22:25: error: cannot assign value of type 'String.SubSequence'\
    \ (aka 'Substring') to type 'String'\n                words = s\n            \
    \            ^\n                        String( )\n/tmp/tmpejz3pxji.swift:24:20:\
    \ error: cannot find 'isPrime' in scope\n                if isPrime(Int(words[s.startIndex..<s.endIndex]))\
    \ {\n                   ^~~~~~~\n/tmp/tmpejz3pxji.swift:27:25: error: cannot assign\
    \ value of type 'String.SubSequence' (aka 'Substring') to type 'String'\n    \
    \            words = s\n                        ^\n                        String(\
    \ )\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_in_text_formatter(sentence)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptfl_wc1l.swift:17:12: error: cannot find 'words_in_sentence_in_text_formatter'\
    \ in scope\n    return words_in_sentence_in_text_formatter(sentence)\n       \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if let sentence = sentence.lowercased() {\n       \
    \ if let splits = sentence.components(separatedBy: \" \") {\n            let isPrime\
    \ = splits.filter { Int($0).isPrime }\n            return isPrime.joined(separator:\
    \ \" \")\n        } else {\n            return \"\"\n        }\n    } else {\n\
    \        return \"\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmph1llj45x.swift:18:34: error: value of type 'String' has no member\
    \ 'components'\n        if let splits = sentence.components(separatedBy: \" \"\
    ) {\n                        ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmph1llj45x.swift:19:51:\
    \ error: reference to member 'isPrime' cannot be resolved without a contextual\
    \ type\n            let isPrime = splits.filter { Int($0).isPrime }\n        \
    \                                          ^\n/tmp/tmph1llj45x.swift:17:8: error:\
    \ initializer for conditional binding must have Optional type, not 'String'\n\
    \    if let sentence = sentence.lowercased() {\n       ^              ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence1(sentence)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpmk_k8wvs.swift:17:12: error: cannot find 'words_in_sentence1' in\
    \ scope\n    return words_in_sentence1(sentence)\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if prime_number(word) == true {\n            result = result\
    \ + word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp2dt0tzvr.swift:19:12: error: cannot find 'prime_number' in scope\n\
    \        if prime_number(word) == true {\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    let chars = sentence.characters\n    var primes = String()\n    for x in\
    \ 1..<chars.count {\n        for y in 2..<chars.count {\n            if chars[x]\
    \ == chars[y] {\n                if x % y == 0 {\n                    primes +=\
    \ \" \" + String(chars[x])\n                    break\n                } else\
    \ {\n                    primes += \" \" + String(chars[x])\n                }\n\
    \            }\n        }\n    }\n    primes = primes.characters.prefix(Int(chars.count))\n\
    \    return primes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpy8shvlwq.swift:20:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = sentence.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpy8shvlwq.swift:24:16:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            if chars[x] == chars[y] {\n       \
    \        ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpy8shvlwq.swift:24:28: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if chars[x] == chars[y] {\n                           ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpy8shvlwq.swift:26:44:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                    primes += \" \" + String(chars[x])\n\
    \                                           ^~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpy8shvlwq.swift:29:44: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n                    primes += \" \" + String(chars[x])\n         \
    \                                  ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpy8shvlwq.swift:34:32: error: no 'prefix'\
    \ candidates produce the expected contextual result type 'String'\n    primes\
    \ = primes.characters.prefix(Int(chars.count))\n                             \
    \  ^\nSwift.Sequence:7:40: note: 'prefix' produces 'PrefixSequence<String>', not\
    \ the "
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let chars = sentence.characters.split(separator:\
    \ \" \").map(String.init) else {\n        return \"no words found\"\n    }\n \
    \   \n    var result = \"\"\n    for char in chars {\n        let str = String(char)\n\
    \        if str.isPrime(of: 2) && result.characters.count == 0 {\n           \
    \ result += str\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpheymqipw.swift:17:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard let chars = sentence.characters.split(separator:\
    \ \" \").map(String.init) else {\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpheymqipw.swift:17:11:\
    \ error: initializer for conditional binding must have Optional type, not '[String]'\n\
    \    guard let chars = sentence.characters.split(separator: \" \").map(String.init)\
    \ else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpheymqipw.swift:24:16: error: value of type 'String' has no member 'isPrime'\n\
    \        if str.isPrime(of: 2) && result.characters.count == 0 {\n           ~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let regex = NSRegularExpression(pattern: \"\\\\s+\"\
    , options: [])\n    return regex.stringByReplacingMatchesInString(sentence, options:\
    \ [], range: NSMakeRange(0, sentence.length), withTemplate: \"\")\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn3mty5d.swift:17:17: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = NSRegularExpression(pattern: \"\\\\s+\", options:\
    \ [])\n                ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpxn3mty5d.swift:18:81: error:\
    \ cannot find 'NSMakeRange' in scope\n    return regex.stringByReplacingMatchesInString(sentence,\
    \ options: [], range: NSMakeRange(0, sentence.length), withTemplate: \"\")\n \
    \                                                                            \
    \   ^~~~~~~~~~~\n/tmp/tmpxn3mty5d.swift:18:105: error: value of type 'String'\
    \ has no member 'length'\n    return regex.stringByReplacingMatchesInString(sentence,\
    \ options: [], range: NSMakeRange(0, sentence.length), withTemplate: \"\")\n \
    \                                                                            \
    \                  ~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution().words_in_sentence(sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqd3wcn7d.swift:17:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().words_in_sentence(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return helper(sentence, 1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpu6z5bv4_.swift:17:12: error: cannot find 'helper' in scope\n  \
    \  return helper(sentence, 1)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return check_for_recursive(sentence, \"\", primes,\
    \ 0, \"\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpsyb65vyu.swift:17:12: error: cannot find 'check_for_recursive'\
    \ in scope\n    return check_for_recursive(sentence, \"\", primes, 0, \"\")\n\
    \           ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpsyb65vyu.swift:17:46: error: cannot find\
    \ 'primes' in scope\n    return check_for_recursive(sentence, \"\", primes, 0,\
    \ \"\")\n                                             ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    var newString = String()\n \
    \   for word in sentence.components(separatedBy: \" \") {\n        let charCount\
    \ = word.characters.count\n        let intCount = Int(charCount)\n        if intCount.isPrime\
    \ {\n            newString.append(word)\n        }\n    }\n    return newString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpc0mc7a4f.swift:19:26: error: value of type 'String' has no member\
    \ 'components'\n    for word in sentence.components(separatedBy: \" \") {\n  \
    \              ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp3qm8spq4/tmp3qm8spq4.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6377583c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b637727ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b637727a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63772797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3qm8spq4                        0x000055801f6c1307 <unavailable> + 4871

    5    libc.so.6                          0x00002b637776f460 __libc_start_main +
    245

    6    tmp3qm8spq4                        0x000055801f6c0f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution().words_in_sentence(sentence: sentence)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkm8kywv0.swift:17:12: error: cannot find 'Solution' in scope\n\
    \    return Solution().words_in_sentence(sentence: sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    let words = sentence.componentsSeparatedByString(\" \")\n    let primes =\
    \ primes(from: words)\n    let newWords = words.filter { prime in\n        return\
    \ words.count > prime\n    }\n    return newWords.joined(separator: \" \")\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpu6dnt8r3.swift:20:26: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = sentence.componentsSeparatedByString(\"\
    \ \")\n                ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu6dnt8r3.swift:21:18:\
    \ error: use of local variable 'primes' before its declaration\n    let primes\
    \ = primes(from: words)\n                 ^\n/tmp/tmpu6dnt8r3.swift:21:9: note:\
    \ 'primes' declared here\n    let primes = primes(from: words)\n        ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var resultString = \"\"\n    for i in sentence.characters\
    \ {\n        if result.characters.count <= Int(i) ** 2 {\n            resultString.append(sentence.substringToIndex(advance(sentence.startIndex,\
    \ i)))\n        }\n    }\n    return resultString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyiw2xy4f.swift:18:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in sentence.characters {\n                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpyiw2xy4f.swift:19:12:\
    \ error: cannot find 'result' in scope\n        if result.characters.count <=\
    \ Int(i) ** 2 {\n           ^~~~~~\n/tmp/tmpyiw2xy4f.swift:19:46: error: cannot\
    \ find operator '**' in scope\n        if result.characters.count <= Int(i) **\
    \ 2 {\n                                             ^~\n/tmp/tmpyiw2xy4f.swift:19:39:\
    \ error: no exact matches in call to initializer \n        if result.characters.count\
    \ <= Int(i) ** 2 {\n                                      ^\n/tmp/tmpyiw2xy4f.swift:19:39:\
    \ note: found candidate with type '(Float16) -> Int'\n        if result.characters.count\
    \ <= Int(i) ** 2 {\n                                      ^\n/tmp/tmpyiw2xy4f.swift:19:39:\
    \ note: found candidate with type '(Float) -> Int'\n        if result.characters.count\
    \ <= Int(i) ** 2 {\n                                      ^\n/tmp/tmpyiw2xy4f.swift:19:39:\
    \ note: found candidate with type '(Double) -> Int'\n        if result.characters.count\
    \ <= Int(i) ** 2 {\n                                      ^\n/tmp/tmpyiw2xy4f.swift:19:39:\
    \ note: found candidate with type '(Float80) -> Int'\n        if result.characters.count\
    \ <= Int(i) ** 2 {\n                                      ^\n/tmp/tmpyiw2xy4f.swift:19:39:\
    \ note: found candidate with type '(Builtin.Int64) -> Int'\n        if result.characters.count\
    \ <= Int(i) ** 2 {\n                                      ^\n/tmp/tmpyiw2xy4f.swift:19:39:\
    \ note: found candidate with type '(Builtin.Word) -> Int'\n        if result.characters.count\
    \ <= Int(i) ** 2 {\n                                      ^\n/tmp/tmpyiw2xy4f.swift:20:59:\
    \ error: cannot find 'advance' in scope\n            resultString.append(sentence.substringToIndex(advance(sentence.startIndex,\
    \ i)))\n                                                          ^~~~~~~\n/tmp/tmp"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code in JavaScript (Node.js 8.9.4)\n\
    \    return sentence.split(' ').filter((element) => !is_prime(element.split(\"\
    \").length).includes(true)).join(\" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpvzbxkoz1.swift:18:27: error: single-quoted string literal found,\
    \ use '\"'\n    return sentence.split(' ').filter((element) => !is_prime(element.split(\"\
    \").length).includes(true)).join(\" \")\n                          ^~~\n     \
    \                     \" \"\n/tmp/tmpvzbxkoz1.swift:18:40: error: cannot find\
    \ 'element' in scope\n    return sentence.split(' ').filter((element) => !is_prime(element.split(\"\
    \").length).includes(true)).join(\" \")\n                                    \
    \   ^~~~~~~\n/tmp/tmpvzbxkoz1.swift:18:49: error: cannot find operator '=>' in\
    \ scope\n    return sentence.split(' ').filter((element) => !is_prime(element.split(\"\
    \").length).includes(true)).join(\" \")\n                                    \
    \            ^~\n/tmp/tmpvzbxkoz1.swift:18:53: error: cannot find 'is_prime' in\
    \ scope\n    return sentence.split(' ').filter((element) => !is_prime(element.split(\"\
    \").length).includes(true)).join(\" \")\n                                    \
    \                ^~~~~~~~\n/tmp/tmpvzbxkoz1.swift:18:62: error: cannot find 'element'\
    \ in scope\n    return sentence.split(' ').filter((element) => !is_prime(element.split(\"\
    \").length).includes(true)).join(\" \")\n                                    \
    \                         ^~~~~~~\n/tmp/tmpvzbxkoz1.swift:18:27: error: missing\
    \ argument label 'separator:' in call\n    return sentence.split(' ').filter((element)\
    \ => !is_prime(element.split(\"\").length).includes(true)).join(\" \")\n     \
    \                     ^\n                          separator: \n/tmp/tmpvzbxkoz1.swift:18:104:\
    \ error: value of type '[String.SubSequence]' (aka 'Array<Substring>') has no\
    \ member 'join'\n    return sentence.split(' ').filter((element) => !is_prime(element.split(\"\
    \").length).includes(true)).join(\" \")\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return remove_punctuation(remove_punctuation(sentence)).words\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpbtad9z6j.swift:17:12: error: cannot find 'remove_punctuation' in\
    \ scope\n    return remove_punctuation(remove_punctuation(sentence)).words\n \
    \          ^~~~~~~~~~~~~~~~~~\n/tmp/tmpbtad9z6j.swift:17:31: error: cannot find\
    \ 'remove_punctuation' in scope\n    return remove_punctuation(remove_punctuation(sentence)).words\n\
    \                              ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for i in 0..<(Int(sentence.length)/2)\
    \ {\n        let substring = String(sentence.prefix(by: Int(sentence.length)/2\
    \ + i))\n        if let substring = substring.unicodeScalars {\n            for\
    \ char in substring{\n                if let char = char.value {\n           \
    \         if Int(char) != char.value {\n                        result += String(char)\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp2kefntmd.swift:18:32: error: value of type 'String' has no member\
    \ 'length'\n    for i in 0..<(Int(sentence.length)/2) {\n                    \
    \  ~~~~~~~~ ^~~~~~\n/tmp/tmp2kefntmd.swift:19:41: error: no exact matches in call\
    \ to instance method 'prefix'\n        let substring = String(sentence.prefix(by:\
    \ Int(sentence.length)/2 + i))\n                                        ^\n/tmp/tmp2kefntmd.swift:19:41:\
    \ note: found candidate with type '(Int) -> PrefixSequence<String>'\n        let\
    \ substring = String(sentence.prefix(by: Int(sentence.length)/2 + i))\n      \
    \                                  ^\n/tmp/tmp2kefntmd.swift:19:41: note: found\
    \ candidate with type '(Int) -> String.SubSequence' (aka '(Int) -> Substring')\n\
    \        let substring = String(sentence.prefix(by: Int(sentence.length)/2 + i))\n\
    \                                        ^\n/tmp/tmp2kefntmd.swift:19:65: error:\
    \ value of type 'String' has no member 'length'\n        let substring = String(sentence.prefix(by:\
    \ Int(sentence.length)/2 + i))\n                                             \
    \          ~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    var strings = sentence.characters\n\
    \    var newString = \"\"\n    for _ in 0..<strings.count {\n        var newWord\
    \ = \"\"\n        for i in 0..<strings[_].length {\n            var isPrime =\
    \ true\n            var isNotPrime = true\n            for j in 0..<strings[_].length\
    \ {\n                if i != j {\n                    if strings[_][i] != strings[_][j]\
    \ {\n                        isNotPrime = false\n                        break\n\
    \                    }\n                }\n            }\n            if isNotPrime\
    \ {\n                for j in 0..<strings[_].length {\n                    if\
    \ strings[_][i] == \"X\" {\n                        isPrime = false\n        \
    \                break\n                    }\n                }\n           \
    \     if isPrime {\n                    newWord += strings[_][i]\n           \
    \     }\n            }\n        }\n        newString += \" \" + newWord\n    }\n\
    \    return newString.substringToIndex(newString.characters.count)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptk8z2b0n.swift:18:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    var strings = sentence.characters\n               \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmptk8z2b0n.swift:22:30: error: '_' can only appear in a pattern or on the\
    \ left side of an assignment\n        for i in 0..<strings[_].length {\n     \
    \                        ^\n/tmp/tmptk8z2b0n.swift:47:22: error: value of type\
    \ 'String' has no member 'substringToIndex'\n    return newString.substringToIndex(newString.characters.count)\n\
    \           ~~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmptk8z2b0n.swift:25:34: error: '_'\
    \ can only appear in a pattern or on the left side of an assignment\n        \
    \    for j in 0..<strings[_].length {\n                                 ^\n/tmp/tmptk8z2b0n.swift:34:38:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \                for j in 0..<strings[_].length {\n                          \
    \           ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    let wordsSet = Set(sentence.components(separatedBy: \" \"))\n    var ret\
    \ = \"\"\n    for i in 0..<sentence.characters.count {\n        let isPrime =\
    \ i % 2 == 1 && i > 1 && !(i % 3)\n        if !wordsSet.contains(String(sentence.substring(with:\
    \ Index(i))) && isPrime {\n            ret += String(sentence.substring(with:\
    \ Index(i)))\n        }\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpnjjt1i0s.swift:27:5: error: expected ')' in expression list\n \
    \   }\n    ^\n/tmp/tmpnjjt1i0s.swift:24:30: note: to match this opening '('\n\
    \        if !wordsSet.contains(String(sentence.substring(with: Index(i))) && isPrime\
    \ {\n                             ^\n/tmp/tmpnjjt1i0s.swift:20:33: error: value\
    \ of type 'String' has no member 'components'\n    let wordsSet = Set(sentence.components(separatedBy:\
    \ \" \"))\n                       ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpnjjt1i0s.swift:22:27:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ 0..<sentence.characters.count {\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpnjjt1i0s.swift:23:50: error: type 'Int'\
    \ cannot be used as a boolean; test for '== 0' instead\n        let isPrime =\
    \ i % 2 == 1 && i > 1 && !(i % 3)\n                                          \
    \   ~   ^\n                                              (       == 0)\n/tmp/tmpnjjt1i0s.swift:24:63:\
    \ error: cannot find 'Index' in scope\n        if !wordsSet.contains(String(sentence.substring(with:\
    \ Index(i))) && isPrime {\n                                                  \
    \            ^~~~~\n/tmp/tmpnjjt1i0s.swift:25:52: error: cannot find 'Index' in\
    \ scope\n            ret += String(sentence.substring(with: Index(i)))\n     \
    \                                              ^~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_naive(sentence: sentence)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1h7n7rht.swift:17:12: error: cannot find 'words_in_sentence_naive'\
    \ in scope\n    return words_in_sentence_naive(sentence: sentence)\n         \
    \  ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard isPrimeNumber(sentence.length) else {\n     \
    \   return \"\"\n    }\n\n    let wordArray = sentence.characters.split{$0 ==\
    \ \" \"}.map(String.init)\n\n    return wordArray.sorted(by: { $0.compare($1)\
    \ == .orderedAscending }).joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprsfyhs0n.swift:17:11: error: cannot find 'isPrimeNumber' in scope\n\
    \    guard isPrimeNumber(sentence.length) else {\n          ^~~~~~~~~~~~~\n/tmp/tmprsfyhs0n.swift:17:34:\
    \ error: value of type 'String' has no member 'length'\n    guard isPrimeNumber(sentence.length)\
    \ else {\n                        ~~~~~~~~ ^~~~~~\n/tmp/tmprsfyhs0n.swift:21:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    let wordArray\
    \ = sentence.characters.split{$0 == \" \"}.map(String.init)\n                \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmprsfyhs0n.swift:23:38: error: value of type 'String' has no member\
    \ 'compare'\n    return wordArray.sorted(by: { $0.compare($1) == .orderedAscending\
    \ }).joined(separator: \" \")\n                                  ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var primes = []\n    var i = 0\n    var result: String\
    \ = \"\"\n    for letter in sentence.characters {\n        if i > 0 {\n      \
    \      if letter == ' ' {\n                result += \" \"\n            }\n  \
    \          if primes.contains(letter) {\n                if primes.count > i {\n\
    \                    result += primes[i]\n                }\n                i\
    \ += 1\n            }\n        }\n        primes.append(letter)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmplg6888wo.swift:22:26: error: single-quoted string literal found,\
    \ use '\"'\n            if letter == ' ' {\n                         ^~~\n   \
    \                      \" \"\n/tmp/tmplg6888wo.swift:17:18: error: empty collection\
    \ literal requires an explicit type\n    var primes = []\n                 ^~\n\
    /tmp/tmplg6888wo.swift:20:28: error: 'characters' is unavailable: Please use String\
    \ directly\n    for letter in sentence.characters {\n                        \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmplg6888wo.swift:25:32:\
    \ error: missing argument label 'where:' in call\n            if primes.contains(letter)\
    \ {\n                               ^\n                               where: \n\
    /tmp/tmplg6888wo.swift:25:32: error: cannot convert value of type 'Character'\
    \ to expected argument type '(Any) throws -> Bool'\n            if primes.contains(letter)\
    \ {\n                               ^\n/tmp/tmplg6888wo.swift:27:37: error: cannot\
    \ convert value of type 'Any' to expected argument type 'String'\n           \
    \         result += primes[i]\n                                    ^\n       \
    \                                 as! String\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpp66_gpar/tmpp66_gpar.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada2edf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada2eaeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada2eaea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada2eae97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp66_gpar                        0x000055738abff307 <unavailable> + 4871

    5    libc.so.6                          0x00002ada2efdf460 __libc_start_main +
    245

    6    tmpp66_gpar                        0x000055738abfef49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659978892
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let words = sentence.components(separatedBy:\
    \ \" \") else { return \"\" }\n    var result = \"\"\n    let primesOfTheWords\
    \ = Array(1...words.count).filter{$0 % $0 == 0}\n    for i in primesOfTheWords\
    \ {\n        let index = (sentence.index(of: words[i], options: .noSearch)!)?.encoded\n\
    \        result = (result+words[index!]).removeDuplicates()\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_l5hmrpw.swift:17:32: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = sentence.components(separatedBy: \" \")\
    \ else { return \"\" }\n                      ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp_l5hmrpw.swift:21:61:\
    \ error: extra argument 'options' in call\n        let index = (sentence.index(of:\
    \ words[i], options: .noSearch)!)?.encoded\n                                 \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n/tmp/tmp_l5hmrpw.swift:21:61: error: cannot\
    \ infer contextual base in reference to member 'noSearch'\n        let index =\
    \ (sentence.index(of: words[i], options: .noSearch)!)?.encoded\n             \
    \                                              ~^~~~~~~~\n/tmp/tmp_l5hmrpw.swift:21:72:\
    \ error: cannot use optional chaining on non-optional value of type 'String.Index'\n\
    \        let index = (sentence.index(of: words[i], options: .noSearch)!)?.encoded\n\
    \                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n  \
    \                                                                     \n/tmp/tmp_l5hmrpw.swift:21:74:\
    \ error: 'encoded' is inaccessible due to 'internal' protection level\n      \
    \  let index = (sentence.index(of: words[i], options: .noSearch)!)?.encoded\n\
    \                                                                         ^~~~~~~\n\
    Swift.String.Index (internal):7:30: note: 'encoded(offsetBy:)' declared here\n\
    \    @inlinable internal func encoded(offsetBy n: Int) -> String.Index\n     \
    \                        ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var res = \"\"\n    var strLen = sentence.length\n    var numPrime = Array(1...strLen)\n\
    \    var i = 2\n    for char in strLen {\n        for prime in numPrime {\n  \
    \          if strLen % prime != 0 && strLen % prime != char {\n              \
    \  break\n            }\n            i += 2\n            if i != strLen {\n  \
    \              numPrime.remove(at: i)\n            }\n        }\n        if strLen\
    \ % i == 0 {\n            res += String(char)\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp38vxs6ox.swift:21:27: error: value of type 'String' has no member\
    \ 'length'\n    var strLen = sentence.length\n                 ~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code in JavaScript (Node.js 8.9.4)\n\
    \    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmptkmc1aos/tmptkmc1aos.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6840365c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b684005cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b684005c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b684005b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptkmc1aos                        0x000055674cba5307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6840551460 __libc_start_main +
    245

    6    tmptkmc1aos                        0x000055674cba4f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let wordsInSentence = sentence.components(separatedBy:\
    \ \" \")\n    guard !wordsInSentence.isEmpty else { return \"\" }\n    var resultWords\
    \ = [String]()\n    for i in 1...wordsInSentence.count {\n        for j in 2..wordsInSentence.count\
    \ {\n            if wordsInSentence.first!.count < i {\n                resultWords.append(wordsInSentence[j\
    \ - 1])\n            } else if wordsInSentence.first!.count == i {\n         \
    \       if i != j {\n                    resultWords.append(wordsInSentence[j\
    \ - 1])\n                }\n            }\n        }\n    }\n    return resultWords.joinWithSeparator(\"\
    \ \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpib3jb9jk.swift:17:36: error: value of type 'String' has no member\
    \ 'components'\n    let wordsInSentence = sentence.components(separatedBy: \"\
    \ \")\n                          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpib3jb9jk.swift:31:24:\
    \ error: value of type '[String]' has no member 'joinWithSeparator'\n    return\
    \ resultWords.joinWithSeparator(\" \")\n           ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmpib3jb9jk.swift:21:19: error: cannot find operator '..' in scope; did you\
    \ mean '...'?\n        for j in 2..wordsInSentence.count {\n                 \
    \ ^~\n                  ...\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n  var result: String = \"\"\n  for character in sentence\
    \ {\n    result += String(character)\n  }\n  for number in 2...Int(sqrt(Double(result.count)))\
    \ {\n    if result.contains(\"\\(number)\") {\n      result = result.filter({$0\
    \ != \"\\(number)\"})\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpviw3pv1f.swift:21:25: error: cannot find 'sqrt' in scope\n  for\
    \ number in 2...Int(sqrt(Double(result.count))) {\n                        ^~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentenceAsArray = sentence.split(separator:\
    \ \" \").map(String.init) else {\n        return \"No words found\"\n    }\n \
    \   var maxLengthOfSentenceAsArray = sentenceAsArray.max{$0.count < $1.count}\n\
    \    let allPrimeNumbers: [Int] = []\n    for i in 1...Int(maxLengthOfSentenceAsArray.count)\
    \ {\n        if sentenceAsArray[i].filter { return $0 == Int(i).isPrime }.isEmpty\
    \ {\n            allPrimeNumbers.append(i)\n        }\n    }\n    return sentenceAsArray.filter\
    \ {\n        return allPrimeNumbers.contains($0.count)\n    }.joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpjc5x9tc0.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String]'\n    guard let sentenceAsArray = sentence.split(separator:\
    \ \" \").map(String.init) else {\n          ^                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjc5x9tc0.swift:22:22: error: value of optional type 'String?' must be\
    \ unwrapped to refer to member 'count' of wrapped base type 'String'\n    for\
    \ i in 1...Int(maxLengthOfSentenceAsArray.count) {\n                     ^\n/tmp/tmpjc5x9tc0.swift:22:22:\
    \ note: chain the optional using '?' to access member 'count' only for non-'nil'\
    \ base values\n    for i in 1...Int(maxLengthOfSentenceAsArray.count) {\n    \
    \                 ^\n                                               ?\n/tmp/tmpjc5x9tc0.swift:22:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    for i in 1...Int(maxLengthOfSentenceAsArray.count) {\n          \
    \           ^\n                                               !\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    return sentence\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpx0fyzkjx/tmpx0fyzkjx.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b18f85c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b18c7cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9b18c7c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9b18c7b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx0fyzkjx                        0x000055ed54657307 <unavailable> + 4871

    5    libc.so.6                          0x00002b9b19171460 __libc_start_main +
    245

    6    tmpx0fyzkjx                        0x000055ed54656f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words.filter(sentence.characters.contains).joinWithSeparator(\"\
    \ \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpu6ah8gwe.swift:17:12: error: cannot find 'words' in scope\n   \
    \ return words.filter(sentence.characters.contains).joinWithSeparator(\" \")\n\
    \           ^~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split{\n\
    \        var word = word.lowercaseString\n        guard is_prime(word) else {\
    \ continue }\n        result += (word + \" \")\n    }\n    return result.trimmingCharacters(in:\
    \ \" \".characters)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp003d68up.swift:18:26: error: no 'split' overloads produce result\
    \ type that conforms to 'Sequence'\n    for word in sentence.split{\n        \
    \                 ^\nSwift.Sequence:2:40: note: found candidate with type '(String.Element,\
    \ Int, Bool) -> [ArraySlice<String.Element>]' (aka '(Character, Int, Bool) ->\
    \ Array<ArraySlice<Character>>')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Sequence:2:40:\
    \ note: found candidate with type '(Int, Bool, (String.Element) throws -> Bool)\
    \ throws -> [ArraySlice<String.Element>]' (aka '(Int, Bool, (Character) throws\
    \ -> Bool) throws -> Array<ArraySlice<Character>>')\n    @inlinable public __consuming\
    \ func split(maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true,\
    \ whereSeparator isSeparator: (Self.Element) throws -> Bool) rethrows -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:12:40: note: found\
    \ candidate with type '(Int, Bool, (String.Element) throws -> Bool) throws ->\
    \ [String.SubSequence]' (aka '(Int, Bool, (Character) throws -> Bool) throws ->\
    \ Array<Substring>')\n    @inlinable public __consuming func split(maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true, whereSeparator isSeparator:\
    \ (Self.Element) throws -> Bool) rethrows -> [Self.SubSequence]\n            \
    \                           ^\nSwift.Collection:2:40: note: found candidate with\
    \ type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character,\
    \ Int, Bool) -> Array<Substring>')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n/tmp/tmp003d68up.swift:23:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    return\
    \ result.trimmingCharacters(in: \" \".characters)\n           ~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return sentence.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \        .components(separatedBy: CharacterSet.whitespaces)\n        .filter({\
    \ (word, length) -> Bool in\n            guard length > 0 else {\n           \
    \     return false\n            }\n            var prime: Int\n            if\
    \ length <= 2 {\n                prime = 2\n            } else {\n           \
    \     prime = 3\n            }\n            for _ in 0..<length {\n          \
    \      if isPrime(prime, length: length) {\n                    return false\n\
    \                }\n                prime += 2\n            }\n            return\
    \ true\n        })\n        .map{ (word) -> String in\n            return word\n\
    \        }\n        .joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpwa4tvz4t.swift:17:44: error: cannot find 'CharacterSet' in scope\n\
    \    return sentence.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                           ^~~~~~~~~~~~\n/tmp/tmpwa4tvz4t.swift:18:34:\
    \ error: cannot find 'CharacterSet' in scope\n        .components(separatedBy:\
    \ CharacterSet.whitespaces)\n                                 ^~~~~~~~~~~~\n/tmp/tmpwa4tvz4t.swift:30:20:\
    \ error: cannot find 'isPrime' in scope\n                if isPrime(prime, length:\
    \ length) {\n                   ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    for letter in sentence.characters\
    \ {\n        if let i = Int(String(letter).unicodeScalars.first!.value) {\n  \
    \          if i > 1 {\n                for _ in 1...i {\n                    if\
    \ isPrime(i) {\n                        return String(letter).unicodeScalars.first!.value\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfwk7cbnb.swift:18:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpfwk7cbnb.swift:22:24: error: cannot find 'isPrime' in scope\n   \
    \                 if isPrime(i) {\n                       ^~~~~~~\n/tmp/tmpfwk7cbnb.swift:23:69:\
    \ error: cannot convert return expression of type 'UInt32' to return type 'String'\n\
    \                        return String(letter).unicodeScalars.first!.value\n \
    \                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/tmp/tmpfwk7cbnb.swift:19:12:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \        if let i = Int(String(letter).unicodeScalars.first!.value) {\n      \
    \     ^       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return sentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp0vj7nf6m/tmp0vj7nf6m.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21adde3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21adadab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21adada988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21adad97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0vj7nf6m                        0x000055cbb9c2c307 <unavailable> + 4871

    5    libc.so.6                          0x00002b21adfcf460 __libc_start_main +
    245

    6    tmp0vj7nf6m                        0x000055cbb9c2bf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979024
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var words_in_sentence = \"\"\n    let word_array =\
    \ sentence.split(separator: \" \")\n    for i in 0..<word_array.count {\n    \
    \    if word_array.contains(where: { (word: String) -> Bool in\n            return\
    \ word.length == Int(i) && word.characters.filter({ $0.isLetter }).count != 0\n\
    \        }) {\n            words_in_sentence = words_in_sentence + word_array[i]\n\
    \        }\n    }\n    return words_in_sentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps9qy5r32.swift:20:39: error: cannot convert value of type '(String)\
    \ -> Bool' to expected argument type '(String.SubSequence) throws -> Bool' (aka\
    \ '(Substring) throws -> Bool')\n        if word_array.contains(where: { (word:\
    \ String) -> Bool in\n                                      ^\n/tmp/tmps9qy5r32.swift:21:25:\
    \ error: value of type 'String' has no member 'length'\n            return word.length\
    \ == Int(i) && word.characters.filter({ $0.isLetter }).count != 0\n          \
    \         ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if let sentence = sentence.lowercased() {\n       \
    \ var s = \"\"\n        var isPrime = true\n        for _ in 0..<Int(sqrt(Double(sentence.count)))\
    \ {\n            if Int(sentence.index(after: startIndex)) != 0 {\n          \
    \      if Int(sentence.index(after: startIndex)) % Int(sqrt(Double(sentence.count)))!\
    \ != 0 {\n                    isPrime = false\n                }\n           \
    \ }\n            s +=\n                String(sentence.substring(to: sentence.index(sentence.startIndex,\
    \ offsetBy: Int(sqrt(Double(sentence.count)))), limitedBy: sentence.endIndex))\n\
    \        }\n        if !isPrime {\n            s += \"...\"\n        }\n     \
    \   return s\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp6455l1rl.swift:20:26: error: cannot find 'sqrt' in scope\n    \
    \    for _ in 0..<Int(sqrt(Double(sentence.count))) {\n                      \
    \   ^~~~\n/tmp/tmp6455l1rl.swift:17:8: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    if let sentence = sentence.lowercased()\
    \ {\n       ^              ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, wordSeparator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp6n9j3wwz.swift:17:65: error: extra argument 'wordSeparator' in\
    \ call\n    return words_in_sentence(sentence: sentence, wordSeparator: \" \"\
    )\n                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if Int(\"\\(word)\".characters.count) == 1 {\n           \
    \ result += word + \" \" // add word and space\n        } else {\n           \
    \ result += \"\\(word)\" + \" \"  // add word and space\n        }\n    }\n  \
    \  return result.trimmingCharacters(in: CharacterSet.whitespaces) //trim space\
    \ from the start and end\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpt4mp3ge2.swift:19:26: error: 'characters' is unavailable: Please\
    \ use String directly\n        if Int(\"\\(word)\".characters.count) == 1 {\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpt4mp3ge2.swift:25:42: error: cannot find 'CharacterSet'\
    \ in scope\n    return result.trimmingCharacters(in: CharacterSet.whitespaces)\
    \ //trim space from the start and end\n                                      \
    \   ^~~~~~~~~~~~\n/tmp/tmpt4mp3ge2.swift:25:19: error: value of type 'String'\
    \ has no member 'trimmingCharacters'\n    return result.trimmingCharacters(in:\
    \ CharacterSet.whitespaces) //trim space from the start and end\n           ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard sentence != \"\" else {\n        return \"\"\n\
    \    }\n    var result = \"\"\n    var prime = 0\n    var isPrime = true\n   \
    \ for letter in sentence.characters {\n        guard letter >= \"a\" && letter\
    \ <= \"z\" else {\n            return \"\"\n        }\n        let index = Int(letter)\
    \ - Int(97)\n        while prime <= index {\n            isPrime = true\n    \
    \        prime = prime + 1\n            for index2 in (prime).stride(to: Int(index),\
    \ by: -1) {\n                if prime % index2 == 0 {\n                    isPrime\
    \ = false\n                    break\n                }\n            }\n     \
    \       if isPrime {\n                result = result + String(letter)\n     \
    \       }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpgmpwdti2.swift:23:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in sentence.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgmpwdti2.swift:27:21: error: no exact matches in call to initializer\
    \ \n        let index = Int(letter) - Int(97)\n                    ^\nSwift.Int:7:12:\
    \ note: candidate expects value of type 'Float16' for parameter #1 (got 'Character')\n\
    \    public init(_ source: Float16)\n           ^\nSwift.Int:10:12: note: candidate\
    \ expects value of type 'Float' for parameter #1 (got 'Character')\n    public\
    \ init(_ source: Float)\n           ^\nSwift.Int:12:12: note: candidate expects\
    \ value of type 'Double' for parameter #1 (got 'Character')\n    public init(_\
    \ source: Double)\n           ^\nSwift.Int:14:12: note: candidate expects value\
    \ of type 'Float80' for parameter #1 (got 'Character')\n    public init(_ source:\
    \ Float80)\n           ^\nSwift.Int:28:12: note: candidate expects value of type\
    \ 'Builtin.Int64' for parameter #1 (got 'Character')\n    public init(_ _value:\
    \ Builtin.Int64)\n           ^\nSwift.Int:61:12: note: candidate expects value\
    \ of type 'Builtin.Word' for parameter #1 (got 'Character')\n    public init(_\
    \ _v: Builtin.Word)\n           ^\n/tmp/tmpgmpwdti2.swift:31:35: error: value\
    \ of type 'Int' has no member 'stride'\n            for index2 in (prime).stride(to:\
    \ Int(index), by: -1) {\n                          ~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(\n        sentence.characters.count >=\
    \ 1,\n        \"sentence must have at least 1 character\"\n    )\n    precondition(\n\
    \        sentence.characters.count <= 100,\n        \"sentence must have at most\
    \ 100 characters\"\n    )\n    var result = \"\"\n    for word in sentence.components(separatedBy:\
    \ \" \") {\n        precondition(\n            !result.isEmpty,\n            \"\
    words_in_sentence() can only return a result after finding a word\"\n        )\n\
    \        var prime = false // true means prime\n        for char in word {\n \
    \           if prime {\n                break\n            }\n            var\
    \ divisor = 2\n            while !((divisor * divisor) <= char.asciiValue && char.asciiValue\
    \ % divisor == 0) {\n                divisor *= 2\n            }\n           \
    \ if divisor != 2 {\n                prime = true\n            }\n        }\n\
    \        if prime {\n            result += word\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkf3846fc.swift:18:18: error: 'characters' is unavailable: Please\
    \ use String directly\n        sentence.characters.count >= 1,\n             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpkf3846fc.swift:22:18:\
    \ error: 'characters' is unavailable: Please use String directly\n        sentence.characters.count\
    \ <= 100,\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkf3846fc.swift:26:26: error: value of type 'String'\
    \ has no member 'components'\n    for word in sentence.components(separatedBy:\
    \ \" \") {\n                ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let letters = sentence.characters\n    var result =\
    \ \"\"\n    var primeFactors = [1]\n    \n    for i in 2..<letters.count {\n \
    \       if primeFactors.contains(letters[i]/i) {\n            primeFactors.append(letters[i]/i)\n\
    \        }\n    }\n    \n    for i in 1..<primeFactors.count {\n        if primeFactors[i]\
    \ == 1 {\n            if letters[i] == \" \" {\n                result += letters[i]\n\
    \            } else {\n                result += \"\\ (\\ letters[i])\"\n    \
    \        }\n        } else {\n            result += \"(\\ letters[i])\"\n    \
    \    }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpm_x44dnk.swift:32:29: error: invalid escape sequence in literal\n\
    \                result += \"\\ (\\ letters[i])\"\n                          \
    \  ^\n/tmp/tmpm_x44dnk.swift:32:32: error: invalid escape sequence in literal\n\
    \                result += \"\\ (\\ letters[i])\"\n                          \
    \     ^\n/tmp/tmpm_x44dnk.swift:35:26: error: invalid escape sequence in literal\n\
    \            result += \"(\\ letters[i])\"\n                         ^\n/tmp/tmpm_x44dnk.swift:17:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    let letters\
    \ = sentence.characters\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpm_x44dnk.swift:22:41: error: cannot convert\
    \ value of type 'Character' to expected argument type 'Int'\n        if primeFactors.contains(letters[i]/i)\
    \ {\n                                        ^\n/tmp/tmpm_x44dnk.swift:23:40:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            primeFactors.append(letters[i]/i)\n                             \
    \          ^\n/tmp/tmpm_x44dnk.swift:29:16: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   if letters[i] == \" \" {\n               ^~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpm_x44dnk.swift:30:34: error:\
    \ no exact matches in call to subscript \n                result += letters[i]\n\
    \                                 ^\nSwift.String:3:12: note: candidate expects\
    \ value of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public\
    \ subscript(r: Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for character in sentence {\n\
    \        let lowerCasedCharacter = String(Character(character).lowercased())\n\
    \        if Character.isLetter(character) {\n            let isPrime = is_prime(letter:\
    \ lowerCasedCharacter)\n            if isPrime {\n                if let lastWord\
    \ = result.last, !lastWord.isEmpty {\n                    result += \" \" + lastWord\n\
    \                }\n                result += \" \" + lowerCasedCharacter\n  \
    \          }\n        }\n    }\n    return result.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpb12qy0ja.swift:19:52: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        let lowerCasedCharacter = String(Character(character).lowercased())\n\
    \                                                   ^\n                      \
    \                             extendedGraphemeClusterLiteral: \n/tmp/tmpb12qy0ja.swift:20:22:\
    \ error: cannot call value of non-function type 'Bool'\n        if Character.isLetter(character)\
    \ {\n                     ^\n/tmp/tmpb12qy0ja.swift:20:12: error: instance member\
    \ 'isLetter' cannot be used on type 'Character'; did you mean to use a value of\
    \ this type instead?\n        if Character.isLetter(character) {\n           ^~~~~~~~~\n\
    /tmp/tmpb12qy0ja.swift:21:27: error: cannot find 'is_prime' in scope\n       \
    \     let isPrime = is_prime(letter: lowerCasedCharacter)\n                  \
    \        ^~~~~~~~\n/tmp/tmpb12qy0ja.swift:23:58: error: value of type 'String.Element'\
    \ (aka 'Character') has no member 'isEmpty'\n                if let lastWord =\
    \ result.last, !lastWord.isEmpty {\n                                         \
    \       ~~~~~~~~ ^~~~~~~\n/tmp/tmpb12qy0ja.swift:24:37: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \                    result += \" \" + lastWord\n                            \
    \        ^\n/tmp/tmpb12qy0ja.swift:30:19: error: value of type 'String' has no\
    \ member 'trimmingCharacters'\n    return result.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \           ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpb12qy0ja.swift:30:43: error: cannot\
    \ infer contextual base in reference to member 'whitespacesAndNewlines'\n    return\
    \ result.trimmingCharacters(in: .whitespacesAndNewlines)\n                   \
    \                      ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard sentence.characters.count >= 3 else { return\
    \ \"\" }\n    let words = sentence.components(separatedBy: \" \")\n    var result\
    \ = \"\"\n    for word in words {\n        let string = word\n        var length\
    \ = 1\n        var prime = true\n        for letter in word {\n            if\
    \ Int(letter) != letter { continue; } else { length = length * Int(letter) }\n\
    \        }\n        if length <= 1 { continue }\n        for i in 2..<length {\n\
    \            if length % i == 0 { prime = false; break }\n        }\n        if\
    \ prime {\n            result += string\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzf5qk0il.swift:17:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    guard sentence.characters.count >= 3 else { return\
    \ \"\" }\n                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpzf5qk0il.swift:18:26: error: value of type 'String'\
    \ has no member 'components'\n    let words = sentence.components(separatedBy:\
    \ \" \")\n                ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.components(separatedBy:\
    \ \" \") {\n        var temp = word\n        var foundPrime = false\n        for\
    \ num in 1...Int(Double(temp.characters.count))  {\n            var isPrime =\
    \ true\n            if num != 1 {\n                var str = String(temp.characters.dropLast())\n\
    \                for char in self.strings(from: str) {\n                    if\
    \ !isPrime {\n                        break\n                    }\n         \
    \           let res = prime_number(string: string)\n                    if res\
    \ == 0 {\n                        isPrime = false\n                        break\n\
    \                    }\n                }\n            }\n            if isPrime\
    \ {\n                result += temp\n                result += \" \"\n       \
    \         foundPrime = true\n            }\n            temp = String(temp.characters.dropLast())\n\
    \        }\n        if !foundPrime {\n            result += temp\n           \
    \ result += \" \"\n        }\n    }\n    return result.trimmingCharacters(in:\
    \ CharacterSet.whitespacesAndNewlines)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptsauilrf.swift:18:26: error: value of type 'String' has no member\
    \ 'components'\n    for word in sentence.components(separatedBy: \" \") {\n  \
    \              ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmptsauilrf.swift:48:42: error: cannot\
    \ find 'CharacterSet' in scope\n    return result.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                         ^~~~~~~~~~~~\n/tmp/tmptsauilrf.swift:48:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    return\
    \ result.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n       \
    \    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmptsauilrf.swift:25:29: error: cannot find\
    \ 'self' in scope; did you mean to use it in a type or extension context?\n  \
    \              for char in self.strings(from: str) {\n                       \
    \     ^~~~\n/tmp/tmptsauilrf.swift:29:31: error: cannot find 'prime_number' in\
    \ scope\n                    let res = prime_number(string: string)\n        \
    \                      ^~~~~~~~~~~~\n/tmp/tmptsauilrf.swift:29:52: error: cannot\
    \ find 'string' in scope\n                    let res = prime_number(string: string)\n\
    \                                                   ^~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    var result = \"\"\n    for i\
    \ in 0..<sentence.characters.count {\n        if isPrime(i) {\n            result\
    \ += sentence.substring(i, i)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp0lfj7_yt.swift:19:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<sentence.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp0lfj7_yt.swift:20:12: error: cannot find 'isPrime' in scope\n   \
    \     if isPrime(i) {\n           ^~~~~~~\n/tmp/tmp0lfj7_yt.swift:21:32: error:\
    \ value of type 'String' has no member 'substring'\n            result += sentence.substring(i,\
    \ i)\n                      ~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    \n    var newString = \"\"\n    \n    for i in 0..<sentence.characters.count\
    \ {\n        \n        if isPrime(i) {\n            newString += String(sentence[i])\n\
    \        }\n        \n    }\n    \n    return newString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_y75zwbh.swift:23:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<sentence.characters.count {\n        \
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp_y75zwbh.swift:25:12: error: cannot find 'isPrime' in scope\n   \
    \     if isPrime(i) {\n           ^~~~~~~\n/tmp/tmp_y75zwbh.swift:26:33: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n            newString += String(sentence[i])\n                   \
    \             ^~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp3qm8spq4/tmp3qm8spq4.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6377583c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b637727ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b637727a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b63772797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3qm8spq4                        0x000055801f6c1307 <unavailable> + 4871

    5    libc.so.6                          0x00002b637776f460 __libc_start_main +
    245

    6    tmp3qm8spq4                        0x000055801f6c0f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let wordsArray = sentence.componentsSeparatedByString(\"\
    \ \")\n    var newWordsArray = [String]()\n\n    for word in wordsArray {\n  \
    \      let newWord = String(word).characters.filter({ Character($0).isPrimeNumber()\
    \ })\n        newWordsArray.append(String(newWord))\n    }\n    return newWordsArray.joinWithSeparator(\"\
    \ \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp35mwb0eg.swift:17:31: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let wordsArray = sentence.componentsSeparatedByString(\"\
    \ \")\n                     ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp35mwb0eg.swift:24:26:\
    \ error: value of type '[String]' has no member 'joinWithSeparator'\n    return\
    \ newWordsArray.joinWithSeparator(\" \")\n           ~~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp35mwb0eg.swift:21:70: error: value of type 'Character' has no member 'isPrimeNumber'\n\
    \        let newWord = String(word).characters.filter({ Character($0).isPrimeNumber()\
    \ })\n                                                       ~~~~~~~~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp35mwb0eg.swift:21:66: error: missing argument label 'extendedGraphemeClusterLiteral:'\
    \ in call\n        let newWord = String(word).characters.filter({ Character($0).isPrimeNumber()\
    \ })\n                                                                 ^\n   \
    \                                                              extendedGraphemeClusterLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let words = sentence.components(separatedBy:\
    \ \" \") else {\n        return \"\"\n    }\n    var result = \"\"\n    for word\
    \ in words {\n        if is_prime(word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfbj0g7jd.swift:17:32: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = sentence.components(separatedBy: \" \")\
    \ else {\n                      ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = \"abcdefghijklmnopqrstuvwxyz\".characters\n\
    \    var result: String = \"\"\n    for word in sentence.split(separator: \" \"\
    ) {\n        var isPrime = true\n        for letter in word {\n            if\
    \ !words.contains(letter) {\n                isPrime = false\n               \
    \ break\n            }\n        }\n        if isPrime {\n            result +=\
    \ word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpaes2mmx_.swift:17:46: error: 'characters' is unavailable: Please\
    \ use String directly\n    let words = \"abcdefghijklmnopqrstuvwxyz\".characters\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    return \"\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp0dn3z1sm/tmp0dn3z1sm.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6296cbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62969b3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62969b3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62969b27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0dn3z1sm                        0x000055c2259d6307 <unavailable> + 4871

    5    libc.so.6                          0x00002b6296ea8460 __libc_start_main +
    245

    6    tmp0dn3z1sm                        0x000055c2259d5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.componentsSeparatedByString(\"\
    \ \")\n    var res = \"\"\n    words.forEach { word in\n        let length: Int?\
    \ = word.countElements\n        if length?.count == 0 {\n            return \"\
    \"\n        }\n        if length == nil {\n            res += word\n        }\
    \ else {\n            let primes = primes(length!)\n            primes.forEach\
    \ { prime in\n                if prime != length! {\n                    res +=\
    \ \" \" + word\n                }\n            }\n        }\n    }\n    return\
    \ res.components(separatedBy: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpetfylgcj.swift:17:26: error: value of type 'String' has no member\
    \ 'componentsSeparatedByString'\n    let words = sentence.componentsSeparatedByString(\"\
    \ \")\n                ~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpetfylgcj.swift:27:26:\
    \ error: use of local variable 'primes' before its declaration\n            let\
    \ primes = primes(length!)\n                         ^\n/tmp/tmpetfylgcj.swift:27:17:\
    \ note: 'primes' declared here\n            let primes = primes(length!)\n   \
    \             ^\n/tmp/tmpetfylgcj.swift:35:16: error: value of type 'String' has\
    \ no member 'components'\n    return res.components(separatedBy: \" \")\n    \
    \       ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return string_in_sentence(sentence, lengths: [2, 3,\
    \ 5, 7, 11, 13, 17, 19])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1sucelzm.swift:17:12: error: cannot find 'string_in_sentence' in\
    \ scope\n    return string_in_sentence(sentence, lengths: [2, 3, 5, 7, 11, 13,\
    \ 17, 19])\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(\"\
    \ \") {\n        let char = word.unicodeScalars\n            .filter{ $0.isPrime\
    \ }\n            .sorted(by: >)\n            .first\n        if char != nil {\n\
    \            result += char!.description\n        } else {\n            result\
    \ += word\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4jqb1t7y.swift:18:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.characters.count == 0 {\n        return\
    \ \"\"\n    }\n    if sentence.characters.count < 3 {\n        return \"\"\n \
    \   }\n    var result = \"\"\n    sentence.characters.forEach { character in\n\
    \        if Int(String(character)) == characterToInt(character) {\n          \
    \  result = result + String(character)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8z2r3e71.swift:17:17: error: 'characters' is unavailable: Please\
    \ use String directly\n    if sentence.characters.count == 0 {\n             \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp8z2r3e71.swift:20:17:\
    \ error: 'characters' is unavailable: Please use String directly\n    if sentence.characters.count\
    \ < 3 {\n                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8z2r3e71.swift:25:38: error: cannot find 'characterToInt'\
    \ in scope\n        if Int(String(character)) == characterToInt(character) {\n\
    \                                     ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let chars = sentence.characters.map { String($0) }\n\
    \    let primes = isPrimeChars(chars.map { $0.first })\n    return sentence.split(separator:\
    \ \" \").filter { primes.contains($0.count) }.map { String($0) }.join(\" \")\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj7sc7xfs.swift:17:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = sentence.characters.map { String($0) }\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpj7sc7xfs.swift:18:18: error: cannot find 'isPrimeChars'\
    \ in scope\n    let primes = isPrimeChars(chars.map { $0.first })\n          \
    \       ^~~~~~~~~~~~\n/tmp/tmpj7sc7xfs.swift:19:99: error: value of type '[String]'\
    \ has no member 'join'\n    return sentence.split(separator: \" \").filter { primes.contains($0.count)\
    \ }.map { String($0) }.join(\" \")\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n\tguard is_string(sentence) else { return \"\" }\n\treturn\
    \ sentence.componentsSeparatedByString(\" \")\n\t\t.map({ $0.characters.count\
    \ }).filter(is_prime).joinWithSeparator(\" \")\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpndhe9fme.swift:17:8: error: cannot find 'is_string' in scope\n\
    \        guard is_string(sentence) else { return \"\" }\n              ^~~~~~~~~\n\
    /tmp/tmpndhe9fme.swift:19:40: error: cannot find 'is_prime' in scope\n       \
    \         .map({ $0.characters.count }).filter(is_prime).joinWithSeparator(\"\
    \ \")\n                                                     ^~~~~~~~\n/tmp/tmpndhe9fme.swift:18:18:\
    \ error: value of type 'String' has no member 'componentsSeparatedByString'\n\
    \        return sentence.componentsSeparatedByString(\" \")\n               ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" { return \"\" }\n    var new_sentence\
    \ = sentence\n\n    for ch in new_sentence {\n        for char in \"abcdefghijklmnopqrstuvwxyz\"\
    \ {\n            if char == ch {\n                new_sentence = new_sentence.replacingOccurrences(of:\
    \ char, with: \"\")\n            }\n        }\n    }\n\n    var new_sentence2\
    \ = new_sentence.characters\n    new_sentence2 = new_sentence2.filter{ $0 != \"\
    -\".characters.count }\n    new_sentence2 = new_sentence2.filter{ $0 != \"a\"\
    .characters.count }\n    new_sentence2 = new_sentence2.filter{ $0 != \"e\".characters.count\
    \ }\n    new_sentence2 = new_sentence2.filter{ $0 != \"i\".characters.count }\n\
    \    new_sentence2 = new_sentence2.filter{ $0 != \"l\".characters.count }\n  \
    \  new_sentence2 = new_sentence2.filter{ $0 != \"o\".characters.count }\n    new_sentence2\
    \ = new_sentence2.filter{ $0 != \"u\".characters.count }\n    new_sentence2 =\
    \ new_sentence2.filter{ $0 != \"y\".characters.count }\n\n    for ch in new_sentence2\
    \ {\n        for char in \"abcdefghijklmnopqrstuvwxyz\" {\n            if char\
    \ == ch {\n                new_sentence = new_sentence.replacingOccurrences(of:\
    \ char, with: \"\")\n            }\n        }\n    }\n\n    return new_sentence\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppwjs989f.swift:23:45: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n                new_sentence = new_sentence.replacingOccurrences(of:\
    \ char, with: \"\")\n                               ~~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmppwjs989f.swift:28:38: error: 'characters' is unavailable: Please use String\
    \ directly\n    var new_sentence2 = new_sentence.characters\n                \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmppwjs989f.swift:29:43: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    new_sentence2 = new_sentence2.filter{\
    \ $0 != \"-\".characters.count }\n                                          ^\n\
    /tmp/tmppwjs989f.swift:30:43: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    new_sentence2 = new_sentence2.filter{\
    \ $0 != \"a\".characters.count }\n                                          ^\n\
    /tmp/tmppwjs989f.swift:31:43: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    new_sentence2 = new_sentence2.filter{\
    \ $0 != \"e\".characters.count }\n                                          ^\n\
    /tmp/tmppwjs989f.swift:32:43: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    new_sentence2 = new_sentence2.filter{\
    \ $0 != \"i\".characters.count }\n                                          ^\n\
    /tmp/tmppwjs989f.swift:33:43: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    new_sentence2 = new_sentence2.filter{\
    \ $0 != \"l\".characters.count }\n                                          ^\n\
    /tmp/tmppwjs989f.swift:34:43: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'Int'\n    new_sentence2 = new_sentence2.filter{\
    \ $0 != \"o\".characters.count }\n                                        "
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.characters.count != 0, \"Empty\
    \ sentence\")\n    precondition(isPrime(sentence.characters.count), \"Empty sentence\"\
    )\n    \n    var ret = \"\"\n    for char in sentence.characters {\n        if\
    \ let c = String(char) {\n            let index = String(c)\n            if StringUtils.isPrime(index)\
    \ {\n                ret += c\n            }\n        }\n    }\n    return ret\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpqqx0lwjz.swift:17:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    precondition(sentence.characters.count != 0, \"Empty\
    \ sentence\")\n                          ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpqqx0lwjz.swift:18:18: error: cannot find\
    \ 'isPrime' in scope\n    precondition(isPrime(sentence.characters.count), \"\
    Empty sentence\")\n                 ^~~~~~~\n/tmp/tmpqqx0lwjz.swift:21:26: error:\
    \ 'characters' is unavailable: Please use String directly\n    for char in sentence.characters\
    \ {\n                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpqqx0lwjz.swift:24:16: error: cannot find 'StringUtils'\
    \ in scope\n            if StringUtils.isPrime(index) {\n               ^~~~~~~~~~~\n\
    /tmp/tmpqqx0lwjz.swift:22:12: error: initializer for conditional binding must\
    \ have Optional type, not 'String'\n        if let c = String(char) {\n      \
    \     ^       ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return repeatedString(sentence: sentence, char: \"\
    \ \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp5nz9ayki.swift:17:12: error: cannot find 'repeatedString' in scope\n\
    \    return repeatedString(sentence: sentence, char: \" \")\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // TODO: implement\n    return \"not yet implemented\"\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmp088giyc9/tmp088giyc9.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9689696c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b968938db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b968938d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b968938c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp088giyc9                        0x00005626a23e6307 <unavailable> + 4871

    5    libc.so.6                          0x00002b9689882460 __libc_start_main +
    245

    6    tmp088giyc9                        0x00005626a23e5f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let chars = sentence.characters\n    let filteredChars\
    \ = chars.filter { !Character.isLetter(_) }\n    let filteredCharsLength = filteredChars.count\n\
    \    let primes = [2, 3, 5, 7, 11, 13, 17, 19]\n    var result = \"\"\n    var\
    \ isPrime = true\n    let maxValue = maxElement(primes)\n    for char in filteredChars\
    \ {\n        var currentPrime = primes.last!\n        for i in primes.indices\
    \ {\n            if prime == i {\n                isPrime = false\n          \
    \      currentPrime = primes[i]\n                break\n            }\n      \
    \  }\n        if isPrime {\n            if char.characters.count == 1 {\n    \
    \            result += char\n            } else {\n                result += String(char)\n\
    \            }\n        }\n        if currentPrime > maxValue {\n            result\
    \ += char\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpwd2yf3wj.swift:17:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = sentence.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwd2yf3wj.swift:18:60:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \    let filteredChars = chars.filter { !Character.isLetter(_) }\n           \
    \                                                ^\n/tmp/tmpwd2yf3wj.swift:23:20:\
    \ error: cannot find 'maxElement' in scope\n    let maxValue = maxElement(primes)\n\
    \                   ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return find_primes(sentence: sentence)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphdbrh1x5.swift:17:12: error: cannot find 'find_primes' in scope\n\
    \    return find_primes(sentence: sentence)\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var res = \"\"\n    for word in sentence.components(separatedBy:\
    \ \" \") {\n        guard let word = word.trimmingCharacters(in: .whitespaces)\
    \ else {\n            continue\n        }\n        if isPrime(word: word) {\n\
    \            res += \" \" + word\n        }\n    }\n    return res.removingFirst()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpvdduwhr3.swift:18:26: error: value of type 'String' has no member\
    \ 'components'\n    for word in sentence.components(separatedBy: \" \") {\n  \
    \              ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvdduwhr3.swift:26:16: error: value\
    \ of type 'String' has no member 'removingFirst'\n    return res.removingFirst()\n\
    \           ~~~ ^~~~~~~~~~~~~\n/tmp/tmpvdduwhr3.swift:19:55: error: cannot infer\
    \ contextual base in reference to member 'whitespaces'\n        guard let word\
    \ = word.trimmingCharacters(in: .whitespaces) else {\n                       \
    \                              ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let words = sentence.split(separator: \" \")\
    \ else { return \"\" }\n    var result = \"\"\n    for word in words {\n     \
    \   let index = word.index(word, startIndex: 0, offsetBy: 1)\n        if (index\
    \ == word.length - 1) || (index == word.length)  {\n            result += \"\\\
    (stringInterpolationSegment(word))\"\n        }\n        else {\n            result\
    \ += \"\\(stringInterpolationSegment(word[index...]))\"\n        }\n    }\n  \
    \  return result.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxug78l7w.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let words = sentence.split(separator: \" \") else { return \"\" }\n\
    \          ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxug78l7w.swift:20:26:\
    \ error: no exact matches in call to instance method 'index'\n        let index\
    \ = word.index(word, startIndex: 0, offsetBy: 1)\n                         ^\n\
    /tmp/tmpxug78l7w.swift:20:26: note: candidate has partially matching parameter\
    \ list (Substring.Index, offsetBy: Int)\n        let index = word.index(word,\
    \ startIndex: 0, offsetBy: 1)\n                         ^\n/tmp/tmpxug78l7w.swift:20:26:\
    \ note: candidate has partially matching parameter list (Substring.Index, offsetBy:\
    \ Int)\n        let index = word.index(word, startIndex: 0, offsetBy: 1)\n   \
    \                      ^\n/tmp/tmpxug78l7w.swift:20:26: note: candidate has partially\
    \ matching parameter list (Substring.Index, offsetBy: Int)\n        let index\
    \ = word.index(word, startIndex: 0, offsetBy: 1)\n                         ^\n\
    /tmp/tmpxug78l7w.swift:21:27: error: value of type 'String.SubSequence' (aka 'Substring')\
    \ has no member 'length'\n        if (index == word.length - 1) || (index == word.length)\
    \  {\n                     ~~~~ ^~~~~~\n/tmp/tmpxug78l7w.swift:21:57: error: value\
    \ of type 'String.SubSequence' (aka 'Substring') has no member 'length'\n    \
    \    if (index == word.length - 1) || (index == word.length)  {\n            \
    \                                       ~~~~ ^~~~~~\n/tmp/tmpxug78l7w.swift:22:26:\
    \ error: cannot find 'stringInterpolationSegment' in scope\n            result\
    \ += \"\\(stringInterpolationSegment(word))\"\n                         ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxug78l7w.swift:25:26: error: cannot find 'stringInterpolationSegment'\
    \ in scope\n            result += \"\\(stringInterpolationSegment(word[index...]))\"\
    \n                         ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxug78l7w.swift:25:57:\
    \ error: no exact matches in call to subscript \n            result += \"\\("
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // your code goes here\n    let wordArray = sentence.components(separatedBy:\
    \ \" \")\n    var result = \"\"\n    for word in wordArray {\n        let length\
    \ = countLetters(word: word)\n        if length == 2 {\n            for letter\
    \ in word {\n                if letter == letter {\n                    result\
    \ = result + \" \" + word\n                }\n            }\n        }\n    }\n\
    \    return result.dropLast()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpo0v6hiom.swift:18:30: error: value of type 'String' has no member\
    \ 'components'\n    let wordArray = sentence.components(separatedBy: \" \")\n\
    \                    ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpo0v6hiom.swift:30:19: error:\
    \ no 'dropLast' candidates produce the expected contextual result type 'String'\n\
    \    return result.dropLast()\n                  ^\nSwift.Sequence:5:40: note:\
    \ 'dropLast' produces '[String.Element]' (aka 'Array<Character>'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func dropLast(_\
    \ k: Int = 1) -> [Self.Element]\n                                       ^\nSwift.Collection:4:40:\
    \ note: 'dropLast' produces 'String.SubSequence' (aka 'Substring'), not the expected\
    \ contextual result type 'String'\n    @inlinable public __consuming func dropLast(_\
    \ k: Int = 1) -> Self.SubSequence\n                                       ^\n\
    /tmp/tmpo0v6hiom.swift:21:22: error: cannot find 'countLetters' in scope\n   \
    \     let length = countLetters(word: word)\n                     ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n\n    for word in sentence.split(\"\
    \ \") {\n        if isPrimeNumber(word.length) == true {\n            result +=\
    \ \" \" + word\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpyjzliteo.swift:19:26: error: no exact matches in call to instance\
    \ method 'split'\n    for word in sentence.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var num = \"1\"\n    var\
    \ final = \"\"\n    for char in sentence.characters {\n        if char == \" \"\
    \ {\n            final = final + char\n        }\n        if num.isPrime {\n \
    \           if char == \"{\" {\n                num = \"1\"\n            }\n \
    \           if char == \"}\" {\n                num = \"2\"\n            }\n \
    \           if char == \",\" {\n                num = \"3\"\n            }\n \
    \           if char == \".\" {\n                num = \"4\"\n            }\n \
    \           if char == \":\" {\n                num = \"5\"\n            }\n \
    \           if char == \"-\" {\n                num = \"6\"\n            }\n \
    \           if char == \"_\" {\n                num = \"7\"\n            }\n \
    \           if char == \"$\" {\n                num = \"8\"\n            }\n \
    \           if char == \",\" {\n                num = \"9\"\n            }\n \
    \           if char == \"?\" {\n                num = \"0\"\n            }\n \
    \           if char == \"-\" {\n                num = \"-\"\n            }\n \
    \           if char == \"/\" {\n                num = \"/\"\n            }\n \
    \           if char == \",\" {\n                num = \"@\"\n            }\n \
    \           if char == \"%\" {\n                num = \"~\"\n            }\n \
    \           if char == \":\" {\n                num = \"$\"\n            }\n \
    \           if char == \"+\" {\n                num = \"&\"\n            }\n \
    \           if char == \"*\" {\n                num = \"?\"\n            }\n \
    \           if char == \"?\" {\n                num = \"?\"\n            }\n \
    \           if char == \"!\" {\n                num = \"!\"\n            }\n \
    \           if char == \"{\" {\n                num = \"?\"\n            }\n \
    \           if char == \"}\" {\n                num = \"?\"\n            }\n \
    \           if char == \",\" {\n                num = \"?\"\n            }\n \
    \           if char == \".\" {\n                num = \"?\"\n            }\n \
    \           if char == \":\" {\n                num = \"?\"\n            }\n \
    \           if char == \"-\" {\n                num = \"?\"\n            }\n \
    \           if char == \"_\" {\n                num = \"?\"\n            }\n \
    \           if char == \"$\" {\n                num = \"?\"\n            }\n \
    \           if char == \",\" {\n                num = \"?\"\n            }\n \
    \           if char == \"?\" {\n                num = \"?\"\n            }\n \
    \           if char == \"-\" {\n                num = \"?\"\n            }\n \
    \           if char == \"/\" {\n                num = \"?\"\n            }\n \
    \           if char == \"%\" {\n                num = \"?\"\n            }\n \
    \           if char == \":\" {\n                num = \"?\"\n            }\n \
    \           if char\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp6fac_dlr.swift:124:20: error: expected '{' after 'if' condition\n\
    \            if char\n                   ^\n/tmp/tmp6fac_dlr.swift:146:55: error:\
    \ expected '}' at end of brace statement\nassert(words_in_sentence(sentence: \"\
    here is\") == \"is\")\n                                                      ^\n\
    /tmp/tmp6fac_dlr.swift:20:37: note: to match this opening '{'\n    for char in\
    \ sentence.characters {\n                                    ^\n/tmp/tmp6fac_dlr.swift:146:55:\
    \ error: expected '}' at end of brace statement\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")\n                                                  \
    \    ^\n/tmp/tmp6fac_dlr.swift:16:52: note: to match this opening '{'\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n                                                   ^\n\
    /tmp/tmp6fac_dlr.swift:20:26: error: 'characters' is unavailable: Please use String\
    \ directly\n    for char in sentence.characters {\n                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6fac_dlr.swift:22:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            final = final + char\n                            ^\n/tmp/tmp6fac_dlr.swift:24:16:\
    \ error: value of type 'String' has no member 'isPrime'\n        if num.isPrime\
    \ {\n           ~~~ ^~~~~~~\n/tmp/tmp6fac_dlr.swift:124:16: error: cannot convert\
    \ value of type 'Character' to expected condition type 'Bool'\n            if\
    \ char\n               ^~~~\n/tmp/tmp6fac_dlr.swift:128:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    var letters = Set<Character>()\n    var result: String = \"\"\n    for c\
    \ in sentence {\n        letters.insert(c)\n    }\n    var maxLen = Int.max\n\
    \    for c in letters {\n        if maxLen % c == 0 {\n            maxLen = maxLen\
    \ / c\n        }\n    }\n    for i in 2...maxLen {\n        for c in letters {\n\
    \            if i%c == 0 {\n                if letters.contains(String(c)) {\n\
    \                    result += c\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfr5n1lig.swift:27:21: error: cannot convert value of type 'Character'\
    \ to expected argument type 'Int'\n        if maxLen % c == 0 {\n            \
    \        ^\n/tmp/tmpfr5n1lig.swift:28:31: error: cannot convert value of type\
    \ 'Character' to expected argument type 'Int'\n            maxLen = maxLen / c\n\
    \                              ^\n/tmp/tmpfr5n1lig.swift:33:18: error: cannot\
    \ convert value of type 'Character' to expected argument type 'Int'\n        \
    \    if i%c == 0 {\n                 ^\n/tmp/tmpfr5n1lig.swift:35:31: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \               result += c\n                              ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence.lowercased())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp3yyum34m.swift:17:30: error: missing argument label 'sentence:'\
    \ in call\n    return words_in_sentence(sentence.lowercased())\n             \
    \                ^\n                             sentence: \n"
  stdout: ''
  timestamp: 1659824544
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    sentence.split(separator: \"\
    \ \").forEach {\n        let letter = String($0)\n        if let count = countLetter(letter)\
    \ {\n            if isPrimeNumber(count) {\n                result += letter\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp45isheyx.swift:20:24: error: cannot find 'countLetter' in scope\n\
    \        if let count = countLetter(letter) {\n                       ^~~~~~~~~~~\n\
    /tmp/tmp45isheyx.swift:21:16: error: cannot find 'isPrimeNumber' in scope\n  \
    \          if isPrimeNumber(count) {\n               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_helper(sentence)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps2wosuzz.swift:17:12: error: cannot find 'words_in_sentence_helper'\
    \ in scope\n    return words_in_sentence_helper(sentence)\n           ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n  var result: String = \"\"\n  if let sentence = sentence.split(separator:\
    \ \" \").map(String.init) {\n    if sentence.filter({ (c) -> Bool in\n      if\
    \ c != \".\" && c != \"?\" && c != \"!\" && c != \"-\"\n    }.isEmpty) == nil\
    \ {\n      for word in sentence {\n        if checkPrimeNumber(word: word) {\n\
    \          result += \" \" + word\n        }\n      }\n    }\n  }\n  return result.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_wu_zfg3.swift:20:54: error: expected '{' after 'if' condition\n\
    \      if c != \".\" && c != \"?\" && c != \"!\" && c != \"-\"\n             \
    \                                        ^\n/tmp/tmp_wu_zfg3.swift:21:7: error:\
    \ value of type '(_) -> Bool' has no member 'isEmpty'\n    }.isEmpty) == nil {\n\
    ~~~~~ ^~~~~~~\n/tmp/tmp_wu_zfg3.swift:23:12: error: cannot find 'checkPrimeNumber'\
    \ in scope\n        if checkPrimeNumber(word: word) {\n           ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp_wu_zfg3.swift:18:6: error: initializer for conditional binding must have\
    \ Optional type, not '[String]'\n  if let sentence = sentence.split(separator:\
    \ \" \").map(String.init) {\n     ^              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_wu_zfg3.swift:29:17: error: value of type 'String' has no member 'trimmingCharacters'\n\
    \  return result.trimmingCharacters(in: .whitespacesAndNewlines)\n         ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp_wu_zfg3.swift:29:41: error: cannot infer contextual\
    \ base in reference to member 'whitespacesAndNewlines'\n  return result.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n                                       ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence_aux(sentence, \"\")\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkpc3noaj.swift:17:12: error: cannot find 'words_in_sentence_aux'\
    \ in scope\n    return words_in_sentence_aux(sentence, \"\")\n           ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978936
- exit_code: -4
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    \n    return \"\"\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: Exception
  stderr: 'tmpigf3620o/tmpigf3620o.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e8011ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e7fe15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e7fe15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e7fe147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpigf3620o                        0x00005599e12c3307 <unavailable> + 4871

    5    libc.so.6                          0x00002b2e8030a460 __libc_start_main +
    245

    6    tmpigf3620o                        0x00005599e12c2f49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n  if sentence.rangeOfCharacter(from: CharacterSet(charactersIn:\
    \ \"abcdefghijklmnopqrstuvwxyz\")) == nil {\n    return \"\"\n  }\n  var result\
    \ = \"\"\n  var isPrime = true\n  \n  for ch in sentence.unicodeScalars {\n  \
    \  if !isPrime || ch % 5 == 0 || ch % 7 == 0 {\n      result += String(UnicodeScalar(ch.value))\n\
    \      isPrime = false\n    }\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj8sqtd_8.swift:17:38: error: cannot find 'CharacterSet' in scope\n\
    \  if sentence.rangeOfCharacter(from: CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\"\
    )) == nil {\n                                     ^~~~~~~~~~~~\n/tmp/tmpj8sqtd_8.swift:17:15:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n  if sentence.rangeOfCharacter(from:\
    \ CharacterSet(charactersIn: \"abcdefghijklmnopqrstuvwxyz\")) == nil {\n     ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmpj8sqtd_8.swift:24:20: error: cannot convert value\
    \ of type 'Unicode.Scalar' to expected argument type 'Int'\n    if !isPrime ||\
    \ ch % 5 == 0 || ch % 7 == 0 {\n                   ^\n/tmp/tmpj8sqtd_8.swift:24:35:\
    \ error: cannot convert value of type 'Unicode.Scalar' to expected argument type\
    \ 'Int'\n    if !isPrime || ch % 5 == 0 || ch % 7 == 0 {\n                   \
    \               ^\n/tmp/tmpj8sqtd_8.swift:25:17: error: no exact matches in call\
    \ to initializer \n      result += String(UnicodeScalar(ch.value))\n         \
    \       ^\nSwift.String:3:23: note: found candidate with type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>')\n    @inlinable public init(_ scalar: Unicode.Scalar)\n\
    \                      ^\nSwift.String:4:23: note: found candidate with type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>')\n    @inlinable public init<T>(_ value: T)\
    \ where T : LosslessStringConvertible\n                      ^\nSwift.String:2:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n\
    \    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:6:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n\
    \    public init<Subject>(reflecting subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" || sentence.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) != nil {\n        return \"\"\n    }\n\n    var result:\
    \ String = \"\"\n\n    if sentence.rangeOfCharacter(from: .whitespacesAndNewlines)\
    \ != nil {\n        let range = sentence.rangeOfCharacter(from: .whitespacesAndNewlines)\n\
    \        let words = sentence.substringToIndex(advance(range.lowerBound, range.upperBound\
    \ + 1))\n        for word in words.split(separator: \" \") {\n            let\
    \ prime = prime_number_of_size(word.count)\n            if prime > 0 {\n     \
    \           result += word + \" \"\n            }\n        }\n    } else {\n \
    \       let words = sentence.split(separator: \" \")\n        for word in words\
    \ {\n            let prime = prime_number_of_size(word.count)\n            if\
    \ prime > 0 {\n                result += word + \" \"\n            }\n       \
    \ }\n    }\n\n    return result.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp61ruxz1n.swift:17:35: error: value of type 'String' has no member\
    \ 'rangeOfCharacter'\n    if sentence == \"\" || sentence.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) != nil {\n                         ~~~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp61ruxz1n.swift:17:59: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlines'\n    if sentence == \"\" || sentence.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) != nil {\n                                        \
    \                 ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp61ruxz1n.swift:23:17: error:\
    \ value of type 'String' has no member 'rangeOfCharacter'\n    if sentence.rangeOfCharacter(from:\
    \ .whitespacesAndNewlines) != nil {\n       ~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp61ruxz1n.swift:23:41:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    if sentence.rangeOfCharacter(from: .whitespacesAndNewlines) != nil {\n  \
    \                                     ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp61ruxz1n.swift:24:30:\
    \ error: value of type 'String' has no member 'rangeOfCharacter'\n        let\
    \ range = sentence.rangeOfCharacter(from: .whitespacesAndNewlines)\n         \
    \           ~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp61ruxz1n.swift:24:54: error: cannot\
    \ infer contextual base in reference to member 'whitespacesAndNewlines'\n    \
    \    let range = sentence.rangeOfCharacter(from: .whitespacesAndNewlines)\n  \
    \                                                  ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp61ruxz1n.swift:25:47:\
    \ error: cannot find 'advance' in scope\n        let words = sentence.substringToIndex(advance(range.lowerBound,\
    \ range.upperBound + 1))\n                                              ^~~~~~~\n\
    /tmp/tmp61ruxz1n.swift:25:30: error: value of type 'String' has no member 'substringToIndex'\n\
    \        let words = sentence.substringToIndex(advance(range.lowerBound, range.upperBound\
    \ + 1))\n                    ~~~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp61ruxz1n.swift:35:25:\
    \ error: cannot find 'prime_number_of_size' in scope\n            let prime =\
    \ prime_number_of_size(word.count)\n      "
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    if let letters = sentence.characters\
    \ {\n        for i in 1..<(Int(sqrt(Double(letters.count)))+1) {\n           \
    \ if letters.indices.contains(i as Int) {\n                for j in 1..<letters.count\
    \ {\n                    if letters[i-1] == letters[j-1] {\n                 \
    \       result += String(letters[i-1])\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpzavf4nbz.swift:18:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    if let letters = sentence.characters {\n          \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzavf4nbz.swift:19:27: error: cannot find 'sqrt' in scope\n      \
    \  for i in 1..<(Int(sqrt(Double(letters.count)))+1) {\n                     \
    \     ^~~~\n/tmp/tmpzavf4nbz.swift:18:8: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    if let letters = sentence.characters\
    \ {\n       ^             ~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence1(sentence: sentence).joined(separator:\
    \ \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphwlqvvad.swift:17:12: error: cannot find 'words_in_sentence1' in\
    \ scope\n    return words_in_sentence1(sentence: sentence).joined(separator: \"\
    \ \")\n           ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // only letters allowed\n    if !sentence.isLetter()\
    \ {\n        return \"\"\n    }\n\n    var result = \"\"\n    var next = 1\n \
    \   for letter in sentence.characters {\n        if isPrime(next) {\n        \
    \    result = result + letter\n        }\n        next = next + 1\n    }\n\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpae9dhnyz.swift:18:18: error: value of type 'String' has no member\
    \ 'isLetter'\n    if !sentence.isLetter() {\n        ~~~~~~~~ ^~~~~~~~\n/tmp/tmpae9dhnyz.swift:24:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in sentence.characters {\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpae9dhnyz.swift:25:12: error: cannot find\
    \ 'isPrime' in scope\n        if isPrime(next) {\n           ^~~~~~~\n/tmp/tmpae9dhnyz.swift:26:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result = result + letter\n                              ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let words = sentence.components(separatedBy:\
    \ \" \") else { return \"\" }\n    let allPrimeNumbers = words.compactMap({ Int($0)\
    \ }).filter({ $0 > 1 }).sorted()\n    return words.filter({\n        guard let\
    \ index = allPrimeNumbers.index(of: $0) else { return false }\n        let nextIndex\
    \ = allPrimeNumbers.index(of: $0, offsetBy: index + 1)\n        return nextIndex\
    \ == allPrimeNumbers.endIndex\n    }).joined(separator: \" \")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpk3ctnh63.swift:17:32: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = sentence.components(separatedBy: \" \")\
    \ else { return \"\" }\n                      ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let list = sentence.components(separatedBy: \" \")\n\
    \    let sortedList = list.sorted()\n    return sortedList.filter { x -> Bool\
    \ in\n        let prime = Int(log(x)) + 2\n        return (prime % x == 0)\n \
    \   }.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4wi_sggu.swift:17:25: error: value of type 'String' has no member\
    \ 'components'\n    let list = sentence.components(separatedBy: \" \")\n     \
    \          ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp4wi_sggu.swift:20:25: error: cannot find\
    \ 'log' in scope\n        let prime = Int(log(x)) + 2\n                      \
    \  ^~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return solution(sentence)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmps4uyyyn4.swift:17:12: error: cannot find 'solution' in scope\n\
    \    return solution(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // TODO: Write your code here\n    var newString =\
    \ \"\"\n    var primeString = \"\"\n    for char in sentence {\n        let num\
    \ = Int(String(char).utf8)!\n        if num == 2 {\n            primeString +=\
    \ String(char)\n        }\n    }\n    return primeString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpoeenke_w.swift:21:19: error: initializer 'init(_:radix:)' requires\
    \ that 'String.UTF8View' conform to 'StringProtocol'\n        let num = Int(String(char).utf8)!\n\
    \                  ^\nSwift.FixedWidthInteger:2:23: note: where 'S' = 'String.UTF8View'\n\
    \    @inlinable public init?<S>(_ text: S, radix: Int = 10) where S : StringProtocol\n\
    \                      ^\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence == \"\" {\n        return \"\"\n    }\n\
    \    var letters = Array()\n    for letter in sentence.characters {\n        if\
    \ letter.isLetter() {\n            letters.append(letter)\n        }\n    }\n\
    \    var prime = \"\"\n    for letter in letters {\n        if isPrime(letter.unicodeScalars)\
    \ {\n            prime = prime + letter\n        }\n    }\n    return prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppu4mrh_b.swift:20:19: error: generic parameter 'Element' could\
    \ not be inferred\n    var letters = Array()\n                  ^\n/tmp/tmppu4mrh_b.swift:20:19:\
    \ note: explicitly specify the generic arguments to fix this issue\n    var letters\
    \ = Array()\n                  ^\n                       <Any>\n/tmp/tmppu4mrh_b.swift:21:28:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in sentence.characters {\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmppu4mrh_b.swift:22:19: error: cannot call\
    \ value of non-function type 'Bool'\n        if letter.isLetter() {\n        \
    \          ^       ~~\n                          \n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code goes here\n    var result = \"\"\n   \
    \ let arr = sentence.characters.split{$0 == \" \"}.map{String($0)}\n    for idx\
    \ in 0..<arr.count {\n        if arr[idx].characters.contains(\"2\") {\n     \
    \       let isPrime = true\n            for iidx in 0..<idx {\n              \
    \  if arr[iidx].characters.contains(\"2\") {\n                    isPrime = false\n\
    \                    break\n                }\n            }\n            if isPrime\
    \ {\n                result.append(arr[idx])\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpf_8hjo8z.swift:19:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = sentence.characters.split{$0 == \" \"}.map{String($0)}\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpf_8hjo8z.swift:21:21: error: 'characters' is unavailable:\
    \ Please use String directly\n        if arr[idx].characters.contains(\"2\") {\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpf_8hjo8z.swift:24:30: error: 'characters' is unavailable: Please\
    \ use String directly\n                if arr[iidx].characters.contains(\"2\"\
    ) {\n                             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpf_8hjo8z.swift:25:21: error: cannot assign to value:\
    \ 'isPrime' is a 'let' constant\n                    isPrime = false\n       \
    \             ^~~~~~~\n/tmp/tmpf_8hjo8z.swift:22:13: note: change 'let' to 'var'\
    \ to make it mutable\n            let isPrime = true\n            ^~~\n      \
    \      var\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let wordsCount = sentence.characters.split(separator:\
    \ \" \").count\n    let result = sentence.characters.split(separator: \" \").map(String.init).filter(String.init).sorted().reduce(\"\
    \", combine: { (result, item) -> String in\n        let length = item.count\n\
    \        var result = String(repeating: \"\", count: length)\n        for i in\
    \ 0..<length {\n            result[length-i] = item[i]\n        }\n        return\
    \ result\n    })\n    return result.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpxe4x6_bs.swift:17:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let wordsCount = sentence.characters.split(separator:\
    \ \" \").count\n                              ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpxe4x6_bs.swift:18:18: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n    let result = sentence.characters.split(separator:\
    \ \" \").map(String.init).filter(String.init).sorted().reduce(\"\", combine: {\
    \ (result, item) -> String in\n                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxe4x6_bs.swift:26:43: error: cannot infer contextual base in reference\
    \ to member 'whitespacesAndNewlines'\n    return result.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n                                         ~^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979061
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(chars: sentence[..<sentence.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpoxzwt04w.swift:17:29: error: incorrect argument label in call (have\
    \ 'chars:', expected 'sentence:')\n    return words_in_sentence(chars: sentence[..<sentence.count])\n\
    \                            ^~~~~~\n                             sentence\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return Solution.words_in_sentence_S(sentence)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4onc9q_v.swift:17:12: error: cannot find 'Solution' in scope\n\
    \    return Solution.words_in_sentence_S(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return solution.words_in_sentence_V2(sentence)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpjid32ael.swift:17:12: error: cannot find 'solution' in scope\n\
    \    return solution.words_in_sentence_V2(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentenceComponents = sentence.components(separatedBy:\
    \ \" \") else {\n        return \"_\"\n    }\n\n    var result = \"\"\n    var\
    \ primeNumbers = 1\n\n    for word in sentenceComponents {\n        if let word\
    \ = word.lowercased() {\n            // Check current number is prime\n      \
    \      if word == \"_\" {\n                continue\n            }\n         \
    \   if primeNumbers == Int(ceil(Double(word.count) / 2)) {\n                result\
    \ += \" \" + word\n            } else {\n                result += word\n    \
    \        }\n            primeNumbers += 1\n        }\n    }\n    return result.trimmingCharacters(in:\
    \ \" .\").lowercased()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpd_vbp4bc.swift:17:45: error: value of type 'String' has no member\
    \ 'components'\n    guard let sentenceComponents = sentence.components(separatedBy:\
    \ \" \") else {\n                                   ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpd_vbp4bc.swift:38:19:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    return\
    \ result.trimmingCharacters(in: \" .\").lowercased()\n           ~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n\treturn words_in_sentence(sentence: sentence, words: [])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_omvhzl.swift:17:54: error: extra argument 'words' in call\n \
    \       return words_in_sentence(sentence: sentence, words: [])\n            \
    \                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1659979025
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentenceAsCharactersArray = sentence\n  \
    \      .unicodeScalars\n        .compactMap { $0 }\n        .filter { !$0.isWhitespace\
    \ }\n        .map { String($0) }\n    else { return \"\" }\n    let primeNumbers\
    \ = sentenceAsCharactersArray\n        .map { Int($0) }\n        .filter { ($0\
    \ >= 2) && ($0 % $1) == 0 }\n        .sorted { $0 < $1 }\n        .map { $0 }\n\
    \    return primeNumbers.joined(separator: \" \")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp7hm18ew9.swift:19:21: error: expected 'else' after 'guard' condition\n\
    \        .compactMap { $0 }\n                    ^\n                    else \n\
    /tmp/tmp7hm18ew9.swift:19:23: error: anonymous closure argument not contained\
    \ in a closure\n        .compactMap { $0 }\n                      ^\n/tmp/tmp7hm18ew9.swift:22:5:\
    \ error: expected expression\n    else { return \"\" }\n    ^\n/tmp/tmp7hm18ew9.swift:18:10:\
    \ error: generic parameter 'ElementOfResult' could not be inferred\n        .unicodeScalars\n\
    \         ^\nSwift.Sequence:2:28: note: in call to function 'compactMap'\n   \
    \ @inlinable public func compactMap<ElementOfResult>(_ transform: (Self.Element)\
    \ throws -> ElementOfResult?) rethrows -> [ElementOfResult]\n                \
    \           ^\n/tmp/tmp7hm18ew9.swift:20:10: error: cannot infer contextual base\
    \ in reference to member 'filter'\n        .filter { !$0.isWhitespace }\n    \
    \    ~^~~~~~\n/tmp/tmp7hm18ew9.swift:23:24: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let primeNumbers = sentenceAsCharactersArray\n        \
    \               ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979053
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n  return sentence.reduce(\"\") { $0 + String($1).characters.filter\
    \ { $0.isLetter } }.characters.map { $0 }.sorted().map { $0 % 2 == 0 ? $0 + 1\
    \ : $0 }.reduce(\"\") { $0 + $1 + \" \" + $1 }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmprpsx9t1y.swift:17:10: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n  return sentence.reduce(\"\") { $0 + String($1).characters.filter\
    \ { $0.isLetter } }.characters.map { $0 }.sorted().map { $0 % 2 == 0 ? $0 + 1\
    \ : $0 }.reduce(\"\") { $0 + $1 + \" \" + $1 }\n         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979333
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var newsentence = \"\"\n    for i in sentence.characters\
    \ {\n        if isPrimeNumber(i: String(i)) {\n            newsentence += i\n\
    \        }\n    }\n    return newsentence\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpm4rckyof.swift:18:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in sentence.characters {\n                  \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpm4rckyof.swift:19:12:\
    \ error: cannot find 'isPrimeNumber' in scope\n        if isPrimeNumber(i: String(i))\
    \ {\n           ^~~~~~~~~~~~~\n/tmp/tmpm4rckyof.swift:20:28: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            newsentence\
    \ += i\n                           ^\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var i = 0\n    var n =\
    \ len(sentence)\n    var j = 0\n    var newString = \"\"\n    while i < n {\n\
    \        if j == 2 {\n            newString += String(sentence.characterAtIndex(i))\n\
    \            i += 1\n            j = 0\n            continue\n        }\n    \
    \    if j % 2 == 0 {\n            newString += String(sentence.characterAtIndex(i))\n\
    \            i += 1\n            j = 0\n            continue\n        } else {\n\
    \            j += 2\n        }\n    }\n    return newString\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpj_rq5sdq.swift:19:13: error: cannot find 'len' in scope\n    var\
    \ n = len(sentence)\n            ^~~\n/tmp/tmpj_rq5sdq.swift:24:42: error: value\
    \ of type 'String' has no member 'characterAtIndex'\n            newString +=\
    \ String(sentence.characterAtIndex(i))\n                                ~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmpj_rq5sdq.swift:30:42: error: value of type 'String'\
    \ has no member 'characterAtIndex'\n            newString += String(sentence.characterAtIndex(i))\n\
    \                                ~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    var newString = \"\"\n\
    \    var newArr = [Int]()\n    var newSet = Set<Int>()\n    for char in sentence\
    \ {\n        switch char {\n        case \"a\":\n            newArr.append(0)\n\
    \        case \"b\":\n            newArr.append(1)\n        case \"c\":\n    \
    \        newArr.append(2)\n        case \"d\":\n            newArr.append(3)\n\
    \        case \"e\":\n            newArr.append(4)\n        case \"f\":\n    \
    \        newArr.append(5)\n        case \"g\":\n            newArr.append(6)\n\
    \        case \"h\":\n            newArr.append(7)\n        case \"i\":\n    \
    \        newArr.append(8)\n        case \"j\":\n            newArr.append(9)\n\
    \        case \"k\":\n            newArr.append(10)\n        case \"l\":\n   \
    \         newArr.append(11)\n        case \"m\":\n            newArr.append(12)\n\
    \        case \"n\":\n            newArr.append(13)\n        case \"o\":\n   \
    \         newArr.append(14)\n        case \"p\":\n            newArr.append(15)\n\
    \        case \"q\":\n            newArr.append(16)\n        case \"r\":\n   \
    \         newArr.append(17)\n        case \"s\":\n            newArr.append(18)\n\
    \        case \"t\":\n            newArr.append(19)\n        case \"u\":\n   \
    \         newArr.append(20)\n        case \"v\":\n            newArr.append(21)\n\
    \        case \"w\":\n            newArr.append(22)\n        case \"x\":\n   \
    \         newArr.append(23)\n        case \"y\":\n            newArr.append(24)\n\
    \        case \"z\":\n            newArr.append(25)\n        case \"A\":\n   \
    \         newArr.append(26)\n        case \"B\":\n            newArr.append(27)\n\
    \        case \"C\":\n            newArr.append(28)\n        case \"D\":\n   \
    \         newArr.append(29)\n        case \"E\":\n            newArr.append(30)\n\
    \        case \"F\":\n            newArr.append(31)\n        case \"G\":\n   \
    \         newArr.append(32)\n        case \"H\":\n            newArr.append(33)\n\
    \        case \"I\":\n            newArr.append(34)\n        case \"J\":\n   \
    \         newArr.append(35)\n        case \"K\":\n            newArr.append(36)\n\
    \        case \"L\":\n            newArr.append(37)\n        case \"M\":\n   \
    \         newArr.append(38)\n        case \"N\":\n            newArr.append(39)\n\
    \        case \"O\":\n            newArr.append(40)\n        case \"P\":\n   \
    \         newArr.append(41)\n        case \"Q\":\n            newArr.append(42)\n\
    \        case \"R\":\n            newArr.append(43)\n        case \"S\":\n   \
    \         newArr.append(44)\n        case \"T\":\n            newArr.append(45)\n\
    \        case \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpos7pfyr1.swift:115:14: error: unterminated string literal\n   \
    \     case \"\n             ^\n/tmp/tmpos7pfyr1.swift:115:15: error: expected\
    \ ':' after 'case'\n        case \"\n              ^\n/tmp/tmpos7pfyr1.swift:137:55:\
    \ error: expected '}' at end of brace statement\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")\n                                                  \
    \    ^\n/tmp/tmpos7pfyr1.swift:21:26: note: to match this opening '{'\n    for\
    \ char in sentence {\n                         ^\n/tmp/tmpos7pfyr1.swift:137:55:\
    \ error: expected '}' at end of brace statement\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")\n                                                  \
    \    ^\n/tmp/tmpos7pfyr1.swift:16:52: note: to match this opening '{'\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n                                                   ^\n\
    /tmp/tmpos7pfyr1.swift:119:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n/tmp/tmpos7pfyr1.swift:18:9: warning: initialization of variable\
    \ 'newString' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    var newString = \"\"\n    ~~~~^~~~~~~~~\n    _\n/tmp/tmpos7pfyr1.swift:20:9:\
    \ warning: initialization of variable 'newSet' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var newSet = Set<Int>()\n    ~~~~^~~~~~\n\
    \    _\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \    var result = \"\"\n    var index = 0\n    while index < sentence.count {\n\
    \        let word = sentence[index]\n        if isPrimeNumber(word: word) && result.isEmpty\
    \ {\n            result += word\n        } else {\n            if result.isEmpty\
    \ {\n                result = word\n            } else {\n                result\
    \ += \" \" + word\n            }\n        }\n        index += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfom879p5.swift:23:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let word\
    \ = sentence[index]\n                   ^~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpfom879p5.swift:24:12: error:\
    \ cannot find 'isPrimeNumber' in scope\n        if isPrimeNumber(word: word) &&\
    \ result.isEmpty {\n           ^~~~~~~~~~~~~\n/tmp/tmpfom879p5.swift:25:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result += word\n                      ^\n/tmp/tmpfom879p5.swift:28:26:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \      result = word\n                         ^~~~\n/tmp/tmpfom879p5.swift:30:33:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result += \" \" + word\n                                ^\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    var nextNum = 1\n    for i in\
    \ 0..<sentence.characters.count {\n        if let c = sentence[i] {\n        \
    \    if c == '-' {\n                nextNum = nextNum * 10 + 1\n             \
    \   continue\n            }\n            let mult = nextNum * 10\n           \
    \ if mult == Int(c) {\n                result += String(c)\n            } else\
    \ {\n                result += String(c)\n                result += String(mult\
    \ - Int(c))\n            }\n            result += \" \"\n            nextNum =\
    \ 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp5ltz57ie.swift:21:21: error: single-quoted string literal found,\
    \ use '\"'\n            if c == '-' {\n                    ^~~\n             \
    \       \"-\"\n/tmp/tmp5ltz57ie.swift:19:27: error: 'characters' is unavailable:\
    \ Please use String directly\n    for i in 0..<sentence.characters.count {\n \
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5ltz57ie.swift:20:20: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ let c = sentence[i] {\n                   ^~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmp5ltz57ie.swift:26:24: error:\
    \ no exact matches in call to initializer \n            if mult == Int(c) {\n\
    \                       ^\nSwift.Int:7:12: note: candidate expects value of type\
    \ 'Float16' for parameter #1 (got 'Character')\n    public init(_ source: Float16)\n\
    \           ^\nSwift.Int:10:12: note: candidate expects value of type 'Float'\
    \ for parameter #1 (got 'Character')\n    public init(_ source: Float)\n     \
    \      ^\nSwift.Int:12:12: note: candidate expects value of type 'Double' for\
    \ parameter #1 (got 'Character')\n    public init(_ source: Double)\n        \
    \   ^\nSwift.Int:14:12: note: candidate expects value of type 'Float80' for parameter\
    \ #1 (got 'Character')\n    public init(_ source: Float80)\n           ^\nSwift.Int:28:12:\
    \ note: candidate expects value of type 'Builtin.Int64' for parameter #1 (got\
    \ 'Character')\n    public init(_ _value: Builtin.Int64)\n           ^\nSwift.Int:61:12:\
    \ note: candidate expects value of type 'Builtin.Word' for parameter #1 (got 'Character')\n\
    \    public init(_ _v: Builtin.Word)\n           ^\n/tmp/tmp5ltz57ie.swift:30:41:\
    \ error: no exact matches in call to initializer \n                result += String(mult\
    \ - Int(c))\n                                        ^\nSwift.Int:7:12: note:\
    \ candidate expects va"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return solution.words_in_sentence(sentence)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpkvo52fl1.swift:17:12: error: cannot find 'solution' in scope\n\
    \    return solution.words_in_sentence(sentence)\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, wordLength:\
    \ wordLength(sentence))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp7s5c5014.swift:17:62: error: cannot find 'wordLength' in scope\n\
    \    return words_in_sentence(sentence: sentence, wordLength: wordLength(sentence))\n\
    \                                                             ^~~~~~~~~~\n/tmp/tmp7s5c5014.swift:17:62:\
    \ error: extra argument 'wordLength' in call\n    return words_in_sentence(sentence:\
    \ sentence, wordLength: wordLength(sentence))\n                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let sentence = sentence?.replacingOccurrences(of:\
    \ \" \", with: \" \").trimmingCharacters(in: .whitespaces) else { return \"\"\
    \ }\n\n    let counts: [Int: Int] = [:]\n    var primes: [Int] = []\n\n    for\
    \ letter in sentence.unicodeScalars.filter({ !$0.isASCII }) {\n        guard letter.value\
    \ % 2 == 0 else { continue }\n        counts[letter.value / 2] += 1\n    }\n\n\
    \    guard counts.isEmpty else { return \"\" }\n\n    for i in 2..<counts[count(counts)-1]\
    \ {\n        guard primes.contains(i) else { continue }\n        primes.append(i)\n\
    \    }\n\n    return sentence.replacingOccurrences(of: \" \", with: \"\").trimmingCharacters(in:\
    \ .whitespaces) + \"\\(i)\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp4_e3ah72.swift:17:36: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    guard let sentence = sentence?.replacingOccurrences(of:\
    \ \" \", with: \" \").trimmingCharacters(in: .whitespaces) else { return \"\"\
    \ }\n                         ~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp4_e3ah72.swift:17:101:\
    \ error: cannot infer contextual base in reference to member 'whitespaces'\n \
    \   guard let sentence = sentence?.replacingOccurrences(of: \" \", with: \" \"\
    ).trimmingCharacters(in: .whitespaces) else { return \"\" }\n                \
    \                                                                            \
    \       ~^~~~~~~~~~~\n/tmp/tmp4_e3ah72.swift:29:25: error: cannot find 'count'\
    \ in scope\n    for i in 2..<counts[count(counts)-1] {\n                     \
    \   ^~~~~\n/tmp/tmp4_e3ah72.swift:29:24: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n    for i in 2..<counts[count(counts)-1]\
    \ {\n                       ^\n/tmp/tmp4_e3ah72.swift:29:24: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n    for i\
    \ in 2..<counts[count(counts)-1] {\n                       ^\n               \
    \  (                       ?? <#default value#>)\n/tmp/tmp4_e3ah72.swift:29:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    for i in 2..<counts[count(counts)-1] {\n                       ^\n\
    \                                        !\n/tmp/tmp4_e3ah72.swift:34:103: error:\
    \ cannot find 'i' in scope\n    return sentence.replacingOccurrences(of: \" \"\
    , with: \"\").trimmingCharacters(in: .whitespaces) + \"\\(i)\"\n             \
    \                                                                            \
    \             ^\n/tmp/tmp4_e3ah72.swift:34:85: error: cannot infer contextual\
    \ base in reference to member 'whitespaces'\n    return sentence.replacingOccurrences(of:\
    \ \" \", with: \"\").trimmingCharacters(in: .whitespaces) + \"\\(i)\"\n      \
    \                                                                            \
    \ ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n\tlet words = sentence.components(separatedBy: \" \")\n\
    \t\n\tlet primes = words.filter({ (word: String) -> Bool in\n\t\tguard word.characters.count\
    \ >= 1 else {\n\t\t\treturn false\n\t\t}\n\t\tvar isPrime = true\n\t\t\n\t\tfor\
    \ letter in word {\n\t\t\tif Int(String(letter).unicodeScalars.first!.value) ==\
    \ 0 {\n\t\t\t\tisPrime = false\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn isPrime\n\t})\n\
    \t\n\treturn \" \".join(primes)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpr3pklieu.swift:17:23: error: value of type 'String' has no member\
    \ 'components'\n        let words = sentence.components(separatedBy: \" \")\n\
    \                    ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpr3pklieu.swift:34:13: error:\
    \ value of type 'String' has no member 'join'\n        return \" \".join(primes)\n\
    \               ~~~ ^~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard let words = sentence.components(separatedBy:\
    \ \" \") else {\n        return \"\"\n    }\n    var result = \"\"\n    for word\
    \ in words {\n        let count = count(from: word)\n        if count == 1 {\n\
    \            result += word\n            continue\n        }\n        if count\
    \ == 2 {\n            if result == \"\" {\n                result = word\n   \
    \         } else {\n                result += \" \" + word\n            }\n  \
    \          continue\n        }\n        if count % 2 != 0 {\n            result\
    \ += \"\\( word \"\n            continue\n        }\n        result += \"\\( word\
    \ \"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp0ij1nojv.swift:36:25: error: cannot find ')' to match opening '('\
    \ in string interpolation\n            result += \"\\( word \"\n             \
    \           ^\n/tmp/tmp0ij1nojv.swift:36:23: error: unterminated string literal\n\
    \            result += \"\\( word \"\n                      ^\n/tmp/tmp0ij1nojv.swift:39:21:\
    \ error: cannot find ')' to match opening '(' in string interpolation\n      \
    \  result += \"\\( word \"\n                    ^\n/tmp/tmp0ij1nojv.swift:39:19:\
    \ error: unterminated string literal\n        result += \"\\( word \"\n      \
    \            ^\n/tmp/tmp0ij1nojv.swift:17:32: error: value of type 'String' has\
    \ no member 'components'\n    guard let words = sentence.components(separatedBy:\
    \ \" \") else {\n                      ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0ij1nojv.swift:22:21:\
    \ error: use of local variable 'count' before its declaration\n        let count\
    \ = count(from: word)\n                    ^\n/tmp/tmp0ij1nojv.swift:22:13: note:\
    \ 'count' declared here\n        let count = count(from: word)\n            ^\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.characters.count > 0, \"The string\
    \ should not be empty\")\n    let wordArray = sentence.characters.split(separator:\
    \ \" \").filter({$0 != \"\\n\"})\n    let n = wordArray.count\n    let result\
    \ = \"\"\n    for i in 0..<n {\n        let start = i / 2\n        let end = n\
    \ - 1 - i\n        if wordArray[start].isPrime && wordArray[end].isPrime {\n \
    \           result += \" \" + wordArray[start] + \" \" + wordArray[end]\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmphf1mv2ok.swift:17:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    precondition(sentence.characters.count > 0, \"The string\
    \ should not be empty\")\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmphf1mv2ok.swift:18:30: error: 'characters'\
    \ is unavailable: Please use String directly\n    let wordArray = sentence.characters.split(separator:\
    \ \" \").filter({$0 != \"\\n\"})\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmphf1mv2ok.swift:24:29: error: value of\
    \ type 'String.SubSequence' (aka 'Substring') has no member 'isPrime'\n      \
    \  if wordArray[start].isPrime && wordArray[end].isPrime {\n           ~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmphf1mv2ok.swift:24:55: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'isPrime'\n        if wordArray[start].isPrime\
    \ && wordArray[end].isPrime {\n                                       ~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmphf1mv2ok.swift:25:20: error: left side of mutating operator\
    \ isn't mutable: 'result' is a 'let' constant\n            result += \" \" + wordArray[start]\
    \ + \" \" + wordArray[end]\n            ~~~~~~ ^\n/tmp/tmphf1mv2ok.swift:20:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let result = \"\"\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1659979028
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    precondition(sentence.length > 0, \"sentence should\
    \ have a non-zero length\")\n    return Array(sentence.characters).filter { (c)\
    \ -> Bool in\n        let primeNumber = isPrime(c)\n        return primeNumber\n\
    \    }.sorted()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8g3thg3h.swift:17:27: error: value of type 'String' has no member\
    \ 'length'\n    precondition(sentence.length > 0, \"sentence should have a non-zero\
    \ length\")\n                 ~~~~~~~~ ^~~~~~\n/tmp/tmp8g3thg3h.swift:19:27: error:\
    \ cannot find 'isPrime' in scope\n        let primeNumber = isPrime(c)\n     \
    \                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \n    var res = \"\"\n    var prime = 1\n    var currentChar: Character?\n\n \
    \   for char in sentence.characters {\n        if char.isLetter {\n          \
    \  if prime > 1 {\n                if current == nil {\n                    res\
    \ = char\n                }\n                else {\n                    res +=\
    \ currentChar!\n                }\n                currentChar = nil\n       \
    \         prime = 1\n            }\n            else {\n                currentChar\
    \ = char\n            }\n        }\n        else {\n            prime++\n    \
    \    }\n    }\n\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpfpkm9huq.swift:25:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in sentence.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpfpkm9huq.swift:28:20: error: cannot find 'current' in scope\n        \
    \        if current == nil {\n                   ^~~~~~~\n/tmp/tmpfpkm9huq.swift:29:27:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \          res = char\n                          ^~~~\n/tmp/tmpfpkm9huq.swift:32:39:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                    res += currentChar!\n                                   \
    \   ^\n/tmp/tmpfpkm9huq.swift:42:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            prime++\n                 ^~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return shortestPrimeSequence(sentence) + sentence.substring(1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpf98oe1gv.swift:17:12: error: cannot find 'shortestPrimeSequence'\
    \ in scope\n    return shortestPrimeSequence(sentence) + sentence.substring(1)\n\
    \           ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpf98oe1gv.swift:17:55: error: value\
    \ of type 'String' has no member 'substring'\n    return shortestPrimeSequence(sentence)\
    \ + sentence.substring(1)\n                                             ~~~~~~~~\
    \ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    return words_in_sentence(sentence: sentence, words:\
    \ [:])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpelyz12v1.swift:17:57: error: extra argument 'words' in call\n \
    \   return words_in_sentence(sentence: sentence, words: [:])\n               \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(){\n\
    \        if checkPrime(word: word){\n            result+= \" \" + word\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp093c60hy.swift:20:21: error: consecutive statements on a line must\
    \ be separated by ';'\n            result+= \" \" + word\n                   \
    \ ^\n                    ;\n/tmp/tmp093c60hy.swift:18:32: error: missing argument\
    \ for parameter 'separator' in call\n    for word in sentence.split(){\n     \
    \                          ^\n                               separator: <#String.Element#>\n\
    Swift.Sequence:2:40: note: 'split(separator:maxSplits:omittingEmptySubsequences:)'\
    \ declared here\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let wordCount = sentence.split(separator: \" \").count\n\
    \    let length = sqrt(Double(wordCount))\n    var output: String = \"\"\n   \
    \ for number in stride(from: 1, to: wordCount, by: 1) {\n        if sqrt(Double(number)).truncatingRemainder(dividingBy:\
    \ length) == 0 {\n            output = output + String(number) + \" \"\n     \
    \   }\n    }\n    output = output.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \    return output.characters.map { String($0) }.joined(separator: \" \")\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8nlbkq5x.swift:18:18: error: cannot find 'sqrt' in scope\n    let\
    \ length = sqrt(Double(wordCount))\n                 ^~~~\n/tmp/tmp8nlbkq5x.swift:21:12:\
    \ error: cannot find 'sqrt' in scope\n        if sqrt(Double(number)).truncatingRemainder(dividingBy:\
    \ length) == 0 {\n           ^~~~\n/tmp/tmp8nlbkq5x.swift:25:21: error: value\
    \ of type 'String' has no member 'trimmingCharacters'\n    output = output.trimmingCharacters(in:\
    \ .whitespacesAndNewlines)\n             ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp8nlbkq5x.swift:25:45:\
    \ error: cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    output = output.trimmingCharacters(in: .whitespacesAndNewlines)\n       \
    \                                    ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8nlbkq5x.swift:26:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    return output.characters.map\
    \ { String($0) }.joined(separator: \" \")\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    sentence.characters.forEach\
    \ { (c) in\n        let range = sentence.rangeOfString(String(c.unicodeScalars.map\
    \ { String($0) }.joined()))\n        result = result + String(c.unicodeScalars.map\
    \ { String($0) }.joined()) + \" \"\n    }\n    let range = result.rangeOfString(\"\
    \ \".characters.first!)\n    return String(result.characters.dropFirst(range.endIndex))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(words_in_sentence(sentence: \"This is a test\"\
    ) == \"is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") ==\
    \ \"go for\")\nassert(words_in_sentence(sentence: \"there is no place available\
    \ here\") == \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I\
    \ am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go\
    \ for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\") ==\
    \ \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp98_ui5ao.swift:19:30: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let range = sentence.rangeOfString(String(c.unicodeScalars.map\
    \ { String($0) }.joined()))\n                    ~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp98_ui5ao.swift:22:24:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    let range =\
    \ result.rangeOfString(\" \".characters.first!)\n                ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let n = sentence.count\n    let arr = sentence.characters\n\
    \    var str = \"\"\n    var prime = true\n    for i in 0..<n {\n        for j\
    \ in 2..<n {\n            if i != j {\n                if arr[i] == arr[j] {\n\
    \                    str += arr[i]\n                }\n            }\n       \
    \ }\n        if prime {\n            str += arr[i]\n            prime = false\n\
    \        }\n    }\n    return str\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmppr_jm10f.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let arr = sentence.characters\n                   \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmppr_jm10f.swift:24:20:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                if arr[i] == arr[j] {\n       \
    \            ^~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmppr_jm10f.swift:24:30: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       if arr[i] == arr[j] {\n                             ^~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmppr_jm10f.swift:25:31:\
    \ error: no exact matches in call to subscript \n                    str += arr[i]\n\
    \                              ^\nSwift.String:3:12: note: candidate expects value\
    \ of type 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.SubSequence { get }\n                      ^\n/tmp/tmppr_jm10f.swift:30:23:\
    \ error: no exact matches in call to subscript \n            str += arr[i]\n \
    \                     ^\nSwift.String:3:12: note: candidate expects value of type\
    \ 'Range<String.Index>' for parameter #1 (got 'Int')\n    public subscript(r:\
    \ Range<String.Index>) -> Substring { get }\n           ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Int')\n    @inlinable public subscript(x: (UnboundedRange_) -> ())\
    \ -> Self.Sub"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n  var string = \"\"\n  if let arr = sentence.split(separator:\
    \ \" \") {\n    for str in arr {\n      if str.isPrime {\n        string += \"\
    \ \" + str\n      }\n    }\n  }\n  return string\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(words_in_sentence(sentence: \"This is a test\") == \"is\"\
    )\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp6y19nzno.swift:20:14: error: value of type 'String.SubSequence'\
    \ (aka 'Substring') has no member 'isPrime'\n      if str.isPrime {\n        \
    \ ~~~ ^~~~~~~\n/tmp/tmp6y19nzno.swift:18:6: error: initializer for conditional\
    \ binding must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \  if let arr = sentence.split(separator: \" \") {\n     ^         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.components(separatedBy:\
    \ \" \") {\n        for character in word {\n            if isPrimeNumber(character)\
    \ {\n                result += character\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp8bni7_ei.swift:18:26: error: value of type 'String' has no member\
    \ 'components'\n    for word in sentence.components(separatedBy: \" \") {\n  \
    \              ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var result = \"\"\n    for word in sentence.split(separator:\
    \ \" \") {\n        if is_prime(word: word) {\n            result += \" \" + word\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(words_in_sentence(sentence: \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence:\
    \ \"lets go for swimming\") == \"go for\")\nassert(words_in_sentence(sentence:\
    \ \"there is no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpe4ie_h8x.swift:19:12: error: cannot find 'is_prime' in scope\n\
    \        if is_prime(word: word) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard sentence != \"\" else {\n        return \"\"\n\
    \    }\n    \n    var output = \"\"\n    let words = sentence.components(separatedBy:\
    \ \" \")\n    for word in words {\n        if word.characters.count != 1 {\n \
    \           continue\n        }\n        \n        if output.isEmpty {\n     \
    \       output = word\n        } else {\n            let length = pow(word.characters.count,\
    \ 2)\n            if isPrime(length) && output.characters.count >= length {\n\
    \                output = output + \" \" + word\n            }\n        }\n  \
    \  }\n    \n    return output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpp25ap_mv.swift:22:26: error: value of type 'String' has no member\
    \ 'components'\n    let words = sentence.components(separatedBy: \" \")\n    \
    \            ~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpp25ap_mv.swift:31:26: error: cannot\
    \ find 'pow' in scope\n            let length = pow(word.characters.count, 2)\n\
    \                         ^~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    let letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    return\
    \ sentence.components(separatedBy: \" \")\n        .filter { letters.contains($0)\
    \ }\n        .sorted()\n        .joined(separator: \" \")\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(words_in_sentence(sentence: \"This is a test\") == \"\
    is\")\nassert(words_in_sentence(sentence: \"lets go for swimming\") == \"go for\"\
    )\nassert(words_in_sentence(sentence: \"there is no place available here\") ==\
    \ \"there is no place\")\nassert(words_in_sentence(sentence: \"Hi I am Hussein\"\
    ) == \"Hi am Hussein\")\nassert(words_in_sentence(sentence: \"go for it\") ==\
    \ \"go for it\")\nassert(words_in_sentence(sentence: \"here\") == \"\")\nassert(words_in_sentence(sentence:\
    \ \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpc_dvh7cy.swift:18:21: error: value of type 'String' has no member\
    \ 'components'\n    return sentence.components(separatedBy: \" \")\n         \
    \  ~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    // TODO: Replace the following code with your solution.\n\
    \    let regex = try! NSRegularExpression(pattern: \"[a-zA-Z ]+\")\n    let matches\
    \ = regex.matches(in: sentence, range: NSRange(sentence.startIndex..., in: sentence))\n\
    \    let words: [String] = []\n    for match in matches {\n        let range =\
    \ match.range(at: 1)\n        let word = sentence[range]\n        if word.characters.count\
    \ != 0 {\n            if words.contains(\"\\(word.characters.count)\") || words.count\
    \ < word.characters.count {\n                words.append(word.characters.count)\n\
    \            }\n        }\n    }\n    let res = words.joined(separator: \" \"\
    )\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmptwgsp8rf.swift:18:22: error: cannot find 'NSRegularExpression'\
    \ in scope\n    let regex = try! NSRegularExpression(pattern: \"[a-zA-Z ]+\")\n\
    \                     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmptwgsp8rf.swift:19:54: error:\
    \ cannot find 'NSRange' in scope\n    let matches = regex.matches(in: sentence,\
    \ range: NSRange(sentence.startIndex..., in: sentence))\n                    \
    \                                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    var res = \"\"\n    var j = 0\n    var isPrime = true\n\
    \    var n = sentence.count\n    for i in 1...n {\n        if n % i == 0 {\n \
    \           j += 1\n            isPrime = false\n        }\n    }\n    if isPrime\
    \ {\n        for i in 1...n {\n            while (n % i == 0) {\n            \
    \    n /= i\n                j++\n            }\n            if j > 0 {\n    \
    \            res = sentence.substringToIndex(advance(sentence.startIndex, j))\n\
    \                return res\n            }\n        }\n    } else {\n        return\
    \ \"\"\n    }\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp0r0s6wom.swift:31:18: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n                j++\n                 ^~\n/tmp/tmp0r0s6wom.swift:34:49:\
    \ error: cannot find 'advance' in scope\n                res = sentence.substringToIndex(advance(sentence.startIndex,\
    \ j))\n                                                ^~~~~~~\n/tmp/tmp0r0s6wom.swift:34:32:\
    \ error: value of type 'String' has no member 'substringToIndex'\n           \
    \     res = sentence.substringToIndex(advance(sentence.startIndex, j))\n     \
    \                 ~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty {\n        return \"\"\n    }\n\
    \n    var words = sentence.characters\n    var result = ''\n\n    while words.count\
    \ > 0 {\n        var candidates = [Int]()\n        var j = 0\n        for _ in\
    \ 0..<words.count {\n            if j > 0 && candidates.contains(words[j-1] +\
    \ 1) {\n                j += 1\n                continue\n            }\n    \
    \        candidates.append(j)\n            j++\n        }\n\n        if candidates.count\
    \ == 1 {\n            result += String(words[0])\n        } else if candidates.count\
    \ > 1 {\n            result += \"(\"\n            for i in 0..<candidates.count\
    \ {\n                result += String(candidates[i])\n                if i !=\
    \ candidates.count - 1 {\n                    result += \" \"\n              \
    \  }\n            }\n            result += \")\"\n        }\n        words = words[candidates.endIndex...]\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmp_999piw_.swift:22:18: error: single-quoted string literal found,\
    \ use '\"'\n    var result = ''\n                 ^~\n                 \"\"\n\
    /tmp/tmp_999piw_.swift:21:26: error: 'characters' is unavailable: Please use String\
    \ directly\n    var words = sentence.characters\n                         ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_999piw_.swift:28:50:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Int'\n\
    \            if j > 0 && candidates.contains(words[j-1] + 1) {\n             \
    \                                    ^\n/tmp/tmp_999piw_.swift:33:14: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            j++\n       \
    \      ^~\n/tmp/tmp_999piw_.swift:37:30: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   result += String(words[0])\n                             ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp_999piw_.swift:48:17:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n        words = words[candidates.endIndex...]\n\
    \                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1659979026
- exit_code: 1
  program: "\n/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(sentence: \"This\
    \ is a test\")\n/// \"is\"\n/// Example 2:\n/// >>> words_in_sentence(sentence:\
    \ \"lets go for swimming\")\n/// \"go for\"\n/// Constraints:\n/// * 1 <= len(sentence)\
    \ <= 100\n/// * sentence contains only letters\nfunc words_in_sentence(sentence:\
    \ String) -> String {\n    guard sentence != \"\" else {\n        return \"\"\n\
    \    }\n    guard let chars = sentence.unicodeScalars else {\n        return \"\
    \"\n    }\n    let set = Set<Character>()\n    \n    for char in chars {\n   \
    \     set.insert(char)\n    }\n    \n    let sorted = set.sorted()\n    let results\
    \ = NSMutableString()\n    \n    for char in sorted {\n        results.appendContentsOfString(String(char))\n\
    \    }\n    \n    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(words_in_sentence(sentence:\
    \ \"This is a test\") == \"is\")\nassert(words_in_sentence(sentence: \"lets go\
    \ for swimming\") == \"go for\")\nassert(words_in_sentence(sentence: \"there is\
    \ no place available here\") == \"there is no place\")\nassert(words_in_sentence(sentence:\
    \ \"Hi I am Hussein\") == \"Hi am Hussein\")\nassert(words_in_sentence(sentence:\
    \ \"go for it\") == \"go for it\")\nassert(words_in_sentence(sentence: \"here\"\
    ) == \"\")\nassert(words_in_sentence(sentence: \"here is\") == \"is\")"
  status: SyntaxError
  stderr: "/tmp/tmpl9l54369.swift:20:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String.UnicodeScalarView'\n    guard let chars\
    \ = sentence.unicodeScalars else {\n          ^           ~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpl9l54369.swift:26:13: error: cannot use mutating member on immutable value:\
    \ 'set' is a 'let' constant\n        set.insert(char)\n        ~~~ ^\n/tmp/tmpl9l54369.swift:23:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let set = Set<Character>()\n\
    \    ^~~\n    var\n/tmp/tmpl9l54369.swift:26:20: error: cannot convert value of\
    \ type 'Unicode.Scalar' to expected argument type 'Character'\n        set.insert(char)\n\
    \                   ^\n/tmp/tmpl9l54369.swift:30:19: error: cannot find 'NSMutableString'\
    \ in scope\n    let results = NSMutableString()\n                  ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659979026
