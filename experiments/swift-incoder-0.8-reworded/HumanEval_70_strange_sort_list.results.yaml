language: swift
name: HumanEval_70_strange_sort_list
results:
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty() {\n      \
    \  return lst\n    }\n    let min = lst.min()!\n    let max = lst.max()!\n   \
    \ var sorted = [Int]()\n    for i in 0..<lst.count {\n        if i != 0 {\n  \
    \          let smallerIndex = findSmaller(sorted, lst[i - 1], min)\n         \
    \   sorted.insert(smallerIndex, i)\n        }\n    }\n    sorted.append(min)\n\
    \    sorted.append(max)\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpnf2vsyiw.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpnf2vsyiw.swift:21:32: error: cannot find 'findSmaller' in scope\n\
    \            let smallerIndex = findSmaller(sorted, lst[i - 1], min)\n       \
    \                        ^~~~~~~~~~~\n/tmp/tmpnf2vsyiw.swift:22:20: error: no\
    \ exact matches in call to instance method 'insert'\n            sorted.insert(smallerIndex,\
    \ i)\n                   ^\n/tmp/tmpnf2vsyiw.swift:22:20: note: found candidate\
    \ with type '(__owned Int, Int) -> ()'\n            sorted.insert(smallerIndex,\
    \ i)\n                   ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let min = lst.minElement()\n\
    \    var rest = lst\n    var rest2 = []\n    for el in lst {\n        if el <\
    \ min {\n            rest2.append(el)\n        } else {\n            rest2.append(min)\n\
    \            rest2 = rest2 + rest\n            rest2 = rest2 + rest2\n       \
    \     rest = []\n        }\n    }\n    rest2 = rest2 + rest\n    rest2 = rest2\
    \ + rest\n    rest2 = rest2 + rest\n    return rest2\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpf6elzc2b.swift:13:19: error: value of type '[Int]' has no member\
    \ 'minElement'\n    let min = lst.minElement()\n              ~~~ ^~~~~~~~~~\n\
    /tmp/tmpf6elzc2b.swift:15:17: error: empty collection literal requires an explicit\
    \ type\n    var rest2 = []\n                ^~\n/tmp/tmpf6elzc2b.swift:29:12:\
    \ error: cannot convert return expression of type '[Any]' to return type '[Int]'\n\
    \    return rest2\n           ^\n/tmp/tmpf6elzc2b.swift:29:12: note: arguments\
    \ to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n\
    \    return rest2\n           ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let sortedLst = lst.sorted()\n\
    \    if lst.isEmpty {\n        return sortedLst\n    }\n\n    let len = sortedLst.count\n\
    \n    // find max number in list\n    let maxValue = sortedLst.reduce(0, combine:\
    \ max<Int>)\n    // find min number in list\n    let minValue = sortedLst.reduce(0,\
    \ combine: min)\n\n    // create new list - [minValue, maxValue, minValue, maxValue,\
    \ minValue...]\n    // and add elements to it\n    var newLst = [Int](repeating:\
    \ minValue, count: len+1)\n\n    for i in 0..<len {\n        newLst[i+1] = sortedLst[i]\n\
    \    }\n\n    newLst[0] = maxValue\n    return newLst\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp4fxt4zgv.swift:21:36: error: extraneous argument label 'combine:'\
    \ in call\n    let maxValue = sortedLst.reduce(0, combine: max<Int>)\n       \
    \                            ^   ~~~~~~~~~\n                                 \
    \      \n/tmp/tmp4fxt4zgv.swift:23:36: error: extraneous argument label 'combine:'\
    \ in call\n    let minValue = sortedLst.reduce(0, combine: min)\n            \
    \                       ^   ~~~~~~~~~\n                                      \
    \ \n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.reverse().sort()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpcsuii8z_.swift:13:16: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    return lst.reverse().sort()\n        \
    \   ~~~ ^\n/tmp/tmpcsuii8z_.swift:13:26: error: value of tuple type '()' has no\
    \ member 'sort'\n    return lst.reverse().sort()\n           ~~~~~~~~~~~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count > 0 else {\
    \ return lst }\n\n    var sorted = lst\n    sorted.sort()\n\n    var reversed\
    \ = lst\n    reversed.reverse()\n\n    return sorted + reversed\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmp58z0vvrx/tmp58z0vvrx.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b485de0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b485db04b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b485db04988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b485db037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp58z0vvrx                        0x00005628fba48644 <unavailable> + 5700

    5    libc.so.6                          0x00002b485dff9460 __libc_start_main +
    245

    6    tmp58z0vvrx                        0x00005628fba48239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var lstSorted = lst\n    var\
    \ max = 0\n    var min = 1\n    for e in lst {\n        if max < e {\n       \
    \     max = e\n        }\n        if min > e {\n            min = e\n        }\n\
    \    }\n    while lst.count > 0 {\n        var maxIndex = -1\n        var minIndex\
    \ = -1\n        for idx in 0..<lst.count {\n            var e = lst[idx]\n   \
    \         if max < e {\n                max = e\n                maxIndex = idx\n\
    \            }\n            if min > e {\n                min = e\n          \
    \      minIndex = idx\n            }\n        }\n        if maxIndex == -1 {\n\
    \            lstSorted.append(min)\n        } else {\n            lstSorted.insert(maxIndex,\
    \ max)\n        }\n    }\n    return lstSorted as [Int]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpqhsjod49.swift:41:23: error: no exact matches in call to instance\
    \ method 'insert'\n            lstSorted.insert(maxIndex, max)\n             \
    \         ^\nSwift.Array:11:37: note: incorrect labels for candidate (have: '(_:_:)',\
    \ expected: '(_:at:)')\n    @inlinable public mutating func insert(_ newElement:\
    \ __owned Element, at i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var max = 0\n    var min =\
    \ 0\n    var result = [Int]()\n    for x in lst {\n        if x >= max {\n   \
    \         max = x\n        }\n        if x < min {\n            min = x\n    \
    \    }\n        result.appendContentsOf([min..<max])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp8q6s2c_8.swift:23:16: error: value of type '[Int]' has no member\
    \ 'appendContentsOf'\n        result.appendContentsOf([min..<max])\n        ~~~~~~\
    \ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return sort(lst, isAscending:\
    \ false)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp8trpwuto.swift:13:12: error: cannot find 'sort' in scope\n    return\
    \ sort(lst, isAscending: false)\n           ^~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var minIndex = -1\n    var\
    \ maxIndex = 0\n\n    for index in lst.indices() {\n        let value = lst[index]\n\
    \n        if minIndex == -1 || value < lst[minIndex] {\n            minIndex =\
    \ index\n        }\n\n        if maxIndex == 0 || (maxIndex == -1 && value > lst[maxIndex])\
    \ {\n            maxIndex = index\n        }\n    }\n\n    if maxIndex == -1 {\n\
    \        return lst as [Int]\n    }\n\n    let leftHalf = strange_sort_list(lst:\
    \ lst.suffix(from: minIndex))\n    let rightHalf = strange_sort_list(lst: lst.suffix(from:\
    \ maxIndex))\n\n    var result = [Int](repeating: -1, count: lst.count)\n    result[minIndex]\
    \ = minIndex\n    result[maxIndex] = maxIndex\n\n    for index in 0 ..< leftHalf.count\
    \ {\n        result[index] = leftHalf[index]\n    }\n\n    for index in 0 ..<\
    \ rightHalf.count {\n        result[index] = rightHalf[index]\n    }\n\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpeogdlmen.swift:16:22: error: cannot call value of non-function\
    \ type 'Range<Array<Int>.Index>' (aka 'Range<Int>')\n    for index in lst.indices()\
    \ {\n                     ^      ~~\n                            \n/tmp/tmpeogdlmen.swift:32:47:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    let leftHalf = strange_sort_list(lst: lst.suffix(from: minIndex))\n\
    \                                              ^\n/tmp/tmpeogdlmen.swift:33:48:\
    \ error: cannot convert value of type 'ArraySlice<Int>' to expected argument type\
    \ '[Int]'\n    let rightHalf = strange_sort_list(lst: lst.suffix(from: maxIndex))\n\
    \                                               ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var min: Int\n    var max:\
    \ Int\n    var temp: Int\n    if lst.count > 0 {\n        min = lst[0]\n     \
    \   max = lst[0]\n        for index in 1..<lst.count {\n            if min > lst[index]\
    \ {\n                min = lst[index]\n            }\n            if max < lst[index]\
    \ {\n                max = lst[index]\n            }\n        }\n        for index\
    \ in min..<(max - min) {\n            temp = lst[index]\n            lst[index]\
    \ = lst[max - index]\n            lst[max - index] = temp\n        }\n    }\n\
    \    return lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpvbg6_8ey.swift:29:16: error: cannot assign through subscript: 'lst'\
    \ is a 'let' constant\n            lst[index] = lst[max - index]\n           \
    \ ~~~^\n/tmp/tmpvbg6_8ey.swift:30:16: error: cannot assign through subscript:\
    \ 'lst' is a 'let' constant\n            lst[max - index] = temp\n           \
    \ ~~~^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var ints = lst\n\n    // 1.\
    \ Find minimum.\n    var minIndex = ints.startIndex\n    while ints[minIndex]\
    \ == min {\n        minIndex -= 1\n    }\n    // 2. Find maximum.\n    var maxIndex\
    \ = ints.startIndex\n    while ints[maxIndex] == max {\n        maxIndex += 1\n\
    \    }\n\n    // 3. Sort remaining elements in reverse order.\n    ints[maxIndex],\
    \ ints[minIndex] = ints[minIndex], ints[maxIndex]\n    ints.sortInPlace()\n\n\
    \    // 4. Reverse the array.\n    var sortedArray = Array(0..<min(maxIndex, minIndex))\n\
    \n    for i in 0..<min(maxIndex, minIndex) {\n        sortedArray[i] = ints[i]\n\
    \    }\n\n    return sortedArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpplihaqfa.swift:27:19: error: consecutive statements on a line must\
    \ be separated by ';'\n    ints[maxIndex], ints[minIndex] = ints[minIndex], ints[maxIndex]\n\
    \                  ^\n                  ;\n/tmp/tmpplihaqfa.swift:27:19: error:\
    \ expected expression\n    ints[maxIndex], ints[minIndex] = ints[minIndex], ints[maxIndex]\n\
    \                  ^\n/tmp/tmpplihaqfa.swift:17:29: error: generic parameter 'T'\
    \ could not be inferred\n    while ints[minIndex] == min {\n                 \
    \           ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public\
    \ func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n                    \
    \   ^\n/tmp/tmpplihaqfa.swift:17:26: error: type '(T, T) -> T' cannot conform\
    \ to 'BinaryInteger'\n    while ints[minIndex] == min {\n                    \
    \     ^\n/tmp/tmpplihaqfa.swift:17:26: note: only concrete types such as structs,\
    \ enums and classes can conform to protocols\n    while ints[minIndex] == min\
    \ {\n                         ^\n/tmp/tmpplihaqfa.swift:17:26: note: required\
    \ by operator function '==' where 'Other' = '(T, T) -> T'\n    while ints[minIndex]\
    \ == min {\n                         ^\n/tmp/tmpplihaqfa.swift:22:26: error: type\
    \ '(T, T) -> T' cannot conform to 'BinaryInteger'\n    while ints[maxIndex] ==\
    \ max {\n                         ^\n/tmp/tmpplihaqfa.swift:22:26: note: only\
    \ concrete types such as structs, enums and classes can conform to protocols\n\
    \    while ints[maxIndex] == max {\n                         ^\n/tmp/tmpplihaqfa.swift:22:26:\
    \ note: required by operator function '==' where 'Other' = '(T, T) -> T'\n   \
    \ while ints[maxIndex] == max {\n                         ^\n/tmp/tmpplihaqfa.swift:22:29:\
    \ error: generic parameter 'T' could not be inferred\n    while ints[maxIndex]\
    \ == max {\n                            ^\nSwift.max:1:24: note: in call to function\
    \ 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpplihaqfa.swift:27:9: warning: subscript is\
    \ accessed but result is unused\n    ints[maxIndex], ints[minIndex] = ints[minIndex],\
    \ ints[m"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n    var res = lst\n    for i in 0..<lst.count {\n     \
    \   var min_idx = i\n        for j in 1..<lst.count {\n            if res[j] <\
    \ res[min_idx] {\n                min_idx = j\n            }\n        }\n    \
    \    if min_idx == i {\n            continue\n        }\n        swap(&res[min_idx],\
    \ &res[i])\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpfkgw7m4c.swift:27:14: error: overlapping accesses to 'res', but\
    \ modification requires exclusive access; consider calling MutableCollection.swapAt(_:_:)\n\
    \        swap(&res[min_idx], &res[i])\n        ~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    \        res.swapAt(min_idx, i)\n/tmp/tmpfkgw7m4c.swift:27:29: note: conflicting\
    \ access is here\n        swap(&res[min_idx], &res[i])\n                     \
    \       ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int]()\n    for\
    \ x in lst {\n        let low = lst.reduce(0) {\n            ($0 < x) ? $0 : x\n\
    \        }\n        let high = lst.reduce(0) {\n            ($0 > x) ? $0 : x\n\
    \        }\n        result.append(low)\n        result.append(high)\n    }\n \
    \   return result as! [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp08_mu6my.swift:15:33: error: contextual closure type '(Int, Int)\
    \ throws -> Int' expects 2 arguments, but 1 was used in closure body\n       \
    \ let low = lst.reduce(0) {\n                                ^\n/tmp/tmp08_mu6my.swift:18:34:\
    \ error: contextual closure type '(Int, Int) throws -> Int' expects 2 arguments,\
    \ but 1 was used in closure body\n        let high = lst.reduce(0) {\n       \
    \                          ^\n/tmp/tmp08_mu6my.swift:24:19: warning: forced cast\
    \ of '[Int]' to same type has no effect\n    return result as! [Int]\n       \
    \           ^~~~~~~~~\n                  \n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty { return lst\
    \ }\n    var minValue = lst[0]\n    var maxValue = lst[0]\n    for value in lst\
    \ {\n        if value < minValue { minValue = value }\n        if value > maxValue\
    \ { maxValue = value }\n    }\n\n    var result = [Int](count: lst.count, repeatedValue:\
    \ minValue)\n    for value in lst {\n        if value < minValue { continue }\n\
    \        if value > maxValue { break } // we checked all values already, let's\
    \ just stop.\n        result.append(value)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpriefheau.swift:21:18: error: no exact matches in call to initializer\
    \ \n    var result = [Int](count: lst.count, repeatedValue: minValue)\n      \
    \           ^\n/tmp/tmpriefheau.swift:21:18: note: candidate has partially matching\
    \ parameter list (repeating: Int, count: Int)\n    var result = [Int](count: lst.count,\
    \ repeatedValue: minValue)\n                 ^\n/tmp/tmpriefheau.swift:21:18:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var result = [Int](count: lst.count, repeatedValue: minValue)\n  \
    \               ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.IsEmpty {\n        return\
    \ []\n    }\n\n    let min = lst[0]\n    let max = lst[lst.count-1]\n\n    guard\
    \ min < max else {\n        return lst\n    }\n\n    for i in lst.indices {\n\
    \        if lst[i] > min {\n            swap(&lst[i], &lst[lst.indices[i]]) //\
    \ Swap current position with the smallest value\n        }\n    }\n\n    return\
    \ lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp7710mxig.swift:13:12: error: value of type '[Int]' has no member\
    \ 'IsEmpty'\n    if lst.IsEmpty {\n       ~~~ ^~~~~~~\n/tmp/tmp7710mxig.swift:26:18:\
    \ error: cannot pass immutable value as inout argument: 'lst' is a 'let' constant\n\
    \            swap(&lst[i], &lst[lst.indices[i]]) // Swap current position with\
    \ the smallest value\n                 ^~~~\n/tmp/tmp7710mxig.swift:26:27: error:\
    \ cannot pass immutable value as inout argument: 'lst' is a 'let' constant\n \
    \           swap(&lst[i], &lst[lst.indices[i]]) // Swap current position with\
    \ the smallest value\n                          ^~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var lst1 = []\n    var lst2\
    \ = []\n    for num in lst {\n        lst1.append(num)\n    }\n\n    for num in\
    \ lst1 {\n        lst2.append(num)\n    }\n\n    for num in lst2 {\n        lst1.append(num)\n\
    \    }\n\n    return lst1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpwm3up99e.swift:13:16: error: empty collection literal requires\
    \ an explicit type\n    var lst1 = []\n               ^~\n/tmp/tmpwm3up99e.swift:14:16:\
    \ error: empty collection literal requires an explicit type\n    var lst2 = []\n\
    \               ^~\n/tmp/tmpwm3up99e.swift:27:12: error: cannot convert return\
    \ expression of type '[Any]' to return type '[Int]'\n    return lst1\n       \
    \    ^\n/tmp/tmpwm3up99e.swift:27:12: note: arguments to generic parameter 'Element'\
    \ ('Any' and 'Int') are expected to be equal\n    return lst1\n           ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var lst2 = lst\n    var result\
    \ = [Int]()\n\n    if lst.count == 0 {\n        return result\n    }\n\n    for\
    \ j in 0..<lst.count {\n        // Sort subarray\n        let subarr = lst2[j..<(j\
    \ + 3)]\n\n        // Get minimum of the subarray\n        var min = subarr[0]\n\
    \        for idx in 0..<subarr.count {\n            if subarr[idx] < min {\n \
    \               min = subarr[idx]\n            }\n        }\n        // Add minimum\
    \ to the result\n        result.append(min)\n        // Add rest of subarray to\
    \ the result\n        for idx in (j + 3)..<lst.count {\n            if lst[idx]\
    \ < min {\n                result.append(lst[idx])\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'Swift/SliceBuffer.swift:287: Fatal error: Index out of bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002b65624e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65621db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b65621db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b65621db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b65621dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b65621d229a <unavailable> + 1397402

    6    tmpvw3unav9                        0x0000562691c94625 <unavailable> + 9765

    7    tmpvw3unav9                        0x0000562691c936ec <unavailable> + 5868

    8    libc.so.6                          0x00002b65626d0460 __libc_start_main +
    245

    9    tmpvw3unav9                        0x0000562691c933c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n\n    if lst[0] > lst[1] {\n        var tmp1 = lst[0]\n\
    \        var tmp2 = lst[1]\n        lst[0] = tmp2\n        lst[1] = tmp1\n   \
    \ }\n\n    var tmp3 = lst[0]\n    var tmp4 = lst[1]\n    lst[0] = lst[1]\n   \
    \ lst[1] = tmp3\n    var tmp5 = lst[0]\n    lst[0] = tmp4\n    lst[1] = tmp5\n\
    \    return strange_sort_list(lst: lst[2..<lst.count])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpur1v3m3j.swift:20:12: error: cannot assign through subscript: 'lst'\
    \ is a 'let' constant\n        lst[0] = tmp2\n        ~~~^\n/tmp/tmpur1v3m3j.swift:21:12:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n        lst[1]\
    \ = tmp1\n        ~~~^\n/tmp/tmpur1v3m3j.swift:26:8: error: cannot assign through\
    \ subscript: 'lst' is a 'let' constant\n    lst[0] = lst[1]\n    ~~~^\n/tmp/tmpur1v3m3j.swift:27:8:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n    lst[1]\
    \ = tmp3\n    ~~~^\n/tmp/tmpur1v3m3j.swift:29:8: error: cannot assign through\
    \ subscript: 'lst' is a 'let' constant\n    lst[0] = tmp4\n    ~~~^\n/tmp/tmpur1v3m3j.swift:30:8:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n    lst[1]\
    \ = tmp5\n    ~~~^\n/tmp/tmpur1v3m3j.swift:31:38: error: cannot convert value\
    \ of type 'ArraySlice<Int>' to expected argument type '[Int]'\n    return strange_sort_list(lst:\
    \ lst[2..<lst.count])\n                                     ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    // Sort array from minimum\
    \ to maximum\n    // Use binary search to find minimum and maximum\n    // then\
    \ swap with minimum and maximum\n    var min = lst[0]\n    var max = lst[0]\n\
    \    for el in lst {\n        if (el > max) {\n            max = el\n        }\
    \ else if (el < min) {\n            min = el\n        } else {\n            //\
    \ swap\n            var tmp = min\n            min = max\n            max = tmp\n\
    \        }\n    }\n\n    var res: [Int] = []\n    res[0] = min\n    for el in\
    \ lst {\n        if (el == min) {\n            continue\n        }\n        if\
    \ ((el > min) && (el < max)) {\n            res[res.length] = el\n        }\n\
    \    }\n    res[res.length] = max\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp00z7z22b.swift:38:21: error: value of type '[Int]' has no member\
    \ 'length'\n            res[res.length] = el\n                ~~~ ^~~~~~\n/tmp/tmp00z7z22b.swift:41:13:\
    \ error: value of type '[Int]' has no member 'length'\n    res[res.length] = max\n\
    \        ~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var l = lst.count\n    var\
    \ n = l\n    var i = 0\n    var j = 0\n    var m = lst.min\n\n    while n > 0\
    \ {\n        j = 0\n        while j < l && lst[j] == m {\n            j += 1\n\
    \        }\n\n        if j > 0 {\n            lst[i], lst[j] = lst[j], lst[i]\n\
    \            i += 1\n        }\n\n        n -= 1\n    }\n    return lst\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp4wkrux93.swift:26:19: error: consecutive statements on a line must\
    \ be separated by ';'\n            lst[i], lst[j] = lst[j], lst[i]\n         \
    \         ^\n                  ;\n/tmp/tmp4wkrux93.swift:26:19: error: expected\
    \ expression\n            lst[i], lst[j] = lst[j], lst[i]\n                  ^\n\
    /tmp/tmp4wkrux93.swift:17:17: warning: use of 'min' treated as a reference to\
    \ instance method in protocol 'Sequence'\n    var m = lst.min\n              \
    \  ^\nSwift.Sequence:3:28: note: 'min()' declared here\n    @inlinable public\
    \ func min() -> Self.Element?\n                           ^\n/tmp/tmp4wkrux93.swift:17:17:\
    \ note: use 'self.' to silence this warning\n    var m = lst.min\n           \
    \     ^\n                self.\n/tmp/tmp4wkrux93.swift:17:17: note: use 'Swift.'\
    \ to reference the global function\n    var m = lst.min\n                ^\n \
    \               Swift.\n/tmp/tmp4wkrux93.swift:21:31: error: type '() -> Int?'\
    \ cannot conform to 'BinaryInteger'\n        while j < l && lst[j] == m {\n  \
    \                            ^\n/tmp/tmp4wkrux93.swift:21:31: note: only concrete\
    \ types such as structs, enums and classes can conform to protocols\n        while\
    \ j < l && lst[j] == m {\n                              ^\n/tmp/tmp4wkrux93.swift:21:31:\
    \ note: required by operator function '==' where 'Other' = '() -> Int?'\n    \
    \    while j < l && lst[j] == m {\n                              ^\n/tmp/tmp4wkrux93.swift:26:16:\
    \ warning: expression of type 'Int' is unused\n            lst[i], lst[j] = lst[j],\
    \ lst[i]\n            ~~~^~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var list = lst\n    var min:\
    \ Int? = nil\n    var max: Int? = nil\n\n    for x in list {\n        if x ==\
    \ nil {\n            list = list.remove(at: 0)\n            continue\n       \
    \ }\n\n        if min?? == nil || x < min! {\n            min = x\n        }\n\
    \n        if max?? == nil || x > max! {\n            max = x\n        }\n    }\n\
    \n    if min != nil {\n        for x in list {\n            if x == nil {\n  \
    \              list = list.remove(at: 0)\n                continue\n         \
    \   }\n\n            if x > min! {\n                list.remove(x)\n         \
    \       list.append(min)\n            }\n        }\n    }\n\n    if max != nil\
    \ {\n        for x in list {\n            if x == nil {\n                list\
    \ = list.remove(at: 0)\n                continue\n            }\n\n          \
    \  if x < max! {\n                list.remove(x)\n                list.append(max)\n\
    \            }\n        }\n    }\n\n    return list\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmplp7jli_d.swift:18:14: warning: comparing non-optional value of\
    \ type 'Int' to 'nil' always returns false\n        if x == nil {\n          \
    \ ~ ^  ~~~\n/tmp/tmplp7jli_d.swift:19:25: error: cannot assign value of type 'Int'\
    \ to type '[Int]'\n            list = list.remove(at: 0)\n                   ~~~~~^~~~~~~~~~~~~\n\
    /tmp/tmplp7jli_d.swift:23:16: error: cannot use optional chaining on non-optional\
    \ value of type 'Int'\n        if min?? == nil || x < min! {\n           ~~~~^\n\
    \               \n/tmp/tmplp7jli_d.swift:27:16: error: cannot use optional chaining\
    \ on non-optional value of type 'Int'\n        if max?? == nil || x > max! {\n\
    \           ~~~~^\n               \n/tmp/tmplp7jli_d.swift:34:18: warning: comparing\
    \ non-optional value of type 'Int' to 'nil' always returns false\n           \
    \ if x == nil {\n               ~ ^  ~~~\n/tmp/tmplp7jli_d.swift:35:29: error:\
    \ cannot assign value of type 'Int' to type '[Int]'\n                list = list.remove(at:\
    \ 0)\n                       ~~~~~^~~~~~~~~~~~~\n/tmp/tmplp7jli_d.swift:40:22:\
    \ error: no exact matches in call to instance method 'remove'\n              \
    \  list.remove(x)\n                     ^\nSwift.Array:10:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(at:)')\n    @inlinable public\
    \ mutating func remove(at index: Int) -> Element\n                           \
    \         ^\nSwift.RangeReplaceableCollection:9:37: note: incorrect labels for\
    \ candidate (have: '(_:)', expected: '(at:)')\n    @inlinable public mutating\
    \ func remove(at position: Self.Index) -> Self.Element\n                     \
    \               ^\n/tmp/tmplp7jli_d.swift:41:29: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n                list.append(min)\n\
    \                            ^\n/tmp/tmplp7jli_d.swift:41:29: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \       list.append(min)\n                            ^\n                    \
    \            ?? <#default value#>\n/tmp/tmplp7jli_d.swift:41:29: note: force-unwrap\
    \ using '!' to abort execut"
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    // Sort by increasing value,\
    \ then decreasing value, then increasing value,\n    // and so on\n    let sortedLst\
    \ = lst.sorted { $0 > $1 }\n    return sortedLst.sorted { $0 < $1 }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpkevex7ma/tmpkevex7ma.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba9a8b2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba9a8825b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba9a8825988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba9a88247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkevex7ma                        0x000055ce86ed5444 <unavailable> + 5188

    5    libc.so.6                          0x00002ba9a8d1a460 __libc_start_main +
    245

    6    tmpkevex7ma                        0x000055ce86ed5039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty() {\n      \
    \  return lst\n    }\n    var min = lst[0]\n    var max = lst[0]\n    for x in\
    \ lst {\n        if x < min {\n            min = x\n        }\n        if x >\
    \ max {\n            max = x\n        }\n    }\n    var ret = [Int]()\n    for\
    \ x in lst {\n        if x == min {\n            ret.append(max)\n        } else\
    \ {\n            ret.append(x)\n        }\n    }\n    return ret\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpucf94uh8.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sort { $0 > $1 }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpexj13x4l.swift:13:16: error: cannot convert return expression of\
    \ type '()' to return type '[Int]'\n    return lst.sort { $0 > $1 }\n        \
    \   ~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpexj13x4l.swift:13:16: error: cannot use mutating\
    \ member on immutable value: 'lst' is a 'let' constant\n    return lst.sort {\
    \ $0 > $1 }\n           ~~~ ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var res = lst\n    if lst.count\
    \ > 0 {\n        var minI = lst.minElement()\n        var maxI = lst.maxElement()\n\
    \        res.removeFirst()\n        res.removeLast()\n        for v in lst {\n\
    \            if v < minI {\n                minI = v\n            }\n        \
    \    if v > maxI {\n                maxI = v\n            }\n        }\n     \
    \   res.insert(maxI, at: 0)\n        res.insert(minI, at: 0)\n    }\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp7xalxn14.swift:15:24: error: value of type '[Int]' has no member\
    \ 'minElement'\n        var minI = lst.minElement()\n                   ~~~ ^~~~~~~~~~\n\
    /tmp/tmp7xalxn14.swift:16:24: error: value of type '[Int]' has no member 'maxElement'\n\
    \        var maxI = lst.maxElement()\n                   ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var i = 0\n    var j = 1\n\
    \    var k = lst.count - 2\n    var temp = 0\n    var output = [Int]()\n    while\
    \ i < k {\n        if lst[i] > lst[j] {\n            temp = lst[i]\n         \
    \   lst[i] = lst[j]\n            lst[j] = temp\n            i += 1\n         \
    \   j += 1\n        } else {\n            if lst[i] > lst[k] {\n             \
    \   temp = lst[i]\n                lst[i] = lst[k]\n                lst[k] = temp\n\
    \                i += 1\n                k += 1\n            } else {\n      \
    \          if lst[j] > lst[k] {\n                    temp = lst[j]\n         \
    \           lst[j] = lst[k]\n                    lst[k] = temp\n             \
    \       j += 1\n                    k += 1\n                }\n            }\n\
    \        }\n    }\n    for _ in lst {\n        output.append(0)\n    }\n    return\
    \ output\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp49pulmkr.swift:21:16: error: cannot assign through subscript: 'lst'\
    \ is a 'let' constant\n            lst[i] = lst[j]\n            ~~~^\n/tmp/tmp49pulmkr.swift:22:16:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n        \
    \    lst[j] = temp\n            ~~~^\n/tmp/tmp49pulmkr.swift:28:20: error: cannot\
    \ assign through subscript: 'lst' is a 'let' constant\n                lst[i]\
    \ = lst[k]\n                ~~~^\n/tmp/tmp49pulmkr.swift:29:20: error: cannot\
    \ assign through subscript: 'lst' is a 'let' constant\n                lst[k]\
    \ = temp\n                ~~~^\n/tmp/tmp49pulmkr.swift:35:24: error: cannot assign\
    \ through subscript: 'lst' is a 'let' constant\n                    lst[j] = lst[k]\n\
    \                    ~~~^\n/tmp/tmp49pulmkr.swift:36:24: error: cannot assign\
    \ through subscript: 'lst' is a 'let' constant\n                    lst[k] = temp\n\
    \                    ~~~^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var temp: Int = lst[0]\n  \
    \  var tempList: [Int] = [Int]()\n    for i in 1..<lst.count {\n        if temp\
    \ > lst[i] {\n            tempList.append(temp)\n            temp = lst[i]\n \
    \       } else {\n            tempList.append(lst[i])\n        }\n    }\n    return\
    \ tempList + [temp]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmp4hog5apo/tmp4hog5apo.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f6de49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f6db40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f6db40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f6db3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4hog5apo                        0x00005579c395c714 <unavailable> + 5908

    5    libc.so.6                          0x00002b1f6e035460 __libc_start_main +
    245

    6    tmp4hog5apo                        0x00005579c395c309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var arr = [Int]()\n    for\
    \ number in lst {\n        for index in 0..<(arr.count - 1) {\n            if\
    \ number > arr[index] {\n                arr.remove(at: index)\n             \
    \   arr.append(number)\n            }\n        }\n    }\n    return arr\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002aff0b152c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff0ae49561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aff0ae49286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aff0ae4913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aff0ae48bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxzm9q4tk                        0x00005609dece95cc <unavailable> + 9676

    6    tmpxzm9q4tk                        0x00005609dece879c <unavailable> + 6044

    7    libc.so.6                          0x00002aff0b33e460 __libc_start_main +
    245

    8    tmpxzm9q4tk                        0x00005609dece8479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var min = lst[0]\n    var max\
    \ = lst[0]\n    for x in lst[1..] {\n        if x < min {\n            min = x\n\
    \        }\n        if x > max {\n            max = x\n        }\n    }\n    var\
    \ tmp = min\n    var arr = [Int]()\n    for x in lst[1..] {\n        if x < min\
    \ {\n            arr.append(tmp)\n            tmp = x\n        } else {\n    \
    \        if x > max {\n                arr.append(tmp)\n                tmp =\
    \ x\n            } else {\n                arr.append(x)\n            }\n    \
    \    }\n    }\n    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp5ilp1b4c.swift:15:19: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for x in lst[1..] {\n                  ^~\n       \
    \           ...\n/tmp/tmp5ilp1b4c.swift:25:19: error: cannot find operator '..'\
    \ in scope; did you mean '...'?\n    for x in lst[1..] {\n                  ^~\n\
    \                  ...\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return []\n    }\n    var min: Int? = nil\n    for x in lst {\n        if\
    \ x == nil {\n            continue\n        }\n        if x == min {\n       \
    \     continue\n        }\n        if min == nil {\n            min = x\n    \
    \        continue\n        }\n        if x < min {\n            min = x\n    \
    \    }\n        if x == min {\n            continue\n        }\n        if x ==\
    \ min {\n            continue\n        }\n        if x < min {\n            min\
    \ = x\n        }\n        if x == min {\n            continue\n        }\n   \
    \     if x < min {\n            min = x\n        }\n    }\n    if min == nil {\n\
    \        return lst\n    }\n    for x in lst {\n        if x == nil {\n      \
    \      continue\n        }\n        if x == min {\n            continue\n    \
    \    }\n        if x < min {\n            min = x\n        }\n    }\n    if min\
    \ == nil {\n        return lst\n    }\n    for x in lst {\n        if x == nil\
    \ {\n            continue\n        }\n        if x == min {\n            continue\n\
    \        }\n        if x < min {\n            min = x\n        }\n    }\n    if\
    \ min == nil {\n        return lst\n    }\n    for x in lst {\n        if x ==\
    \ nil {\n            continue\n        }\n        if x == min {\n            continue\n\
    \        }\n        if x < min {\n            min = x\n        }\n    }\n    if\
    \ min == nil {\n        return lst\n    }\n    for x in lst {\n        if x ==\
    \ nil {\n            continue\n        }\n        if x == min {\n            continue\n\
    \        }\n        if x < min {\n            min = x\n        }\n    }\n    if\
    \ min == nil {\n        return lst\n    }\n    for x in lst {\n        if x ==\
    \ nil {\n            continue\n        }\n        if x == min {\n            continue\n\
    \        }\n        if x < min {\n            min = x\n        }\n    }\n    if\
    \ min == nil {\n        return lst\n    }\n    for x in lst {\n        if x ==\
    \ nil {\n            continue\n        }\n        if x == min {\n            continue\n\
    \        }\n        if x < min {\n            min = x\n        }\n    }\n    if\
    \ min == nil {\n        return lst\n    }\n    for x in lst {\n        if x ==\
    \ nil {\n            continue\n        }\n        if x == min {\n            continue\n\
    \        }\n        if x < min {\n            min = x\n        }\n    }\n    if\
    \ min == nil {\n        return lst\n    }\n    for x in lst {\n        if x ==\
    \ nil {\n            continue\n        }\n        if x == min {\n            continue\n\
    \        }\n        if x < min {\n            min = x\n        }\n    }\n    if\
    \ min == nil {\n        return lst\n    }\n    for x in lst {\n        if x ==\
    \ nil {\n            continue\n        }\n        if x == min {\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpmpxjedhw.swift:190:53: error: expected '}' at end of brace statement\n\
    assert(strange_sort_list(lst: [111111]) == [111111])\n                       \
    \                             ^\n/tmp/tmpmpxjedhw.swift:162:18: note: to match\
    \ this opening '{'\n    for x in lst {\n                 ^\n/tmp/tmpmpxjedhw.swift:190:53:\
    \ error: expected '}' at end of brace statement\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])\n                                                   \
    \ ^\n/tmp/tmpmpxjedhw.swift:12:45: note: to match this opening '{'\nfunc strange_sort_list(lst:\
    \ [Int]) -> [Int] {\n                                            ^\n/tmp/tmpmpxjedhw.swift:18:14:\
    \ warning: comparing non-optional value of type 'Int' to 'nil' always returns\
    \ false\n        if x == nil {\n           ~ ^  ~~~\n/tmp/tmpmpxjedhw.swift:28:16:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if x < min {\n               ^\n/tmp/tmpmpxjedhw.swift:28:16: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if x < min {\n               ^\n                   ?? <#default value#>\n\
    /tmp/tmpmpxjedhw.swift:28:16: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if x < min {\n               ^\n\
    \                  !\n/tmp/tmpmpxjedhw.swift:37:16: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n        if x < min {\n  \
    \             ^\n/tmp/tmpmpxjedhw.swift:37:16: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if x < min {\n   \
    \            ^\n                   ?? <#default value#>\n/tmp/tmpmpxjedhw.swift:37:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if x < min {\n               ^\n                  !\n/tmp/tmpmpxjedhw.swift:43:16:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if x < min {\n               ^\n/tmp/tmpmpxjedhw.swift:43:16: note: coalesce\
    \ using '??' to provide a default when the optiona"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted(by: ^Int((a:\
    \ Int, b: Int) -> Bool in\n        switch (a, b) {\n        case let (a,b):\n\
    \            if a < b {\n                return true\n            }\n        \
    \    return false\n        }\n    ))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpw0icjio6.swift:13:57: error: expected ',' separator\n    return\
    \ lst.sorted(by: ^Int((a: Int, b: Int) -> Bool in\n                          \
    \                              ^\n                                           \
    \            ,\n/tmp/tmpw0icjio6.swift:13:57: error: expected expression in list\
    \ of expressions\n    return lst.sorted(by: ^Int((a: Int, b: Int) -> Bool in\n\
    \                                                        ^\n/tmp/tmpw0icjio6.swift:13:27:\
    \ error: '^' is not a prefix unary operator\n    return lst.sorted(by: ^Int((a:\
    \ Int, b: Int) -> Bool in\n                          ^\n/tmp/tmpw0icjio6.swift:13:28:\
    \ error: no exact matches in call to initializer \n    return lst.sorted(by: ^Int((a:\
    \ Int, b: Int) -> Bool in\n                           ^\n/tmp/tmpw0icjio6.swift:13:28:\
    \ note: found candidate with type '(((Int, Int) -> Bool).Type) -> Int'\n    return\
    \ lst.sorted(by: ^Int((a: Int, b: Int) -> Bool in\n                          \
    \ ^\n/tmp/tmpw0icjio6.swift:13:28: note: found candidate with type '(((Int, Int)\
    \ -> Bool).Type, Int) -> Int?'\n    return lst.sorted(by: ^Int((a: Int, b: Int)\
    \ -> Bool in\n                           ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    var res = lst\n    \n\
    \    var minElem = res[0]\n    \n    res.remove(at: 0)\n    res.remove(at: res.index(of:\
    \ minElem))\n    \n    for i in 1..<res.count {\n        \n        var curElem\
    \ = res[i]\n        \n        var nextMinElem = res[i-1]\n        \n        if\
    \ curElem < nextMinElem {\n            \n            res.remove(at: i)\n     \
    \       \n            res.remove(at: res.index(of: curElem))\n            \n \
    \           res.remove(at: res.index(of: nextMinElem))\n            \n       \
    \     res.append(curElem)\n            \n            res.append(nextMinElem)\n\
    \            \n        } else {\n            \n            res.remove(at: i)\n\
    \            \n            res.remove(at: res.index(of: curElem))\n          \
    \  \n            res.remove(at: res.index(of: nextMinElem))\n            \n  \
    \          res.insert(curElem, at: 0)\n            \n            res.insert(nextMinElem,\
    \ at: res.count - 1)\n            \n        }\n        \n    }\n    \n    return\
    \ res\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpt4w1m5_f.swift:19:24: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n    res.remove(at: res.index(of: minElem))\n                  \
    \     ^\n/tmp/tmpt4w1m5_f.swift:19:24: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n    res.remove(at: res.index(of:\
    \ minElem))\n                       ^\n                                      \
    \    ?? <#default value#>\n/tmp/tmpt4w1m5_f.swift:19:24: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    res.remove(at:\
    \ res.index(of: minElem))\n                       ^\n                        \
    \                 !\n/tmp/tmpt4w1m5_f.swift:31:32: error: value of optional type\
    \ 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value of type\
    \ 'Array<Int>.Index' (aka 'Int')\n            res.remove(at: res.index(of: curElem))\n\
    \                               ^\n/tmp/tmpt4w1m5_f.swift:31:32: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \         res.remove(at: res.index(of: curElem))\n                           \
    \    ^\n                                                  ?? <#default value#>\n\
    /tmp/tmpt4w1m5_f.swift:31:32: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            res.remove(at: res.index(of:\
    \ curElem))\n                               ^\n                              \
    \                   !\n/tmp/tmpt4w1m5_f.swift:33:32: error: value of optional\
    \ type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Int>.Index' (aka 'Int')\n            res.remove(at: res.index(of:\
    \ nextMinElem))\n                               ^\n/tmp/tmpt4w1m5_f.swift:33:32:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            res.remove(at: res.index(of: nextMinElem))\n            \
    \                   ^\n                                                      ??\
    \ <#default value#>\n/tmp/tmpt4w1m5_f.swift:33"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    switch lst.count {\n    case\
    \ 0:\n        return []\n    case 1:\n        return lst\n    case 2:\n      \
    \  return sorted(lst) + sorted(lst, comparing: <, >)\n    case 3:\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >, <, >)\n    case 4:\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >, <, >, <, >)\n    default:\n     \
    \   return sorted(lst) + sorted(lst, comparing: <, >, <, >, <, >, <, >)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmps1fldpcz.swift:19:16: error: cannot find 'sorted' in scope\n  \
    \      return sorted(lst) + sorted(lst, comparing: <, >)\n               ^~~~~~\n\
    /tmp/tmps1fldpcz.swift:19:30: error: cannot find 'sorted' in scope\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >)\n                             ^~~~~~\n\
    /tmp/tmps1fldpcz.swift:21:16: error: cannot find 'sorted' in scope\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >, <, >)\n               ^~~~~~\n/tmp/tmps1fldpcz.swift:21:30:\
    \ error: cannot find 'sorted' in scope\n        return sorted(lst) + sorted(lst,\
    \ comparing: <, >, <, >)\n                             ^~~~~~\n/tmp/tmps1fldpcz.swift:21:16:\
    \ error: the compiler is unable to type-check this expression in reasonable time;\
    \ try breaking up the expression into distinct sub-expressions\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >, <, >)\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmps1fldpcz.swift:23:16: error: cannot find 'sorted' in scope\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >, <, >, <, >)\n               ^~~~~~\n\
    /tmp/tmps1fldpcz.swift:23:30: error: cannot find 'sorted' in scope\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >, <, >, <, >)\n                   \
    \          ^~~~~~\n/tmp/tmps1fldpcz.swift:23:16: error: the compiler is unable\
    \ to type-check this expression in reasonable time; try breaking up the expression\
    \ into distinct sub-expressions\n        return sorted(lst) + sorted(lst, comparing:\
    \ <, >, <, >, <, >)\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmps1fldpcz.swift:25:16: error: cannot find 'sorted' in scope\n        return\
    \ sorted(lst) + sorted(lst, comparing: <, >, <, >, <, >, <, >)\n             \
    \  ^~~~~~\n/tmp/tmps1fldpcz.swift:25:30: error: cannot find 'sorted' in scope\n\
    \        return sorted(lst) + sorted(lst, comparing: <, >, <, >, <, >, <, >)\n\
    \                             ^~~~~~\n/tmp/tmps1fldpcz.swift:25:16: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expr"
  stdout: ''
  timestamp: 1660028714
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  if lst.count == 0 {\n    return\
    \ lst\n  }\n  guard lst[0] < lst[lst.count - 1] else {\n    return lst\n  }\n\n\
    \  guard let m = lst.min() else { return lst }\n  let index = lst.index(lst.startIndex,\
    \ offsetBy: lst.count - 1)\n  let rest = strange_sort_list(lst: lst.dropLast())\n\
    \n  return [m] + rest + [index] + rest.dropLast()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmp5jsgqz95/tmp5jsgqz95.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77a903fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77a8d36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77a8d36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77a8d357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5jsgqz95                        0x000055d12e385884 <unavailable> + 6276

    5    libc.so.6                          0x00002b77a922b460 __libc_start_main +
    245

    6    tmp5jsgqz95                        0x000055d12e385479 <unavailable> + 5241

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    for i\
    \ in 0 ..< result.count {\n        for j in (i + 1) ..< result.count {\n     \
    \       if result[i] > result[j] {\n                let tmp = result[i]\n    \
    \            result[i] = result[j]\n                result[j] = tmp\n        \
    \    }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmphzjl35or/tmphzjl35or.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4878504c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b48781fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b48781fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b48781fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphzjl35or                        0x000055bfed011664 <unavailable> + 5732

    5    libc.so.6                          0x00002b48786f0460 __libc_start_main +
    245

    6    tmphzjl35or                        0x000055bfed011259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var arr: [Int] = lst\n    arr.sort()\n\
    \    return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpvvwhn412/tmpvvwhn412.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abff0fc3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abff0cbab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abff0cba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abff0cb97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvvwhn412                        0x000055c00bfd54f4 <unavailable> + 5364

    5    libc.so.6                          0x00002abff11af460 __libc_start_main +
    245

    6    tmpvvwhn412                        0x000055c00bfd50e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n    var res = lst\n    var i = lst.count - 1\n    for j\
    \ in 1...i {\n        let t = res[i]\n        if t > res[j] {\n            res[i]\
    \ = res[j]\n            res[j] = t\n        }\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpgt9dm4n3/tmpgt9dm4n3.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b10215d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b10212cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b10212cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10212ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgt9dm4n3                        0x000055d9ace98664 <unavailable> + 5732

    5    libc.so.6                          0x00002b10217c0460 __libc_start_main +
    245

    6    tmpgt9dm4n3                        0x000055d9ace98259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var a = lst\n\n    for i in\
    \ 0..<min(3, a.count) {\n        let j = findFirstIndexOfMax(a, nil)\n       \
    \ if j == -1 { break }\n        let t = a[j]\n        a[j] = a[i]\n        a[i]\
    \ = t\n    }\n    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp167frrdx.swift:16:17: error: cannot find 'findFirstIndexOfMax'\
    \ in scope\n        let j = findFirstIndexOfMax(a, nil)\n                ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp167frrdx.swift:16:40: error: 'nil' requires a contextual type\n      \
    \  let j = findFirstIndexOfMax(a, nil)\n                                     \
    \  ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  var result = [Int]()\n  for element\
    \ in lst {\n    let min = element.min()\n    let max = element.max()\n    result.insert(min,\
    \ at: 0)\n    result.insert(max, at: result.count - 1)\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp_v7pugfh.swift:15:23: error: cannot call value of non-function\
    \ type 'Int'\n    let min = element.min()\n                      ^  ~~\n     \
    \                    \n/tmp/tmp_v7pugfh.swift:15:15: error: static member 'min'\
    \ cannot be used on instance of type 'Int'\n    let min = element.min()\n    \
    \          ^~~~~~~\n              Int\n/tmp/tmp_v7pugfh.swift:16:23: error: cannot\
    \ call value of non-function type 'Int'\n    let max = element.max()\n       \
    \               ^  ~~\n                         \n/tmp/tmp_v7pugfh.swift:16:15:\
    \ error: static member 'max' cannot be used on instance of type 'Int'\n    let\
    \ max = element.max()\n              ^~~~~~~\n              Int\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var min_val = lst[0]\n    var\
    \ max_val = lst[0]\n    for n in lst {\n        if n < min_val {\n           \
    \ min_val = n\n        }\n        if n > max_val {\n            max_val = n\n\
    \        }\n    }\n    if max_val < min_val {\n        return lst\n    }\n   \
    \ var sorted = [Int]()\n    sorted.append(min_val)\n    var left = 0\n    var\
    \ right = sorted.count - 1\n    var i = sorted.count\n    for _ in 0..<i {\n \
    \       if sorted[left] == sorted[right] {\n            if left == right {\n \
    \               sorted.append(sorted[left])\n            }\n            else {\n\
    \                sorted[left], sorted[right] = sorted[right], sorted[left]\n \
    \           }\n            if left > right {\n                left -= 1\n    \
    \            right += 1\n            }\n            else {\n                left\
    \ += 1\n                right -= 1\n            }\n        }\n        else {\n\
    \            if left == right {\n                sorted.append(sorted[left])\n\
    \            }\n            else {\n                sorted[right], sorted[left]\
    \ = sorted[left], sorted[right]\n            }\n            if left > right {\n\
    \                left += 1\n                right -= 1\n            }\n      \
    \      else {\n                left -= 1\n                right += 1\n       \
    \     }\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpf73qeptq.swift:37:29: error: consecutive statements on a line must\
    \ be separated by ';'\n                sorted[left], sorted[right] = sorted[right],\
    \ sorted[left]\n                            ^\n                            ;\n\
    /tmp/tmpf73qeptq.swift:37:29: error: expected expression\n                sorted[left],\
    \ sorted[right] = sorted[right], sorted[left]\n                            ^\n\
    /tmp/tmpf73qeptq.swift:53:30: error: consecutive statements on a line must be\
    \ separated by ';'\n                sorted[right], sorted[left] = sorted[left],\
    \ sorted[right]\n                             ^\n                            \
    \ ;\n/tmp/tmpf73qeptq.swift:53:30: error: expected expression\n              \
    \  sorted[right], sorted[left] = sorted[left], sorted[right]\n               \
    \              ^\n/tmp/tmpf73qeptq.swift:37:23: warning: subscript is accessed\
    \ but result is unused\n                sorted[left], sorted[right] = sorted[right],\
    \ sorted[left]\n                ~~~~~~^~~~~~\n/tmp/tmpf73qeptq.swift:53:23: warning:\
    \ subscript is accessed but result is unused\n                sorted[right], sorted[left]\
    \ = sorted[left], sorted[right]\n                ~~~~~~^~~~~~~\n/tmp/tmpf73qeptq.swift:30:9:\
    \ warning: variable 'i' was never mutated; consider changing to 'let' constant\n\
    \    var i = sorted.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    // check length of array\n\
    \    if lst.count < 2 {\n        return lst\n    }\n\n    // calculate min and\
    \ max value\n    var min, max : Int\n    min = max = lst[0]\n    for element in\
    \ lst {\n        if element < min {\n            min = element\n        }\n  \
    \      if element > max {\n            max = element\n        }\n    }\n\n   \
    \ // initialize stack\n    var stack : [Int] = Array(count: lst.count - 1, repeatedValue:\
    \ min)\n    var result : [Int] = Array(count: lst.count, repeatedValue: min)\n\
    \n    // process array\n    for element in lst {\n        // add element to stack\
    \ by swapping min with max and removing min from stack\n        stack[stack.count\
    \ - 1] = max\n        max = element\n        while stack.count > 0 {\n       \
    \     var currentElement = stack[stack.count - 1]\n            stack.removeLast()\n\
    \            result[result.count] = currentElement\n        }\n    }\n\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpedmurwjf.swift:20:15: error: cannot assign value of type '()' to\
    \ type 'Int'\n    min = max = lst[0]\n          ~~~~^~~~~~~~\n/tmp/tmpedmurwjf.swift:31:68:\
    \ error: extra argument 'repeatedValue' in call\n    var stack : [Int] = Array(count:\
    \ lst.count - 1, repeatedValue: min)\n                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpedmurwjf.swift:31:31: error: missing argument for parameter 'repeating'\
    \ in call\n    var stack : [Int] = Array(count: lst.count - 1, repeatedValue:\
    \ min)\n                              ^\n                              repeating:\
    \ <#Int#>, \nSwift.Array:4:23: note: 'init(repeating:count:)' declared here\n\
    \    @inlinable public init(repeating repeatedValue: Element, count: Int)\n  \
    \                    ^\n/tmp/tmpedmurwjf.swift:32:65: error: extra argument 'repeatedValue'\
    \ in call\n    var result : [Int] = Array(count: lst.count, repeatedValue: min)\n\
    \                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/tmp/tmpedmurwjf.swift:32:32:\
    \ error: missing argument for parameter 'repeating' in call\n    var result :\
    \ [Int] = Array(count: lst.count, repeatedValue: min)\n                      \
    \         ^\n                               repeating: <#Int#>, \nSwift.Array:4:23:\
    \ note: 'init(repeating:count:)' declared here\n    @inlinable public init(repeating\
    \ repeatedValue: Element, count: Int)\n                      ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var lst2 = [Int]()\n\n    lst2\
    \ = lst.reverse()\n\n    var lst3 = lst\n\n    for _ in 0..<(lst2.count - 1) {\n\
    \        lst3.append(lst3.popLast())\n    }\n\n    return lst3\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp3adcn8kc.swift:15:16: error: cannot assign value of type '()' to\
    \ type '[Int]'\n    lst2 = lst.reverse()\n           ~~~~^~~~~~~~~\n/tmp/tmp3adcn8kc.swift:15:16:\
    \ error: cannot use mutating member on immutable value: 'lst' is a 'let' constant\n\
    \    lst2 = lst.reverse()\n           ~~~ ^\n/tmp/tmp3adcn8kc.swift:20:26: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       lst3.append(lst3.popLast())\n                         ^\n/tmp/tmp3adcn8kc.swift:20:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        lst3.append(lst3.popLast())\n                         ^\n   \
    \                                ?? <#default value#>\n/tmp/tmp3adcn8kc.swift:20:26:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        lst3.append(lst3.popLast())\n                         ^\n   \
    \                               !\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count > 0 else {\n\
    \        return lst\n    }\n\n    var min_elem = min(lst)\n    var max_elem =\
    \ max(lst)\n\n    var new_lst = [Int]()\n\n    for i in 0..<lst.count {\n    \
    \    if lst[i] > max_elem {\n            new_lst.insert(max_elem, at: i)\n   \
    \         max_elem = lst[i]\n        } else if lst[i] < min_elem {\n         \
    \   new_lst.insert(min_elem, at: i)\n            min_elem = lst[i]\n        }\
    \ else {\n            new_lst.insert(lst[i], at: i)\n        }\n    }\n\n    return\
    \ new_lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpg_rqa12b.swift:17:27: error: missing argument for parameter #2\
    \ in call\n    var min_elem = min(lst)\n                          ^\n        \
    \                  , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpg_rqa12b.swift:18:27: error: missing argument for parameter\
    \ #2 in call\n    var max_elem = max(lst)\n                          ^\n     \
    \                     , <#[Int]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    if lst.count < 2 {\n\
    \        return lst\n    }\n    \n    var smallest = lst[0]\n    var largest =\
    \ lst[0]\n    var temp: [Int] = []\n    \n    for n in lst {\n        if smallest\
    \ > n {\n            smallest = n\n        }\n        \n        if n > largest\
    \ {\n            largest = n\n        }\n    }\n    \n    for n in lst {\n   \
    \     if n == smallest {\n            temp.append(smallest)\n        } else {\n\
    \            temp.append(n)\n        }\n    }\n    \n    for n in lst {\n    \
    \    if n == largest {\n            temp.append(largest)\n        } else {\n \
    \           temp.append(n)\n        }\n    }\n    \n    return temp\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpr04067qm/tmpr04067qm.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24d91dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24d8ed6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24d8ed6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24d8ed57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr04067qm                        0x000055f9bef10644 <unavailable> + 5700

    5    libc.so.6                          0x00002b24d93cb460 __libc_start_main +
    245

    6    tmpr04067qm                        0x000055f9bef10239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    var i\
    \ = lst.count\n    while i > 0 {\n        var cur = result[i - 1]\n        result[i-1]\
    \ = result[i - 1] > cur ? result[i - 1] : cur\n        result[i] = result[i] <\
    \ cur ? result[i] : cur\n        i -= 1\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d204d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d201cf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8d201cf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8d201cf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8d201cebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b8d1ffcee83 <unavailable> + 188035

    6    tmpn_ssn3zh                        0x0000558bc7dc0195 <unavailable> + 8597

    7    tmpn_ssn3zh                        0x0000558bc7dbf3ec <unavailable> + 5100

    8    libc.so.6                          0x00002b8d206c4460 __libc_start_main +
    245

    9    tmpn_ssn3zh                        0x0000558bc7dbf0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var arr = [Int]()\n    for\
    \ i in lst {\n        arr.append(i)\n    }\n    if arr.count == 0 {\n        return\
    \ nil\n    }\n    var minVal = arr[0]\n    var maxVal = arr[arr.count - 1]\n \
    \   for idx in arr.indices {\n        if arr[idx] < minVal {\n            minVal\
    \ = arr[idx]\n        }\n        if arr[idx] > maxVal {\n            maxVal =\
    \ arr[idx]\n        }\n    }\n\n    var result: [Int] = []\n    for idx in arr.indices\
    \ {\n        guard arr[idx] == minVal || arr[idx] == maxVal else {\n         \
    \   continue\n        }\n        result.append(arr[idx])\n    }\n    result.reverse()\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp5o_hzisx.swift:18:16: error: 'nil' is incompatible with return\
    \ type '[Int]'\n        return nil\n               ^\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let min = lst[0]\n    var max\
    \ = lst[0]\n    for _ in lst {\n        let min = min\n        let max = lst[0]\n\
    \    }\n    var ans = lst\n    for x in lst {\n        if x < min {\n        \
    \    ans = ans + [min]\n            min = x\n        } else {\n            if\
    \ x > max {\n                ans = ans + [max]\n                max = x\n    \
    \        }\n        }\n    }\n    ans = ans + [max]\n    return ans\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpewlys6uw.swift:23:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = x\n            ^~~\n/tmp/tmpewlys6uw.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = lst[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n\tsort.Sort(func(a, b Int) bool\
    \ {\n\t\treturn a < b\n\t})\n\tfor i := len(lst) - 1; i > 0; i-- {\n\t\tlst[i],\
    \ lst[i-1] = lst[i-1], lst[i]\n\t}\n\treturn lst\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpmbntor4a.swift:13:12: error: expected expression in list of expressions\n\
    \        sort.Sort(func(a, b Int) bool {\n                  ^\n/tmp/tmpmbntor4a.swift:13:16:\
    \ error: expected identifier in function declaration\n        sort.Sort(func(a,\
    \ b Int) bool {\n                      ^\n/tmp/tmpmbntor4a.swift:16:9: error:\
    \ expected type\n        for i := len(lst) - 1; i > 0; i-- {\n               ^\n\
    \                <#type#>\n/tmp/tmpmbntor4a.swift:16:9: error: expected 'in' after\
    \ for-each pattern\n        for i := len(lst) - 1; i > 0; i-- {\n            \
    \   ^\n/tmp/tmpmbntor4a.swift:16:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := len(lst) - 1; i > 0; i-- {\n               ^\n/tmp/tmpmbntor4a.swift:17:9:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       lst[i], lst[i-1] = lst[i-1], lst[i]\n                      ^\n       \
    \               ;\n/tmp/tmpmbntor4a.swift:17:9: error: expected expression\n \
    \               lst[i], lst[i-1] = lst[i-1], lst[i]\n                      ^\n\
    /tmp/tmpmbntor4a.swift:13:2: error: cannot find 'sort' in scope\n        sort.Sort(func(a,\
    \ b Int) bool {\n        ^~~~\n"
  stdout: ''
  timestamp: 1660028655
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count > 0 else {\
    \ return lst }\n\n    // Start with minimum element, then the maximum of the remaining\
    \ elements:\n    guard lst.count > 1 else { return lst }\n    var sortedList =\
    \ [Int]()\n    for idx in 0..<lst.count {\n        sortedList.append(lst[idx])\n\
    \        if idx > 1 {\n            // Move all elements before to end of array\n\
    \            sortedList.removeLast()\n            sortedList.appendContentsOf(lst[idx-1..<idx])\n\
    \        }\n    }\n    return sortedList\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpkuhzxx3y.swift:23:24: error: value of type '[Int]' has no member\
    \ 'appendContentsOf'\n            sortedList.appendContentsOf(lst[idx-1..<idx])\n\
    \            ~~~~~~~~~~ ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count > 0 else {\
    \ return lst }\n    guard lst.reduce(0) { $0 + $1 < $1 } == 0 else { return lst\
    \ }\n    let mid = lst.count / 2\n    let left = lst[0 ..< mid]\n    let right\
    \ = lst[mid...]\n    lst = left.sorted().append(right).sorted()\n    return lst\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpkahculwh.swift:14:35: error: cannot convert value of type 'Bool'\
    \ to closure result type 'Int'\n    guard lst.reduce(0) { $0 + $1 < $1 } == 0\
    \ else { return lst }\n                          ~~~~~~~~^~~~\n/tmp/tmpkahculwh.swift:18:5:\
    \ error: cannot assign to value: 'lst' is a 'let' constant\n    lst = left.sorted().append(right).sorted()\n\
    \    ^~~\n/tmp/tmpkahculwh.swift:18:32: error: missing argument label 'contentsOf:'\
    \ in call\n    lst = left.sorted().append(right).sorted()\n                  \
    \             ^\n                               contentsOf: \n/tmp/tmpkahculwh.swift:18:25:\
    \ error: cannot use mutating member on immutable value: function call returns\
    \ immutable value\n    lst = left.sorted().append(right).sorted()\n          ~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpkahculwh.swift:18:39: error: value of tuple type '()' has no member\
    \ 'sorted'\n    lst = left.sorted().append(right).sorted()\n          ~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028662
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty {\n        return\
    \ lst\n    }\n    var res = lst\n    let min = res.min()!\n    let max = res.max()!\n\
    \    var lastMaxIndex = -1\n    for idx in res.indices {\n        if res[idx]\
    \ == max {\n            lastMaxIndex = idx\n        }\n    }\n    for idx in res.indices\
    \ {\n        if res[idx] == min {\n            res[lastMaxIndex] = res[idx]\n\
    \            res[idx] = min\n        }\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmptos05t_9/tmptos05t_9.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2c0ce9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2c09e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2c09e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2c09df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptos05t_9                        0x000055f09d343834 <unavailable> + 6196

    5    libc.so.6                          0x00002ae2c0ed5460 __libc_start_main +
    245

    6    tmptos05t_9                        0x000055f09d343429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let max = lst.max()\n    let\
    \ min = lst.min()\n    var result: [Int] = []\n    for x in lst[0...] {\n    \
    \    if x < min {\n            result.insert(min, at: 0)\n        }\n        else\
    \ if x > max {\n            result.insert(max, at: result.count)\n        }\n\
    \        else {\n            result.append(x)\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmplpy9zi8g.swift:17:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if x < min {\n              \
    \ ^\n/tmp/tmplpy9zi8g.swift:17:16: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        if x < min {\n             \
    \  ^\n                   ?? <#default value#>\n/tmp/tmplpy9zi8g.swift:17:16: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        if x < min {\n               ^\n                  !\n/tmp/tmplpy9zi8g.swift:18:27:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            result.insert(min, at: 0)\n                          ^\n/tmp/tmplpy9zi8g.swift:18:27:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            result.insert(min, at: 0)\n                          ^\n\
    \                              ?? <#default value#>\n/tmp/tmplpy9zi8g.swift:18:27:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            result.insert(min, at: 0)\n                          ^\n\
    \                             !\n/tmp/tmplpy9zi8g.swift:20:21: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n        else\
    \ if x > max {\n                    ^\n/tmp/tmplpy9zi8g.swift:20:21: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     else if x > max {\n                    ^\n                        ?? <#default\
    \ value#>\n/tmp/tmplpy9zi8g.swift:20:21: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        else if x > max {\n\
    \                    ^\n                       !\n/tmp/tmplpy9zi8g.swift:21:27:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            result.insert(max, at: result.count)\n                          ^\n\
    /tmp/tmplpy9zi8g.swift:21:27: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n            result.insert(max, at: result.count)\n\
    \     "
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    for x\
    \ in result {\n        for y in result {\n            if y > x {\n           \
    \     swap(&result[y], &result[x])\n            }\n        }\n    }\n    result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpw4ct1492.swift:21:5: warning: variable is unused\n    result\n\
    \    ^~~~~~\n/tmp/tmpw4ct1492.swift:17:22: error: overlapping accesses to 'result',\
    \ but modification requires exclusive access; consider calling MutableCollection.swapAt(_:_:)\n\
    \                swap(&result[y], &result[x])\n                ~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n\
    \                result.swapAt(y, x)\n/tmp/tmpw4ct1492.swift:17:34: note: conflicting\
    \ access is here\n                swap(&result[y], &result[x])\n             \
    \                    ^~~~~~~~~~\n/tmp/tmpw4ct1492.swift:21:5: error: missing return\
    \ in global function expected to return '[Int]'\n    result\n    ^\n/tmp/tmpw4ct1492.swift:21:5:\
    \ note: did you mean to return the last expression?\n    result\n    ^\n    return\
    \ \n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var sortedList = lst\n    sortedList.removeFirst()\n\
    \    sortedList.removeLast()\n    for index in (0..<sortedList.count).reverse()\
    \ {\n        var tmp = sortedList[index]\n        sortedList.insert(tmp, at: index)\n\
    \    }\n    return sortedList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp0mz3v8_s.swift:16:41: error: value of type 'Range<Int>' has no\
    \ member 'reverse'\n    for index in (0..<sortedList.count).reverse() {\n    \
    \             ~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var res = [Int]()\n    for\
    \ x in lst {\n        for _ in 0..<x.bitWidth {\n            res.append(x)\n \
    \       }\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpsq0_z749/tmpsq0_z749.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f0b017c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f0ad0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f0ad0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f0ad0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsq0_z749                        0x000055be344cb834 <unavailable> + 6196

    5    libc.so.6                          0x00002b8f0b203460 __libc_start_main +
    245

    6    tmpsq0_z749                        0x000055be344cb429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  var sorted: Array<Int> = []\n\
    \  for i in lst {\n    sorted.append(i)\n    sorted.sort()\n  }\n  return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpxcp42j1e/tmpxcp42j1e.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae35a8dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae35a5d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae35a5d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae35a5d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxcp42j1e                        0x000055a4e0b996b4 <unavailable> + 5812

    5    libc.so.6                          0x00002ae35aaca460 __libc_start_main +
    245

    6    tmpxcp42j1e                        0x000055a4e0b992a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count >= 3 else {\n\
    \        return lst\n    }\n    let min = lst[0]\n    let max = lst[lst.count\
    \ - 1]\n\n    var reversed = 0\n    let reversedLst: [[Int]] = lst.reverse()\n\
    \n    while true {\n        if reversedLst.contains(min) {\n            reversed\
    \ = reversedLst.indexOf(min, by: reversed)!\n            let temp = reversedLst.removeAtIndex(index)\n\
    \            reversedLst.insert(reversed, at: 0)\n            reversedLst.insert(temp,\
    \ at: 0)\n        } else {\n            break\n        }\n    }\n\n    return\
    \ reversedLst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp7h2xgqzc.swift:20:36: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    let reversedLst: [[Int]] = lst.reverse()\n\
    \                               ~~~ ^\n/tmp/tmp7h2xgqzc.swift:20:36: error: cannot\
    \ convert value of type '()' to specified type '[[Int]]'\n    let reversedLst:\
    \ [[Int]] = lst.reverse()\n                               ~~~~^~~~~~~~~\n/tmp/tmp7h2xgqzc.swift:23:33:\
    \ error: cannot convert value of type 'Int' to expected argument type '[Int]'\n\
    \        if reversedLst.contains(min) {\n                                ^\n/tmp/tmp7h2xgqzc.swift:24:36:\
    \ error: value of type '[[Int]]' has no member 'indexOf'\n            reversed\
    \ = reversedLst.indexOf(min, by: reversed)!\n                       ~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmp7h2xgqzc.swift:25:50: error: cannot find 'index' in scope\n\
    \            let temp = reversedLst.removeAtIndex(index)\n                   \
    \                              ^~~~~\n/tmp/tmp7h2xgqzc.swift:25:36: error: value\
    \ of type '[[Int]]' has no member 'removeAtIndex'\n            let temp = reversedLst.removeAtIndex(index)\n\
    \                       ~~~~~~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp7h2xgqzc.swift:26:25:\
    \ error: no exact matches in call to instance method 'insert'\n            reversedLst.insert(reversed,\
    \ at: 0)\n                        ^\n/tmp/tmp7h2xgqzc.swift:26:25: note: found\
    \ candidate with type '(__owned [Int], Int) -> ()'\n            reversedLst.insert(reversed,\
    \ at: 0)\n                        ^\n/tmp/tmp7h2xgqzc.swift:27:25: error: no exact\
    \ matches in call to instance method 'insert'\n            reversedLst.insert(temp,\
    \ at: 0)\n                        ^\n/tmp/tmp7h2xgqzc.swift:27:25: note: found\
    \ candidate with type '(__owned [Int], Int) -> ()'\n            reversedLst.insert(temp,\
    \ at: 0)\n                        ^\n/tmp/tmp7h2xgqzc.swift:33:12: error: cannot\
    \ convert return expression of type '[[Int]]' to return type '[Int]'\n    return\
    \ reversedLst\n           ^\n/tmp/tmp7h2xgqzc.swift:33:12: note: arguments to\
    \ generic parameter 'Element' ('[Int]' and 'Int') are expected to be equal\n \
    \   r"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n\tif lst.isEmpty {\n\t\treturn\
    \ lst\n\t}\n\tlet min = lst[0]\n\tlet max = lst[0]\n\tvar index = 0\n\tfor item\
    \ in lst {\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t\tif item < min {\n\
    \t\t\tmin = item\n\t\t}\n\t}\n\tfor item in lst {\n\t\tif item > max {\n\t\t\t\
    max = item\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\tfor item\
    \ in lst {\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t\tif item < min {\n\
    \t\t\tmin = item\n\t\t}\n\t}\n\tfor item in lst {\n\t\tif item > max {\n\t\t\t\
    max = item\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\tfor item\
    \ in lst {\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t\tif item < min {\n\
    \t\t\tmin = item\n\t\t}\n\t}\n\tfor item in lst {\n\t\tif item > max {\n\t\t\t\
    max = item\n\t\t}\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\treturn\
    \ lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmphv3driqi.swift:21:4: error: cannot assign to value: 'max' is a\
    \ 'let' constant\n                        max = item\n                       \
    \ ^~~\n/tmp/tmphv3driqi.swift:17:2: note: change 'let' to 'var' to make it mutable\n\
    \        let max = lst[0]\n        ^~~\n        var\n/tmp/tmphv3driqi.swift:24:4:\
    \ error: cannot assign to value: 'min' is a 'let' constant\n                 \
    \       min = item\n                        ^~~\n/tmp/tmphv3driqi.swift:16:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let min = lst[0]\n \
    \       ^~~\n        var\n/tmp/tmphv3driqi.swift:29:4: error: cannot assign to\
    \ value: 'max' is a 'let' constant\n                        max = item\n     \
    \                   ^~~\n/tmp/tmphv3driqi.swift:17:2: note: change 'let' to 'var'\
    \ to make it mutable\n        let max = lst[0]\n        ^~~\n        var\n/tmp/tmphv3driqi.swift:32:4:\
    \ error: cannot assign to value: 'min' is a 'let' constant\n                 \
    \       min = item\n                        ^~~\n/tmp/tmphv3driqi.swift:16:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let min = lst[0]\n \
    \       ^~~\n        var\n/tmp/tmphv3driqi.swift:37:4: error: cannot assign to\
    \ value: 'max' is a 'let' constant\n                        max = item\n     \
    \                   ^~~\n/tmp/tmphv3driqi.swift:17:2: note: change 'let' to 'var'\
    \ to make it mutable\n        let max = lst[0]\n        ^~~\n        var\n/tmp/tmphv3driqi.swift:40:4:\
    \ error: cannot assign to value: 'min' is a 'let' constant\n                 \
    \       min = item\n                        ^~~\n/tmp/tmphv3driqi.swift:16:2:\
    \ note: change 'let' to 'var' to make it mutable\n        let min = lst[0]\n \
    \       ^~~\n        var\n/tmp/tmphv3driqi.swift:45:4: error: cannot assign to\
    \ value: 'max' is a 'let' constant\n                        max = item\n     \
    \                   ^~~\n/tmp/tmphv3driqi.swift:17:2: note: change 'let' to 'var'\
    \ to make it mutable\n        let max = lst[0]\n        ^~~\n        var\n/tmp/tmphv3driqi.swift:48:4:\
    \ error: cannot assign to value: 'min' is a 'let' constant\n                 \
    \       min = item\n         "
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int]()\n    var\
    \ index = 0\n    \n    var minElem = lst[0]\n    \n    for value in lst {\n  \
    \      if value < minElem {\n            minElem = value\n        }\n        \n\
    \        result[index] = value\n        index++\n    }\n    \n    for value in\
    \ lst {\n        switch value {\n        case minElem:\n            continue\n\
    \        default:\n            result.insert(minElem, at: index)\n           \
    \ \n            minElem = value\n            index++\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp2uxo86ey.swift:24:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        index++\n             ^~\n/tmp/tmp2uxo86ey.swift:35:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  index++\n                 ^~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count < 2 {\n      \
    \  return lst\n    }\n    var lMin = lst[0]\n    var lMax = lst[0]\n    for i\
    \ := 1; i < lst.count; i++ {\n        if lst[i] < lMin {\n            lMin = lst[i]\n\
    \        } else if lst[i] > lMax {\n            lMax = lst[i]\n        }\n   \
    \ }\n    var rMin = lst[0]\n    var rMax = lst[0]\n    for i := 1; i < lst.count;\
    \ i++ {\n        if lst[i] < rMin {\n            rMin = lst[i]\n        } else\
    \ if lst[i] > rMax {\n            rMax = lst[i]\n        }\n    }\n    return\
    \ [lMin, rMin, lMax, rMax]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpwuk1iprm.swift:18:12: error: expected type\n    for i := 1; i <\
    \ lst.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpwuk1iprm.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmpwuk1iprm.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 1; i < lst.count; i++ {\n       \
    \    ^\n/tmp/tmpwuk1iprm.swift:27:12: error: expected type\n    for i := 1; i\
    \ < lst.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpwuk1iprm.swift:27:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmpwuk1iprm.swift:27:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 1; i < lst.count; i++ {\n       \
    \    ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var sorted_lst = lst\n    var\
    \ min = sorted_lst.min()\n    var max = sorted_lst.max()\n    if min == max {\n\
    \        return sorted_lst\n    }\n    for index in (0..<(sorted_lst.count)) {\n\
    \        if min > max  {\n            sorted_lst.remove(at: index)\n         \
    \   continue\n        }\n        sorted_lst.remove(at: index)\n        let new_min\
    \ = sorted_lst.min()\n        if new_min > min {\n            sorted_lst.insert(new_min,\
    \ at: index)\n            continue\n        }\n        let new_max = sorted_lst.max()\n\
    \        if new_max < max {\n            sorted_lst.insert(new_max, at: index)\n\
    \        }\n    }\n    return sorted_lst\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpvx7bd0zt.swift:20:16: error: binary operator '>' cannot be applied\
    \ to two 'Int?' operands\n        if min > max  {\n           ~~~ ^ ~~~\n/tmp/tmpvx7bd0zt.swift:20:16:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if min > max  {\n               ^\n/tmp/tmpvx7bd0zt.swift:26:20:\
    \ error: binary operator '>' cannot be applied to two 'Int?' operands\n      \
    \  if new_min > min {\n           ~~~~~~~ ^ ~~~\n/tmp/tmpvx7bd0zt.swift:26:20:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n        if new_min > min {\n                   ^\n/tmp/tmpvx7bd0zt.swift:27:31:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            sorted_lst.insert(new_min, at: index)\n                         \
    \     ^\n/tmp/tmpvx7bd0zt.swift:27:31: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n            sorted_lst.insert(new_min,\
    \ at: index)\n                              ^\n                              \
    \        ?? <#default value#>\n/tmp/tmpvx7bd0zt.swift:27:31: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    sorted_lst.insert(new_min, at: index)\n                              ^\n\
    \                                     !\n/tmp/tmpvx7bd0zt.swift:31:20: error:\
    \ binary operator '<' cannot be applied to two 'Int?' operands\n        if new_max\
    \ < max {\n           ~~~~~~~ ^ ~~~\n/tmp/tmpvx7bd0zt.swift:31:20: note: overloads\
    \ for '<' exist with these partially matching parameter lists: (Int, Int)\n  \
    \      if new_max < max {\n                   ^\n/tmp/tmpvx7bd0zt.swift:32:31:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            sorted_lst.insert(new_max, at: index)\n                         \
    \     ^\n/tmp/tmpvx7bd0zt.swift:32:31: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n            sorted_lst.insert(new_max,\
    \ at: index)\n                              ^\n                              \
    \        ?"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  var result = [Int]()\n\n  guard\
    \ lst.count > 0 else {\n    return result\n  }\n\n  var minInt = Int64(lst[0])\n\
    \  var maxInt = Int64(lst[0])\n\n  for val in lst {\n    if val > maxInt {\n \
    \     maxInt = val\n    }\n\n    if val < minInt {\n      minInt = val\n    }\n\
    \  }\n\n  for i in 0..<lst.count {\n    if lst[i] < minInt {\n      result.insert(minInt,\
    \ at: i)\n      minInt = Int64(lst[i])\n    }\n\n    if lst[i] > maxInt {\n  \
    \    result.insert(maxInt, at: i)\n      maxInt = Int64(lst[i])\n    }\n  }\n\n\
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpp38k5lh4.swift:24:16: error: cannot assign value of type 'Int'\
    \ to type 'Int64'\n      maxInt = val\n               ^~~\n               Int64(\
    \ )\n/tmp/tmpp38k5lh4.swift:28:16: error: cannot assign value of type 'Int' to\
    \ type 'Int64'\n      minInt = val\n               ^~~\n               Int64(\
    \ )\n/tmp/tmpp38k5lh4.swift:34:21: error: cannot convert value of type 'Int64'\
    \ to expected argument type 'Int'\n      result.insert(minInt, at: i)\n      \
    \              ^\n                    Int(  )\n/tmp/tmpp38k5lh4.swift:39:21: error:\
    \ cannot convert value of type 'Int64' to expected argument type 'Int'\n     \
    \ result.insert(maxInt, at: i)\n                    ^\n                    Int(\
    \  )\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var lst2 = lst\n    lst2.sort()\n\
    \    return lst2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpjn5__6iw/tmpjn5__6iw.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b188e362c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b188e059b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b188e059988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b188e0587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjn5__6iw                        0x00005596e74ed4f4 <unavailable> + 5364

    5    libc.so.6                          0x00002b188e54e460 __libc_start_main +
    245

    6    tmpjn5__6iw                        0x00005596e74ed0e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  if lst.isEmpty() {\n    return\
    \ lst\n  }\n  var smallest = lst.min()\n  var largest = lst.max()\n  var sorted:\
    \ [Int] = []\n  for number in lst {\n    if number < smallest {\n      sorted\
    \ = append(sorted, smallest)\n      smallest = number\n    } else if number >\
    \ largest {\n      sorted = append(sorted, largest)\n      largest = number\n\
    \    } else {\n      sorted = append(sorted, number)\n    }\n  }\n  sorted = append(sorted,\
    \ largest)\n  return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp4tnzgm98.swift:13:10: error: cannot call value of non-function\
    \ type 'Bool'\n  if lst.isEmpty() {\n         ^      ~~\n                \n/tmp/tmp4tnzgm98.swift:20:17:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \    if number < smallest {\n                ^\n/tmp/tmp4tnzgm98.swift:20:17:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if number < smallest {\n                ^\n                     \
    \    ?? <#default value#>\n/tmp/tmp4tnzgm98.swift:20:17: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    if number <\
    \ smallest {\n                ^\n                        !\n/tmp/tmp4tnzgm98.swift:21:16:\
    \ error: cannot find 'append' in scope\n      sorted = append(sorted, smallest)\n\
    \               ^~~~~~\n/tmp/tmp4tnzgm98.swift:23:24: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n    } else if number\
    \ > largest {\n                       ^\n/tmp/tmp4tnzgm98.swift:23:24: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ } else if number > largest {\n                       ^\n                   \
    \            ?? <#default value#>\n/tmp/tmp4tnzgm98.swift:23:24: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    } else\
    \ if number > largest {\n                       ^\n                          \
    \    !\n/tmp/tmp4tnzgm98.swift:24:16: error: cannot find 'append' in scope\n \
    \     sorted = append(sorted, largest)\n               ^~~~~~\n/tmp/tmp4tnzgm98.swift:27:16:\
    \ error: cannot find 'append' in scope\n      sorted = append(sorted, number)\n\
    \               ^~~~~~\n/tmp/tmp4tnzgm98.swift:30:12: error: cannot find 'append'\
    \ in scope\n  sorted = append(sorted, largest)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return []\n    }\n    var min_idx = lst.index(of: min(lst))!\n    let max_idx\
    \ = lst.index(of: max(lst))!\n    var arr = [Int]()\n    for i in min_idx ..<\
    \ max_idx {\n        arr.append(lst[i])\n    }\n    return arr\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp583o0bzk.swift:16:40: error: missing argument for parameter #2\
    \ in call\n    var min_idx = lst.index(of: min(lst))!\n                      \
    \                 ^\n                                       , <#Int#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmp583o0bzk.swift:16:37:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    var min_idx = lst.index(of: min(lst))!\n                                \
    \    ^\n/tmp/tmp583o0bzk.swift:17:40: error: missing argument for parameter #2\
    \ in call\n    let max_idx = lst.index(of: max(lst))!\n                      \
    \                 ^\n                                       , <#Int#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmp583o0bzk.swift:17:37:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    let max_idx = lst.index(of: max(lst))!\n                                \
    \    ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    let low\
    \ = &lst[0]\n    \n    // Find min and max value\n    let minIndex = lst.index(low)\n\
    \    let minValue = &lst[minIndex]\n    \n    let maxIndex = lst.index(minValue)!\n\
    \    \n    // Sort left side first\n    \n    if maxIndex > 0 {\n        let min1\
    \ = &lst[minIndex]\n        let min2 = &lst[minIndex - 1]\n        \n        if\
    \ min1 < min2 {\n            result = result.sorted()\n        }\n    }\n    \n\
    \    // Sort right side second\n    \n    if maxIndex < lst.count - 1 {\n    \
    \    let max1 = &lst[maxIndex]\n        let max2 = &lst[maxIndex + 1]\n      \
    \  \n        if max1 > max2 {\n            result = result.sorted()\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpnayo22bg.swift:14:15: error: '&' may only be used to pass an argument\
    \ to inout parameter\n    let low = &lst[0]\n              ^\n/tmp/tmpnayo22bg.swift:17:24:\
    \ error: no exact matches in call to instance method 'index'\n    let minIndex\
    \ = lst.index(low)\n                       ^\n/tmp/tmpnayo22bg.swift:17:24: note:\
    \ found candidate with type '(Int) -> Int'\n    let minIndex = lst.index(low)\n\
    \                       ^\n/tmp/tmpnayo22bg.swift:17:24: note: found candidate\
    \ with type '(Int) -> Int'\n    let minIndex = lst.index(low)\n              \
    \         ^\n/tmp/tmpnayo22bg.swift:17:24: note: found candidate with type '(Int)\
    \ -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n    let minIndex = lst.index(low)\n\
    \                       ^\n/tmp/tmpnayo22bg.swift:18:20: error: '&' may only be\
    \ used to pass an argument to inout parameter\n    let minValue = &lst[minIndex]\n\
    \                   ^\n/tmp/tmpnayo22bg.swift:20:30: error: missing argument label\
    \ 'of:' in call\n    let maxIndex = lst.index(minValue)!\n                   \
    \          ^\n                             of: \n/tmp/tmpnayo22bg.swift:25:20:\
    \ error: '&' may only be used to pass an argument to inout parameter\n       \
    \ let min1 = &lst[minIndex]\n                   ^\n/tmp/tmpnayo22bg.swift:26:20:\
    \ error: '&' may only be used to pass an argument to inout parameter\n       \
    \ let min2 = &lst[minIndex - 1]\n                   ^\n/tmp/tmpnayo22bg.swift:36:20:\
    \ error: '&' may only be used to pass an argument to inout parameter\n       \
    \ let max1 = &lst[maxIndex]\n                   ^\n/tmp/tmpnayo22bg.swift:37:20:\
    \ error: '&' may only be used to pass an argument to inout parameter\n       \
    \ let max2 = &lst[maxIndex + 1]\n                   ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  var i = 0\n  var max = Float.greatestFiniteMagnitude\n\
    \  for idx in lst.indices {\n    let number = lst[idx]\n    if number < min {\n\
    \      min = number\n    }\n    if number > max {\n      max = number\n    }\n\
    \    lst[idx] = i\n    i += 1\n  }\n  var idx = i\n  var min = Float.leastNormalMagnitude\n\
    \  for idx in lst.indices {\n    let number = lst[idx]\n    if number < min {\n\
    \      min = number\n    }\n    lst[idx] = i\n    i += 1\n  }\n  max = Float.greatestFiniteMagnitude\n\
    \  for idx in lst.indices {\n    let number = lst[idx]\n    if number > max {\n\
    \      max = number\n    }\n    lst[idx] = i\n    i += 1\n  }\n  return lst\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpsa6iosq5.swift:17:15: error: type '(T, T) -> T' cannot conform\
    \ to 'BinaryInteger'\n    if number < min {\n              ^\n/tmp/tmpsa6iosq5.swift:17:15:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n    if number < min {\n              ^\n/tmp/tmpsa6iosq5.swift:17:15:\
    \ note: required by operator function '<' where 'Other' = '(T, T) -> T'\n    if\
    \ number < min {\n              ^\n/tmp/tmpsa6iosq5.swift:17:17: error: generic\
    \ parameter 'T' could not be inferred\n    if number < min {\n               \
    \ ^\nSwift.min:1:24: note: in call to function 'min'\n@inlinable public func min<T>(_\
    \ x: T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpsa6iosq5.swift:18:7:\
    \ error: no exact matches in reference to global function 'min'\n      min = number\n\
    \      ^\n/tmp/tmpsa6iosq5.swift:18:7: note: found candidate with type '(_, _)\
    \ -> _'\n      min = number\n      ^\n/tmp/tmpsa6iosq5.swift:18:7: note: found\
    \ candidate with type '(_, _, _, _...) -> _'\n      min = number\n      ^\n/tmp/tmpsa6iosq5.swift:20:15:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and 'Float'\n\
    \    if number > max {\n       ~~~~~~ ^ ~~~\n/tmp/tmpsa6iosq5.swift:20:15: note:\
    \ overloads for '>' exist with these partially matching parameter lists: (Int,\
    \ Int)\n    if number > max {\n              ^\n/tmp/tmpsa6iosq5.swift:21:13:\
    \ error: cannot assign value of type 'Int' to type 'Float'\n      max = number\n\
    \            ^~~~~~\n            Float()\n/tmp/tmpsa6iosq5.swift:23:8: error:\
    \ cannot assign through subscript: 'lst' is a 'let' constant\n    lst[idx] = i\n\
    \    ~~~^\n/tmp/tmpsa6iosq5.swift:30:15: error: binary operator '<' cannot be\
    \ applied to operands of type 'Int' and 'Float'\n    if number < min {\n     \
    \  ~~~~~~ ^ ~~~\n/tmp/tmpsa6iosq5.swift:30:15: note: overloads for '<' exist with\
    \ these partially matching parameter lists: (Int, Int)\n    if number < min {\n\
    \              ^\n/tmp/tmpsa6iosq5.swift:31:13: error: cannot assign value of\
    \ type 'Int' to type 'Float'\n      min = number\n            ^~~~~~\n       \
    \     Float("
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let min = lst.min()\n    let\
    \ max = lst.max()\n    var sorted = lst\n    for element in lst {\n        if\
    \ element < min {\n            sorted.remove(at: sorted.index(of: min))\n    \
    \        sorted.insert(element, at: sorted.index(of: min))\n        }\n      \
    \  else if element > max {\n            sorted.remove(at: sorted.index(of: max))\n\
    \            sorted.insert(element, at: sorted.index(of: max))\n        }\n  \
    \  }\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpom2884tf.swift:17:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if element < min {\n        \
    \             ^\n/tmp/tmpom2884tf.swift:17:22: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if element < min {\n\
    \                     ^\n                         ?? <#default value#>\n/tmp/tmpom2884tf.swift:17:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if element < min {\n                     ^\n                \
    \        !\n/tmp/tmpom2884tf.swift:18:38: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n            sorted.remove(at: sorted.index(of: min))\n        \
    \                             ^\n/tmp/tmpom2884tf.swift:18:38: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \         sorted.remove(at: sorted.index(of: min))\n                         \
    \            ^\n                                                    ?? <#default\
    \ value#>\n/tmp/tmpom2884tf.swift:18:38: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            sorted.remove(at:\
    \ sorted.index(of: min))\n                                     ^\n           \
    \                                        !\n/tmp/tmpom2884tf.swift:18:48: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \           sorted.remove(at: sorted.index(of: min))\n                       \
    \                        ^\n/tmp/tmpom2884tf.swift:18:48: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \   sorted.remove(at: sorted.index(of: min))\n                               \
    \                ^\n                                                   ?? <#default\
    \ value#>\n/tmp/tmpom2884tf.swift:18:48: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            sorted.remove(at:\
    \ sorted.index(of: min))\n            "
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n\tvar res: [Int] = []\n\n\tlet\
    \ min = min(lst)\n\n\tfor elem in lst {\n\t\tif elem < min {\n\t\t\tres.insert(elem,\
    \ at: 0)\n\t\t\tmin = elem\n\t\t} else if elem > min {\n\t\t\tres.insert(min,\
    \ at: res.count - 1)\n\t\t\tmin = min(lst)\n\t\t}\n\t}\n\n\treturn res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpxradutx4.swift:15:19: error: missing argument for parameter #2\
    \ in call\n        let min = min(lst)\n                         ^\n          \
    \               , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var temp = [Int]()\n    for\
    \ element in lst.reverse() {\n        if temp.contains(element) {\n          \
    \  continue\n        }\n        temp.append(element)\n    }\n    return temp.reverse()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmprg8nv7sj.swift:14:24: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    for element in lst.reverse() {\n     \
    \              ~~~ ^\n/tmp/tmprg8nv7sj.swift:14:24: error: for-in loop requires\
    \ '()' to conform to 'Sequence'\n    for element in lst.reverse() {\n        \
    \           ~~~~^~~~~~~~~\n/tmp/tmprg8nv7sj.swift:20:17: error: cannot convert\
    \ return expression of type '()' to return type '[Int]'\n    return temp.reverse()\n\
    \           ~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let min_idx = lst.min()!\n\
    \    let max_idx = lst.max()!\n    return lst.sorted().prefix(max_idx - min_idx).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmp_1l6o57k/tmp_1l6o57k.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e85b8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e85882b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e85882988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e858817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_1l6o57k                        0x0000562ffd143774 <unavailable> + 6004

    5    libc.so.6                          0x00002b8e85d77460 __libc_start_main +
    245

    6    tmp_1l6o57k                        0x0000562ffd143369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let size = lst.count\n    return\
    \ (0..<size).map({ i in\n        let j = lst.index(lst.startIndex, offsetBy: i)\n\
    \        let k = lst.index(lst.startIndex, offsetBy: (i + 1))\n        if j <\
    \ k {\n            lst[j], lst[k] = lst[k], lst[j]\n        }\n        return\
    \ lst[i]\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpax6lel6e.swift:18:19: error: consecutive statements on a line must\
    \ be separated by ';'\n            lst[j], lst[k] = lst[k], lst[j]\n         \
    \         ^\n                  ;\n/tmp/tmpax6lel6e.swift:18:19: error: expected\
    \ expression\n            lst[j], lst[k] = lst[k], lst[j]\n                  ^\n\
    /tmp/tmpax6lel6e.swift:18:16: warning: expression of type 'Int' is unused\n  \
    \          lst[j], lst[k] = lst[k], lst[j]\n            ~~~^~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty {\n        return\
    \ lst\n    }\n    var sorted_lst = [Int]()\n    var last_value = 0\n\n    for\
    \ i in lst {\n        if i == last_value {\n            sorted_lst.append(i)\n\
    \            last_value += 1\n        } else {\n            last_value = i\n \
    \           sorted_lst.insert(last_value, i)\n        }\n    }\n\n    return sorted_lst\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp13300wfs.swift:25:24: error: no exact matches in call to instance\
    \ method 'insert'\n            sorted_lst.insert(last_value, i)\n            \
    \           ^\nSwift.Array:11:37: note: incorrect labels for candidate (have:\
    \ '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect labels for candidate\
    \ (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Self.Element, at i: Self.Index)\n                      \
    \              ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty {\n        return\
    \ lst\n    }\n    var l = lst.minElement()\n    var r = lst.maxElement()\n   \
    \ while l != r {\n        var tmp = l\n        l = r\n        r = tmp\n    }\n\
    \    return lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpei09mi5p.swift:16:17: error: value of type '[Int]' has no member\
    \ 'minElement'\n    var l = lst.minElement()\n            ~~~ ^~~~~~~~~~\n/tmp/tmpei09mi5p.swift:17:17:\
    \ error: value of type '[Int]' has no member 'maxElement'\n    var r = lst.maxElement()\n\
    \            ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    var res = lst\n    \n\
    \    let minElem = res[0]\n    let maxElem = res[0]\n    \n    for elem in res\
    \ {\n        if elem < minElem {\n            minElem = elem\n        } else if\
    \ elem > maxElem {\n            maxElem = elem\n        }\n    }\n    \n    if\
    \ maxElem < minElem {\n        minElem, maxElem = maxElem, minElem\n    }\n  \
    \  \n    while (minElem <= maxElem) {\n        var temp = minElem\n        minElem\
    \ = maxElem\n        maxElem = temp\n    }\n    \n    for elem in res {\n    \
    \    if elem < minElem {\n            res.remove(at: 0)\n            res.insert(elem,\
    \ at: 0)\n        } else if (elem == minElem) {\n            res.remove(at: 0)\n\
    \            res.insert(elem, at: 0)\n        }\n    }\n    \n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpsktrbrtw.swift:28:16: error: consecutive statements on a line must\
    \ be separated by ';'\n        minElem, maxElem = maxElem, minElem\n         \
    \      ^\n               ;\n/tmp/tmpsktrbrtw.swift:28:16: error: expected expression\n\
    \        minElem, maxElem = maxElem, minElem\n               ^\n/tmp/tmpsktrbrtw.swift:21:13:\
    \ error: cannot assign to value: 'minElem' is a 'let' constant\n            minElem\
    \ = elem\n            ^~~~~~~\n/tmp/tmpsktrbrtw.swift:16:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let minElem = res[0]\n    ^~~\n    var\n/tmp/tmpsktrbrtw.swift:23:13:\
    \ error: cannot assign to value: 'maxElem' is a 'let' constant\n            maxElem\
    \ = elem\n            ^~~~~~~\n/tmp/tmpsktrbrtw.swift:17:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let maxElem = res[0]\n    ^~~\n    var\n/tmp/tmpsktrbrtw.swift:28:9:\
    \ warning: expression of type 'Int' is unused\n        minElem, maxElem = maxElem,\
    \ minElem\n        ^~~~~~~\n/tmp/tmpsktrbrtw.swift:33:9: error: cannot assign\
    \ to value: 'minElem' is a 'let' constant\n        minElem = maxElem\n       \
    \ ^~~~~~~\n/tmp/tmpsktrbrtw.swift:16:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let minElem = res[0]\n    ^~~\n    var\n/tmp/tmpsktrbrtw.swift:34:9:\
    \ error: cannot assign to value: 'maxElem' is a 'let' constant\n        maxElem\
    \ = temp\n        ^~~~~~~\n/tmp/tmpsktrbrtw.swift:17:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let maxElem = res[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted { $0 < $1\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2,\
    \ 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5,\
    \ 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmprmbno6no/tmprmbno6no.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af501b0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af501802b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af501802988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5018017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprmbno6no                        0x0000556aef76c444 <unavailable> + 5188

    5    libc.so.6                          0x00002af501cf7460 __libc_start_main +
    245

    6    tmprmbno6no                        0x0000556aef76c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty {\n        return\
    \ []\n    }\n    if lst.count == 1 {\n        return lst\n    }\n    var min_val\
    \ = lst[0]\n    var max_val = min_val\n    var temp_min_index = 0\n    var temp_max_index\
    \ = 0\n    for i in lst {\n        if i > max_val {\n            max_val = i\n\
    \            temp_max_index = i\n        }\n        if i < min_val {\n       \
    \     min_val = i\n            temp_min_index = i\n        }\n    }\n    \n  \
    \  var tmp_lst = strange_sort_list(lst: Array(lst.suffix(from: temp_min_index)))\n\
    \    tmp_lst.append(min_val)\n    tmp_lst.append(max_val)\n    tmp_lst = strange_sort_list(lst:\
    \ tmp_lst)\n    \n    return tmp_lst\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660028661
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted(by: <)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpv7wme3pr/tmpv7wme3pr.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ed0657c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ed034eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6ed034e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6ed034d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv7wme3pr                        0x00005607e9ca5444 <unavailable> + 5188

    5    libc.so.6                          0x00002b6ed0843460 __libc_start_main +
    245

    6    tmpv7wme3pr                        0x00005607e9ca5039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var ordered = [Int]()\n   \
    \ var min = lst[0]\n    for i in lst {\n        ordered[i] = i\n        if i <\
    \ min {\n            min = i\n        }\n    }\n    var max = min\n    for i in\
    \ lst {\n        if i > max {\n            ordered[i] = max\n            max =\
    \ i\n        }\n    }\n    for i in  ordered {\n        ordered[i] = i\n    }\n\
    \    return ordered\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b58a6fafc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58a6ca6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b58a6ca6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b58a6ca613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b58a6ca5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b58a6aa57ec <unavailable> + 186348

    6    tmp5iy3p1t8                        0x0000562d2f65d322 <unavailable> + 8994

    7    tmp5iy3p1t8                        0x0000562d2f65c55c <unavailable> + 5468

    8    libc.so.6                          0x00002b58a719b460 __libc_start_main +
    245

    9    tmp5iy3p1t8                        0x0000562d2f65c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var output = [Int]()\n    var\
    \ min: Int? = nil\n    var max: Int? = nil\n    for num in lst {\n        if min\
    \ == nil {\n            min = num\n        } else {\n            if num < min\
    \ {\n                min = num\n            }\n        }\n        if max == nil\
    \ {\n            max = num\n        } else {\n            if num > max {\n   \
    \             max = num\n            }\n        }\n    }\n    if min != nil {\n\
    \        output.append(min)\n    }\n    if max != nil {\n        output.append(max)\n\
    \    }\n    for num in lst {\n        if num != min && num != max {\n        \
    \    output.append(num)\n        }\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpuaqgelt0.swift:20:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n            if num < min {\n        \
    \             ^\n/tmp/tmpuaqgelt0.swift:20:22: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            if num < min {\n\
    \                     ^\n                         ?? <#default value#>\n/tmp/tmpuaqgelt0.swift:20:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            if num < min {\n                     ^\n                \
    \        !\n/tmp/tmpuaqgelt0.swift:27:22: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n            if num > max {\n   \
    \                  ^\n/tmp/tmpuaqgelt0.swift:27:22: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n            if\
    \ num > max {\n                     ^\n                         ?? <#default value#>\n\
    /tmp/tmpuaqgelt0.swift:27:22: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            if num > max {\n         \
    \            ^\n                        !\n/tmp/tmpuaqgelt0.swift:33:23: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \       output.append(min)\n                      ^\n/tmp/tmpuaqgelt0.swift:33:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        output.append(min)\n                      ^\n               \
    \           ?? <#default value#>\n/tmp/tmpuaqgelt0.swift:33:23: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        output.append(min)\n\
    \                      ^\n                         !\n/tmp/tmpuaqgelt0.swift:36:23:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        output.append(max)\n                      ^\n/tmp/tmpuaqgelt0.swift:36:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        output.append(max)\n                      ^\n               \
    \           "
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    switch lst.count {\n    case\
    \ 0:\n        return []\n    case 1:\n        return lst\n    case 2:\n      \
    \  if lst[0] > lst[1] {\n            return lst\n        }\n        return reversed(lst)\n\
    \    default:\n        let min = lst.min()\n        let max = lst.max()\n    \
    \    var lst2 = reversedArray(lst)\n        lst2.sortInPlace()\n        lst2.removeFirst()\n\
    \        if lst[0] < min {\n            lst2.remove(at: 0)\n        }\n      \
    \  if lst[1] > max {\n            lst2.remove(at: 1)\n        }\n        return\
    \ lst2\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmph8qaw6co.swift:22:16: error: cannot find 'reversed' in scope\n\
    \        return reversed(lst)\n               ^~~~~~~~\n/tmp/tmph8qaw6co.swift:26:20:\
    \ error: cannot find 'reversedArray' in scope\n        var lst2 = reversedArray(lst)\n\
    \                   ^~~~~~~~~~~~~\n/tmp/tmph8qaw6co.swift:29:21: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ if lst[0] < min {\n                    ^\n/tmp/tmph8qaw6co.swift:24:13: note:\
    \ short-circuit using 'guard' to exit this function early if the optional value\
    \ contains 'nil'\n        let min = lst.min()\n            ^\n        guard  \
    \             else { return <#default value#> }\n/tmp/tmph8qaw6co.swift:24:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let min = lst.min()\n                      ^\n              \
    \              ?? <#default value#>\n/tmp/tmph8qaw6co.swift:24:23: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        let\
    \ min = lst.min()\n                      ^\n                           !\n/tmp/tmph8qaw6co.swift:29:21:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if lst[0] < min {\n                    ^\n                  \
    \      ?? <#default value#>\n/tmp/tmph8qaw6co.swift:29:21: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ lst[0] < min {\n                    ^\n                       !\n/tmp/tmph8qaw6co.swift:32:21:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if lst[1] > max {\n                    ^\n/tmp/tmph8qaw6co.swift:25:13:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n        let max = lst.max()\n            ^\n        guard\
    \               else { return <#default value#> }\n/tmp/tmph8qaw6co.swift:25:23:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        let max = lst.max()\n                      ^\n              \
    \       "
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int]()\n    for\
    \ value in lst {\n        result.append(value)\n    }\n    for value in lst {\n\
    \        if result.last > value {\n            result.insert(result.last - 1,\
    \ value)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpwbns98hu.swift:18:19: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if result.last > value {\n  \
    \                ^\n/tmp/tmpwbns98hu.swift:18:19: note: coalesce using '??' to\
    \ provide a default when the optional value contains 'nil'\n        if result.last\
    \ > value {\n                  ^\n                       ?? <#default value#>\n\
    /tmp/tmpwbns98hu.swift:18:19: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if result.last > value {\n   \
    \               ^\n                      !\n/tmp/tmpwbns98hu.swift:19:34: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \           result.insert(result.last - 1, value)\n                          \
    \       ^\n/tmp/tmpwbns98hu.swift:19:34: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            result.insert(result.last\
    \ - 1, value)\n                                 ^\n                          (\
    \           ?? <#default value#>)\n/tmp/tmpwbns98hu.swift:19:34: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \    result.insert(result.last - 1, value)\n                                 ^\n\
    \                                     !\n/tmp/tmpwbns98hu.swift:19:20: error:\
    \ no exact matches in call to instance method 'insert'\n            result.insert(result.last\
    \ - 1, value)\n                   ^\n/tmp/tmpwbns98hu.swift:19:20: note: candidate\
    \ has partially matching parameter list (__owned Int, at: Int)\n            result.insert(result.last\
    \ - 1, value)\n                   ^\n/tmp/tmpwbns98hu.swift:19:20: note: candidate\
    \ has partially matching parameter list (__owned Int, at: Array<Int>.Index)\n\
    \            result.insert(result.last - 1, value)\n                   ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    func findMin(lst : [Int]) ->\
    \ Int {\n        var min = Int(lst.min())\n        for i in lst.removeAll {\n\
    \            if min > i {\n                min = i\n            }\n        }\n\
    \        return min\n    }\n\n    func findMax(lst : [Int]) -> Int {\n       \
    \ var max = Int(lst.max())\n        for i in lst.removeAll {\n            if max\
    \ < i {\n                max = i\n            }\n        }\n        return max\n\
    \    }\n\n    var result = lst.sorted()\n    var max = findMax(result)\n    var\
    \ min = findMin(result)\n    var len = result.count\n\n    var i = min\n    for\
    \ _ in 0 ..< len - 1 {\n        if max < result[i + 1] {\n            result =\
    \ result.removeLast() + result[len - 1]\n        }\n        if min > result[i\
    \ + 1] {\n            result = result.dropLast() + result[i]\n        }\n    \
    \    max = findMax(result)\n        min = findMin(result)\n        len--\n   \
    \     i++\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpcq2fb9fi.swift:14:27: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        var min = Int(lst.min())\n  \
    \                        ^\n/tmp/tmpcq2fb9fi.swift:14:27: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        var\
    \ min = Int(lst.min())\n                          ^\n                        \
    \        ?? <#default value#>\n/tmp/tmpcq2fb9fi.swift:14:27: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        var\
    \ min = Int(lst.min())\n                          ^\n                        \
    \       !\n/tmp/tmpcq2fb9fi.swift:15:22: error: no exact matches in reference\
    \ to instance method 'removeAll'\n        for i in lst.removeAll {\n         \
    \            ^\n/tmp/tmpcq2fb9fi.swift:15:22: note: found candidate with type\
    \ '(Bool) -> ()'\n        for i in lst.removeAll {\n                     ^\n/tmp/tmpcq2fb9fi.swift:15:22:\
    \ note: found candidate with type '((Int) throws -> Bool) throws -> ()'\n    \
    \    for i in lst.removeAll {\n                     ^\n/tmp/tmpcq2fb9fi.swift:15:22:\
    \ error: no 'removeAll' overloads produce result type that conforms to 'Sequence'\n\
    \        for i in lst.removeAll {\n                     ^\nSwift.Array:12:37:\
    \ note: found candidate with type '(Bool) -> ()'\n    @inlinable public mutating\
    \ func removeAll(keepingCapacity keepCapacity: Bool = false)\n               \
    \                     ^\nSwift.RangeReplaceableCollection:2:37: note: found candidate\
    \ with type '((Int) throws -> Bool) throws -> ()'\n    @inlinable public mutating\
    \ func removeAll(where shouldBeRemoved: (Self.Element) throws -> Bool) rethrows\n\
    \                                    ^\nSwift.RangeReplaceableCollection:14:37:\
    \ note: found candidate with type '(Bool) -> ()'\n    @inlinable public mutating\
    \ func removeAll(keepingCapacity keepCapacity: Bool = false)\n               \
    \                     ^\nSwift.RangeReplaceableCollection:2:37: note: found candidate\
    \ with type '((Int) throws -> Bool) throws -> ()'\n    @inlinable public mutating\
    \ func removeAll(where sho"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard !lst.isEmpty else { return\
    \ lst }\n    var min = lst[0]\n    var max = lst[0]\n    var min_index = 0\n \
    \   for index, i in lst.enumerated() {\n        if i < min {\n            min\
    \ = i\n            min_index = index\n        }\n        if i > max {\n      \
    \      max = i\n        }\n    }\n    var min_list = [Int](repeating: min_index,\
    \ count: lst.count)\n    min_list.sort()\n    var max_list = [Int](repeating:\
    \ max_index, count: lst.count)\n    max_list.sort()\n    var new_lst = [Int]()\n\
    \    for i in min_index..<(max_list.last + 1) {\n        new_lst.append((min_list[i]))\n\
    \        new_lst.append((max_list[i]))\n    }\n    return new_lst\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpv5rjfofp.swift:17:14: error: expected 'in' after for-each pattern\n\
    \    for index, i in lst.enumerated() {\n             ^\n/tmp/tmpv5rjfofp.swift:17:14:\
    \ error: expected Sequence expression for for-each loop\n    for index, i in lst.enumerated()\
    \ {\n             ^\n/tmp/tmpv5rjfofp.swift:28:37: error: cannot find 'max_index'\
    \ in scope\n    var max_list = [Int](repeating: max_index, count: lst.count)\n\
    \                                    ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n\tif lst.len() == 0 {\n\t\treturn\
    \ []\n\t}\n\tswitch lst[0] {\n\tcase Int.min():\n\t\treturn strange_sort_list(lst:\
    \ lst[1..<lst.count])\n\tcase Int.max():\n\t\treturn strange_sort_list(lst: lst[0..<lst.count])\n\
    \tdefault:\n\t\treturn lst\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp1wcryuuy.swift:13:9: error: value of type '[Int]' has no member\
    \ 'len'\n        if lst.len() == 0 {\n           ~~~ ^~~\n/tmp/tmp1wcryuuy.swift:17:11:\
    \ error: cannot call value of non-function type 'Int'\n        case Int.min():\n\
    \                 ^  ~~\n                    \n/tmp/tmp1wcryuuy.swift:19:11: error:\
    \ cannot call value of non-function type 'Int'\n        case Int.max():\n    \
    \             ^  ~~\n                    \n/tmp/tmp1wcryuuy.swift:18:36: error:\
    \ cannot convert value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n\
    \                return strange_sort_list(lst: lst[1..<lst.count])\n         \
    \                                        ^\n/tmp/tmp1wcryuuy.swift:20:36: error:\
    \ cannot convert value of type 'ArraySlice<Int>' to expected argument type '[Int]'\n\
    \                return strange_sort_list(lst: lst[0..<lst.count])\n         \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  guard lst.count > 0 else { return\
    \ lst }\n\n  var result = Array(lst.count)\n\n  for i in 0..<lst.count {\n   \
    \ result[i] = lst.maxElement()!\n  }\n  for index in 1..<lst.count {\n    result[index]\
    \ = lst.minElement()!\n  }\n  return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp32yotx_z.swift:15:22: error: missing argument label 'arrayLiteral:'\
    \ in call\n  var result = Array(lst.count)\n                     ^\n         \
    \            arrayLiteral: \n/tmp/tmp32yotx_z.swift:18:21: error: value of type\
    \ '[Int]' has no member 'maxElement'\n    result[i] = lst.maxElement()!\n    \
    \            ~~~ ^~~~~~~~~~\n/tmp/tmp32yotx_z.swift:21:25: error: value of type\
    \ '[Int]' has no member 'minElement'\n    result[index] = lst.minElement()!\n\
    \                    ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var s = lst\n\n    for element\
    \ in lst {\n        var pos = 0\n        for _ in 0 ..< s.count {\n          \
    \  pos += 1\n            if s[pos] < element {\n                break\n      \
    \      }\n        }\n\n        s[pos], s[s.count-1] = s[s.count-1], s[pos]\n \
    \   }\n\n    return s\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpcyt6kxnh.swift:24:15: error: consecutive statements on a line must\
    \ be separated by ';'\n        s[pos], s[s.count-1] = s[s.count-1], s[pos]\n \
    \             ^\n              ;\n/tmp/tmpcyt6kxnh.swift:24:15: error: expected\
    \ expression\n        s[pos], s[s.count-1] = s[s.count-1], s[pos]\n          \
    \    ^\n/tmp/tmpcyt6kxnh.swift:24:10: warning: subscript is accessed but result\
    \ is unused\n        s[pos], s[s.count-1] = s[s.count-1], s[pos]\n        ~^~~~~\n\
    /tmp/tmpcyt6kxnh.swift:13:9: warning: variable 's' was never mutated; consider\
    \ changing to 'let' constant\n    var s = lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n\tif lst.isEmpty {\n\t\treturn\
    \ lst\n\t}\n\n\tvar min = lst[0]\n\tvar max = lst[0]\n\tvar mid = min + ((max\
    \ - min) / 2)\n\tfor i := 1; i < lst.count; i++ {\n\t\tif lst[i] < mid {\n\t\t\
    \tmin = mid\n\t\t\tmid = min + ((max - min) / 2)\n\t\t} else if lst[i] > mid {\n\
    \t\t\tmax = mid\n\t\t\tmid = min + ((max - min) / 2)\n\t\t} else {\n\t\t\tmin\
    \ = lst[i]\n\t\t\tmid = min + ((max - min) / 2)\n\t\t}\n\t}\n\n\treturn strange_sort_list(lst:\
    \ lst, min: min, max: max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmplap87_r0.swift:20:9: error: expected type\n        for i := 1;\
    \ i < lst.count; i++ {\n               ^\n                <#type#>\n/tmp/tmplap87_r0.swift:20:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 1; i < lst.count;\
    \ i++ {\n               ^\n/tmp/tmplap87_r0.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 1; i < lst.count; i++ {\n   \
    \            ^\n/tmp/tmplap87_r0.swift:33:26: error: extra arguments at positions\
    \ #2, #3 in call\n        return strange_sort_list(lst: lst, min: min, max: max)\n\
    \                                ^\n/tmp/tmplap87_r0.swift:12:6: note: 'strange_sort_list(lst:)'\
    \ declared here\nfunc strange_sort_list(lst: [Int]) -> [Int] {\n     ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result: [Int] = []\n  \
    \  if lst.count == 0 {\n        return lst\n    }\n    var max: Int = 0\n    for\
    \ index in lst.indices {\n        if max < lst[index] {\n            max = lst[index]\n\
    \        }\n    }\n    for index in lst.indices {\n        if lst[index] == max\
    \ {\n            result.append(index)\n        }\n    }\n    for index in lst.indices\
    \ {\n        if lst[index] == max {\n            result.insert(index, max)\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpjkw7z8vz.swift:30:20: error: no exact matches in call to instance\
    \ method 'insert'\n            result.insert(index, max)\n                   ^\n\
    Swift.Array:11:37: note: incorrect labels for candidate (have: '(_:_:)', expected:\
    \ '(_:at:)')\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  var strange_sort: [Int] = []\n\
    \n  // Find the minimum element in the list.\n  var min_idx = lst.indexOf(min(lst))\n\
    \  if min_idx != lst.count {\n    strange_sort = strange_sort + lst[min_idx]\n\
    \  }\n\n  // Find the maximum element in the list.\n  var max_idx = lst.indexOf(max(lst))\n\
    \  if max_idx != lst.count {\n    strange_sort = strange_sort + lst[max_idx]\n\
    \  }\n\n  // Find the minimum element in the sorted list.\n  min_idx = strange_sort.indexOf(min(strange_sort))\n\
    \  if min_idx != strange_sort.count {\n    strange_sort = strange_sort + strange_sort[min_idx]\n\
    \  }\n\n  // Find the maximum element in the sorted list.\n  max_idx = strange_sort.indexOf(max(strange_sort))\n\
    \  if max_idx != strange_sort.count {\n    strange_sort = strange_sort + strange_sort[max_idx]\n\
    \  }\n\n  // Find the minimum element in the reversed list.\n  min_idx = strange_sort.reversed().indexOf(min(strange_sort.reversed()))\n\
    \  if min_idx != strange_sort.count {\n    strange_sort = strange_sort + strange_sort[min_idx]\n\
    \  }\n\n  // Find the maximum element in the reversed list.\n  max_idx = strange_sort.reversed().indexOf(max(strange_sort.reversed()))\n\
    \  if max_idx != strange_sort.count {\n    strange_sort = strange_sort + strange_sort[max_idx]\n\
    \  }\n\n  // Return the list with elements sorted in strange order.\n  return\
    \ strange_sort\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpsm_fxjmy.swift:16:21: error: value of type '[Int]' has no member\
    \ 'indexOf'\n  var min_idx = lst.indexOf(min(lst))\n                ~~~ ^~~~~~~\n\
    /tmp/tmpsm_fxjmy.swift:16:36: error: missing argument for parameter #2 in call\n\
    \  var min_idx = lst.indexOf(min(lst))\n                                   ^\n\
    \                                   , <#[Int]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpsm_fxjmy.swift:22:21: error: value of type\
    \ '[Int]' has no member 'indexOf'\n  var max_idx = lst.indexOf(max(lst))\n   \
    \             ~~~ ^~~~~~~\n/tmp/tmpsm_fxjmy.swift:22:36: error: missing argument\
    \ for parameter #2 in call\n  var max_idx = lst.indexOf(max(lst))\n          \
    \                         ^\n                                   , <#[Int]#>\n\
    Swift.max:1:24: note: 'max' declared here\n@inlinable public func max<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpsm_fxjmy.swift:28:26:\
    \ error: value of type '[Int]' has no member 'indexOf'\n  min_idx = strange_sort.indexOf(min(strange_sort))\n\
    \            ~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpsm_fxjmy.swift:28:50: error: missing\
    \ argument for parameter #2 in call\n  min_idx = strange_sort.indexOf(min(strange_sort))\n\
    \                                                 ^\n                        \
    \                         , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpsm_fxjmy.swift:34:26: error: value of type '[Int]'\
    \ has no member 'indexOf'\n  max_idx = strange_sort.indexOf(max(strange_sort))\n\
    \            ~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpsm_fxjmy.swift:34:50: error: missing\
    \ argument for parameter #2 in call\n  max_idx = strange_sort.indexOf(max(strange_sort))\n\
    \                                                 ^\n                        \
    \                         , <#[Int]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Compar"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int](repeating:\
    \ 0, count: lst.count)\n    var min = lst.min() // To avoid the case where there's\
    \ one element\n    var max = lst.max()\n    var curr = min\n    while lst.contains(curr)\
    \ {\n        result[lsts.index(lst, curr)] = curr\n        curr++\n    }\n   \
    \ while result.count < lst.count { // In case we have no elements left\n     \
    \   result[result.count] = curr\n        curr++\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpot41hbi_.swift:17:24: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    while lst.contains(curr) {\n    \
    \                   ^\n/tmp/tmpot41hbi_.swift:17:24: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n    while lst.contains(curr)\
    \ {\n                       ^\n                            ?? <#default value#>\n\
    /tmp/tmpot41hbi_.swift:17:24: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    while lst.contains(curr) {\n     \
    \                  ^\n                           !\n/tmp/tmpot41hbi_.swift:18:16:\
    \ error: cannot find 'lsts' in scope\n        result[lsts.index(lst, curr)] =\
    \ curr\n               ^~~~\n/tmp/tmpot41hbi_.swift:19:13: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n        curr++\n            ^~\n\
    /tmp/tmpot41hbi_.swift:22:32: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n        result[result.count] = curr\n            \
    \                   ^\n/tmp/tmpot41hbi_.swift:22:32: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        result[result.count]\
    \ = curr\n                               ^\n                                 \
    \   ?? <#default value#>\n/tmp/tmpot41hbi_.swift:22:32: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n        result[result.count]\
    \ = curr\n                               ^\n                                 \
    \  !\n/tmp/tmpot41hbi_.swift:23:13: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        curr++\n            ^~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    var swapped\
    \ = false\n    for idx2 in stride(from: 0, to: result.count, by: 1) {\n      \
    \  if swapped {\n            swapped = false\n            idx = idx2\n       \
    \     continue\n        }\n        if result[idx2] == result[idx] {\n        \
    \    swapped = true\n            continue\n        }\n        let maxIndex1 =\
    \ idx2\n        let minIndex1 = idx2\n        if result[idx2] > result[idx] {\n\
    \            minIndex1 = idx\n        }\n        if result[idx2] < result[idx]\
    \ {\n            maxIndex1 = idx\n        }\n        if minIndex1 != idx2 {\n\
    \            result = swap(&result, minIndex1, maxIndex1)\n            swapped\
    \ = true\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpzj77uu1m.swift:18:13: error: cannot find 'idx' in scope\n     \
    \       idx = idx2\n            ^~~\n/tmp/tmpzj77uu1m.swift:21:35: error: cannot\
    \ find 'idx' in scope\n        if result[idx2] == result[idx] {\n            \
    \                      ^~~\n/tmp/tmpzj77uu1m.swift:27:34: error: cannot find 'idx'\
    \ in scope\n        if result[idx2] > result[idx] {\n                        \
    \         ^~~\n/tmp/tmpzj77uu1m.swift:28:25: error: cannot find 'idx' in scope\n\
    \            minIndex1 = idx\n                        ^~~\n/tmp/tmpzj77uu1m.swift:28:13:\
    \ error: cannot assign to value: 'minIndex1' is a 'let' constant\n           \
    \ minIndex1 = idx\n            ^~~~~~~~~\n/tmp/tmpzj77uu1m.swift:26:9: note: change\
    \ 'let' to 'var' to make it mutable\n        let minIndex1 = idx2\n        ^~~\n\
    \        var\n/tmp/tmpzj77uu1m.swift:30:34: error: cannot find 'idx' in scope\n\
    \        if result[idx2] < result[idx] {\n                                 ^~~\n\
    /tmp/tmpzj77uu1m.swift:31:25: error: cannot find 'idx' in scope\n            maxIndex1\
    \ = idx\n                        ^~~\n/tmp/tmpzj77uu1m.swift:31:13: error: cannot\
    \ assign to value: 'maxIndex1' is a 'let' constant\n            maxIndex1 = idx\n\
    \            ^~~~~~~~~\n/tmp/tmpzj77uu1m.swift:25:9: note: change 'let' to 'var'\
    \ to make it mutable\n        let maxIndex1 = idx2\n        ^~~\n        var\n\
    /tmp/tmpzj77uu1m.swift:34:22: error: cannot assign value of type '()' to type\
    \ '[Int]'\n            result = swap(&result, minIndex1, maxIndex1)\n        \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzj77uu1m.swift:34:47:\
    \ error: extra argument in call\n            result = swap(&result, minIndex1,\
    \ maxIndex1)\n                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~\n/tmp/tmpzj77uu1m.swift:34:36:\
    \ error: cannot convert value of type 'Int' to expected argument type '[Int]'\n\
    \            result = swap(&result, minIndex1, maxIndex1)\n                  \
    \                 ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var ret = lst\n    for i :=\
    \ 0; i < len(lst); i++ {\n        for j := 0; j < (i-1); j++ {\n            if\
    \ ret[j] < ret[j+1] {\n                var t = ret[j]\n                ret[j]\
    \ = ret[j+1]\n                ret[j+1] = t\n            }\n        }\n    }\n\
    \    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp0er4fhhx.swift:14:12: error: expected type\n    for i := 0; i <\
    \ len(lst); i++ {\n           ^\n            <#type#>\n/tmp/tmp0er4fhhx.swift:14:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(lst); i++\
    \ {\n           ^\n/tmp/tmp0er4fhhx.swift:14:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 0; i < len(lst); i++ {\n           ^\n/tmp/tmp0er4fhhx.swift:15:16:\
    \ error: expected type\n        for j := 0; j < (i-1); j++ {\n               ^\n\
    \                <#type#>\n/tmp/tmp0er4fhhx.swift:15:16: error: expected 'in'\
    \ after for-each pattern\n        for j := 0; j < (i-1); j++ {\n             \
    \  ^\n/tmp/tmp0er4fhhx.swift:15:16: error: expected Sequence expression for for-each\
    \ loop\n        for j := 0; j < (i-1); j++ {\n               ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  return lst\n    .sorted(by: {\n\
    \      let m = $0\n      let n = $1\n      if n < m {\n        return true\n \
    \     }\n      if m > n {\n        return false\n      }\n      return true\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpu0bwny42/tmpu0bwny42.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab74ca91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab74c788b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab74c788988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab74c7877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu0bwny42                        0x00005617538b7444 <unavailable> + 5188

    5    libc.so.6                          0x00002ab74cc7d460 __libc_start_main +
    245

    6    tmpu0bwny42                        0x00005617538b7039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst as [Int]\n    }\n\n    let maxIndex: Int = lst.count - 1\n\n  \
    \  var result = lst as [Int]\n\n    for i in 0..<maxIndex {\n        if result[i]\
    \ > result[i+1] {\n            result[i], result[i+1] = result[i+1], result[i]\n\
    \        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp413b2y0v.swift:23:22: error: consecutive statements on a line must\
    \ be separated by ';'\n            result[i], result[i+1] = result[i+1], result[i]\n\
    \                     ^\n                     ;\n/tmp/tmp413b2y0v.swift:23:22:\
    \ error: expected expression\n            result[i], result[i+1] = result[i+1],\
    \ result[i]\n                     ^\n/tmp/tmp413b2y0v.swift:23:19: warning: subscript\
    \ is accessed but result is unused\n            result[i], result[i+1] = result[i+1],\
    \ result[i]\n            ~~~~~~^~~\n/tmp/tmp413b2y0v.swift:19:9: warning: variable\
    \ 'result' was never mutated; consider changing to 'let' constant\n    var result\
    \ = lst as [Int]\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    // Sort the array in descending\
    \ order\n    sort.Sort(sort.Reverse(lst))\n    // Return an array with the original\
    \ array in the correct order\n    return lst\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpp_cptr_n.swift:14:5: error: cannot find 'sort' in scope\n    sort.Sort(sort.Reverse(lst))\n\
    \    ^~~~\n/tmp/tmpp_cptr_n.swift:14:15: error: cannot find 'sort' in scope\n\
    \    sort.Sort(sort.Reverse(lst))\n              ^~~~\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    // Create new empty array in\
    \ sorted order.\n    var strange_lst = Array(repeating: 0, count: lst.count)\n\
    \    // Iterate through array and insert elements in correct order.\n    for i\
    \ in 0..<lst.count {\n        strange_lst[i] = min(strange_lst[i], lst[i])\n \
    \       strange_lst[lst.count - 1 - i] = max(strange_lst[lst.count - 1 - i], strange_lst[i])\n\
    \    }\n    return strange_lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpttb1asma/tmpttb1asma.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb33527c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb3321eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb3321e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb3321d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpttb1asma                        0x000055bede08e7b4 <unavailable> + 6068

    5    libc.so.6                          0x00002abb33713460 __libc_start_main +
    245

    6    tmpttb1asma                        0x000055bede08e3a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let result = lst.reduce([Int]()){\
    \ (arr, _) -> [Int] in\n        let m = arr.min()!\n        let m = arr.max()!\n\
    \        let u = arr.min()!\n        arr.append(u)\n        arr.append(m)\n  \
    \      return arr\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpmn2o3geh.swift:17:13: error: cannot use mutating member on immutable\
    \ value: 'arr' is a 'let' constant\n        arr.append(u)\n        ~~~ ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count >= 2 else {\n\
    \        return lst\n    }\n    let sorted = lst.sorted()\n    \n    if sorted.count\
    \ < 2 {\n        return sorted\n    } else {\n        var left = 0\n        var\
    \ right = sorted.count - 1\n        \n        loop {\n            if left == right\
    \ {\n                break\n            }\n            \n            let mid =\
    \ (left + right) / 2.0\n            let element = sorted[mid]\n            \n\
    \            if element <= sorted[left] {\n                right = mid\n     \
    \       } else {\n                left = mid + 1\n            }\n        }\n \
    \       \n        let output = sorted[..(left + 1)]\n        \n        for i in\
    \ right..<sorted.count {\n            output.append(sorted[i])\n        }\n  \
    \      \n        return output\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp97q07niv.swift:24:9: error: cannot find 'loop' in scope\n     \
    \   loop {\n        ^~~~\n/tmp/tmp97q07niv.swift:29:38: error: binary operator\
    \ '/' cannot be applied to operands of type 'Int' and 'Double'\n            let\
    \ mid = (left + right) / 2.0\n                      ~~~~~~~~~~~~~~ ^ ~~~\n/tmp/tmp97q07niv.swift:29:38:\
    \ note: overloads for '/' exist with these partially matching parameter lists:\
    \ (Double, Double), (Duration, Double), (Int, Int)\n            let mid = (left\
    \ + right) / 2.0\n                                     ^\n/tmp/tmp97q07niv.swift:39:29:\
    \ error: cannot find operator '..' in scope; did you mean '...'?\n        let\
    \ output = sorted[..(left + 1)]\n                            ^~\n            \
    \                ...\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted { $0 < $1\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2,\
    \ 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5,\
    \ 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmprmbno6no/tmprmbno6no.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af501b0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af501802b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af501802988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5018017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprmbno6no                        0x0000556aef76c444 <unavailable> + 5188

    5    libc.so.6                          0x00002af501cf7460 __libc_start_main +
    245

    6    tmprmbno6no                        0x0000556aef76c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n    var result: [Int] = []\n    var i = 0\n    var largest\
    \ = lst[0]\n    for value in lst {\n        if value == largest {\n          \
    \  result.append(value)\n        } else {\n            result.append(largest)\n\
    \            result.append(value)\n            largest = value\n        }\n  \
    \      i += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpedow39x9/tmpedow39x9.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7977ae2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b79777d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b79777d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b79777d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpedow39x9                        0x000055fd46272644 <unavailable> + 5700

    5    libc.so.6                          0x00002b7977cce460 __libc_start_main +
    245

    6    tmpedow39x9                        0x000055fd46272239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n\tif lst.isEmpty() {\n\t\treturn\
    \ lst\n\t}\n\n\t// Create first element and rest of list.\n\tvar first: Int =\
    \ lst[0]\n\tvar rest = lst[1..<lst.count]\n\n\t// Find the max value in the rest\
    \ of list.\n\tvar max: Int = rest.reduce(0)(max, {$0 > $1})\n\n\t// Find smallest\
    \ element in the rest of list.\n\tvar min: Int = rest.reduce(0)(min, {$0 < $1})\n\
    \n\t// Swap the first element and max of the rest of list.\n\tfirst, rest = max,\
    \ rest\n\n\t// Swap the min element and first element of the rest of list.\n\t\
    min, rest = first, first\n\n\t// Append max and min to list.\n\trest.append(min),\
    \ rest.append(max)\n\n\t// Return the new list.\n\treturn rest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmph855i6qh.swift:28:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        first, rest = max, rest\n             ^\n     \
    \        ;\n/tmp/tmph855i6qh.swift:28:7: error: expected expression\n        first,\
    \ rest = max, rest\n             ^\n/tmp/tmph855i6qh.swift:13:9: error: cannot\
    \ call value of non-function type 'Bool'\n        if lst.isEmpty() {\n       \
    \        ^      ~~\n                      \n/tmp/tmph855i6qh.swift:22:32: error:\
    \ generic parameter 'T' could not be inferred\n        var max: Int = rest.reduce(0)(max,\
    \ {$0 > $1})\n                                      ^\nSwift.max:1:24: note: in\
    \ call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmph855i6qh.swift:22:29: error:\
    \ missing argument for parameter 'into' in call\n        var max: Int = rest.reduce(0)(max,\
    \ {$0 > $1})\n                                   ^\n                         \
    \          into: <#_#>, \nSwift.Sequence:3:28: note: 'reduce(into:_:)' declared\
    \ here\n    @inlinable public func reduce<Result>(into initialResult: __owned\
    \ Result, _ updateAccumulatingResult: (_ partialResult: inout Result, Self.Element)\
    \ throws -> ()) rethrows -> Result\n                           ^\n/tmp/tmph855i6qh.swift:22:29:\
    \ error: cannot convert value of type 'Int' to expected argument type '(inout\
    \ Result, Int) throws -> ()'\n        var max: Int = rest.reduce(0)(max, {$0 >\
    \ $1})\n                                   ^\n/tmp/tmph855i6qh.swift:25:32: error:\
    \ generic parameter 'T' could not be inferred\n        var min: Int = rest.reduce(0)(min,\
    \ {$0 < $1})\n                                      ^\nSwift.min:1:24: note: in\
    \ call to function 'min'\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmph855i6qh.swift:25:29: error:\
    \ missing argument for parameter 'into' in call\n        var min: Int = rest.reduce(0)(min,\
    \ {$0 < $1})\n                                   ^\n                         \
    \          into: <#_#>, \nSwift.Sequence:3:28: note: 'reduce(into:_:)' decl"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty() {\n      \
    \  return lst\n    }\n\n    var min: Int\n    var max: Int\n    var res: [[Int]]\
    \ = []\n\n    for num in lst {\n        if min == Infinity {\n            min\
    \ = num\n        }\n\n        if max < num {\n            max = num\n        }\n\
    \n        if min > num {\n            res = append(res, Array(repeating: num,\
    \ count: max - min + 1))\n            min = num\n        }\n    }\n\n    return\
    \ res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp6v962o1g.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp6v962o1g.swift:22:19: error: cannot find 'Infinity' in scope\n  \
    \      if min == Infinity {\n                  ^~~~~~~~\n/tmp/tmp6v962o1g.swift:31:19:\
    \ error: cannot find 'append' in scope\n            res = append(res, Array(repeating:\
    \ num, count: max - min + 1))\n                  ^~~~~~\n/tmp/tmp6v962o1g.swift:36:12:\
    \ error: cannot convert return expression of type '[[Int]]' to return type '[Int]'\n\
    \    return res\n           ^\n/tmp/tmp6v962o1g.swift:36:12: note: arguments to\
    \ generic parameter 'Element' ('[Int]' and 'Int') are expected to be equal\n \
    \   return res\n           ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    // Base case when no integers\
    \ are in the list\n    if lst.count == 0 {\n        return lst\n    }\n    var\
    \ lstCopy = lst\n\n    // Sort the list initially using the minimum value\n  \
    \  lstCopy.sort()\n\n    // Find the minimum value in the list to replace minimum\
    \ value in the list\n    var minimum = lstCopy[0]\n    for i in 1..<lstCopy.count\
    \ {\n        if lstCopy[i] < minimum {\n            minimum = lstCopy[i]\n   \
    \     }\n    }\n\n    // Set the minimum value in the list as the last value of\
    \ the list in the list\n    for index in 1..<lstCopy.count {\n        lstCopy[index]\
    \ = minimum\n    }\n\n    return lstCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpwps2qrnt/tmpwps2qrnt.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aecd6eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aecd6bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aecd6bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aecd6baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwps2qrnt                        0x000055e9f5833784 <unavailable> + 6020

    5    libc.so.6                          0x00002aecd70a5460 __libc_start_main +
    245

    6    tmpwps2qrnt                        0x000055e9f5833379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted().reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpfl4bzuj6/tmpfl4bzuj6.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae993be0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9938d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9938d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9938d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfl4bzuj6                        0x000055d401ca84e4 <unavailable> + 5348

    5    libc.so.6                          0x00002ae993dcc460 __libc_start_main +
    245

    6    tmpfl4bzuj6                        0x000055d401ca80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var newList = lst\n    newList.sort()\n\
    \    return newList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmp1jl6nlpt/tmp1jl6nlpt.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4eee5d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4eee2cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4eee2ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4eee2c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1jl6nlpt                        0x000055d30009c4f4 <unavailable> + 5364

    5    libc.so.6                          0x00002b4eee7bf460 __libc_start_main +
    245

    6    tmp1jl6nlpt                        0x000055d30009c0e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    result.sort()\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpp8gomoj0/tmpp8gomoj0.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e012bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e00fb6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e00fb6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e00fb57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp8gomoj0                        0x000055c6336e54f4 <unavailable> + 5364

    5    libc.so.6                          0x00002b2e014ab460 __libc_start_main +
    245

    6    tmpp8gomoj0                        0x000055c6336e50e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count > 0 else {\n\
    \        return lst\n    }\n\n    let min = lst[0]\n    var sorted = lst\n\n \
    \   for idx in 1..<lst.count {\n        if sorted[idx - 1] > min {\n         \
    \   sorted.insert(sorted.last - 1, sorted[idx - 1])\n            sorted.remove(at:\
    \ idx - 1)\n        } else {\n            sorted.insert(sorted[idx - 1], sorted[idx\
    \ - 1])\n            sorted.remove(at: idx)\n        }\n    }\n\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp3zzzv1zs.swift:22:20: error: no exact matches in call to instance\
    \ method 'insert'\n            sorted.insert(sorted.last - 1, sorted[idx - 1])\n\
    \                   ^\n/tmp/tmp3zzzv1zs.swift:22:20: note: candidate has partially\
    \ matching parameter list (__owned Int, at: Int)\n            sorted.insert(sorted.last\
    \ - 1, sorted[idx - 1])\n                   ^\n/tmp/tmp3zzzv1zs.swift:22:20: note:\
    \ candidate has partially matching parameter list (__owned Int, at: Array<Int>.Index)\n\
    \            sorted.insert(sorted.last - 1, sorted[idx - 1])\n               \
    \    ^\n/tmp/tmp3zzzv1zs.swift:22:34: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n            sorted.insert(sorted.last\
    \ - 1, sorted[idx - 1])\n                                 ^\n/tmp/tmp3zzzv1zs.swift:22:34:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            sorted.insert(sorted.last - 1, sorted[idx - 1])\n       \
    \                          ^\n                          (           ?? <#default\
    \ value#>)\n/tmp/tmp3zzzv1zs.swift:22:34: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            sorted.insert(sorted.last\
    \ - 1, sorted[idx - 1])\n                                 ^\n                \
    \                     !\n/tmp/tmp3zzzv1zs.swift:25:20: error: no exact matches\
    \ in call to instance method 'insert'\n            sorted.insert(sorted[idx -\
    \ 1], sorted[idx - 1])\n                   ^\nSwift.Array:11:37: note: incorrect\
    \ labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\nSwift.RangeReplaceableCollection:6:37: note: incorrect\
    \ labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Self.Element, at i: Self.Index)\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted { $0 < $1\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2,\
    \ 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5,\
    \ 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmprmbno6no/tmprmbno6no.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af501b0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af501802b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af501802988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5018017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprmbno6no                        0x0000556aef76c444 <unavailable> + 5188

    5    libc.so.6                          0x00002af501cf7460 __libc_start_main +
    245

    6    tmprmbno6no                        0x0000556aef76c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count > 0 else {\
    \ return lst }\n    return lst.sorted(by: { $0 < $1 }).reversed()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpwxqhxwb9/tmpwxqhxwb9.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e4a7ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e4a4e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e4a4e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e4a4e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwxqhxwb9                        0x000055b3a2057504 <unavailable> + 5380

    5    libc.so.6                          0x00002b4e4a9d7460 __libc_start_main +
    245

    6    tmpwxqhxwb9                        0x000055b3a20570f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n\n    let minValue = lst[0]\n    let maxValue = lst[lst.count\
    \ - 1]\n    var result: [Int] = []\n\n    for i in lst.indices {\n        result.append(minValue)\n\
    \        result.append(maxValue)\n    }\n\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpbpm418y7/tmpbpm418y7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a222f8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a21fefb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a21fef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a21fee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbpm418y7                        0x00005561a1299664 <unavailable> + 5732

    5    libc.so.6                          0x00002b5a224e4460 __libc_start_main +
    245

    6    tmpbpm418y7                        0x00005561a1299259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count > 0 else {\n\
    \        return []\n    }\n    var arr: [Int] = []\n    guard lst.count > 1 else\
    \ {\n        for value in lst {\n            arr.append(value)\n        }\n  \
    \      return arr\n    }\n    let min = lst.minElement()\n    let max = lst.maxElement()\n\
    \    arr.insert(min, at: 0)\n    arr.insert(max, at: 0)\n    for index in 1..<lst.count\
    \ {\n        arr[index] = min\n        arr[arr.count - index] = max\n    }\n \
    \   return arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpm25151l3.swift:23:19: error: value of type '[Int]' has no member\
    \ 'minElement'\n    let min = lst.minElement()\n              ~~~ ^~~~~~~~~~\n\
    /tmp/tmpm25151l3.swift:24:19: error: value of type '[Int]' has no member 'maxElement'\n\
    \    let max = lst.maxElement()\n              ~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    for idx\
    \ in\n        0..<lst.count {\n            switch idx {\n            case 0:\n\
    \                result[0] = lst[idx]\n                idx -= 1\n            case\
    \ 1:\n                result[1] = lst[idx]\n                idx -= 1\n       \
    \     case 2:\n                result[2] = lst[idx]\n                idx -= 1\n\
    \            case 3:\n                result[3] = lst[idx]\n                idx\
    \ -= 1\n            }\n        }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp1aaew7ox.swift:19:21: error: left side of mutating operator isn't\
    \ mutable: 'idx' is a 'let' constant\n                idx -= 1\n             \
    \   ~~~ ^\n/tmp/tmp1aaew7ox.swift:22:21: error: left side of mutating operator\
    \ isn't mutable: 'idx' is a 'let' constant\n                idx -= 1\n       \
    \         ~~~ ^\n/tmp/tmp1aaew7ox.swift:25:21: error: left side of mutating operator\
    \ isn't mutable: 'idx' is a 'let' constant\n                idx -= 1\n       \
    \         ~~~ ^\n/tmp/tmp1aaew7ox.swift:28:21: error: left side of mutating operator\
    \ isn't mutable: 'idx' is a 'let' constant\n                idx -= 1\n       \
    \         ~~~ ^\n/tmp/tmp1aaew7ox.swift:16:13: error: switch must be exhaustive\n\
    \            switch idx {\n            ^\n/tmp/tmp1aaew7ox.swift:16:13: note:\
    \ do you want to add a default clause?\n            switch idx {\n           \
    \ ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count < 2 {\n      \
    \  return lst\n    }\n\n    var newLst = lst // copy lst to newLst\n\n    var\
    \ minVal: Int = newLst[0]\n    var maxVal: Int = newLst[0]\n    var currMin: Int\
    \ = 0\n    var currMax: Int = 0\n\n    for valIndex in 1..lst.count {\n      \
    \  if newLst[valIndex] < minVal {\n            currMin = minVal\n            maxVal\
    \ = newLst[valIndex]\n        } else {\n            currMin = newLst[valIndex]\n\
    \        }\n\n        if newLst[valIndex] > maxVal {\n            currMax = maxVal\n\
    \            minVal = newLst[valIndex]\n        } else {\n            currMax\
    \ = newLst[valIndex]\n        }\n\n        newLst[valIndex] = maxVal\n       \
    \ newLst[currMax] = minVal\n\n        newLst[currMin] = currMax\n        newLst[valIndex]\
    \ = minVal\n    }\n\n    return newLst\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpbv1zqy_6.swift:24:22: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for valIndex in 1..lst.count {\n                  \
    \   ^~\n                     ...\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmphm45yj3x/tmphm45yj3x.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6069ff6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6069cedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6069ced988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6069cec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphm45yj3x                        0x000055da7ad53484 <unavailable> + 5252

    5    libc.so.6                          0x00002b606a1e2460 __libc_start_main +
    245

    6    tmphm45yj3x                        0x000055da7ad53079 <unavailable> + 4217

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let max = lst.max()\n    var\
    \ tmp = [Int](repeating: max, count: lst.count)\n    for (i,j) in lst.enumerated()\
    \ {\n        tmp[i] = j\n    }\n    return tmp\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpm5rrglt0.swift:14:32: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    var tmp = [Int](repeating: max, count:\
    \ lst.count)\n                               ^\n/tmp/tmpm5rrglt0.swift:13:9: note:\
    \ short-circuit using 'guard' to exit this function early if the optional value\
    \ contains 'nil'\n    let max = lst.max()\n        ^\n    guard              \
    \ else { return <#default value#> }\n/tmp/tmpm5rrglt0.swift:13:19: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let max = lst.max()\n                  ^\n                        ?? <#default\
    \ value#>\n/tmp/tmpm5rrglt0.swift:13:19: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n    let max = lst.max()\n  \
    \                ^\n                       !\n/tmp/tmpm5rrglt0.swift:14:32: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    var tmp = [Int](repeating: max, count: lst.count)\n                     \
    \          ^\n                                   ?? <#default value#>\n/tmp/tmpm5rrglt0.swift:14:32:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var tmp = [Int](repeating: max, count: lst.count)\n             \
    \                  ^\n                                  !\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  if lst.count < 2 {\n    return\
    \ lst\n  }\n\n  let minIndex = lst.index(of: lst.min()!)\n  let maxIndex = lst.index(of:\
    \ lst.max()!)\n\n  var sortedList = lst[minIndex..<maxIndex]\n\n  sortedList.reverse()\n\
    \  sortedList.insert(at: sortedList.endIndex, at: lst.min()!)\n  sortedList.insert(at:\
    \ sortedList.endIndex, at: lst.max()!)\n\n  return sortedList\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpstx28uzq.swift:17:22: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n  let minIndex = lst.index(of: lst.min()!)\n         \
    \            ^\n/tmp/tmpstx28uzq.swift:17:22: note: use 'firstIndex(of:)' instead\n\
    \  let minIndex = lst.index(of: lst.min()!)\n                     ^~~~~\n    \
    \                 firstIndex\n/tmp/tmpstx28uzq.swift:18:22: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n  let maxIndex = lst.index(of:\
    \ lst.max()!)\n                     ^\n/tmp/tmpstx28uzq.swift:18:22: note: use\
    \ 'firstIndex(of:)' instead\n  let maxIndex = lst.index(of: lst.max()!)\n    \
    \                 ^~~~~\n                     firstIndex\n/tmp/tmpstx28uzq.swift:20:35:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n  var sortedList\
    \ = lst[minIndex..<maxIndex]\n                                  ^\n/tmp/tmpstx28uzq.swift:18:7:\
    \ note: short-circuit using 'guard' to exit this function early if the optional\
    \ value contains 'nil'\n  let maxIndex = lst.index(of: lst.max()!)\n      ^\n\
    \  guard                                    else { return <#default value#> }\n\
    /tmp/tmpstx28uzq.swift:18:22: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n  let maxIndex = lst.index(of: lst.max()!)\n\
    \                     ^\n                                           ?? <#default\
    \ value#>\n/tmp/tmpstx28uzq.swift:18:22: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n  let maxIndex = lst.index(of:\
    \ lst.max()!)\n                     ^\n                                      \
    \    !\n/tmp/tmpstx28uzq.swift:20:35: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n  var sortedList = lst[minIndex..<maxIndex]\n\
    \                                  ^\n                                  (    \
    \    ?? <#default value#>)\n/tmp/tmpstx28uzq.swift:20:35: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n  var sortedList\
    \ = lst[minIndex..<m"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return []\n    }\n\n    var minItem = Int64(math.MinInt64)\n    var maxItem\
    \ = Int64(math.MaxInt64)\n    var tmp int64\n\n    for i := 0; i < lst.count;\
    \ i++ {\n        if lst[i] < minItem {\n            minItem = lst[i]\n       \
    \ }\n        if lst[i] > maxItem {\n            maxItem = lst[i]\n        }\n\
    \    }\n\n    tmp = minItem\n    minItem = maxItem\n    maxItem = tmp\n\n    var\
    \ result = [Int]()\n    for i := 0; i < lst.count; i++ {\n        if lst[i] >\
    \ minItem {\n            lst[i], lst[lst.index(after: i)] = lst[lst.index(after:\
    \ i)], lst[i]\n            result.append(lst[i])\n        }\n    }\n    result.append(minItem)\n\
    \    result.append(maxItem)\n    result.reverse()\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpsr0ctr8c.swift:19:13: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n    var tmp int64\n\
    \            ^\n/tmp/tmpsr0ctr8c.swift:19:13: note: join the identifiers together\n\
    \    var tmp int64\n        ~~~~^~~~~\n        tmpint64\n/tmp/tmpsr0ctr8c.swift:19:13:\
    \ note: join the identifiers together with camel-case\n    var tmp int64\n   \
    \     ~~~~^~~~~\n        tmpInt64\n/tmp/tmpsr0ctr8c.swift:21:12: error: expected\
    \ type\n    for i := 0; i < lst.count; i++ {\n           ^\n            <#type#>\n\
    /tmp/tmpsr0ctr8c.swift:21:12: error: expected 'in' after for-each pattern\n  \
    \  for i := 0; i < lst.count; i++ {\n           ^\n/tmp/tmpsr0ctr8c.swift:21:12:\
    \ error: expected Sequence expression for for-each loop\n    for i := 0; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmpsr0ctr8c.swift:35:12: error: expected type\n  \
    \  for i := 0; i < lst.count; i++ {\n           ^\n            <#type#>\n/tmp/tmpsr0ctr8c.swift:35:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < lst.count;\
    \ i++ {\n           ^\n/tmp/tmpsr0ctr8c.swift:35:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < lst.count; i++ {\n       \
    \    ^\n/tmp/tmpsr0ctr8c.swift:37:19: error: consecutive statements on a line\
    \ must be separated by ';'\n            lst[i], lst[lst.index(after: i)] = lst[lst.index(after:\
    \ i)], lst[i]\n                  ^\n                  ;\n/tmp/tmpsr0ctr8c.swift:37:19:\
    \ error: expected expression\n            lst[i], lst[lst.index(after: i)] = lst[lst.index(after:\
    \ i)], lst[i]\n                  ^\n/tmp/tmpsr0ctr8c.swift:17:25: error: cannot\
    \ find 'math' in scope\n    var minItem = Int64(math.MinInt64)\n             \
    \           ^~~~\n/tmp/tmpsr0ctr8c.swift:18:25: error: cannot find 'math' in scope\n\
    \    var maxItem = Int64(math.MaxInt64)\n                        ^~~~\n/tmp/tmpsr0ctr8c.swift:19:9:\
    \ error: type annotation missing in pattern\n    var tmp int64\n        ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  let sorted = lst.sorted()\n \
    \ let result = sorted.isEmpty ? lst : sorted\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpego0vl4g/tmpego0vl4g.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b532301fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5322d16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5322d16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5322d157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpego0vl4g                        0x0000563818a2f514 <unavailable> + 5396

    5    libc.so.6                          0x00002b532320b460 __libc_start_main +
    245

    6    tmpego0vl4g                        0x0000563818a2f109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    switch lst.count {\n    case\
    \ 0:\n        return []\n    case 1:\n        return [0]\n    case 2:\n      \
    \  if lst[0] > lst[1] {\n            return [1, lst[1]]\n        } else {\n  \
    \          return [0, lst[0]]\n        }\n    default:\n        var tmp: Int\n\
    \        var i1: Int = 0\n        var i2: Int = 0\n        for i2 = 1; i2 < lst.count;\
    \ i2++ {\n            tmp = lst[i2]\n            if tmp > lst[i1] {\n        \
    \        lst[i1], lst[i2] = lst[i2], lst[i1]\n            }\n            lst[i1\
    \ + 1], lst[i1] = lst[i1], lst[i1 + 1]\n            lst[i2 - 1], lst[i2] = lst[i2],\
    \ lst[i2 - 1]\n            i1 += 1\n        }\n        return lst\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpswidxyz2.swift:28:9: error: C-style for statement has been removed\
    \ in Swift 3\n        for i2 = 1; i2 < lst.count; i2++ {\n        ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpswidxyz2.swift:31:24: error: consecutive statements on a line must be\
    \ separated by ';'\n                lst[i1], lst[i2] = lst[i2], lst[i1]\n    \
    \                   ^\n                       ;\n/tmp/tmpswidxyz2.swift:31:24:\
    \ error: expected expression\n                lst[i1], lst[i2] = lst[i2], lst[i1]\n\
    \                       ^\n/tmp/tmpswidxyz2.swift:33:24: error: consecutive statements\
    \ on a line must be separated by ';'\n            lst[i1 + 1], lst[i1] = lst[i1],\
    \ lst[i1 + 1]\n                       ^\n                       ;\n/tmp/tmpswidxyz2.swift:33:24:\
    \ error: expected expression\n            lst[i1 + 1], lst[i1] = lst[i1], lst[i1\
    \ + 1]\n                       ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    // Sort array from min\
    \ to max with increasing order\n    let minIndex = 0\n    let maxIndex = lst.count\
    \ - 1\n    var sortedArray = lst\n    \n    // Sort by starting with min\n   \
    \ while minIndex != maxIndex {\n        while minIndex < maxIndex && sortedArray[minIndex]\
    \ > sortedArray[minIndex + 1] {\n            sortedArray.remove(at: minIndex +\
    \ 1)\n            minIndex += 1\n        }\n        while minIndex < maxIndex\
    \ && sortedArray[maxIndex] < sortedArray[minIndex] {\n            sortedArray.remove(at:\
    \ maxIndex - 1)\n            maxIndex -= 1\n        }\n    }\n    return sortedArray\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpvhxt3_04.swift:23:22: error: left side of mutating operator isn't\
    \ mutable: 'minIndex' is a 'let' constant\n            minIndex += 1\n       \
    \     ~~~~~~~~ ^\n/tmp/tmpvhxt3_04.swift:15:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let minIndex = 0\n    ^~~\n    var\n/tmp/tmpvhxt3_04.swift:27:22:\
    \ error: left side of mutating operator isn't mutable: 'maxIndex' is a 'let' constant\n\
    \            maxIndex -= 1\n            ~~~~~~~~ ^\n/tmp/tmpvhxt3_04.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let maxIndex = lst.count\
    \ - 1\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpl1jng6kx/tmpl1jng6kx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab61c013c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab61bd0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab61bd0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab61bd097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1jng6kx                        0x00005605f789e3d4 <unavailable> + 5076

    5    libc.so.6                          0x00002ab61c1ff460 __libc_start_main +
    245

    6    tmpl1jng6kx                        0x00005605f789dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660028493
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    for i\
    \ in 0..<len(lst) {\n        let first = result[0]\n        for j in 0..<result.count\
    \ {\n            result[j] = result[j - 1]\n        }\n        result[0] = first\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpyy1huyqq.swift:14:18: error: cannot find 'len' in scope\n    for\
    \ i in 0..<len(lst) {\n                 ^~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result: [Int] = []\n  \
    \  if lst.isEmpty {\n        return result\n    }\n    var first = lst.min(by:\
    \ { $0 < $1 })\n    if first == lst.first {\n        return result\n    }\n  \
    \  var last = lst.max(by: { $0 > $1 })\n    guard last == lst.last else {\n  \
    \      return result\n    }\n\n    var rest = lst.reduce(into: []) {\n       \
    \ if $0 < first {\n            $0[$0] += 1\n        } else {\n            $0.append(0)\n\
    \        }\n    }\n\n    guard rest == lst else {\n        return result\n   \
    \ }\n\n    var index = lst.index(of: first)!\n    var result = strange_sort_list(lst:\
    \ lst.sublist(after: index))\n    result.append(first)\n    for i in 1...lst.count\
    \ {\n        if rest == lst {\n            result += strange_sort_list(lst: lst.sublist(0,\
    \ i))\n        }\n        if lst.index(of: rest[i]) == nil {\n            result.append(rest[i])\n\
    \        } else {\n            if i < lst.index(of: rest[i])! {\n            \
    \    result.append(rest[i])\n            }\n            result += [first]\n  \
    \      }\n    }\n    result.append(last)\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpu3kfihwy.swift:26:37: error: contextual closure type '(inout [Any],\
    \ Int) throws -> ()' expects 2 arguments, but 1 was used in closure body\n   \
    \ var rest = lst.reduce(into: []) {\n                                    ^\n/tmp/tmpu3kfihwy.swift:27:12:\
    \ error: cannot convert value of type '[Any]' to expected argument type 'Int'\n\
    \        if $0 < first {\n           ^\n/tmp/tmpu3kfihwy.swift:27:17: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ if $0 < first {\n                ^\n/tmp/tmpu3kfihwy.swift:27:17: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \     if $0 < first {\n                ^\n                      ?? <#default value#>\n\
    /tmp/tmpu3kfihwy.swift:27:17: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        if $0 < first {\n            \
    \    ^\n                     !\n/tmp/tmpu3kfihwy.swift:38:31: error: value of\
    \ optional type 'Int?' must be unwrapped to a value of type 'Int'\n    var index\
    \ = lst.index(of: first)!\n                              ^\n/tmp/tmpu3kfihwy.swift:38:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    var index = lst.index(of: first)!\n                             \
    \ ^\n                                    ?? <#default value#>\n/tmp/tmpu3kfihwy.swift:38:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    var index = lst.index(of: first)!\n                             \
    \ ^\n                                   !\n/tmp/tmpu3kfihwy.swift:39:45: error:\
    \ value of type '[Int]' has no member 'sublist'\n    var result = strange_sort_list(lst:\
    \ lst.sublist(after: index))\n                                        ~~~ ^~~~~~~\n\
    /tmp/tmpu3kfihwy.swift:43:50: error: value of type '[Int]' has no member 'sublist'\n\
    \            result += strange_sort_list(lst: lst.sublist(0, i))\n           \
    \                                  ~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return []\n    }\n    var list = lst\n    list.removeFirst()\n    return strange_sort_list(list)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpyd2d01gl.swift:18:30: error: missing argument label 'lst:' in call\n\
    \    return strange_sort_list(list)\n                             ^\n        \
    \                     lst: \n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var ret = [Int]()\n    for\
    \ element in lst {\n        if element > ret {\n            ret.append(element)\n\
    \        }\n        if element < ret {\n            ret.remove(element)\n    \
    \    }\n    }\n    return ret\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpfi8jl8r4.swift:15:22: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if element > ret {\n              \
    \       ^\n/tmp/tmpfi8jl8r4.swift:18:22: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n        if element < ret {\n              \
    \       ^\n/tmp/tmpfi8jl8r4.swift:19:17: error: no exact matches in call to instance\
    \ method 'remove'\n            ret.remove(element)\n                ^\nSwift.Array:10:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(at:)')\n   \
    \ @inlinable public mutating func remove(at index: Int) -> Element\n         \
    \                           ^\nSwift.RangeReplaceableCollection:9:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(at:)')\n    @inlinable public\
    \ mutating func remove(at position: Self.Index) -> Self.Element\n            \
    \                        ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty() {\n      \
    \  return lst\n    }\n    // initialize first value\n    let min = lst[0]\n  \
    \  var lst2 = []\n\n    // initialize second value\n    let max = 0\n    for index\
    \ in 0..<lst.count {\n        // increment max as you move through the list\n\
    \        max = max > lst[index] ? max : lst[index]\n\n        // if max is now\
    \ greater than min, add max to new list\n        if max > min {\n            lst2.append(max)\n\
    \            max = lst[index]\n        }\n\n        // if max is now greater than\
    \ min and less than max,\n        // then add min to new list\n        if max\
    \ < min && max > lst[index] {\n            lst2.append(min)\n            min =\
    \ lst[index]\n        }\n    }\n    lst2.append(max)\n    return lst2\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp29ajm4zr.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmp29ajm4zr.swift:18:16: error: empty collection literal requires an\
    \ explicit type\n    var lst2 = []\n               ^~\n/tmp/tmp29ajm4zr.swift:24:9:\
    \ error: cannot assign to value: 'max' is a 'let' constant\n        max = max\
    \ > lst[index] ? max : lst[index]\n        ^~~\n/tmp/tmp29ajm4zr.swift:21:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let max = 0\n    ^~~\n    var\n\
    /tmp/tmp29ajm4zr.swift:29:13: error: cannot assign to value: 'max' is a 'let'\
    \ constant\n            max = lst[index]\n            ^~~\n/tmp/tmp29ajm4zr.swift:21:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = 0\n    ^~~\n \
    \   var\n/tmp/tmp29ajm4zr.swift:36:13: error: cannot assign to value: 'min' is\
    \ a 'let' constant\n            min = lst[index]\n            ^~~\n/tmp/tmp29ajm4zr.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = lst[0]\n    ^~~\n\
    \    var\n/tmp/tmp29ajm4zr.swift:40:12: error: cannot convert return expression\
    \ of type '[Any]' to return type '[Int]'\n    return lst2\n           ^\n/tmp/tmp29ajm4zr.swift:40:12:\
    \ note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected\
    \ to be equal\n    return lst2\n           ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var sorted = []\n    var max\
    \ = lst[0]\n    for e in lst {\n        if e > max {\n            max = e\n  \
    \      }\n    }\n    for e in lst {\n        if e < max {\n            sorted.append(max)\n\
    \            max = e\n        } else {\n            sorted.append(e)\n       \
    \ }\n    }\n    return sorted as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpmxr67b2h.swift:13:18: error: empty collection literal requires\
    \ an explicit type\n    var sorted = []\n                 ^~\n/tmp/tmpmxr67b2h.swift:28:19:\
    \ error: cannot convert value of type '[Any]' to type '[Int]' in coercion\n  \
    \  return sorted as [Int]\n                  ^\n/tmp/tmpmxr67b2h.swift:28:19:\
    \ note: arguments to generic parameter 'Element' ('Any' and 'Int') are expected\
    \ to be equal\n    return sorted as [Int]\n                  ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  var arr = [Int]()\n  var min\
    \ = lst[0]\n  var max = lst[0]\n  for el in lst {\n    if el < min {\n      min\
    \ = el\n    } else if el > max {\n      max = el\n    } else {\n      arr.append(el)\n\
    \    }\n  }\n  for i in 0..<arr.count {\n    if arr[i] < min {\n      arr[i] =\
    \ min\n    } else if arr[i] > max {\n      arr[i] = max\n    }\n  }\n  return\
    \ arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpljpi6vij/tmpljpi6vij.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2de10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab2db07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab2db07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab2db067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpljpi6vij                        0x000055de4344f874 <unavailable> + 6260

    5    libc.so.6                          0x00002aab2dffc460 __libc_start_main +
    245

    6    tmpljpi6vij                        0x000055de4344f469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let min = lst[0]\n    var res\
    \ = Array(repeating: Int.max, count: lst.count)\n    for elem in lst {\n     \
    \   if elem < min {\n            for idx in 1..lst.count {\n                res[idx]\
    \ = elem\n            }\n        } else {\n            for idx in 1..lst.count\
    \ {\n                if elem < res[idx] {\n                    res[idx] = elem\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return res as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp_syprpoh.swift:17:25: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n            for idx in 1..lst.count {\n               \
    \         ^~\n                        ...\n/tmp/tmp_syprpoh.swift:21:25: error:\
    \ cannot find operator '..' in scope; did you mean '...'?\n            for idx\
    \ in 1..lst.count {\n                        ^~\n                        ...\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    guard lst.count > 0 else\
    \ {\n        return lst\n    }\n    \n    let startIndex = lst.index(lst.min())!\n\
    \    let endIndex = lst.index(lst.max()!)!\n    \n    let startArray = strange_sort_list(lst.prefix(startIndex))\n\
    \    let endArray = strange_sort_list(lst.suffix(endIndex))\n    \n    return\
    \ startArray + lst.prefix(startIndex) + endArray + lst.suffix(endIndex)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpey4l_t6y.swift:18:32: error: missing argument label 'of:' in call\n\
    \    let startIndex = lst.index(lst.min())!\n                               ^\n\
    \                               of: \n/tmp/tmpey4l_t6y.swift:18:36: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n    let\
    \ startIndex = lst.index(lst.min())!\n                                   ^\n/tmp/tmpey4l_t6y.swift:18:36:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let startIndex = lst.index(lst.min())!\n                        \
    \           ^\n                                         ?? <#default value#>\n\
    /tmp/tmpey4l_t6y.swift:18:36: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    let startIndex = lst.index(lst.min())!\n\
    \                                   ^\n                                      \
    \  !\n/tmp/tmpey4l_t6y.swift:19:30: error: missing argument label 'of:' in call\n\
    \    let endIndex = lst.index(lst.max()!)!\n                             ^\n \
    \                            of: \n/tmp/tmpey4l_t6y.swift:21:51: error: missing\
    \ argument label 'while:' in call\n    let startArray = strange_sort_list(lst.prefix(startIndex))\n\
    \                                                  ^\n                       \
    \                           while: \n/tmp/tmpey4l_t6y.swift:21:40: error: missing\
    \ argument label 'lst:' in call\n    let startArray = strange_sort_list(lst.prefix(startIndex))\n\
    \                                       ^\n                                  \
    \     lst: \n/tmp/tmpey4l_t6y.swift:22:38: error: missing argument label 'lst:'\
    \ in call\n    let endArray = strange_sort_list(lst.suffix(endIndex))\n      \
    \                               ^\n                                     lst: \n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var lstCopy = lst\n    var\
    \ result = [Int]()\n    var min: Int = 0\n    var max: Int = 0\n\n    for n in\
    \ lstCopy {\n        if min == 0 {\n            min = n\n        } else {\n  \
    \          if min > n {\n                max = n\n            }\n        }\n \
    \   }\n\n    for n in lstCopy {\n        if n == max {\n            result.append(max)\n\
    \            max = min - 1\n        } else {\n            result.append((min <\
    \ n) ? min : n)\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpbbe9hwx0/tmpbbe9hwx0.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f88797c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f8848eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f8848e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f8848d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbbe9hwx0                        0x000055f9da7ed5f4 <unavailable> + 5620

    5    libc.so.6                          0x00002b8f88983460 __libc_start_main +
    245

    6    tmpbbe9hwx0                        0x000055f9da7ed1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count < 2 {\n      \
    \  return lst\n    }\n    var minIdx = 0\n    var maxIdx = lst.count - 1\n\n \
    \   var sortedIdx = 1\n    while sortedIdx < lst.count {\n        if lst[sortedIdx]\
    \ > lst[minIdx] {\n            minIdx = sortedIdx\n        }\n        if lst[sortedIdx]\
    \ < lst[maxIdx] {\n            maxIdx = sortedIdx\n        }\n        sortedIdx\
    \ += 1\n    }\n    var lst2 = lst[minIdx..<maxIdx] + lst[minIdx..<maxIdx] + lst[minIdx..<maxIdx]\
    \ + lst[minIdx..<maxIdx]\n    return lst2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpzlhh0r3s.swift:30:12: error: cannot convert return expression of\
    \ type 'ArraySlice<Int>' to return type '[Int]'\n    return lst2\n           ^~~~\n"
  stdout: ''
  timestamp: 1660028660
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var r: [Int] = lst + [0]\n\
    \    var i = 0\n    var j = 0\n    var temp: Int\n    for i < r.count {\n    \
    \    if i == 0 {\n            r[i] = r[j]\n            i += 1\n        }\n   \
    \     if r[i] > r[j] {\n            temp = r[i]\n            r[i] = r[j]\n   \
    \         r[j] = temp\n            i += 1\n        } else {\n            j +=\
    \ 1\n        }\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpnw_mlj5w.swift:17:11: error: expected 'in' after for-each pattern\n\
    \    for i < r.count {\n          ^\n/tmp/tmpnw_mlj5w.swift:17:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < r.count {\n     \
    \     ^~\n           \n/tmp/tmpnw_mlj5w.swift:17:11: error: '<' is not a prefix\
    \ unary operator\n    for i < r.count {\n          ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  \n    var min = Int.max\n   \
    \ var max = Int.min\n    \n    for index in lst {\n        if index < min {\n\
    \            min = index\n        } else if index > max {\n            max = index\n\
    \        }\n    }\n    \n    var result = [Int]()\n    \n    for i in 0 ..< lst.count\
    \ {\n        if min <= lst[i] && lst[i] <= max {\n            result.insert(lst[i],\
    \ at: i)\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmp13gxquwe/tmp13gxquwe.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa91d2bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa91a22b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa91a22988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa91a217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp13gxquwe                        0x0000565089e5f824 <unavailable> + 6180

    5    libc.so.6                          0x00002baa91f17460 __libc_start_main +
    245

    6    tmp13gxquwe                        0x0000565089e5f419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return []\n    }\n\n    let min_idx = lst.index(minElement(lst, defaultVal:\
    \ 0))\n    let max_idx = lst.index(maxElement(lst, defaultVal: 0))\n    var rest\
    \ = lst[max_idx..<lst.count]\n\n    // Swap minimum element with maximum\n   \
    \ swap(&lst[min_idx..<lst.count], &lst[max_idx..<lst.count])\n\n    // Sort the\
    \ rest and put it back together with minimum at the end\n    let sorted_rest =\
    \ strange_sort_list(rest)\n    append(sorted_rest, min_idx)\n    return lst\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp14jejf8n.swift:17:29: error: cannot find 'minElement' in scope\n\
    \    let min_idx = lst.index(minElement(lst, defaultVal: 0))\n               \
    \             ^~~~~~~~~~\n/tmp/tmp14jejf8n.swift:17:23: error: no exact matches\
    \ in call to instance method 'index'\n    let min_idx = lst.index(minElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp/tmp14jejf8n.swift:17:23: note:\
    \ found candidate with type '(Int) -> Int'\n    let min_idx = lst.index(minElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp/tmp14jejf8n.swift:17:23: note:\
    \ found candidate with type '(Int) -> Int'\n    let min_idx = lst.index(minElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp/tmp14jejf8n.swift:17:23: note:\
    \ found candidate with type '((Int) throws -> Bool) throws -> Array<Int>.Index?'\
    \ (aka '((Int) throws -> Bool) throws -> Optional<Int>')\n    let min_idx = lst.index(minElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp/tmp14jejf8n.swift:17:23: note:\
    \ found candidate with type '(Int) -> Array<Int>.Index?' (aka '(Int) -> Optional<Int>')\n\
    \    let min_idx = lst.index(minElement(lst, defaultVal: 0))\n               \
    \       ^\n/tmp/tmp14jejf8n.swift:18:29: error: cannot find 'maxElement' in scope\n\
    \    let max_idx = lst.index(maxElement(lst, defaultVal: 0))\n               \
    \             ^~~~~~~~~~\n/tmp/tmp14jejf8n.swift:18:23: error: no exact matches\
    \ in call to instance method 'index'\n    let max_idx = lst.index(maxElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp/tmp14jejf8n.swift:18:23: note:\
    \ found candidate with type '(Int) -> Int'\n    let max_idx = lst.index(maxElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp/tmp14jejf8n.swift:18:23: note:\
    \ found candidate with type '(Int) -> Int'\n    let max_idx = lst.index(maxElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp/tmp14jejf8n.swift:18:23: note:\
    \ found candidate with type '((Int) throws -> Bool) throws -> Array<Int>.Index?'\
    \ (aka '((Int) throws -> Bool) throws -> Optional<Int>')\n    let max_idx = lst.index(maxElement(lst,\
    \ defaultVal: 0))\n                      ^\n/tmp"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var res = lst\n    if res ==\
    \ nil {\n        return [] as [Int]\n    }\n\n    var minv = Int.max\n    var\
    \ maxv = Int.min\n    for x in res {\n        if x > maxv {\n            maxv\
    \ = x\n        } else if x < minv {\n            minv = x\n        }\n    }\n\n\
    \    var midv = minv\n    for x in res {\n        if x > midv {\n            for\
    \ y in res {\n                if y > midv && y != x {\n                    midv\
    \ = y\n                }\n            }\n        } else {\n            for y in\
    \ res {\n                if y > maxv && y != x {\n                    maxv = y\n\
    \                }\n            }\n        }\n    }\n\n    if minv == maxv {\n\
    \        return res as [Int]\n    }\n\n    var tmpv = minv\n    for x in res {\n\
    \        if x > tmpv {\n            tmpv = x\n        }\n    }\n\n    res = []\n\
    \    for x in res {\n        if x == tmpv {\n            res.append(x)\n     \
    \   } else {\n            res.insert(x, at: 0)\n        }\n    }\n\n    return\
    \ res as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmp6_g4udro/tmp6_g4udro.swift:81: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae968c8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae968986b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae968986988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9689857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6_g4udro                        0x000055e33a9645f4 <unavailable> + 5620

    5    libc.so.6                          0x00002ae968e7b460 __libc_start_main +
    245

    6    tmp6_g4udro                        0x000055e33a9641e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted { $0 < $1\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2,\
    \ 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5,\
    \ 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmprmbno6no/tmprmbno6no.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af501b0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af501802b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af501802988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5018017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprmbno6no                        0x0000556aef76c444 <unavailable> + 5188

    5    libc.so.6                          0x00002af501cf7460 __libc_start_main +
    245

    6    tmprmbno6no                        0x0000556aef76c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty() {\n      \
    \  return lst\n    }\n\n    var result = lst\n    \n    for idx in\n        stride(from:\
    \ 0, to: lst.count, by: -1)\n    {\n        if lst.contains(result[idx]) {\n \
    \           result.removeSubrange(idx, 1)\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpqrra156z.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpqrra156z.swift:23:40: error: extra argument in call\n           \
    \ result.removeSubrange(idx, 1)\n                                 ~~~~~~^~\n/tmp/tmpqrra156z.swift:23:35:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Range<Array<Int>.Index>'\
    \ (aka 'Range<Int>')\n            result.removeSubrange(idx, 1)\n            \
    \                      ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var min: Int? = nil\n    var\
    \ max: Int? = nil\n\n    if lst.count > 0 {\n        // Find the smallest value.\n\
    \        minValue = min(lst)\n        max = max(lst)\n\n        // Swap the smallest\
    \ and largest values.\n        // This moves the largest value to the front.\n\
    \        if let _ = min {\n            min = max\n            max = nil\n    \
    \    }\n\n        // Now sort both min and max.\n        if let minValue = minValue\
    \ {\n            if min > minValue {\n                swap(&min, &minValue)\n\
    \            }\n        }\n        if let maxValue = max {\n            if max\
    \ < maxValue {\n                swap(&max, &maxValue)\n            }\n       \
    \ }\n    }\n\n    // Now return min and max as one array.\n    let min = minValue\n\
    \    let max = maxValue\n    return (minValue: min, maxValue: max)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpwuqr5g47.swift:18:9: error: cannot find 'minValue' in scope\n \
    \       minValue = min(lst)\n        ^~~~~~~~\n/tmp/tmpwuqr5g47.swift:18:20: error:\
    \ cannot call value of non-function type 'Int?'\n        minValue = min(lst)\n\
    \                   ^\n/tmp/tmpwuqr5g47.swift:19:15: error: cannot call value\
    \ of non-function type 'Int?'\n        max = max(lst)\n              ^\n/tmp/tmpwuqr5g47.swift:29:27:\
    \ error: cannot find 'minValue' in scope\n        if let minValue = minValue {\n\
    \                          ^~~~~~~~\n/tmp/tmpwuqr5g47.swift:30:16: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \     if min > minValue {\n               ^\n/tmp/tmpwuqr5g47.swift:30:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \            if min > minValue {\n               ^\n                   ?? <#default\
    \ value#>\n/tmp/tmpwuqr5g47.swift:30:16: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n            if min > minValue\
    \ {\n               ^\n                  !\n/tmp/tmpwuqr5g47.swift:35:16: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \           if max < maxValue {\n               ^\n/tmp/tmpwuqr5g47.swift:35:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            if max < maxValue {\n               ^\n                 \
    \  ?? <#default value#>\n/tmp/tmpwuqr5g47.swift:35:16: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            if\
    \ max < maxValue {\n               ^\n                  !\n/tmp/tmpwuqr5g47.swift:36:28:\
    \ error: inout argument could be set to a value with a type other than 'Int';\
    \ use a value declared as type 'Int?' instead\n                swap(&max, &maxValue)\n\
    \                           ^\n/tmp/tmpwuqr5g47.swift:36:28: error: cannot pass\
    \ immutable value as inout argument: 'maxValue' is a 'let' constant\n        \
    \        swap(&max, &maxValue)\n                           ^~~~~~~~~\n/tmp/tmpwuqr5g47.swift:42:15:\
    \ error: "
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int]()\n    var\
    \ min = Int(math.max(1, lst[0]))\n    var max = Int(math.min(lst.last, 1))\n \
    \   for x in lst {\n        if x < min {\n            min = x\n        } else\
    \ if x > max {\n            max = x\n        }\n    }\n    for x in lst {\n  \
    \      if x == min {\n            result.insert(min, x)\n            result.insert(x,\
    \ max)\n        } else {\n            result.insert(x, min)\n            result.insert(max,\
    \ x)\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp0dhbkaf1.swift:14:19: error: cannot find 'math' in scope\n    var\
    \ min = Int(math.max(1, lst[0]))\n                  ^~~~\n/tmp/tmp0dhbkaf1.swift:15:19:\
    \ error: cannot find 'math' in scope\n    var max = Int(math.min(lst.last, 1))\n\
    \                  ^~~~\n/tmp/tmp0dhbkaf1.swift:25:20: error: no exact matches\
    \ in call to instance method 'insert'\n            result.insert(min, x)\n   \
    \                ^\n/tmp/tmp0dhbkaf1.swift:25:20: note: found candidate with type\
    \ '(__owned Int, Int) -> ()'\n            result.insert(min, x)\n            \
    \       ^\n/tmp/tmp0dhbkaf1.swift:26:20: error: no exact matches in call to instance\
    \ method 'insert'\n            result.insert(x, max)\n                   ^\n/tmp/tmp0dhbkaf1.swift:26:20:\
    \ note: found candidate with type '(__owned Int, Int) -> ()'\n            result.insert(x,\
    \ max)\n                   ^\n/tmp/tmp0dhbkaf1.swift:28:20: error: no exact matches\
    \ in call to instance method 'insert'\n            result.insert(x, min)\n   \
    \                ^\n/tmp/tmp0dhbkaf1.swift:28:20: note: found candidate with type\
    \ '(__owned Int, Int) -> ()'\n            result.insert(x, min)\n            \
    \       ^\n/tmp/tmp0dhbkaf1.swift:29:20: error: no exact matches in call to instance\
    \ method 'insert'\n            result.insert(max, x)\n                   ^\n/tmp/tmp0dhbkaf1.swift:29:20:\
    \ note: found candidate with type '(__owned Int, Int) -> ()'\n            result.insert(max,\
    \ x)\n                   ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count <= 1 {\n     \
    \   return lst\n    }\n\n    var lst1 = lst\n    var lst2 = lst1\n    var lst3\
    \ = lst1\n\n    var min = lst2[0]\n    for val in lst2 {\n        if val < min\
    \ {\n            min = val\n        }\n    }\n    for val in lst3 {\n        if\
    \ val < min {\n            lst1 = lst2\n            lst2 = lst3\n            lst3\
    \ = lst\n            lst = lst1\n            lst[0] = min\n            break\n\
    \        }\n    }\n    for val in lst3 {\n        if val > min {\n           \
    \ lst1 = lst2\n            lst2 = lst3\n            lst3 = lst\n            lst\
    \ = lst1\n            lst[0] = max\n            break\n        }\n    }\n    for\
    \ val in lst3 {\n        if val > min {\n            lst1 = lst2\n           \
    \ lst2 = lst3\n            lst3 = lst\n            lst = lst1\n            lst[0]\
    \ = min\n            break\n        }\n    }\n    for val in lst3 {\n        if\
    \ val < min {\n            lst1 = lst2\n            lst2 = lst3\n            lst3\
    \ = lst\n            lst = lst1\n            lst[0] = max\n            break\n\
    \        }\n    }\n    for val in lst3 {\n        if val > min {\n           \
    \ lst1 = lst2\n            lst2 = lst3\n            lst3 = lst\n            lst\
    \ = lst1\n            lst[0] = min\n            break\n        }\n    }\n\n  \
    \  return lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpzzjn179m.swift:32:13: error: cannot assign to value: 'lst' is a\
    \ 'let' constant\n            lst = lst1\n            ^~~\n/tmp/tmpzzjn179m.swift:33:16:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n        \
    \    lst[0] = min\n            ~~~^\n/tmp/tmpzzjn179m.swift:42:13: error: cannot\
    \ assign to value: 'lst' is a 'let' constant\n            lst = lst1\n       \
    \     ^~~\n/tmp/tmpzzjn179m.swift:43:22: error: generic parameter 'T' could not\
    \ be inferred\n            lst[0] = max\n                     ^\nSwift.max:1:24:\
    \ note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T) -> T where T : Comparable\n                       ^\n/tmp/tmpzzjn179m.swift:43:16:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n        \
    \    lst[0] = max\n            ~~~^\n/tmp/tmpzzjn179m.swift:43:22: error: no 'max'\
    \ candidates produce the expected contextual result type 'Int'\n            lst[0]\
    \ = max\n                     ^\nSwift.max:1:24: note: 'max' produces '(T, T)\
    \ -> T', not the expected contextual result type 'Int'\n@inlinable public func\
    \ max<T>(_ x: T, _ y: T) -> T where T : Comparable\n                       ^\n\
    Swift.max:1:24: note: 'max' produces '(T, T, T, T...) -> T', not the expected\
    \ contextual result type 'Int'\n@inlinable public func max<T>(_ x: T, _ y: T,\
    \ _ z: T, _ rest: T...) -> T where T : Comparable\n                       ^\n\
    /tmp/tmpzzjn179m.swift:52:13: error: cannot assign to value: 'lst' is a 'let'\
    \ constant\n            lst = lst1\n            ^~~\n/tmp/tmpzzjn179m.swift:53:16:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n        \
    \    lst[0] = min\n            ~~~^\n/tmp/tmpzzjn179m.swift:62:13: error: cannot\
    \ assign to value: 'lst' is a 'let' constant\n            lst = lst1\n       \
    \     ^~~\n/tmp/tmpzzjn179m.swift:63:22: error: generic parameter 'T' could not\
    \ be inferred\n            lst[0] = max\n                     ^\nSwift.max:1:24:\
    \ note: in call to function 'max'\n@inlinable public func max<T>(_ x: T, _ y:\
    \ T) -> T where T : Comparable\n                       ^\n/tmp/t"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard !lst.isEmpty else { return\
    \ lst }\n    guard lst.count > 1 else { return lst }\n\n    let minI = lst.index(of:\
    \ lst.min()!)\n    let maxI = lst.index(of: lst.max()!)\n\n    var list = lst\n\
    \    let start = minI < maxI ? minI : maxI\n    var end = minI\n    var i = start\n\
    \    while i < maxI {\n        list.append(list.swapAt(i, end))\n        end =\
    \ i + 1\n        i += 1\n    }\n    return list\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpyq266_af.swift:16:20: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let minI = lst.index(of: lst.min()!)\n           \
    \        ^\n/tmp/tmpyq266_af.swift:16:20: note: use 'firstIndex(of:)' instead\n\
    \    let minI = lst.index(of: lst.min()!)\n                   ^~~~~\n        \
    \           firstIndex\n/tmp/tmpyq266_af.swift:17:20: warning: 'index(of:)' is\
    \ deprecated: renamed to 'firstIndex(of:)'\n    let maxI = lst.index(of: lst.max()!)\n\
    \                   ^\n/tmp/tmpyq266_af.swift:17:20: note: use 'firstIndex(of:)'\
    \ instead\n    let maxI = lst.index(of: lst.max()!)\n                   ^~~~~\n\
    \                   firstIndex\n/tmp/tmpyq266_af.swift:20:17: error: value of\
    \ optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to\
    \ a value of type 'Array<Int>.Index' (aka 'Int')\n    let start = minI < maxI\
    \ ? minI : maxI\n                ^\n/tmp/tmpyq266_af.swift:20:17: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let start = minI < maxI ? minI : maxI\n                ^\n                 \
    \    ?? <#default value#>\n/tmp/tmpyq266_af.swift:20:17: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n    let start =\
    \ minI < maxI ? minI : maxI\n                ^\n                    !\n/tmp/tmpyq266_af.swift:20:24:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    let start\
    \ = minI < maxI ? minI : maxI\n                       ^\n/tmp/tmpyq266_af.swift:20:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let start = minI < maxI ? minI : maxI\n                       ^\n\
    \                            ?? <#default value#>\n/tmp/tmpyq266_af.swift:20:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let start = minI < maxI ? minI : maxI\n                       ^\n\
    \                           !\n/tmp/tmpyq266_af.swift:23:15: error: value of optional\
    \ type 'Array<Int>.Index?' (ak"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n    let min = lst[0]\n    for i in 1..<lst.count {\n  \
    \      if lst[i] < min {\n            min = lst[i]\n        }\n    }\n    \n \
    \   var sorted: [Int] = []\n    for i in 0..<lst.count {\n        if lst[i] >=\
    \ min {\n            sorted = sorted + [lst[i]]\n        }\n    }\n    sorted\
    \ = sorted + [min]\n    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpz2hly6r9.swift:19:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = lst[i]\n            ^~~\n/tmp/tmpz2hly6r9.swift:16:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = lst[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var lstCopy = lst\n    for\
    \ i = 1; i < lst.count; i++ {\n        for j = i; j > 0; j-- {\n            if\
    \ lst[j] < lst[j-1] {\n                let temp = lstCopy[j]\n               \
    \ lstCopy[j] = lst[j-1]\n                lst[j-1] = temp\n            }\n    \
    \    }\n    }\n    return lstCopy\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpamhky7k1.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = 1; i < lst.count; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpamhky7k1.swift:15:9: error: C-style for statement has been removed in\
    \ Swift 3\n        for j = i; j > 0; j-- {\n        ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmpamhky7k1.swift:17:36:\
    \ error: cannot find 'j' in scope\n                let temp = lstCopy[j]\n   \
    \                                ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int]()\n\n  \
    \  if lst.count == 0 {\n        return result\n    }\n\n    for i : Int in  lst\
    \ {\n        let idx = lst.index(of: i)\n        result.insert(idx, at: 0)\n \
    \   }\n\n    result.sortInPlace()\n\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpou1a18er.swift:20:23: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        let idx = lst.index(of: i)\n                 \
    \     ^\n/tmp/tmpou1a18er.swift:20:23: note: use 'firstIndex(of:)' instead\n \
    \       let idx = lst.index(of: i)\n                      ^~~~~\n            \
    \          firstIndex\n/tmp/tmpou1a18er.swift:21:23: error: value of optional\
    \ type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Int>.Index' (aka 'Int')\n        result.insert(idx, at: 0)\n\
    \                      ^\n/tmp/tmpou1a18er.swift:20:13: note: short-circuit using\
    \ 'guard' to exit this function early if the optional value contains 'nil'\n \
    \       let idx = lst.index(of: i)\n            ^\n        guard             \
    \         else { return <#default value#> }\n/tmp/tmpou1a18er.swift:20:23: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        let idx = lst.index(of: i)\n                      ^\n               \
    \                    ?? <#default value#>\n/tmp/tmpou1a18er.swift:20:23: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \        let idx = lst.index(of: i)\n                      ^\n               \
    \                   !\n/tmp/tmpou1a18er.swift:21:23: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        result.insert(idx,\
    \ at: 0)\n                      ^\n                          ?? <#default value#>\n\
    /tmp/tmpou1a18er.swift:21:23: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        result.insert(idx, at: 0)\n  \
    \                    ^\n                         !\n/tmp/tmpou1a18er.swift:24:12:\
    \ error: value of type '[Int]' has no member 'sortInPlace'\n    result.sortInPlace()\n\
    \    ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    // find the min\n    var min\
    \ = lst[0]\n    for idx in lst {\n        if min > idx {\n            min = idx\n\
    \        }\n    }\n\n    // find the max\n    var max = lst[0]\n    for idx in\
    \ lst {\n        if max < idx {\n            max = idx\n        }\n    }\n\n \
    \   // swap min and max\n    for idx in lst {\n        if min < idx {\n      \
    \      lst[idx], lst[min] = lst[min], lst[idx]\n        }\n    }\n\n    return\
    \ lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpja14h5i6.swift:32:21: error: consecutive statements on a line must\
    \ be separated by ';'\n            lst[idx], lst[min] = lst[min], lst[idx]\n \
    \                   ^\n                    ;\n/tmp/tmpja14h5i6.swift:32:21: error:\
    \ expected expression\n            lst[idx], lst[min] = lst[min], lst[idx]\n \
    \                   ^\n/tmp/tmpja14h5i6.swift:32:16: warning: expression of type\
    \ 'Int' is unused\n            lst[idx], lst[min] = lst[min], lst[idx]\n     \
    \       ~~~^~~~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var res = lst\n    \n    let\
    \ minValue = min(lst)\n    \n    for i in 0..<res.count {\n        if res[i] <\
    \ minValue {\n            swap(&res[i], &res[res.count - 1 - i])\n        }\n\
    \    }\n    \n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpg8vcdxa3.swift:15:27: error: missing argument for parameter #2\
    \ in call\n    let minValue = min(lst)\n                          ^\n        \
    \                  , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var sortedList = lst\n    var\
    \ largestIndex = sortedList.count - 1\n    var nextIndex = largestIndex\n    while\
    \ nextIndex >= 0 {\n        sortedList[nextIndex] = sortedList[largestIndex]\n\
    \        largestIndex -= 1\n        nextIndex -= 1\n    }\n    return sortedList\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpmxlx9yns/tmpmxlx9yns.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b05fdb51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b05fd848b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b05fd848988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b05fd8477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmxlx9yns                        0x0000558efd5fe4d4 <unavailable> + 5332

    5    libc.so.6                          0x00002b05fdd3d460 __libc_start_main +
    245

    6    tmpmxlx9yns                        0x0000558efd5fe0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var min: Int = 0\n    var max:\
    \ Int = 0\n    for x in lst {\n        if min > x {\n            min = x\n   \
    \     } else if max < x {\n            max = x\n        }\n    }\n    guard min\
    \ <= max else { return lst }\n    let lower = min\n    let upper = max\n    var\
    \ tmp = min\n    while tmp != max && tmp != lower {\n        lst[lower] = lst[upper]\n\
    \        lst[upper] = tmp\n        lower = (lower + 1) % lst.count\n        upper\
    \ = (upper + 2) % lst.count\n        tmp = lower\n    }\n    lst[lower] = lst[upper]\n\
    \    return lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpu0u9qs0z.swift:27:12: error: cannot assign through subscript: 'lst'\
    \ is a 'let' constant\n        lst[lower] = lst[upper]\n        ~~~^\n/tmp/tmpu0u9qs0z.swift:28:12:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n        lst[upper]\
    \ = tmp\n        ~~~^\n/tmp/tmpu0u9qs0z.swift:29:9: error: cannot assign to value:\
    \ 'lower' is a 'let' constant\n        lower = (lower + 1) % lst.count\n     \
    \   ^~~~~\n/tmp/tmpu0u9qs0z.swift:23:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let lower = min\n    ^~~\n    var\n/tmp/tmpu0u9qs0z.swift:30:9:\
    \ error: cannot assign to value: 'upper' is a 'let' constant\n        upper =\
    \ (upper + 2) % lst.count\n        ^~~~~\n/tmp/tmpu0u9qs0z.swift:24:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let upper = max\n    ^~~\n    var\n/tmp/tmpu0u9qs0z.swift:33:8:\
    \ error: cannot assign through subscript: 'lst' is a 'let' constant\n    lst[lower]\
    \ = lst[upper]\n    ~~~^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty {\n        return\
    \ lst\n    }\n\n    // get minimum number in the list\n    var min_number = lst[0]\n\
    \    for number in lst {\n        if number < min_number {\n            min_number\
    \ = number\n        }\n    }\n\n    // get maximum number in the list\n    var\
    \ max_number = lst[0]\n    for number in lst {\n        if number > max_number\
    \ {\n            max_number = number\n        }\n    }\n\n    // create new list\
    \ to sort and return\n    var new_list = [Int]()\n    for number in lst {\n  \
    \      if number > min_number {\n            new_list.append(number)\n       \
    \ }\n        if number < max_number {\n            new_list.append(number)\n \
    \       }\n    }\n    return new_list\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmp3n1ao4ro/tmp3n1ao4ro.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3799258c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3798f4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3798f4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3798f4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3n1ao4ro                        0x00005647dec45694 <unavailable> + 5780

    5    libc.so.6                          0x00002b3799444460 __libc_start_main +
    245

    6    tmp3n1ao4ro                        0x00005647dec45289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let arr: [Int] = lst\n    let\
    \ min = arr[0]\n    let max = arr[arr.count-1]\n    \n    var sorted_arr = [Int]()\n\
    \    for x in arr {\n        let diff = x-min\n        if diff > max {\n     \
    \       diff += max - min\n        }\n        if diff > min {\n            diff\
    \ -= min - max\n        }\n        sorted_arr.append(diff)\n    }\n    \n    return\
    \ sorted_arr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp32ue7tq5.swift:21:18: error: left side of mutating operator isn't\
    \ mutable: 'diff' is a 'let' constant\n            diff += max - min\n       \
    \     ~~~~ ^\n/tmp/tmp32ue7tq5.swift:19:9: note: change 'let' to 'var' to make\
    \ it mutable\n        let diff = x-min\n        ^~~\n        var\n/tmp/tmp32ue7tq5.swift:24:18:\
    \ error: left side of mutating operator isn't mutable: 'diff' is a 'let' constant\n\
    \            diff -= min - max\n            ~~~~ ^\n/tmp/tmp32ue7tq5.swift:19:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let diff = x-min\n \
    \       ^~~\n        var\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let len = lst.count\n    let\
    \ minLst = lst.min()\n    let maxLst = lst.max()\n    var lst1 = lst + [minLst]\n\
    \    for var i = 2; i < len; i++) {\n        if lst1[i] > lst1[i - 1] {\n    \
    \        lst1 = lst1 + [minLst]\n        }\n        lst1 = lst1 + [maxLst]\n \
    \   }\n    return lst1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpx0ycmsdx.swift:17:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i < len; i++) {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpx0ycmsdx.swift:23:12: error: cannot convert return expression of type\
    \ '[Int?]' to return type '[Int]'\n    return lst1\n           ^\n/tmp/tmpx0ycmsdx.swift:23:12:\
    \ note: arguments to generic parameter 'Element' ('Int?' and 'Int') are expected\
    \ to be equal\n    return lst1\n           ^\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty() {\n      \
    \  return []\n    }\n    var result = Array(repeating: 0, count: lst.count)\n\
    \    var start = 0\n    var end = lst.count - 1\n    while start <= end {\n  \
    \      let mid = start + (end - start) / 2\n        if lst.first <= mid {\n  \
    \          result = result\n                .filter { $0 != mid }\n          \
    \      .append (lst.first + mid)\n            start = mid + 1\n        } else\
    \ if mid < end {\n            result = result\n                .filter { $0 !=\
    \ mid }\n                .append (lst.last + mid)\n            end = mid\n   \
    \     } else {\n            result = result\n                .filter { $0 != mid\
    \ }\n                .append (lst.first + mid)\n            start = mid + 1\n\
    \            end = mid - 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpzj9k5adx.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpzj9k5adx.swift:21:16: error: value of optional type 'Int?' must be\
    \ unwrapped to a value of type 'Int'\n        if lst.first <= mid {\n        \
    \       ^\n/tmp/tmpzj9k5adx.swift:21:16: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        if lst.first <= mid\
    \ {\n               ^\n                     ?? <#default value#>\n/tmp/tmpzj9k5adx.swift:21:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if lst.first <= mid {\n               ^\n                   \
    \ !\n/tmp/tmpzj9k5adx.swift:24:18: error: cannot assign value of type '()' to\
    \ type '[Int]'\n                .append (lst.first + mid)\n~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzj9k5adx.swift:24:30: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n                .append (lst.first + mid)\n      \
    \                       ^\n/tmp/tmpzj9k5adx.swift:24:30: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n         \
    \       .append (lst.first + mid)\n                             ^\n          \
    \               (         ?? <#default value#>)\n/tmp/tmpzj9k5adx.swift:24:30:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n                .append (lst.first + mid)\n                         \
    \    ^\n                                  !\n/tmp/tmpzj9k5adx.swift:29:18: error:\
    \ cannot assign value of type '()' to type '[Int]'\n                .append (lst.last\
    \ + mid)\n~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzj9k5adx.swift:29:30:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \                .append (lst.last + mid)\n                             ^\n/tmp/tmpzj9k5adx.swift:29:30:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n                .append (lst.last + mid)\n                          "
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var list = lst.copy()\n   \
    \ for idx in range(len(list) - 1, -1, -1) {\n        for idx2 in range(idx + 1,\
    \ len(list)) {\n            switch list[idx2] {\n            case list[idx]:\n\
    \                list.remove(list[idx])\n                list.insert(idx, list[idx2])\n\
    \            default:\n                break\n            }\n        }\n    }\n\
    \    return list as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp5afbkxqw.swift:13:20: error: value of type '[Int]' has no member\
    \ 'copy'\n    var list = lst.copy()\n               ~~~ ^~~~\n/tmp/tmp5afbkxqw.swift:14:16:\
    \ error: cannot find 'range' in scope\n    for idx in range(len(list) - 1, -1,\
    \ -1) {\n               ^~~~~\n/tmp/tmp5afbkxqw.swift:14:22: error: cannot find\
    \ 'len' in scope\n    for idx in range(len(list) - 1, -1, -1) {\n            \
    \         ^~~\n/tmp/tmp5afbkxqw.swift:15:21: error: cannot find 'range' in scope\n\
    \        for idx2 in range(idx + 1, len(list)) {\n                    ^~~~~\n\
    /tmp/tmp5afbkxqw.swift:15:36: error: cannot find 'len' in scope\n        for idx2\
    \ in range(idx + 1, len(list)) {\n                                   ^~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    switch lst.count {\n    case\
    \ 0:\n        return [] as [Int]\n    case 1:\n        return lst as [Int]\n \
    \   case 2:\n        let min = lst[0]\n        let max = lst[1]\n        return\
    \ Array(Set(lst).sorted())\n    case 3:\n        let min = lst[0]\n        let\
    \ max = lst[1]\n        let min = max(min, lst[2])\n        let max = min(max,\
    \ lst[2])\n        return [min, max]\n    case 4:\n        let min = lst[0]\n\
    \        let max = lst[1]\n        let min = max(min, lst[2])\n        let max\
    \ = min(max, lst[2])\n        let min = min(min, lst[3])\n        let max = max(max,\
    \ lst[3])\n        return [min, max]\n    case 5:\n        let min = lst[0]\n\
    \        let max = lst[1]\n        let min = max(min, lst[2])\n        let max\
    \ = min(max, lst[2])\n        let min = min(min, lst[3])\n        let max = max(max,\
    \ lst[3])\n        let min = min(min, lst[4])\n        let max = max(max, lst[4])\n\
    \        return [min, max]\n    case 6:\n        let min = lst[0]\n        let\
    \ max = lst[1]\n        let min = max(min, lst[2])\n        let max = min(max,\
    \ lst[2])\n        let min = min(min, lst[3])\n        let max = max(max, lst[3])\n\
    \        let min = min(min, lst[4])\n        let max = max(max, lst[4])\n    \
    \    let min = min(min, lst[5])\n        let max = max(max, lst[5])\n        return\
    \ [min, max]\n    case 7:\n        let min = lst[0]\n        let max = lst[1]\n\
    \        let min = max(min, lst[2])\n        let max = min(max, lst[2])\n    \
    \    let min = min(min, lst[3])\n        let max = max(max, lst[3])\n        let\
    \ min = min(min, lst[4])\n        let max = max(max, lst[4])\n        let min\
    \ = min(min, lst[5])\n        let max = max(max, lst[5])\n        let min = min(min,\
    \ lst[6])\n        let max = max(max, lst[6])\n        return [min, max]\n   \
    \ case 8:\n        let min = lst[0]\n        let max = lst[1]\n        let min\
    \ = max(min, lst[2])\n        let max = min(max, lst[2])\n        let min = min(min,\
    \ lst[3])\n        let max = max(max, lst[3])\n        let min = min(min, lst[4])\n\
    \        let max = max(max, lst[4])\n        let min = min(min, lst[5])\n    \
    \    let max = max(max, lst[5])\n        let min = min(min, lst[6])\n        let\
    \ max = max(max, lst[6])\n        let min = min(min, lst[7])\n        let max\
    \ = max(max, lst[7])\n        return [min, max]\n    case 9:\n        let min\
    \ = lst[0]\n        let max = lst[1]\n        let min = max(min, lst[2])\n   \
    \     let max = min(max, lst[2])\n        let min = min(min, lst[3])\n       \
    \ let max = max(max, lst[3])\n        let min = min(min, lst[4])\n        let\
    \ max = \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp97k1ye8z.swift:96:18: error: expected initial value after '='\n\
    \        let max = \n                 ^\n/tmp/tmp97k1ye8z.swift:120:53: error:\
    \ expected '}' at end of brace statement\nassert(strange_sort_list(lst: [111111])\
    \ == [111111])\n                                                    ^\n/tmp/tmp97k1ye8z.swift:12:45:\
    \ note: to match this opening '{'\nfunc strange_sort_list(lst: [Int]) -> [Int]\
    \ {\n                                            ^\n/tmp/tmp97k1ye8z.swift:25:19:\
    \ error: cannot call value of non-function type 'Int'\n        let min = max(min,\
    \ lst[2])\n                  ^\n/tmp/tmp97k1ye8z.swift:31:19: error: cannot call\
    \ value of non-function type 'Int'\n        let min = max(min, lst[2])\n     \
    \             ^\n/tmp/tmp97k1ye8z.swift:39:19: error: cannot call value of non-function\
    \ type 'Int'\n        let min = max(min, lst[2])\n                  ^\n/tmp/tmp97k1ye8z.swift:49:19:\
    \ error: cannot call value of non-function type 'Int'\n        let min = max(min,\
    \ lst[2])\n                  ^\n/tmp/tmp97k1ye8z.swift:61:19: error: cannot call\
    \ value of non-function type 'Int'\n        let min = max(min, lst[2])\n     \
    \             ^\n/tmp/tmp97k1ye8z.swift:75:19: error: cannot call value of non-function\
    \ type 'Int'\n        let min = max(min, lst[2])\n                  ^\n/tmp/tmp97k1ye8z.swift:91:19:\
    \ error: cannot call value of non-function type 'Int'\n        let min = max(min,\
    \ lst[2])\n                  ^\n/tmp/tmp97k1ye8z.swift:13:5: error: switch must\
    \ be exhaustive\n    switch lst.count {\n    ^\n/tmp/tmp97k1ye8z.swift:13:5: note:\
    \ do you want to add a default clause?\n    switch lst.count {\n    ^\n/tmp/tmp97k1ye8z.swift:100:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var rs = lst.sort { a, b in\n\
    \        // Swap `a` and `b` if `a` is greater.\n        if a > b {\n        \
    \    (a, b) = (b, a)\n        }\n        // Swap `b` and `c` if `b` is greater\
    \ than `c`.\n        if b > c {\n            (b, c) = (c, b)\n        }\n    \
    \    // Swap `c` and `d` if `c` is greater than `d`.\n        if c > d {\n   \
    \         (c, d) = (d, c)\n        }\n        // Swap `d` and `e` if `d` is greater\
    \ than `e`.\n        if d > e {\n            (d, e) = (e, d)\n        }\n    \
    \    // Swap `e` and `f` if `e` is greater than `f`.\n        if e > f {\n   \
    \         (e, f) = (f, e)\n        }\n        // Swap `f` and `g` if `f` is greater\
    \ than `g`.\n        if f > g {\n            (f, g) = (g, f)\n        }\n    \
    \    // Swap `g` and `h` if `g` is greater than `h`.\n        if g > h {\n   \
    \         (g, h) = (h, g)\n        }\n        // Swap `h` and `a` if `h` is greater\
    \ than `a`.\n        if h > a {\n            (h, a) = (a, h)\n        }\n    \
    \    // Swap `a` and `b` if `a` is greater than `b`.\n        if a > b {\n   \
    \         (a, b) = (b, a)\n        }\n        return true\n    }\n    return rs\
    \ as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpsxq054sv.swift:19:16: error: cannot find 'c' in scope\n       \
    \ if b > c {\n               ^\n/tmp/tmpsxq054sv.swift:20:17: error: cannot find\
    \ 'c' in scope\n            (b, c) = (c, b)\n                ^\n/tmp/tmpsxq054sv.swift:20:23:\
    \ error: cannot find 'c' in scope\n            (b, c) = (c, b)\n             \
    \         ^\n/tmp/tmpsxq054sv.swift:23:12: error: cannot find 'c' in scope\n \
    \       if c > d {\n           ^\n/tmp/tmpsxq054sv.swift:23:16: error: cannot\
    \ find 'd' in scope\n        if c > d {\n               ^\n/tmp/tmpsxq054sv.swift:24:14:\
    \ error: cannot find 'c' in scope\n            (c, d) = (d, c)\n             ^\n\
    /tmp/tmpsxq054sv.swift:24:17: error: cannot find 'd' in scope\n            (c,\
    \ d) = (d, c)\n                ^\n/tmp/tmpsxq054sv.swift:24:23: error: cannot\
    \ find 'd' in scope\n            (c, d) = (d, c)\n                      ^\n/tmp/tmpsxq054sv.swift:24:26:\
    \ error: cannot find 'c' in scope\n            (c, d) = (d, c)\n             \
    \            ^\n/tmp/tmpsxq054sv.swift:27:12: error: cannot find 'd' in scope\n\
    \        if d > e {\n           ^\n/tmp/tmpsxq054sv.swift:27:16: error: cannot\
    \ find 'e' in scope\n        if d > e {\n               ^\n/tmp/tmpsxq054sv.swift:28:14:\
    \ error: cannot find 'd' in scope\n            (d, e) = (e, d)\n             ^\n\
    /tmp/tmpsxq054sv.swift:28:17: error: cannot find 'e' in scope\n            (d,\
    \ e) = (e, d)\n                ^\n/tmp/tmpsxq054sv.swift:28:23: error: cannot\
    \ find 'e' in scope\n            (d, e) = (e, d)\n                      ^\n/tmp/tmpsxq054sv.swift:28:26:\
    \ error: cannot find 'd' in scope\n            (d, e) = (e, d)\n             \
    \            ^\n/tmp/tmpsxq054sv.swift:31:12: error: cannot find 'e' in scope\n\
    \        if e > f {\n           ^\n/tmp/tmpsxq054sv.swift:31:16: error: cannot\
    \ find 'f' in scope\n        if e > f {\n               ^\n/tmp/tmpsxq054sv.swift:32:14:\
    \ error: cannot find 'e' in scope\n            (e, f) = (f, e)\n             ^\n\
    /tmp/tmpsxq054sv.swift:32:17: error: cannot find 'f' in scope\n            (e,\
    \ f) = (f, e)\n                ^\n/tmp/tmpsxq054sv.swift:32:23: error: cannot\
    \ find 'f"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpl1jng6kx/tmpl1jng6kx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab61c013c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab61bd0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab61bd0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab61bd097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1jng6kx                        0x00005605f789e3d4 <unavailable> + 5076

    5    libc.so.6                          0x00002ab61c1ff460 __libc_start_main +
    245

    6    tmpl1jng6kx                        0x00005605f789dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660028493
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty {\n        return\
    \ lst\n    }\n    let minIndex = lst.firstIndex(of: lst.min())\n    let maxIndex\
    \ = lst.firstIndex(of: lst.max()!)\n\n    let minValues = minIndex ..< maxIndex\n\
    \    let maxValues = minIndex ..< maxIndex\n\n    for i in minValues {\n     \
    \   for j in maxValues {\n            let temp = lst[i]\n            lst[i] =\
    \ lst[j]\n            lst[j] = temp\n        }\n    }\n    return lst\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp5garcn9w.swift:16:43: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    let minIndex = lst.firstIndex(of:\
    \ lst.min())\n                                          ^\n/tmp/tmp5garcn9w.swift:16:43:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let minIndex = lst.firstIndex(of: lst.min())\n                  \
    \                        ^\n                                                ??\
    \ <#default value#>\n/tmp/tmp5garcn9w.swift:16:43: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n    let minIndex =\
    \ lst.firstIndex(of: lst.min())\n                                          ^\n\
    \                                               !\n/tmp/tmp5garcn9w.swift:19:34:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    let minValues\
    \ = minIndex ..< maxIndex\n                                 ^\n/tmp/tmp5garcn9w.swift:19:34:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let minValues = minIndex ..< maxIndex\n                         \
    \        ^\n                                 (        ?? <#default value#>)\n\
    /tmp/tmp5garcn9w.swift:19:34: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    let minValues = minIndex ..< maxIndex\n\
    \                                 ^\n                                        \
    \ !\n/tmp/tmp5garcn9w.swift:20:34: error: value of optional type 'Array<Int>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Int>.Index'\
    \ (aka 'Int')\n    let maxValues = minIndex ..< maxIndex\n                   \
    \              ^\n/tmp/tmp5garcn9w.swift:20:34: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n    let maxValues = minIndex\
    \ ..< maxIndex\n                                 ^\n                         \
    \        (        ?? <#default value#>)\n/tmp/tmp5garcn9w.swift:20:34: note: force-unwrap\
    \ using '!' to abort"
  stdout: ''
  timestamp: 1660028657
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty() {\n      \
    \  return lst\n    }\n    var strange = lst\n    let minValue = lst[0]\n    var\
    \ maxValue = minValue\n    for value in lst {\n        if value < minValue {\n\
    \            strange.append(value)\n        } else if value > maxValue {\n   \
    \         strange.append(value)\n        } else {\n            let index = lst.indexOf\
    \ { $0 >= value }\n            let index = lst.index(before: index)\n        \
    \    strange.append(strange[index])\n            strange.removeFirst()\n     \
    \   }\n    }\n    return strange as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpeonqd5j9.swift:13:12: error: cannot call value of non-function\
    \ type 'Bool'\n    if lst.isEmpty() {\n           ^      ~~\n                \
    \  \n/tmp/tmpeonqd5j9.swift:25:29: error: value of type '[Int]' has no member\
    \ 'indexOf'\n            let index = lst.indexOf { $0 >= value }\n           \
    \             ~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var n = lst.count\n    var\
    \ newArray = [Int]()\n    for i in 0..<n {\n        var min = lst[i]\n       \
    \ var max = i\n        var count = 1\n        while (i + count < n && lst[i +\
    \ count] < min) {\n            count += 1\n        }\n        while (i + count\
    \ < n && lst[i + count] == min) {\n            count += 1\n        }\n       \
    \ while (i + count < n && lst[i + count] > min) {\n            count -= 1\n  \
    \      }\n        newArray.append(min + (max - min) * (count - 1))\n    }\n  \
    \  return newArray\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpx_gnnali/tmpx_gnnali.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43d4ca8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43d499fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43d499f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43d499e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx_gnnali                        0x00005579f22426c4 <unavailable> + 5828

    5    libc.so.6                          0x00002b43d4e94460 __libc_start_main +
    245

    6    tmpx_gnnali                        0x00005579f22422b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var max = -1\n    var min =\
    \ 0\n    for element in lst {\n        if element > max {\n            max = element\n\
    \        } else if element < min {\n            min = element\n        }\n   \
    \ }\n    var strangedSorted = [Int](repeating: 0, count: lst.count)\n    if min\
    \ > 0 {\n        strangedSorted = strangedSorted + [0]\n    }\n    if max < 0\
    \ {\n        strangedSorted = strangedSorted + [0]\n    }\n    for element in\
    \ lst {\n        if element > max {\n            strangedSorted = strangedSorted\
    \ + [element - min]\n        }\n        if element < min {\n            strangedSorted\
    \ = strangedSorted + [element - min]\n        }\n    }\n    return strangedSorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmp3nw46o7x/tmp3nw46o7x.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59885e2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59882d9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59882d9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59882d87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3nw46o7x                        0x00005637f4a7a664 <unavailable> + 5732

    5    libc.so.6                          0x00002b59887ce460 __libc_start_main +
    245

    6    tmp3nw46o7x                        0x00005637f4a7a259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted { $0 < $1\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2,\
    \ 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5,\
    \ 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmprmbno6no/tmprmbno6no.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af501b0bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af501802b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af501802988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5018017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprmbno6no                        0x0000556aef76c444 <unavailable> + 5188

    5    libc.so.6                          0x00002af501cf7460 __libc_start_main +
    245

    6    tmprmbno6no                        0x0000556aef76c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028656
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var res = lst\n    for i in\
    \ (0..<lst.count).reversed() {\n        for j in (i+1..<lst.count).reversed()\
    \ {\n            if res[j] < res[i] {\n                let tmp = res[i]\n    \
    \            res[i] = res[j]\n                res[j] = tmp\n            }\n  \
    \      }\n    }\n    return res as [Int]\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmp_ar2xu14/tmp_ar2xu14.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fc268c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fbf5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fbf5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fbf5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_ar2xu14                        0x000055ddc1b51834 <unavailable> + 6196

    5    libc.so.6                          0x00002b11fc454460 __libc_start_main +
    245

    6    tmp_ar2xu14                        0x000055ddc1b51429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var res = lst.copy()\n    res.sortInPlace()\n\
    \    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpmn7ihpyn.swift:13:19: error: value of type '[Int]' has no member\
    \ 'copy'\n    var res = lst.copy()\n              ~~~ ^~~~\n"
  stdout: ''
  timestamp: 1660028657
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n\n    var sorted_lst = [Int]()\n    var min = lst[0]\n\
    \    var max = lst[0]\n    for v in lst {\n        if v < min {\n            min\
    \ = v\n        }\n        if v > max {\n            max = v\n        }\n    }\n\
    \n    for v in lst {\n        let pos = v - min\n        sorted_lst.append(pos\
    \ + min)\n    }\n\n    return sorted_lst + [max]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpy9tmstr5/tmpy9tmstr5.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b457a1bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4579eb4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4579eb4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4579eb37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy9tmstr5                        0x000055852ed076f4 <unavailable> + 5876

    5    libc.so.6                          0x00002b457a3a9460 __libc_start_main +
    245

    6    tmpy9tmstr5                        0x000055852ed072e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sorted(by: { $0\
    \ < $1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'tmpnk5iuugf/tmpnk5iuugf.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fa2c7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fa2972b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fa2972988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fa29717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnk5iuugf                        0x000055dbf84a6444 <unavailable> + 5188

    5    libc.so.6                          0x00002b8fa2e67460 __libc_start_main +
    245

    6    tmpnk5iuugf                        0x000055dbf84a6039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    return lst\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpcj0wpgx4/tmpcj0wpgx4.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b518ec80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b518e977b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b518e977988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b518e9767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcj0wpgx4                        0x0000558fadaa13d4 <unavailable> + 5076

    5    libc.so.6                          0x00002b518ee6c460 __libc_start_main +
    245

    6    tmpcj0wpgx4                        0x0000558fadaa0fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var max = 0\n    var min =\
    \ 0\n\n    for v in lst {\n        if v > max {\n            max = v\n       \
    \ }\n        if v < min {\n            min = v\n        }\n    }\n    \n    var\
    \ result = [Int]()\n    if min != 0 {\n        result.append(self[min])\n    }\n\
    \    \n    for v in lst {\n        if v > max {\n            result.append(self[max])\n\
    \        }\n        if v < min {\n            result.append(self[v])\n       \
    \ }\n    }\n    \n    if max != 0 {\n        result.append(self[max])\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpt9et3wvt.swift:27:23: error: cannot find 'self' in scope; did you\
    \ mean to use it in a type or extension context?\n        result.append(self[min])\n\
    \                      ^~~~\n/tmp/tmpt9et3wvt.swift:32:27: error: cannot find\
    \ 'self' in scope; did you mean to use it in a type or extension context?\n  \
    \          result.append(self[max])\n                          ^~~~\n/tmp/tmpt9et3wvt.swift:35:27:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n            result.append(self[v])\n                          ^~~~\n\
    /tmp/tmpt9et3wvt.swift:40:23: error: cannot find 'self' in scope; did you mean\
    \ to use it in a type or extension context?\n        result.append(self[max])\n\
    \                      ^~~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var strangeSorted = lst\n\n\
    \    for i in 1..<strangeSorted.count {\n        let minValue = strangeSorted[i-1]\n\
    \        let maxValue = strangeSorted[i]\n        var temp: Int\n        for j\
    \ in 0..<strangeSorted.count {\n            if j < i {\n                continue\n\
    \            }\n            if strangeSorted[j] < minValue {\n               \
    \ temp = minValue\n            } else if (strangeSorted[j] < maxValue) && strangeSorted[j]\
    \ > temp {\n                temp = strangeSorted[j]\n            }\n        }\n\
    \        strangeSorted = [minValue, temp, maxValue, maxValue, minValue, maxValue,\
    \ minValue, minValue, maxValue, maxValue, minValue, temp, maxValue, maxValue,\
    \ maxValue, maxValue, maxValue, minValue]\n    }\n    return strangeSorted\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpixu9f9zq.swift:25:56: error: variable 'temp' used before being\
    \ initialized\n            } else if (strangeSorted[j] < maxValue) && strangeSorted[j]\
    \ > temp {\n                                                       ^\n/tmp/tmpixu9f9zq.swift:18:13:\
    \ note: variable defined here\n        var temp: Int\n            ^\n/tmp/tmpixu9f9zq.swift:29:36:\
    \ error: variable 'temp' used before being initialized\n        strangeSorted\
    \ = [minValue, temp, maxValue, maxValue, minValue, maxValue, minValue, minValue,\
    \ maxValue, maxValue, minValue, temp, maxValue, maxValue, maxValue, maxValue,\
    \ maxValue, minValue]\n                                   ^\n/tmp/tmpixu9f9zq.swift:18:13:\
    \ note: variable defined here\n        var temp: Int\n            ^\n/tmp/tmpixu9f9zq.swift:29:132:\
    \ error: variable 'temp' used before being initialized\n        strangeSorted\
    \ = [minValue, temp, maxValue, maxValue, minValue, maxValue, minValue, minValue,\
    \ maxValue, maxValue, minValue, temp, maxValue, maxValue, maxValue, maxValue,\
    \ maxValue, minValue]\n                                                      \
    \                                                                            \
    \ ^\n/tmp/tmpixu9f9zq.swift:18:13: note: variable defined here\n        var temp:\
    \ Int\n            ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var min_idx = lst.index(min(lst))\n\
    \    var max_idx = lst.index(max(lst))\n\n    for i in 1..<min(max_idx - min_idx,\
    \ lst.count - max_idx) {\n        if min_idx < max_idx {\n            var x =\
    \ lst[min_idx]\n            lst[min_idx] = lst[max_idx]\n            lst[max_idx]\
    \ = x\n        }\n\n        min_idx += i\n        max_idx += i\n    }\n\n    return\
    \ lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpl9kmym71.swift:13:23: error: no exact matches in call to instance\
    \ method 'index'\n    var min_idx = lst.index(min(lst))\n                    \
    \  ^\n/tmp/tmpl9kmym71.swift:13:23: note: candidate expects value of type 'Int'\
    \ for parameter #1 (got 'Int')\n    var min_idx = lst.index(min(lst))\n      \
    \                ^\n/tmp/tmpl9kmym71.swift:13:23: note: candidate expects value\
    \ of type 'Int' for parameter #1 (got 'Int')\n    var min_idx = lst.index(min(lst))\n\
    \                      ^\n/tmp/tmpl9kmym71.swift:13:23: note: candidate expects\
    \ value of type 'Int' for parameter #1 (got 'Int')\n    var min_idx = lst.index(min(lst))\n\
    \                      ^\n/tmp/tmpl9kmym71.swift:13:23: note: candidate expects\
    \ value of type 'Array<Int>.Index' (aka 'Int') for parameter #1 (got 'Array<Int>.Index'\
    \ (aka 'Int'))\n    var min_idx = lst.index(min(lst))\n                      ^\n\
    /tmp/tmpl9kmym71.swift:13:23: note: candidate expects value of type 'Array<Int>.Index'\
    \ (aka 'Int') for parameter #1 (got 'Array<Int>.Index' (aka 'Int'))\n    var min_idx\
    \ = lst.index(min(lst))\n                      ^\n/tmp/tmpl9kmym71.swift:13:36:\
    \ error: missing argument for parameter #2 in call\n    var min_idx = lst.index(min(lst))\n\
    \                                   ^\n                                   , <#Int#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmpl9kmym71.swift:13:33:\
    \ error: cannot convert value of type '[Int]' to expected argument type 'Int'\n\
    \    var min_idx = lst.index(min(lst))\n                                ^\n/tmp/tmpl9kmym71.swift:14:23:\
    \ error: no exact matches in call to instance method 'index'\n    var max_idx\
    \ = lst.index(max(lst))\n                      ^\n/tmp/tmpl9kmym71.swift:14:23:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Int')\n \
    \   var max_idx = lst.index(max(lst))\n                      ^\n/tmp/tmpl9kmym71.swift:14:23:\
    \ note: candidate expects value of type 'Int' for parameter #1 (got 'Int')\n \
    \   var max_idx = lst.index(max(lst))"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count < 2 {\n      \
    \  return lst\n    }\n    var sorted = []\n    var minIdx = 0\n    for idx :=\
    \ 0; idx < lst.count; idx++ {\n        if idx == 0 {\n            sorted = append(sorted,\
    \ lst[idx])\n            continue\n        }\n        if lst.sorted[idx] < sorted[minIdx]\
    \ {\n            minIdx = idx\n        }\n    }\n    for idx := 0; idx < minIdx;\
    \ idx++ {\n        sorted = append(sorted, lst[idx])\n    }\n    for idx := minIdx;\
    \ idx < lst.count; idx++ {\n        sorted = append(sorted, lst[idx])\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpgqftaobs.swift:18:14: error: expected type\n    for idx := 0; idx\
    \ < lst.count; idx++ {\n             ^\n              <#type#>\n/tmp/tmpgqftaobs.swift:18:14:\
    \ error: expected 'in' after for-each pattern\n    for idx := 0; idx < lst.count;\
    \ idx++ {\n             ^\n/tmp/tmpgqftaobs.swift:18:14: error: expected Sequence\
    \ expression for for-each loop\n    for idx := 0; idx < lst.count; idx++ {\n \
    \            ^\n/tmp/tmpgqftaobs.swift:27:14: error: expected type\n    for idx\
    \ := 0; idx < minIdx; idx++ {\n             ^\n              <#type#>\n/tmp/tmpgqftaobs.swift:27:14:\
    \ error: expected 'in' after for-each pattern\n    for idx := 0; idx < minIdx;\
    \ idx++ {\n             ^\n/tmp/tmpgqftaobs.swift:27:14: error: expected Sequence\
    \ expression for for-each loop\n    for idx := 0; idx < minIdx; idx++ {\n    \
    \         ^\n/tmp/tmpgqftaobs.swift:30:14: error: expected type\n    for idx :=\
    \ minIdx; idx < lst.count; idx++ {\n             ^\n              <#type#>\n/tmp/tmpgqftaobs.swift:30:14:\
    \ error: expected 'in' after for-each pattern\n    for idx := minIdx; idx < lst.count;\
    \ idx++ {\n             ^\n/tmp/tmpgqftaobs.swift:30:14: error: expected Sequence\
    \ expression for for-each loop\n    for idx := minIdx; idx < lst.count; idx++\
    \ {\n             ^\n/tmp/tmpgqftaobs.swift:16:18: error: empty collection literal\
    \ requires an explicit type\n    var sorted = []\n                 ^~\n/tmp/tmpgqftaobs.swift:33:12:\
    \ error: cannot convert return expression of type '[Any]' to return type '[Int]'\n\
    \    return sorted\n           ^\n/tmp/tmpgqftaobs.swift:33:12: note: arguments\
    \ to generic parameter 'Element' ('Any' and 'Int') are expected to be equal\n\
    \    return sorted\n           ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    var ints = [Int]()\n\
    \    \n    if lst.count == 0 {\n        \n        return ints\n        \n    }\n\
    \    \n    if lst.count == 1 {\n        \n        let min = lst[0]\n        \n\
    \        ints.append(min)\n        \n        let max = lst[0]\n        \n    \
    \    if lst.count > 1 {\n            \n            for elem in lst {\n       \
    \         \n                if elem < min {\n                    \n          \
    \          min = elem\n                    \n                } else if elem >\
    \ max {\n                    \n                    max = elem\n              \
    \      \n                }\n                \n            }\n            \n  \
    \      }\n        \n        ints.append(max)\n        \n        return ints\n\
    \        \n    }\n    \n    var curr = lst[0]\n    \n    for elem in lst {\n \
    \       \n        if elem > curr {\n            \n            ints.append(curr)\n\
    \            \n            curr = elem\n            \n        } else {\n     \
    \       \n            ints.append(elem)\n            \n        }\n        \n \
    \   }\n    \n    ints.append(curr)\n    \n    return ints\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpfsh2c6wv.swift:36:21: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n                    min = elem\n                    ^~~\n/tmp/tmpfsh2c6wv.swift:24:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let min = lst[0]\n \
    \       ^~~\n        var\n/tmp/tmpfsh2c6wv.swift:40:21: error: cannot assign to\
    \ value: 'max' is a 'let' constant\n                    max = elem\n         \
    \           ^~~\n/tmp/tmpfsh2c6wv.swift:28:9: note: change 'let' to 'var' to make\
    \ it mutable\n        let max = lst[0]\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let mut sorted = lst\n    sorted.sort()\n\
    \n    let sorted_list = sorted.to_vec()\n    for index in 0..<sorted_list.count\
    \ {\n        let tmp = sorted_list[index]\n        sorted_list[index] = sorted_list[index\
    \ + 1]\n        sorted_list[index + 1] = tmp\n    }\n\n    sorted_list\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpa1rc59bc.swift:13:13: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n    let mut sorted =\
    \ lst\n            ^\n/tmp/tmpa1rc59bc.swift:13:13: note: join the identifiers\
    \ together\n    let mut sorted = lst\n        ~~~~^~~~~~\n        mutsorted\n\
    /tmp/tmpa1rc59bc.swift:13:13: note: join the identifiers together with camel-case\n\
    \    let mut sorted = lst\n        ~~~~^~~~~~\n        mutSorted\n/tmp/tmpa1rc59bc.swift:14:5:\
    \ error: cannot find 'sorted' in scope\n    sorted.sort()\n    ^~~~~~\n/tmp/tmpa1rc59bc.swift:16:23:\
    \ error: cannot find 'sorted' in scope\n    let sorted_list = sorted.to_vec()\n\
    \                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var min: Int = 0\n    var max:\
    \ Int = 0\n    for x in lst {\n        if x < min {\n            min = x\n   \
    \     } else if x > max {\n            max = x\n        }\n    }\n    var sorted\
    \ = [Int]()\n    for x in lst {\n        sorted.append(x)\n    }\n    sorted.append(min)\n\
    \    sorted.append(max)\n    for x in lst {\n        sorted.remove(x)\n    }\n\
    \    return sorted\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp9hme68q6.swift:29:16: error: no exact matches in call to instance\
    \ method 'remove'\n        sorted.remove(x)\n               ^\nSwift.Array:10:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(at:)')\n   \
    \ @inlinable public mutating func remove(at index: Int) -> Element\n         \
    \                           ^\nSwift.RangeReplaceableCollection:9:37: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(at:)')\n    @inlinable public\
    \ mutating func remove(at position: Self.Index) -> Self.Element\n            \
    \                        ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 { return\
    \ lst }\n    var result = [Int]()\n    var j = 0\n    for idx in lst {\n     \
    \   result.append(idx)\n        j += 1\n        if j == lst.count {\n        \
    \    j += 1\n        }\n    }\n    for idx in result {\n        idx = idx + 1\n\
    \        if idx != lst[0] {\n            result.removeAll()\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpn0fodqfu.swift:24:9: error: cannot assign to value: 'idx' is a\
    \ 'let' constant\n        idx = idx + 1\n        ^~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.isEmpty {\n        return\
    \ lst\n    }\n\n    var minI = 0\n    var maxI = lst.count\n    for _ in 0..<maxI-1\
    \ {\n        if let idx = minI {\n            let minVal = lst[idx]\n        \
    \    if let nextIdx = idx + 1 {\n                let nextMinVal = lst[nextIdx]\n\
    \                if minVal > nextMinVal {\n                    minI = nextIdx\n\
    \                } else {\n                    minI = idx\n                }\n\
    \            } else {\n                minI = idx\n            }\n        } else\
    \ {\n            // if minI is 0, then we cannot find a next smallest number,\n\
    \            // so we have to break out of for loop.\n            break\n    \
    \    }\n    }\n\n    // now minI is our min index\n\n    let sortedIdx = minI\n\
    \    var sortedArr = lst\n    for idx in minI...maxI {\n        let val = lst[idx]\n\
    \        if val != sortedArr[sortedIdx] {\n            sortedArr[sortedIdx], val\
    \ = val, sortedArr[sortedIdx]\n            sortedIdx = idx\n        }\n    }\n\
    \    return sortedArr\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpnn3v6k6_.swift:46:33: error: consecutive statements on a line must\
    \ be separated by ';'\n            sortedArr[sortedIdx], val = val, sortedArr[sortedIdx]\n\
    \                                ^\n                                ;\n/tmp/tmpnn3v6k6_.swift:46:33:\
    \ error: expected expression\n            sortedArr[sortedIdx], val = val, sortedArr[sortedIdx]\n\
    \                                ^\n/tmp/tmpnn3v6k6_.swift:22:16: error: initializer\
    \ for conditional binding must have Optional type, not 'Int'\n            if let\
    \ nextIdx = idx + 1 {\n               ^             ~~~~~~~\n/tmp/tmpnn3v6k6_.swift:20:12:\
    \ error: initializer for conditional binding must have Optional type, not 'Int'\n\
    \        if let idx = minI {\n           ^         ~~~~\n/tmp/tmpnn3v6k6_.swift:46:22:\
    \ warning: subscript is accessed but result is unused\n            sortedArr[sortedIdx],\
    \ val = val, sortedArr[sortedIdx]\n            ~~~~~~~~~^~~~~~~~~~~\n/tmp/tmpnn3v6k6_.swift:18:9:\
    \ warning: variable 'maxI' was never mutated; consider changing to 'let' constant\n\
    \    var maxI = lst.count\n    ~~~ ^\n    let\n/tmp/tmpnn3v6k6_.swift:42:9: warning:\
    \ variable 'sortedArr' was never mutated; consider changing to 'let' constant\n\
    \    var sortedArr = lst\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  if lst.count == 0 { return lst\
    \ }\n  let min: Int = lst.min()\n  let max: Int = lst.max()\n  let result = lst.filter{\
    \ $0 < min }.filter{ $0 != max }.filter{ $0 < max }\n  \n  switch result {\n \
    \   case let .init(arr): return arr\n    case let .init(_): return [] as [Int]\n\
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(strange_sort_list(lst: [1, 2,\
    \ 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5,\
    \ 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4,\
    \ 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\n\
    assert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpniagt1nr.swift:14:22: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n  let min: Int = lst.min()\n        \
    \             ^\n/tmp/tmpniagt1nr.swift:14:22: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n  let min: Int = lst.min()\n\
    \                     ^\n                           ?? <#default value#>\n/tmp/tmpniagt1nr.swift:14:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n  let min: Int = lst.min()\n                     ^\n                \
    \          !\n/tmp/tmpniagt1nr.swift:15:22: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n  let max: Int = lst.max()\n   \
    \                  ^\n/tmp/tmpniagt1nr.swift:15:22: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n  let max: Int\
    \ = lst.max()\n                     ^\n                           ?? <#default\
    \ value#>\n/tmp/tmpniagt1nr.swift:15:22: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n  let max: Int = lst.max()\n\
    \                     ^\n                          !\n/tmp/tmpniagt1nr.swift:19:15:\
    \ error: no exact matches in call to initializer \n    case let .init(arr): return\
    \ arr\n              ^\nSwift.Array:2:23: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(arrayLiteral:)')\n    @inlinable public init(arrayLiteral\
    \ elements: Element...)\n                      ^\nSwift.Array:2:12: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(from:)')\n    public init(from\
    \ decoder: Decoder) throws\n           ^\n/tmp/tmpniagt1nr.swift:20:10: warning:\
    \ 'let' pattern has no effect; sub-pattern didn't bind any variables\n    case\
    \ let .init(_): return [] as [Int]\n         ^~~~~~~~~~~~\n         \n/tmp/tmpniagt1nr.swift:20:20:\
    \ error: '_' can only appear in a pattern or on the left side of an assignment\n\
    \    case let .init(_): return [] as [Int]\n                   ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  guard lst.count > 0 else { return\
    \ lst }\n  var strangeList = [Int]()\n  for index in 0..<lst.count {\n    if index\
    \ == 0 {\n      strangeList.append(lst[index])\n      continue\n    }\n    if\
    \ strangeList[index] < lst[index] {\n      strangeList[index] = lst[index]\n \
    \   }\n  }\n  return strangeList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b19b1c46c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19b193d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b19b193d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b19b193d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b19b193cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b19b173ce83 <unavailable> + 188035

    6    tmp9hqcw40g                        0x0000562dc1a623fa <unavailable> + 9210

    7    tmp9hqcw40g                        0x0000562dc1a6162c <unavailable> + 5676

    8    libc.so.6                          0x00002b19b1e32460 __libc_start_main +
    245

    9    tmp9hqcw40g                        0x0000562dc1a61309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    let maxValue = lst.max()\n\
    \    let minValue = lst.min()\n    var sortedList = lst\n    sortedList.removeFirst()\n\
    \    sortedList.removeLast()\n    sortedList.removeLast()\n    for i in 0..<sortedList.count/2\
    \ {\n        var a = sortedList.removeLast()\n        var b = sortedList.removeLast()\n\
    \        if a > maxValue {\n            a = minValue\n        }\n        if b\
    \ > maxValue {\n            b = minValue\n        }\n        if a > b {\n    \
    \        sortedList.append(b)\n            sortedList.append(a)\n        } else\
    \ {\n            sortedList.append(a)\n            sortedList.append(b)\n    \
    \    }\n    }\n    sortedList.append(maxValue)\n    sortedList.removeFirst()\n\
    \    return sortedList\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpammp88pg.swift:22:16: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n        if a > maxValue {\n         \
    \      ^\n/tmp/tmpammp88pg.swift:22:16: note: coalesce using '??' to provide a\
    \ default when the optional value contains 'nil'\n        if a > maxValue {\n\
    \               ^\n                        ?? <#default value#>\n/tmp/tmpammp88pg.swift:22:16:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if a > maxValue {\n               ^\n                       !\n\
    /tmp/tmpammp88pg.swift:23:17: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n            a = minValue\n                ^\n/tmp/tmpammp88pg.swift:23:17:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            a = minValue\n                ^\n                       \
    \  ?? <#default value#>\n/tmp/tmpammp88pg.swift:23:17: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            a =\
    \ minValue\n                ^\n                        !\n/tmp/tmpammp88pg.swift:25:16:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        if b > maxValue {\n               ^\n/tmp/tmpammp88pg.swift:25:16: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        if b > maxValue {\n               ^\n                        ?? <#default\
    \ value#>\n/tmp/tmpammp88pg.swift:25:16: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        if b > maxValue {\n\
    \               ^\n                       !\n/tmp/tmpammp88pg.swift:26:17: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \           b = minValue\n                ^\n/tmp/tmpammp88pg.swift:26:17: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \            b = minValue\n                ^\n                         ?? <#default\
    \ value#>\n/tmp/tmpammp88pg.swift:26:17: note: force-unwrap using '!' to abort "
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    for idx\
    \ = lst.count - 1; idx > 0; idx-- {\n        let value = result[idx]\n       \
    \ let next = result[idx - 1]\n        if value < next {\n            result.removeAtIndex(idx)\n\
    \            result.append(value)\n            result.append(next)\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpck1l6xg2.swift:14:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for idx = lst.count - 1; idx > 0; idx-- {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpck1l6xg2.swift:15:28: error: cannot find 'idx' in scope\n        let value\
    \ = result[idx]\n                           ^~~\n/tmp/tmpck1l6xg2.swift:16:27:\
    \ error: cannot find 'idx' in scope\n        let next = result[idx - 1]\n    \
    \                      ^~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    guard lst.count >= 1 else {\
    \ return lst }\n    let minValue = lst[0]\n    guard lst.count > 1 else {\n  \
    \      return lst\n    }\n    let maxValue = lst[1]\n    let minIndex = lst.index(of:\
    \ minValue)\n    let maxIndex = lst.index(of: maxValue)\n    var sortedList =\
    \ lst\n    sortedList.swapAt(minIndex, maxIndex)\n    sortedList.swapAt(maxIndex+1,\
    \ minIndex)\n    sortedList.swapAt(minIndex+1, maxIndex)\n    return sortedList\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpfivs899d.swift:19:24: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let minIndex = lst.index(of: minValue)\n         \
    \              ^\n/tmp/tmpfivs899d.swift:19:24: note: use 'firstIndex(of:)' instead\n\
    \    let minIndex = lst.index(of: minValue)\n                       ^~~~~\n  \
    \                     firstIndex\n/tmp/tmpfivs899d.swift:20:24: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n    let maxIndex = lst.index(of:\
    \ maxValue)\n                       ^\n/tmp/tmpfivs899d.swift:20:24: note: use\
    \ 'firstIndex(of:)' instead\n    let maxIndex = lst.index(of: maxValue)\n    \
    \                   ^~~~~\n                       firstIndex\n/tmp/tmpfivs899d.swift:22:23:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    sortedList.swapAt(minIndex,\
    \ maxIndex)\n                      ^\n/tmp/tmpfivs899d.swift:22:23: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ sortedList.swapAt(minIndex, maxIndex)\n                      ^\n           \
    \                    ?? <#default value#>\n/tmp/tmpfivs899d.swift:22:23: note:\
    \ force-unwrap using '!' to abort execution if the optional value contains 'nil'\n\
    \    sortedList.swapAt(minIndex, maxIndex)\n                      ^\n        \
    \                      !\n/tmp/tmpfivs899d.swift:22:33: error: value of optional\
    \ type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Int>.Index' (aka 'Int')\n    sortedList.swapAt(minIndex, maxIndex)\n\
    \                                ^\n/tmp/tmpfivs899d.swift:22:33: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ sortedList.swapAt(minIndex, maxIndex)\n                                ^\n \
    \                                        ?? <#default value#>\n/tmp/tmpfivs899d.swift:22:33:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    sortedList.swapAt(minIndex, maxIndex)\n                         \
    \       ^\n  "
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = lst\n    for index\
    \ in stride(from: 0, to: lst.count - 1, by: 1) {\n        var minIndex = index\n\
    \        for n in stride(from: minIndex + 1, to: lst.count, by: -1) {\n      \
    \      var minValue = lst[minIndex]\n            var maxValue = lst[index]\n \
    \           if maxValue < minValue {\n                minValue = lst[index]\n\
    \                maxValue = lst[minIndex]\n            }\n            if maxValue\
    \ < minValue {\n                minValue = lst[minIndex]\n                maxValue\
    \ = lst[index]\n            }\n            if maxValue < minValue {\n        \
    \        minValue = lst[index]\n                maxValue = lst[minIndex]\n   \
    \         }\n            if maxValue < minValue {\n                minValue =\
    \ lst[index]\n                maxValue = lst[minIndex]\n            }\n      \
    \      if maxValue < minValue {\n                minValue = lst[index]\n     \
    \           maxValue = lst[minIndex]\n            }\n            if maxValue <\
    \ minValue {\n                minValue = lst[index]\n                maxValue\
    \ = lst[minIndex]\n            }\n            if maxValue < minValue {\n     \
    \           minValue = lst[index]\n                maxValue = lst[minIndex]\n\
    \            }\n            if maxValue < minValue {\n                minValue\
    \ = lst[index]\n                maxValue = lst[minIndex]\n            }\n    \
    \        if maxValue < minValue {\n                minValue = lst[index]\n   \
    \             maxValue = lst[minIndex]\n            }\n            if maxValue\
    \ < minValue {\n                minValue = lst[index]\n                maxValue\
    \ = lst[minIndex]\n            }\n            if maxValue < minValue {\n     \
    \           minValue = lst[index]\n                maxValue = lst[minIndex]\n\
    \            }\n            if maxValue < minValue {\n                minValue\
    \ = lst[index]\n                maxValue = lst[minIndex]\n            }\n    \
    \        if maxValue < minValue {\n                minValue = lst[index]\n   \
    \             maxValue = lst[minIndex]\n            }\n            if maxValue\
    \ < minValue {\n                minValue = lst[index]\n                maxValue\
    \ = lst[minIndex]\n            }\n            if maxValue < minValue {\n     \
    \           minValue = lst[index]\n                maxValue = lst[minIndex]\n\
    \            }\n            if maxValue < minValue {\n                minValue\
    \ = lst[index]\n                maxValue = lst[minIndex]\n            }\n    \
    \        if maxValue < minValue {\n                minValue = lst[index]\n   \
    \             maxValue = lst[minIndex]\n            }\n            if maxValue\
    \ < minValue {\n                minValue = lst[index]\n                maxValue\
    \ = lst[minIndex]\n            }\n            if maxValue < minValue {\n     \
    \           minValue = lst[index]\n                maxValue = lst[minIndex]\n\
    \            }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp8jbjrz_w.swift:119:53: error: expected '}' at end of brace statement\n\
    assert(strange_sort_list(lst: [111111]) == [111111])\n                       \
    \                             ^\n/tmp/tmp8jbjrz_w.swift:14:60: note: to match\
    \ this opening '{'\n    for index in stride(from: 0, to: lst.count - 1, by: 1)\
    \ {\n                                                           ^\n/tmp/tmp8jbjrz_w.swift:119:53:\
    \ error: expected '}' at end of brace statement\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])\n                                                   \
    \ ^\n/tmp/tmp8jbjrz_w.swift:12:45: note: to match this opening '{'\nfunc strange_sort_list(lst:\
    \ [Int]) -> [Int] {\n                                            ^\n/tmp/tmp8jbjrz_w.swift:99:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp8jbjrz_w.swift:13:9:\
    \ warning: initialization of variable 'result' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var result = lst\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp8jbjrz_w.swift:15:13: warning: variable 'minIndex' was never mutated;\
    \ consider changing to 'let' constant\n        var minIndex = index\n        ~~~\
    \ ^\n        let\n/tmp/tmp8jbjrz_w.swift:16:13: warning: immutable value 'n' was\
    \ never used; consider replacing with '_' or removing it\n        for n in stride(from:\
    \ minIndex + 1, to: lst.count, by: -1) {\n            ^\n            _\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.len() == 0 {\n     \
    \   return []\n    }\n\n    // get min element of unsorted list\n    let minVal\
    \ = lst[0]\n    // get index where min value appears\n    let minIdx = lst.index(of:\
    \ minVal)\n    // get sorted list without min value\n    let sortedWithoutMin\
    \ = lst[1..<minIdx]\n\n    // get max element of unsorted list\n    let maxVal\
    \ = lst[lst.count - 1]\n    // get index where max value appears\n    let maxIdx\
    \ = lst.index(of: maxVal)\n    // get sorted list without max value\n    let sortedWithoutMax\
    \ = lst[minIdx..<maxIdx]\n\n    // concatenate sorted list with min and max values\n\
    \    let sortedWithMinMax = sortedWithoutMin + sortedWithoutMax\n    // insert\
    \ min and max value back in the list\n    sortedWithMinMax.insert(minVal, at:\
    \ 0)\n    sortedWithMinMax.insert(maxVal, at: sortedWithMinMax.endIndex)\n\n \
    \   return sortedWithMinMax\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpvjexa52m.swift:13:12: error: value of type '[Int]' has no member\
    \ 'len'\n    if lst.len() == 0 {\n       ~~~ ^~~\n/tmp/tmpvjexa52m.swift:20:22:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    let minIdx\
    \ = lst.index(of: minVal)\n                     ^\n/tmp/tmpvjexa52m.swift:20:22:\
    \ note: use 'firstIndex(of:)' instead\n    let minIdx = lst.index(of: minVal)\n\
    \                     ^~~~~\n                     firstIndex\n/tmp/tmpvjexa52m.swift:22:36:\
    \ error: value of optional type 'Array<Int>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Int>.Index' (aka 'Int')\n    let sortedWithoutMin\
    \ = lst[1..<minIdx]\n                                   ^\n/tmp/tmpvjexa52m.swift:22:36:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let sortedWithoutMin = lst[1..<minIdx]\n                        \
    \           ^\n                                   (      ?? <#default value#>)\n\
    /tmp/tmpvjexa52m.swift:22:36: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n    let sortedWithoutMin = lst[1..<minIdx]\n\
    \                                   ^\n                                      \
    \   !\n/tmp/tmpvjexa52m.swift:27:22: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let maxIdx = lst.index(of: maxVal)\n             \
    \        ^\n/tmp/tmpvjexa52m.swift:27:22: note: use 'firstIndex(of:)' instead\n\
    \    let maxIdx = lst.index(of: maxVal)\n                     ^~~~~\n        \
    \             firstIndex\n/tmp/tmpvjexa52m.swift:29:41: error: value of optional\
    \ type 'Array<Int>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Int>.Index' (aka 'Int')\n    let sortedWithoutMax = lst[minIdx..<maxIdx]\n\
    \                                        ^\n/tmp/tmpvjexa52m.swift:27:9: note:\
    \ short-circuit using 'guard' to exit this function early if the optional value\
    \ contains 'nil'\n    let maxIdx = lst.index(of: maxVal)\n        ^\n    guard\
    \                              else { return <#default value#> }\n/tmp/tmpvjexa52m.swift:27:22"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst.asArray()\n    }\n    var lstSorted: [Int] = lst.asArray()\n  \
    \  var min: Int = lstSorted[0]\n    var max: Int = lstSorted[0]\n    for v in\
    \ lstSorted {\n        if v < min {\n            min = v\n        } else if v\
    \ > max {\n            max = v\n        }\n    }\n    var min = lstSorted[0]\n\
    \    var max = lstSorted[0]\n    for v in lstSorted {\n        if v < min {\n\
    \            min = v\n        } else if v > max {\n            max = v\n     \
    \   }\n    }\n    lstSorted = Array([min...max])\n    for v in lstSorted {\n \
    \       lstSorted.remove(v)\n    }\n    return lstSorted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmph885_mpz.swift:14:20: error: value of type '[Int]' has no member\
    \ 'asArray'\n        return lst.asArray()\n               ~~~ ^~~~~~~\n/tmp/tmph885_mpz.swift:16:32:\
    \ error: value of type '[Int]' has no member 'asArray'\n    var lstSorted: [Int]\
    \ = lst.asArray()\n                           ~~~ ^~~~~~~\n/tmp/tmph885_mpz.swift:26:9:\
    \ error: invalid redeclaration of 'min'\n    var min = lstSorted[0]\n        ^\n\
    /tmp/tmph885_mpz.swift:17:9: note: 'min' previously declared here\n    var min:\
    \ Int = lstSorted[0]\n        ^\n/tmp/tmph885_mpz.swift:27:9: error: invalid redeclaration\
    \ of 'max'\n    var max = lstSorted[0]\n        ^\n/tmp/tmph885_mpz.swift:18:9:\
    \ note: 'max' previously declared here\n    var max: Int = lstSorted[0]\n    \
    \    ^\n/tmp/tmph885_mpz.swift:35:27: error: cannot convert value of type 'ClosedRange<Self>'\
    \ to expected element type 'Int'\n    lstSorted = Array([min...max])\n       \
    \                   ^\n/tmp/tmph885_mpz.swift:37:19: error: no exact matches in\
    \ call to instance method 'remove'\n        lstSorted.remove(v)\n            \
    \      ^\nSwift.Array:10:37: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(at:)')\n    @inlinable public mutating func remove(at index: Int)\
    \ -> Element\n                                    ^\nSwift.RangeReplaceableCollection:9:37:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(at:)')\n   \
    \ @inlinable public mutating func remove(at position: Self.Index) -> Self.Element\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var n = lst.length\n    var\
    \ sorted = [Int](repeating: Int(), count: n)\n    for i in 0..<n {\n        for\
    \ j in i+1..<n {\n            if sorted[j] < sorted[i] {\n                sorted.swapAt(i,\
    \ j)\n            }\n        }\n    }\n    return sorted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpjshprerh.swift:13:17: error: value of type '[Int]' has no member\
    \ 'length'\n    var n = lst.length\n            ~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count <= 1 {\n     \
    \   return lst\n    }\n\n    guard lst.count > 2 else { return lst }\n\n    var\
    \ min = lst[0]\n    var max = lst[0]\n    var min_i = -1\n    var max_i = -1\n\
    \n    for _ in 0 ..< lst.count - 2 {\n        guard min_i < 0 || (max_i < 0 &&\
    \ (min < max)) || (min_i >= 0 && max_i >= 0 && (min <= max)) else { return lst\
    \ }\n        min = lst[min_i]\n        max = lst[max_i]\n        min_i = -1\n\
    \        max_i = -1\n\n        for j in 0 ..< lst.count {\n            guard min_i\
    \ < 0 || (max_i < 0 && (min < max)) || (min_i >= 0 && max_i >= 0 && (min <= max))\
    \ else { return lst }\n\n            if lst[j] < max {\n                min =\
    \ lst[j]\n                min_i = j\n            } else {\n                max\
    \ = lst[j]\n                max_i = j\n            }\n        }\n    }\n\n   \
    \ return append(lst, min, max: max)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3,\
    \ 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1])\
    \ == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5,\
    \ 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst:\
    \ [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpdit8lc5v.swift:44:12: error: cannot find 'append' in scope\n  \
    \  return append(lst, min, max: max)\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count == 0 {\n     \
    \   return lst\n    }\n\n    let minI = lst.index(of: lst.min())!\n    let minValue\
    \ = lst[minI]\n\n    var lst2 = lst\n    lst2.reverse()\n\n    var maxI = lst2.index(of:\
    \ minValue)!\n    while maxI > 0 {\n        var tmpI = lst2.index(of: maxValue,\
    \ offsetBy: -1)!\n        lst2.remove(at: maxI)\n        lst2.insert(tmpI, at:\
    \ maxI)\n        maxI = lst2.index(of: maxValue, offsetBy: -1)!\n    }\n\n   \
    \ return lst2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp7e4dyqjd.swift:17:34: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    let minI = lst.index(of: lst.min())!\n\
    \                                 ^\n/tmp/tmp7e4dyqjd.swift:17:34: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let minI = lst.index(of: lst.min())!\n                                 ^\n \
    \                                      ?? <#default value#>\n/tmp/tmp7e4dyqjd.swift:17:34:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let minI = lst.index(of: lst.min())!\n                          \
    \       ^\n                                      !\n/tmp/tmp7e4dyqjd.swift:25:35:\
    \ error: cannot find 'maxValue' in scope\n        var tmpI = lst2.index(of: maxValue,\
    \ offsetBy: -1)!\n                                  ^~~~~~~~\n/tmp/tmp7e4dyqjd.swift:25:25:\
    \ error: no exact matches in call to instance method 'index'\n        var tmpI\
    \ = lst2.index(of: maxValue, offsetBy: -1)!\n                        ^\n/tmp/tmp7e4dyqjd.swift:25:25:\
    \ note: found candidate with type '(Int, Int) -> Int'\n        var tmpI = lst2.index(of:\
    \ maxValue, offsetBy: -1)!\n                        ^\n/tmp/tmp7e4dyqjd.swift:28:31:\
    \ error: cannot find 'maxValue' in scope\n        maxI = lst2.index(of: maxValue,\
    \ offsetBy: -1)!\n                              ^~~~~~~~\n/tmp/tmp7e4dyqjd.swift:28:21:\
    \ error: no exact matches in call to instance method 'index'\n        maxI = lst2.index(of:\
    \ maxValue, offsetBy: -1)!\n                    ^\n/tmp/tmp7e4dyqjd.swift:28:21:\
    \ note: found candidate with type '(Int, Int) -> Int'\n        maxI = lst2.index(of:\
    \ maxValue, offsetBy: -1)!\n                    ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.count > 1 {\n      \
    \  var arr: [Int] = []\n        var min: Int = 0\n        var max: Int = 0\n \
    \       for el in lst {\n            max = el\n            if max < min {\n  \
    \              min = max\n            } else {\n                max = max\n  \
    \          }\n            arr.append(max)\n        }\n        for el in lst {\n\
    \            max = el\n            if max < min {\n                min = max\n\
    \            } else {\n                max = max\n            }\n            arr.insert(max,\
    \ min)\n        }\n        return arr\n    } else {\n        return lst\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpwhwdmfqa.swift:22:21: error: assigning a variable to itself\n \
    \               max = max\n                ~~~ ^ ~~~\n/tmp/tmpwhwdmfqa.swift:31:21:\
    \ error: assigning a variable to itself\n                max = max\n         \
    \       ~~~ ^ ~~~\n/tmp/tmpwhwdmfqa.swift:33:17: error: no exact matches in call\
    \ to instance method 'insert'\n            arr.insert(max, min)\n            \
    \    ^\nSwift.Array:11:37: note: incorrect labels for candidate (have: '(_:_:)',\
    \ expected: '(_:at:)')\n    @inlinable public mutating func insert(_ newElement:\
    \ __owned Element, at i: Int)\n                                    ^\nSwift.RangeReplaceableCollection:6:37:\
    \ note: incorrect labels for candidate (have: '(_:_:)', expected: '(_:at:)')\n\
    \    @inlinable public mutating func insert(_ newElement: __owned Self.Element,\
    \ at i: Self.Index)\n                                    ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n\tif lst.isEmpty {\n\t\treturn\
    \ []\n\t}\n\tresult := lst.sort{ $0 >= $1 }.map { $0 }\n\tswitch len(result) {\n\
    \tcase 0:\n\t\treturn []\n\tcase 1:\n\t\treturn result\n\tdefault:\n\t\treturn\
    \ result\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpp4_0gj_h.swift:16:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := lst.sort{ $0 >= $1 }.map { $0 }\n   \
    \           ^\n              ;\n/tmp/tmpp4_0gj_h.swift:16:9: error: expected expression\n\
    \        result := lst.sort{ $0 >= $1 }.map { $0 }\n               ^\n/tmp/tmpp4_0gj_h.swift:16:2:\
    \ error: cannot find 'result' in scope\n        result := lst.sort{ $0 >= $1 }.map\
    \ { $0 }\n        ^~~~~~\n/tmp/tmpp4_0gj_h.swift:17:9: error: cannot find 'len'\
    \ in scope\n        switch len(result) {\n               ^~~\n/tmp/tmpp4_0gj_h.swift:17:13:\
    \ error: cannot find 'result' in scope\n        switch len(result) {\n       \
    \            ^~~~~~\n/tmp/tmpp4_0gj_h.swift:21:10: error: cannot find 'result'\
    \ in scope\n                return result\n                       ^~~~~~\n/tmp/tmpp4_0gj_h.swift:23:10:\
    \ error: cannot find 'result' in scope\n                return result\n      \
    \                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpl1jng6kx/tmpl1jng6kx.swift:29: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab61c013c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab61bd0ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab61bd0a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab61bd097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl1jng6kx                        0x00005605f789e3d4 <unavailable> + 5076

    5    libc.so.6                          0x00002ab61c1ff460 __libc_start_main +
    245

    6    tmpl1jng6kx                        0x00005605f789dfc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1660028493
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sort { $0 < $1 }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpsv030vyj.swift:13:16: error: cannot convert return expression of\
    \ type '()' to return type '[Int]'\n    return lst.sort { $0 < $1 }\n        \
    \   ~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpsv030vyj.swift:13:16: error: cannot use mutating\
    \ member on immutable value: 'lst' is a 'let' constant\n    return lst.sort {\
    \ $0 < $1 }\n           ~~~ ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    if lst.IsEmpty {\n        return\
    \ lst\n    }\n    let minValue = min(lst)\n    let maxValue = max(lst)\n    var\
    \ list = lst as [Int]\n    for i in 0..<min(lst.count, maxValue) - 1 {\n     \
    \   list = strange_sort_helper(list, minValue, maxValue)\n    }\n    return list\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp50efij51.swift:13:12: error: value of type '[Int]' has no member\
    \ 'IsEmpty'\n    if lst.IsEmpty {\n       ~~~ ^~~~~~~\n/tmp/tmp50efij51.swift:16:27:\
    \ error: missing argument for parameter #2 in call\n    let minValue = min(lst)\n\
    \                          ^\n                          , <#[Int]#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmp50efij51.swift:17:27:\
    \ error: missing argument for parameter #2 in call\n    let maxValue = max(lst)\n\
    \                          ^\n                          , <#[Int]#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n  if lst.count == 0 {\n    return\
    \ []\n  }\n  var result = lst\n  for i in 0..<lst.count {\n    for j in (i + 1)..<lst.count\
    \ {\n      for k in 0..<lst.count {\n        if i != j && i != k && j != k {\n\
    \          var a = result[i]\n          result[i] = result[j]\n          result[j]\
    \ = a\n          break\n        }\n      }\n    }\n  }\n  return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmptkpa06zf/tmptkpa06zf.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7b07a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7b049fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7b049f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7b049e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptkpa06zf                        0x000055fde5ae9664 <unavailable> + 5732

    5    libc.so.6                          0x00002ab7b0994460 __libc_start_main +
    245

    6    tmptkpa06zf                        0x000055fde5ae9259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    \n    var strange_lst = [Int]()\n\
    \    \n    for i in lst {\n        strange_lst.append(i)\n    }\n    \n    if\
    \ lst.count > 0 {\n        for i in lst {\n            for j in lst {\n      \
    \          if i == j {\n                    continue\n                }\n    \
    \            if strange_lst[j] < strange_lst[i] {\n                    strange_lst[i],\
    \ strange_lst[j] = strange_lst[j], strange_lst[i]\n                }\n       \
    \     }\n        }\n    }\n    \n    return strange_lst\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp2x0gfhrg.swift:27:35: error: consecutive statements on a line must\
    \ be separated by ';'\n                    strange_lst[i], strange_lst[j] = strange_lst[j],\
    \ strange_lst[i]\n                                  ^\n                      \
    \            ;\n/tmp/tmp2x0gfhrg.swift:27:35: error: expected expression\n   \
    \                 strange_lst[i], strange_lst[j] = strange_lst[j], strange_lst[i]\n\
    \                                  ^\n/tmp/tmp2x0gfhrg.swift:27:32: warning: subscript\
    \ is accessed but result is unused\n                    strange_lst[i], strange_lst[j]\
    \ = strange_lst[j], strange_lst[i]\n                    ~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: -4
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int]()\n    if\
    \ lst.count == 0 {\n        return result\n    }\n    var current = lst[0]\n \
    \   for val in lst {\n        if current > val {\n            current = val\n\
    \        } else {\n            result.append(current)\n            current = val\n\
    \        }\n    }\n    result.append(current)\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: Exception
  stderr: 'tmpqam3v6t4/tmpqam3v6t4.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac40b652c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac40b349b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac40b349988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac40b3487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqam3v6t4                        0x000055ff2a53e6a4 <unavailable> + 5796

    5    libc.so.6                          0x00002ac40b83e460 __libc_start_main +
    245

    6    tmpqam3v6t4                        0x000055ff2a53e299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    lst.reverse()\n    return lst\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmp8rpkw_y4.swift:13:9: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    lst.reverse()\n    ~~~ ^\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var result = [Int]()\n    var\
    \ minValue = min(lst)\n    var maxValue = max(lst)\n    \n    for value in lst\
    \ {\n        if value < minValue {\n            result = append(result, [minValue],\
    \ 0)\n            minValue = min(minValue, value)\n        } else if value > maxValue\
    \ {\n            result = append(result, [maxValue], 0)\n            maxValue\
    \ = max(maxValue, value)\n        } else {\n            result = append(result,\
    \ value, 0)\n        }\n    }\n    \n    result = append(result, minValue)\n \
    \   result = append(result, maxValue)\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4, 2, 3])\n\
    assert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7,\
    \ 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5])\
    \ == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as [Int])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7, 3, 6,\
    \ 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5, 5,\
    \ -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmprydkewsa.swift:14:27: error: missing argument for parameter #2\
    \ in call\n    var minValue = min(lst)\n                          ^\n        \
    \                  , <#[Int]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmprydkewsa.swift:15:27: error: missing argument for parameter\
    \ #2 in call\n    var maxValue = max(lst)\n                          ^\n     \
    \                     , <#[Int]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmprydkewsa.swift:19:22: error: cannot find 'append'\
    \ in scope\n            result = append(result, [minValue], 0)\n             \
    \        ^~~~~~\n/tmp/tmprydkewsa.swift:22:22: error: cannot find 'append' in\
    \ scope\n            result = append(result, [maxValue], 0)\n                \
    \     ^~~~~~\n/tmp/tmprydkewsa.swift:25:22: error: cannot find 'append' in scope\n\
    \            result = append(result, value, 0)\n                     ^~~~~~\n\
    /tmp/tmprydkewsa.swift:29:14: error: cannot find 'append' in scope\n    result\
    \ = append(result, minValue)\n             ^~~~~~\n/tmp/tmprydkewsa.swift:30:14:\
    \ error: cannot find 'append' in scope\n    result = append(result, maxValue)\n\
    \             ^~~~~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    return lst.sort().reverse()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) == [1, 4,\
    \ 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7])\n\
    assert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
    \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
    \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == []\
    \ as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8,\
    \ 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5])\
    \ == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmphr5py0ah.swift:13:16: error: cannot use mutating member on immutable\
    \ value: 'lst' is a 'let' constant\n    return lst.sort().reverse()\n        \
    \   ~~~ ^\n/tmp/tmphr5py0ah.swift:13:23: error: value of tuple type '()' has no\
    \ member 'reverse'\n    return lst.sort().reverse()\n           ~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660028658
- exit_code: 1
  program: "\n/// Given array of integers, return array in strange order.\n/// Strange\
    \ sorting, is when you start with the minimum value,\n/// then maximum of the\
    \ remaining integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
    \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
    /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
    func strange_sort_list(lst: [Int]) -> [Int] {\n    var list = lst\n    let len\
    \ = list.count\n    if len < 2 { return list }\n\n    // Find the smallest element\
    \ in the remaining list\n    var min = Int64(Int64.max)\n    var min_idx = Int64(Int64.max)\n\
    \    for i in 0..<len {\n        if list[i] < min {\n            min = list[i]\n\
    \            min_idx = i\n        }\n    }\n\n    // Swap with the smallest\n\
    \    let tmp = list[min_idx]\n    list[min_idx] = list[len-1]\n    list[len-1]\
    \ = tmp\n\n    // Sort the rest of the list\n    for i in 1..<len {\n        let\
    \ tmp = list[i]\n        let idx = i\n        let left = list.prefix(idx).reduce(into:\
    \ []) {\n            $0.append($1)\n        }\n        let right = list.suffix(idx).reduce(into:\
    \ []) {\n            $0.append($1)\n        }\n        if left != [] {\n     \
    \       list.insert(idx-1, at: left.count)\n            strange_sort_list(lst:\
    \ left)\n        }\n        if right != [] {\n            list.insert(idx, at:\
    \ right.count)\n            strange_sort_list(lst: right)\n        }\n    }\n\n\
    \    return list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(strange_sort_list(lst:\
    \ [1, 2, 3, 4]) == [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9])\
    \ == [5, 9, 6, 8, 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5,\
    \ 2, 4, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8,\
    \ 6, 7])\nassert(strange_sort_list(lst: [5, 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst:\
    \ [] as [Int]) == [] as [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5,\
    \ 6, 7, 8]) == [1, 8, 2, 7, 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2,\
    \ 2, 2, 5, 5, -5, -5]) == [-5, 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst:\
    \ [111111]) == [111111])"
  status: SyntaxError
  stderr: "/tmp/tmpd7kb_knj.swift:22:23: error: cannot assign value of type 'Int'\
    \ to type 'Int64'\n            min = list[i]\n                  ~~~~^~~\n    \
    \              Int64( )\n/tmp/tmpd7kb_knj.swift:23:23: error: cannot assign value\
    \ of type 'Int' to type 'Int64'\n            min_idx = i\n                   \
    \   ^\n                      Int64( )\n/tmp/tmpd7kb_knj.swift:28:19: error: no\
    \ exact matches in call to subscript \n    let tmp = list[min_idx]\n         \
    \         ^\nSwift.Array:16:23: note: candidate expects value of type 'Int' for\
    \ parameter #1 (got 'Int64')\n    @inlinable public subscript(index: Int) -> Element\
    \ { get set }\n                      ^\nSwift.Array:17:23: note: candidate expects\
    \ value of type 'Range<Int>' for parameter #1 (got 'Int64')\n    @inlinable public\
    \ subscript(bounds: Range<Int>) -> ArraySlice<Element> { get set }\n         \
    \             ^\nSwift.Collection:3:23: note: candidate expects value of type\
    \ '(UnboundedRange_) -> ()' for parameter #1 (got 'Int64')\n    @inlinable public\
    \ subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get }\n        \
    \              ^\nSwift.MutableCollection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Int64')\n    @inlinable\
    \ public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence { get set }\n\
    \                      ^\n/tmp/tmpd7kb_knj.swift:29:10: error: cannot convert\
    \ value of type 'Int64' to expected argument type 'Int'\n    list[min_idx] = list[len-1]\n\
    \         ^\n         Int(   )\n/tmp/tmpd7kb_knj.swift:44:13: warning: result\
    \ of call to 'strange_sort_list(lst:)' is unused\n            strange_sort_list(lst:\
    \ left)\n            ^                ~~~~~~~~~~~\n/tmp/tmpd7kb_knj.swift:48:13:\
    \ warning: result of call to 'strange_sort_list(lst:)' is unused\n           \
    \ strange_sort_list(lst: right)\n            ^                ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660028658
