language: swift
name: HumanEval_111_histogram
results:
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if isEmpty(test) {\n        return []\n    }\n    var map = [:]\n\
    \    test.unicodeScalars.forEach { scalar in\n        let char = scalar.stringValue\n\
    \        if let count = map[char] {\n            map[char] = count + 1\n     \
    \   } else {\n            map[char] = 1\n        }\n    }\n    return map\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpyoghgj22.swift:17:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(test) {\n       ^~~~~~~\n/tmp/tmpyoghgj22.swift:18:16: error: use\
    \ [:] to get an empty dictionary literal\n        return []\n               ^\n\
    \                :\n/tmp/tmpyoghgj22.swift:20:15: error: empty collection literal\
    \ requires an explicit type\n    var map = [:]\n              ^~~\n/tmp/tmpyoghgj22.swift:22:27:\
    \ error: value of type 'Unicode.Scalar' has no member 'stringValue'\n        let\
    \ char = scalar.stringValue\n                   ~~~~~~ ^~~~~~~~~~~\n/tmp/tmpyoghgj22.swift:29:12:\
    \ error: cannot convert return expression of type '[AnyHashable : Any]' to return\
    \ type '[String : Int]'\n    return map\n           ^\n/tmp/tmpyoghgj22.swift:29:12:\
    \ note: arguments to generic parameter 'Key' ('AnyHashable' and 'String') are\
    \ expected to be equal\n    return map\n           ^\n/tmp/tmpyoghgj22.swift:29:12:\
    \ note: arguments to generic parameter 'Value' ('Any' and 'Int') are expected\
    \ to be equal\n    return map\n           ^\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let maxOccurrences = Dictionary(grouping: test.lowercased(), by:\
    \ {$0})\n        .map({ (key, value) in (value, key) })\n        .max{$0.1 < $1.1}\n\
    \        .map{$0.0 }\n        .reduce([:]) { $0 + [$1] + [$2] }\n        .sorted\
    \ { $0.1 < $1.1 }\n        .map{$0.key}\n        .reduce([:]) { $0 + [$1] + [$2].map\
    \ { $0.1 } }\n    return maxOccurrences\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpu1423lnu.swift:17:26: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let maxOccurrences = Dictionary(grouping: test.lowercased(),\
    \ by: {$0})\n                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009642
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters = [String: Int]()\n    var mostRepeatedLetter = \"\"\
    \n    var mostRepeatedCount = Int64(Int.max)\n    var temp = \"\"\n    for _char\
    \ in test {\n        let value = letters[temp]\n        if value == nil {\n  \
    \          letters[temp] = 1\n        } else {\n            let count = value!\
    \ + 1\n            if count > mostRepeatedCount {\n                mostRepeatedLetter\
    \ = temp\n                mostRepeatedCount = count\n            }\n         \
    \   letters[temp] = count\n        }\n        temp = String(Character(_char))\n\
    \    }\n    return letters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7t6gtq3s.swift:29:37: error: cannot assign value of type 'Int'\
    \ to type 'Int64'\n                mostRepeatedCount = count\n               \
    \                     ^~~~~\n                                    Int64( )\n/tmp/tmp7t6gtq3s.swift:33:33:\
    \ error: missing argument label 'extendedGraphemeClusterLiteral:' in call\n  \
    \      temp = String(Character(_char))\n                                ^\n  \
    \                              extendedGraphemeClusterLiteral: \n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar max = [String : Int]()\n\tvar count = [String : Int]()\n\tvar\
    \ words = test.characters\n\tvar maxWord = nil\n\twords.forEach {\n\t\tif let\
    \ count = count[$0] {\n\t\t\tmax[$0] = count\n\t\t\tif maxWord == nil || count\
    \ > maxWord!.value {\n\t\t\t\tmaxWord = max[$0]\n\t\t\t}\n\t\t\tcount[$0] += 1\n\
    \t\t} else {\n\t\t\tcount[$0] = 1\n\t\t\tmax[$0] = 1\n\t\t}\n\t}\n\tif maxWord\
    \ == nil {\n\t\treturn [:]\n\t}\n\treturn maxWord!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp558u0499.swift:19:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        var words = test.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp558u0499.swift:20:16:\
    \ error: 'nil' requires a contextual type\n        var maxWord = nil\n       \
    \               ^\n/tmp/tmp558u0499.swift:22:24: error: cannot convert value of\
    \ type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \                if let count = count[$0] {\n                                \
    \     ^\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let characters = test.characters.map({ String($0) })\n    var result\
    \ = [:]\n    characters.forEach { character, count in\n        if let count =\
    \ result[character] {\n            result[character] = count + 1\n        } else\
    \ {\n            result[character] = 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpb5dfsa23.swift:17:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = test.characters.map({ String($0) })\n\
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpb5dfsa23.swift:18:18: error: empty collection literal requires\
    \ an explicit type\n    var result = [:]\n                 ^~~\n/tmp/tmpb5dfsa23.swift:19:26:\
    \ error: contextual closure type '(String) throws -> Void' expects 1 argument,\
    \ but 2 were used in closure body\n    characters.forEach { character, count in\n\
    \                         ^\n/tmp/tmpb5dfsa23.swift:21:33: error: cannot convert\
    \ value of type 'Any' to expected argument type 'Int'\n            result[character]\
    \ = count + 1\n                                ^\n                           \
    \           as! Int\n/tmp/tmpb5dfsa23.swift:26:12: error: cannot convert return\
    \ expression of type '[AnyHashable : Any]' to return type '[String : Int]'\n \
    \   return result\n           ^\n/tmp/tmpb5dfsa23.swift:26:12: note: arguments\
    \ to generic parameter 'Key' ('AnyHashable' and 'String') are expected to be equal\n\
    \    return result\n           ^\n/tmp/tmpb5dfsa23.swift:26:12: note: arguments\
    \ to generic parameter 'Value' ('Any' and 'Int') are expected to be equal\n  \
    \  return result\n           ^\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [:]\n    }\n\n    var freq: [String\
    \ : Int] = [:]\n    test.split(separator: \" \").forEach { x in\n        freq[x]\
    \ = (x != \"\") ? freq[x!] + 1 : 0\n    }\n\n    return freq\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpr_h7qc4w.swift:23:14: error: cannot convert value of type 'String.SubSequence'\
    \ (aka 'Substring') to expected argument type 'String'\n        freq[x] = (x !=\
    \ \"\") ? freq[x!] + 1 : 0\n             ^\n             String( )\n/tmp/tmpr_h7qc4w.swift:23:37:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        freq[x] = (x != \"\") ? freq[x!] +\
    \ 1 : 0\n                                    ^\n                             \
    \      String( )\n/tmp/tmpr_h7qc4w.swift:23:37: error: cannot force unwrap value\
    \ of non-optional type 'String.SubSequence' (aka 'Substring')\n        freq[x]\
    \ = (x != \"\") ? freq[x!] + 1 : 0\n                                   ~^\n  \
    \                                  \n/tmp/tmpr_h7qc4w.swift:23:35: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ freq[x] = (x != \"\") ? freq[x!] + 1 : 0\n                                 \
    \ ^\n/tmp/tmpr_h7qc4w.swift:23:35: note: coalesce using '??' to provide a default\
    \ when the optional value contains 'nil'\n        freq[x] = (x != \"\") ? freq[x!]\
    \ + 1 : 0\n                                  ^\n                             \
    \ (        ?? <#default value#>)\n/tmp/tmpr_h7qc4w.swift:23:35: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        freq[x]\
    \ = (x != \"\") ? freq[x!] + 1 : 0\n                                  ^\n    \
    \                                  !\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tcharCounts := [String : Int]()\n\ttest.unicodeScalars.forEach { char\
    \ in\n\t\tcharCounts[char.unicodeScalars.first!.stringValue] = charCounts[char.unicodeScalars.first!.stringValue]!\
    \ + 1\n\t}\n\treturn charCounts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp4ek1z3n5.swift:17:12: error: consecutive statements on a line must\
    \ be separated by ';'\n        charCounts := [String : Int]()\n              \
    \    ^\n                  ;\n/tmp/tmp4ek1z3n5.swift:17:13: error: expected expression\n\
    \        charCounts := [String : Int]()\n                   ^\n/tmp/tmp4ek1z3n5.swift:17:2:\
    \ error: cannot find 'charCounts' in scope\n        charCounts := [String : Int]()\n\
    \        ^~~~~~~~~~\n/tmp/tmp4ek1z3n5.swift:21:9: error: cannot find 'charCounts'\
    \ in scope\n        return charCounts\n               ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tresult : [String : Int]()\n\ttest.lowercaseString.split(\" \").forEach\
    \ {\n\t\tletter:String in\n\t\tresult[letter] = result[letter]! + 1\n\t}\n\treturn\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpbtit2nh1.swift:17:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result : [String : Int]()\n              ^\n  \
    \            ;\n/tmp/tmpbtit2nh1.swift:17:9: error: expected expression\n    \
    \    result : [String : Int]()\n               ^\n/tmp/tmpbtit2nh1.swift:17:2:\
    \ error: cannot find 'result' in scope\n        result : [String : Int]()\n  \
    \      ^~~~~~\n/tmp/tmpbtit2nh1.swift:22:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar freq = [String : Int]()\n\tvar max = 0\n\tvar test = [String]()\n\
    \tfor i := 0; i < len(test); i++ {\n\t\tfreq[test[i]] = freq[test[i]] + 1\n\t\t\
    if freq[test[i]] > max {\n\t\t\tmax = freq[test[i]]\n\t\t}\n\t}\n\tfor k := range\
    \ freq {\n\t\ttest = append(test, k)\n\t}\n\tsort.Sort(sort.Reverse(sort.IntSlice((test))))\n\
    \tfor i := 0; i < len(test); i++ {\n\t\tif freq[test[i]] == max {\n\t\t\tcontinue\n\
    \t\t}\n\t\tresult = append(result, test[i])\n\t\tfreq[test[i]]--\n\t}\n\treturn\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpzuntque7.swift:20:9: error: expected type\n        for i := 0;\
    \ i < len(test); i++ {\n               ^\n                <#type#>\n/tmp/tmpzuntque7.swift:20:9:\
    \ error: expected 'in' after for-each pattern\n        for i := 0; i < len(test);\
    \ i++ {\n               ^\n/tmp/tmpzuntque7.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n        for i := 0; i < len(test); i++ {\n   \
    \            ^\n/tmp/tmpzuntque7.swift:26:9: error: expected type\n        for\
    \ k := range freq {\n               ^\n                <#type#>\n/tmp/tmpzuntque7.swift:26:9:\
    \ error: expected 'in' after for-each pattern\n        for k := range freq {\n\
    \               ^\n/tmp/tmpzuntque7.swift:26:9: error: expected Sequence expression\
    \ for for-each loop\n        for k := range freq {\n               ^\n/tmp/tmpzuntque7.swift:30:9:\
    \ error: expected type\n        for i := 0; i < len(test); i++ {\n           \
    \    ^\n                <#type#>\n/tmp/tmpzuntque7.swift:30:9: error: expected\
    \ 'in' after for-each pattern\n        for i := 0; i < len(test); i++ {\n    \
    \           ^\n/tmp/tmpzuntque7.swift:30:9: error: expected Sequence expression\
    \ for for-each loop\n        for i := 0; i < len(test); i++ {\n              \
    \ ^\n/tmp/tmpzuntque7.swift:37:9: error: cannot find 'result' in scope\n     \
    \   return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar counts: [String : Int] = [:]\n\ttest.characters\n\t\t.flatMap\
    \ { c in\n\t\t\tif let char = c.unicodeScalars.first {\n\t\t\t\tlet count = counts[char]\
    \ ?? 0\n\t\t\t\tcounts[char] = (count + 1)\n\t\t\t}\n\t\t}\n\t\t.sorted { $0.count\
    \ < $1.count }\n\t\t.forEach { print($0.char, $0.count) }\n\treturn counts\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp2c9ha33p.swift:25:22: error: generic parameter 'Bound' could not\
    \ be inferred\n                .sorted { $0.count < $1.count }\n             \
    \                      ^\n/tmp/tmp2c9ha33p.swift:21:24: error: cannot convert\
    \ value of type 'Unicode.Scalar' to expected argument type 'String'\n        \
    \                        let count = counts[char] ?? 0\n                     \
    \                              ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    switch test {\n    case \"\":\n        return [:] as [String : Int]\n\
    \    case \"a b c a b\":\n        var result = [:] as [String : Int]\n       \
    \ var letterCount = [String : Int]()\n        test.components(separatedBy: \"\
    \ \").forEach { letter in\n            letterCount[letter] = (letterCount[letter]\
    \ ?? 0) + 1 as Int\n        }\n        let maxCount = letterCount.keys.max()!\n\
    \        var maxLetter = letterCount.keys.max()!\n        for i in 0...letterCount.keys.count\
    \ {\n            let letter = letterCount.keys.sorted()[i]\n            if letterCount[letter]\
    \ > maxCount {\n                maxCount = letterCount[letter]\n             \
    \   maxLetter = letter\n            }\n        }\n        result[maxLetter] =\
    \ maxCount\n        return result\n    default:\n        let letterCount = [String\
    \ : Int]()\n        test.components(separatedBy: \" \").forEach { letter in\n\
    \            letterCount[letter] = (letterCount[letter] ?? 0) + 1 as Int\n   \
    \     }\n        let maxCount = letterCount.keys.max()!\n        var maxLetter\
    \ = letterCount.keys.max()!\n        for i in 0...letterCount.keys.count {\n \
    \           let letter = letterCount.keys.sorted()[i]\n            if letterCount[letter]\
    \ > maxCount {\n                maxCount = letterCount[letter]\n             \
    \   maxLetter = letter\n            }\n        }\n        return [maxLetter: maxCount]\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b\
    \ a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"\
    a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"\
    b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\")\
    \ == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpgqxbfql2.swift:23:14: error: value of type 'String' has no member\
    \ 'components'\n        test.components(separatedBy: \" \").forEach { letter in\n\
    \        ~~~~ ^~~~~~~~~~\n/tmp/tmpgqxbfql2.swift:30:27: error: cannot convert\
    \ value of type 'Int?' to expected argument type 'Dictionary<String, Int>.Keys.Element'\
    \ (aka 'String')\n            if letterCount[letter] > maxCount {\n          \
    \                ^\n/tmp/tmpgqxbfql2.swift:31:17: error: cannot assign to value:\
    \ 'maxCount' is a 'let' constant\n                maxCount = letterCount[letter]\n\
    \                ^~~~~~~~\n/tmp/tmpgqxbfql2.swift:26:9: note: change 'let' to\
    \ 'var' to make it mutable\n        let maxCount = letterCount.keys.max()!\n \
    \       ^~~\n        var\n/tmp/tmpgqxbfql2.swift:31:39: error: cannot assign value\
    \ of type 'Int?' to type 'Dictionary<String, Int>.Keys.Element' (aka 'String')\n\
    \                maxCount = letterCount[letter]\n                           ~~~~~~~~~~~^~~~~~~~\n\
    /tmp/tmpgqxbfql2.swift:35:27: error: cannot assign value of type 'Dictionary<String,\
    \ Int>.Keys.Element' (aka 'String') to type 'Int?'\n        result[maxLetter]\
    \ = maxCount\n                          ^\n/tmp/tmpgqxbfql2.swift:39:14: error:\
    \ value of type 'String' has no member 'components'\n        test.components(separatedBy:\
    \ \" \").forEach { letter in\n        ~~~~ ^~~~~~~~~~\n/tmp/tmpgqxbfql2.swift:40:24:\
    \ error: cannot assign through subscript: 'letterCount' is a 'let' constant\n\
    \            letterCount[letter] = (letterCount[letter] ?? 0) + 1 as Int\n   \
    \         ~~~~~~~~~~~^\n/tmp/tmpgqxbfql2.swift:38:9: note: change 'let' to 'var'\
    \ to make it mutable\n        let letterCount = [String : Int]()\n        ^~~\n\
    \        var\n/tmp/tmpgqxbfql2.swift:46:27: error: cannot convert value of type\
    \ 'Int?' to expected argument type 'Dictionary<String, Int>.Keys.Element' (aka\
    \ 'String')\n            if letterCount[letter] > maxCount {\n               \
    \           ^\n/tmp/tmpgqxbfql2.swift:47:17: error: cannot assign to value: 'maxCount'\
    \ is a 'let' constant\n                maxCount = letterCount[letter]\n      \
    \          ^~~~~~~"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    histogram(test: test, symbols: nil)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpf2m2v7d1.swift:17:36: error: extra argument 'symbols' in call\n\
    \    histogram(test: test, symbols: nil)\n             ~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmpf2m2v7d1.swift:17:36: error: 'nil' requires a contextual type\n    histogram(test:\
    \ test, symbols: nil)\n                                   ^\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" { return [:] }\n    let array = test.characters.map\
    \ { String($0) }\n    let histogram = Dictionary(uniqueKeysWithValues: array.enumerated().map\
    \ {\n        ($1, test.characters.filter({ $0 == $1 }).count)\n    })\n    return\
    \ histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpjbbelwcp.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let array = test.characters.map { String($0) }\n  \
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpjbbelwcp.swift:20:37: error: contextual closure type '(String.Element)\
    \ throws -> Bool' (aka '(Character) throws -> Bool') expects 1 argument, but 2\
    \ were used in closure body\n        ($1, test.characters.filter({ $0 == $1 }).count)\n\
    \                                    ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test.components(separatedBy: \" \")\n        .sorted { $0.count\
    \ > $1.count }\n        .map { $0.trimmingCharacters(in: .whitespaces) }\n   \
    \     .map({ $0.lowercased() })\n        .enumerated().reduce(into: [:]) {\n \
    \           $1[$0.0 + $0.1.count] = $0.0 + $0.1\n        }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpumi9mthx.swift:17:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return test.components(separatedBy: \" \")\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009629
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\t\n\tlet letters = test.lowercased().characters\n\t\n\tlet charCount:\
    \ [String : Int] = [:]\n\t\n\tfor char in letters {\n\t\t\n\t\tcharCount[char]\
    \ = (charCount[char] ?? 0) + 1\n\t\t\n\t}\n\t\n\treturn charCount\n\t\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp9znbps8l.swift:18:34: error: 'characters' is unavailable: Please\
    \ use String directly\n        let letters = test.lowercased().characters\n  \
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9znbps8l.swift:24:13: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n                charCount[char]\
    \ = (charCount[char] ?? 0) + 1\n                          ^\n/tmp/tmp9znbps8l.swift:24:32:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                charCount[char] = (charCount[char] ?? 0) + 1\n              \
    \                               ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let testArray = test.split(separator: \" \") else {\n    \
    \    return [:] as [String : Int]\n    }\n\n    var counter = [String : Int]()\n\
    \    for letter in testArray {\n        guard let letterAsInt = counter[letter]\
    \ else {\n            counter[letter] = 1\n        }\n        counter[letter]!\
    \ += 1 // += since counter is a mutable dictionary\n    }\n\n    return counter\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpaymeutsw.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not '[String.SubSequence]' (aka 'Array<Substring>')\n\
    \    guard let testArray = test.split(separator: \" \") else {\n          ^  \
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpaymeutsw.swift:23:41: error:\
    \ cannot convert value of type 'String.SubSequence' (aka 'Substring') to expected\
    \ argument type 'String'\n        guard let letterAsInt = counter[letter] else\
    \ {\n                                        ^\n                             \
    \           String( )\n/tmp/tmpaymeutsw.swift:24:21: error: cannot convert value\
    \ of type 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \            counter[letter] = 1\n                    ^\n                    String(\
    \ )\n/tmp/tmpaymeutsw.swift:26:17: error: cannot convert value of type 'String.SubSequence'\
    \ (aka 'Substring') to expected argument type 'String'\n        counter[letter]!\
    \ += 1 // += since counter is a mutable dictionary\n                ^\n      \
    \          String( )\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar letters : [String : Int]\n\tvar maxCount : Int\n\t\n\tfor letter\
    \ in test.characters {\n\t\tletters[letter] = letters[letter] ?? 0\n\t\tletters[letter]\
    \ = letters[letter] + 1\n\t\tif maxCount < letters[letter] {\n\t\t\tmaxCount =\
    \ letters[letter]\n\t\t}\n\t}\n\n\treturn letters\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpaiwg0o30.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n        for letter in test.characters {\n             \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpaiwg0o30.swift:21:29: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                letters[letter] = letters[letter]\
    \ ?? 0\n                                          ^\n/tmp/tmpaiwg0o30.swift:21:11:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                letters[letter] = letters[letter] ?? 0\n                    \
    \    ^\n/tmp/tmpaiwg0o30.swift:22:28: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n                letters[letter] = letters[letter]\
    \ + 1\n                                         ^\n/tmp/tmpaiwg0o30.swift:22:28:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n                letters[letter] = letters[letter] + 1\n             \
    \                            ^\n                                  (          \
    \     ?? <#default value#>)\n/tmp/tmpaiwg0o30.swift:22:28: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        \
    \        letters[letter] = letters[letter] + 1\n                             \
    \            ^\n                                                 !\n/tmp/tmpaiwg0o30.swift:22:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                letters[letter] = letters[letter] + 1\n                     \
    \                     ^\n/tmp/tmpaiwg0o30.swift:22:11: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n                letters[letter]\
    \ = letters[letter] + 1\n                        ^\n/tmp/tmpaiwg0o30.swift:23:24:\
    \ error: no exact matches in call to subscript \n                if maxCount <\
    \ letters[letter] {\n                                     ^\n/tmp/tmpaiwg0o30.swif"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var counter = [String : Int]()\n    for ch in test {\n        counter[ch]\
    \ = (counter[ch] ?? 0) + 1\n    }\n    return counter.sorted(by: { $0.0 < $1.0\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\")\
    \ == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\"\
    \ : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\"\
    \ : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") ==\
    \ [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") ==\
    \ [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"\
    g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp1isltecu.swift:19:17: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        counter[ch] = (counter[ch] ?? 0)\
    \ + 1\n                ^\n/tmp/tmp1isltecu.swift:19:32: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        counter[ch]\
    \ = (counter[ch] ?? 0) + 1\n                               ^\n/tmp/tmp1isltecu.swift:21:20:\
    \ error: cannot convert return expression of type '[Dictionary<String, Int>.Element]'\
    \ (aka 'Array<(key: String, value: Int)>') to return type '[String : Int]'\n \
    \   return counter.sorted(by: { $0.0 < $1.0 })\n           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var count: [String : Int] = [:]\n    var result = [String]()\n \
    \   for char in test.characters {\n        if let count = count[char] {\n    \
    \        count[char] = count + 1\n        } else {\n            count[char] =\
    \ 1\n        }\n    }\n    for char in count {\n        if count[char] == 1 {\n\
    \            result.append(char)\n        }\n    }\n    if result.isEmpty {\n\
    \        return [:]\n    } else {\n        return result\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpip075ivb.swift:19:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in test.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpip075ivb.swift:20:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let count = count[char] {\n                             ^\n/tmp/tmpip075ivb.swift:23:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            count[char] = 1\n                  ^\n/tmp/tmpip075ivb.swift:27:18:\
    \ error: cannot convert value of type '(key: String, value: Int)' to expected\
    \ argument type 'String'\n        if count[char] == 1 {\n                 ^\n\
    /tmp/tmpip075ivb.swift:28:27: error: cannot convert value of type '(key: String,\
    \ value: Int)' to expected argument type 'String'\n            result.append(char)\n\
    \                          ^\n/tmp/tmpip075ivb.swift:34:16: error: cannot convert\
    \ return expression of type '[String]' to return type '[String : Int]'\n     \
    \   return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return count(test, \" \")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmphh2lzutq.swift:17:12: error: cannot find 'count' in scope\n   \
    \ return count(test, \" \")\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram: [String : Int] = [:]\n    for letter in test.characters\
    \ {\n        histogram[letter] = (histogram[letter] ?? 0) + 1\n    }\n    return\
    \ histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpwuw_67am.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in test.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpwuw_67am.swift:19:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        histogram[letter] = (histogram[letter] ?? 0) + 1\n                  ^\n\
    /tmp/tmpwuw_67am.swift:19:40: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        histogram[letter] = (histogram[letter]\
    \ ?? 0) + 1\n                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var results = [String : Int]()\n    for c in test.characters {\n\
    \        if let count = results[c] {\n            results[c] = count + 1\n   \
    \     } else {\n            results[c] = 1\n        }\n    }\n    return results\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpvvgom6z4.swift:18:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in test.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpvvgom6z4.swift:19:32:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let count = results[c] {\n                               ^\n/tmp/tmpvvgom6z4.swift:20:21:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            results[c] = count + 1\n                    ^\n/tmp/tmpvvgom6z4.swift:22:21:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            results[c] = 1\n                    ^\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    // get all letters found in the test\n    let characters = test.characters\n\
    \    var result: [String : Int] = [:]\n\n    // loop through all the letters\n\
    \    for let character in characters {\n        // if the letter doesn't exist\
    \ in our result, add it\n        if result[character] == nil {\n            result[character]\
    \ = 1\n        } else {\n            // if the letter exists in our result, increment\
    \ the count\n            result[character]!++\n        }\n    }\n\n    // return\
    \ the result\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp5jcpskaa.swift:22:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let character in characters {\n   \
    \     ^\n/tmp/tmp5jcpskaa.swift:18:27: error: 'characters' is unavailable: Please\
    \ use String directly\n    let characters = test.characters\n                \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp5jcpskaa.swift:24:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if result[character] == nil {\n\
    \                  ^\n/tmp/tmp5jcpskaa.swift:25:20: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            result[character]\
    \ = 1\n                   ^\n/tmp/tmp5jcpskaa.swift:28:31: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            result[character]!++\n\
    \                              ^~\n/tmp/tmp5jcpskaa.swift:28:20: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       result[character]!++\n                   ^\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram: [String: Int] = [:]\n    for letter in test.lowercaseString.characters\
    \ {\n        histogram[letter] = (histogram[letter] ?? 0) + 1\n    }\n    return\
    \ histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpxthg3d1c.swift:18:24: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    for letter in test.lowercaseString.characters {\n   \
    \               ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    // Split on whitespace.\n    let testArray = test.split(separator:\
    \ \" \")\n\n    // For each word, count how many times it occurs.\n    var histogram:\
    \ [String : Int] = [:]\n    for word in testArray {\n        if let count = histogram[word]\
    \ {\n            // Increment by one, and keep track of the old value.\n     \
    \       histogram[word] = count + 1\n        } else {\n            // First time\
    \ seeing this word, so set its count to one.\n            histogram[word] = 1\n\
    \        }\n    }\n\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpmj7klika.swift:23:34: error: cannot convert value of type 'String.SubSequence'\
    \ (aka 'Substring') to expected argument type 'String'\n        if let count =\
    \ histogram[word] {\n                                 ^\n                    \
    \             String( )\n/tmp/tmpmj7klika.swift:25:23: error: cannot convert value\
    \ of type 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \            histogram[word] = count + 1\n                      ^\n          \
    \            String( )\n/tmp/tmpmj7klika.swift:28:23: error: cannot convert value\
    \ of type 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \            histogram[word] = 1\n                      ^\n                  \
    \    String( )\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let letters = test.characters.filter { $0 != ' ' }\n    return letters.enumerated().reduce(into:\
    \ [String : Int]()) { (result, element) in\n        var count = result[(element.element)!]!\n\
    \        result[(element.element)!] = (count + 1)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpffubgmy9.swift:17:50: error: single-quoted string literal found,\
    \ use '\"'\n    let letters = test.characters.filter { $0 != ' ' }\n         \
    \                                        ^~~\n                               \
    \                  \" \"\n/tmp/tmpffubgmy9.swift:17:24: error: 'characters' is\
    \ unavailable: Please use String directly\n    let letters = test.characters.filter\
    \ { $0 != ' ' }\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpffubgmy9.swift:19:45: error: cannot convert value of\
    \ type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        var count = result[(element.element)!]!\n                           \
    \                 ^\n/tmp/tmpffubgmy9.swift:19:45: error: cannot force unwrap\
    \ value of non-optional type 'String.Element' (aka 'Character')\n        var count\
    \ = result[(element.element)!]!\n                           ~~~~~~~~~~~~~~~~~^\n\
    \                                            \n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tcounts := [String : Int]()\n\tfor c := range test {\n\t\tcounts[test[c]]\
    \ = counts[test[c]] + 1\n\t}\n\tvar letters []String = [:] // TODO: Swift 2.0\n\
    \tfor c := range counts {\n\t\tletters = append(letters, String(test[c]))\n\t\
    }\n\treturn counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpjolmm_03.swift:17:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        counts := [String : Int]()\n              ^\n \
    \             ;\n/tmp/tmpjolmm_03.swift:17:9: error: expected expression\n   \
    \     counts := [String : Int]()\n               ^\n/tmp/tmpjolmm_03.swift:18:9:\
    \ error: expected type\n        for c := range test {\n               ^\n    \
    \            <#type#>\n/tmp/tmpjolmm_03.swift:18:9: error: expected 'in' after\
    \ for-each pattern\n        for c := range test {\n               ^\n/tmp/tmpjolmm_03.swift:18:9:\
    \ error: expected Sequence expression for for-each loop\n        for c := range\
    \ test {\n               ^\n/tmp/tmpjolmm_03.swift:21:13: error: consecutive statements\
    \ on a line must be separated by ';'\n        var letters []String = [:] // TODO:\
    \ Swift 2.0\n                   ^\n                   ;\n/tmp/tmpjolmm_03.swift:21:16:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ letters []String = [:] // TODO: Swift 2.0\n                      ^\n       \
    \               ;\n/tmp/tmpjolmm_03.swift:22:9: error: expected type\n       \
    \ for c := range counts {\n               ^\n                <#type#>\n/tmp/tmpjolmm_03.swift:22:9:\
    \ error: expected 'in' after for-each pattern\n        for c := range counts {\n\
    \               ^\n/tmp/tmpjolmm_03.swift:22:9: error: expected Sequence expression\
    \ for for-each loop\n        for c := range counts {\n               ^\n/tmp/tmpjolmm_03.swift:17:2:\
    \ error: cannot find 'counts' in scope\n        counts := [String : Int]()\n \
    \       ^~~~~~\n/tmp/tmpjolmm_03.swift:21:6: error: type annotation missing in\
    \ pattern\n        var letters []String = [:] // TODO: Swift 2.0\n           \
    \ ^\n/tmp/tmpjolmm_03.swift:21:14: error: empty collection literal requires an\
    \ explicit type\n        var letters []String = [:] // TODO: Swift 2.0\n     \
    \               ^~\n/tmp/tmpjolmm_03.swift:21:14: warning: expression of type\
    \ '[Any]' is unused\n        var letters []String = [:] // TODO: Swift 2.0\n \
    \                   ^~\n/tmp/tmpjolmm_03.swift:21:16: error: cannot assign to\
    \ immutable expr"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar maxCount = 0\n\tvar maxLetter = [String: Int]()\n\tfor char in\
    \ test.characters {\n\t\tletterCount := 0\n\t\tif let letter = maxLetter[char]\
    \ {\n\t\t\tletterCount = letter + 1\n\t\t}\n\t\tif letterCount > maxCount {\n\t\
    \t\tmaxCount = letterCount\n\t\t\tmaxLetter[char] = letterCount\n\t\t}\n\t}\n\t\
    return maxLetter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpl56eovw1.swift:20:14: error: consecutive statements on a line must\
    \ be separated by ';'\n                letterCount := 0\n                    \
    \       ^\n                           ;\n/tmp/tmpl56eovw1.swift:20:15: error:\
    \ expected expression\n                letterCount := 0\n                    \
    \        ^\n/tmp/tmpl56eovw1.swift:19:19: error: 'characters' is unavailable:\
    \ Please use String directly\n        for char in test.characters {\n        \
    \                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpl56eovw1.swift:20:3: error: cannot find 'letterCount' in scope\n\
    \                letterCount := 0\n                ^~~~~~~~~~~\n/tmp/tmpl56eovw1.swift:21:29:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                if let letter = maxLetter[char] {\n                         \
    \                 ^\n/tmp/tmpl56eovw1.swift:22:4: error: cannot find 'letterCount'\
    \ in scope\n                        letterCount = letter + 1\n               \
    \         ^~~~~~~~~~~\n/tmp/tmpl56eovw1.swift:24:6: error: cannot find 'letterCount'\
    \ in scope\n                if letterCount > maxCount {\n                   ^~~~~~~~~~~\n\
    /tmp/tmpl56eovw1.swift:25:15: error: cannot find 'letterCount' in scope\n    \
    \                    maxCount = letterCount\n                                \
    \   ^~~~~~~~~~~\n/tmp/tmpl56eovw1.swift:26:22: error: cannot find 'letterCount'\
    \ in scope\n                        maxLetter[char] = letterCount\n          \
    \                                ^~~~~~~~~~~\n/tmp/tmpl56eovw1.swift:26:14: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                        maxLetter[char] = letterCount\n                     \
    \             ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let letters = test.characters.flatMap { String($0) }\n    return\
    \ Dictionary(uniqueKeysWithValues: letters.enumerated().map { ($0, letters.filter{$0\
    \ == $1}).count) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp9u4npq9j.swift:18:108: error: consecutive statements on a line\
    \ must be separated by ';'\n    return Dictionary(uniqueKeysWithValues: letters.enumerated().map\
    \ { ($0, letters.filter{$0 == $1}).count) })\n                               \
    \                                                                            ^\n\
    \                                                                            \
    \                               ;\n/tmp/tmp9u4npq9j.swift:18:108: error: expected\
    \ expression\n    return Dictionary(uniqueKeysWithValues: letters.enumerated().map\
    \ { ($0, letters.filter{$0 == $1}).count) })\n                               \
    \                                                                            ^\n\
    /tmp/tmp9u4npq9j.swift:17:24: error: 'characters' is unavailable: Please use String\
    \ directly\n    let letters = test.characters.flatMap { String($0) }\n       \
    \                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp9u4npq9j.swift:18:91: error: contextual closure type '(String.Element)\
    \ throws -> Bool' (aka '(Character) throws -> Bool') expects 1 argument, but 2\
    \ were used in closure body\n    return Dictionary(uniqueKeysWithValues: letters.enumerated().map\
    \ { ($0, letters.filter{$0 == $1}).count) })\n                               \
    \                                                           ^\n/tmp/tmp9u4npq9j.swift:18:103:\
    \ error: value of tuple type '(EnumeratedSequence<[String.Element]>.Iterator.Element,\
    \ [String.Element])' (aka '((offset: Int, element: Character), Array<Character>)')\
    \ has no member 'count'\n    return Dictionary(uniqueKeysWithValues: letters.enumerated().map\
    \ { ($0, letters.filter{$0 == $1}).count) })\n                               \
    \                                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters = test.split(\" \")\n    var histo = [String : Int]()\n\
    \    for letter in letters {\n        if histo[letter] == nil {\n            histo[letter]\
    \ = 1\n        } else {\n            histo[letter]++\n        }\n    }\n    return\
    \ histo\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b\
    \ a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"\
    a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"\
    b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\")\
    \ == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpf17uz519.swift:17:24: error: no exact matches in call to instance\
    \ method 'split'\n    var letters = test.split(\" \")\n                      \
    \ ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [:]\n    }\n\n    var map = [:]\n\
    \    var testChars = test.unicodeScalars.map { $0.value }\n\n    for char in testChars\
    \ {\n        if let count = map[char] {\n            map[char] = count + 1\n \
    \       } else {\n            map[char] = 1\n        }\n    }\n\n    return map\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpjjmxl1of.swift:21:15: error: empty collection literal requires\
    \ an explicit type\n    var map = [:]\n              ^~~\n/tmp/tmpjjmxl1of.swift:26:25:\
    \ error: cannot convert value of type 'Any' to expected argument type 'Int'\n\
    \            map[char] = count + 1\n                        ^\n              \
    \                as! Int\n/tmp/tmpjjmxl1of.swift:32:12: error: cannot convert\
    \ return expression of type '[AnyHashable : Any]' to return type '[String : Int]'\n\
    \    return map\n           ^\n/tmp/tmpjjmxl1of.swift:32:12: note: arguments to\
    \ generic parameter 'Key' ('AnyHashable' and 'String') are expected to be equal\n\
    \    return map\n           ^\n/tmp/tmpjjmxl1of.swift:32:12: note: arguments to\
    \ generic parameter 'Value' ('Any' and 'Int') are expected to be equal\n    return\
    \ map\n           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n  var result = Dictionary<String, Int>()\n\n  for word in test.split(\"\
    \ \") {\n    guard let letter = word.removeFirst(), letter != \"\" else { return\
    \ result }\n    result[letter] = (result[letter] ?? 0) + 1\n  }\n\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7q0qmwse.swift:19:20: error: no exact matches in call to instance\
    \ method 'split'\n  for word in test.split(\" \") {\n                   ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var (max, histograms): [String : Int] = [:]\n    for i in test.split(\"\
    \ \") {\n        let currentCount = histograms![i] ?? 0\n        histograms![i]\
    \ += currentCount\n        if currentCount > max {\n            max = currentCount\n\
    \        }\n    }\n    return histograms\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpu58_j2ks.swift:17:9: error: tuple pattern cannot match values of\
    \ the non-tuple type '[String : Int]'\n    var (max, histograms): [String : Int]\
    \ = [:]\n        ^\n/tmp/tmpu58_j2ks.swift:18:19: error: no exact matches in call\
    \ to instance method 'split'\n    for i in test.split(\" \") {\n             \
    \     ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram(strings.Split(test).reduce([String : Int]()) {\
    \ counts, letter in\n        counts[letter] = (counts[letter] ?? 0) + 1;\n   \
    \     return counts;\n    });\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp877uqg1l.swift:17:22: error: cannot find 'strings' in scope\n \
    \   return histogram(strings.Split(test).reduce([String : Int]()) { counts, letter\
    \ in\n                     ^~~~~~~\n/tmp/tmp877uqg1l.swift:17:22: error: missing\
    \ argument label 'test:' in call\n    return histogram(strings.Split(test).reduce([String\
    \ : Int]()) { counts, letter in\n                     ^\n                    \
    \ test: \n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var h = [String : Int]()\n    test.split(\" \").forEach { a in\n\
    \        h[a.lowercased()] = h[a.lowercased()] ?? 0\n        h[a.lowercased()]\
    \ += 1 }\n    return h\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmps8sz2tsz.swift:18:16: error: missing argument label 'separator:'\
    \ in call\n    test.split(\" \").forEach { a in\n               ^\n          \
    \     separator: \n/tmp/tmps8sz2tsz.swift:20:10: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n        h[a.lowercased()]\
    \ += 1 }\n         ^\n/tmp/tmps8sz2tsz.swift:20:10: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        h[a.lowercased()]\
    \ += 1 }\n         ^\n                         !\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tlet count = test.characters.reduce(into: [String : Int](), { (result,\
    \ char) in\n\t\tresult[char] = (result[char] ?? 0) + 1\n\t\tif result[char] >\
    \ result[String(result[char])] {\n\t\t\tresult[char] = result[String(result[char])]\n\
    \t\t}\n\t})\n\treturn count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp1us94ynm.swift:18:10: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n                result[char]\
    \ = (result[char] ?? 0) + 1\n                       ^\n/tmp/tmp1us94ynm.swift:18:26:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n                result[char] = (result[char] ?? 0) +\
    \ 1\n                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test.split(\" \").filter({ $0 }).reduce([String : Int]())\
    \ {\n        guard let index = self[$0] else { return $0 }\n        self[$0] =\
    \ (index + 1, $0)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpg35kzpff.swift:18:27: error: cannot find 'self' in scope; did you\
    \ mean to use it in a type or extension context?\n        guard let index = self[$0]\
    \ else { return $0 }\n                          ^~~~\n/tmp/tmpg35kzpff.swift:19:9:\
    \ error: cannot find 'self' in scope; did you mean to use it in a type or extension\
    \ context?\n        self[$0] = (index + 1, $0)\n        ^~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if isEmpty(test) {\n        return [:]\n    }\n    var histogram\
    \ = [String : Int]()\n    var count: Int = 0\n    var letter: String? = nil\n\
    \    for character in test.lowercased() {\n        if let count = histogram[character]\
    \ {\n            histogram[character] = count + 1\n        } else {\n        \
    \    histogram[character] = 1\n            count += 1\n            letter = character\n\
    \        }\n    }\n    if let count = histogram[letter!] {\n        histogram[letter!]\
    \ = count + 1\n    } else {\n        histogram[letter!] = 1\n    }\n    return\
    \ histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp8tbrroa1.swift:17:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(test) {\n       ^~~~~~~\n/tmp/tmp8tbrroa1.swift:24:34: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   if let count = histogram[character] {\n                                 ^\n\
    /tmp/tmp8tbrroa1.swift:25:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            histogram[character] = count\
    \ + 1\n                      ^\n/tmp/tmp8tbrroa1.swift:27:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            histogram[character]\
    \ = 1\n                      ^\n/tmp/tmp8tbrroa1.swift:29:20: error: cannot assign\
    \ value of type 'Character' to type 'String?'\n            letter = character\n\
    \                   ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return reduce(test).sorted { $0.key < $1.key }.map { $0.key }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpgf5mw45g.swift:17:12: error: cannot find 'reduce' in scope\n  \
    \  return reduce(test).sorted { $0.key < $1.key }.map { $0.key }\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var maxCount = 0\n    var maxLetter = \"\"\n    var letterCount\
    \ = [String: Int]()\n\n    var letters = test.characters()\n\n    for letter in\
    \ letters {\n        letterCount[letter] = (letterCount[letter] ?? 0) + 1\n\n\
    \        if letterCount[letter] > maxCount {\n            maxCount = letterCount[letter]\n\
    \            maxLetter = letter\n        }\n    }\n\n    return letterCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpojk4c1pg.swift:21:24: error: cannot call value of non-function\
    \ type 'String'\n    var letters = test.characters()\n                       ^\
    \         ~~\n                                 \n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar letters = test.split(\" \")\n\tvar freqs: [String : Int] = [ :\
    \ ]\n\n\tfor letter in letters {\n\t\tif let index = freqs.index(forKey: letter)\
    \ {\n\t\t\tfreqs[index] = freqs[index] + 1\n\t\t} else {\n\t\t\tfreqs[letter]\
    \ = 1\n\t\t}\n\t}\n\n\treturn freqs\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpnpyj8yvg.swift:17:21: error: no exact matches in call to instance\
    \ method 'split'\n        var letters = test.split(\" \")\n                  \
    \         ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = Dictionary<String, Int>()\n    var letters: [String]\
    \ = []\n    test.split(\" \").forEach { letter in\n        guard letter.characters.count\
    \ > 0 else { return }\n        letters.append(letter)\n        histogram[letter]\
    \ = (histogram[letter] ?? 0) + 1\n    }\n    letters = letters.sorted { $0 < $1\
    \ }\n\n    return letters\n        .prefix(2)\n        .flatMap { histogram[$0]\
    \ ?? 0 }\n        .reduce(into: [:]) { (result, count) in\n            result[String(count)]\
    \ = count\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpcghqposv.swift:19:16: error: missing argument label 'separator:'\
    \ in call\n    test.split(\" \").forEach { letter in\n               ^\n     \
    \          separator: \n/tmp/tmpcghqposv.swift:21:24: error: cannot convert value\
    \ of type 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \        letters.append(letter)\n                       ^\n                  \
    \     String( )\n/tmp/tmpcghqposv.swift:28:10: warning: 'flatMap' is deprecated:\
    \ Please use compactMap(_:) for the case where closure returns an optional value\n\
    \        .flatMap { histogram[$0] ?? 0 }\n         ^\n/tmp/tmpcghqposv.swift:28:10:\
    \ note: use 'compactMap(_:)' instead\n        .flatMap { histogram[$0] ?? 0 }\n\
    \         ^~~~~~~\n         compactMap\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    for s in test.split(\" \"\
    ) {\n        if let i = histogram[s] {\n            histogram[s] += 1\n      \
    \  } else {\n            histogram[s] = 1\n        }\n    }\n    return histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpgknwbdpt.swift:18:19: error: no exact matches in call to instance\
    \ method 'split'\n    for s in test.split(\" \") {\n                  ^\nSwift.Sequence:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tresult := [:]\n\tfor _, letter := range test {\n\t\tif _, ok := result[letter];\
    \ !ok {\n\t\t\tresult[letter] = 1\n\t\t} else {\n\t\t\tresult[letter] += 1\n\t\
    \t}\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp17bfpo6e.swift:17:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := [:]\n              ^\n              ;\n\
    /tmp/tmp17bfpo6e.swift:17:9: error: expected expression\n        result := [:]\n\
    \               ^\n/tmp/tmp17bfpo6e.swift:18:7: error: expected 'in' after for-each\
    \ pattern\n        for _, letter := range test {\n             ^\n/tmp/tmp17bfpo6e.swift:18:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, letter\
    \ := range test {\n             ^\n/tmp/tmp17bfpo6e.swift:19:12: error: expected\
    \ '{' after 'if' condition\n                if _, ok := result[letter]; !ok {\n\
    \                         ^\n/tmp/tmp17bfpo6e.swift:17:2: error: cannot find 'result'\
    \ in scope\n        result := [:]\n        ^~~~~~\n/tmp/tmp17bfpo6e.swift:25:9:\
    \ error: cannot find 'result' in scope\n        return result\n              \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var dictionary: [String : Int] = [:]\n    var maxCount: Int = 0\n\
    \    for letter in test.split(\" \") {\n        guard let count = dictionary[letter]\
    \ else {\n            dictionary[letter] = 1\n            maxCount = 1\n     \
    \       continue\n        }\n        dictionary[letter] = count + 1\n        maxCount\
    \ = max(maxCount, count)\n    }\n    if maxCount <= 0 {\n        return [:]\n\
    \    }\n    return dictionary.map { (letter, count) -> (String, Int) in\n    \
    \    return (letter, count)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpty9u_3n3.swift:19:24: error: no exact matches in call to instance\
    \ method 'split'\n    for letter in test.split(\" \") {\n                    \
    \   ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n/tmp/tmpty9u_3n3.swift:31:23: error:\
    \ cannot convert return expression of type '[(String, Int)]' to return type '[String\
    \ : Int]'\n    return dictionary.map { (letter, count) -> (String, Int) in\n \
    \          ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tguard let words = test.components(separatedBy: \" \").filter({ !$0.isEmpty\
    \ }) else {\n\t\treturn [:]\n\t}\n\t\n\tlet maxLetter = words.reduce(0) { (max:\
    \ Int, current: String) -> Int in\n\t\treturn max(max, current.unicodeScalars.filter({\
    \ $0.isLower }).count)\n\t}\n\t\n\treturn words.reduce(into: [String : Int](),\
    \ { (acc, cur, ind) -> ([String : Int], Int, Int) -> [String : Int] in\n\t\tacc[ind]\
    \ = ind == words.count - 1 ? maxLetter : acc[ind] + 1\n\t\treturn acc\n\t})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpg0ine6mw.swift:17:25: error: value of type 'String' has no member\
    \ 'components'\n        guard let words = test.components(separatedBy: \" \").filter({\
    \ !$0.isEmpty }) else {\n                          ~~~~ ^~~~~~~~~~\n/tmp/tmpg0ine6mw.swift:22:10:\
    \ error: cannot call value of non-function type 'Int'\n                return\
    \ max(max, current.unicodeScalars.filter({ $0.isLower }).count)\n            \
    \           ^\n/tmp/tmpg0ine6mw.swift:22:54: error: value of type 'Unicode.Scalar'\
    \ has no member 'isLower'\n                return max(max, current.unicodeScalars.filter({\
    \ $0.isLower }).count)\n                                                     \
    \           ~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    // TODO: make this faster\n    var histogram = [:]\n    for letter\
    \ in\n        test.unicodeScalars.map {\n        String($0).unicodeScalars.map\
    \ {\n            histogram[$0] = (histogram[$0] ?? 0) + 1\n        }\n    }\n\
    \    \n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp8x_ewjs3.swift:21:16: error: anonymous closure argument not contained\
    \ in a closure\n        String($0).unicodeScalars.map {\n               ^\n/tmp/tmp8x_ewjs3.swift:18:21:\
    \ error: empty collection literal requires an explicit type\n    var histogram\
    \ = [:]\n                    ^~~\n/tmp/tmp8x_ewjs3.swift:20:14: error: generic\
    \ parameter 'T' could not be inferred\n        test.unicodeScalars.map {\n   \
    \          ^\nSwift.Collection:2:28: note: in call to function 'map'\n    @inlinable\
    \ public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n\
    \                           ^\n/tmp/tmp8x_ewjs3.swift:20:29: error: for-in loop\
    \ requires '((Unicode.Scalar) throws -> T) throws -> [T]' to conform to 'Sequence'\n\
    \        test.unicodeScalars.map {\n        ~~~~~~~~~~~~~~~~~~~~^~~\n/tmp/tmp8x_ewjs3.swift:26:12:\
    \ error: cannot convert return expression of type '[AnyHashable : Any]' to return\
    \ type '[String : Int]'\n    return histogram\n           ^\n/tmp/tmp8x_ewjs3.swift:26:12:\
    \ note: arguments to generic parameter 'Key' ('AnyHashable' and 'String') are\
    \ expected to be equal\n    return histogram\n           ^\n/tmp/tmp8x_ewjs3.swift:26:12:\
    \ note: arguments to generic parameter 'Value' ('Any' and 'Int') are expected\
    \ to be equal\n    return histogram\n           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram: [String : Int] = [:]\n    for letter in test.lowercased()\
    \ {\n        histogram[letter] = (histogram[letter]!) ?? 0\n        histogram[letter]!++\n\
    \    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp81fuerxm.swift:19:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        histogram[letter] = (histogram[letter]!)\
    \ ?? 0\n                  ^\n/tmp/tmp81fuerxm.swift:19:40: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        histogram[letter]\
    \ = (histogram[letter]!) ?? 0\n                                       ^\n/tmp/tmp81fuerxm.swift:20:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        histogram[letter]!++\n\
    \                          ^~\n/tmp/tmp81fuerxm.swift:20:19: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        histogram[letter]!++\n\
    \                  ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n    for c in test.characters.sorted()\
    \ {\n        let index = result[c] ?? 0\n        result[c] = index + 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7u4kgjtg.swift:18:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in test.characters.sorted() {\n             \
    \     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp7u4kgjtg.swift:19:28:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n        let index = result[c] ?? 0\n               \
    \            ^\n/tmp/tmp7u4kgjtg.swift:20:16: error: cannot convert value of type\
    \ 'String.Element' (aka 'Character') to expected argument type 'String'\n    \
    \    result[c] = index + 1\n               ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    var letters = [Character]()\n\
    \    var maxCount = 0\n    for char in test.characters {\n        letters.append(char)\n\
    \        if histogram[String(char)] ?? 0 == 0 {\n            histogram[String(char)]\
    \ -= 1\n        } else {\n            histogram[String(char)] += 1\n        }\n\
    \        if histogram[String(char)] > maxCount {\n            maxCount = histogram[String(char)]\n\
    \        }\n    }\n    for (char, count) in histogram {\n        if maxCount <\
    \ count {\n            letters.removeAll()\n            histogram[String(char)]\
    \ = count\n        }\n    }\n    \n    return letters.map { String($0) : histogram[String($0)]\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\")\
    \ == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\"\
    \ : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\"\
    \ : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") ==\
    \ [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") ==\
    \ [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"\
    g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp6sq4bgzd.swift:38:36: error: consecutive statements on a line must\
    \ be separated by ';'\n    return letters.map { String($0) : histogram[String($0)]\
    \ }\n                                   ^\n                                  \
    \ ;\n/tmp/tmp6sq4bgzd.swift:38:37: error: expected expression\n    return letters.map\
    \ { String($0) : histogram[String($0)] }\n                                   \
    \ ^\n/tmp/tmp6sq4bgzd.swift:20:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in test.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp6sq4bgzd.swift:23:22:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            histogram[String(char)] -= 1\n                     ^\n/tmp/tmp6sq4bgzd.swift:23:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            histogram[String(char)] -= 1\n                     ^\n  \
    \                                 !\n/tmp/tmp6sq4bgzd.swift:25:22: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \     histogram[String(char)] += 1\n                     ^\n/tmp/tmp6sq4bgzd.swift:25:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            histogram[String(char)] += 1\n                     ^\n  \
    \                                 !\n/tmp/tmp6sq4bgzd.swift:27:21: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ if histogram[String(char)] > maxCount {\n                    ^\n/tmp/tmp6sq4bgzd.swift:27:21:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if histogram[String(char)] > maxCount {\n                   \
    \ ^\n                                   ?? <#default value#>\n/tmp/tmp6sq4bgzd.swift:27:21:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        if histogram[String(char)] > maxCount {\n        "
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let alphabet = Dictionary(grouping: test, by: { String($0) })\n\
    \    return alphabet.map{ $0.key }.sorted {\n        if $1 == ($0 as NSString).lowercased()\
    \ {\n            return false\n        }\n        return true\n    }.map {\n \
    \       String($0): Int($1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpg4rcw40g.swift:24:19: error: consecutive statements on a line must\
    \ be separated by ';'\n        String($0): Int($1)\n                  ^\n    \
    \              ;\n/tmp/tmpg4rcw40g.swift:24:19: error: expected expression\n \
    \       String($0): Int($1)\n                  ^\n/tmp/tmpg4rcw40g.swift:19:25:\
    \ error: cannot find type 'NSString' in scope\n        if $1 == ($0 as NSString).lowercased()\
    \ {\n                        ^~~~~~~~\n/tmp/tmpg4rcw40g.swift:23:7: error: cannot\
    \ convert return expression of type '[String]' to return type '[String : Int]'\n\
    \    }.map {\n~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n    var charArray = test.characters.map\
    \ { String($0) }\n    charArray.enumerated().forEach { index, char in\n      \
    \  let count = charArray.filter({ $0 == char }).count\n        result[char] =\
    \ count\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp4hawf87d.swift:18:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    var charArray = test.characters.map { String($0) }\n\
    \                         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp4hawf87d.swift:18:9: warning: variable 'charArray' was\
    \ never mutated; consider changing to 'let' constant\n    var charArray = test.characters.map\
    \ { String($0) }\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result : [String : Int] = [:]\n    test.characters.forEach {\
    \ c in\n        let i = result[c]\n        result[c] = i + 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpzczt4b9u.swift:19:23: error: no exact matches in call to subscript\
    \ \n        let i = result[c]\n                      ^\nSwift.Dictionary:8:23:\
    \ note: candidate expects value of type 'Dictionary<String, Int>.Index' for parameter\
    \ #1 (got 'String.Element' (aka 'Character'))\n    @inlinable public subscript(position:\
    \ Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Element { get }\n  \
    \                    ^\nSwift.Dictionary:2:23: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'String.Element' (aka 'Character'))\n  \
    \  @inlinable public subscript(key: Key) -> Value? { get set }\n             \
    \         ^\nSwift.Collection:2:23: note: candidate expects value of type 'Range<Dictionary<String,\
    \ Int>.Index>' for parameter #1 (got 'String.Element' (aka 'Character'))\n   \
    \ @inlinable public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get\
    \ }\n                      ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'String.Element' (aka\
    \ 'Character'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    var testChars = test.characters\n\
    \    for char in testChars {\n        if let count = histogram[char] {\n     \
    \       histogram[char] = count + 1\n        } else {\n            histogram[char]\
    \ = 1\n        }\n    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpfox3mzi8.swift:18:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    var testChars = test.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpfox3mzi8.swift:20:34:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let count = histogram[char] {\n                                 ^\n\
    /tmp/tmpfox3mzi8.swift:21:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            histogram[char] = count + 1\n\
    \                      ^\n/tmp/tmpfox3mzi8.swift:23:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            histogram[char]\
    \ = 1\n                      ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tcounts := [String : Int]()\n\tfor _, c := range test {\n\t\tif _,\
    \ ok := counts[c]; !ok {\n\t\t\tcounts[c] = 0\n\t\t}\n\t\tcounts[c]++\n\t}\n\t\
    return counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpio997tno.swift:17:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        counts := [String : Int]()\n              ^\n \
    \             ;\n/tmp/tmpio997tno.swift:17:9: error: expected expression\n   \
    \     counts := [String : Int]()\n               ^\n/tmp/tmpio997tno.swift:18:7:\
    \ error: expected 'in' after for-each pattern\n        for _, c := range test\
    \ {\n             ^\n/tmp/tmpio997tno.swift:18:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, c := range test {\n             ^\n/tmp/tmpio997tno.swift:19:12:\
    \ error: expected '{' after 'if' condition\n                if _, ok := counts[c];\
    \ !ok {\n                         ^\n/tmp/tmpio997tno.swift:17:2: error: cannot\
    \ find 'counts' in scope\n        counts := [String : Int]()\n        ^~~~~~\n\
    /tmp/tmpio997tno.swift:24:9: error: cannot find 'counts' in scope\n        return\
    \ counts\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return countString(test, \" \").sorted(by: { $0.1 > $1.1 }).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp62bge__7.swift:17:12: error: cannot find 'countString' in scope\n\
    \    return countString(test, \" \").sorted(by: { $0.1 > $1.1 }).reversed()\n\
    \           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test(\" \")\n        .split(\" \")\n        .filter({ !$0.isEmpty\
    \ })\n        .map {\n            String($0)\n        }\n        .map {\n    \
    \        String($0).lowercased()\n        }\n        .reduce([String : Int](),\
    \ { $0[$1] = $0[$1] + 1 })\n        .sorted(by: { $0.value > $1.value })\n   \
    \     .map({ $0.key })\n        .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n        .map({ String($0) })\n        .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n        .map({ String($0) })\n        .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n        .map({ String($0) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpm9r0cnoy.swift:29:41: error: cannot find 'NSComparisonResult' in\
    \ scope\n        .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n                                        ^~~~~~~~~~~~~~~~~~\n/tmp/tmpm9r0cnoy.swift:31:41:\
    \ error: cannot find 'NSComparisonResult' in scope\n        .sorted(by: { $0.compare($1)\
    \ == NSComparisonResult.OrderedAscending })\n                                \
    \        ^~~~~~~~~~~~~~~~~~\n/tmp/tmpm9r0cnoy.swift:33:41: error: cannot find\
    \ 'NSComparisonResult' in scope\n        .sorted(by: { $0.compare($1) == NSComparisonResult.OrderedAscending\
    \ })\n                                        ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard !test.isEmpty else {\n        return [ : ]\n    }\n    \n\
    \    var histogram = [String : Int]()\n    var letters = test.characters\n   \
    \ while !letters.isEmpty {\n        let letter = letters.removeLast()\n      \
    \  let count = histogram.countValue(forKey: String(letter)) ?? 0\n        histogram[letter]\
    \ = histogram.updateValue(count + 1, forKey: String(letter))\n    }\n    return\
    \ histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpsef4n_2u.swift:22:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    var letters = test.characters\n                   \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsef4n_2u.swift:25:31:\
    \ error: value of type '[String : Int]' has no member 'countValue'\n        let\
    \ count = histogram.countValue(forKey: String(letter)) ?? 0\n                \
    \    ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpsef4n_2u.swift:26:19: error: cannot convert\
    \ value of type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        histogram[letter] = histogram.updateValue(count + 1, forKey: String(letter))\n\
    \                  ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if isEmpty(test) {\n        return []\n    }\n    var maxCount =\
    \ 0\n    var result: [String : Int] = [:]\n    for char in test.lowercaseString.split(separator:\
    \ \"a\") {\n        if let count = result[char] {\n            count += count\n\
    \        } else {\n            result[char] = 1\n        }\n        if count ==\
    \ maxCount {\n            for (key, value) in result {\n                if value\
    \ == maxCount {\n                    result.removeValue(forKey: key)\n       \
    \             break\n                }\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.1 < $1.1 }).reversed().reduce(into: [String : Int](),\
    \ { (_, item) in item[\"key\"] = item[\"value\"]; item; })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpo9iw5hpp.swift:17:8: error: cannot find 'isEmpty' in scope\n  \
    \  if isEmpty(test) {\n       ^~~~~~~\n/tmp/tmpo9iw5hpp.swift:18:16: error: use\
    \ [:] to get an empty dictionary literal\n        return []\n               ^\n\
    \                :\n/tmp/tmpo9iw5hpp.swift:22:22: error: value of type 'String'\
    \ has no member 'lowercaseString'\n    for char in test.lowercaseString.split(separator:\
    \ \"a\") {\n                ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpo9iw5hpp.swift:37:108:\
    \ error: cannot access element using subscript for tuple type 'ReversedCollection<[Dictionary<String,\
    \ Int>.Element]>.Element' (aka '(key: String, value: Int)'); did you mean to use\
    \ '.key'?\n    return result.sorted(by: { $0.1 < $1.1 }).reversed().reduce(into:\
    \ [String : Int](), { (_, item) in item[\"key\"] = item[\"value\"]; item; })\n\
    \                                                                            \
    \                               ^~~~~~~\n                                    \
    \                                                                       .key\n\
    /tmp/tmpo9iw5hpp.swift:37:122: error: cannot access element using subscript for\
    \ tuple type 'ReversedCollection<[Dictionary<String, Int>.Element]>.Element' (aka\
    \ '(key: String, value: Int)'); did you mean to use '.value'?\n    return result.sorted(by:\
    \ { $0.1 < $1.1 }).reversed().reduce(into: [String : Int](), { (_, item) in item[\"\
    key\"] = item[\"value\"]; item; })\n                                         \
    \                                                                            \
    \    ^~~~~~~~~\n                                                             \
    \                                                            .value\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return []\n    }\n    return test.split(\"\
    \ \").compactMap({ String($0).lowercased() }).reduce([String : Int]()) { (res,\
    \ v) in\n        res[v] = res[v] + 1\n        return res\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp21ebgmqx.swift:18:16: error: use [:] to get an empty dictionary\
    \ literal\n        return []\n               ^\n                :\n/tmp/tmp21ebgmqx.swift:20:23:\
    \ error: missing argument label 'separator:' in call\n    return test.split(\"\
    \ \").compactMap({ String($0).lowercased() }).reduce([String : Int]()) { (res,\
    \ v) in\n                      ^\n                      separator: \n/tmp/tmp21ebgmqx.swift:21:12:\
    \ error: cannot assign through subscript: 'res' is a 'let' constant\n        res[v]\
    \ = res[v] + 1\n        ~~~^\n/tmp/tmp21ebgmqx.swift:21:21: error: value of optional\
    \ type 'Int?' must be unwrapped to a value of type 'Int'\n        res[v] = res[v]\
    \ + 1\n                    ^\n/tmp/tmp21ebgmqx.swift:21:21: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        res[v]\
    \ = res[v] + 1\n                    ^\n                 (      ?? <#default value#>)\n\
    /tmp/tmp21ebgmqx.swift:21:21: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        res[v] = res[v] + 1\n        \
    \            ^\n                       !\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test.characters.reduce(into: [String : Int](), { $0[$1] =\
    \ $0[$1] + 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmps2qgu8xv.swift:17:64: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n    return test.characters.reduce(into:\
    \ [String : Int](), { $0[$1] = $0[$1] + 1 })\n                               \
    \                                ^\n/tmp/tmps2qgu8xv.swift:17:73: error: cannot\
    \ convert value of type 'String.Element' (aka 'Character') to expected argument\
    \ type 'String'\n    return test.characters.reduce(into: [String : Int](), { $0[$1]\
    \ = $0[$1] + 1 })\n                                                          \
    \              ^\n/tmp/tmps2qgu8xv.swift:17:72: error: value of optional type\
    \ 'Int?' must be unwrapped to a value of type 'Int'\n    return test.characters.reduce(into:\
    \ [String : Int](), { $0[$1] = $0[$1] + 1 })\n                               \
    \                                        ^\n/tmp/tmps2qgu8xv.swift:17:72: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \    return test.characters.reduce(into: [String : Int](), { $0[$1] = $0[$1] +\
    \ 1 })\n                                                                     \
    \  ^\n                                                                     ( \
    \     ?? <#default value#>)\n/tmp/tmps2qgu8xv.swift:17:72: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ test.characters.reduce(into: [String : Int](), { $0[$1] = $0[$1] + 1 })\n  \
    \                                                                     ^\n    \
    \                                                                       !\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\treturn countOccurrences(letters: test.lowercased(), letterGrouping:\
    \ letterGrouping, letterCounts: letterCountsMap)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp179er5d0.swift:17:9: error: cannot find 'countOccurrences' in scope\n\
    \        return countOccurrences(letters: test.lowercased(), letterGrouping: letterGrouping,\
    \ letterCounts: letterCountsMap)\n               ^~~~~~~~~~~~~~~~\n/tmp/tmp179er5d0.swift:17:70:\
    \ error: cannot find 'letterGrouping' in scope\n        return countOccurrences(letters:\
    \ test.lowercased(), letterGrouping: letterGrouping, letterCounts: letterCountsMap)\n\
    \                                                                            ^~~~~~~~~~~~~~\n\
    /tmp/tmp179er5d0.swift:17:100: error: cannot find 'letterCountsMap' in scope\n\
    \        return countOccurrences(letters: test.lowercased(), letterGrouping: letterGrouping,\
    \ letterCounts: letterCountsMap)\n                                           \
    \                                                               ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var maxCount = 0\n    var maxLetter = \"\"\n    var histogram =\
    \ [String : Int]()\n    for letter in test.lowercased() {\n        var letterCount\
    \ = histogram[letter]\n        letterCount = letterCount == nil ? 1 : letterCount\
    \ + 1\n        histogram[letter] = letterCount\n        if letterCount > maxCount\
    \ {\n            maxCount = letterCount\n            maxLetter = letter\n    \
    \    }\n    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpebdi9g0_.swift:21:36: error: no exact matches in call to subscript\
    \ \n        var letterCount = histogram[letter]\n                            \
    \       ^\nSwift.Dictionary:8:23: note: candidate expects value of type 'Dictionary<String,\
    \ Int>.Index' for parameter #1 (got 'Character')\n    @inlinable public subscript(position:\
    \ Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Element { get }\n  \
    \                    ^\nSwift.Dictionary:2:23: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'Character')\n    @inlinable public subscript(key:\
    \ Key) -> Value? { get set }\n                      ^\nSwift.Collection:2:23:\
    \ note: candidate expects value of type 'Range<Dictionary<String, Int>.Index>'\
    \ for parameter #1 (got 'Character')\n    @inlinable public subscript(bounds:\
    \ Range<Self.Index>) -> Slice<Self> { get }\n                      ^\nSwift.Collection:3:23:\
    \ note: candidate expects value of type '(UnboundedRange_) -> ()' for parameter\
    \ #1 (got 'Character')\n    @inlinable public subscript(x: (UnboundedRange_) ->\
    \ ()) -> Self.SubSequence { get }\n                      ^\n/tmp/tmpebdi9g0_.swift:23:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        histogram[letter] = letterCount\n                  ^\n/tmp/tmpebdi9g0_.swift:26:25:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  maxLetter = letter\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram.(test)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpd66qb757.swift:17:22: error: expected member name following '.'\n\
    \    return histogram.(test)\n                     ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test(test).reduce(into: [String : Int](), { $0[$1] = $0[$1]\
    \ + 1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpb71nv0y9.swift:17:12: error: cannot call value of non-function\
    \ type 'String'\n    return test(test).reduce(into: [String : Int](), { $0[$1]\
    \ = $0[$1] + 1 })\n           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test.isEmpty {\n        return [:]\n    }\n    var histo = [String\
    \ : Int]()\n    for char in test {\n        histo[char] = (histo[char]!) + (1)\n\
    \    }\n    var max = -1\n    for char in histo {\n        if max < histo[char]\
    \ {\n            max = histo[char]\n        }\n    }\n    var result = [String\
    \ : Int]()\n    for char in histo {\n        if histo[char] == max {\n       \
    \     result[char] = histo[char]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpyiijb29e.swift:22:15: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        histo[char] = (histo[char]!) + (1)\n\
    \              ^\n/tmp/tmpyiijb29e.swift:22:30: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        histo[char] = (histo[char]!)\
    \ + (1)\n                             ^\n/tmp/tmpyiijb29e.swift:26:23: error:\
    \ no exact matches in call to subscript \n        if max < histo[char] {\n   \
    \                   ^\n/tmp/tmpyiijb29e.swift:26:23: note: found candidate with\
    \ type '(Dictionary<String, Int>.Index) -> (key: String, value: Int)'\n      \
    \  if max < histo[char] {\n                      ^\n/tmp/tmpyiijb29e.swift:26:23:\
    \ note: candidate expects value of type 'String' for parameter #1 (got '(key:\
    \ String, value: Int)')\n        if max < histo[char] {\n                    \
    \  ^\n/tmp/tmpyiijb29e.swift:26:16: error: binary operator '<' cannot be applied\
    \ to operands of type 'Int' and '(key: String, value: Int)'\n        if max <\
    \ histo[char] {\n           ~~~ ^ ~~~~~~~~~~~\n/tmp/tmpyiijb29e.swift:26:16: note:\
    \ overloads for '<' exist with these partially matching parameter lists: (Int,\
    \ Int)\n        if max < histo[char] {\n               ^\n/tmp/tmpyiijb29e.swift:27:24:\
    \ error: no exact matches in call to subscript \n            max = histo[char]\n\
    \                       ^\n/tmp/tmpyiijb29e.swift:27:24: note: found candidate\
    \ with type '(Dictionary<String, Int>.Index) -> (key: String, value: Int)'\n \
    \           max = histo[char]\n                       ^\n/tmp/tmpyiijb29e.swift:27:24:\
    \ note: found candidate with type '(String) -> @lvalue Int?'\n            max\
    \ = histo[char]\n                       ^\n/tmp/tmpyiijb29e.swift:27:24: note:\
    \ found candidate with type '(Range<Dictionary<String, Int>.Index>) -> Slice<[String\
    \ : Int]>'\n            max = histo[char]\n                       ^\n/tmp/tmpyiijb29e.swift:27:24:\
    \ note: found candidate with type '((key: String, value: Int)) -> Dictionary<String,\
    \ Int>.SubSequence' (aka '((key: String, value: Int)) -> Slice<Dictionary<String,\
    \ Int>>"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    histogram(test: test.trimmingCharacters(in: .whitespaces))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpwr4b2mga.swift:17:26: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    histogram(test: test.trimmingCharacters(in: .whitespaces))\n\
    \                    ~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpwr4b2mga.swift:17:50: error:\
    \ cannot infer contextual base in reference to member 'whitespaces'\n    histogram(test:\
    \ test.trimmingCharacters(in: .whitespaces))\n                               \
    \                 ~^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard test != \"\" else {\n        return []\n    }\n    var frequency:\
    \ [String : Int] = [:]\n    for letter in test.lowercased() {\n        frequency[letter]\
    \ = (countForKey(frequency, letter)!) + 1\n    }\n    return frequency\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmprk8b3x78.swift:18:16: error: use [:] to get an empty dictionary\
    \ literal\n        return []\n               ^\n                :\n/tmp/tmprk8b3x78.swift:22:30:\
    \ error: cannot find 'countForKey' in scope\n        frequency[letter] = (countForKey(frequency,\
    \ letter)!) + 1\n                             ^~~~~~~~~~~\n/tmp/tmprk8b3x78.swift:22:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        frequency[letter] = (countForKey(frequency, letter)!) + 1\n         \
    \         ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let words = test.components(separatedBy: \" \") else {\n \
    \       return []\n    }\n\n    // Sort the letters by the count\n    let sortedLetters\
    \ = words.sorted{ $0.count > $1.count }\n\n    var occurrences = Dictionary<String,\
    \ Int>()\n    var letters = [String]()\n\n    for letter in sortedLetters {\n\
    \        guard let count = occurrences[letter] else {\n            occurrences[letter]\
    \ = Int()\n        }\n        occurrences[letter] = occurrences[letter] + 1\n\
    \        letters.append(letter)\n    }\n\n    return letters.map{\n        (letter,\
    \ count) -> (String, Int) in\n        return (letter, count)\n    }.sorted{ $0.1\
    \ < $1.1 }.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpyx61exdw.swift:17:28: error: value of type 'String' has no member\
    \ 'components'\n    guard let words = test.components(separatedBy: \" \") else\
    \ {\n                      ~~~~ ^~~~~~~~~~\n/tmp/tmpyx61exdw.swift:18:16: error:\
    \ use [:] to get an empty dictionary literal\n        return []\n            \
    \   ^\n                :\n/tmp/tmpyx61exdw.swift:36:9: error: contextual closure\
    \ type '(String) throws -> (String, Int)' expects 1 argument, but 2 were used\
    \ in closure body\n        (letter, count) -> (String, Int) in\n        ^\n/tmp/tmpyx61exdw.swift:38:33:\
    \ error: cannot convert return expression of type '(String, Int)' to return type\
    \ '[String : Int]'\n    }.sorted{ $0.1 < $1.1 }.last!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var maxCount = 0\n    var maxChar = \"\"\n    var maxKey = \"\"\n\
    \    var histogram = [:]\n    for char in test.unicodeScalars {\n        let count\
    \ = String(char).unicodeScalars.count\n        if count > maxCount {\n       \
    \     maxCount = count\n            maxChar = char\n            maxKey = String(char)\n\
    \        } else if count == maxCount {\n            let key = String(char)\n \
    \           if histogram[key] != nil {\n                histogram[key]?.append(count)\n\
    \            } else {\n                histogram[key] = [count]\n            }\n\
    \        }\n    }\n\n    var returnDict: [String : Int] = [String : Int]()\n \
    \   for (_, values) in histogram {\n        var max = 0\n        var maxChar =\
    \ \"\"\n        for v in values {\n            if v > max {\n                max\
    \ = v\n                maxChar = v\n            }\n        }\n        returnDict[maxChar]\
    \ = max\n    }\n    return returnDict\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpl3k1eibw.swift:20:21: error: empty collection literal requires\
    \ an explicit type\n    var histogram = [:]\n                    ^~~\n/tmp/tmpl3k1eibw.swift:25:23:\
    \ error: cannot assign value of type 'Unicode.Scalar' to type 'String'\n     \
    \       maxChar = char\n                      ^~~~\n/tmp/tmpl3k1eibw.swift:30:27:\
    \ error: cannot convert value of type 'String' to expected argument type 'Dictionary<AnyHashable,\
    \ Any>.Index'\n                histogram[key]?.append(count)\n               \
    \           ^\n/tmp/tmpl3k1eibw.swift:30:31: error: cannot use optional chaining\
    \ on non-optional value of type '(key: AnyHashable, value: Any)'\n           \
    \     histogram[key]?.append(count)\n                ~~~~~~~~~~~~~~^\n       \
    \                       \n/tmp/tmpl3k1eibw.swift:30:33: error: value of tuple\
    \ type '(key: AnyHashable, value: Any)' has no member 'append'\n             \
    \   histogram[key]?.append(count)\n                ~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpl3k1eibw.swift:41:18:\
    \ error: for-in loop requires 'Any' to conform to 'Sequence'\n        for v in\
    \ values {\n                 ^~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar dict [String : Int] = [:]\n\tfor letter in test.split(\" \") {\n\
    \t\tdict[letter] = dict[letter] + 1\n\t}\n\treturn dict\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmppt2s9auu.swift:17:10: error: consecutive statements on a line must\
    \ be separated by ';'\n        var dict [String : Int] = [:]\n               \
    \ ^\n                ;\n/tmp/tmppt2s9auu.swift:17:6: error: type annotation missing\
    \ in pattern\n        var dict [String : Int] = [:]\n            ^\n/tmp/tmppt2s9auu.swift:17:11:\
    \ error: cannot assign to immutable expression of type '[String : Int].Type'\n\
    \        var dict [String : Int] = [:]\n                 ^~~~~~~~~~~~~~\n/tmp/tmppt2s9auu.swift:17:28:\
    \ error: cannot assign value of type '[AnyHashable : Any]' to type '[String :\
    \ Int].Type'\n        var dict [String : Int] = [:]\n                        \
    \          ^~~\n/tmp/tmppt2s9auu.swift:18:21: error: no exact matches in call\
    \ to instance method 'split'\n        for letter in test.split(\" \") {\n    \
    \                       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test.isEmpty {\n        return [:]\n    }\n\n    // Split the\
    \ string into words and process each one.\n    // We keep track of which letters\
    \ have been encountered so we\n    // don't count them twice.\n    var letters\
    \ = [String: Int]()\n    var words = [String]()\n    var letterCounts = [:]\n\
    \    var letterCount = 0\n    var wordCount = 0\n\n    for c in test.unicodeScalars\
    \ {\n        // Skip this letter if it has already been encountered.\n       \
    \ if let count = letters[c] {\n            letterCount += count\n        } else\
    \ {\n            letters[c] = letterCount\n            letterCount += 1\n\n  \
    \          // Split the string and add the words found.\n            words = test.unicodeScalars.filter({\
    \ c in\n                let cString = String($0)\n                return !letterCounts[cString]\
    \ && !letterCounts[c]\n            }).map { String($0) }\n            letterCounts[words[0].lowercased()]\
    \ = wordCount\n            wordCount += words.count\n        }\n    }\n\n    //\
    \ Return a dictionary with the letter with the most occurrences and a count of\
    \ how often it occurred.\n    let most = letters.reduce([String: Int](), { (r,\
    \ k) -> ([String : Int], Int) in\n        let count = r[k] ?? 0\n        return\
    \ (count > r[k], count)\n    }).0\n    return most\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp_ezqpdze.swift:40:38: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'c'?\n  \
    \              let cString = String($0)\n                                    \
    \ ^~\n                                     c\n/tmp/tmp_ezqpdze.swift:26:24: error:\
    \ empty collection literal requires an explicit type\n    var letterCounts = [:]\n\
    \                       ^~~\n/tmp/tmp_ezqpdze.swift:32:31: error: subscript 'subscript(_:)'\
    \ requires that 'Unicode.Scalar' conform to 'RangeExpression'\n        if let\
    \ count = letters[c] {\n                              ^\nSwift.Collection:2:23:\
    \ note: where 'R' = 'Unicode.Scalar'\n    @inlinable public subscript<R>(r: R)\
    \ -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }\n\
    \                      ^\n/tmp/tmp_ezqpdze.swift:35:21: error: cannot convert\
    \ value of type 'Unicode.Scalar' to expected argument type 'String'\n        \
    \    letters[c] = letterCount\n                    ^\n/tmp/tmp_ezqpdze.swift:41:37:\
    \ error: optional type 'Any?' cannot be used as a boolean; test for '== nil' instead\n\
    \                return !letterCounts[cString] && !letterCounts[c]\n         \
    \              ~            ^\n                        (                     ==\
    \ nil)\n/tmp/tmp_ezqpdze.swift:41:63: error: optional type 'Any?' cannot be used\
    \ as a boolean; test for '== nil' instead\n                return !letterCounts[cString]\
    \ && !letterCounts[c]\n                                                 ~    \
    \        ^\n                                                  (              \
    \ == nil)\n/tmp/tmp_ezqpdze.swift:49:60: error: declared closure result '([String\
    \ : Int], Int)' is incompatible with contextual type '[String : Int]'\n    let\
    \ most = letters.reduce([String: Int](), { (r, k) -> ([String : Int], Int) in\n\
    \                                                           ^~~~~~~~~~~~~~~~~~~~~\n\
    \                                                           [String : Int]\n/tmp/tmp_ezqpdze.swift:50:23:\
    \ error: cannot convert value of type 'Dictionary<String, Int>.Element' (aka '(k"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String: Int]()\n    test.split(\" \").map { histogram.updateValue(1,\
    \ forKey: $0) }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmprszdcyio.swift:18:10: error: no exact matches in call to instance\
    \ method 'split'\n    test.split(\" \").map { histogram.updateValue(1, forKey:\
    \ $0) }\n         ^\n/tmp/tmprszdcyio.swift:18:10: note: candidate has partially\
    \ matching parameter list (separator: String.Element, maxSplits: Int, omittingEmptySubsequences:\
    \ Bool)\n    test.split(\" \").map { histogram.updateValue(1, forKey: $0) }\n\
    \         ^\n/tmp/tmprszdcyio.swift:18:10: note: candidate has partially matching\
    \ parameter list (separator: String.Element, maxSplits: Int, omittingEmptySubsequences:\
    \ Bool)\n    test.split(\" \").map { histogram.updateValue(1, forKey: $0) }\n\
    \         ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    switch test.countByReduce() {\n    case let .Some(count), let strings\
    \ = count:\n        return strings.compactMap({ (string, _) -> [String : Int]\
    \ in\n            let count = count[string]!\n            return [string : count]\n\
    \        }).sorted(by: { (_, _) -> Bool in\n            return $0.1 > $1.1\n \
    \       })\n    default:\n        return []\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpz8uc_1va.swift:18:32: error: 'strings' must be bound in every pattern\n\
    \    case let .Some(count), let strings = count:\n                           \
    \    ^\n/tmp/tmpz8uc_1va.swift:18:20: error: 'count' must be bound in every pattern\n\
    \    case let .Some(count), let strings = count:\n                   ^\n/tmp/tmpz8uc_1va.swift:18:40:\
    \ error: expected ':' after 'case'\n    case let .Some(count), let strings = count:\n\
    \                                       ^\n/tmp/tmpz8uc_1va.swift:18:40: error:\
    \ expected expression\n    case let .Some(count), let strings = count:\n     \
    \                                  ^\n/tmp/tmpz8uc_1va.swift:18:42: error: labels\
    \ are only valid on loops, if, and switch statements\n    case let .Some(count),\
    \ let strings = count:\n                                         ^\n/tmp/tmpz8uc_1va.swift:23:20:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments\n            return $0.1 > $1.1\n                   ^\n/tmp/tmpz8uc_1va.swift:23:27:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments\n            return $0.1 > $1.1\n                       \
    \   ^\n/tmp/tmpz8uc_1va.swift:17:17: error: value of type 'String' has no member\
    \ 'countByReduce'\n    switch test.countByReduce() {\n           ~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpz8uc_1va.swift:19:16: error: cannot find 'strings' in scope\n        return\
    \ strings.compactMap({ (string, _) -> [String : Int] in\n               ^~~~~~~\n\
    /tmp/tmpz8uc_1va.swift:26:16: error: use [:] to get an empty dictionary literal\n\
    \        return []\n               ^\n                :\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram(test.lowercased().components(separatedBy: \" \"\
    ))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\")\
    \ == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\"\
    \ : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\"\
    \ : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") ==\
    \ [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") ==\
    \ [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"\
    g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp13xhn82j.swift:17:22: error: missing argument label 'test:' in\
    \ call\n    return histogram(test.lowercased().components(separatedBy: \" \"))\n\
    \                     ^\n                     test: \n/tmp/tmp13xhn82j.swift:17:40:\
    \ error: value of type 'String' has no member 'components'\n    return histogram(test.lowercased().components(separatedBy:\
    \ \" \"))\n                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letterCounts = [String : Int]()\n    var i = 0\n    for letter\
    \ in test.lowercased() {\n        if let count = letterCounts[letter] {\n    \
    \        letterCounts[letter] = count + 1\n        } else {\n            letterCounts[letter]\
    \ = 1\n        }\n        i += 1\n    }\n    return letterCounts\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmppu9sevv5.swift:20:37: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if let count = letterCounts[letter]\
    \ {\n                                    ^\n/tmp/tmppu9sevv5.swift:21:26: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            letterCounts[letter] = count + 1\n                         ^\n/tmp/tmppu9sevv5.swift:23:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            letterCounts[letter] = 1\n                         ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let list = test.characters.split{$0 == \" \"}.map{String($0)}\n\
    \    let letters = list.reduce(into: [String : Int](), {\n        $1[$0] = ($1[$0]\
    \ ?? 0) + 1\n    })\n    return letters\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpgrnq00ct.swift:17:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    let list = test.characters.split{$0 == \" \"}.map{String($0)}\n\
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgrnq00ct.swift:18:37: error: cannot convert value of type '[String\
    \ : Int]' to expected argument type 'Range<String.Index>'\n    let letters = list.reduce(into:\
    \ [String : Int](), {\n                                    ^\n/tmp/tmpgrnq00ct.swift:19:11:\
    \ error: cannot assign through subscript: subscript is get-only\n        $1[$0]\
    \ = ($1[$0] ?? 0) + 1\n        ~~^~~~\n/tmp/tmpgrnq00ct.swift:19:29: error: cannot\
    \ convert value of type 'Int' to expected argument type 'Substring'\n        $1[$0]\
    \ = ($1[$0] ?? 0) + 1\n                            ^\n/tmp/tmpgrnq00ct.swift:19:34:\
    \ error: cannot convert value of type 'Int' to expected argument type 'Substring'\n\
    \        $1[$0] = ($1[$0] ?? 0) + 1\n                                 ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var max = [String: Int]()\n    var result = [String : Int]()\n\n\
    \    for character in test.characters.split(\" \") {\n        let count = max[character]\n\
    \        max[character] = count + 1\n    }\n\n    for character in max.keys {\n\
    \        result[character] = max[character]\n    }\n\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpta4p79d6.swift:20:38: error: no exact matches in call to instance\
    \ method 'split'\n    for character in test.characters.split(\" \") {\n      \
    \                               ^\nSwift.Sequence:2:40: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable public\
    \ __consuming func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result = Dictionary<String, Int>()\n    for c in test {\n  \
    \      switch c {\n        case 'a':\n        case 'b':\n        case 'c':\n \
    \       case ' ':\n        case '\\t':\n            continue\n        case '\\\
    n':\n            result = [:] as [String : Int]\n            return result\n \
    \       }\n\n        var count = result[c] ?? 0\n        result[c] = count + 1\n\
    \    }\n\n    return result.sorted(by: { $0.1 > $1.1 }).reversed().map { ($0,\
    \ $1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a b b\
    \ a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"\
    a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"\
    b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\")\
    \ == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp9lsuuc6j.swift:20:14: error: single-quoted string literal found,\
    \ use '\"'\n        case 'a':\n             ^~~\n             \"a\"\n/tmp/tmp9lsuuc6j.swift:20:9:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \        case 'a':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9lsuuc6j.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'b':\n   \
    \          ^~~\n             \"b\"\n/tmp/tmp9lsuuc6j.swift:21:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'b':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9lsuuc6j.swift:22:14:\
    \ error: single-quoted string literal found, use '\"'\n        case 'c':\n   \
    \          ^~~\n             \"c\"\n/tmp/tmp9lsuuc6j.swift:22:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ 'c':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9lsuuc6j.swift:23:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ' ':\n   \
    \          ^~~\n             \" \"\n/tmp/tmp9lsuuc6j.swift:23:9: error: 'case'\
    \ label in a 'switch' must have at least one executable statement\n        case\
    \ ' ':\n        ^~~~~~~~~\n                  break\n/tmp/tmp9lsuuc6j.swift:24:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '\\t':\n \
    \            ^~~~\n             \"\\t\"\n/tmp/tmp9lsuuc6j.swift:26:14: error:\
    \ single-quoted string literal found, use '\"'\n        case '\\n':\n        \
    \     ^~~~\n             \"\\n\"\n/tmp/tmp9lsuuc6j.swift:19:9: error: switch must\
    \ be exhaustive\n        switch c {\n        ^\n/tmp/tmp9lsuuc6j.swift:19:9: note:\
    \ do you want to add a default clause?\n        switch c {\n        ^\n/tmp/tmp9lsuuc6j.swift:31:28:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        var count = result[c] ?? 0\n                           ^\n/tmp/tmp9lsuuc6j.swift:32:16:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result[c] = count + 1\n               ^\n/tmp/tmp9lsuuc6j.swift:35:58:\
    \ error: cannot con"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n    var count: Int = 0\n    var\
    \ letter: String = \"\"\n    for char in test {\n        if let charIndex = test.index(of:\
    \ char) {\n            letter = String(test[charIndex])\n            result[letter]\
    \ = result[letter] + 1\n        }\n    }\n    return result \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpmovk6rcj.swift:21:33: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n        if let charIndex = test.index(of: char) {\n  \
    \                              ^\n/tmp/tmpmovk6rcj.swift:21:33: note: use 'firstIndex(of:)'\
    \ instead\n        if let charIndex = test.index(of: char) {\n               \
    \                 ^~~~~\n                                firstIndex\n/tmp/tmpmovk6rcj.swift:23:36:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            result[letter] = result[letter] + 1\n                           \
    \        ^\n/tmp/tmpmovk6rcj.swift:23:36: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            result[letter]\
    \ = result[letter] + 1\n                                   ^\n               \
    \              (              ?? <#default value#>)\n/tmp/tmpmovk6rcj.swift:23:36:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            result[letter] = result[letter] + 1\n                   \
    \                ^\n                                           !\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    for char in test.lowercased()\
    \ {\n        histogram[char] = (histogram[char] ?? 0) + 1\n    }\n    return histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpgk2zvd8m.swift:19:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        histogram[char] = (histogram[char]\
    \ ?? 0) + 1\n                  ^\n/tmp/tmpgk2zvd8m.swift:19:38: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   histogram[char] = (histogram[char] ?? 0) + 1\n                           \
    \          ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let letters = test.split(separator: \" \").map({ $0.lowercased()\
    \ }),\n        let keys = Array(letters.map { $0.prefix(1).uppercased() }),\n\
    \        let values = letters.map({ letters.filter({ $0.lowercased() == $0.prefix(1).uppercased()\
    \ }).count })\n    else {\n        return [:] as [String : Int]\n    }\n    return\
    \ zip(keys, values).map { $0.0 : $0.1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpqyuqi9py.swift:23:40: error: consecutive statements on a line must\
    \ be separated by ';'\n    return zip(keys, values).map { $0.0 : $0.1 }\n    \
    \                                   ^\n                                      \
    \ ;\n/tmp/tmpqyuqi9py.swift:23:41: error: expected expression\n    return zip(keys,\
    \ values).map { $0.0 : $0.1 }\n                                        ^\n/tmp/tmpqyuqi9py.swift:19:34:\
    \ error: contextual type for closure argument list expects 1 argument, which cannot\
    \ be implicitly ignored\n        let values = letters.map({ letters.filter({ $0.lowercased()\
    \ == $0.prefix(1).uppercased() }).count })\n                                 ^\n\
    \                                   _ in\n/tmp/tmpqyuqi9py.swift:17:11: error:\
    \ initializer for conditional binding must have Optional type, not '[String]'\n\
    \    guard let letters = test.split(separator: \" \").map({ $0.lowercased() }),\n\
    \          ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqyuqi9py.swift:18:9: error: initializer for conditional binding must have\
    \ Optional type, not '[String]'\n        let keys = Array(letters.map { $0.prefix(1).uppercased()\
    \ }),\n        ^          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqyuqi9py.swift:23:30:\
    \ error: cannot convert return expression of type '[String]' to return type '[String\
    \ : Int]'\n    return zip(keys, values).map { $0.0 : $0.1 }\n           ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result = [:] as [String : Int]\n    for letter in test.characters\
    \ {\n        if let count = result[letter] {\n            result[letter] = 1 +\
    \ count\n        } else {\n            result[letter] = 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp4v86kqrs.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in test.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp4v86kqrs.swift:19:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let count = result[letter] {\n                              ^\n/tmp/tmp4v86kqrs.swift:20:20:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result[letter] = 1 + count\n                   ^\n/tmp/tmp4v86kqrs.swift:22:20:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            result[letter] = 1\n                   ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [String: Int]()\n    }\n\n   \
    \ var letters: [String: Int] = [:]\n    for s in test.split(separator: \" \")\
    \ {\n        if let letter = String(s.characters) {\n            if letters.keys.contains(letter)\
    \ {\n                letters[letter] = (letters[letter] ?? 0) + 1;\n         \
    \   } else {\n                letters[letter] = 1;\n            }\n        }\n\
    \    }\n    return letters.sorted(by: { ($0.key, $1.key) < ($1.key, $0.key) }).map\
    \ { ($0.0, $0.1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpcpftx1_b.swift:23:34: error: 'characters' is unavailable: Please\
    \ use Substring directly\n        if let letter = String(s.characters) {\n   \
    \                              ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: Substring { get set }\n\
    \               ^\n/tmp/tmpcpftx1_b.swift:23:12: error: initializer for conditional\
    \ binding must have Optional type, not 'String'\n        if let letter = String(s.characters)\
    \ {\n           ^            ~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcpftx1_b.swift:31:72:\
    \ error: cannot convert return expression of type '[(String, Int)]' to return\
    \ type '[String : Int]'\n    return letters.sorted(by: { ($0.key, $1.key) < ($1.key,\
    \ $0.key) }).map { ($0.0, $0.1) }\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar result : [String : Int]\n\tvar letters : [String] = test.stringByReplacingOccurrencesOfStrings(\n\
    \t\t\" \", withString: \"\",\n\t\toptions: NSStringCompareOptions.CaseInsensitiveSearch).componentsSeparatedByString(\"\
    \ \")\n\tfor letter in letters {\n\t\tif let count = letters.filter({ $0 == letter\
    \ }).count  {\n\t\t\tresult[letter] = count\n\t\t}\n\t}\n\treturn result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpld3ey48y.swift:20:12: error: cannot find 'NSStringCompareOptions'\
    \ in scope\n                options: NSStringCompareOptions.CaseInsensitiveSearch).componentsSeparatedByString(\"\
    \ \")\n                         ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpld3ey48y.swift:18:32:\
    \ error: value of type 'String' has no member 'stringByReplacingOccurrencesOfStrings'\n\
    \        var letters : [String] = test.stringByReplacingOccurrencesOfStrings(\n\
    \                                 ~~~~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpld3ey48y.swift:22:6: error: initializer for conditional binding must have\
    \ Optional type, not 'Int'\n                if let count = letters.filter({ $0\
    \ == letter }).count  {\n                   ^           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard !test.isEmpty else { return [:] }\n    var result = [:]\n\
    \    test.split(separator: \" \")\n        .reduce(0) { $1 + counts[$0] }\n  \
    \      .sort().reversed()\n        .forEach { result[String($0)] = $1 }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpxrk_y2oq.swift:18:18: error: empty collection literal requires\
    \ an explicit type\n    var result = [:]\n                 ^~~\n/tmp/tmpxrk_y2oq.swift:20:27:\
    \ error: cannot find 'counts' in scope\n        .reduce(0) { $1 + counts[$0] }\n\
    \                          ^~~~~~\n/tmp/tmpxrk_y2oq.swift:23:12: error: cannot\
    \ convert return expression of type '[AnyHashable : Any]' to return type '[String\
    \ : Int]'\n    return result\n           ^\n/tmp/tmpxrk_y2oq.swift:23:12: note:\
    \ arguments to generic parameter 'Key' ('AnyHashable' and 'String') are expected\
    \ to be equal\n    return result\n           ^\n/tmp/tmpxrk_y2oq.swift:23:12:\
    \ note: arguments to generic parameter 'Value' ('Any' and 'Int') are expected\
    \ to be equal\n    return result\n           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [String: Int]()\n    }\n    var\
    \ counters: [String: Int] = [:]\n    var result: [String: Int] = [:]\n    for\
    \ letter in test.lowercased() {\n        if let count = counters[letter] {\n \
    \           counters[letter] = count + 1\n        } else {\n            counters[letter]\
    \ = 1\n        }\n    }\n    for (_, count) in counters {\n        if count >\
    \ result.count {\n            result = counters\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpz0oci4my.swift:23:33: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if let count = counters[letter]\
    \ {\n                                ^\n/tmp/tmpz0oci4my.swift:24:22: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       counters[letter] = count + 1\n                     ^\n/tmp/tmpz0oci4my.swift:26:22:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            counters[letter] = 1\n                     ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return []\n    }\n    counts := make(map[String:\
    \ Int]) // [String : Int]\n    var maxCount = 1\n    for _, letter := range test\
    \ {\n        if counts[letter] == nil {\n            counts[letter] = 1\n    \
    \    } else if counts[letter] > maxCount {\n            counts[letter] = maxCount\n\
    \            maxCount = counts[letter]\n        }\n    }\n    return counts\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmphrjg7x4k.swift:20:11: error: consecutive statements on a line must\
    \ be separated by ';'\n    counts := make(map[String: Int]) // [String : Int]\n\
    \          ^\n          ;\n/tmp/tmphrjg7x4k.swift:20:12: error: expected expression\n\
    \    counts := make(map[String: Int]) // [String : Int]\n           ^\n/tmp/tmphrjg7x4k.swift:22:10:\
    \ error: expected 'in' after for-each pattern\n    for _, letter := range test\
    \ {\n         ^\n/tmp/tmphrjg7x4k.swift:22:10: error: expected Sequence expression\
    \ for for-each loop\n    for _, letter := range test {\n         ^\n/tmp/tmphrjg7x4k.swift:18:16:\
    \ error: use [:] to get an empty dictionary literal\n        return []\n     \
    \          ^\n                :\n/tmp/tmphrjg7x4k.swift:20:5: error: cannot find\
    \ 'counts' in scope\n    counts := make(map[String: Int]) // [String : Int]\n\
    \    ^~~~~~\n/tmp/tmphrjg7x4k.swift:30:12: error: cannot find 'counts' in scope\n\
    \    return counts\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    var max = 0\n    test.split(\"\
    \ \").forEach() { histogram += [$0 : (histogram[$0] ?? 0)+1] }\n    for (k,v)\
    \ in histogram {\n        if v > max { max = v }\n    }\n    if max < 1 { histogram\
    \ = [:] }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpk2oq726l.swift:19:43: error: binary operator '+=' cannot be applied\
    \ to operands of type '[String : Int]' and '[ArraySlice<String.Element> : Int]'\
    \ (aka 'Dictionary<ArraySlice<Character>, Int>')\n    test.split(\" \").forEach()\
    \ { histogram += [$0 : (histogram[$0] ?? 0)+1] }\n                           \
    \     ~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk2oq726l.swift:19:10:\
    \ error: no exact matches in call to instance method 'split'\n    test.split(\"\
    \ \").forEach() { histogram += [$0 : (histogram[$0] ?? 0)+1] }\n         ^\n/tmp/tmpk2oq726l.swift:19:10:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    test.split(\"\
    \ \").forEach() { histogram += [$0 : (histogram[$0] ?? 0)+1] }\n         ^\n/tmp/tmpk2oq726l.swift:19:10:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [String.SubSequence]'\
    \ (aka '(Character, Int, Bool) -> Array<Substring>')\n    test.split(\" \").forEach()\
    \ { histogram += [$0 : (histogram[$0] ?? 0)+1] }\n         ^\n"
  stdout: ''
  timestamp: 1660009572
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    for string in test.split(\"\
    \ \") {\n        if let letter = string.first {\n            histogram[letter]\
    \ = (histogram[letter] ?? 0) + 1\n        }\n    }\n    return histogram\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpk629ekb_.swift:18:24: error: no exact matches in call to instance\
    \ method 'split'\n    for string in test.split(\" \") {\n                    \
    \   ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar histogram: [String : Int] = [:]\n\ttest.characters.forEach { char\
    \ in\n\t\thistogram[char] = (histogram[char] ?? 0) + 1\n\t}\n\treturn histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpit2tzi4f.swift:19:13: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n                histogram[char]\
    \ = (histogram[char] ?? 0) + 1\n                          ^\n/tmp/tmpit2tzi4f.swift:19:32:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n                histogram[char] = (histogram[char] ??\
    \ 0) + 1\n                                             ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n\n    for s in test.split(\" \"\
    ) {\n        if let count = result[s]?? 0 {\n            result[s] = (result[s]??\
    \ 0) + 1\n        } else {\n            result[s] = 1 // We start at 1 because\
    \ the first character has only 1 occurrence\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpybzr453_.swift:20:36: error: expected '{' after 'if' condition\n\
    \        if let count = result[s]?? 0 {\n                                   ^\n\
    /tmp/tmpybzr453_.swift:21:38: error: expected ',' separator\n            result[s]\
    \ = (result[s]?? 0) + 1\n                                     ^\n            \
    \                        ,\n/tmp/tmpybzr453_.swift:19:19: error: no exact matches\
    \ in call to instance method 'split'\n    for s in test.split(\" \") {\n     \
    \             ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let letters = test.characters\n    var result = [:]\n    for letter\
    \ in letters {\n        if let count = result[letter] {\n            result[letter]\
    \ = count + 1\n        } else {\n            result[letter] = 1\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpnbu3z18h.swift:17:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    let letters = test.characters\n                   \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnbu3z18h.swift:18:18:\
    \ error: empty collection literal requires an explicit type\n    var result =\
    \ [:]\n                 ^~~\n/tmp/tmpnbu3z18h.swift:21:30: error: cannot convert\
    \ value of type 'Any' to expected argument type 'Int'\n            result[letter]\
    \ = count + 1\n                             ^\n                              \
    \     as! Int\n/tmp/tmpnbu3z18h.swift:26:12: error: cannot convert return expression\
    \ of type '[AnyHashable : Any]' to return type '[String : Int]'\n    return result\n\
    \           ^\n/tmp/tmpnbu3z18h.swift:26:12: note: arguments to generic parameter\
    \ 'Key' ('AnyHashable' and 'String') are expected to be equal\n    return result\n\
    \           ^\n/tmp/tmpnbu3z18h.swift:26:12: note: arguments to generic parameter\
    \ 'Value' ('Any' and 'Int') are expected to be equal\n    return result\n    \
    \       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let testRange = test.unicodeScalars.filter { $0 != ' ' }.map(String.init),\
    \ \n        let counts = testRange\n            .map({ charToFrequency($0) })\n\
    \            .sorted()\n            .map({ ($1, $0) })\n            else { return\
    \ [:] }\n    return counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpg_c_dbhn.swift:17:62: error: single-quoted string literal found,\
    \ use '\"'\n    guard let testRange = test.unicodeScalars.filter { $0 != ' ' }.map(String.init),\
    \ \n                                                             ^~~\n       \
    \                                                      \" \"\n/tmp/tmpg_c_dbhn.swift:19:20:\
    \ error: cannot find 'charToFrequency' in scope\n            .map({ charToFrequency($0)\
    \ })\n                   ^~~~~~~~~~~~~~~\n/tmp/tmpg_c_dbhn.swift:17:54: warning:\
    \ trailing closure in this context is confusable with the body of the statement;\
    \ pass as a parenthesized argument to silence this warning\n    guard let testRange\
    \ = test.unicodeScalars.filter { $0 != ' ' }.map(String.init), \n            \
    \                                        ~^\n                                \
    \                    (             )\n/tmp/tmpg_c_dbhn.swift:17:11: error: initializer\
    \ for conditional binding must have Optional type, not '[String]'\n    guard let\
    \ testRange = test.unicodeScalars.filter { $0 != ' ' }.map(String.init), \n  \
    \        ^               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n\n    var letters = [String]()\n\
    \    if test != \"\" {\n        letters = test.split(separator: \" \")\n    }\n\
    \n    for let letter in letters {\n        if let count = histogram.value(forKey:\
    \ letter) {\n            histogram[letter] = count + 1\n        } else {\n   \
    \         histogram[letter] = 1\n        }\n    }\n\n    return histogram\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpnj9a5891.swift:24:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let letter in letters {\n        ^\n\
    /tmp/tmpnj9a5891.swift:21:17: error: cannot assign value of type '[String.SubSequence]'\
    \ (aka 'Array<Substring>') to type '[String]'\n        letters = test.split(separator:\
    \ \" \")\n                ^\n/tmp/tmpnj9a5891.swift:21:17: note: arguments to\
    \ generic parameter 'Element' ('String.SubSequence' (aka 'Substring') and 'String')\
    \ are expected to be equal\n        letters = test.split(separator: \" \")\n \
    \               ^\n/tmp/tmpnj9a5891.swift:25:34: error: value of type '[String\
    \ : Int]' has no member 'value'\n        if let count = histogram.value(forKey:\
    \ letter) {\n                       ~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\thistogram = [:]\n\tlet chars = Array(test.characters)\n\tfor char\
    \ in chars {\n\t\thistogram[char] = histogram.value(forKey: char) ?? 0 + 1\n\t\
    }\n\treturn histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmph5hi66dz.swift:17:2: error: cannot assign to value: 'histogram'\
    \ is a function\n        histogram = [:]\n        ^~~~~~~~~\n/tmp/tmph5hi66dz.swift:18:25:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ chars = Array(test.characters)\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph5hi66dz.swift:20:12:\
    \ error: value of type '(String) -> [String : Int]' has no subscripts\n      \
    \          histogram[char] = histogram.value(forKey: char) ?? 0 + 1\n        \
    \        ~~~~~~~~~^\n/tmp/tmph5hi66dz.swift:20:31: error: value of type '(String)\
    \ -> [String : Int]' has no member 'value'\n                histogram[char] =\
    \ histogram.value(forKey: char) ?? 0 + 1\n                                  ~~~~~~~~~\
    \ ^~~~~\n/tmp/tmph5hi66dz.swift:22:9: error: cannot convert return expression\
    \ of type '(String) -> [String : Int]' to return type '[String : Int]'\n     \
    \   return histogram\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result = [:]\n    var seen = [String]()\n    for letter in test.lowercased()\
    \ {\n        if let count = result[letter] {\n            result[letter] = count\
    \ + 1\n        } else {\n            result[letter] = 1\n        }\n        if\
    \ let alreadySeen = seen[letter] {\n            result[letter] = result[letter]\
    \ + result[alreadySeen]\n        } else {\n            seen[letter] = 1\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpyg97icvm.swift:17:18: error: empty collection literal requires\
    \ an explicit type\n    var result = [:]\n                 ^~~\n/tmp/tmpyg97icvm.swift:21:30:\
    \ error: cannot convert value of type 'Any' to expected argument type 'Int'\n\
    \            result[letter] = count + 1\n                             ^\n    \
    \                               as! Int\n/tmp/tmpyg97icvm.swift:25:34: error:\
    \ no exact matches in call to subscript \n        if let alreadySeen = seen[letter]\
    \ {\n                                 ^\nSwift.Array:16:23: note: candidate expects\
    \ value of type 'Int' for parameter #1 (got 'Character')\n    @inlinable public\
    \ subscript(index: Int) -> Element { get set }\n                      ^\nSwift.Array:17:23:\
    \ note: candidate expects value of type 'Range<Int>' for parameter #1 (got 'Character')\n\
    \    @inlinable public subscript(bounds: Range<Int>) -> ArraySlice<Element> {\
    \ get set }\n                      ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\nSwift.MutableCollection:3:23: note: candidate\
    \ expects value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get set }\n                      ^\n/tmp/tmpyg97icvm.swift:26:45: error: binary\
    \ operator '+' cannot be applied to two 'Slice<[AnyHashable : Any]>' operands\n\
    \            result[letter] = result[letter] + result[alreadySeen]\n         \
    \                    ~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyg97icvm.swift:26:36:\
    \ error: no exact matches in call to subscript \n            result[letter] =\
    \ result[letter] + result[alreadySeen]\n                                   ^\n\
    /tmp/tmpyg97icvm.swift:26:36: note: found candidate with type '(Range<Dictionary<AnyHashable,\
    \ Any>.Index>) -> Slice<[AnyHashable : Any]>'\n            result[letter] = result[letter]\
    \ + result[alreadySeen]\n                           "
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n    for letter in test.split(\"\
    \ \") {\n        result[letter] = (result[letter] ?? 0) + 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp9dqmrs0c.swift:18:24: error: no exact matches in call to instance\
    \ method 'split'\n    for letter in test.split(\" \") {\n                    \
    \   ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var charDict: [String : Int] = [:]\n    for char in test.characters.split(separator:\
    \ \" \") {\n        if charDict[char] == nil {\n            charDict[char] = 1\n\
    \        } else {\n            charDict[char] += 1\n        }\n    }\n    return\
    \ charDict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp_7u1jszt.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in test.characters.split(separator: \" \"\
    ) {\n                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp_7u1jszt.swift:19:21: error: cannot convert value of type\
    \ 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \        if charDict[char] == nil {\n                    ^\n                 \
    \   String( )\n/tmp/tmp_7u1jszt.swift:20:22: error: cannot convert value of type\
    \ 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \            charDict[char] = 1\n                     ^\n                    \
    \ String( )\n/tmp/tmp_7u1jszt.swift:22:22: error: cannot convert value of type\
    \ 'String.SubSequence' (aka 'Substring') to expected argument type 'String'\n\
    \            charDict[char] += 1\n                     ^\n                   \
    \  String( )\n/tmp/tmp_7u1jszt.swift:22:21: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n            charDict[char] += 1\n\
    \                    ^\n/tmp/tmp_7u1jszt.swift:22:21: note: force-unwrap using\
    \ '!' to abort execution if the optional value contains 'nil'\n            charDict[char]\
    \ += 1\n                    ^\n                          !\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tlet chars = test.characters\n\tvar frequency = [String : Int]()\n\t\
    var maxCount = 0\n\tfor char in chars {\n\t\tif let count = frequency.updateValue(chars.filter({\
    \ $0 == char }).count, forKey: char) {\n\t\t\tmaxCount = max(maxCount, count)\n\
    \t\t}\n\t}\n\treturn frequency\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpa0eg5xfy.swift:17:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        let chars = test.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpa0eg5xfy.swift:21:84:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                if let count = frequency.updateValue(chars.filter({ $0 == char\
    \ }).count, forKey: char) {\n                                                \
    \                                                 ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result = [String : Int]()\n    \n    for letter in test.unicodeScalars.reversed()\
    \ {\n        let count = test.unicodeScalars.filter { $0 == letter }.count\n \
    \       if result[key: letter] != nil { \n            result[key: letter]! +=\
    \ count\n        } else {\n            result[key: letter] = count\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpmjg_vexs.swift:21:18: error: extraneous argument label 'key:' in\
    \ subscript\n        if result[key: letter] != nil { \n                 ^~~~~~\n\
    \                  \n/tmp/tmpmjg_vexs.swift:21:18: error: subscript 'subscript(_:)'\
    \ requires that 'Unicode.Scalar' conform to 'RangeExpression'\n        if result[key:\
    \ letter] != nil { \n                 ^\nSwift.Collection:2:23: note: where 'R'\
    \ = 'Unicode.Scalar'\n    @inlinable public subscript<R>(r: R) -> Self.SubSequence\
    \ where R : RangeExpression, Self.Index == R.Bound { get }\n                 \
    \     ^\n/tmp/tmpmjg_vexs.swift:22:19: error: extraneous argument label 'key:'\
    \ in subscript\n            result[key: letter]! += count\n                  ^~~~~~\n\
    \                   \n/tmp/tmpmjg_vexs.swift:24:19: error: extraneous argument\
    \ label 'key:' in subscript\n            result[key: letter] = count\n       \
    \           ^~~~~~\n                   \n/tmp/tmpmjg_vexs.swift:24:25: error:\
    \ cannot convert value of type 'Unicode.Scalar' to expected argument type 'String'\n\
    \            result[key: letter] = count\n                        ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar result : [String : Int] = [ : ]\n\tfor char in test.characters\
    \ {\n\t\tresult[char] = result[char]! + 1\n\t}\n\treturn result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7t52wqbs.swift:18:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        for char in test.characters {\n               \
    \          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp7t52wqbs.swift:19:10: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result[char] = result[char]!\
    \ + 1\n                       ^\n/tmp/tmp7t52wqbs.swift:19:25: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n             \
    \   result[char] = result[char]! + 1\n                                      ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    letterCounts.withDefaultValue { [ : : Int : ] in\n        var result:\
    \ [String : Int] = [ : : ]()\n\n        var count = letterCounts[test.lowercased()]\n\
    \        if let currentCount = letterCounts[test.lowercased()] {\n           \
    \ result[test.lowercased()] = max(1, currentCount + count)\n        }\n\n    \
    \    if test.count > 1 {\n            let subTests = test.components(separatedBy:\
    \ \" \")\n            for subTest in subTests {\n                var subCount\
    \ = letterCounts[subTest.lowercased()]\n                if let currentCount =\
    \ letterCounts[subTest.lowercased()] {\n                    subCount = max(1,\
    \ currentCount + subCount)\n                }\n                result[subTest.lowercased()]\
    \ = subCount\n            }\n        }\n\n        return result\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp3diy2v7p.swift:17:39: error: expected 'weak', 'unowned', or no\
    \ specifier in capture list\n    letterCounts.withDefaultValue { [ : : Int : ]\
    \ in\n                                      ^\n/tmp/tmp3diy2v7p.swift:18:40: error:\
    \ expected expression in container literal\n        var result: [String : Int]\
    \ = [ : : ]()\n                                       ^\n/tmp/tmp3diy2v7p.swift:18:45:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ result: [String : Int] = [ : : ]()\n                                       \
    \     ^\n                                            ;\n/tmp/tmp3diy2v7p.swift:17:5:\
    \ error: cannot find 'letterCounts' in scope\n    letterCounts.withDefaultValue\
    \ { [ : : Int : ] in\n    ^~~~~~~~~~~~\n/tmp/tmp3diy2v7p.swift:20:21: error: cannot\
    \ find 'letterCounts' in scope\n        var count = letterCounts[test.lowercased()]\n\
    \                    ^~~~~~~~~~~~\n/tmp/tmp3diy2v7p.swift:21:31: error: cannot\
    \ find 'letterCounts' in scope\n        if let currentCount = letterCounts[test.lowercased()]\
    \ {\n                              ^~~~~~~~~~~~\n/tmp/tmp3diy2v7p.swift:28:32:\
    \ error: cannot find 'letterCounts' in scope\n                var subCount = letterCounts[subTest.lowercased()]\n\
    \                               ^~~~~~~~~~~~\n/tmp/tmp3diy2v7p.swift:29:39: error:\
    \ cannot find 'letterCounts' in scope\n                if let currentCount = letterCounts[subTest.lowercased()]\
    \ {\n                                      ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar letters = [String: Int]()\n\tfor letter := range test.lowercased()\
    \ {\n\t\tif letters[letter] == nil {\n\t\t\tletters[letter] = 1\n\t\t} else {\n\
    \t\t\tletters[letter]!++\n\t\t}\n\t}\n\treturn letters\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmphv8sxidb.swift:18:14: error: expected type\n        for letter\
    \ := range test.lowercased() {\n                    ^\n                     <#type#>\n\
    /tmp/tmphv8sxidb.swift:18:14: error: expected 'in' after for-each pattern\n  \
    \      for letter := range test.lowercased() {\n                    ^\n/tmp/tmphv8sxidb.swift:18:14:\
    \ error: expected Sequence expression for for-each loop\n        for letter :=\
    \ range test.lowercased() {\n                    ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var charCount = [String : Int]()\n    test.unicodeScalars.forEach\
    \ { char in\n        if let _ = charCount[char] {\n            charCount[char]\
    \ = charCount[char] + 1\n        }\n        else {\n            charCount[char]\
    \ = 1\n        }\n    }\n    return charCount\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpmxp1d9jp.swift:19:29: error: subscript 'subscript(_:)' requires\
    \ that 'Unicode.Scalar' conform to 'RangeExpression'\n        if let _ = charCount[char]\
    \ {\n                            ^\nSwift.Collection:2:23: note: where 'R' = 'Unicode.Scalar'\n\
    \    @inlinable public subscript<R>(r: R) -> Self.SubSequence where R : RangeExpression,\
    \ Self.Index == R.Bound { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    \n    var result = [:]\n    var letters = [String]()\n    \n   \
    \ letters = test.split(separator: \" \")\n    \n    for letter in letters {\n\
    \        \n        let count = result[letter] ?? 0\n        \n        result[letter]\
    \ = count + 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp6ia451hf.swift:18:18: error: empty collection literal requires\
    \ an explicit type\n    var result = [:]\n                 ^~~\n/tmp/tmp6ia451hf.swift:21:13:\
    \ error: cannot assign value of type '[String.SubSequence]' (aka 'Array<Substring>')\
    \ to type '[String]'\n    letters = test.split(separator: \" \")\n           \
    \ ^\n/tmp/tmp6ia451hf.swift:21:13: note: arguments to generic parameter 'Element'\
    \ ('String.SubSequence' (aka 'Substring') and 'String') are expected to be equal\n\
    \    letters = test.split(separator: \" \")\n            ^\n/tmp/tmp6ia451hf.swift:27:26:\
    \ error: cannot convert value of type 'Any' to expected argument type 'Int'\n\
    \        result[letter] = count + 1\n                         ^\n            \
    \                   as! Int\n/tmp/tmp6ia451hf.swift:30:12: error: cannot convert\
    \ return expression of type '[AnyHashable : Any]' to return type '[String : Int]'\n\
    \    return result\n           ^\n/tmp/tmp6ia451hf.swift:30:12: note: arguments\
    \ to generic parameter 'Key' ('AnyHashable' and 'String') are expected to be equal\n\
    \    return result\n           ^\n/tmp/tmp6ia451hf.swift:30:12: note: arguments\
    \ to generic parameter 'Value' ('Any' and 'Int') are expected to be equal\n  \
    \  return result\n           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters = [String : Int]()\n    for letter in test.characters\
    \ {\n        if let count = letters[letter] {\n            letters[letter] = count\
    \ + 1\n        } else {\n            letters[letter] = 1\n        }\n    }\n \
    \   return letters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpmpqwq1t4.swift:18:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in test.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpmpqwq1t4.swift:19:32:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let count = letters[letter] {\n                               ^\n\
    /tmp/tmpmpqwq1t4.swift:20:21: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            letters[letter] = count + 1\n\
    \                    ^\n/tmp/tmpmpqwq1t4.swift:22:21: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            letters[letter]\
    \ = 1\n                    ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram: [String : Int] = [:]\n    for letter in test.lowercaseString.characters\
    \ {\n        if histogram.values.contains(letter) {\n            histogram[letter]\
    \ = histogram.values[letter] + 1\n        } else {\n            histogram[letter]\
    \ = 1\n        }\n    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpsiiql60z.swift:18:24: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    for letter in test.lowercaseString.characters {\n   \
    \               ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let testArray = test.split(separator: \" \").map { $0.lowercased()\
    \ } else { return [:] }\n    let histogramsArray: [String : Int] = [:]\n    for\
    \ string in testArray {\n        histogramsArray[string] = (histogramsArray[string]\
    \ ?? 0) + 1;\n    }\n    return histogramsArray\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpo2su_t3y.swift:17:58: error: expected 'else' after 'guard' condition\n\
    \    guard let testArray = test.split(separator: \" \").map { $0.lowercased()\
    \ } else { return [:] }\n                                                    \
    \     ^\n                                                         else \n/tmp/tmpo2su_t3y.swift:17:60:\
    \ error: anonymous closure argument not contained in a closure\n    guard let\
    \ testArray = test.split(separator: \" \").map { $0.lowercased() } else { return\
    \ [:] }\n                                                           ^\n/tmp/tmpo2su_t3y.swift:17:77:\
    \ error: consecutive statements on a line must be separated by ';'\n    guard\
    \ let testArray = test.split(separator: \" \").map { $0.lowercased() } else {\
    \ return [:] }\n                                                             \
    \               ^\n                                                          \
    \                  ;\n/tmp/tmpo2su_t3y.swift:17:78: error: expected expression\n\
    \    guard let testArray = test.split(separator: \" \").map { $0.lowercased()\
    \ } else { return [:] }\n                                                    \
    \                         ^\n/tmp/tmpo2su_t3y.swift:17:32: error: generic parameter\
    \ 'T' could not be inferred\n    guard let testArray = test.split(separator: \"\
    \ \").map { $0.lowercased() } else { return [:] }\n                          \
    \     ^\nSwift.Collection:2:28: note: in call to function 'map'\n    @inlinable\
    \ public func map<T>(_ transform: (Self.Element) throws -> T) rethrows -> [T]\n\
    \                           ^\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar frequencies = [String : Int]()\n\tfor letter in test {\n\t\tif\
    \ frequencies[letter] == nil {\n\t\t\tfrequencies[letter] = 1\n\t\t} else {\n\t\
    \t\tfrequencies[letter]!++\n\t\t}\n\t}\n\treturn frequencies\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp0l0tmqu4.swift:19:18: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                if frequencies[letter] ==\
    \ nil {\n                               ^\n/tmp/tmp0l0tmqu4.swift:20:16: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                        frequencies[letter] = 1\n                           \
    \         ^\n/tmp/tmp0l0tmqu4.swift:22:24: error: cannot find operator '++' in\
    \ scope; did you mean '+= 1'?\n                        frequencies[letter]!++\n\
    \                                            ^~\n/tmp/tmp0l0tmqu4.swift:22:16:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                        frequencies[letter]!++\n                            \
    \        ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tguard !test.isEmpty else { return [:] }\n\n\tlet result = test.componentsSeparatedByCharactersInSet(NSCharacterSet.lowercaseLetterCharacterSet())\n\
    \t\t.map { (letter) -> String in\n\t\t\tlet letterCount = letters.filter{ $0.letter\
    \ ==  letter }.count\n\t\t\treturn letter == letter ? letter : [letter, letterCount]\n\
    \t\t}\n\t\t.filter { $0.count > 1 }\n\t\t.sorted(by: { $0.1 < $1.1 }).reduce(into:\
    \ [String : Int]()) { (result, e) in\n\t\t\tresult[e.0] = (result[e.0] ?? 0) +\
    \ e.1\n\t\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmph51w7ovr.swift:19:57: error: cannot find 'NSCharacterSet' in scope\n\
    \        let result = test.componentsSeparatedByCharactersInSet(NSCharacterSet.lowercaseLetterCharacterSet())\n\
    \                                                               ^~~~~~~~~~~~~~\n\
    /tmp/tmph51w7ovr.swift:21:22: error: cannot find 'letters' in scope\n        \
    \                let letterCount = letters.filter{ $0.letter ==  letter }.count\n\
    \                                          ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009570
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters: [String: Int] = [:]\n    for char in test.lowercased()\
    \ {\n        letters[char] = (letters[char]!?.0) + 1\n    }\n    return letters\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp98n_4krd.swift:19:42: error: cannot convert value of type 'String?'\
    \ to expected argument type 'Int'\n        letters[char] = (letters[char]!?.0)\
    \ + 1\n                                         ^\n/tmp/tmp98n_4krd.swift:19:34:\
    \ error: cannot convert value of type 'Character' to expected argument type 'Dictionary<String,\
    \ Int>.Index'\n        letters[char] = (letters[char]!?.0) + 1\n             \
    \                    ^\n/tmp/tmp98n_4krd.swift:19:17: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n        letters[char]\
    \ = (letters[char]!?.0) + 1\n                ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if testIsEmpty(test) {\n        return [:]\n    }\n    let chars\
    \ = test.characters\n    var histogram: [String : Int] = [:]\n    var currentLetter\
    \ = nil\n    var currentOccurrence = 0\n    for char in chars {\n        guard\
    \ let countValue = histogram[char] else {\n            histogram[char] = 1\n \
    \       } else {\n            histogram[char] += countValue\n        }\n     \
    \   if currentLetter == nil {\n            currentLetter = char\n        } else\
    \ if char == currentLetter {\n            currentOccurrence += 1\n           \
    \ currentLetter = nil\n        } else {\n            if currentOccurrence > histogram[currentLetter]\
    \ {\n                histogram[currentLetter] = currentOccurrence\n          \
    \      currentOccurrence = 1\n                currentLetter = char\n         \
    \   }\n        }\n    }\n    if currentOccurrence > histogram[currentLetter] {\n\
    \        histogram[currentLetter] = currentOccurrence\n    }\n    return histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpdsstoe6b.swift:27:10: error: consecutive statements on a line must\
    \ be separated by ';'\n        } else {\n         ^\n         ;\n/tmp/tmpdsstoe6b.swift:27:11:\
    \ error: expected expression\n        } else {\n          ^\n/tmp/tmpdsstoe6b.swift:17:8:\
    \ error: cannot find 'testIsEmpty' in scope\n    if testIsEmpty(test) {\n    \
    \   ^~~~~~~~~~~\n/tmp/tmpdsstoe6b.swift:20:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    let chars = test.characters\n              \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpdsstoe6b.swift:22:25:\
    \ error: 'nil' requires a contextual type\n    var currentLetter = nil\n     \
    \                   ^\n/tmp/tmpdsstoe6b.swift:25:42: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n        guard let countValue\
    \ = histogram[char] else {\n                                         ^\n/tmp/tmpdsstoe6b.swift:26:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            histogram[char] = 1\n                      ^\n/tmp/tmpdsstoe6b.swift:36:34:\
    \ error: binary operator '>' cannot be applied to operands of type 'Int' and '(key:\
    \ String, value: Int)'\n            if currentOccurrence > histogram[currentLetter]\
    \ {\n               ~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdsstoe6b.swift:36:34:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            if currentOccurrence > histogram[currentLetter] {\n\
    \                                 ^\n/tmp/tmpdsstoe6b.swift:43:26: error: binary\
    \ operator '>' cannot be applied to operands of type 'Int' and '(key: String,\
    \ value: Int)'\n    if currentOccurrence > histogram[currentLetter] {\n      \
    \ ~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdsstoe6b.swift:43:26:\
    \ note: overloads for '>' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    if currentOccurrence > histogram[currentLetter] {\n        \
    \                 ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [:]\n    }\n    var histogram:\
    \ [String : Int] = [:]\n    for letter in test.lowercaseString.split(separator:\
    \ \" \") {\n        histogram[letter] = (histogram[letter] ?? 0) + 1\n    }\n\
    \    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp463gd84g.swift:21:24: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    for letter in test.lowercaseString.split(separator: \"\
    \ \") {\n                  ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var dict: [String : Int] = [:]\n\n    test.split(separator: \" \"\
    ).forEach { word in\n        dict[word] = (dict[word] ?? 0) + 1\n    }\n\n   \
    \ return dict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpz53sd_17.swift:20:14: error: cannot convert value of type 'String.SubSequence'\
    \ (aka 'Substring') to expected argument type 'String'\n        dict[word] = (dict[word]\
    \ ?? 0) + 1\n             ^\n             String( )\n/tmp/tmpz53sd_17.swift:20:28:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        dict[word] = (dict[word] ?? 0) + 1\n\
    \                           ^\n                           String( )\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test.characters.reduce(into: [String : Int]()) {\n      \
    \  histogram($0.value, $0.key, $1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpkr_migxz.swift:18:18: error: extra arguments at positions #2, #3\
    \ in call\n        histogram($0.value, $0.key, $1)\n                 ^\n/tmp/tmpkr_migxz.swift:16:6:\
    \ note: 'histogram(test:)' declared here\nfunc histogram(test: String) -> [String\
    \ : Int] {\n     ^\n/tmp/tmpkr_migxz.swift:18:22: error: value of type '[String\
    \ : Int]' has no member 'value'\n        histogram($0.value, $0.key, $1)\n   \
    \               ~~ ^~~~~\n/tmp/tmpkr_migxz.swift:18:32: error: value of type '[String\
    \ : Int]' has no member 'key'\n        histogram($0.value, $0.key, $1)\n     \
    \                       ~~ ^~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" { return [:] }\n\n    var histogram = [String :\
    \ Int]()\n    var letterCounts = [String : Int]()\n    var letters = test.lowercased()\n\
    \    for letter in letters {\n        if let count = letterCounts[letter] {\n\
    \            histogram[letter] = count + 1\n        } else {\n            letterCounts[letter]\
    \ = 1\n        }\n    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpmo3w_sm6.swift:23:37: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if let count = letterCounts[letter]\
    \ {\n                                    ^\n/tmp/tmpmo3w_sm6.swift:24:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            histogram[letter] = count + 1\n                      ^\n/tmp/tmpmo3w_sm6.swift:26:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            letterCounts[letter] = 1\n                         ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram: [String : Int] = [:]\n    test.split(\" \").forEach\
    \ { char in\n        histogram[char] = (histogram[char] ?? 0) + 1\n    }\n   \
    \ return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7hgud8sr.swift:18:10: error: no exact matches in call to instance\
    \ method 'split'\n    test.split(\" \").forEach { char in\n         ^\n/tmp/tmp7hgud8sr.swift:18:10:\
    \ note: candidate has partially matching parameter list (separator: String.Element,\
    \ maxSplits: Int, omittingEmptySubsequences: Bool)\n    test.split(\" \").forEach\
    \ { char in\n         ^\n/tmp/tmp7hgud8sr.swift:18:10: note: candidate has partially\
    \ matching parameter list (separator: String.Element, maxSplits: Int, omittingEmptySubsequences:\
    \ Bool)\n    test.split(\" \").forEach { char in\n         ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    histogramCount := [String : Int]()\n\n    for _, char := range test\
    \ {\n        if _, exists := histogramCount[char]; !exists {\n            histogramCount[char]\
    \ = 1\n        } else {\n            histogramCount[char]++\n        }\n    }\n\
    \n    return histogramCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpx6nm1ld1.swift:17:19: error: consecutive statements on a line must\
    \ be separated by ';'\n    histogramCount := [String : Int]()\n              \
    \    ^\n                  ;\n/tmp/tmpx6nm1ld1.swift:17:20: error: expected expression\n\
    \    histogramCount := [String : Int]()\n                   ^\n/tmp/tmpx6nm1ld1.swift:19:10:\
    \ error: expected 'in' after for-each pattern\n    for _, char := range test {\n\
    \         ^\n/tmp/tmpx6nm1ld1.swift:19:10: error: expected Sequence expression\
    \ for for-each loop\n    for _, char := range test {\n         ^\n/tmp/tmpx6nm1ld1.swift:20:22:\
    \ error: expected '{' after 'if' condition\n        if _, exists := histogramCount[char];\
    \ !exists {\n                     ^\n/tmp/tmpx6nm1ld1.swift:17:5: error: cannot\
    \ find 'histogramCount' in scope\n    histogramCount := [String : Int]()\n   \
    \ ^~~~~~~~~~~~~~\n/tmp/tmpx6nm1ld1.swift:27:12: error: cannot find 'histogramCount'\
    \ in scope\n    return histogramCount\n           ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" { return [:] }\n\n    var map = [:] as [String :\
    \ Int]\n    var words = test.split(\" \")\n    for word in words {\n        guard\
    \ let value = map[word] else {\n            map[word] = 1\n            continue\n\
    \        }\n        map[word] += 1\n    }\n\n    return map\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp9b0fgry8.swift:20:22: error: no exact matches in call to instance\
    \ method 'split'\n    var words = test.split(\" \")\n                     ^\n\
    Swift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)', expected:\
    \ '(separator:)')\n    @inlinable public __consuming func split(separator: Self.Element,\
    \ maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n\
    \                                       ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters = [String: Int]()\n    for letter in test.lowercaseString.split(separator:\
    \ \" \") {\n        letters[letter] = (letters[letter] ?? 0) + 1\n    }\n    return\
    \ letters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp2g21kjl6.swift:18:24: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    for letter in test.lowercaseString.split(separator: \"\
    \ \") {\n                  ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tresult := [String: Int]()\n\ttest.splitN(\" \")\n\t\t.reduce([String:\
    \ Int]()) { (result, word) in\n\t\t\tresult[(word)] = result[(word)] + 1\n\t\t\
    \treturn result\n\t\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpxaho556y.swift:17:8: error: consecutive statements on a line must\
    \ be separated by ';'\n        result := [String: Int]()\n              ^\n  \
    \            ;\n/tmp/tmpxaho556y.swift:17:9: error: expected expression\n    \
    \    result := [String: Int]()\n               ^\n/tmp/tmpxaho556y.swift:17:2:\
    \ error: cannot find 'result' in scope\n        result := [String: Int]()\n  \
    \      ^~~~~~\n/tmp/tmpxaho556y.swift:23:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n  return countAndSort(test.split(\" \"), by: { $0 })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpex5l1ktk.swift:17:10: error: cannot find 'countAndSort' in scope\n\
    \  return countAndSort(test.split(\" \"), by: { $0 })\n         ^~~~~~~~~~~~\n\
    /tmp/tmpex5l1ktk.swift:17:28: error: no exact matches in call to instance method\
    \ 'split'\n  return countAndSort(test.split(\" \"), by: { $0 })\n            \
    \               ^\n/tmp/tmpex5l1ktk.swift:17:28: note: found candidate with type\
    \ '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]' (aka '(Character,\
    \ Int, Bool) -> Array<ArraySlice<Character>>')\n  return countAndSort(test.split(\"\
    \ \"), by: { $0 })\n                           ^\n/tmp/tmpex5l1ktk.swift:17:28:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [String.SubSequence]'\
    \ (aka '(Character, Int, Bool) -> Array<Substring>')\n  return countAndSort(test.split(\"\
    \ \"), by: { $0 })\n                           ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [:] as [String : Int]\n    }\n\
    \n    var letters = test.characters.flatMap({ $0.lowercased() })\n    var histogram:\
    \ [String : Int] = [:]\n    for letter in letters {\n        histogram[letter]\
    \ = (histogram[letter] ?? 0) + 1\n    }\n    return histogram\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpc5ddwejz.swift:21:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    var letters = test.characters.flatMap({ $0.lowercased()\
    \ })\n                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpc5ddwejz.swift:24:19: error: cannot convert value of\
    \ type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        histogram[letter] = (histogram[letter] ?? 0) + 1\n                  ^\n\
    /tmp/tmpc5ddwejz.swift:24:40: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        histogram[letter]\
    \ = (histogram[letter] ?? 0) + 1\n                                       ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [:] as [String : Int]\n    }\n\
    \    \n    var map = [:] as [String : Int]\n    test.split(\" \").forEach { word\
    \ in\n        word = (word + \"\").lowercased()\n        if map.keys.contains(word)\
    \ {\n            map[word]! += 1;\n        } else {\n            map[word] = 1\n\
    \        }\n    }\n    \n    return map\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7twi_7rv.swift:22:10: error: no exact matches in call to instance\
    \ method 'split'\n    test.split(\" \").forEach { word in\n         ^\n/tmp/tmp7twi_7rv.swift:22:10:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    test.split(\"\
    \ \").forEach { word in\n         ^\n/tmp/tmp7twi_7rv.swift:22:10: note: found\
    \ candidate with type '(String.Element, Int, Bool) -> [String.SubSequence]' (aka\
    \ '(Character, Int, Bool) -> Array<Substring>')\n    test.split(\" \").forEach\
    \ { word in\n         ^\n/tmp/tmp7twi_7rv.swift:23:9: error: cannot assign to\
    \ value: 'word' is a 'let' constant\n        word = (word + \"\").lowercased()\n\
    \        ^~~~\n/tmp/tmp7twi_7rv.swift:23:28: error: no 'lowercased' candidates\
    \ produce the expected contextual result type 'ArraySlice<String.Element>' (aka\
    \ 'ArraySlice<Character>')\n        word = (word + \"\").lowercased()\n      \
    \                     ^\nSwift.String:2:17: note: 'lowercased()' produces 'String',\
    \ not the expected contextual result type 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>')\n\
    \    public func lowercased() -> String\n                ^\nSwift.Substring:2:17:\
    \ note: 'lowercased()' produces 'String', not the expected contextual result type\
    \ 'String.SubSequence' (aka 'Substring')\n    public func lowercased() -> String\n\
    \                ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result = Dictionary<String, Int>()\n    for c in test.lowercased()\
    \ {\n        result[c] = result[c] ?? 0\n        result[c] += 1\n    }\n    let\
    \ sorted = Dictionary(grouping: result.values, by: { $0 })\n    return sorted\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpx5_f1ify.swift:19:16: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        result[c] = result[c] ?? 0\n   \
    \            ^\n/tmp/tmpx5_f1ify.swift:19:28: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n        result[c] = result[c]\
    \ ?? 0\n                           ^\n/tmp/tmpx5_f1ify.swift:20:16: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   result[c] += 1\n               ^\n/tmp/tmpx5_f1ify.swift:20:15: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ result[c] += 1\n              ^\n/tmp/tmpx5_f1ify.swift:20:15: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        result[c]\
    \ += 1\n              ^\n                 !\n/tmp/tmpx5_f1ify.swift:23:12: error:\
    \ cannot convert return expression of type '[Dictionary<String, Int>.Values.Element\
    \ : [Dictionary<String, Int>.Values.Element]]' (aka 'Dictionary<Int, Array<Int>>')\
    \ to return type '[String : Int]'\n    return sorted\n           ^\n/tmp/tmpx5_f1ify.swift:23:12:\
    \ note: arguments to generic parameter 'Key' ('Dictionary<String, Int>.Values.Element'\
    \ (aka 'Int') and 'String') are expected to be equal\n    return sorted\n    \
    \       ^\n/tmp/tmpx5_f1ify.swift:23:12: note: arguments to generic parameter\
    \ 'Value' ('[Dictionary<String, Int>.Values.Element]' (aka 'Array<Int>') and 'Int')\
    \ are expected to be equal\n    return sorted\n           ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var count = [String : Int]()\n    for char in test.characters {\n\
    \        if let char = String(char) {\n            let count = count[char] ??\
    \ 0\n            count[char] = count + 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7r3uhjn6.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in test.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp7r3uhjn6.swift:21:18:\
    \ error: value of type 'Int' has no subscripts\n            count[char] = count\
    \ + 1\n            ~~~~~^\n/tmp/tmp7r3uhjn6.swift:19:12: error: initializer for\
    \ conditional binding must have Optional type, not 'String'\n        if let char\
    \ = String(char) {\n           ^          ~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" { //empty string is considered as empty list\n \
    \       return [:] as [String : Int]\n    }\n    var result = [String : Int]()\n\
    \    var letters: [String] = test.split(\" \").map { String($0) }\n    for letter\
    \ in letters {\n        result[letter] = (result[letter] ?? 0) + 1\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpoa4gv9s2.swift:21:40: error: missing argument label 'separator:'\
    \ in call\n    var letters: [String] = test.split(\" \").map { String($0) }\n\
    \                                       ^\n                                  \
    \     separator: \n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String: Int]()\n    var count = 0\n    var letters\
    \ = \"\"\n\n    for letter in test {\n        if letters.isEmpty {\n         \
    \   letters += letter\n        } else {\n            letters += \" \"\n      \
    \      letters += letter\n        }\n        if histogram[letters.lowercased()]\
    \ == nil {\n            histogram[letters.lowercased()] = Int()\n        }\n \
    \       histogram[letters.lowercased()] = histogram[letters.lowercased()] + 1\n\
    \    }\n\n    for letter in histogram {\n        if histogram[letter] == nil {\n\
    \            histogram[letter] = Int()\n        }\n    }\n\n    return histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp2hkm4oiz.swift:23:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            letters += letter\n        \
    \               ^\n/tmp/tmp2hkm4oiz.swift:26:24: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            letters +=\
    \ letter\n                       ^\n/tmp/tmp2hkm4oiz.swift:31:52: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ histogram[letters.lowercased()] = histogram[letters.lowercased()] + 1\n    \
    \                                               ^\n/tmp/tmp2hkm4oiz.swift:31:52:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        histogram[letters.lowercased()] = histogram[letters.lowercased()]\
    \ + 1\n                                                   ^\n                \
    \                          (                               ?? <#default value#>)\n\
    /tmp/tmp2hkm4oiz.swift:31:52: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n        histogram[letters.lowercased()]\
    \ = histogram[letters.lowercased()] + 1\n                                    \
    \               ^\n                                                          \
    \               !\n/tmp/tmp2hkm4oiz.swift:35:22: error: cannot convert value of\
    \ type '(key: String, value: Int)' to expected argument type 'String'\n      \
    \  if histogram[letter] == nil {\n                     ^\n/tmp/tmp2hkm4oiz.swift:36:23:\
    \ error: cannot convert value of type '(key: String, value: Int)' to expected\
    \ argument type 'String'\n            histogram[letter] = Int()\n            \
    \          ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tguard !test.isEmpty else { return [:] }\n\tlet letterCount = [Character\
    \ : Int]()\n\tfor letter in test.lowercased() {\n\t\tletterCount[letter] = (letterCount[letter]\
    \ ?? 0) + 1\n\t}\n\treturn letterCount\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpn5tca78b.swift:20:14: error: cannot assign through subscript: 'letterCount'\
    \ is a 'let' constant\n                letterCount[letter] = (letterCount[letter]\
    \ ?? 0) + 1\n                ~~~~~~~~~~~^\n/tmp/tmpn5tca78b.swift:18:2: note:\
    \ change 'let' to 'var' to make it mutable\n        let letterCount = [Character\
    \ : Int]()\n        ^~~\n        var\n/tmp/tmpn5tca78b.swift:22:9: error: cannot\
    \ convert return expression of type '[Character : Int]' to return type '[String\
    \ : Int]'\n        return letterCount\n               ^\n/tmp/tmpn5tca78b.swift:22:9:\
    \ note: arguments to generic parameter 'Key' ('Character' and 'String') are expected\
    \ to be equal\n        return letterCount\n               ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n  var result = [:]\n  for letter in test.lowercaseString.split(\" \"\
    ) {\n    guard let count = result[letter] else {\n      result[letter] = 1\n \
    \     continue\n    }\n    result[letter] = count + 1\n  }\n  return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp0rzpymbi.swift:17:16: error: empty collection literal requires\
    \ an explicit type\n  var result = [:]\n               ^~~\n/tmp/tmp0rzpymbi.swift:18:22:\
    \ error: value of type 'String' has no member 'lowercaseString'\n  for letter\
    \ in test.lowercaseString.split(\" \") {\n                ~~~~ ^~~~~~~~~~~~~~~\n\
    /tmp/tmp0rzpymbi.swift:25:10: error: cannot convert return expression of type\
    \ '[AnyHashable : Any]' to return type '[String : Int]'\n  return result\n   \
    \      ^\n/tmp/tmp0rzpymbi.swift:25:10: note: arguments to generic parameter 'Key'\
    \ ('AnyHashable' and 'String') are expected to be equal\n  return result\n   \
    \      ^\n/tmp/tmp0rzpymbi.swift:25:10: note: arguments to generic parameter 'Value'\
    \ ('Any' and 'Int') are expected to be equal\n  return result\n         ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tif test == \"\" {\n\t\treturn [:] as [String : Int]\n\t}\n\n\thistogram\
    \ := [:]\n\tvar maxCount : Int = -1\n\tvar maxKey : String = \"\"\n\n\tfor _,\
    \ charAt := range test {\n\t\tcount := histogram[charAt] ?? 0\n\t\thistogram[charAt]\
    \ = count + 1\n\t\tif count > maxCount {\n\t\t\tmaxCount = count\n\t\t\tmaxKey\
    \ = charAt\n\t\t}\n\t}\n\n\treturn histogram\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpv97aurfs.swift:21:11: error: consecutive statements on a line must\
    \ be separated by ';'\n        histogram := [:]\n                 ^\n        \
    \         ;\n/tmp/tmpv97aurfs.swift:21:12: error: expected expression\n      \
    \  histogram := [:]\n                  ^\n/tmp/tmpv97aurfs.swift:25:7: error:\
    \ expected 'in' after for-each pattern\n        for _, charAt := range test {\n\
    \             ^\n/tmp/tmpv97aurfs.swift:25:7: error: expected Sequence expression\
    \ for for-each loop\n        for _, charAt := range test {\n             ^\n/tmp/tmpv97aurfs.swift:26:8:\
    \ error: consecutive statements on a line must be separated by ';'\n         \
    \       count := histogram[charAt] ?? 0\n                     ^\n            \
    \         ;\n/tmp/tmpv97aurfs.swift:26:9: error: expected expression\n       \
    \         count := histogram[charAt] ?? 0\n                      ^\n/tmp/tmpv97aurfs.swift:21:2:\
    \ error: function is unused\n        histogram := [:]\n        ^~~~~~~~~\n/tmp/tmpv97aurfs.swift:34:9:\
    \ error: cannot convert return expression of type '(String) -> [String : Int]'\
    \ to return type '[String : Int]'\n        return histogram\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result = [String : Int]()\n    test.split(separator: \" \").forEach\
    \ { (letter) in\n        result[letter] = (result[letter] ?? 0) + 1\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp5l_83853.swift:19:16: error: cannot convert value of type 'String.SubSequence'\
    \ (aka 'Substring') to expected argument type 'String'\n        result[letter]\
    \ = (result[letter] ?? 0) + 1\n               ^\n               String( )\n/tmp/tmp5l_83853.swift:19:34:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        result[letter] = (result[letter] ??\
    \ 0) + 1\n                                 ^\n                               \
    \  String( )\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let letters = test.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \    var letterCounts = [String : Int]()\n    letters.split(separator: \" \").forEach\
    \ { letter in\n        let count = letterCounts[letter] ?? 0\n        letterCounts[letter]\
    \ = count + 1\n    }\n    return letterCounts\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp6uoexu8f.swift:17:47: error: cannot find 'CharacterSet' in scope\n\
    \    let letters = test.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n\
    \                                              ^~~~~~~~~~~~\n/tmp/tmp6uoexu8f.swift:17:24:\
    \ error: value of type 'String' has no member 'trimmingCharacters'\n    let letters\
    \ = test.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)\n       \
    \           ~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    func updateCounter(char: String)\
    \ {\n        histogram[char] = (histogram[char] ?? 0) + 1\n    }\n    test.unicodeScalars.forEach\
    \ { updateCounter($0.value) }\n    return histogram\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpkq05w86o.swift:21:49: error: missing argument label 'char:' in\
    \ call\n    test.unicodeScalars.forEach { updateCounter($0.value) }\n        \
    \                                        ^\n                                 \
    \               char: \n/tmp/tmpkq05w86o.swift:21:52: error: cannot convert value\
    \ of type 'UInt32' to expected argument type 'String'\n    test.unicodeScalars.forEach\
    \ { updateCounter($0.value) }\n                                              \
    \     ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let lowercased = test.lowercased() else {\n        return\
    \ [String : Int]()\n    }\n\n    var histogram = [String : Int]()\n    \n    for\
    \ i in lowercased.characters {\n        let letter = String(i).uppercased()\n\n\
    \        if let count = histogram[letter] {\n            histogram[letter] = 1\
    \ + count\n        } else {\n            histogram[letter] = 1\n        }\n  \
    \  }\n    \n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp4iwml8tx.swift:17:11: error: initializer for conditional binding\
    \ must have Optional type, not 'String'\n    guard let lowercased = test.lowercased()\
    \ else {\n          ^                ~~~~~~~~~~~~~~~~~\n/tmp/tmp4iwml8tx.swift:23:25:\
    \ error: 'characters' is unavailable: Please use String directly\n    for i in\
    \ lowercased.characters {\n                        ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    \n    var result: [String : Int] = [:]\n    var letter: String =\
    \ test.characters.map({ String($0) })\n    letter = letter.reduce(into: [String:\
    \ Int]()) { (result, next, letter) in\n        \n        var count = 1\n     \
    \   result[letter] = (result[letter] ?? 0) + count\n        \n        if letter\
    \ == next {\n            count += 1\n        }\n        \n        result[letter]\
    \ = count\n    }\n    \n    return letter\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpeiafklbx.swift:19:42: error: cannot convert value of type '[String]'\
    \ to specified type 'String'\n    var letter: String = test.characters.map({ String($0)\
    \ })\n                         ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeiafklbx.swift:20:21:\
    \ error: cannot assign value of type '[String : Int]' to type 'String'\n    letter\
    \ = letter.reduce(into: [String: Int]()) { (result, next, letter) in\n       \
    \      ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpeiafklbx.swift:20:53:\
    \ error: contextual closure type '(inout [String : Int], String.Element) throws\
    \ -> ()' (aka '(inout Dictionary<String, Int>, Character) throws -> ()') expects\
    \ 2 arguments, but 3 were used in closure body\n    letter = letter.reduce(into:\
    \ [String: Int]()) { (result, next, letter) in\n                             \
    \                       ^\n/tmp/tmpeiafklbx.swift:32:12: error: cannot convert\
    \ return expression of type 'String' to return type '[String : Int]'\n    return\
    \ letter\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test.split().reduce(into: [String : Int]()) {\n        ($1,\
    \ $2) in\n        if let value = $1[$2] {\n            $1[$2] = value + 1\n  \
    \      } else {\n            $1[$2] = 1\n        }\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpj225w0j7.swift:18:10: error: expected parameter name followed by\
    \ ':'\n        ($1, $2) in\n         ^\n/tmp/tmpj225w0j7.swift:18:14: error: expected\
    \ parameter name followed by ':'\n        ($1, $2) in\n             ^\n/tmp/tmpj225w0j7.swift:19:24:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments\n        if let value = $1[$2] {\n                      \
    \ ^\n/tmp/tmpj225w0j7.swift:19:27: error: anonymous closure arguments cannot be\
    \ used inside a closure that has explicit arguments\n        if let value = $1[$2]\
    \ {\n                          ^\n/tmp/tmpj225w0j7.swift:20:13: error: anonymous\
    \ closure arguments cannot be used inside a closure that has explicit arguments\n\
    \            $1[$2] = value + 1\n            ^\n/tmp/tmpj225w0j7.swift:20:16:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments\n            $1[$2] = value + 1\n               ^\n/tmp/tmpj225w0j7.swift:22:13:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments\n            $1[$2] = 1\n            ^\n/tmp/tmpj225w0j7.swift:22:16:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments\n            $1[$2] = 1\n               ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test.split(\" \").map { $0.lowercased() }\n        .filter\
    \ { !$0.isEmpty }\n        .map {\n            ($0, test.split($0).reduce(0,+))\n\
    \        }\n        .reduce([String : Int]()) { $0 + [$1 : ($1 ?? 0) + $0] }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpy4y02dzs.swift:17:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return test.split(\" \").map { $0.lowercased() }\n    \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009617
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let testChars = test.characters\n    var histogram = [String : Int]()\n\
    \n    for i in 0..<testChars.count {\n        if let v = histogram[testChars[i]]\
    \ {\n            histogram[testChars[i]] += 1\n        } else {\n            histogram[testChars[i]]\
    \ = 1\n        }\n    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpttp82umc.swift:17:26: error: 'characters' is unavailable: Please\
    \ use String directly\n    let testChars = test.characters\n                 \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpttp82umc.swift:21:39:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let v = histogram[testChars[i]] {\n                              \
    \        ^\n/tmp/tmpttp82umc.swift:22:32: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            histogram[testChars[i]]\
    \ += 1\n                               ^\n/tmp/tmpttp82umc.swift:22:22: error:\
    \ value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n \
    \           histogram[testChars[i]] += 1\n                     ^\n/tmp/tmpttp82umc.swift:22:22:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            histogram[testChars[i]] += 1\n                     ^\n  \
    \                                 !\n/tmp/tmpttp82umc.swift:24:32: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       histogram[testChars[i]] = 1\n                               ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let words = test.split(separator: \" \")\n    return words.reduce(into:\
    \ [String : Int](), { result, word in\n        result[word] = (result[word] ??\
    \ 0) + 1\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpbg84c1lb.swift:19:16: error: cannot convert value of type 'String.SubSequence'\
    \ (aka 'Substring') to expected argument type 'String'\n        result[word] =\
    \ (result[word] ?? 0) + 1\n               ^\n               String( )\n/tmp/tmpbg84c1lb.swift:19:32:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n        result[word] = (result[word] ?? 0)\
    \ + 1\n                               ^\n                               String(\
    \ )\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [:] as [String : Int]\n    for letter in test.lowercased()\
    \ {\n        let index = histogram.count\n        histogram[letter] = index\n\
    \    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp43nvcj6u.swift:20:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        histogram[letter] = index\n    \
    \              ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters: [String: Int] = [:]\n    for letter in test.split(\"\
    \ \") {\n        letters[letter] = (letters[letter] ?? 0) + 1\n    }\n    return\
    \ letters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpnf3a1fdm.swift:18:24: error: no exact matches in call to instance\
    \ method 'split'\n    for letter in test.split(\" \") {\n                    \
    \   ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tif test == \"\" {\n\t\treturn [:]\n\t}\n\n\tvar histogram: [String\
    \ : Int] = [:]\n\n\tfor word in test.split(\" \") {\n\t\thistogram[word] = histogram.getOrDefault(word,\
    \ 0) + 1\n\t}\n\n\treturn histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpff39duyg.swift:23:19: error: no exact matches in call to instance\
    \ method 'split'\n        for word in test.split(\" \") {\n                  \
    \       ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var occurrence: [String : Int] = [:]\n\n    for letter in test.characters\
    \ {\n        if let count = occurrence[letter] {\n            occurrence[letter]\
    \ = count + 1\n        } else {\n            occurrence[letter] = 1\n        }\n\
    \    }\n\n    return occurrence\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpo35vmm44.swift:19:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in test.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpo35vmm44.swift:20:35:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let count = occurrence[letter] {\n                               \
    \   ^\n/tmp/tmpo35vmm44.swift:21:24: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            occurrence[letter] = count +\
    \ 1\n                       ^\n/tmp/tmpo35vmm44.swift:23:24: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            occurrence[letter]\
    \ = 1\n                       ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    \n    let letters = test.lowercaseString.split(separator: \" \"\
    )\n    \n    var dictionary: [String : Int] = [:]\n    \n    for letter in letters\
    \ {\n        let occurrences = dictionary[letter] ?? 0\n        dictionary[letter]\
    \ = occurrences + 1\n    }\n    \n    return dictionary\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpwlbqav2e.swift:18:24: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    let letters = test.lowercaseString.split(separator: \"\
    \ \")\n                  ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n    var i: Int = 1\n    for letter\
    \ in test.lowercaseString.split(\" \") {\n        result[letter] = result[letter]\
    \ + i\n        i = i + 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpjoj98xr0.swift:19:24: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    for letter in test.lowercaseString.split(\" \") {\n \
    \                 ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram(test.characters.map { String($0) })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpd7podxof.swift:17:22: error: missing argument label 'test:' in\
    \ call\n    return histogram(test.characters.map { String($0) })\n           \
    \          ^\n                     test: \n/tmp/tmpd7podxof.swift:17:38: error:\
    \ cannot convert value of type '[String]' to expected argument type 'String'\n\
    \    return histogram(test.characters.map { String($0) })\n                  \
    \                   ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String: Int]()\n    test.characters.forEach {\n\
    \        let currentCount = histogram[$0] ?? 0\n        histogram[$0] = currentCount\
    \ + 1\n    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmprs4od8yv.swift:19:38: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        let currentCount\
    \ = histogram[$0] ?? 0\n                                     ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard test.count != 0 else { return [:] }\n    var histogram = [String\
    \ : Int]()\n    test.unicodeScalars.forEach { unicodeScalar in\n        guard\
    \ let str = unicodeScalar.value, !str.isEmpty else { return }\n        if let\
    \ index = histogram[str]\n        {\n            histogram[str] += 1\n       \
    \ }\n        else\n        {\n            histogram[str] = 1;\n        }\n   \
    \ }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpyu91nvqj.swift:20:51: error: value of type 'UInt32' has no member\
    \ 'isEmpty'\n        guard let str = unicodeScalar.value, !str.isEmpty else {\
    \ return }\n                                              ~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let chars = test.characters.map(String.init)\n    let count = chars.reduce([String:\
    \ Int](), combine: { (result, [String : Int]) -> [String : Int] in\n        var\
    \ count = result\n        for char in chars {\n            if let value = result.removeValue(forKey:\
    \ char) {\n                count = count.combine({ [String : Int](char : value.1,\
    \ value: value.2 + 1) }) { $0 + $1.value }\n            }\n        }\n       \
    \ return count\n    })\n    return count.map { String($0.key): $0.value }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpe6jrdxig.swift:18:67: warning: unnamed parameters must be written\
    \ with the empty name '_'\n    let count = chars.reduce([String: Int](), combine:\
    \ { (result, [String : Int]) -> [String : Int] in\n                          \
    \                                        ^\n                                 \
    \                                 _: \n/tmp/tmpe6jrdxig.swift:27:38: error: consecutive\
    \ statements on a line must be separated by ';'\n    return count.map { String($0.key):\
    \ $0.value }\n                                     ^\n                       \
    \              ;\n/tmp/tmpe6jrdxig.swift:27:38: error: expected expression\n \
    \   return count.map { String($0.key): $0.value }\n                          \
    \           ^\n/tmp/tmpe6jrdxig.swift:17:22: error: 'characters' is unavailable:\
    \ Please use String directly\n    let chars = test.characters.map(String.init)\n\
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpe6jrdxig.swift:18:29: error: extraneous argument label 'combine:'\
    \ in call\n    let count = chars.reduce([String: Int](), combine: { (result, [String\
    \ : Int]) -> [String : Int] in\n                            ^                \
    \ ~~~~~~~~~\n                                              \n/tmp/tmpe6jrdxig.swift:18:56:\
    \ error: cannot convert value of type '([String : Int], [String : Int]) -> [String\
    \ : Int]' to expected argument type '([String : Int], String) throws -> [String\
    \ : Int]'\n    let count = chars.reduce([String: Int](), combine: { (result, [String\
    \ : Int]) -> [String : Int] in\n                                             \
    \          ^\n/tmp/tmpe6jrdxig.swift:21:35: error: cannot use mutating member\
    \ on immutable value: 'result' is a 'let' constant\n            if let value =\
    \ result.removeValue(forKey: char) {\n                           ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let histogram = Dictionary<String, Int>()\n    for ch in test {\n\
    \        if let count = histogram.value[ch] {\n            histogram.value +=\
    \ count\n        } else {\n            histogram.value[ch] = 1\n        }\n  \
    \  }\n    return histogram.value\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmplj2a6sov.swift:19:34: error: value of type '[String : Int]' has\
    \ no member 'value'\n        if let count = histogram.value[ch] {\n          \
    \             ~~~~~~~~~ ^~~~~\n/tmp/tmplj2a6sov.swift:20:23: error: value of type\
    \ '[String : Int]' has no member 'value'\n            histogram.value += count\n\
    \            ~~~~~~~~~ ^~~~~\n/tmp/tmplj2a6sov.swift:22:23: error: value of type\
    \ '[String : Int]' has no member 'value'\n            histogram.value[ch] = 1\n\
    \            ~~~~~~~~~ ^~~~~\n/tmp/tmplj2a6sov.swift:25:22: error: value of type\
    \ '[String : Int]' has no member 'value'\n    return histogram.value\n       \
    \    ~~~~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var map = [:]\n    for char in test.characters {\n        if var\
    \ count = map[char] {\n            count += 1;\n            map[char] = count;\n\
    \        }\n    }\n    return map\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmph_bqr3fj.swift:17:15: error: empty collection literal requires\
    \ an explicit type\n    var map = [:]\n              ^~~\n/tmp/tmph_bqr3fj.swift:18:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in test.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmph_bqr3fj.swift:20:19: error: type of expression\
    \ is ambiguous without more context\n            count += 1;\n            ~~~~~~^~~~\n\
    /tmp/tmph_bqr3fj.swift:24:12: error: cannot convert return expression of type\
    \ '[AnyHashable : Any]' to return type '[String : Int]'\n    return map\n    \
    \       ^\n/tmp/tmph_bqr3fj.swift:24:12: note: arguments to generic parameter\
    \ 'Key' ('AnyHashable' and 'String') are expected to be equal\n    return map\n\
    \           ^\n/tmp/tmph_bqr3fj.swift:24:12: note: arguments to generic parameter\
    \ 'Value' ('Any' and 'Int') are expected to be equal\n    return map\n       \
    \    ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test.components(separatedBy: \" \").reduce(into: [String\
    \ : Int](), { count, letter in\n        guard let count = count[letter] else {\n\
    \            count[letter] = 1\n        } else {\n            count[letter] +=\
    \ 1\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp84zsnd6m.swift:20:10: error: consecutive statements on a line must\
    \ be separated by ';'\n        } else {\n         ^\n         ;\n/tmp/tmp84zsnd6m.swift:20:11:\
    \ error: expected expression\n        } else {\n          ^\n/tmp/tmp84zsnd6m.swift:17:17:\
    \ error: value of type 'String' has no member 'components'\n    return test.components(separatedBy:\
    \ \" \").reduce(into: [String : Int](), { count, letter in\n           ~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    for i in test.characters.reversed().map({\
    \ $0.isUppercase ? UInt8(1) : UInt8(0) }).sorted(by: <) {\n        histogram[i.string]\
    \ = histogram[i.string] ?? 1\n        histogram[i.string] += 1 // Swift compiler\
    \ can't prove this doesn't overflow.\n    }\n    return histogram\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpywyuryxk.swift:18:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in test.characters.reversed().map({ $0.isUppercase\
    \ ? UInt8(1) : UInt8(0) }).sorted(by: <) {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpywyuryxk.swift:19:21: error: value of\
    \ type 'UInt8' has no member 'string'\n        histogram[i.string] = histogram[i.string]\
    \ ?? 1\n                  ~ ^~~~~~\n/tmp/tmpywyuryxk.swift:19:43: error: value\
    \ of type 'UInt8' has no member 'string'\n        histogram[i.string] = histogram[i.string]\
    \ ?? 1\n                                        ~ ^~~~~~\n/tmp/tmpywyuryxk.swift:20:21:\
    \ error: value of type 'UInt8' has no member 'string'\n        histogram[i.string]\
    \ += 1 // Swift compiler can't prove this doesn't overflow.\n                \
    \  ~ ^~~~~~\n/tmp/tmpywyuryxk.swift:20:18: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n        histogram[i.string] += 1\
    \ // Swift compiler can't prove this doesn't overflow.\n                 ^\n/tmp/tmpywyuryxk.swift:20:18:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        histogram[i.string] += 1 // Swift compiler can't prove this doesn't\
    \ overflow.\n                 ^\n                           !\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histo = [String : Int]()\n    var words = test.split()\n   \
    \ for word in words {\n        if histo[word] == nil {\n            histo[word]\
    \ = 1\n        } else {\n            histo[word] = histo[word] + 1\n        }\n\
    \    }\n    return histo\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpbxem3vl0.swift:18:28: error: missing argument for parameter 'separator'\
    \ in call\n    var words = test.split()\n                           ^\n      \
    \                     separator: <#String.Element#>\nSwift.Sequence:2:40: note:\
    \ 'split(separator:maxSplits:omittingEmptySubsequences:)' declared here\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n    \
    \                                   ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram(test.characters, test.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpo9jfnzv4.swift:17:44: error: extra argument in call\n    return\
    \ histogram(test.characters, test.count)\n                    ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n    var letters = test.split(\"\
    \ \").map({ String($0) })\n    for letter in letters {\n        if let count =\
    \ result[letter] {\n            result[letter] = count + 1\n        } else {\n\
    \            result[letter] = 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpnsvf1ua3.swift:18:24: error: no exact matches in call to instance\
    \ method 'split'\n    var letters = test.split(\" \").map({ String($0) })\n  \
    \                     ^\nSwift.Sequence:2:40: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(separator:)')\n    @inlinable public __consuming\
    \ func split(separator: Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences:\
    \ Bool = true) -> [ArraySlice<Self.Element>]\n                               \
    \        ^\nSwift.Collection:2:40: note: incorrect labels for candidate (have:\
    \ '(_:)', expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [Self.SubSequence]\n                                       ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let count = test.count(\"\\n\") else {\n        return [:]\n\
    \    }\n    var counts: [String : Int] = [:]\n    test.enumerateLines { (line,\
    \ i) in counts[line] = 1 }\n    return counts\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp9uvybx6d.swift:17:28: error: cannot call value of non-function\
    \ type 'Int'\n    guard let count = test.count(\"\\n\") else {\n             \
    \              ^\n/tmp/tmp9uvybx6d.swift:21:10: error: value of type 'String'\
    \ has no member 'enumerateLines'\n    test.enumerateLines { (line, i) in counts[line]\
    \ = 1 }\n    ~~~~ ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String: Int]()\n    for letter in test.lowercased()\
    \ {\n        histogram[letter] = (histogram[letter] ?? 0) + 1\n    }\n    return\
    \ histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7d4omvlu.swift:19:19: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        histogram[letter] = (histogram[letter]\
    \ ?? 0) + 1\n                  ^\n/tmp/tmp7d4omvlu.swift:19:40: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \   histogram[letter] = (histogram[letter] ?? 0) + 1\n                       \
    \                ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let words = test.components(separatedBy: \" \")\n    var letterCount\
    \ = [:]\n    for word in words {\n        let letter = word[0]\n        if letterCount.contains(letter)\
    \ {\n            letterCount[letter] = letterCount[letter] + 1\n        } else\
    \ {\n            letterCount[letter] = 1\n        }\n    }\n    return letterCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpxkeb4v7j.swift:17:22: error: value of type 'String' has no member\
    \ 'components'\n    let words = test.components(separatedBy: \" \")\n        \
    \        ~~~~ ^~~~~~~~~~\n/tmp/tmpxkeb4v7j.swift:18:23: error: empty collection\
    \ literal requires an explicit type\n    var letterCount = [:]\n             \
    \         ^~~\n/tmp/tmpxkeb4v7j.swift:27:12: error: cannot convert return expression\
    \ of type '[AnyHashable : Any]' to return type '[String : Int]'\n    return letterCount\n\
    \           ^\n/tmp/tmpxkeb4v7j.swift:27:12: note: arguments to generic parameter\
    \ 'Key' ('AnyHashable' and 'String') are expected to be equal\n    return letterCount\n\
    \           ^\n/tmp/tmpxkeb4v7j.swift:27:12: note: arguments to generic parameter\
    \ 'Value' ('Any' and 'Int') are expected to be equal\n    return letterCount\n\
    \           ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram(test.lowercased())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp8ioxflzw.swift:17:22: error: missing argument label 'test:' in\
    \ call\n    return histogram(test.lowercased())\n                     ^\n    \
    \                 test: \n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let counts = test.characters.reduce(into: [String : Int]()) { (counts,\
    \ ch) in\n        let c = counts[ch]\n        counts[ch] = c != nil ? c + 1 :\
    \ 1\n    }\n    return counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpzdhmwsta.swift:18:23: error: no exact matches in call to subscript\
    \ \n        let c = counts[ch]\n                      ^\nSwift.Dictionary:8:23:\
    \ note: candidate expects value of type 'Dictionary<String, Int>.Index' for parameter\
    \ #1 (got 'String.Element' (aka 'Character'))\n    @inlinable public subscript(position:\
    \ Dictionary<Key, Value>.Index) -> Dictionary<Key, Value>.Element { get }\n  \
    \                    ^\nSwift.Dictionary:2:23: note: candidate expects value of\
    \ type 'String' for parameter #1 (got 'String.Element' (aka 'Character'))\n  \
    \  @inlinable public subscript(key: Key) -> Value? { get set }\n             \
    \         ^\nSwift.Collection:2:23: note: candidate expects value of type 'Range<Dictionary<String,\
    \ Int>.Index>' for parameter #1 (got 'String.Element' (aka 'Character'))\n   \
    \ @inlinable public subscript(bounds: Range<Self.Index>) -> Slice<Self> { get\
    \ }\n                      ^\nSwift.Collection:3:23: note: candidate expects value\
    \ of type '(UnboundedRange_) -> ()' for parameter #1 (got 'String.Element' (aka\
    \ 'Character'))\n    @inlinable public subscript(x: (UnboundedRange_) -> ()) ->\
    \ Self.SubSequence { get }\n                      ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tlet letters = test.lowercaseString.componentsSeparatedByString(\"\
    \ \")\n\t\n\tlet count = Array(0..<test.lowercaseString.characters.count).map\
    \ { _ in 0 }\n\t\n\tfor i in 0..<test.lowercaseString.characters.count {\n\t\t\
    if let index = test.lowercaseString.characters.indexOf(i) {\n\t\t\tcount[index]\
    \ = count[index] + 1\n\t\t}\n\t}\n\t\n\tvar dictionary = [String : Int]()\n\t\n\
    \tlet maxValue = count.max()\n\tfor index in 0..<count.count {\n\t\tlet letter\
    \ = String(test.lowercaseString.characters[index])\n\t\tdictionary[letter] = count[index]\n\
    \t\tif maxValue == count[index] {\n\t\t\tdictionary.removeValue(forKey: letter)\n\
    \t\t}\n\t}\n\t\n\treturn dictionary\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp_b7nlf83.swift:17:21: error: value of type 'String' has no member\
    \ 'lowercaseString'\n        let letters = test.lowercaseString.componentsSeparatedByString(\"\
    \ \")\n                      ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp_b7nlf83.swift:19:29:\
    \ error: value of type 'String' has no member 'lowercaseString'\n        let count\
    \ = Array(0..<test.lowercaseString.characters.count).map { _ in 0 }\n        \
    \                      ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp_b7nlf83.swift:21:20: error:\
    \ value of type 'String' has no member 'lowercaseString'\n        for i in 0..<test.lowercaseString.characters.count\
    \ {\n                     ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp_b7nlf83.swift:22:23:\
    \ error: value of type 'String' has no member 'lowercaseString'\n            \
    \    if let index = test.lowercaseString.characters.indexOf(i) {\n           \
    \                    ~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp_b7nlf83.swift:31:28: error:\
    \ value of type 'String' has no member 'lowercaseString'\n                let\
    \ letter = String(test.lowercaseString.characters[index])\n                  \
    \                  ~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram(test.characters().map { ($0).isLetter ? $0 : nil\
    \ }.filter {\n        $0 != nil\n    }.map {\n        $0.count > 1 ? $0.element\
    \ : $0\n    }.sorted()) {\n        switch $0 {\n        case .Some(_):\n     \
    \       return $0.element\n        case .None:\n            return [:]\n     \
    \   }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp5yof04zy.swift:17:12: error: type of expression is ambiguous without\
    \ more context\n    return histogram(test.characters().map { ($0).isLetter ? $0\
    \ : nil }.filter {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var freqs = [String : Int]()\n    for char in test.characters.reversed()\
    \ {\n        if let count = freqs[char] {\n            freqs[char] = count + 1\n\
    \        } else {\n            freqs[char] = 1\n        }\n    }\n    return freqs\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7eol7v_r.swift:18:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in test.characters.reversed() {\n        \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp7eol7v_r.swift:19:30: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        if let count =\
    \ freqs[char] {\n                             ^\n/tmp/tmp7eol7v_r.swift:20:19:\
    \ error: cannot convert value of type 'String.Element' (aka 'Character') to expected\
    \ argument type 'String'\n            freqs[char] = count + 1\n              \
    \    ^\n/tmp/tmp7eol7v_r.swift:22:19: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n            freqs[char]\
    \ = 1\n                  ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\treturn getCounts(test).sorted(by: <)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpw9brhayz.swift:17:9: error: cannot find 'getCounts' in scope\n\
    \        return getCounts(test).sorted(by: <)\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    \n    let chars = test.characters\n\
    \    \n    for char in chars {\n        histogram[char] = (histogram[char] ??\
    \ 0) + 1\n    }\n    \n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpc_iwo8ww.swift:19:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = test.characters\n                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpc_iwo8ww.swift:22:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        histogram[char] = (histogram[char] ?? 0) + 1\n                  ^\n/tmp/tmpc_iwo8ww.swift:22:38:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        histogram[char] = (histogram[char] ?? 0) + 1\n                      \
    \               ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    \n    var frequencies: [String : Int] = [:]\n    for letter in test.characters\
    \ {\n        if let count = frequencies[letter] {\n            frequencies[letter]\
    \ = count + 1\n        } else {\n            frequencies[letter] = 1\n       \
    \ }\n    }\n    return frequencies\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpz3yx46jq.swift:19:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in test.characters {\n                 \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpz3yx46jq.swift:20:36:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let count = frequencies[letter] {\n                              \
    \     ^\n/tmp/tmpz3yx46jq.swift:21:25: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            frequencies[letter] = count\
    \ + 1\n                        ^\n/tmp/tmpz3yx46jq.swift:23:25: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       frequencies[letter] = 1\n                        ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram: [String: Int] = [:]\n\n    for letter in test.lowercased()\
    \ {\n        if let count = histogram[letter] {\n            histogram[letter]\
    \ = count + 1\n        } else {\n            histogram[letter] = 1\n        }\n\
    \    }\n\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7aet3saz.swift:20:34: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if let count = histogram[letter]\
    \ {\n                                 ^\n/tmp/tmp7aet3saz.swift:21:23: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            histogram[letter] = count + 1\n                      ^\n/tmp/tmp7aet3saz.swift:23:23:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            histogram[letter] = 1\n                      ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test.isEmpty {\n        return []\n    }\n\n    var letterCounters\
    \ = [String : Int]()\n    var mostFrequentLetters = [String]()\n\n    for letter\
    \ in test.lowercased() {\n        letterCounters[letter] = (letterCounters[letter]\
    \ ?? 0) + 1\n    }\n\n    for letter in letterCounters.keys {\n        if letterCounters[letter]\
    \ == letterCounters[letters.first] {\n            mostFrequentLetters.append(letter)\n\
    \        } else {\n            letterCounters[letter] = letterCounters[letter]!\
    \ - 1\n        }\n    }\n\n    var histogram = [String: Int]()\n    for letter\
    \ in letterCounters {\n        histogram[letter] = letterCounters[letter]!\n \
    \   }\n\n    if let _ = histogram[letters.first] {\n        histogram[letters.first]!\
    \ -= 1\n    }\n\n    for letter in letters.second {\n        if histogram[letter]\
    \ == histogram[letters.first]! {\n            histogram[letter]! -= 1\n      \
    \      histogram[letters.first]! -= 1\n        }\n    }\n\n    return histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpovwaq4bq.swift:18:16: error: use [:] to get an empty dictionary\
    \ literal\n        return []\n               ^\n                :\n/tmp/tmpovwaq4bq.swift:25:24:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        letterCounters[letter] = (letterCounters[letter] ?? 0) + 1\n        \
    \               ^\n/tmp/tmpovwaq4bq.swift:25:50: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        letterCounters[letter]\
    \ = (letterCounters[letter] ?? 0) + 1\n                                      \
    \           ^\n/tmp/tmpovwaq4bq.swift:29:53: error: cannot find 'letters' in scope\n\
    \        if letterCounters[letter] == letterCounters[letters.first] {\n      \
    \                                              ^~~~~~~\n/tmp/tmpovwaq4bq.swift:38:19:\
    \ error: cannot convert value of type '(key: String, value: Int)' to expected\
    \ argument type 'String'\n        histogram[letter] = letterCounters[letter]!\n\
    \                  ^\n/tmp/tmpovwaq4bq.swift:38:44: error: cannot convert value\
    \ of type '(key: String, value: Int)' to expected argument type 'String'\n   \
    \     histogram[letter] = letterCounters[letter]!\n                          \
    \                 ^\n/tmp/tmpovwaq4bq.swift:41:26: error: cannot find 'letters'\
    \ in scope\n    if let _ = histogram[letters.first] {\n                      \
    \   ^~~~~~~\n/tmp/tmpovwaq4bq.swift:42:19: error: cannot find 'letters' in scope\n\
    \        histogram[letters.first]! -= 1\n                  ^~~~~~~\n/tmp/tmpovwaq4bq.swift:45:19:\
    \ error: cannot find 'letters' in scope\n    for letter in letters.second {\n\
    \                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var freq = [String: Int]()\n    for letter in test {\n        freq[letter]\
    \ = freq[letter] ?? 0\n        freq[letter]++\n    }\n    return freq\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7560d7sc.swift:19:14: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        freq[letter] = freq[letter] ?? 0\n\
    \             ^\n/tmp/tmp7560d7sc.swift:19:29: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        freq[letter] =\
    \ freq[letter] ?? 0\n                            ^\n/tmp/tmp7560d7sc.swift:20:21:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        freq[letter]++\n\
    \                    ^~\n/tmp/tmp7560d7sc.swift:20:13: error: no exact matches\
    \ in call to subscript \n        freq[letter]++\n            ^\n/tmp/tmp7560d7sc.swift:20:13:\
    \ note: found candidate with type '(Dictionary<String, Int>.Index) -> (key: String,\
    \ value: Int)'\n        freq[letter]++\n            ^\n/tmp/tmp7560d7sc.swift:20:13:\
    \ note: found candidate with type '(String) -> @lvalue Int?'\n        freq[letter]++\n\
    \            ^\n/tmp/tmp7560d7sc.swift:20:13: note: found candidate with type\
    \ '(Range<Dictionary<String, Int>.Index>) -> Slice<[String : Int]>'\n        freq[letter]++\n\
    \            ^\n/tmp/tmp7560d7sc.swift:20:13: note: found candidate with type\
    \ '((UnboundedRange_) -> ()) -> Dictionary<String, Int>.SubSequence' (aka '((UnboundedRange_)\
    \ -> ()) -> Slice<Dictionary<String, Int>>')\n        freq[letter]++\n       \
    \     ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\treturn collections.reduce(Array(test)) { histogramReducer($0) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpaxrpfzrw.swift:17:9: error: cannot find 'collections' in scope\n\
    \        return collections.reduce(Array(test)) { histogramReducer($0) }\n   \
    \            ^~~~~~~~~~~\n/tmp/tmpaxrpfzrw.swift:17:43: error: cannot find 'histogramReducer'\
    \ in scope\n        return collections.reduce(Array(test)) { histogramReducer($0)\
    \ }\n                                                 ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return countLetters(test) |> groupBy |> mapValues |> toArray |>\
    \ toDictionary |> toSortedDict\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmplzioqzw2.swift:17:12: error: cannot find 'countLetters' in scope\n\
    \    return countLetters(test) |> groupBy |> mapValues |> toArray |> toDictionary\
    \ |> toSortedDict\n           ^~~~~~~~~~~~\n/tmp/tmplzioqzw2.swift:17:31: error:\
    \ cannot find operator '|>' in scope\n    return countLetters(test) |> groupBy\
    \ |> mapValues |> toArray |> toDictionary |> toSortedDict\n                  \
    \            ^~\n/tmp/tmplzioqzw2.swift:17:34: error: cannot find 'groupBy' in\
    \ scope\n    return countLetters(test) |> groupBy |> mapValues |> toArray |> toDictionary\
    \ |> toSortedDict\n                                 ^~~~~~~\n/tmp/tmplzioqzw2.swift:17:42:\
    \ error: cannot find operator '|>' in scope\n    return countLetters(test) |>\
    \ groupBy |> mapValues |> toArray |> toDictionary |> toSortedDict\n          \
    \                               ^~\n/tmp/tmplzioqzw2.swift:17:45: error: cannot\
    \ find 'mapValues' in scope\n    return countLetters(test) |> groupBy |> mapValues\
    \ |> toArray |> toDictionary |> toSortedDict\n                               \
    \             ^~~~~~~~~\n/tmp/tmplzioqzw2.swift:17:55: error: cannot find operator\
    \ '|>' in scope\n    return countLetters(test) |> groupBy |> mapValues |> toArray\
    \ |> toDictionary |> toSortedDict\n                                          \
    \            ^~\n/tmp/tmplzioqzw2.swift:17:58: error: cannot find 'toArray' in\
    \ scope\n    return countLetters(test) |> groupBy |> mapValues |> toArray |> toDictionary\
    \ |> toSortedDict\n                                                         ^~~~~~~\n\
    /tmp/tmplzioqzw2.swift:17:66: error: cannot find operator '|>' in scope\n    return\
    \ countLetters(test) |> groupBy |> mapValues |> toArray |> toDictionary |> toSortedDict\n\
    \                                                                 ^~\n/tmp/tmplzioqzw2.swift:17:69:\
    \ error: cannot find 'toDictionary' in scope\n    return countLetters(test) |>\
    \ groupBy |> mapValues |> toArray |> toDictionary |> toSortedDict\n          \
    \                                                          ^~~~~~~~~~~~\n/tmp/tmplzioqzw2.swift:17:82:\
    \ error: cannot find operator '|>' in sc"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard !test.isEmpty else { return [:] }\n    \n    var frequencies:\
    \ [String : Int] = [:]\n    \n    for letter in test.unicodeScalars.sorted(by:\
    \ { $0.value > $1.value }){\n        guard let count = frequencies[letter]\n \
    \           else { frequencies[letter] = 1 }\n        frequencies[letter] = (frequencies[letter]\
    \ + 1) % count\n    }\n    \n    return frequencies\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpq67bkxrx.swift:22:38: error: subscript 'subscript(_:)' requires\
    \ that 'Unicode.Scalar' conform to 'RangeExpression'\n        guard let count\
    \ = frequencies[letter]\n                                     ^\nSwift.Collection:2:23:\
    \ note: where 'R' = 'Unicode.Scalar'\n    @inlinable public subscript<R>(r: R)\
    \ -> Self.SubSequence where R : RangeExpression, Self.Index == R.Bound { get }\n\
    \                      ^\n/tmp/tmpq67bkxrx.swift:23:32: error: cannot convert\
    \ value of type 'Unicode.Scalar' to expected argument type 'String'\n        \
    \    else { frequencies[letter] = 1 }\n                               ^\n/tmp/tmpq67bkxrx.swift:24:21:\
    \ error: cannot convert value of type 'Unicode.Scalar' to expected argument type\
    \ 'String'\n        frequencies[letter] = (frequencies[letter] + 1) % count\n\
    \                    ^\n/tmp/tmpq67bkxrx.swift:24:52: error: binary operator '+'\
    \ cannot be applied to operands of type 'Int?' and 'Int'\n        frequencies[letter]\
    \ = (frequencies[letter] + 1) % count\n                               ~~~~~~~~~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmpq67bkxrx.swift:24:52: note: overloads for '+' exist with these\
    \ partially matching parameter lists: (Int, Int)\n        frequencies[letter]\
    \ = (frequencies[letter] + 1) % count\n                                      \
    \             ^\n/tmp/tmpq67bkxrx.swift:24:43: error: no exact matches in call\
    \ to subscript \n        frequencies[letter] = (frequencies[letter] + 1) % count\n\
    \                                          ^\n/tmp/tmpq67bkxrx.swift:24:43: note:\
    \ found candidate with type '(String) -> @lvalue Int?'\n        frequencies[letter]\
    \ = (frequencies[letter] + 1) % count\n                                      \
    \    ^\n/tmp/tmpq67bkxrx.swift:24:43: note: found candidate with type '(Unicode.Scalar)\
    \ -> Dictionary<String, Int>.SubSequence' (aka '(Unicode.Scalar) -> Slice<Dictionary<String,\
    \ Int>>')\n        frequencies[letter] = (frequencies[letter] + 1) % count\n \
    \                                         ^\n"
  stdout: ''
  timestamp: 1660009572
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tif test == \"\" {\n\t\treturn [:] as [String : Int]\n\t}\n\n\tchars\
    \ := test.lowercaseString.characters.sorted()\n\thistogramsByCharacter := [:]\
    \ as [String : Int]\n\n\tfor char in chars {\n\t\tif histogramsByCharacter.contains(char)\
    \ {\n\t\t\thistogramsByCharacter[char] += 1\n\t\t} else {\n\t\t\thistogramsByCharacter[char]\
    \ = 1\n\t\t}\n\t}\n\n\treturn histogramsByCharacter\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpsecd4xnt.swift:21:7: error: consecutive statements on a line must\
    \ be separated by ';'\n        chars := test.lowercaseString.characters.sorted()\n\
    \             ^\n             ;\n/tmp/tmpsecd4xnt.swift:21:8: error: expected\
    \ expression\n        chars := test.lowercaseString.characters.sorted()\n    \
    \          ^\n/tmp/tmpsecd4xnt.swift:21:2: error: cannot find 'chars' in scope\n\
    \        chars := test.lowercaseString.characters.sorted()\n        ^~~~~\n/tmp/tmpsecd4xnt.swift:24:14:\
    \ error: cannot find 'chars' in scope\n        for char in chars {\n         \
    \           ^~~~~\n/tmp/tmpsecd4xnt.swift:32:9: error: cannot find 'histogramsByCharacter'\
    \ in scope\n        return histogramsByCharacter\n               ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters: [String : Int] = [:]\n    var words: [String] = []\n\
    \    for c in test.characters {\n        var count = 1\n        if let letter\
    \ = letters[c] {\n            count = letter + 1\n        }\n        letters[c]\
    \ = count\n        if c != \" \" {\n            words.append(c)\n        }\n \
    \   }\n    return letters\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp_80n_rtj.swift:19:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in test.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_80n_rtj.swift:21:33:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        if let letter = letters[c] {\n                                ^\n/tmp/tmp_80n_rtj.swift:24:17:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        letters[c] = count\n                ^\n/tmp/tmp_80n_rtj.swift:26:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            words.append(c)\n                         ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var result: [String : Int] = [:]\n\n    for i in test.unicodeScalars\
    \ {\n        var found = false\n        for letter in result {\n            if\
    \ i == letter.value\n                { found = true; break }\n        }\n\n  \
    \      if !found {\n            result[i] = 1\n        } else {\n            result[i]\
    \ += 1 // if found increment the count\n        }\n    }\n\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp7i47yzh1.swift:22:18: error: referencing operator function '=='\
    \ on 'BinaryInteger' requires that 'Unicode.Scalar' conform to 'BinaryInteger'\n\
    \            if i == letter.value\n                 ^\nSwift.BinaryInteger:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension BinaryInteger {\n         \
    \ ^\n/tmp/tmp7i47yzh1.swift:27:20: error: cannot convert value of type 'Unicode.Scalar'\
    \ to expected argument type 'String'\n            result[i] = 1\n            \
    \       ^\n/tmp/tmp7i47yzh1.swift:29:19: error: no exact matches in call to subscript\
    \ \n            result[i] += 1 // if found increment the count\n             \
    \     ^\n/tmp/tmp7i47yzh1.swift:29:19: note: candidate expects value of type 'String'\
    \ for parameter #1 (got 'Unicode.Scalar')\n            result[i] += 1 // if found\
    \ increment the count\n                  ^\n/tmp/tmp7i47yzh1.swift:29:19: note:\
    \ found candidate with type '(Unicode.Scalar) -> Dictionary<String, Int>.SubSequence'\
    \ (aka '(Unicode.Scalar) -> Slice<Dictionary<String, Int>>')\n            result[i]\
    \ += 1 // if found increment the count\n                  ^\n/tmp/tmp7i47yzh1.swift:29:19:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            result[i] += 1 // if found increment the count\n                \
    \  ^\n/tmp/tmp7i47yzh1.swift:29:19: note: force-unwrap using '!' to abort execution\
    \ if the optional value contains 'nil'\n            result[i] += 1 // if found\
    \ increment the count\n                  ^\n                     !\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard !test.isEmpty else { return [:] }\n\n    var map = [String\
    \ : Int]()\n\n    var currentCount = 0\n    for char in test.characters {\n  \
    \      guard let count = map.getValue(forKey: char) else { map[char] = 1 }\n \
    \       map[char] = count.successor()\n        currentCount += count\n    }\n\n\
    \    return map\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(histogram(test: \"\
    a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp_agfdjdv.swift:22:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in test.characters {\n                   \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp_agfdjdv.swift:23:31:\
    \ error: value of type '[String : Int]' has no member 'getValue'\n        guard\
    \ let count = map.getValue(forKey: char) else { map[char] = 1 }\n            \
    \              ~~~ ^~~~~~~~\n/tmp/tmp_agfdjdv.swift:23:65: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        guard\
    \ let count = map.getValue(forKey: char) else { map[char] = 1 }\n            \
    \                                                    ^\n/tmp/tmp_agfdjdv.swift:24:13:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        map[char] = count.successor()\n            ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return histogram(test.characters, test.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpo9jfnzv4.swift:17:44: error: extra argument in call\n    return\
    \ histogram(test.characters, test.count)\n                    ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let result: [String : Int] = [:]\n    var longest = \"\"\n    for\
    \ letter in test.lowercased().characters {\n        result[letter] = result[letter]\
    \ ?? 0\n        result[letter]++\n        if result[[letter]] == 1 {\n       \
    \     if letter > longest {\n                longest = letter\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpzv3j2utz.swift:19:37: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in test.lowercased().characters {\n    \
    \                                ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpzv3j2utz.swift:20:16: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        result[letter]\
    \ = result[letter] ?? 0\n               ^\n/tmp/tmpzv3j2utz.swift:20:33: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        result[letter] = result[letter] ?? 0\n                              \
    \  ^\n/tmp/tmpzv3j2utz.swift:21:23: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n        result[letter]++\n                      ^~\n/tmp/tmpzv3j2utz.swift:21:15:\
    \ error: no exact matches in call to subscript \n        result[letter]++\n  \
    \            ^\n/tmp/tmpzv3j2utz.swift:21:15: note: found candidate with type\
    \ '(Dictionary<String, Int>.Index) -> (key: String, value: Int)'\n        result[letter]++\n\
    \              ^\n/tmp/tmpzv3j2utz.swift:21:15: note: found candidate with type\
    \ '(String) -> Int?'\n        result[letter]++\n              ^\n/tmp/tmpzv3j2utz.swift:21:15:\
    \ note: found candidate with type '(Range<Dictionary<String, Int>.Index>) -> Slice<[String\
    \ : Int]>'\n        result[letter]++\n              ^\n/tmp/tmpzv3j2utz.swift:21:15:\
    \ note: found candidate with type '((UnboundedRange_) -> ()) -> Dictionary<String,\
    \ Int>.SubSequence' (aka '((UnboundedRange_) -> ()) -> Slice<Dictionary<String,\
    \ Int>>')\n        result[letter]++\n              ^\n/tmp/tmpzv3j2utz.swift:22:19:\
    \ error: cannot convert value of type '[Character]' to expected argument type\
    \ 'String'\n        if result[[letter]] == 1 {\n                  ^\n/tmp/tmpzv3j2utz.swift:23:23:\
    \ error: binary operator '>' cannot be applied to operands of type 'Character'\
    \ and 'String'\n            if letter > longest {\n               ~~~~~~ ^ ~~~~~~~\n\
    /tmp/tmpzv3j2utz.swift:24:27: error: cannot assign v"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let letters = test.lowercased().components(separatedBy: \" \")\n\
    \    var histogram: [String : Int] = [:]\n    for let letter in letters {\n  \
    \      if histogram.keys.contains(letter) {\n            histogram[letter] = histogram[letter]\
    \ + 1\n        } else {\n            histogram[letter] = 1\n        }\n    }\n\
    \    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp8cv_olot.swift:19:9: error: 'let' pattern cannot appear nested\
    \ in an already immutable context\n    for let letter in letters {\n        ^\n\
    /tmp/tmp8cv_olot.swift:17:37: error: value of type 'String' has no member 'components'\n\
    \    let letters = test.lowercased().components(separatedBy: \" \")\n        \
    \          ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letters = test.split(\" \")\n    var histogram = [String : Int]()\n\
    \    for letter in letters {\n        histogram[letter] = (histogram[letter] ??\
    \ 0) + 1\n    }\n    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp32avd781.swift:17:24: error: no exact matches in call to instance\
    \ method 'split'\n    var letters = test.split(\" \")\n                      \
    \ ^\nSwift.Sequence:2:40: note: incorrect labels for candidate (have: '(_:)',\
    \ expected: '(separator:)')\n    @inlinable public __consuming func split(separator:\
    \ Self.Element, maxSplits: Int = Int.max, omittingEmptySubsequences: Bool = true)\
    \ -> [ArraySlice<Self.Element>]\n                                       ^\nSwift.Collection:2:40:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(separator:)')\n\
    \    @inlinable public __consuming func split(separator: Self.Element, maxSplits:\
    \ Int = Int.max, omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n\
    \                                       ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    test += \" \"\n    var counts = [String : Int]()\n    var letters\
    \ = [String]()\n    for char in test.characters {\n        if let count = counts[char]\
    \ {\n            counts[char] = count + 1\n        } else {\n            counts[char]\
    \ = 1\n        }\n    }\n    \n    var highestCount = 0\n    var highestLetter:\
    \ String? = nil\n    var highestCount = -1\n    for (_, count) in counts {\n \
    \       if count > highestCount {\n            highestCount = count\n        \
    \    highestLetter = nil\n        }\n        if count > highestCount {\n     \
    \       highestCount = count\n            highestLetter = char\n        }\n  \
    \  }\n    \n    return [String : Int](highestLetter!, highestCount)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp6fjv0a6c.swift:17:10: error: left side of mutating operator isn't\
    \ mutable: 'test' is a 'let' constant\n    test += \" \"\n    ~~~~ ^\n/tmp/tmp6fjv0a6c.swift:20:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in test.characters {\n                     ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp6fjv0a6c.swift:21:31: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n        if let\
    \ count = counts[char] {\n                              ^\n/tmp/tmp6fjv0a6c.swift:22:20:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            counts[char] = count + 1\n                   ^\n/tmp/tmp6fjv0a6c.swift:24:20:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            counts[char] = 1\n                   ^\n/tmp/tmp6fjv0a6c.swift:30:9:\
    \ error: invalid redeclaration of 'highestCount'\n    var highestCount = -1\n\
    \        ^\n/tmp/tmp6fjv0a6c.swift:28:9: note: 'highestCount' previously declared\
    \ here\n    var highestCount = 0\n        ^\n/tmp/tmp6fjv0a6c.swift:38:29: error:\
    \ cannot find 'char' in scope\n            highestLetter = char\n            \
    \                ^~~~\n/tmp/tmp6fjv0a6c.swift:42:12: error: no exact matches in\
    \ call to initializer \n    return [String : Int](highestLetter!, highestCount)\n\
    \           ^\n/tmp/tmp6fjv0a6c.swift:42:12: note: found candidate with type '(__owned\
    \ String, (Int, Int) throws -> Int) throws -> [String : Int]'\n    return [String\
    \ : Int](highestLetter!, highestCount)\n           ^\n/tmp/tmp6fjv0a6c.swift:42:12:\
    \ note: found candidate with type '(__owned String, (String.Element) throws ->\
    \ String) throws -> [String : Int]' (aka '(__owned String, (Character) throws\
    \ -> String) throws -> Dictionary<String, Int>')\n    return [String : Int](highestLetter!,\
    \ highestCount)\n           ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\thistogram: for (i, character) in test.characters {\n\t\thistogram[character]\
    \ = histogram[character] ?? 0\n\t\thistogram[character]++\n\t}\n\treturn histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmplsio5hbe.swift:17:40: error: tuple pattern cannot match values\
    \ of non-tuple type 'Character'\n        histogram: for (i, character) in test.characters\
    \ {\n                                              ^\n/tmp/tmplsio5hbe.swift:21:9:\
    \ error: cannot convert return expression of type '(String) -> [String : Int]'\
    \ to return type '[String : Int]'\n        return histogram\n               ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [:] as [String : Int]\n    }\n\
    \    var histogram = [:]\n    for letter in test.lowercased() {\n        guard\
    \ let count = histogram[letter] else {\n            histogram[letter] = 1\n  \
    \          continue\n        }\n        histogram[letter] = count + 1\n    }\n\
    \    return histogram\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp46qh9f6g.swift:20:21: error: empty collection literal requires\
    \ an explicit type\n    var histogram = [:]\n                    ^~~\n/tmp/tmp46qh9f6g.swift:26:29:\
    \ error: cannot convert value of type 'Any' to expected argument type 'Int'\n\
    \        histogram[letter] = count + 1\n                            ^\n      \
    \                            as! Int\n/tmp/tmp46qh9f6g.swift:28:12: error: cannot\
    \ convert return expression of type '[AnyHashable : Any]' to return type '[String\
    \ : Int]'\n    return histogram\n           ^\n/tmp/tmp46qh9f6g.swift:28:12: note:\
    \ arguments to generic parameter 'Key' ('AnyHashable' and 'String') are expected\
    \ to be equal\n    return histogram\n           ^\n/tmp/tmp46qh9f6g.swift:28:12:\
    \ note: arguments to generic parameter 'Value' ('Any' and 'Int') are expected\
    \ to be equal\n    return histogram\n           ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [:] as [String : Int]\n    test.split(\" \")\n \
    \       .enumerated()\n        .forEach { (idx, c) in\n            histogram[c]\
    \ = histogram.updated(c, histogram[c] ?? 0) + 1\n        }\n    return histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpbij0rar1.swift:18:10: error: no exact matches in call to instance\
    \ method 'split'\n    test.split(\" \")\n         ^\n/tmp/tmpbij0rar1.swift:18:10:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    test.split(\"\
    \ \")\n         ^\n/tmp/tmpbij0rar1.swift:18:10: note: found candidate with type\
    \ '(String.Element, Int, Bool) -> [String.SubSequence]' (aka '(Character, Int,\
    \ Bool) -> Array<Substring>')\n    test.split(\" \")\n         ^\n/tmp/tmpbij0rar1.swift:21:38:\
    \ error: value of type '[String : Int]' has no member 'updated'\n            histogram[c]\
    \ = histogram.updated(c, histogram[c] ?? 0) + 1\n                           ~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660009576
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var histogram = [String : Int]()\n    for c in test {\n        if\
    \ histogram.containsKey(c) {\n            histogram[c] = histogram[c] + 1\n  \
    \      } else {\n            histogram[c] = 1\n        }\n    }\n    return histogram\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpvhtayo22.swift:19:22: error: value of type '[String : Int]' has\
    \ no member 'containsKey'\n        if histogram.containsKey(c) {\n           ~~~~~~~~~\
    \ ^~~~~~~~~~~\n/tmp/tmpvhtayo22.swift:20:37: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n            histogram[c] = histogram[c]\
    \ + 1\n                                    ^\n/tmp/tmpvhtayo22.swift:20:37: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \            histogram[c] = histogram[c] + 1\n                               \
    \     ^\n                           (            ?? <#default value#>)\n/tmp/tmpvhtayo22.swift:20:37:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            histogram[c] = histogram[c] + 1\n                       \
    \             ^\n                                       !\n/tmp/tmpvhtayo22.swift:20:38:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            histogram[c] = histogram[c] + 1\n                               \
    \      ^\n/tmp/tmpvhtayo22.swift:20:23: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            histogram[c] = histogram[c]\
    \ + 1\n                      ^\n/tmp/tmpvhtayo22.swift:22:23: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            histogram[c]\
    \ = 1\n                      ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return [:] as [String : Int]\n    }\n\
    \n    var letters = test.characters.map { String($0) }\n    var dict = [:] as\
    \ [String : Int]\n    var result = [String : Int]()\n\n    for letter in letters\
    \ {\n        if !dict.isEmpty {\n            var current = dict[letter]\n    \
    \        dict[letter] = current + 1\n        } else {\n            dict[letter]\
    \ = 1\n        }\n\n        if dict[letter] > result[letter] {\n            result[letter]\
    \ = dict[letter]\n        }\n    }\n\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp5w87f69m.swift:21:24: error: 'characters' is unavailable: Please\
    \ use String directly\n    var letters = test.characters.map { String($0) }\n\
    \                       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5w87f69m.swift:28:28: error: value of optional type 'Int?'\
    \ must be unwrapped to a value of type 'Int'\n            dict[letter] = current\
    \ + 1\n                           ^\n/tmp/tmp5w87f69m.swift:28:28: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \         dict[letter] = current + 1\n                           ^\n         \
    \                  (       ?? <#default value#>)\n/tmp/tmp5w87f69m.swift:28:28:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            dict[letter] = current + 1\n                           ^\n\
    \                                  !\n/tmp/tmp5w87f69m.swift:33:16: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \ if dict[letter] > result[letter] {\n               ^\n/tmp/tmp5w87f69m.swift:33:16:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        if dict[letter] > result[letter] {\n               ^\n      \
    \                  ?? <#default value#>\n/tmp/tmp5w87f69m.swift:33:16: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        if\
    \ dict[letter] > result[letter] {\n               ^\n                       !\n\
    /tmp/tmp5w87f69m.swift:33:33: error: value of optional type 'Int?' must be unwrapped\
    \ to a value of type 'Int'\n        if dict[letter] > result[letter] {\n     \
    \                           ^\n/tmp/tmp5w87f69m.swift:33:33: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        if\
    \ dict[letter] > result[letter] {\n                                ^\n       \
    \                                  ?? <#default value#>\n/tmp/tmp5w87f69m.swift:33:33:\
    \ note: force-unwrap using '!' to abort e"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tlet counts = test.chars()\n\t\t.flatMap({ String($0) })\n\t\t.flatMap({\
    \ $0.contains(\" \") })\n\t\t.map({ $0.lowercased() })\n\t\t.flatMap({ $0.isLetter()\
    \ })\n\t\t.flatMap({ $0.countElements() })\n\t\t.sorted()\n\t\t.reversed()\n\t\
    \t.map { $0.toInt() }\n\treturn counts\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpond4p3es.swift:17:20: error: value of type 'String' has no member\
    \ 'chars'\n        let counts = test.chars()\n                     ~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660009572
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    let letters = test.split(separator: \" \")\n    .map({ String($0.lowercased()).unicodeScalars.compactMap().reduce(0)\
    \ { $0 + ($1.value == 0 ? 1 : $1.value) } }) \n    .reduce(into: [String: Int](),\
    \ { $0[$1] = $0 + 1 })\n    return letters.sorted(by: { $0.value > $1.value })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp49x3caxd.swift:17:19: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let letters = test.split(separator: \" \")\n          \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009645
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var letterCount: [String : Int] = [:]\n    var testSet = Set(test)\n\
    \    for letter in testSet {\n        letterCount[letter] = (letterCount[letter]\
    \ ?? 0) + test.count(letter)\n    }\n    return letterCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp3r1yxe0l.swift:20:44: error: cannot convert value of type 'String.Element'\
    \ (aka 'Character') to expected argument type 'String'\n        letterCount[letter]\
    \ = (letterCount[letter] ?? 0) + test.count(letter)\n                        \
    \                   ^\n/tmp/tmp3r1yxe0l.swift:20:21: error: cannot convert value\
    \ of type 'String.Element' (aka 'Character') to expected argument type 'String'\n\
    \        letterCount[letter] = (letterCount[letter] ?? 0) + test.count(letter)\n\
    \                    ^\n/tmp/tmp3r1yxe0l.swift:20:65: error: cannot call value\
    \ of non-function type 'Int'\n        letterCount[letter] = (letterCount[letter]\
    \ ?? 0) + test.count(letter)\n                                               \
    \                 ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    var maxDict = [String : Int]()\n    var max = 0\n    for letter\
    \ in test {\n        if maxDict[letter] == max {\n            maxDict[letter]\
    \ = maxDict[letter] + 1\n        }\n        else {\n            max = maxDict[letter]\
    \ + 1\n        }\n    }\n    for letter in test {\n        if maxDict[letter]\
    \ == max {\n            maxDict[letter] = maxDict[letter] + 1\n        }\n   \
    \     else {\n            max = maxDict[letter] + 1\n        }\n    }\n    for\
    \ letter in test {\n        if maxDict[letter] == max {\n            maxDict[letter]\
    \ = maxDict[letter] + 1\n        }\n        else {\n            max = maxDict[letter]\
    \ + 1\n        }\n    }\n    return maxDict\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d\
    \ g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1,\
    \ \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp5h91vk6j.swift:20:20: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n        if maxDict[letter] == max {\n  \
    \                 ^\n/tmp/tmp5h91vk6j.swift:21:21: error: cannot convert value\
    \ of type 'Character' to expected argument type 'String'\n            maxDict[letter]\
    \ = maxDict[letter] + 1\n                    ^\n/tmp/tmp5h91vk6j.swift:21:38:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            maxDict[letter] = maxDict[letter] + 1\n                         \
    \            ^\n/tmp/tmp5h91vk6j.swift:21:38: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n            maxDict[letter]\
    \ = maxDict[letter] + 1\n                                     ^\n            \
    \                  (               ?? <#default value#>)\n/tmp/tmp5h91vk6j.swift:21:38:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            maxDict[letter] = maxDict[letter] + 1\n                 \
    \                    ^\n                                             !\n/tmp/tmp5h91vk6j.swift:21:39:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            maxDict[letter] = maxDict[letter] + 1\n                         \
    \             ^\n/tmp/tmp5h91vk6j.swift:24:27: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            max = maxDict[letter]\
    \ + 1\n                          ^\n/tmp/tmp5h91vk6j.swift:24:26: error: value\
    \ of optional type 'Int?' must be unwrapped to a value of type 'Int'\n       \
    \     max = maxDict[letter] + 1\n                         ^\n/tmp/tmp5h91vk6j.swift:24:26:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            max = maxDict[letter] + 1\n                         ^\n \
    \                 (               ?? <#default value#>)\n/tmp/tmp5h91vk6j.swift:24:26:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            max = maxDict[letter] + 1\n                       "
  stdout: ''
  timestamp: 1660009572
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    guard let charArray = test.characters.split(separator: \" \").flatMap\
    \ { String($0) } else { return [:] }\n    var histogram = [String : Int]()\n \
    \   charArray.forEach { (element) in\n        if let count = histogram[element]\
    \ {\n            histogram[element] = count + 1\n        } else {\n          \
    \  histogram[element] = 1\n        }\n    }\n    return histogram\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpidqorf86.swift:17:73: error: expected 'else' after 'guard' condition\n\
    \    guard let charArray = test.characters.split(separator: \" \").flatMap { String($0)\
    \ } else { return [:] }\n                                                    \
    \                    ^\n                                                     \
    \                   else \n/tmp/tmpidqorf86.swift:17:82: error: anonymous closure\
    \ argument not contained in a closure\n    guard let charArray = test.characters.split(separator:\
    \ \" \").flatMap { String($0) } else { return [:] }\n                        \
    \                                                         ^\n/tmp/tmpidqorf86.swift:17:87:\
    \ error: consecutive statements on a line must be separated by ';'\n    guard\
    \ let charArray = test.characters.split(separator: \" \").flatMap { String($0)\
    \ } else { return [:] }\n                                                    \
    \                                  ^\n                                       \
    \                                               ;\n/tmp/tmpidqorf86.swift:17:88:\
    \ error: expected expression\n    guard let charArray = test.characters.split(separator:\
    \ \" \").flatMap { String($0) } else { return [:] }\n                        \
    \                                                               ^\n/tmp/tmpidqorf86.swift:17:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    guard let\
    \ charArray = test.characters.split(separator: \" \").flatMap { String($0) } else\
    \ { return [:] }\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpidqorf86.swift:17:65: error: 'flatMap'\
    \ has been renamed to 'compactMap(_:)': Please use compactMap(_:) for the case\
    \ where closure returns an optional value\n    guard let charArray = test.characters.split(separator:\
    \ \" \").flatMap { String($0) } else { return [:] }\n                        \
    \                                        ^~~~~~~\n                           \
    \                                     compactMap\nSwift.Collec"
  stdout: ''
  timestamp: 1660009571
- exit_code: -4
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return test\n        .split(separator: \" \")\n        .enumerated()\n\
    \        .reduce(into: [String : Int]()) {\n            $0[$1.element.lowercased()]\
    \ = $1.offset\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(histogram(test:\
    \ \"a b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\"\
    ) == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\"\
    \ : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"\
    r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b\
    \ b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"\
    t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\n\
    assert(histogram(test: \"a\") == [\"a\" : 1])"
  status: Exception
  stderr: 'tmp3ax6s4g9/tmp3ax6s4g9.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77c4f4dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b77c4c44b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b77c4c44988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b77c4c437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3ax6s4g9                        0x000055929068d9db <unavailable> + 6619

    5    libc.so.6                          0x00002b77c5139460 __libc_start_main +
    245

    6    tmp3ax6s4g9                        0x000055929068d579 <unavailable> + 5497

    '
  stdout: ''
  timestamp: 1660009572
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n\tvar freq = [String : Int]()\n\tfor _, b := range test {\n\t\tfreq[b]\
    \ = freq[b]! + 1 // just in case...\n\t}\n\treturn freq\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpiqid2p_l.swift:18:7: error: expected 'in' after for-each pattern\n\
    \        for _, b := range test {\n             ^\n/tmp/tmpiqid2p_l.swift:18:7:\
    \ error: expected Sequence expression for for-each loop\n        for _, b := range\
    \ test {\n             ^\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n  var result = [:]\n  test.split(\" \").reduce((counts, [String : Int])\
    \ in result += (counts) { _ in 1 }\n  )\n  return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test:\
    \ \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\n\
    assert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test:\
    \ \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\"\
    \ : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String\
    \ : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmps54z_1kf.swift:18:51: error: expected ',' separator\n  test.split(\"\
    \ \").reduce((counts, [String : Int]) in result += (counts) { _ in 1 }\n     \
    \                                             ^\n                            \
    \                     ,\n/tmp/tmps54z_1kf.swift:18:51: error: expected expression\
    \ in list of expressions\n  test.split(\" \").reduce((counts, [String : Int])\
    \ in result += (counts) { _ in 1 }\n                                         \
    \         ^\n/tmp/tmps54z_1kf.swift:17:16: error: empty collection literal requires\
    \ an explicit type\n  var result = [:]\n               ^~~\n/tmp/tmps54z_1kf.swift:18:27:\
    \ error: cannot find 'counts' in scope\n  test.split(\" \").reduce((counts, [String\
    \ : Int]) in result += (counts) { _ in 1 }\n                          ^~~~~~\n\
    /tmp/tmps54z_1kf.swift:18:8: error: no exact matches in call to instance method\
    \ 'split'\n  test.split(\" \").reduce((counts, [String : Int]) in result += (counts)\
    \ { _ in 1 }\n       ^\n/tmp/tmps54z_1kf.swift:18:8: note: found candidate with\
    \ type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]' (aka '(Character,\
    \ Int, Bool) -> Array<ArraySlice<Character>>')\n  test.split(\" \").reduce((counts,\
    \ [String : Int]) in result += (counts) { _ in 1 }\n       ^\n/tmp/tmps54z_1kf.swift:18:8:\
    \ note: found candidate with type '(String.Element, Int, Bool) -> [String.SubSequence]'\
    \ (aka '(Character, Int, Bool) -> Array<Substring>')\n  test.split(\" \").reduce((counts,\
    \ [String : Int]) in result += (counts) { _ in 1 }\n       ^\n/tmp/tmps54z_1kf.swift:18:26:\
    \ error: instance method 'reduce' expects 2 separate arguments; remove extra parentheses\
    \ to change tuple into separate arguments\n  test.split(\" \").reduce((counts,\
    \ [String : Int]) in result += (counts) { _ in 1 }\n                         ^\
    \                      ~\n                                                \nSwift.Sequence:2:28:\
    \ note: 'reduce' declared here\n    @inlinable public func reduce<Result>(_ initialResult:\
    \ Result, _ nextPartialResult: (_ partialResult: Result, Self.Element) throws\
    \ -> Result) rethrows -> Result\n        "
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    letters := strings.Split(test, \"\\n\")\n    letterCount = [:]\n\
    \    for i := 0; i < len(letterCount); i++ {\n        letterCount[letters[i]]\
    \ = letterCount[i] + 1\n    }\n\n    for i := 0; i < len(letterCount); i++ {\n\
    \        if letterCount[letters[i]] == letterCount[i] {\n            letterCount[letters[i]]\
    \ = letterCount[i] + 1\n        }\n    }\n    return letterCount\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(histogram(test: \"a b b a\") == [\"a\" : 2, \"\
    b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\" : 2, \"b\" : 2])\n\
    assert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\" : 1, \"c\" : 1, \"\
    d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" :\
    \ 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") == [\"b\" : 4])\nassert(histogram(test:\
    \ \"r t g\") == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"\"\
    ) == [:] as [String : Int])\nassert(histogram(test: \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpx_5z3php.swift:17:12: error: consecutive statements on a line must\
    \ be separated by ';'\n    letters := strings.Split(test, \"\\n\")\n         \
    \  ^\n           ;\n/tmp/tmpx_5z3php.swift:17:13: error: expected expression\n\
    \    letters := strings.Split(test, \"\\n\")\n            ^\n/tmp/tmpx_5z3php.swift:19:12:\
    \ error: expected type\n    for i := 0; i < len(letterCount); i++ {\n        \
    \   ^\n            <#type#>\n/tmp/tmpx_5z3php.swift:19:12: error: expected 'in'\
    \ after for-each pattern\n    for i := 0; i < len(letterCount); i++ {\n      \
    \     ^\n/tmp/tmpx_5z3php.swift:19:12: error: expected Sequence expression for\
    \ for-each loop\n    for i := 0; i < len(letterCount); i++ {\n           ^\n/tmp/tmpx_5z3php.swift:23:12:\
    \ error: expected type\n    for i := 0; i < len(letterCount); i++ {\n        \
    \   ^\n            <#type#>\n/tmp/tmpx_5z3php.swift:23:12: error: expected 'in'\
    \ after for-each pattern\n    for i := 0; i < len(letterCount); i++ {\n      \
    \     ^\n/tmp/tmpx_5z3php.swift:23:12: error: expected Sequence expression for\
    \ for-each loop\n    for i := 0; i < len(letterCount); i++ {\n           ^\n/tmp/tmpx_5z3php.swift:17:5:\
    \ error: cannot find 'letters' in scope\n    letters := strings.Split(test, \"\
    \\n\")\n    ^~~~~~~\n/tmp/tmpx_5z3php.swift:28:12: error: cannot find 'letterCount'\
    \ in scope\n    return letterCount\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    return frequenciesOf(test).sorted { $0.value.count > $1.value.count\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(histogram(test: \"a b b a\")\
    \ == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") == [\"a\"\
    \ : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1, \"b\"\
    \ : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\") ==\
    \ [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\") ==\
    \ [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1, \"\
    g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmp53bfmaq3.swift:17:12: error: cannot find 'frequenciesOf' in scope\n\
    \    return frequenciesOf(test).sorted { $0.value.count > $1.value.count }\n \
    \          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660009571
- exit_code: 1
  program: "\n/// Given a string representing a space separated lowercase letters,\
    \ return a dictionary\n/// of the letter with the most repetition and containing\
    \ the corresponding count.\n/// If several letters have the same occurrence, return\
    \ all of them.\n/// Example:\n/// >>> histogram(test: \"a b c\")\n/// [\"a\" :\
    \ 1, \"b\" : 1, \"c\" : 1]\n/// >>> histogram(test: \"a b b a\")\n/// [\"a\" :\
    \ 2, \"b\" : 2]\n/// >>> histogram(test: \"a b c a b\")\n/// [\"a\" : 2, \"b\"\
    \ : 2]\n/// >>> histogram(test: \"b b b b a\")\n/// [\"b\" : 4]\n/// >>> histogram(test:\
    \ \"\")\n/// [:] as [String : Int]\nfunc histogram(test: String) -> [String :\
    \ Int] {\n    if test == \"\" {\n        return []\n    }\n\n    var charCount\
    \ = [String : Int]()\n    let words = test.split(separator: \" \")\n    for word\
    \ in words {\n        let char = String(word)\n        if charCount.keys.contains(char)\
    \ {\n            charCount[char] = (charCount[char]! + 1) * Int(1)\n        }\
    \ else {\n            charCount[char] = Int(1)\n        }\n    }\n\n    return\
    \ charCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(histogram(test: \"a\
    \ b b a\") == [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c a b\") ==\
    \ [\"a\" : 2, \"b\" : 2])\nassert(histogram(test: \"a b c d g\") == [\"a\" : 1,\
    \ \"b\" : 1, \"c\" : 1, \"d\" : 1, \"g\" : 1])\nassert(histogram(test: \"r t g\"\
    ) == [\"r\" : 1, \"t\" : 1, \"g\" : 1])\nassert(histogram(test: \"b b b b a\"\
    ) == [\"b\" : 4])\nassert(histogram(test: \"r t g\") == [\"r\" : 1, \"t\" : 1,\
    \ \"g\" : 1])\nassert(histogram(test: \"\") == [:] as [String : Int])\nassert(histogram(test:\
    \ \"a\") == [\"a\" : 1])"
  status: SyntaxError
  stderr: "/tmp/tmpi65oddrc.swift:18:16: error: use [:] to get an empty dictionary\
    \ literal\n        return []\n               ^\n                :\n"
  stdout: ''
  timestamp: 1660009572
