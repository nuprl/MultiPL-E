name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["    # write your function here\n    return nums", "  # Write your code\
    \ here.\nend\n</cell>\n<code language=julia-1.1>", "    sorted = []\n    digits\
    \ = nums.map { |n| n.to_s.split('').map(&:to_i).sum }\n    sorted = nums.sort_by\
    \ { |n| digits[n.to_s.split('').map(&:to_i)].to_i }\n    sorted\nend", "  # TODO:\
    \ Your code here\nend", "  # write your code here\nend\n</cell>\n<cell>\nnums\
    \ = [1, 8, 6, 4, 0, 4, 3, 0]\norder_by_points(nums)\n</cell>\n<cell>\nnums = [4,\
    \ 6, 1, 7, 2, 5, 8, 0]\norder_by_points(nums)\n</cell>\n<cell>\nnums = [4, 6,\
    \ 1, 7, 2, 5, 8, 0, 8, 3, 9, 4, 7, 5, 3, 1, 6, 4, 5]\norder_by_points(nums)\n\
    </cell>\n<cell>\nnums = [1]\norder_by_points(nums)\n</cell>\n<text>\nQuestion\
    \ 5\nWrite a Python function which takes a list and returns a new list in which\
    \ all elements are sorted in ascending order (from small to large) according to\
    \ the integer value they have in common with all the elements in original list.",
  "    # Return the input list sorted by the sum of their digits\n    # in ascending\
    \ order\n    return nums.sort(key = lambda num : sum(num))\nend", "  nums = nums.sort\n\
    end", "    numbers_sum = {}\n    sorted_nums = []\n    sum = 0\n    sum_num =\
    \ 0\n    count = 0\n    nums.each do |num|\n        sum += num.to_i\n        sum_num\
    \ = num.to_i\n        numbers_sum[sum_num] = numbers_sum[sum_num] || {}\n    \
    \    numbers_sum[sum_num][count] = numbers_sum[sum_num][count] || []\n       \
    \ numbers_sum[sum_num][count] << num\n        count += 1\n    end\n    numbers_sum.each\
    \ do |sum_num, sublist|\n        sublist.sort.each do |index|\n            sorted_nums.push\
    \ sublist[index]\n        end\n    end\n    return sorted_nums\nend", "  return\
    \ sorted(nums, key=lambda num: sum_of_digits(num))\nend", "  nums.sort! { |a,b|\
    \ a <=> b }\nend", "    # initialize result list\n    result = []\n    # Loop\
    \ through each item in the list\n    for i in nums\n        # Initialize sum\n\
    \        sum = 0\n        # Loop through each digit in the number\n        for\
    \ j in i\n            # Add the digit to the sum\n            sum += j\n     \
    \   # Add sum to result list\n        result << sum\n    # Sort result list according\
    \ to the sum of its digits\n    # Note: use argsort to sort array in ascending\
    \ order\n    result.sort {|a, b| b <=> a }\n    # Return sorted array\n    return\
    \ result\nend", "  return sorted(nums, :key => nums.method(:sum))\nend\n</cell>\n\
    <cell>\norder_by_points(nums)\n</cell>\n<text>\nWrite a function which calculates\
    \ the distance between two points. It should return the distance as Integer.\n\
    The distance should be calculated as the absolute value of difference between\
    \ the coordinates of two points.\nWrite a test function for the distance function\
    \ which passes all of the test cases. The test cases contains pairs of points\
    \ to calculate the distance between. Your test function should calculate the distance\
    \ between every pair of points and return the average distance.", "  return nums.sort.reverse.sort_by_key(&:itself).reverse\n\
    end", "    # initialize an empty list for sorting results\n    results = []",
  "  # Use helper function sort_by_sum to sort nums\n  # in ascending order according\
    \ to the sum of their digits.\n  nums = sort_by_sum(nums)\n  \n  # Return the\
    \ sorted list of integers.\n  return nums", "    # Your code here\n    arr=[]\n\
    \    sum_arr=[]\n    for i in nums:\n        sum_arr.append(sum(i))\n        arr.append(i)\n\
    \    arr=arr[::-1]\n    arr.sort(key=sum_arr.__getitem__, reverse=True)\n    return\
    \ arr", "    nums.sort! { |a, b| a <=> b } # sort by points\n    nums.sort_by\
    \ { |n| n.digits.inject(0) { |sum, digit| sum + digit } }\nend", "    sum = 0\n\
    \    nums.each do |n|\n        sum += n % 10\n    end\n    sum = (sum % 10).to_i\n\
    \    sum < 0 ? nums.reverse : nums\nend", "  nums.sort!\n  nums.inject(0) {|sum,\
    \ el| sum += el.to_i if el.is_a?(Integer) }\nend", "  # TODO: Write your code\
    \ here\nend", "  # Write your code here.\nend", "  # TODO: Implement this function\n\
    end", "  nums.sort{|a,b| a.to_s + b.to_s <=> b.to_s + a.to_s}\nend", "  nums =\
    \ nums.sort{|x,y| x + y.to_i}\n  return nums\nend", "    sorted = []\n    sums\
    \ = []", "  nums.sort{|a,b| (a.to_s.to_i*10+a.to_s.to_i).to_s <=> (b.to_s.to_i*10+b.to_s.to_i).to_s}\n\
    end", "  nums.sort! {|a,b| a.to_s + b.to_s}\nend\nprint order_by_points([1,4,2,5,3,7,6,8,9])",
  "  # Return the sorted list.\n  nums_sorted = []\n  num_sum = 0", "    nums_sorted\
    \ = nums.sort {|a,b| a.to_s + b.to_s <=> b.to_s + a.to_s}\n    return nums_sorted\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThank you for your answer.\
    \ I tried your code, but I got an error.\n\"undefined method `+' for nil:NilClass\"\
    \n<|/ c |>\n<| c |>\nI have corrected my answer, I think it solves the problem\
    \ now.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    # Write your logic here\n  \
    \  sum = 0\n    points = []\n    for n in nums:\n        sum = sum + n\n     \
    \   points.append(n)\n    points.sort(key = lambda x:sum-x)\n    return points\n\
    print(order_by_points([1, 3, 6, 1, 8, 3, 6, 9, 0]))\n</cell>\n<text>\nCounting\
    \ and Sorting", "  nums.sort! {|x,y| x.to_s + y.to_s}\nend", "  nums.sort!\nend\n\
    </cell>\n<cell>", "    nums.sort!\n    sorted_nums = []\n    while nums.length\
    \ > 0\n        num = nums.shift\n        digit = 0\n        while num > 0\n  \
    \          digit = num % 10\n            num /= 10\n        end\n        if nums.include?(digit)\n\
    \            sorted_nums << digit << sorted_nums.last\n        else\n        \
    \    sorted_nums << digit\n        end\n    end\n    sorted_nums.reverse\nend\n\
    </cell>\n<code language=julia-1.5>", "    points = 0\n    sorted_nums = []\n \
    \   nums.each do |x|\n      digits += x.to_s\n      points += 1\n    end\n   \
    \ points.times do |x|\n      sorted_nums << nums[x]\n    end\n    return sorted_nums\n\
    end", "  nums.sort!\n  i = 1\n  while i < nums.size\n    sum = nums[i]\n    while\
    \ i < nums.size and nums[i] > sum\n      sum -= nums[i]\n      i += 1\n    i +=\
    \ 1\n    nums[i] = sum\n  end\n  nums\nend", "    sums = nums.each_with_object(Hash.new(0))\
    \ { |n, h| h[n] += n }\n    nums.sort.reverse.sort_by { |n| sums[n] }\nend\nassert\
    \ order_by_points([]) == []\nassert order_by_points([5]) == [5]\nassert order_by_points([4,\
    \ 5]) == [5, 4]\nassert order_by_points([2, 7, 9, 1, 8, 0, 3, 6]) == [0, 1, 2,\
    \ 3, 4, 5, 7, 9]\nassert order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1,\
    \ 0, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</cell>\n<text>\nThe next function converts\
    \ list of integers to its string representation:", "  nums.sort! do |a,b|\n  \
    \  sum = a.to_s + b.to_s\n    sum.to_i <=> b.to_i\n  end\nend", "  # TODO: Write\
    \ your code here\n  return nums.sort_by{|x| x.to_s.chars.map(&:to_i).inject(0,\
    \ :+)}\nend", "    # Write your code here.\n    return nums", "  nums.sort { |a,b|\
    \ a <=> b } # ascending order\nend\nnums = order_by_points([-1,-3,-2,1,2,4,6,2,4,6,6,-10,-2])\n\
    p nums", "  nums.sort! do |a, b|\n    sum = a.to_i + b.to_i\n    a <=> b ||= sum\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nThe point\
    \ of asking for help on Stack Overflow is that we do not just answer questions,\
    \ but the OP learns something. This is what this site is all about. Questions\
    \ are valuable for future visitors, they make them easier for us to learn from\
    \ and help people to answer their own questions. And Stack Overflow is a good\
    \ place for that, because it is a place where people learn to help others.\n<|/\
    \ c |>\n<| a tags=ruby |>\nSort by length and then by sum\n<code>", "  return\
    \ nums.sort{|a,b| sum(a) == sum(b) ? a.index - b.index : sum(a) < sum(b) ? -1\
    \ : 1}\nend", "    # Write your code here\n    return sorted(nums, key=lambda\
    \ num: (sum(map(int, str(num)))) % len(nums))\n</cell>\n<cell>\norder_by_points([9,10,11,12,13,14,15,16])\n\
    </cell>\n<text>\nWrite a Python program to Find the sum of the first n numbers\
    \ of a Fibonacci Series whose first 6 numbers are 1, 2, 3, 5, 8, 13, 21 respectively.\n\
    The sum of first 5 numbers in the series is 13.", "  nums.sort_by{|x| x.to_s.chars.map(&:to_i).reduce(:+)}\n\
    end\norder_by_points([3, 99, 5, -2, 6, 99])", "    nums.sort!\n    return nums\n\
    end", "# Your code here\nend\n</cell>\n<cell>\norder_by_points([-10, -3, 1, 2,\
    \ 0])\n</cell>\n<cell>\norder_by_points([1, 2, 0])\n</cell>\n<cell>\norder_by_points([4,\
    \ 3, 1])\n</cell>\n<cell>\norder_by_points([3, 2])\n</cell>\n<cell>\norder_by_points([5,\
    \ 1, 3, 10, 2, 4])\n</cell>\n<cell>\norder_by_points([1, 3, 2, 4, 5])\n</cell>\n\
    <text>\nPart III - Revising K-means", "  nums.sort(key=lambda num: nums.count(num))\n\
    end", "  nums.sort! {|a,b| a[1] <=> b[1] if a[1] == b[1] }\n  nums\nend", "  sorted_list\
    \ = nums.sort{|a, b| (a..b).sum <=> a.sum <=> b.sum}\n  result = []\n  while sorted_list.any?\n\
    \    sorted_list.pop until sorted_list.any? {|item| item > 0}\n    result += sorted_list\n\
    \  end\n  result.reverse\nend", "  # TODO: Write your code here\nend", "  return\
    \ nums.sort.sort_by {|x| x.sum.to_i}\nend\n</cell>\n<cell>\nnums = [3, 2, 8, 7,\
    \ 1, 0]\norder_by_points(nums)\n</cell>\n<cell>", "  new_nums = []\n  nums.each\
    \ do |num|\n    if new_nums.any? {|i| i.digits == num.digits}\n      new_nums.each\
    \ {|i| i.digits += num.digits}\n    else\n      new_nums << num\n    end\n  end\n\
    \  return new_nums.sort_by{|num| num.digits.reverse}.to_a\nend", "  nums.sort!\n\
    \  digits = nums.map{|x| x.to_s.split(//).map(&:to_i).sum}\n  nums.sort!{|x,y|\
    \ digits[x] > digits[y]}\nend\n</code>\n<|/ a dscore=2 tags=sorting,ruby |>\n\
    <| c |>\nNice solution, thanks!  I like how you can make use of digits to sort\
    \ by index in the original array without having to do any extra calculations.\
    \  One thing though, I think it would be a bit clearer to write `digits = nums.map{|x|\
    \ x.to_s.split(//).map(&:to_i).sum}` as `digits = nums.map(&:to_s).map(&:to_i).sum`.\n\
    <|/ c |>\n<| a |>\nThis works for me:\n<code>", "  points = []\n  sum = 0\n  for\
    \ i in nums\n    points[i] = i\n    sum += i\n  end\n  points.sort.each do |i|\n\
    \    if points[i] != sum\n      points.delete_at(points.index(i))\n    end\n \
    \ end\n  points\nend", "  nums.sort! { |a, b| b + a.to_i }\n  nums\nend", "  nums.sort!\n\
    \  nums.each_with_index { |n, i| nums[i] = n if n.to_s.chars.map(&:to_i).sum ==\
    \ i }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nGood idea. Also note that Ruby\
    \ already has a method for this: `Array#sort_by`.\n<|/ c |>\n<| c |>\nI agree,\
    \ but I like to learn new ways of solving a problem by trying something out :)\n\
    <|/ c |>\n<| c |>\nI think `each_with_index` is much more elegant than using `map`\
    \ and `sum` here. You could also combine both `each_with_index` and `map` into\
    \ one like `each_with_index.map { |n,i| n if n.to_s.chars.map(&:to_i).sum == i\
    \ }`.\n<|/ c |>\n<| a tags=ruby |>\nUsing sort_by, you can do this:\n<code>\n\
    arr = [\n    1,\n    3,\n    5,\n    2,\n    5,\n    7,\n    9,\n    1,\n    4,\n\
    \    3,\n    8,\n    2,\n    8,\n    9,\n    2,\n    3,\n    7,\n    6,\n    9,\n\
    \    1,\n    3,\n    2,\n    3,\n    8,\n    3,\n    2,\n    1,\n    3,\n    4,\n\
    \    4,\n    8,\n    2,\n    2,\n    3,\n    1,\n    1,\n    9,\n    9,\n    2,\n\
    \    1,\n    3,\n    3,\n    1,\n    1,\n    8,\n    7,\n    4,\n    7,\n    1,\n\
    \    4,\n    3,\n    2,\n    1,\n    2,\n    9,\n    1,\n    9,\n    4,\n    8,\n\
    \    7,\n    1,\n    1,\n    4,\n    3,\n    9,\n    2,\n    3,\n    3,\n    1,\n\
    \    1,\n    1,\n    3,\n    3,\n    1,\n    1,\n    1,\n    1,\n    1,\n    2,\n\
    \    1,\n    1,\n    1,\n    9,\n    9,\n    1,\n    1,\n    1,\n    1,\n    9,\n\
    \    9,\n    1,\n    1,\n    2,\n    1,\n    1,\n    4,\n    3,\n    8,\n    7,\n\
    \    1,\n    1,\n    2,\n    1,\n    ", "  sorted_nums = []\n  total_sum = 0\n\
    \  last_point = 0\n  nums.each do |num|\n    digit = num % 10\n    total_sum +=\
    \ digit\n    if last_point == 0 || digit != nums[last_point-1] % 10\n      last_point\
    \ = nums.index(num)\n      sorted_nums << num\n    end\n  end\n  sorted_nums <<\
    \ total_sum % 10 if total_sum != 0\n  sorted_nums\nend", "    # Order the numbers\
    \ based on their sum of their digits.\n    # nums = nums[]\n    # sum_digits =\
    \ 0\n    # for i in range(len(nums)):\n    #     sum_digits += nums[i]\n    #\
    \ return sum_digits, nums\n    # Ordered list [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\
    \    nums.sort(key=lambda x: sum(map(int, str(x))))\n    return nums", "  # sort\
    \ the given list of integers in ascending order according to the sum of their\
    \ digits\n  # return a new list of sorted integers\nend", "    return nums.sort{\
    \ |a, b| \n        sum1 = sum2 = sum1 + a.to_s + b.to_s\n        return sum1 if\
    \ sum1 < sum2\n        sum1\n        sum2\n    }\nend\n</code>\nThe output of\
    \ this will be:\n<code>\n[\"333\", \"44\", \"444\", \"3\", \"33\"]\n</code>\n\
    <|/ a dscore=1 tags=ruby-on-rails,ruby,arrays |>\n<| a tags=ruby-on-rails,ruby,arrays\
    \ |>\nYou can get it done by two ways", "  nums.sort{|a,b| a+b}\nend\n</cell>\n\
    <code language=julia-1.5>", "  nums = nums.map do |num|\n    num = num.to_i\n\
    \    num < 0 ? -num : num\n  end.sort\n  nums.map { |n| n }\nend", "  nums.sort!{|a,b|\
    \ a.to_s.length + b.to_s.length}\nend", "    sums = nums.inject(:+)\n    nums.sort.tap\
    \ { |a,b| sums[a] += sums[b] }\nend\n</cell>\n<cell>\nnums = [12,13,14,15,16]\n\
    order_by_points(nums)\n</cell>\n<text>\nExtra Credit\nWrite a function to convert\
    \ decimal number to binary string (with padding zeroes) in Ruby.\nFor example,\
    \ decToBin(12) should return \"1100\".", "  nums.sort.with_index { |i, n| [(-n.to_s.split(//).inject(0)+n.to_s.split(//).sum)].min\
    \ if i==n }\nend", "    sorted = []\n    digits = []\n    for i in nums\n    \
    \    digit = get_digit(i)\n        if digit not in digits\n            digits\
    \ << digit\n            sorted << i\n        elsif digits.include?(digit)\n  \
    \          sorted << i\n        end\n    end\n    sorted = sorted.sort_by{|i|\
    \ digits.index(i)} if !sorted.empty?\n    sorted.map!{|i| nums[i]}\nend", "  #\
    \ write code here\nend", '  nums.sort!', "    # initialize a map to store the\
    \ sums of digits\n    sums = nums.inject({}){|sums, num| sums[num.to_s] = num.to_s.chars.reduce(:+).to_i;\
    \ sums }\n    # initialize a map to store the indices of elements\n    idxs =\
    \ nums.inject({}){|sums, num| sums[num.to_s] = num; sums }\n    \n    # loop through\
    \ each element in the original list\n    nums.each_with_index do |num, index|\n\
    \        # store the index of all elements with same digit\n        # in ascending\
    \ order\n        if idxs[num.to_s] > index\n            idxs[num.to_s] = index\n\
    \        end\n    end", "  nums.sort{|x,y| (x+y).to_s.to_i <=> (x+y).to_i }\n\
    end\np order_by_points([2,3,4,1,8,7,6,10,9,5])", "    sorted = []\n    sorted_index\
    \ = []\n    for num in nums\n        digits = num.digits\n        sum_digits =\
    \ sum(digits)\n        if sum_digits in sorted\n            index = [i for i,\
    \ v in enumerate(digits) if v == sum_digits].index(num)\n            sorted_index.append(index)\n\
    \            sorted.append(sum_digits)\n        else\n            sorted.append(sum_digits)\n\
    \            sorted_index.append(num)\n    return sorted, sorted_index", "   \
    \ # Your code goes here\n    nums.sort! {|a, b| b.to_f - a.to_f}\n    return nums\n\
    end\n</cell>\n<cell>", "end\n</cell>\n<cell>\nnums = [8, 2, 6, 4, 8, 6]\norder_by_points(nums)\n\
    </cell>\n<text>\nQuestion 4\nWrite a function that takes an array of numbers as\
    \ an argument and returns the number of different values it has.\nExample:", " \
    \ # TODO: your code here\nend", "  # Solution code here\nend\n</cell>\n<cell>\n\
    order_by_points([[7, 1], [5, 9], [1, 8], [6, 6]])\n</cell>\n<text>\nELI5: Write\
    \ a function which takes an array of positive integers and return an array of\
    \ the even numbers in ascending order. The even numbers are those whose squared\
    \ value is greater than or equal to 1.\nFor example:\n[1, 2, 4, 8, 16, 32, 64]\
    \ -> [2, 4]", "  nums.sort_by do |x|\n    x.to_s.split(\"\").map.with_index {\
    \ |n,i| [(n + x.to_s.split(\"\")[i]).to_i, i] }.to_h.\n      sort_by {|x,y| x[0]}.last[1]\n\
    \  end\nend\n</code>\n<|/ a tags=sorting,ruby |>\n<| c |>\nNice solution, but\
    \ `split` is not going to be O(1).\n<|/ c |>\n<| c |>\nIt is. `split` needs to\
    \ traverse the entire string for each element\n<|/ c |>\n<| c |>\nThank you for\
    \ pointing out that `split` traverses the whole string. I've edited my answer\
    \ to reflect that.\n<|/ c |>\n<| c |>\nThat will make things O(n^2) in time and\
    \ memory, whereas sorting is O(n log n) in the size of the list, because you need\
    \ to sort. But I guess it's not a huge deal since these are only a few items.\
    \ Anyway, +1 from me.\n<|/ c |>\n<| a |>\nI like using Array#sort_by, so here's\
    \ my take on it:\n<code>", "  # Write your code here.\nend\n</cell>\n<text>\n\
    Now write an algorithm that prints all of the numbers of the integers from 1 to\
    \ 100, but prints the sums in ascending order according to the digits' sum.",
  "    # Write your code here.\n    digits = [num for num in nums]\n    digits.sort\n\
    \    point = 0\n    for index in range(0,len(nums)-1,1):\n        digitsum = digits[point]\
    \ + digits[index+1]\n        if digitsum > 10:\n            point += 1\n     \
    \       digits[index+1] = digitsum\n            digits.remove\n        else:\n\
    \            digits[index+1] = digitsum\n    return digits\nprint(order_by_points([9,5,3,6,8,2,4,7,1]))\n\
    </cell>\n<text>\nQ9. Write a function which counts how many times each element\
    \ appears in the given list.\nFor example:\n[1, 2, 3] -> {1:2, 2:1, 3:3}", " \
    \ nums.sort!\n  nums.map! {|x| x.to_i}\n  nums.sort!\n  return nums\nend", " \
    \   sort = []\n    digit_sum = nums.inject(:+)\n    sort.push([digit_sum, nums])\
    \ if digit_sum > 0\n    sort.each do |ds, nums|\n      nums.sort.each do |n|\n\
    \        digit_sum -= ds \n        sort << [digit_sum, n] if digit_sum > 0\n \
    \     end\n    end\n    sort.sort_by{|ds, n| n}\nend\n</cell>\n<cell>\nnums =\
    \ [3, 12, 2, 6, 21, 5, 10]\norder_by_points(nums)\n</cell>\n<text>\nRuby has several\
    \ array methods which you can apply to an array.  The array method include?  is\
    \ one of them.  It tests whether a given value occurs in a given array.", "  nums.sort.sort_by\
    \ { |n| n.digits.reduce(:+) }\nend", " \n    nums.sort(key = lambda i: sum(map(int,\
    \ str(i))))\n \n    return nums\n ", " \n    # initialize a variable to track\
    \ the index\n    index = 0", "  nums.sort! {|a, b| a.to_i + b.to_i}\nend", " \
    \ # O(N log N)\n  nums.sort!\n  sums = nums.map{|x| x.to_s.split('').map(&:to_i).reduce(:+)}.uniq\n\
    \  sums.each do |sum|\n    nums[sums.index(sum)] = nums[sums.index(sum)].reverse\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,arrays,sorting dscore=1 |>\n<| c\
    \ |>\nI'm sorry, but this solution is not correct. It fails to sort the array\
    \ when the sum of the digits in two consecutive elements is equal and should be\
    \ ordered. E.g. [10, 1, 100, 12]\n<|/ c |>\n<| a dscore=1 |>\nHere's a very naive\
    \ solution using recursion. Obviously it can be improved and optimized, but this\
    \ should do the trick:\n<code>", "  nums.sort do |a, b|\n    (a[0] + a[1]).to_i\
    \ <=> (b[0] + b[1]).to_i || a[0].to_i <=> b[0].to_i\n  end\nend", "  nums.sort!\
    \ do |i1, i2|\n    sum1 = sum2 = nil\n    sum_digits = nil\n    while i1 > 0\n\
    \      i1 = i1-1\n      i2 = i2-1\n      sum1 += i1 % 10\n      sum2 += i2 % 10\n\
    \      sum_digits += i1 % 10 + i2 % 10\n    end\n    if sum1 == sum2\n      sum_digits\n\
    \    else\n      sum_digits == 0 ? 0 : sum_digits - sum1 - sum2\n    end\n  end\n\
    end\n</code>\nThe above code takes advantage of Ruby's \"Enumerable\" object:\
    \ it knows how to iterate through each element of a collection.  It knows how\
    \ to sort an array, and it even knows how to sum up all the digits of an integer.\
    \  \nSince it sorts by the sum of the digits instead of by the sum of the digits\
    \ and the index, it's very efficient.  In fact, it's very simple.  \nBut notice\
    \ that the above code is extremely un-Rubyish.  It uses some really ugly language\
    \ features such as \"while\" and \"if\".  It also doesn't use proper Ruby idioms.\
    \  It is not idiomatic Ruby.  This is really a Python program!  But I'll post\
    \ it anyway, just for the heck of it.\n<code>", "    sum = 0\n    for i in nums\n\
    \        sum += i\n    end\n    return sum\nend", "  #Write your code here\nend",
  "  return nums.sort\nend", "\tnums.sort!{|a, b| a.to_s + b.to_s}\nend", "    sorted_nums\
    \ = []\n    sorted_nums = nums.sort\n    sum_of_digits = nums.sum\n    sorted_nums\n\
    \    sum_of_digits\nend\norder_by_points([-100, 5, 10, -5, -20, 100])", "  nums.sort\
    \ do |a, b|\n    if a + b > 9\n      b - a + 1\n    else\n      a if a > b\n \
    \   end\n  end\nend", "  nums = nums.sort\n  num_to_sum = {}\n  i = 0\n  while\
    \ i < nums.length\n    if num_to_sum[nums[i]] = true then\n      i = i + 1\n \
    \   else\n      num_to_sum[nums[i]] = true\n      i = i + 1\n    end\n  end\n\
    \  i = 1 while i < nums.length\n    if num_to_sum[nums[i]] then\n      i = 1\n\
    \    else\n      num_to_sum[nums[i]] = true\n      i = i + 1\n    end\n  end\n\
    \  nums = nums.sort\n  return nums\nend", "    # Write your code here.\n    #\
    \ return nums.sort { |a, b| a.to_s + b.to_s }\n    return nums.sort { |a, b| (a.to_s\
    \ + b.to_s).to_i }\nend", "  # TODO: Write your code here\n  nums.sort! do |a,b|\n\
    \    sum = a + b\n    sum < 10 ? -sum : sum\n  end\n  nums\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis is not working because of the `<=>` operator of\
    \ sort. Not because of the `!` operator. I cannot use any of those operators,\
    \ as they are just for demonstration purposes.\n<|/ c |>\n<| c |>\nWhat do you\
    \ mean? You can't use it? That's why I said \"Note\" above.\n<|/ c |>\n<| c |>\n\
    No, I mean I can't use any of those operators, as they are just for demonstration\
    \ purposes.\n<|/ c |>\n<| c |>\nI've edited my question with some code. Could\
    \ you have a look at it?\n<|/ c |>\n<| a tags=ruby |>\nI have solved this problem\
    \ by using the sort method which has a specific purpose and can be used for this\
    \ purpose also. I think this is a bit clearer then using gsub or regular expressions.\n\
    <code>", "  sorted = []\n  digits = nums.map {|x| x.to_s.split('').map(&:to_i)\
    \ }\n  digits.each do |digits|\n    sorted = sorted + [digits.reduce(0) {|p, i|\
    \ p + i }] \n  end\n  sorted.sort_by!{|x| x.to_i }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,sorting,algorithm |>\nJust sorting them as strings is fine.\
    \ \n<code>\nsorted = numbers.sort\n</code>\n<|/ a dscore=0 |>\n<| c |>\nBut they\
    \ have to be sorted in ascending order. With your solution, the smallest numbers\
    \ are at the end.\n<|/ c |>\n<| c |>\nAh! I see! That wasn't very clear in the\
    \ question\n<|/ c |>\n<| a dscore=0 |>\nI think this is a decent solution using\
    \ only integers\n<code>", "    # Write your code here\n    arr = []\n    arr.extend(nums)\n\
    \    arr.sort(key = lambda x:sum(map(lambda y:int(y),x)))\n    return arr\n</cell>\n\
    <cell>", "    puts \"Sorting...\"\n    nums.sort! { |a, b| sum(a.to_s) <=> sum(b.to_s)\
    \ } if nums.nil?\n    puts \"Done\"\nend", "  sorted = []\n  sum = nums.inject(0)\
    \ { |sum, n| sum += n.to_i }\n  sorted = nums.sort { |a, b| a.to_i + b.to_i ==\
    \ sum }\n  sorted + [sum]\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis code\
    \ also seems to fail for input like `[1,2,3]` because the final line `sorted +\
    \ [sum]` results in `[3, 1, 3]` instead of `[3, 3, 1, 3]`.\n<|/ c |>\n<| c |>\n\
    , I've updated the answer accordingly.\n<|/ c |>\n<| c |>\nYour code worked for\
    \ me. Thanks for your help.\n<|/ c |>\n<| a |>\nI came up with a solution that\
    \ has O(n) time complexity and O(logn) space complexity. I also don't need to\
    \ do any sorting. If I understand correctly, we can use Divide and Conquer to\
    \ reduce the problem to finding the maximum sum digit in each of the numbers less\
    \ than the original input, and we can also use it to solve the problem in reverse\
    \ by finding the lowest digit in the input less than the maximum of the sum of\
    \ its digits.\n<code>", "  # TODO: Your code goes here\n  raise NotImplementedError()\n\
    end", "  # TODO: Write your code here\n  return nums\nend", "  # TODO: Write code\
    \ here.\nend\n</cell>\n<text>\nTest Your Solution\nRun the cell below to test\
    \ your solution. Note that the expected output is listed as a float in the next\
    \ cell below, where you can see that your code returns \"Not equal\", since your\
    \ expected output differs from the actual output.", "  # Write your code here\n\
    end\n</cell>\n<cell>\norder_by_points([-2, -1, 1, 2, 3]) # => [-1, -2, -1, 1,\
    \ 2, 3]\n</cell>\n<cell>\norder_by_points([1, 2, 2, 1]) # => [1, 2, 2, 1, 1]\n\
    </cell>\n<cell>\norder_by_points([1, 1, 3, 5]) # => [1, 1, 5, 3, 1]\n</cell>\n\
    <text>\nHomework\nIn the cell below you will implement a function, max_sum_subseq,\
    \ which will calculate the max sum of any prefix of a list of numbers. For example,\
    \ the prefix of [1, 3, 5] is the list [1, 3, 5]. The max sum of the prefix of\
    \ numbers is the sum of the last two numbers of the prefix [1, 3, 5]. The max\
    \ sum here is 3 + 5 = 8.", "    sorted = []\n    sorted.push(nums[0])\n    for\
    \ i in 1..nums.length\n        digits = nums[i]\n        sum  = digits.reduce(0,\
    \ :+)\n        sorted.push(sum)\n    end\n    sorted.sort { |a, b| a <=> b }\n\
    end", "  nums.sort.with_index do |x,i|\n    if x.to_s.size == 1\n      x.to_s[0]\n\
    \    elsif x.to_s.size != 0\n      x.to_s.to_a.sort_by { |y| y.to_s.size }.index(x.to_s)\
    \ + 1\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your solution.\
    \ It helped me to understand `sort_by`. However, the `i` value in the block in\
    \ `sort_by` didn't work for me.\n<|/ c |>\n<| c |>\nAh, it seems my initial implementation\
    \ was wrong. I'll try to update the answer.\n<|/ c |>\n<| c |>\nI've updated my\
    \ answer. I'm not sure whether that solves your problem, because I don't know\
    \ what your problem is (and it doesn't look like the code in your question is\
    \ related to that problem).\n<|/ c |>\n<| c |>\nMy problem is that the `i` value\
    \ in `sort_by` is different from `i` in `with_index`. I know `with_index` is used\
    \ to get the index of the element in the list, but `sort_by` is used to sort the\
    \ list according to the sum of the digits. I think I should use `sort_by` not\
    \ `with_index` in the block, but I couldn't find a solution.\n<|/ c |>\n<| c |>\n\
    Oh, I think I see now. You want to sort the list, not just group them by their\
    \ sum. Sorry, didn't get that from the question. I'll try to update my answer\
    \ later.\n<|/ c |>\n<| a tags=ruby,sorting,ruby-on-rails |>\nI assume you only\
    \ want to use sort_by, because you already have an array of integers (nums). Having\
    \ nums.sort.with_index doesn't help much in this case, because with_index will\
    \ give the position of the item in the array and not the sum of the digits. \n\
    So, how can we get around this? We must use the each_cons method in Ruby 2.1+.\
    \ \n<code>\nnums.sort.each_cons(2) do |x|\n  puts x.map { |y| y.to_s.size }.sum\
    \ + x.last\nend\n</code>\nOutput:\n<code>\n4\n6\n3\n7\n2\n</code>\nThe each_cons\
    \ method will iterate over the array and yield pairs. \n<code>\nnums.sort.each_cons(2)\
    \ do |x|\n  puts x.map { |y| y.to_s.size }.sum + x.last\nend", "  nums.sort\n\
    \  sums = nums.map{|x| x.to_i}\n  sums.each_with_index.sort{|a, b| sums[b] - sums[a]}.map{|a|\
    \ a.index}.to_h\nend", "  sorted_nums = []\n  sorted_nums += nums\n  sorted_nums.sort!\
    \ { |a, b| a.to_i + b.to_i }\n  sorted_nums\nend", "  return nums\nend", "   \
    \ # Your code here\n    return nums\n</cell>\n<cell>", "    nums.sort!\n    nums.uniq!\n\
    end\n</cell>\n<cell>\nnums = [7,1,0,4,3,6,7,4,3,2,6,7,8,5,1,0,3]\n</cell>\n<cell>",
  "    # Write your code here.\n    return sorted(nums)\n</cell>\n<cell>\nnums = [121,\
    \ 321, 231, 111, 121, 131, 123, 123, 122]\nprint(order_by_points(nums))\n</cell>\n\
    <text>\nE. Given two arrays of equal size, A and B, write a Python program to\
    \ find the position of two elements in B which are missing in A.", "  # Your code\
    \ here\nend\n</cell>\n<code language=julia-1.5>", "    return nums\nend\nprint(order_by_points([12,\
    \ 13, 21, 22, 23, 33]))\n</cell>\n<text>\nProblem 7: Write a function that returns\
    \ the sum of the elements of a given list.\nExample:", "  nums.sort!{|a,b| a.to_s.split('').sum\
    \ <=> b.to_s.split('').sum}\nend", "  # +++your code here+++\nend", "  # Your\
    \ code here\nend\n</cell>\n<cell>", "  nums.sort!{|a, b| a.to_i + b.to_i }\nend",
  '  nums_sorted = nums.sort', "    # Write your code here\n    \n    return nums\n\
    </cell>\n<text>\nThe function will return the given list of integers sorted in\
    \ ascending order according to the sum of their digits. For example, order_by_points([10,\
    \ 2, 6, 1, 8, 3]) returns [1, 2, 6, 10, 8, 3].", "  # TODO: replace this part\
    \ with your own code\n  # Hint: Use a dictionary to save the positions of the\
    \ element\n  # in the list according to their digits.\n  # Example dic = {1: 0,\
    \ 2: 1, 3: 2, 4: 3}\n  points = []\n  dic = {}\n  for i in nums:\n    dic.setdefault(i,\
    \ 0)\n    dic[i] += 1\n  for i in nums:\n    points.append(dic.get(i))\n  points.sort()\n\
    \  print(points)\n  \n  return points\n    \n    \nprint(order_by_points([1,2,4,7,6,3,9,8,0]))",
  "  nums = nums.sort\n  return nums.first\nend", "    nums.sort! # sort in ascending\
    \ order by default\n    return nums\nend", "  sorted_list = []\n  sorted_index\
    \ = 0\n  for i in (0..nums.length-1)\n    digits = nums[i].to_s.split(//)\n  \
    \  if digits.inject(0){|sum,x| sum + x.to_i} == nums[i].to_i\n      sorted_list\
    \ << nums[i]\n      sorted_index += 1\n    end\n  end\n  sorted_list.sort!\n \
    \ sorted_list[sorted_index..-1]\nend", "  nums.sort!\n  nums.each do |i|\n   \
    \ nums.delete(i if nums.all? {|x| x.to_s.chars.to_a.reduce(0) {|sum, e| sum +\
    \ e.to_i} == i.to_s.chars.to_a.reduce(0) {|sum, e| sum + e.to_i}})\n  end\nend\n\
    </code>\nOutput:\n<code>\n> nums = [2, 9, 22, 9, 1, 15]\n> order_by_points(nums)\n\
    => [1, 15, 2, 9, 22, 9]\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for answering\
    \ the question, but I actually wanted a way to do it without modifying the array.\n\
    <|/ c |>\n<| a tags=ruby |>\nAs others have pointed out, you need to use reduce\
    \ to sum the digits and compare that sum to each element. Here is an alternative\
    \ way to implement a sort method which modifies the original array, rather than\
    \ creating a new one:\n<code>", "    sorted_points = []\n    nums.each do |num|\n\
    \      current_sum = 0\n      nums.each do |n|\n        current_sum += n % 10\n\
    \      end\n      if current_sum == num\n        sorted_points.push(num)\n   \
    \   end\n    end\n    sorted_points.sort!\nend", "  sums = nums.sum\n  min_sum\
    \ = sums.min\n  max_sum = sums.max\n  min_idx = nums.index(min_sum)\n  max_idx\
    \ = nums.index(max_sum)\n  return nums[min_idx..max_idx]\nend", "    nums_sorted\
    \ = []\n    \n    for i in nums:\n        num = abs(i)\n        sum = 0\n    \
    \    \n        if num < 10:\n            sum += num\n        else:\n         \
    \   sum += num%10\n            num = num//10\n            \n        while num\
    \ > 0:\n            sum += num%10\n            num = num//10\n            \n \
    \       if sum > nums_sorted[-1]:\n            nums_sorted.append(sum)\n    \n\
    \    return nums_sorted", "  nums.sort! { |a,b| a.to_i + b.to_i }\nend", "  sorted_nums\
    \ = []\n  nums.each_with_index do |n, i|\n    sorted_nums << n if nums.count(n)\
    \ == 1 &&\n      nums.count(nums[i]) == 1\n  end\n  sorted_nums\nend\np order_by_points([23,\
    \ 72, 115, 20])", "  nums.sort! do |a,b|\n    sum_a = 0\n    sum_b = 0\n    nums.each_with_index\
    \ do |x,i|\n      sum_a += x if x % 10 == 0\n      sum_b += x if i % 10 == 0\n\
    \    end\n    sum_a == sum_b ? a : b # Reverse sorting\n  end\nend", "    # Write\
    \ your code here.\n    return sorted(nums, key=lambda a: sum(a))", "    nums =\
    \ nums.sort_by {|i| i.digits.length }.to_a\n    nums = nums.sort_by {|i| i.digits.reverse\
    \ }.to_a\n    nums = nums.sort_by {|i| i }.to_a\n    nums = nums.sort_by {|i|\
    \ i }.to_a\n    nums = nums.sort_by {|i| i }.to_a\nend", "    # Write your code\
    \ here\n    nums_sorted = []\n    \n    for num in nums:\n        if num.digits.sum()\
    \ >= 10:\n            sort_index = 0\n            sum_digit = num.digits.sum()\n\
    \            \n            for i in range(10):\n                if num.digits[i]\
    \ == sum_digit:\n                    sort_index = i\n                    break\n\
    \            nums_sorted.append(nums[sort_index])\n            nums.remove(nums[sort_index])\n\
    \    \n    return nums_sorted\n    ", "    return nums\nend\n</cell>\n<cell>\n\
    nums = [6, 9, 10, 1, 6, 3, 6, 8, 4, 12, 7, 5]\norder_by_points(nums)\n</cell>\n\
    <text>\nWrite a function that takes a list of numbers and returns the sum of the\
    \ digits in each number. For example, if a list is [6, 9, 10, 1, 6, 3, 6, 8, 4,\
    \ 12, 7, 5] the sum of the digits is 1 + 6 + 6 + 9 + 10 + 8 + 4 + 12 + 7 + 5 =\
    \ 27.", "  # write your code here\n  return []\nend", "    # implement here\n\
    end", '# Write your code below!', "    # Write your code here\n    nums.sort!\n\
    \    sorted_nums = nums.map { |x| x.to_s }\n    sorted_nums.each do |x|\n    \
    \    digits = x.to_s.scan(/\\d/).map(&:to_i)\n        digits_sum = digits.inject(0)\
    \ { |sum, digit| sum + digit }\n        x.replace!(\"(\", \"\")\n        x.replace!(\"\
    )\", \"\")\n        x.replace!(digits_sum.to_s, \"\")\n    end\n    sorted_nums\n\
    end", "  # your code here\nend", "  return nums\nend", "  nums.sort!\n  nums.sort!{|a,b|\
    \ b - a }\n  nums.sort!{|a,b| a.to_s == \"#<Bignum:\" ? -1 : a.to_s <=> b.to_s}\n\
    end", "  # Write your code here\n  n = nums.count\n  sum = 0\n  n = nums.length",
  "  nums.sort!\n  i = 0\n  while i < nums.length\n    j = nums.length - 1\n    while\
    \ j > i\n      return true if nums[j] < nums[i]\n      return false if nums[j]\
    \ > nums[i]\n      j -= 1\n    end\n    i += 1\n  end\n  nums\nend", "    # write\
    \ your code here\n    sums = [0] * 10\n    for num in nums:\n        index = num\
    \ // 10\n        sums[index] += num % 10\n    return sorted(nums, key = lambda\
    \ n: sums[n // 10])", "    sorted = []\n    total = 0\n    \n    # Write your\
    \ code here.\n    nums.each do |x|\n      total += x.to_i\n      sorted << x if\
    \ total != x.to_i\n    end\n    sorted.reverse!\n    \n    sorted\nend", "   \
    \ nums.sort! {|a, b| b <=> a }\nend\n</cell>\n<cell>\norder_by_points(points)\n\
    </cell>\n<cell>\npoints\n</cell>\n<cell>", "    numbers = nums.to_a\n    sorted_numbers\
    \ = numbers.sort_by do |num|\n      sum = 0\n      digits = num.to_s.split(//)\n\
    \      digits.each {|d| sum += d.to_i}\n      sum\n    end\n    return sorted_numbers\n\
    \  end", "  nums_sorted = []\n  nums_sum = 0\n  nums.each do |num|\n    nums_sum\
    \ += num.to_i\n    nums_sorted << num if nums_sum == nums_sorted.last.to_i\n \
    \ end\n  nums_sorted.reverse!\nend", "  # write your code here\n  nums.sort.each\
    \ do |n|\n    sum = 0\n    while n > 0\n      sum = sum + n % 10\n      n = n\
    \ / 10\n    end\n    if sum < n\n      nums.swap(n, n + sum)\n    end\n  end\n\
    end", "  nums.sort! { |a, b| (a.to_i + b.to_i).to_s }\nend", "  nums.sort!\n \
    \ for i in 0..nums.length-1\n    return i\n  end\nend", "  return nums.sort(key\
    \ = lambda x : x.to_s.split('').reverse.join.to_i).reverse\nend", "  sums = nums.map(&:to_i).inject(Hash.new(0))\
    \ {|h, (i, sum)| h[sum] += i; h}\n  sums.sort_by { |sum, index| sums.rjust(index)\
    \ }\nend", "  # Your code here\nend", "    sums = nums.map(&:to_i).map(&:digits).sum\n\
    \    nums.sort_by{|n| sums[n]}\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt works\
    \ but not really in the way I wanted to do it. First of all it makes new arrays\
    \ of all the sums and then sorts them. Anyway thank you for answer!\n<|/ c |>\n\
    <| c |>\nActually you don't need to create new arrays for sums. Simply sum each\
    \ array and put this value in new array.\n<|/ c |>\n<| c |>\nYes, I thought about\
    \ it, but the thing is that my code was supposed to be written as I already have\
    \ it written. So I wanted to change it a bit, thanks for pointing that out. I've\
    \ edited my post and now it makes much more sense.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here's a modified version of's solution that does what you asked:\n<code>", " \
    \ # +++your code here+++\nend", "  return nums.sort_by do |n|\n    return n if\
    \ n.digits.sum >= 10\n    return n if n.digits.sum >= 20\n    return n if n.digits.sum\
    \ >= 30\n    return n if n.digits.sum >= 40\n    return n if n.digits.sum >= 50\n\
    \    return n if n.digits.sum >= 60\n    return n if n.digits.sum >= 70\n    return\
    \ n if n.digits.sum >= 80\n    return n if n.digits.sum >= 90\n    return n if\
    \ n.digits.sum >= 100\n    return n\n  end\nend\n</code>\nAnd here are some outputs:\n\
    <code>\nnums = [2, 12, 4, 1, 7, 5, 1, 8, 4]\norder_by_points(nums)\n=> [4, 2,\
    \ 5, 7, 8, 1, 12, 1, 4]", "  # Your code goes here\n  nums.sort!{|a,b|a+b}\nend",
  "  # Write your code here\n  nums_sorted = []\n  nums_sorted = nums.sort{|x,y|\n\
    \    x = x.to_i\n    y = y.to_i\n    x + y if (x + y) != 0\n  }\n  return nums_sorted\n\
    end", "  nums.sort!\nend\norder_by_points([14, 7, 13, 5, 12, 9])\n=> [5, 7, 9,\
    \ 12, 13, 14]", "    sorted = []\n    sums = nums.map(&:to_i).reduce(:+)\n   \
    \ sums.times do |i|\n        sorted.push(nums[i] if nums[i] <= sums)\n    end\n\
    \    sorted\nend", "  nums.sort! { |a, b| (a.to_i + b.to_i).to_i }\nend\n</cell>\n\
    <cell>\norder_by_points([7, 5, 7, 9, 4, 2])\n</cell>\n<text>\nQ4\nImplement the\
    \ following sorting algorithms in increasing order of time complexity:", "  index\
    \ = {}\n  nums.each_with_index do |n, i|\n    index[n.to_s.split('').map{|s| s.to_i}.inject(0,\
    \ &:+)]=i\n  end\n  nums.sort{|a,b| b<=>a }\n  nums.map {|n| nums[index[n.to_s.split('').map{|s|\
    \ s.to_i}.inject(0, &:+)]]}\nend", "  nums.sort!\n  sums = nums.map(&:to_i)\n\
    \  sums.each do |sum|\n    i = sums.index { |sum| sum == sum }\n    nums[i], nums[sums.index(i)]\
    \ = nums[sums.index(i)], nums[i]\n  end\n  nums\nend", "  # Your code here\nend\n\
    </cell>\n<cell>\norder_by_points([-2,8,0,-5,-10,20,-5,-10,-3,5,6])\n</cell>\n\
    <text>\n2.12 Find all possible combinations of items in a list\nWrite a function\
    \ which finds all possible combinations of items in the given list.\nFor example,\
    \ given [1,2,3], the combinations are:", "    nums_copy = nums.clone\n    sums\
    \ = nums.map { |num| num.to_s.split('').map(&:to_i).reduce(:+) }\n    nums.sort!\
    \ {|a, b| sums[a] <=> sums[b]}\n    nums_copy.sort! {|a, b| sums[a] <=> sums[b]}\n\
    \    nums\nend", "  sorted_nums = nums\n  # sort by their digits and descending\
    \ order based on their index\n  sorted_nums.sort! do |a, b|\n    if a == b\n \
    \     a\n    else\n      digit1 = a\n      digit2 = b\n      d = digit1.to_i +\
    \ digit2.to_i\n      d = d % 10\n      d = d > 9 ? d : 0\n      a < b ? -1 : d\
    \ < 0 ? 1 : 0\n    end\n  end\n  return sorted_nums\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| c |>\nNice! I'd probably do it with `String#count` (i.e. `s.to_s.chars.map(&:digit).count`)\
    \ but this is nice and concise.\n<|/ c |>\n<| c |>\nYou mean `a` and `b` are the\
    \ indices of the array, right?\n<|/ c |>\n<| c |>\nYes, `a` and `b` are the indices\
    \ of the array. Thanks for pointing that out!\n<|/ c |>\n<| a dscore=1 tags=ruby\
    \ |>\nSince we know that a string is a collection of characters, we could use\
    \ the .index method to search for the digit we wish to find, and then return the\
    \ position in the string where it can be found:\n<code>\n\"1234\".index(\"4\"\
    ) #=> 5\n</code>\nNow we can use that position value to obtain the integer at\
    \ that position in the string:\n<code>\n\"1234\".chars.map(&:to_i).index(4) #=>\
    \ 5\n</code>\nNow we can simply sum those values, and we will have the position\
    \ of the digit we're looking for:\n<code>\n\"1234\".chars.map(&:to_i).index(4).to_s\
    \ + 1\n</code>\nNow we can sort by that, using the following method and using\
    \ our number as the sort key:\n<code>", "  # TODO: Write your code here\nend",
  "  # TODO: raise exception if given list does not contain at least 3 integers\n\
    \  # TODO: compute sum of all integers in given list and sort the list by it\n\
    \  # TODO: if given list contains at least 3 integers, sort them in ascending\
    \ order\n  # TODO: return the ordered list\nend", "    sort = []\n    i = 0\n\
    \    while i < nums.length\n        sum = 0\n        while i < nums.length and\
    \ nums[i].to_i < 10\n            sum += nums[i].to_i\n            i += 1\n   \
    \     sort.push(sum)\n        i += 1\n    nums.sort!\n    i = 0\n    while i <\
    \ nums.length\n        sum = 0\n        while i < nums.length and nums[i].to_i\
    \ >= 10\n            sum += nums[i].to_i\n            i += 1\n        sort.unshift(sum)\n\
    \        i += 1\n    return sort\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ |>\n<| a tags=ruby,algorithm,ruby-on-rails dscore=0 |>\nMy initial thought was\
    \ to convert the input to an array, sort it, then convert it back into a string.\n\
    This is not very efficient since it converts the entire array into strings.\n\
    <code>", "    return nums\nend", "  sums = nums.group_by { |x| x.to_s }.map {\
    \ |k, v| [k, v.map(&:length).max] }.to_h\n  sums.sort_by { |k, v| v }.reverse.map\
    \ { |k, v| [k, nums[k]] }\nend", "  # Write your code here\nend", "  nums.sort!\n\
    \  index = 0\n  while index != nums.count\n    nums[index] = nums.inject(0) {|sum,\
    \ digit| sum + digit.to_i}\n    index += 1\n  end\nend", "  return nums\nend\n\
    nums = [7, 2, 5, 11, 8, 10, 12]\np order_by_points(nums)", "  nums_sorted = nums.sort\n\
    \  nums_sorted.reverse!\nend", "    # Write your code here.\n    \n</cell>\n<text>\n\
    Exercise 3\nHere we define a function which orders the given list of integers\n\
    by the sum of the absolute values of the digits of the integers.\nIf the sum of\
    \ the absolute values is equal, order them based on\ntheir index in the original\
    \ list.", "    sorted = []\n    nums.each_with_index do |n, i|\n      sorted.push(nums[i])\
    \ if n.to_s.size != i.to_s.size\n    end\n    sorted.sort_by{|x| -x.to_s.split(\"\
    \").map(&:to_i).inject(0)}\nend", "    nums_sorted = [] # sort the nums in ascending\
    \ order by sum of their digits\n    sorted = [] # store the sorted items (nums_sorted\
    \ = nums)\n    sums = nums.inject(:+) # sum of each number in nums\n    sums.times\
    \ do | index |\n      digit = nums.at( index % nums.length )\n      nums_sorted\
    \ << nums[ index % nums.length ] if sums == digit\n    end\n    nums_sorted.each_with_index\
    \ do | number, index |\n      sorted << number if number == nums[ index % nums.length\
    \ ]\n    end\n    sorted.join( ',' )\nend\nputs order_by_points([1,3,4,2,5,7,8,9,6,0])\
    \ # => 0,3,6,9,2,5,8,7,1,4,0\nputs order_by_points([3,2,1]) # => 3,2,1\nputs order_by_points([6,2,3,1,2,5,4,7,8,9,0,1])\
    \ # => 1,0,2,3,4,5,6,7,8,9", "  # Return the ordered list.\nend", "    nums.sort!\n\
    \    return nums\nend", "  # Write your code here\n  # nums is a list\n  nums=\
    \ nums.sort\n  nums.each do |num|\n    index = num.index(num.last)\n    num.last=\
    \ num.shift\n    num.insert(index, num.sum)\n  end\nend\norder_by_points([3, 10,\
    \ 5, 16, 20])\n=> [3, 5, 10, 16, 20]\n</code>\n<|/ a tags=ruby |>\n<| a |>\nThis\
    \ is a bit verbose, but I think it's pretty clear what the code does.\n<code>",
  "    # Your code here\n    nums_sorted = sorted(nums)\n    nums_sorted.sort(key=lambda\
    \ x: int(x))\n    nums_sorted = list(nums_sorted)\n    nums_sorted = nums_sorted[:nums_sorted.index(1)]\n\
    \    \n    return nums_sorted", "    nums_with_points = []\n    num_sum = 0\n\
    \    points_to_num = {}\n    for num in nums\n        num_sum += num\n       \
    \ if num_sum in points_to_num\n            points_to_num[num_sum] += 1\n     \
    \   else\n            points_to_num[num_sum] = 1\n            num_sum += points_to_num[num_sum]\n\
    \        nums_with_points << [num,points_to_num[num_sum]]\n    return nums_with_points.sort\
    \ { |a,b| a[1] <=> b[1] }\nend", "  nums.sort!\n  nums.map!{|n| [n, nums.index(n)]\
    \ }.sort_by{|k,v| v[0]}.map {|k,v| v[1]}\nend", "    # Write your code here.\n\
    end\n</cell>\n<code language=julia-0.5>\norder_by_points([-2,1,-2,4,-2,3,5])\n\
    </cell>\n<code language=julia-0.5>\norder_by_points([2,4,5,4,3,4,5,2])\n</cell>\n\
    <code language=julia-0.5>\norder_by_points([2,2,2,2,2,3,3,3,3])\n</cell>\n<text>\n\
    2.4 Counting Bits", "  nums.sort! do |a, b|\n    nums_sum = (a + b).to_s.split('')\n\
    \    nums_sum.sort_by{|s| s.to_i}\n  end\nend\nassert(order_by_points([7, 4, 2,\
    \ 7, 8, 7, 1, 9, 3, 0]) == [8, 7, 9, 7, 8, 4, 2, 0, 7, 7])", "    nums.sort!\n\
    \    nums.map { |n| [n, n.to_s.chars.map(&:to_i).inject(:+).abs] }\nend", " \n\
    \ \n    sums = {}\n \n    for item in nums\n        digit = item % 10\n      \
    \  sums[digit] = sums[digit] + 1 if digit in sums else 1\n \n    nums.sort! {\
    \ |a, b| sums[b] - sums[a] }\n \n    return nums\nend", "    sorted_list = nums.sort\n\
    end", "    # write your sorting code here\n    nums.sort! do |a, b|\n        (a+b).to_s.length\
    \ <=> (a+b).to_s.length\n    end\nend\n</cell>\n<cell>", "    sorted_by_sum =\
    \ []\n    sorted_by_index = []", "  nums.sort { |a,b| a + b }\nend", "    # Your\
    \ code here\n    # ...\nend\n</cell>\n<cell>\nnums = [3, 6, 5, 2, 5, 1, 7, 9,\
    \ 3, 6, 1, 3, 1]\norder_by_points(nums)\n</cell>\n<text>\n5. Subsets and set operations\n\
    5.1 Set operations\n5.1.1 Set union (\u222A)\nSuppose that we have the following\
    \ two sets:", "    # order them by their sum\n    nums = nums.sort", "  sum =\
    \ 0\n  nums.each_index do |i|\n    sum += nums[i]\n  end\n  nums.sort! { |a,b|\
    \ (sum - a.to_i + b.to_i).abs }\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\n<code>", "  nums.sort { |a, b| sum_digits(a) + sum_digits(b) }\nend", " \
    \ return nums\nend", "    sum = 0\n    nums.each do |x|\n        sum += x.to_i\n\
    \    end\n    sum = (sum % 10)\n    sum = (sum >= 5) ? sum : sum - 5\n    sum\
    \ = (sum > 0) ? sum : 0\n    return sum, nums\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
