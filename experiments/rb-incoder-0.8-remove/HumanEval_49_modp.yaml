name: HumanEval_49_modp
language: rb
prompt: "# Return 2^n modulo p (be aware of numerics).\ndef modp(n, p)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
  \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2,\
  \ candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8,\
  \ candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4,\
  \ candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
completions: ["  if n.modulo(p) == 0 then return 1 end\n  r = n.modulo(p)\n  r.reduce(p)\n\
    end\n</cell>\n<code language=julia-1.5>", "    p == Bignum.new(p) # check input\n\
    \    return Bignum.new(n).pow(-p).to_i\nend", "  while n >= p\n    n -= p\n  end\n\
    \  n\nend", "  r = 0xffffffff\n  v = (p-1)/2\n  while n > 0\n    r = (((r mod\
    \ p) << 1) + n % p) % p\n    n /= p\n    v += 1\n  end\n  v % p\nend", "  r =\
    \ 1\n  while n > p\n    r = r * 2 % p\n    n /= p\n  end\n  r\nend", "  r, s =\
    \ 0, n / p\n  while s < p\n    r = (r * s) + n\n    s += 1\n  end\n  return r\
    \ % p\nend", "  return ((n % p) + p) % p\nend", "  ((n % p + p) % p) % p\nend",
  "  return ((n % (p+1)) if (n < 0) else (n % (p-1)))\nend", "  return ((n << p) +\
    \ 1) % (p + 1)\nend", "  n1 = n.clone\n  n1.each { |e| e <= p ? n1[e] = e % p\
    \ : n1[e] = p }\n  n1\nend", "  return ((n % p) + p) % p\nend", "    m, r = divmod(n,\
    \ p)\n    if r != 0: return m + p\n    else: return m", "  r = 31\n  r = r.next\n\
    \  while (r = r.next) != nil\n    r %= p\n  end\n  r\nend", "  m = 1\n  while\
    \ n > p\n    n /= p\n    m = (m * p + n) % p\n  end\n  m\nend", "  (p ** n) %\
    \ p\nend", "  if p < 2\n    return n\n  n1 = n % p\n  r = n % p\n  n2 = (r + n1)\
    \ % (p-1)\n  if n2 == 0\n    return n\n  r = n - n2\n  r = r * 2 % p\n  return\
    \ r\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis code doesn't work for p==2.\n\
    <|/ c |>\n<| c |>\nIt works with p==2 because the answer is always an integer,\
    \ and mod2 is defined to give the correct answer even for p != 2.\n<|/ c |>\n\
    <| c |>\n, yes, it does work. [See here](http://ideone.com/9oTm7). For example\
    \ if p = 2, the modulus is always 2 and the result is always 0 or 1.\n<|/ c |>\n\
    <| c |>\n, yes, it does work. See [here](http://ideone.com/9oTm7).\n<|/ c |>\n\
    <| c |>\n, thanks for the links, I did a quick test with p = 2, and you're right,\
    \ your code works. I was incorrectly assuming that your code would work, since\
    \ `mod2` always gives a result for p != 2, whereas `modp` doesn't.\n<|/ c |>\n\
    <| a tags=integer,math,language-agnostic,modulo |>\nA solution that will work\
    \ with any base is as follows:\n<code>\nfunction mod (p:int; n:int)\n    n = n\
    \ % p\n    n = n + (p // n) * mod(p, n)\n    return n\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nIf `p = 2` and `n = 6` then this returns `3` instead of `2`.\n\
    <|/ c |>\n<| c |>\n: That's what I thought was wanted. Fixed now.\n<|/ c |>\n\
    <| c |>\nThe original code returns 2 on p=2 and n=6 where it shouldn't.\n<|/ c\
    \ |>\n<| c |>\n: The original code would return 3 on p=2 and n=6. This code returns\
    \ 2 on p=2 and n=6, which is exactly what was asked for.\n<|/ c |>\n<| c |>\n\
    : Yes it does, I even tested it on a p==2 and n==6 example and got the correct\
    \ results. Are you looking at something different?\n<|/ c |>\n<| a dscore=4 |>\n\
    If you use Ruby you can just use Integer#divmod, which allows you to directly\
    \ divide an Integer by ", "  q, r = n.divmod(p)\n  if r != 0\n    q, r = r.divmod(p)\n\
    \  end\n  return q << n if r == 0\n  return q * (1 << r) if r < 0\nend", "  r\
    \ = []\n  r = Array.new(n) {|i| p[i]}\n  r.each_index do |i|\n    r[i] -= n[i]\n\
    \  end\n  r.each_with_index do |r, i|\n    r[i] = r[i] * p[i] % p[i]\n  end\n\
    \  r\nend", "    p\nend", "  return ((n & 0x3FFFFFFF) << (p & 0x1F)) ^ ((n >>\
    \ 30) & 0x3FFFFFFF)\nend", "  r = 1\n  while r.bit_length <= n\n    r = r * p\
    \ % 4294967296\n  end\n  r\nend", "  r = []\n  while n.zero?\n    r << 0\n   \
    \ n >>= 1\n  end\n  while n.nonzero?\n    if n.even?\n      r << p\n      n -=\
    \ p\n    elsif n.odd?\n      r << 1\n      n -= 1\n    else\n      break\n   \
    \ end\n  end\n  r\nend", "  r = 0\n  while n > p\n    n -= p\n    r += 1\n  end\n\
    \  r\nend", "    r, i = n, 0\n    while i < p\n        r = ((r * r) + i) % p\n\
    \        i += 1\n    r\nend", "  result = 1\n  n.times { result *= p }\n  result\n\
    end", "  n1 = n % p\n  n2 = n1 % p\n  n3 = n2 % p\n  n4 = n3 % p\n  n5 = n4 %\
    \ p\n  n6 = n5 % p\n  return n6 % p\nend", "  return ((p-1) * pow(2, (n-1)) +\
    \ 1) % (p-1)\nend", "  ((n % p) == 0) ? n : ((n / p) + 1) * p\nend", "  m = 1\n\
    \  while p * m <= n\n    m <<= 1\n  end\n  m -= p\n  m %= p\nend", "  r = 1\n\
    \  while n > 0\n    r = p * r + n\n    n /= p\n  r\nend", "  ((n % p + p) % p)\n\
    end", "  return ((n & -p) << n) % (p | -p)\nend", "    p1 = bignum(p)\n    n =\
    \ n * p1\n    n, i = divmod(n, p1)\n    if i == 0: return 0\n    if i == p1: return\
    \ 1\n    r = bignum(n)\n    r, i = divmod(r, p1)\n    if i == 0: return r\n  \
    \  if i == p1: return r + 1\n    assert False", "  ((n % p) + p) % p\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis should be the selected answer!\n<|/ c |>\n<|\
    \ a dscore=5 |>\nYou would need an algorithm for finding modular inverse of a\
    \ number, and that is more difficult than just using simple multiplication. If\
    \ you are using any math library (like BigDecimal for Java), they will probably\
    \ have one. \nIn general you cannot inverse a number by simple multiplication,\
    \ and you should consider which method of finding inverse is more suitable for\
    \ your case. For example, if you know that your number is a prime (no one knows\
    \ for sure if that is the case), you can simply check if it's divisible by any\
    \ number between 2 and n - 1 and if it is, then it's trivial to find it's inverse.\n\
    <|/ a tags=modular-arithmetic,math |>\n<| c |>\nThe inverse is easy to find if\
    \ n is even.\n<|/ c |>\n<| c |>\nIf n is even it's easy to find it's inverse.\
    \  (If n is odd, it's very hard to find it's inverse.)  It depends on the problem\
    \ domain.  For instance, an \"inverse mod p\" function which just works for a\
    \ p^n modulo p problem is trivial.\n<|/ c |>\n<| c |>\nFor a non-prime number,\
    \ the only way to find an inverse is with a library that does it for you, such\
    \ as [this one](http://stackoverflow.com/questions/221983/why-do-people-say-there-is-no-modular-multiplicative-inverse-function/221993#221993).\n\
    <|/ c |>\n<| c |>\nI feel like this is a great answer, but I have one question.\
    \ How would one determine if a number is even or not?\n<|/ c |>\n<| c |>\nThis\
    \ answer doesn't make sense. By \"inverse\" do you mean \"modular inverse of x\"\
    ? If so then the inverse is defined in the question as the inverse of modular\
    \ multiplicative inverse.\n<|/ c |>\n<| a tags=modular-arithmetic,math |>\nThe\
    \ inverse of an integer is not unique. Some integers are multiples of others.\
    \ For example, if your number is 7, then:\n<code>\n7^3 = 1\n7^2 = 9\n7^1 = 7\n\
    7^0 = 1\n</code>\nBut if we consider the inverse of the number:\n<code>\n7^7 =\
    \ 1 mod 7\n</code>\nThat means that 7 is some multiple of 7. \nSo there are many\
    \ inverse of 7. But in general you can't find the inverse ", '    return ((n %
    p) + p) % p', "  result = 1\n  while n > 0\n    if n & 1 == 1\n      result =\
    \ result * p % p\n    n /= 2\n    p = (p * p) % p\n  end\n  result\nend\n</cell>\n\
    <code language=julia-1.5>", "  (remainder, remainders) = n.divmod(p)\n  return\
    \ (remainder.abs, remainders) if remainders.nonzero? else\n    [remainder.abs]\n\
    end", "  r = 1\n  while n > 0\n    r = r % p\n    n = n / p\n  end\n  r\nend",
  "    r, s = 0, 1\n    while n >= p\n        r = r * 2 + 1\n        s *= p\n    \
    \    n -= p\n    return (s * r) % p\nend\n</cell>\n<code language=julia-0.6>\n\
    for p in primes(n)\n    biggerthan(p, p)\nend\n</cell>\n<code language=julia-0.6>\n\
    biggerthan(568, 8) # returns nothing\n</cell>\n<text>\nExercise", "  return ((n\
    \ % p) + p) % p\nend", "  r = 1\n  while n > p\n    r = r * 2 % p\n    n /= p\n\
    \  end\n  r\nend", "  return n & (p-1)\nend", "  if p < 2 then return end\n  if\
    \ n == 0 then return p end\n  t = modpow(2, p, n-1) * p\n  if t < 2 then return\
    \ 0 end\n  if t > p then return p end\n  return t\nend", "  return ((n % p) +\
    \ p) % p\nend", "  return n & (-p-1)\nend", "  xs = n % p\n  if xs == 0 and n\
    \ != 0: return 0\n  if xs < 0: return modp(n + x, p) % p\n  return xs % p\nend\n\
    </cell>\n<code language=julia-1.6>", "  ret = n.dup\n  while p\n    ret += (n\
    \ >> p) & mask\n    p /= 2\n  end\n  return ret\nend", "  (n, rem) = divmod(n,\
    \ p)\n  (rem, rem2) = divmod(rem, p)\n  rem\nend\n</cell>\n<code language=julia-1.3>",
  "  ret = n.dup\n  p += ret.bitsize\n  while ret.bitsize < p\n    ret = ret * 2\n\
    \  end\n  if ret.bitsize > p\n    ret = ret >> p\n  end\n  return ret\nend", " \
    \ return ((p-1) * pow(2, n)) % p\nend\n</cell>\n<text>\nSo what if we wanted to\
    \ calculate this directly? Well, it turns out that it's possible! Let's check\
    \ it out for ourselves!", "  ret = 1\n  while n > 0\n    r = n % p\n    ret =\
    \ ret * p + r\n    n = n / p\n  end\n  return ret\nend", "  r = [0, 1]\n  while\
    \ r.length < n\n    r = r.product(0)+[0, p-1]\n  end\n  r[n]\nend", "  ((n % p)\
    \ + p) % p\nend", "  r, s = 0, 1\n  while (n >= 0)\n    s, r = s * 10, r * p %\
    \ p\n    n = (n - r) / p\n  return s\nend", "  r = [0, n]\n  while p > 0\n   \
    \ r = r + r.last + [(r[-1].last * 2**(n-1)).floor.modulo(p)]\n    p = p / 2\n\
    \  end\n  return r\nend", "    (p0,p1) = p.abs\n    (q0,q1) = (0,1)\n    while\
    \ n > 0\n        (q,r) = n.divmod(p0)\n        (q0,q1,q) = q1.div(q1,p)\n    \
    \    (q0,r,q) = q.divmod(r+p1)\n        (q0,q1,q) = q1.div(q1,p)\n        (q1,r,q)\
    \ = q.divmod(r+p0)\n        (q1,q0,q) = q0.div(q0,p)\n        (q,r,q1) = q.divmod(r+p0)\n\
    \        (q,r,q0) = q.divmod(r+p0)\n        (q,r,q1) = q.divmod(r+p1)\n      \
    \  (q1,r,q) = q.divmod(r+p1)\n        (q1,r,q) = q.divmod(r+p0)\n        (q,r,q0)\
    \ = q.divmod(r+p0)\n        (q,r,q0) = q.divmod(r+p0)\n        (q,r,q1) = q.divmod(r+p1)\n\
    \        (q1,r,q) = q.divmod(r+p1)\n        (q1,r,q) = q.divmod(r+p0)\n      \
    \  (q,r,q0) = q.divmod(r+p0)\n        (q,r,q0) = q.divmod(r+p0)\n        (q,r,q1)\
    \ = q.divmod(r+p1)\n        (q1,r,q) = q.divmod(r+p1)\n        (q1,r,q) = q.divmod(r+p0)\n\
    \        (q,r,q0) = q.divmod(r+p0)\n        (q,r,q0) = q.divmod(r+p0)\n      \
    \  (q,r,q1) = q.divmod(r+p1)\n        (q1,r,q) = q.divmod(r+p1)\n        (q1,r,q)\
    \ = q.divmod(r+p0)\n        (q,r,q0) = q.divmod(r+p0)\n        (q,r,q0) = q.divmod(r+p0)\n\
    \        (q,r,q1) = q.divmod(r+p1)\n        (q1,r,q) = q.divmod(r+p1)\n      \
    \  (q1,r,q) = q.divmod(r+p0)\n        (q,r,q0) = q.divmod(r+p0)\n        (q,r,q0)\
    \ = q.divmod(r+p0)\n        (q,r,q1) = q.divmod(r+p1)\n        (q1,r,q) = q.divmod(r+p1)\n\
    \        (q1,r,q) = q.divmod(r+p0)\n        (q,r,q0) = q.divmod(r+p0)\n      \
    \  (q,r,q0) = q.divmod(r+", "  p1 = BigInt.pow(n-1, p)\n  (p2n, p2m) = p1.divmod(p)\n\
    \  return p2n\nend", "  r = 1\n  for i in (0..n-1)\n    r = r * p % i\n  end\n\
    \  r\nend", "  r1, r2 = p\n  (p1r1, p2r1), (p1r2, p2r2) = p % r1, p % r2\n  if\
    \ r1 == 0: return p2r1\n  if r2 == 0: return p2r2\n  r = r1\n  while r != r2:\n\
    \    r = r2 if r < r1 else r1\n  return r", "\treturn ((n << p) % p)\nend\nfunction\
    \ modpow(n, p, r)\n\treturn modp(n, p) ^ r\nend", "  r = 0\n  while n > 0 do\n\
    \    r = r * p + (n % p)\n    n /= p\n  end\n  return r\nend", "    return ((n\
    \ % p + p) % p) if p != 0 else n\nend", "  ret = n\n  while n != 0\n    ret =\
    \ ret * p\n    n = n / p\n  end\n  return ret\nend", "  t = 1\n  while p != 0\n\
    \    t = t * n % p\n    p = p / 2\n  end\n  t\nend", "  n2 = n * 2\n  p += n2\
    \ >> 30\n  n -= n2 & 01\n  p ^= n\n  p %= p\n  p ^= p\n  return p\nend\n</code>\n\
    Note that when n = 2^30 + 1 then the modulus p is the smallest number that can\
    \ encapsulate the value 2^30 + 1 - 1 = 31 bits. Since p = 31 this means that n\
    \ = 2^31. Let's consider a number n that represents 2^30 mod p = 31, which is\
    \ obviously smaller than 2^31 - 1 = 31 bits.\nIn order to test the validity of\
    \ the modp function we must first define the problem under consideration. The\
    \ problem we are testing is the following:", "  return ((n%p)*(p+1)%p)%p\nend",
  "  return ((n / p + 1 ) * p) % p\nend", "  r = (n).floor\n  (r + p) % p\nend", " \
    \ n = n.abs # abs(n) <= p\n  while p > 0\n    p >>= 1\n    n |= n >> p\n  end\n\
    \  n\nend", "  n = (n+1)%p\n  return (n - n*((n-1)%p))%p\nend", "  rem = p\n \
    \ n.times do\n    rem = rem * 2 % p\n  end\n  rem\nend", "  r =\n    if n < 0\n\
    \      0\n    else\n      if p < 0\n        (p % -n)\n      else\n        ((p\
    \ // n) * n)\n      end\n    end\n  r %= p\n  r >>= 8 if r < 0\n  r\nend", " \
    \ return ((n%p) + p) % p\nend", "  r = []\n  r.push(n % p)\n  while n /= p\n \
    \   r.push(n % p)\n  return r\nend", "  r, i = divMod(n, p)\n  r\nend", "  return\
    \ n**(1/p) % p\nend\n</pre>", "  ret = n\n  while (ret % p) != 0\n    ret = ret\
    \ % p\n  end\n  ret\nend", "  return ((n % p) + p) % p\nend", "  m = (p-1)/2\n\
    \  x = 1 \n  while n > 1\n    x = x * (m-n+1) + n\n    n = n/2\n  end\n  x % p\n\
    end", "  r = n % p\n  return r if r <= p else r + p\nend", "  r, s = n.divmod(p)\n\
    \  if s > 0\n    r = r + 1\n    s += 1\n  end\n  if r > p\n    r, s = (r-p).divmod(s)\n\
    \  end\n  return r, s\nend", "  r = 1\n  while n > 0, n % p, n /= p\n  r\nend",
  "  m = (n % p) % p\n  (rest = n) % p\n  return m if rest == 0 else m + modp(rest,\
    \ p)\nend", "  return ((n % p) + p) % p\nend", "  r = 0\n  while n % p == 0\n\
    \    r, n = n, r\n  end\n  r\nend", "  return ((n & -p) ^ n) << (p & -n)\nend",
  "  ((n % p) + p) % p\nend", "  n0 = n % p\n  n1 = n0.to_i(2)\n  if n == n0\n   \
    \ n1\n  else\n    n0.to_s(2).to_i(2).divmod(p).inject(:+) * p\n  end\nend", " \
    \ while n and p\n    n >>= 1\n    p -= 1\n  end\n  n\nend", "  return ((n&1) ?\
    \ p-2 : p-1) + n # n&1 returns 0 for odd n, 1 for even\nend", "    r, s = 0, 1\n\
    \    while n > 0, n % p == 0, n /= p\n    r += s\n    if n > 1\n        r, s =\
    \ s, r\n    return r", "  r = [1, 1]\n  while n > 1\n    mod = n%p\n    r = [(r[0]%p)\
    \ + r[1], r[1]/mod]\n    n = (n-mod)\n  end\n  r[1]\nend", "  r = 1\n  while n\
    \ > 0 do\n    r = ((r * n) + p) % p\n    n /= 2\n  end\n  r\nend", "  x = n.abs\n\
    \  y = x.quo(p)\n  y = (y + x).div(2)\n  y = p.div(y) unless y.equal?(Modp::ONE)\n\
    \  y\nend\n</code>\nYou don't need to remember the modulus, just use modp each\
    \ time. As soon as you have a Modp::ZERO modulus, you are done, and you can safely\
    \ discard it.\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nI noticed a big difference\
    \ between your method and my method of using the inverse of the modulus.  In your\
    \ method, the final modular multiplication step is unnecessary (as you saw on\
    \ https://math.stackexchange.com/questions/262937/modulo-operations-on-arbitrary-modulus-with-a-prime-number-modulus-p).\n\
    <code>", "  r = Bignum.new(0)\n  x = Bignum.new(n)\n  x.shiftLeftBy(1)\n  while\
    \ !x.isZero()\n    if x.bitLength() > p.bitLength()\n      r = r.add(x)\n    \
    \  break\n    x.shiftLeftBy(p.bitLength())\n  end\n  return r\nend", "  n0 = n.abs\
    \ % p\n  r = n % p\n  if r == 0\n    r1 = p - 1\n  else\n    r1 = r\n  end\n \
    \ n.ceil\n  (r1 * n0 + r).floor\nend", "  r = 1\n  while n > p\n    r = r * 2\
    \ % p\n    n /= p\n  return r\nend", "  p\nend", "  r1, r2 = n % p, p % p\n  if\
    \ r1 == 0 then\n    r2\n  else\n    r1, r2 = p - r2, r1\n  end\nend", "  a = (n\
    \ / p).floor()\n  return a + (a >= n)\nend", "  n0 = n.clone\n  n0.each_byte{|b|\n\
    \    if b == p.first\n      p -= 1\n    end\n  }\n  n\nend", "  a = (p - 1) >>\
    \ 8\n  b = (p - 1) & 255\n  return ((a ^ n) & -a & b) | ((a & n) << b)\nend",
  "  r = 1\n  while n > 0, n % p, r = r * 2, n /= p\n  r\nend", "  n1 = n.to_f\n \
    \ n2 = p - n\n  n1.divmod(n2)\nend", "  ret = 1\n  while n > p\n    ret = (ret\
    \ % p) + p\n    n = n / p\n  end\n  return ret\nend", "  rem = 0\n  while rem\
    \ * p < n\n    rem = rem + 1\n  end\n  rem * p\nend", "  u = (n % p) + 1\n  return\
    \ u if u > 0 && (n % p) == 0 else u\nend\n</cell>\n<code language=julia-1.5>",
  "  return ((n%p) == 0 and n%p) or modp( (n//p)*p, p )\nend", "  ret = (n-1) % p\n\
    \  ret |= ((n%p) < 0) ? p - ((n%p) > 0) : n%p\n  ret\nend", "  r = 0\n  while\
    \ n > 0 do\n    r = r*p + n%p\n    n = n / p\n  end\n  return r\nend", "  ((n\
    \ % p + p) % p).floor\nend", "  return ((n % p + p) % p) % p\nend", "  return\
    \ ((p-1)*n) & p\nend\n</cell>\n<code language=julia-1.0>", "  return p if n >=\
    \ 0 else ((n % p) + p) % p\nend", "  r = 1\n  while n > 0, do\n    r = r * p %\
    \ n\n    n = n / 2\n  end\n  r\nend\n</cell>\n<code language=julia-1.1>", "  r\
    \ = 1\n  while n > 0\n    r = ((r << n) & p) if (n /= 32) != 0 && (r & (p - 1))\
    \ != 0\n  end\n  r\nend", "  q, r = divMod(n, p)\n  r ? r + q * p : q\nend", " \
    \ while n >= p\n    n = ((n % p) + p) % p\n  end\n  n\nend", "  (n).to_s(2).scan(/.{8}/)\
    \ {|x| x.reverse! }.reverse!\n  (n & -p).zero? ? n : 2**n.to_s(2).reverse!\nend",
  "  p -= 1\n  r = 0\n  while ((n >> p) > 0) and ((n >> p) != 0)\n    n ^= (n & ((1\
    \ << p) - 1))\n    r |= (n >> p)\n    p -= 1\n  r |= ((n << (64 - p)) - 1) if\
    \ (n & ((1 << 64) - 1))\n  r %= p\n  return r\nend", "  return ((n % p) + p) %\
    \ p\nend", "  ((n >> p) & MASK) ? ((n - (((n >> p) & MASK) * (1 << p)) % p) &\
    \ MASK) : (n % p)\nend", "    r, i = MODMOD(n, p)\n    if i == 0\n        return\
    \ r\n    r, i = r % p, r - i * (p - 1)\n    return r", "  r = 1\n  while n > 0\
    \ do\n    r = r*p % n\n    n /= p\n  end\n  r\nend\n</cell>\n<text>\nThe modular\
    \ exponentiation algorithm above is implemented in Julia's pow function. We can\
    \ implement the modular exponentiation algorithm ourselves as follows, although\
    \ Julia's implementation is more efficient and more flexible. We'll implement\
    \ the modular exponentiation algorithm using the Gauss-Jordan algorithm and we'll\
    \ implement a more efficient implementation using the Chinese-Restaurants algorithm\
    \ as well.", "  return ((n >> 1) + 1) % p\nend", "  r = 1\n  while p\n    q, r\
    \ = divmod(n, p)\n    n    = q\n    p    = r\n  end\n  return r % p\nend", " \
    \ (n >= 0) == (p >= 0) == (p >= n)\n  p # Non-negative\nend", "  (p == 0) ? 0\
    \ : 1\nend", "  (b, n) = n.divmod(p)\n  (b, b == 0 ? 1 : b)  # Force b to be in\
    \ range.\n  n\nend", '    return ((n % p) + p) % p', "  (p ** n) % p\nend\n</code>\n\
    Then we can write the function as modpo:\n<code>", "  n = n.to_i\n  p = p.to_i\n\
    \  if n == 0 then\n    return 0\n  else\n    if n <= p then\n      return 1\n\
    \    else\n      return p % n\n    end\n  end\nend", "  rems = 1\n  n.times do\n\
    \    rems = (rems * p) % p\n  end\n  rems\nend", "  r =  0\n  while n > 0\n  \
    \  r = r*p % n\n    n = n >> 1\n  end\n  r\nend", "  r = 1\n  while n > 0, n %\
    \ p == 0, n /= p\n  r\nend", "  m =\n  if n == 0\n    1 // p\n  else\n    p\n\
    \  end\n  Math.pow(m, n)\nend", "    a, b = divmodn, n\n    if a == 0 and b ==\
    \ 1 or b == 0 and a * a == b:\n        return p\n    return modn(b, p)", "  if\
    \ p > 2 ^ n.bit_length\n    raise(ArgumentError, \"The modulus p must be less\
    \ than or equal to 2^n\")\n  r = n % p\n  while r > 0\n    r = r % p\n  end\n\
    \  r\nend", "  begin\n    return n if n < 0 || (n % p) == 0 \n    \n    n + ((p\
    \ - 1) % n)\n  end\nend\n</cell>\n<cell>", "  (p^(n-1))/p\nend", "  while n <\
    \ 0\n    n = n * 2 + 8\n  n % p\nend", "  return ((n & (p-1)) ^ n) % p\nend",
  "  return ((n >> ugemp(p, 2 ** 64)) % p)\nend", "  (p * n).modulo(p)\nend", "  r\
    \ = 0x1\n  while n > 0\n    r = ((r * 0x1) + n % p) % p\n    n >>= 1\n  end\n\
    \  r\nend", "  result = 1\n  while n > p\n    result *= p\n    result %= p\n \
    \   n -= result\n  end\n  result\nend", "  r1, remainder = divrem(BigInt.pow(2,\
    \ n), p, 2)\n  r2 = BigInt.mul(r1, BigInt.inverse(p))\n  return r2, remainder\n\
    end", "  result = 1\n  while n > 0\n    result, n = n div p, n % p\n  end\n  result\n\
    end", "  r, s = n.divmod(p)\n  if n.sign == 0 && p.sign == 0\n    r\n  else\n\
    \    s + p\n  end\nend", "  return ((n >> 1) + p) % p\nend", "  r = []\n  for\
    \ b in n.to_s(2)\n    b = b.chr\n    i = b.index(\".\")\n    if i == -1\n    \
    \  r.append(b)\n    else\n      m = b[i..-1].to_i(2)\n      b = b[0..i+1]\n  \
    \    if b == \"\"\n        r.push(\"#{b}0\")\n      else\n        if m * 2 ==\
    \ 10\n          r.push(\"#{b}0\")\n        else\n          if m == 0\n       \
    \     r.push(\"#{b}1\")\n          else\n            r.push(\"#{b}#{m}\").gsub(/\\\
    B0.(?!\\B)/, \".\")\n          end\n        end\n      end\n    end\n  end\n \
    \ r.join.sub(/[#0]+/, \"\")\nend", "  r =  n^(p-1)\n  r %= p\n  r &= (p-1)\n \
    \ r\nend\n</cell>\n<code language=julia-1.0>\np = 256\n</cell>\n<code language=julia-1.0>\n\
    modp(1,p)\n</cell>\n<code language=julia-1.0>\nmodp(2,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(3,p)\n</cell>\n<code language=julia-1.0>\nmodp(4,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(5,p)\n</cell>\n<code language=julia-1.0>\nmodp(6,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(7,p)\n</cell>\n<code language=julia-1.0>\nmodp(8,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(9,p)\n</cell>\n<code language=julia-1.0>\nmodp(10,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(11,p)\n</cell>\n<code language=julia-1.0>\nmodp(12,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(13,p)\n</cell>\n<code language=julia-1.0>\nmodp(14,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(15,p)\n</cell>\n<code language=julia-1.0>\nmodp(16,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(17,p)\n</cell>\n<code language=julia-1.0>\nmodp(18,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(19,p)\n</cell>\n<code language=julia-1.0>\nmodp(20,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(21,p)\n</cell>\n<code language=julia-1.0>\nmodp(22,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(23,p)\n</cell>\n<code language=julia-1.0>\nmodp(24,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(25,p)\n</cell>\n<code language=julia-1.0>\nmodp(26,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(27,p)\n</cell>\n<code language=julia-1.0>\nmodp(28,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(29,p)\n</cell>\n<code language=julia-1.0>\nmodp(30,p)\n</cell>\n<code language=julia-1.0>\n\
    modp(31,p)\n</cell>\n<code language=julia-1.0>\n", "  m = (n % p) + p\n  if m\
    \ > p then \n    m -= p\n  else \n    m == 0\n  end\n  return m\nend", "  r =\
    \ n.to_s(2)\n  while r.length < p\n    r = '0' + r\n  end\n  r\nend", "  return\
    \ ((n % p) + p) % p\nend", "  ret = n % p\n  if ret == 0\n    ret\n  else\n  \
    \  p -= ret\n    ret + (p < 0)\n  end\nend", "  return ((n & -p) == p) ? n : ((n\
    \ | -p) == p) ? n : ((n & -p) == p) ? n : ((n | -p) == p) ? n : 0\nend", '    return
    ((n & (-p -1)) >> (p-1))', '    return ((n % p) + p) % p', "  r = 0; t = 1; s\
    \ = 1; p2 = p; n2 = n\n  n.times { r = ((r * p) % n2, s = (r * s) % n2) }\n  r;\
    \ s\nend", "  ((n % p) + p) % p\nend", "  r = 0\n  while n > 0 and n & 1 == 1\n\
    \    r = r << 1\n    n >>= 1\n  end\n  if n != 0\n    r = r + (p & -n)\n  end\n\
    \  return r\nend", "  r =  n % p\n  if r == 0\n    return n\n  r -= 1\n  rem =\
    \ p // r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r\
    \ %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n  if\
    \ r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n  \
    \  return rem\n  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n    return rem\n\
    \  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n \
    \ rem = p // r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p //\
    \ r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n\
    \  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n\
    \    return rem\n  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n    return rem\n\
    \  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n \
    \ rem = p // r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p //\
    \ r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n\
    \  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n\
    \    return rem\n  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n    return rem\n\
    \  r += 1\n  rem = p // r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n \
    \ rem = p // r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p //\
    \ r\n  r %= p\n  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n\
    \  if r == 0\n    return rem\n  r += 1\n  rem = p // r\n  r %= p\n", "  (p^(n-1))*n%p\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI know this is an old question but I\
    \ had a similar problem and found the solution I wanted.\nI needed the ability\
    \ to generate prime numbers between a certain range.  For this I use the following\
    \ functions:\n<code>\nrequire 'bigint'", "  while n > p\n    n -= p\n  end\n \
    \ n\nend", "  r = 1\n  while n > 0 do\n    r = r * p % n\n    n /= p\n  end\n\
    \  r\nend", "  ret = n.dup.quo(2**p).to_i(2)\n  ret.zero? ? n : ret\nend", " \
    \   t, r = divmodn(n, p)\n    s := t >> 1\n    if (t & 1) != 0\n        s := -p\n\
    \    r := r * p + s\n    return r, s\nend", "  return ((n-1)%p)\nend\n</cell>\n\
    <cell>", "  n = n.to_i\n  p = p.to_i\n  if (n.odd? && p.odd?) || (p.odd? && !n.odd?)\n\
    \    raise \"ArgumentError: p and n must be odd numbers\"\n  end\n  return ((n.even?\
    \ && p.even?) || (p.even? && !n.even?)) ? p : p.inverse\nend", "  n1 = n & ((1\
    \ << 64) - 1); n2 = (n - n1) >> 64; n = (n1 + n2) >> 64\n  n1 = n1 >> 64; n2 =\
    \ n2 >> 64; n = n >> 64\n  return (p * n) % p\nend", "  r = n % p\n  while r ==\
    \ 0\n    r = n % p\n  end\n  r\nend", "  r = (n^(p-1)) % p\n  r == 0 ? 0 : r\n\
    end", "  n, p = n.to_i, p.to_i\n  i = 1\n  while i <= p\n    i = i * 2\n  end\n\
    \  return i % p\nend", "  r = 1\n  while n > 0 do\n    r = r * p % n\n    n =\
    \ n / 2\n  end\n  r\nend", "\treturn ((n << p) & n) % p\nend", "  r = (n % p)\n\
    \  return (r * p) if r <= 0 else r", "  r = 0\n  for i in 0...n\n    r = ((r *\
    \ 2) + 1) % p\n  end\n  r\nend", "  ((n >> p) & pow(2, 32 - (p % 8)))\nend", " \
    \   if p < 2\n        return n\n    if p > n\n        return n\n    if n == 1\n\
    \        return p\n    # Iterate over bits of n starting from the right\n    #\
    \ http://code.activestate.com/recipes/577102-integer-based-exponentiation-algorithm-exponentiation-in-python/\n\
    \    acc = 0\n    while n != 1:\n        # Left shifting n by 1 bit\n        n\
    \ >>= 1\n        acc += n\n    # Left shifting acc by p (p is now a power of 2)\n\
    \    acc <<= p\n    return acc", "  n = (n * Math.pow(2, p)) % p\n  return n\n\
    end", "  r = BigInt.new(p)\n  while n > 0\n    r = r * p % n\n    n /= p\n  end\n\
    \  r\nend", "  return ((n % p) + p) % p\nend", "  x = n\n  r = nil\n  while n\
    \ > 1\n    r = x * p % n\n    x = r\n  end\n  r\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=algorithm,math |>\nThe below answer has two parts:\nFirst: how\
    \ to find powers\nSecond: how to find modular inverse\nFor finding powers, you\
    \ need to use the following formula:\nx^n = x^(n-1) * x mod p\nFor finding modular\
    \ inverse, use the following formula:\nx^p = (x^(p-1))*x mod p\nIf p is prime,\
    \ find modular inverse by factorization. \nIf p is not prime, find modular inverse\
    \ by using the above formula for prime p \nNote that for finding modular inverse,\
    \ you need to find the inverse mod p first. \nTo factorize using Fermat's Theorem,\
    \ use the following formula:\nx^(p-1) = (x^(p-2))*(x^(p-3))* mod p\nIf you need\
    \ to find the inverse mod p, you just need to replace (p-1) with p-1 in above\
    \ formulas.\nNow implement the above formulas in your language. \nBelow are the\
    \ C functions to perform the above mentioned tasks:\n<code>\nint inverse(unsigned\
    \ int n)\n{\n    unsigned int p, q, r, i, x=1, y;", "  return ((n & 0xffff) *\
    \ pow(2, 32, (p & 0xffff)) + 0x10000) % p\nend", "  ((n % p) + p) % p\nend\n</pre>\n\
    \    </td>\n  </tr>\n</table>\n</div>\n</div>", "  return ((n >> 1) ^ p) & p\n\
    end", "  return ((p-1) * 2**(n-1)) % p\nend", "  while n != 0\n    n &= n - 1\n\
    \    p = (p + 1) & p\n  end\n  p\nend", "  r, s = n.divmod(p)\n  r + (r >= p and\
    \ n % r == 0)\nend\n</cell>\n<code language=julia-1.1>", "  q, r = divmod(n, p)\n\
    \  if r != 0 then q*p else q\nend", "  n = n.abs # Handle negative moduli (be\
    \ aware of numerics).\n  p = p.abs # Handle negative moduli.\n  rem = n % p\n\
    \  r2 = rem ** 2\n  if rem == 0 or (rem == -1 && p == 1)\n    mod = p # Handle\
    \ identity moduli (be aware of numerics).\n  else\n    mod = (rem + (n % p)) %\
    \ p\n  end\n  return mod if r2 > n\n  return modp(r2, p) \nend\n</cell>\n<cell>",
  "  r = [0,1]\n  r[1] = (((n * p[1]) % p[0]) % p[1]) % p[0]\n  if n > 1 then\n  \
    \  r[0] = (modp(n - 1, p)[1] * p[0]) % p[1]\n  else\n    r[0] = ((n * p[0]) %\
    \ p[1]) % p[1]\n  end\n  r\nend", "  r = n % p\n  r == 0 ? n : r\nend\n</code>\n\
    You can then use it like this :\n<code>\nrequire 'bignum'\np n = 2**32  # => 8\n\
    p n, modp(n, p)  # => 8\n</code>\n<|/ a dscore=4 |>\n<| a dscore=2 |>\n<code>",
  "  return ((n % p) + p) % p\nend", "  return ((n % p) + p) % p\nend", "  return\
    \ ((n % p) + p) % p\nend", "  ((p * n) & -n | p * (n+1) - p - 1) % p\nend", " \
    \ (remainder, remainder) = remModp(n, p)\n  remainder\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
