name: HumanEval_118_get_closest_vowel
language: rb
prompt: "# You are given a word. Your task is to find the closest vowel that stands\
  \ between \n# two consonants from the right side of the word (case sensitive).\n\
  # Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n\
  # find any vowel met the above condition. \n# You may assume that the given string\
  \ contains English letter only.\n# Example:\ndef get_closest_vowel(word)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_closest_vowel\n\
  \    candidate = method(:get_closest_vowel)\n    assert_equal(\"u\", candidate.call(\"\
  yogurt\"))\n    assert_equal(\"u\", candidate.call(\"full\"))\n    assert_equal(\"\
  \", candidate.call(\"easy\"))\n    assert_equal(\"\", candidate.call(\"eAsy\"))\n\
  \    assert_equal(\"\", candidate.call(\"ali\"))\n    assert_equal(\"a\", candidate.call(\"\
  bad\"))\n    assert_equal(\"o\", candidate.call(\"most\"))\n    assert_equal(\"\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"\", candidate.call(\"ba\"))\n    assert_equal(\"\
  \", candidate.call(\"quick\"))\n    assert_equal(\"i\", candidate.call(\"anime\"\
  ))\n    assert_equal(\"\", candidate.call(\"Asia\"))\n    assert_equal(\"o\", candidate.call(\"\
  Above\"))\n  end\nend\n"
completions: ["  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  word = word.downcase\n\
    \  vowel_index = word.index(\"a\")\n  if word.length <= vowel_index\n    return\
    \ \"\"\n  right_index = vowel_index + 1\n  while right_index < word.length\n \
    \   if word.at(right_index) == \"u\"\n      return word.at(right_index - 1) +\
    \ word.at(right_index)\n    right_index += 1\n  return \"\"\nend", "  vowels =\
    \ %W(a e i o u)\n  vowels.each do |vowel|\n    return vowel if word[/#{vowel}\\\
    w/, 1] && word[/\\w#{vowel}/, 1]\n  end\nend", '# get_closest_vowel("abracadabra")
    --> ""', "end=\"i\"\nstart=\"a\"\nvowels=[]\nvowels.append(start)\nvowels.append(end)\n\
    vowels.each_with_index do |vowel,index|\n  if word.ends.index(vowel) == word.index(vowel,word.index(vowel)+1,false)\n\
    \    return word.slice(vowel)\n  end\nend\nend", "  vowels = %w( a e i o u )\n\
    \  consonants = %w( b c d f g h j k l m n p q r s t v w x y z )\n  consonants.reverse_each.with_index\
    \ do |vowel, index|\n    next_consonant = consonants[index + 1] if index + 1 <\
    \ consonants.length\n    return '' if next_consonant.nil? || vowel == next_consonant\n\
    \    \n    range = if vowel == word[index]\n      vowels[word.rindex(vowel, index\
    \ + 1)..-1]\n    else\n      vowels[(word.rindex(vowel, index))..(word.rindex(vowel,\
    \ index + 1))]\n    end", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  vowel_index\
    \ = vowels.length\n  vowel_distances = []", "  \"Given a word, return closest\
    \ vowel to the right.\"\n  # +++your code here+++\n  if word == nil or word.size\
    \ == 0\n    return ''\n  vowels = 'aeiouAEIOU'\n  vowel_offset = nil\n  consonant_offset\
    \ = -1\n  consonant_limit = word.size - 1\n  consonant_limit = consonant_limit\
    \ - 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit\
    \ + 1\n  consonant_limit = consonant_limit + 1\n  consonant_limit = consonant_limit ",
  "  vowels = %w[a e i o u]\n  vowel_word = vowels.to_a.find {|v| word =~ /[#{v}]/}\
    \ unless vowels.nil?\n  vowel_word ? vowel_word : \"\"\nend", "  \n  return ''",
  "  vowels = {'a', 'e', 'i', 'o', 'u'}\n  word = word.downcase\n  return vowels.find\
    \ { |vowel| word[vowel.downcase.length..-1].include?(vowel) }\nend", "  # Return\
    \ the closest vowel between consonants in right side of the word.\n  vowels =\
    \ ['a', 'e', 'i', 'o', 'u']\n  result = ''\n  if word.count('a') == 1:\n    result\
    \ += 'a'\n  elif word.count('e') == 1:\n    result += 'e'\n  elif word.count('i')\
    \ == 1:\n    result += 'i'\n  elif word.count('o') == 1:\n    result += 'o'\n\
    \  elif word.count('u') == 1:\n    result += 'u'\n  else:\n    for char in word:\n\
    \      if char in vowels:\n        result += char\n  return result if result else\
    \ ''\n  ", "    word.scan(/[aeiou]/)\n    word.scan(/[aeiouy]/)\n    word.scan(/[bcdfghjklmnpqrstvwxyz]/)\n\
    \    vowel = word[/[aeiouy]/]\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n \
    \   </div>\n  </div>\n</body>", "    # implement here\n    vowels = \"aeiouAEIOU\"\
    \n    length = len(word)\n    i = length - 1\n    v = \"\"\n    \n    while i\
    \ >= 0 and i >= 0:\n        if word[i] in vowels:\n            v += word[i]\n\
    \        else:\n            if v == \"\":\n                return \"\"\n     \
    \       else:\n                i -= 1\n                break\n    return v", " \
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"\xE4\", \"\xF6\", \"\xFC\
    \"]\n  vowel_start = false\n  vowel_end = false\n  word = word.to_s\n  vowels.each\
    \ do |vowel|\n    if word[word.index(vowel)..-1] == vowel\n      vowel_start =\
    \ false\n      vowel_end = false\n      vowel_start = true\n      vowel_end =\
    \ true\n    end\n  end\n  if vowel_start && vowel_end\n    word = word[word.index(vowels.last)..-1]\n\
    \  end\n  return word\nend\nget_closest_vowel(\"uma\") # \"ua\"", "    vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n    \n    word = str(word).lower()\n    \n    if\
    \ not word:\n        return \"\"", "  return word.rindex(:consonant_a) + word.rindex(:consonant_b)\
    \ + word.rindex(:consonant_c) \nend\n</cell>\n<cell>", '    return "a" if word=="dog"
    else "e" if word=="cat" else "i" if word=="parrot" else "o"', "  vowels = [\u2018\
    a\u2019, \u2018e\u2019, \u2018i\u2019, \u2018o\u2019, \u2018u\u2019]\n  letters\
    \ = word.split(\u201C \u201C)\n  distance = 0\n  closest_vowel = \"\"\n  \n  #\
    \ You have to find the distance between the given letter and the closest vowel\n\
    \  # If there is a vowel at the end, then you go from right to left\n  # Otherwise,\
    \ from left to right\n  \n  letters.each do |letter|\n    distance += distance_between(letter,\
    \ closest_vowel)\n  end\n  return closest_vowel if distance == vowels.count\n\
    end", "    vowels = %W(a e i o u)\n    begining = word[0, word.length-1]\n   \
    \ end = word[word.length-1, word.length]\n    vowels_found = begining.downcase.split(//).map(&:downcase).reduce(:+).minus\
    \ vowels.minus end.downcase.split(//).map(&:downcase).reduce(:+) == 0\n    return\
    \ vowels_found ? word[word.length-1, word.length] : \"\"\nend\n</pre>\n      \
    \      </div>\n          \n          <aside class=\"notes\">\n              \n\
    \          </aside>\n        \n      </section>\n      \n      \n      <section>\n\
    \          \n          \n          <h2 id=\"ruby---regex\">Ruby Regex</h2>\n \
    \         \n          <p>\n          Ruby regular expressions are similar to JavaScript,\
    \ Perl, and Python regular expressions.\n          You might have noticed a big\
    \ difference in the syntax between the two, though \n          the syntax is similar.\n\
    \          </p>\n          \n          <p>\n          The key difference between\
    \ Ruby and other languages is that Ruby uses the\n          <strong>=~</strong>\
    \ operator to check a regular expression. \n          </p>\n          \n     \
    \     <p>\n          Ruby regular expressions use different syntax than JavaScript\
    \ \n          regular expressions do. They use <strong>?</strong> and <strong>*</strong>\
    \ to denote optional \n          and greedy matching. Ruby also uses <strong>\\\
    </strong> to denote a backslash. \n          </p>\n          \n          <p>\n\
    \          Ruby regular expressions also allow you to specify the beginning and\
    \ end of the expression.\n          </p>\n          \n          <p>\n        \
    \  To find all the occurences of a pattern in a string, you can use the <code>g</code>\
    \ \n          modifier:\n          </p>\n          \n          <pre class=\"ruby\"\
    >\nstring = \"The quick brown fox jumps over the lazy dog\"\np string.gsub(/\\\
    b(fox|foxy|foxy)\\b/, \"<span class=\\\"highlight\\\">$1</span>\")\n</pre>\n \
    \         \n          <p>\n          This would give the following output:\n \
    \         </p>\n          \n          <pre class=\"ruby\">\n<span class=\"highlight\"\
    >#&lt;NoMemoryError: failed to allocate memory&gt;</span>\n<span class=\"highlight\"\
    >#&lt;NoMemoryError: failed to allocate memory&gt;</span>\n<span class=\"highlight\"\
    >#&lt;NoMemoryError: failed to allocate memory&gt;</span>\n<span class=\"highlight\"\
    >#&lt;NoMemoryError: failed to allocate memory&gt;</span>\n<span class=\"highlight\"\
    >#&lt;NoMemoryError: failed to allocate memory&gt;</span>\n<span class=\"highlight\"\
    >#&lt;NoMemoryError: failed to allocate memory&gt;</span>\n<span class=\"highlight\"\
    >#&lt;NoMemoryError: failed to allocate memory&gt;</span>\n<span class=\"highlight",
  "  return \"??????\"\nend\n</cell>\n<code language=julia-0.4>\nget_closest_vowel(\"\
    puppy\")\n</cell>\n<code language=julia-0.4>\nget_closest_vowel(\"AaAaA\")\n</cell>\n\
    <code language=julia-0.4>", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  new_word\
    \ = word.downcase\n  i = 0\n  j = len(new_word)-1\n  closest = nil\n  \n  while(i\
    \ != j)\n    if(new_word[i] == vowels.first)\n      if(new_word[j] == vowels.last)\n\
    \        closest = new_word[i]\n        break\n      end\n    end\n    if(new_word[j]\
    \ == vowels.first)\n      if(new_word[i] == vowels.last)\n        closest = new_word[j]\n\
    \        break\n      end\n    end\n    i += 1\n    j += 1\n  end\n  return closest\n\
    end", "  return \"\"\nend", "  vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U']\n  consonants = 'bcdfghjklmnpqrstvwxyz'\n  letters = word.split('')\n\
    \  new_letters = letters.map do |c|\n    if c == consonants\n      vowels.include?(c)\
    \ ? 'a' : \"#{c}#{consonants}\"\n    elsif c.is_a?(String)\n      \"#{c}#{consonants}\"\
    \n    else\n      c\n    end\n  end\n  new_letters.join\nend\n</pre>\n<h2>Resources</h2>\n\
    <ul>\n  <li><a href=\"http://www.ruby-lang.org/en/documentation/quickstart/index.html\"\
    >Quickstart</a></li>\n</ul>\n</div>\n</div>\n<div id=\"validators\" class=\"section\"\
    >\n<h1>Validators</h1>\n<p>Validators are used by Forms to control the values\
    \ of form fields. \nA validator is typically used to control the content of fields.\
    \ \nThere are many types of validators available. \nTwo commonly used are StringValidator\
    \ (to control a String field), \nand RangeValidator (to control a numeric field).\
    \ The following \nexample shows how to use each type of validator:</p>\n<pre class=\"\
    prettyprint lang-js\">\n<span class=\"c\">// Define the field name</span>\nvar\
    \ fieldName = 'myField';", "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U']\n    vowel_count = {}\n    \n    for letter in word:\n        if letter\
    \ in vowels:\n            if letter not in vowel_count:\n                vowel_count[letter]\
    \ = 1\n            else:\n                vowel_count[letter] += 1", "  vowels\
    \ = ['a', 'e', 'i', 'o', 'u', 'y'] \n  vowels_count = word.length \n  \n  vowels_count\
    \ -= 1 if word.start_with?('e') && word.end_with?('i') else 0 \n  vowels_count\
    \ -= 1 if word.start_with?('i') && word.end_with?('o') else 0 \n  vowels_count\
    \ -= 1 if word.start_with?('o') && word.end_with?('u') else 0 \n  vowels_count\
    \ -= 1 if word.start_with?('u') && word.end_with?('a') else 0 \n  vowels_count\
    \ -= 1 if word.start_with?('a') && word.end_with?('e') else 0 \n  vowels_count\
    \ -= 1 if word.start_with?('e') && word.end_with?('o') else 0 \n  vowels_count\
    \ -= 1 if word.start_with?('o') && word.end_with?('u') else 0 \n  vowels_count\
    \ -= 1 if word.start_with?('u') && word.end_with?('a') else 0 ", "  vowels = \"\
    aeiouAEIOU\"\n  vowels = vowels.downcase # convert string into array\n  closest_to_right\
    \ = word.length - 1\n  # find closest vowel to right\n  closest_to_right = closest_to_right\
    \ - 1\n  while (closest_to_right >= 0 and closest_to_right < word.length)\n  \
    \  if vowels.include?(word[closest_to_right])\n      return word[closest_to_right]\n\
    \    end\n    closest_to_right -= 1\n  end\n  return \"\"\nend\nget_closest_vowel(\"\
    bat\") # => \"a\"", '  return "a"', "  vowels = %w(a e i o u)\n  word.scan(/([aeiou])[^aeiou]/)\n\
    \  word.scan(/([^aeiou])[aeiou]/)\n  \n  vowels.sort.each do |vowel|\n    if (word.index(vowel)\
    \ == 0 && (word.length + 1) > vowel.index(vowel)\n      word[vowel.index(vowel)..-1]\n\
    \    end\n  end\nend", "  vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"}\n\
    \  return \"\" if vowels.all? { |vowel| vowels.index(vowel) <= word.index(vowel)\
    \ + 1 }\n  \nend\n</cell>\n<cell>\nget_closest_vowel(\"Awesome\")\n</cell>\n<cell>",
  "  vowels = ['a','e','i','o','u','A','E','I','O','U']\n  vowel_counts = word.scan(/(^|\\\
    s)#{vowels.join('|')}(\\s|$)/).count\n  vowel_index = word.size-1 - (vowel_counts.sort.last-1)\n\
    \  return vowels[vowel_index]\nend", "  vowels = ['a','e','i','o','u']\n  consonants\
    \ = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z']\n\
    \  vowels_count = word.count vowels\n  if vowels_count > 0\n    vowels.each do\
    \ |vowel|\n      index = word.index(vowel) \n      distance = word.size - index\n\
    \      return word[index] if distance <= vowels_count\n    end\n  end\n  ''\n\
    end", "    vowels = %W(a e i o u) # %w is equivalent to re.findall('[a-z]', word)\n\
    \    vowels.each do |vowel|\n        if word.index(vowel) % 2 == 0\n         \
    \   return vowel\n        end\n    end\n    return \"\"\nend", "    \n    # YOUR\
    \ CODE HERE\n    return \n</cell>\n<cell>\nget_closest_vowel('pneumonia')\n</cell>\n\
    <text>\nImplement is_palindrome\nNext let's implement is_palindrome.", "  vowels\
    \ = ['a','e','i','o','u']\n  vowel_count = 0\n  \n  current_index = word.length\
    \ - 1\n  while current_index >= 0\n    vowel_count += 1 \n    current_index =\
    \ current_index - 1\n  \n  current_index = 0\n  while current_index <= word.length\n\
    \    if word[current_index] == 'e'\n      current_index += 1\n      break\n  \
    \  \n    if word[current_index] == 'a'\n      current_index += 1\n      break\n\
    \    \n    if word[current_index] == 'i'\n      current_index += 1\n      break\n\
    \    \n    if word[current_index] == 'o'\n      current_index += 1\n      break\n\
    \    \n    if word[current_index] == 'u'\n      current_index += 1\n      break\n\
    \    \n  current_index = word.length - 1\n  while current_index >= 0\n    if word[current_index]\
    \ == 'e'\n      current_index -= 1\n      break\n    \n    if word[current_index]\
    \ == 'a'\n      current_index -= 1\n      break\n    \n    if word[current_index]\
    \ == 'i'\n      current_index -= 1\n      break\n    \n    if word[current_index]\
    \ == 'o'\n      current_index -= 1\n      break\n    \n    if word[current_index]\
    \ == 'u'\n      current_index -= 1\n      break\n    \n    current_index = current_index\
    \ - 1\n  \n  if current_index == -1\n    return ''\n  \n  return vowels[vowel_count\
    \ % vowels.length] \nend", "  word=word.downcase\n  vowels=['a','e','i','o','u']\n\
    \  vowels.each{|v| return v if v==word[word.length..-1].to_s.downcase[0]}\n  ''\n\
    end", "    vowels = %w(a e i o u)\n    word = word.split(//)\n    word.each do\
    \ |word|\n        word.downcase.each do |letter|\n            if vowels.include?(letter)\n\
    \                puts letter\n                return letter\n            end\n\
    \        end\n    end\nend\nget_closest_vowel(\"codewarrior\") #=> o\nget_closest_vowel(\"\
    dabe\") #=> \nget_closest_vowel(\"apple\") #=> \nget_closest_vowel(\"python\"\
    ) #=> \nget_closest_vowel(\"codewarrior\") #=> o\nget_closest_vowel(\"dabe\")\
    \ #=> \nget_closest_vowel(\"apple\") #=> \nget_closest_vowel(\"python\") #=> \n\
    get_closest_vowel(\"codewarrior\") #=> o\nget_closest_vowel(\"dabe\") #=> \nget_closest_vowel(\"\
    apple\") #=> \nget_closest_vowel(\"python\") #=> \nget_closest_vowel(\"codewarrior\"\
    ) #=> o\nget_closest_vowel(\"dabe\") #=> \nget_closest_vowel(\"apple\") #=> \n\
    get_closest_vowel(\"python\") #=> \nget_closest_vowel(\"codewarrior\") #=> o\n\
    get_closest_vowel(\"dabe\") #=> \nget_closest_vowel(\"apple\") #=> \nget_closest_vowel(\"\
    python\") #=> \nget_closest_vowel(\"codewarrior\") #=> o\nget_closest_vowel(\"\
    dabe\") #=> \nget_closest_vowel(\"apple\") #=> \nget_closest_vowel(\"python\"\
    ) #=> \nget_closest_vowel(\"codewarrior\") #=> o\nget_closest_vowel(\"dabe\")\
    \ #=> \nget_closest_vowel(\"apple\") #=> \nget_closest_vowel(\"python\") #=> \n\
    get_closest_vowel(\"codewarrior\") #=> o\nget_closest_vowel(\"dabe\") #=> \nget_closest_vowel(\"\
    apple\") #=> \nget_closest_vowel(\"python\") #=> \nget_closest_vowel(\"codewarrior\"\
    ) #=> o\nget_closest_vowel(\"dabe\") #=> \nget_closest_vowel(\"apple\") #=> \n\
    get_closest_vowel(\"python\") #=> \nget_closest_vowel(\"codewarrior\") #=> o\n\
    get_closest_vowel(\"dabe\") #=> \nget_closest_vowel(\"apple\") #=> \nget_closest_vowel(\"\
    python\") #=> \nget_closest_vowel(\"codewarrior\") #=> o\nget_closest_vowel(\"\
    dabe\") #=> \nget_closest_vowel(\"apple\") #", "  vowels = %w(a e i o u)\n  \n\
    \  vowels.find { |vowel| vowels.index{|letter| letter == vowel}}\nend", "  word\
    \ = word.downcase\n  \n  return word.split('').each_with_index.reject { |_, i|\
    \ i == 0 || i == word.length }\n       .min_by { |_, i| word.rindex(\"aeiou\"\
    , 0, i) }[1]\nend", "    letters=[]\n    letter_count=0\n    word_length= len(word)\n\
    \    vowels=[\"a\",\"e\",\"i\",\"o\",\"u\",\"A\",\"E\",\"I\",\"O\",\"U\"]\n  \
    \  for letter in word:\n        if letter in vowels:\n            letter_count+=1\
    \ \n            letters.append(letter)\n        else:\n            if letter_count\
    \ > word_length-1:\n                break\n            if letter_count>word_length:\n\
    \                letter_count = 0 \n    \n    return \"\".join(letters)\nprint(get_closest_vowel(\"\
    happy\"))\nprint(get_closest_vowel(\"hAPpLe\"))\nprint(get_closest_vowel(\"HAPLey\"\
    ))\nprint(get_closest_vowel(\"abracadabra\"))\nprint(get_closest_vowel(\"aaaa\"\
    ))\nprint(get_closest_vowel(\"a\"))\nprint(get_closest_vowel(\"h\"))\nprint(get_closest_vowel(\"\
    z\"))\nprint(get_closest_vowel(\"zah\"))\nprint(get_closest_vowel(\"zahzah\"))\n\
    print(get_closest_vowel(\"zahzah\"))\nprint(get_closest_vowel(\"zahzaa\"))\nprint(get_closest_vowel(\"\
    zahza\"))\nprint(get_closest_vowel(\"zahz\"))\nprint(get_closest_vowel(\"zah\"\
    ))\nprint(get_closest_vowel(\"Zah\"))\nprint(get_closest_vowel(\"zaZaZa\"))\n\
    print(get_closest_vowel(\"zazaZa\"))\nprint(get_closest_vowel(\"zazaza\"))\nprint(get_closest_vowel(\"\
    zaZaZ\"))\nprint(get_closest_vowel(\"za\"))\nprint(get_closest_vowel(\"z\"))\n\
    print(get_closest_vowel(\"Z\"))\nprint(get_closest_vowel(\"zZ\"))\nprint(get_closest_vowel(\"\
    zZZ\"))\nprint(get_closest_vowel(\"zZZz\"))\nprint(get_closest_vowel(\"zZZzZ\"\
    ))\nprint(get_closest_vowel(\"zZZzZZ\"))\nprint(get_closest_vowel(\"zZZzZZz\"\
    ))\nprint(get_closest_vowel(\"zZZzZZzZ\"))\nprint(get_closest_vowel(\"zZZzZZzZZ\"\
    ))\nprint(get_closest_vowel(\"zZZzZZzZZz\"))\nprint(get_closest_vowel(\"zZZzZZzZZzZ\"\
    ))\nprint(get_closest_vowel(\"zZZzZZzZZzZZ\"))\nprint(get_closest_vowel(\"zZZzZZzZZzZZz\"\
    ))\nprint(get_closest_vowel(\"zZZzZZzZZzZZzZ\"))\nprint(get_closest_vowel(\"zZZzZZzZZzZZzZZ\"\
    ))\nprint(get_closest_vowel(\"zZZzZZz", "  vowels = ['a','e','i','o','u']\n  word_list\
    \ = word.split(//) #convert string to array\n  positions = []\n  \n  vowels.each\
    \ do |vowel|\n    if vowel.include?(word_list[-1]) #get last item of the array\
    \ and check if it contains the vowel\n      positions << word_list[-1].length\
    \ #save index of vowel\n      word_list.pop #if we found the vowel, remove the\
    \ last item of the array\n      break\n    end\n  end\n  return positions.max_by\
    \ { |position| position} \nend\n</cell>\n<cell>", "  vowels = \"aeiouAEIOU\"\n\
    \  vowels.each do |vowel|\n    idx = word.index(vowel)\n    if idx && idx > word.size\
    \ - 1\n      idx = word.index(vowel, idx + 1)\n    end\n    return vowel if idx\n\
    \  end\nend", "  vowels = ['a','e','i','o','u']\n  vowels.each do |v|\n    break\
    \ if word =~ /v/\n    break if word =~ /#{v}/\n  end\n  return '' if word.count(\"\
    a\") < word.count(\"e\") || word.count(\"i\") < word.count(\"o\") || word.count(\"\
    u\") < word.count(\"a\")\n  return '' if word.count(\"a\") < word.count(\"e\"\
    ) || word.count(\"i\") < word.count(\"o\") || word.count(\"u\") < word.count(\"\
    i\")\n  return '' if word.count(\"a\") < word.count(\"e\") || word.count(\"i\"\
    ) < word.count(\"o\") || word.count(\"u\") < word.count(\"o\")\n  return '' if\
    \ word.count(\"a\") < word.count(\"e\") || word.count(\"i\") < word.count(\"o\"\
    ) || word.count(\"u\") < word.count(\"u\")\n  word.downcase.split(//).each do\
    \ |letter|\n    return letter if vowels.include?(letter)\n  end\nend", "  consonant_list\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n  vowel_list = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n  closest_vowel = \"\"\n  word_length = len(word)\n\
    \  for each_consonant in consonant_list:\n    current_index = word.index(each_consonant)\n\
    \    if current_index >= word_length-1:\n      break\n    current_index -= 1\n\
    \    for each_vowel in vowel_list:\n      current_word_index = current_index -\
    \ each_vowel\n      if current_index >= word_length-1:\n        break\n      current_vowel_index\
    \ = current_index - current_word_index\n      if current_vowel_index < 0:\n  \
    \      break\n      current_vowel = word[current_vowel_index]\n      if current_vowel\
    \ in vowel_list:\n        closest_vowel = current_vowel\n        break\n  return\
    \ closest_vowel\nprint(get_closest_vowel(\"dabba\")) # Output should be vowel\
    \ b \nprint(get_closest_vowel(\"dabbaab\")) # Output should be vowel b \nprint(get_closest_vowel(\"\
    dabbaazz\")) # Output should be vowel b\nprint(get_closest_vowel(\"dabbba\"))\
    \ # Output should be vowel b\nprint(get_closest_vowel(\"dabbbaab\")) # Output\
    \ should be vowel b\nprint(get_closest_vowel(\"dabbbaazz\")) # Output should be\
    \ vowel b\nprint(get_closest_vowel(\"abba\")) # Output should be vowel a\nprint(get_closest_vowel(\"\
    abbaab\")) # Output should be vowel a\nprint(get_closest_vowel(\"abbaazz\")) #\
    \ Output should be vowel a\nprint(get_closest_vowel(\"abbba\")) # Output should\
    \ be vowel a\nprint(get_closest_vowel(\"abbbaab\")) # Output should be vowel a\n\
    print(get_closest_vowel(\"abbbaazz\")) # Output should be vowel a\nprint(get_closest_vowel(\"\
    yabba\")) # Output should be vowel y\nprint(get_closest_vowel(\"yabbaab\")) #\
    \ Output should be vowel y\nprint(get_closest_vowel(\"yabbaazz\")) # Output should\
    \ be vowel y\nprint(get_closest_vowel(\"yabbba\")) # Output should be vowel y\n\
    print(get_closest_vowel(\"yabbbaab\")) # Output should be vowel y\nprint(get_closest_vowel(\"\
    yabbbaazz\")) # Output should be vowel y\nprint(get_closest_vowel(\"yabbbba\"\
    )) # Output should be vowel y\nprint(get_closest_vowel(\"yabbbbaab\")) # Output\
    \ should be vowel y\nprint(get_closest_", "  vowels = ('a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U')\n  vowels_count = vowels.count\n  result = ''\n  i\
    \ = 0\n  while i < word.length\n    char = word.slice(i,i+1)\n    if vowels_count(char)\
    \ == 1\n      result += char\n      i += 1\n    else \n      if vowels_count(char)\
    \ == 2\n        char.upcase!\n        result += char\n        i += 1\n      else\
    \ \n        if vowels_count(char) == 3\n          char.upcase!\n          char.upcase!\n\
    \          result += char\n          i += 1\n        end\n      end\n    end\n\
    \  end\n  return result\nend\n \nassert_equals(get_closest_vowel('Celestia'),\
    \ \"\")\nassert_equals(get_closest_vowel(\"Celestia\"), \"C\")\nassert_equals(get_closest_vowel(\"\
    Iphone\"), \"O\")\nassert_equals(get_closest_vowel(\"a\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    ab\"), \"a\")\nassert_equals(get_closest_vowel(\"ab\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    aB\"), \"a\")\nassert_equals(get_closest_vowel(\"iphone\"), \"o\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    aBbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"\
    abbey\"), \"a\")\nassert_equals(get_closest_vowel(\"abbey", "    vowels = [\"\
    a\", \"e\", \"i\", \"o\", \"u\"]\n    vowel_count = word.count(\"a\") + word.count(\"\
    e\") + word.count(\"i\") + word.count(\"o\") + word.count(\"u\")\n    if vowel_count\
    \ > 4:\n        return \"\"\n    if vowel_count < 3:\n        return \"\"\n  \
    \  if word[-1] not in vowels:\n        vowels.insert(0, word[-1])\n    vowel_distance\
    \ = vowel_count - word.count(\"aeiou\")\n    vowel_diff = vowels[-1] - word[-1]\n\
    \    return vowels[abs(vowel_distance) - abs(vowel_diff)]", "  vowels = \"aeiouAEIOU\"\
    \n  consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n  consonants_rev\
    \ = consonants.reverse\n  vowels_rev = vowels.reverse\n  result = \"\"\n  last_consonant_index\
    \ = -1\n  last_vowel_index = -1\n  last_consonant_index2 = -1\n  last_vowel_index2\
    \ = -1\n  consonant_index = consonants.index(word[-2])\n  vowel_index = vowels.index(word[-1])\n\
    \  consonant_index2 = consonants.index(word[-3])\n  vowel_index2 = vowels.index(word[-2])\n\
    \  consonant_index3 = consonants.index(word[-4])\n  vowel_index3 = vowels.index(word[-3])\n\
    \  consonant_index4 = consonants.index(word[-5])\n  vowel_index4 = vowels.index(word[-4])\n\
    \  consonant_index5 = consonants.index(word[-6])\n  vowel_index5 = vowels.index(word[-5])\n\
    \  consonant_index6 = consonants.index(word[-7])\n  vowel_index6 = vowels.index(word[-6])\n\
    \  consonant_index7 = consonants.index(word[-8])\n  vowel_index7 = vowels.index(word[-7])\n\
    \  consonant_index8 = consonants.index(word[-9])\n  vowel_index8 = vowels.index(word[-8])\n\
    \  consonant_index9 = consonants.index(word[-10])\n  vowel_index9 = vowels.index(word[-9])\n\
    \  consonant_index10 = consonants.index(word[-11])\n  vowel_index10 = vowels.index(word[-10])\n\
    \  consonant_index11 = consonants.index(word[-12])\n  vowel_index11 = vowels.index(word[-11])\n\
    \  consonant_index12 = consonants.index(word[-13])\n  vowel_index12 = vowels.index(word[-12])\n\
    \  consonant_index13 = consonants.index(word[-14])\n  vowel_index13 = vowels.index(word[-13])\n\
    \  consonant_index14 = consonants.index(word[-15])\n  vowel_index14 = vowels.index(word[-14])\n\
    \  consonant_index15 = consonants.index(word[-16])\n  vowel_index15 = vowels.index(word[-15])\n\
    \  consonant_index16 = consonants.index(word[-17])\n  vowel_index16 = vowels.index(word[-16])\n\
    \  consonant_index17 = consonants.index(word", "  return ''\nend", " \nend = \"\
    \"\n \nbegin = word.rindex(\"a\") + 1\nend = word.rindex(\"e\")\n \nwhile begin\
    \ < end do\n \n    if word.slice!(begin..end).include?(\"A\"..\"Z\")\n \n    \
    \    begin = word.rindex(\"a\") + 1\n        end = word.rindex(\"e\")\n \n   \
    \ end\nend\n \nreturn word\nend", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n    vowels.each { |vowel| word.gsub!(vowel, \"\") }\n    word.split(\"\"\
    ).map { |char| char }.uniq.each { |char| word.gsub!(char, \"\") }\n    word =\
    \ word.gsub(/[aeiou]/, \"\")\n    vowel = word.length > 0 ? vowels.find { |vowel|\
    \ word.include?(vowel) } : \"\"\n    return vowel\nend", "  vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n  vowel_count = 0\n  consonant_count = word.count('c') + 1\n\
    \  vowel_count = vowel_count + consonant_count * 2\n  vowel_count = vowel_count\
    \ - 1\n  vowel_count = vowel_count - word.count('a') + word.count('e') + word.count('i')\
    \ + word.count('o') + word.count('u')\n  vowel_count = vowel_count - word.count('c')\n\
    \  vowel_count = vowel_count - 1\n  vowel_count = vowel_count - 1\n  closest_vowel_dist\
    \ = word.count('a') + word.count('e') + word.count('i') + word.count('o') + word.count('u')\n\
    \  closest_vowel_dist = closest_vowel_dist - word.count('c') + word.count('e')\
    \ + word.count('i') + word.count('o') + word.count('u') + word.count('a')\n  closest_vowel_dist\
    \ = closest_vowel_dist - word.count('c')\n  closest_vowel_dist = closest_vowel_dist\
    \ - 1\n  closest_vowel_dist = closest_vowel_dist - word.count('a')\n  closest_vowel_dist\
    \ = closest_vowel_dist - word.count('e') + word.count('i') + word.count('o') +\
    \ word.count('u') + word.count('a') + word.count('e') + word.count('i') + word.count('o')\
    \ + word.count('u')\n  closest_vowel_dist = closest_vowel_dist - 1\n  closest_vowel_dist\
    \ = closest_vowel_dist - word.count('i') + word.count('o') + word.count('u') +\
    \ word.count('a')\n  closest_vowel_dist = closest_vowel_dist - 1\n  closest_vowel_dist\
    \ = closest_vowel_dist - word.count('o') + word.count('u') + word.count('a')\n\
    \  closest_vowel_dist = closest_vowel_dist - 1\n  closest_vowel_dist = closest_vowel_dist\
    \ - word.count('e') + word.count('i') + word.count('o') + word.count('u') + word.count('a')\n\
    \  closest_vowel_dist = closest_vowel_dist - 1\n  closest_vowel_dist = closest_vowel_dist\
    \ - word.count('e') + word.count('i') + word.count('o') + word.count('u') + word.count('a')\n\
    \  closest_vowel_dist = closest_vowel_dist - 1\n  closest_vowel_dist = closest_vowel_dist\
    \ - word.count('e') + word.count('i') + word.count('o') + word.count('u') + word.count('a')\n\
    \  closest_vowel_dist = closest_vowel_dist - 1\n  closest_vowel_dist = closest_vowel_dist\
    \ - ", "  return 'a' if word.length >= 3 && word[word.length-1].to_s.include?(\"\
    a\") \n    || 'e' if word.length >= 3 && word[word.length-1].to_s.include?(\"\
    e\") \n    || 'i' if word.length >= 3 && word[word.length-1].to_s.include?(\"\
    i\") \n    || 'o' if word.length >= 3 && word[word.length-1].to_s.include?(\"\
    o\") \n    || 'u' if word.length >= 3 && word[word.length-1].to_s.include?(\"\
    u\") \n    || ''\nend\n</cell>\n<cell>", "    return \"\"\n</code>\n<|/ q tags=python-3.x,python\
    \ dscore=1 |>\n<| c |>\nIf your code works, post it on [codereview](http://codereview.stackexchange.com/)\
    \ for improvements\n<|/ c |>\n<| c |>\nPlease explain what problem(s) you are\
    \ having with the code you posted.\n<|/ c |>\n<| c |>\nMy code won't work. I am\
    \ not sure how to get it so that it works how I want it to\n<|/ c |>\n<| a dscore=0\
    \ |>\nThis should be pretty straightforward.  You need to figure out what the\
    \ start and end indices are for the word you are searching.  Then, just use those\
    \ indices to get a slice of the word to search.\n<code>", "  vowels = [\"a\",\"\
    e\",\"i\",\"o\",\"u\"]\n  \n  word.upcase!", "  vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n  word.gsub(/[aeiou]/,\"\").gsub(/[b-z]/,\"\").gsub(/[a-y]/,\"\
    \").gsub(/[!^a-z]/,\"\").each do |vowel|\n    if vowels.index(vowel) != -1 &&\
    \ vowels.index(vowel) != word.index(\"a\") + 1 && vowels.index(vowel) != word.index(\"\
    b\") - 1 && vowels.index(vowel) != word.index(\"c\") + 1 && vowels.index(vowel)\
    \ != word.index(\"d\") - 1 && vowels.index(vowel) != word.index(\"e\") - 1 &&\
    \ vowels.index(vowel) != word.index(\"f\") - 1 && vowels.index(vowel) != word.index(\"\
    g\") - 1 && vowels.index(vowel) != word.index(\"h\") - 1 && vowels.index(vowel)\
    \ != word.index(\"i\") - 1 && vowels.index(vowel) != word.index(\"j\") - 1 &&\
    \ vowels.index(vowel) != word.index(\"k\") - 1 && vowels.index(vowel) != word.index(\"\
    l\") - 1 && vowels.index(vowel) != word.index(\"m\") - 1 && vowels.index(vowel)\
    \ != word.index(\"n\") - 1 && vowels.index(vowel) != word.index(\"o\") - 1 &&\
    \ vowels.index(vowel) != word.index(\"p\") - 1 && vowels.index(vowel) != word.index(\"\
    q\") - 1 && vowels.index(vowel) != word.index(\"r\") - 1 && vowels.index(vowel)\
    \ != word.index(\"s\") - 1 && vowels.index(vowel) != word.index(\"t\") - 1 &&\
    \ vowels.index(vowel) != word.index(\"u\") - 1 && vowels.index(vowel) != word.index(\"\
    v\") - 1 && vowels.index(vowel) != word.index(\"w\") - 1 && vowels.index(vowel)\
    \ != word.index(\"x\") - 1 && vowels.index(vowel) != word.index(\"y\") - 1 &&\
    \ vowels.index(vowel) != word.index(\"z\") - 1\n      return vowel\n    end\n\
    \  end\n  return \"\"\nend\n</pre>\n</div>\n</div>\n</div>\n<p>\nNow, write a\
    \ function that takes an array of words and returns a list of their vowel count\n\
    </p>\n<div class=\"solution\">\n<pre>\n<span class=\"comment\"># Write your function\
    \ here</span>", "  vowels = \"aeiouAEIOU\"\n  return vowels.find {|vowel| vowel.downcase\
    \ == word.downcase }\nend\n</cell>\n<text>\nQ6\nImplement the function which counts\
    \ the frequency of the vowel present in the given string. You can assume that\
    \ the given string contains English letter only.", "  vowel = nil\n  vowel_distance\
    \ = 0\n  word.chars.reverse_each.with_index do |char, index|\n    if char.upcase\
    \ == \"A\" || char.upcase == \"E\" || char.upcase == \"I\" || char.upcase == \"\
    O\" || char.upcase == \"U\"\n      vowel = char\n      vowel_distance = index\n\
    \    end\n  end\n  return vowel if vowel && vowel_distance > 0\n  return \"\"\n\
    end", "  return \nend\n</cell>\n<code language=julia-0.4>\nget_closest_vowel(\"\
    apple\")\n</cell>\n<code language=julia-0.4>\nget_closest_vowel(\"BANANA\")\n\
    </cell>\n<code language=julia-0.4>\nget_closest_vowel(\"pig\")\n</cell>\n<code\
    \ language=julia-0.4>\nget_closest_vowel(\"ABba\")\n</cell>\n<code language=julia-0.4>\n\
    get_closest_vowel(\"EAT\")\n</cell>\n<code language=julia-0.4>", "  vowel_positions\
    \ = [\n    [0, 5],\n    [6, 10],\n    [11, 15],\n    [16, 20],\n    [21, 25],\n\
    \    [0, 2],\n  ]\n  consonant_positions = [\n    [0, 1],\n    [2, 3],\n    [4,\
    \ 5],\n    [6, 7],\n    [8, 9],\n    [10, 11],\n    [12, 13],\n    [14, 15],\n\
    \    [16, 17],\n  ]\n  closest_position = 0\n  closest_vowel = ''\n  consonant_index\
    \ = 0\n  vowel_index = 0\n  consonant_positions_count = consonant_positions.size\
    \ - 1\n  vowel_positions_count = vowel_positions.size - 1\n  while consonant_positions_count\
    \ >= 0 and vowel_positions_count >= 0:\n    consonant_index = consonant_positions[consonant_positions_count]\n\
    \    vowel_index = vowel_positions[vowel_positions_count]\n    if word[consonant_index]\
    \ >= 'a' and word[consonant_index] <= 'z'\n      vowel_positions[vowel_positions_count]\
    \ += 1\n      consonant_positions_count -= 1\n    elif word[consonant_index] >=\
    \ 'A' and word[consonant_index] <= 'Z'\n      vowel_positions[vowel_positions_count]\
    \ += 1\n      consonant_positions_count -= 1\n    \n    consonant_index += 1\n\
    \    if consonant_index == consonant_positions[consonant_positions_count]\n  \
    \    vowel_positions_count -= 1\n      consonant_positions_count -= 1\n    end\n\
    \  end\n  return closest_vowel\nend", "    # write your code in Ruby\nend", " \
    \   \n    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowel_count = {}\n    for i\
    \ in vowels:\n        vowel_count[i] = word.count(i)\n    # find the vowel from\
    \ the right side that is closest to consonant\n    closest_vowel = ''\n    closest_distance\
    \ = 1000\n    for i in vowels:\n        distance = abs(vowel_count[i] - len(word))\n\
    \        if distance < closest_distance:\n            closest_distance = distance\n\
    \            closest_vowel = i\n    return closest_vowel", "  vowels = %w{a e\
    \ i o u}\n  word.scan(/[aeiou]/)\n  vowels.find_all {|v| v <= word and word <=\
    \ \"u\" }.join(\"\") rescue \"\"\nend", "    vowels = ['a', 'e', 'i', 'o', 'u']\n\
    \    return vowels[word.rindex('a'):word.rindex('a') + len(word) - len(vowels)]\n\
    <|/ file source=github |>\n<| c |>\nWhat happens if the word is just 'a'? Is that\
    \ in the list, or does it need to return 'a'? It sounds like you need to handle\
    \ that case separately, just like you would handle 'aeiou'.\n<|/ c |>\n<| c |>\n\
    Thanks for the suggestions. I modified the code so that if the word is just 'a',\
    \ the function returns 'a'.\n<|/ c |>\n<| a tags=python-3.x,python |>\nYou can\
    \ try the following approach:\n<code>", "  vowels = ['a', 'e', 'i', 'o', 'u']\n\
    \  \n  # Your code goes here\n  vowels.each do |v|\n    if word.rindex(v) < word.size\
    \ - 1\n      break\n    end\n  end\n  \n  return \"\" if vowels.include? word[-1]\n\
    \  \n  \nend", "    # your code here\n    return \"\"\n</cell>\n<cell>\nget_closest_vowel(\"\
    hello\")\n</cell>\n<text>\nGreat Job!", "  # Your code here\n  vowels = (\"a\"\
    ,\"e\",\"i\",\"o\",\"u\")\n  left_index = -1\n  right_index = len(word)\n  for\
    \ i in vowels:\n    index = word.index(i)\n    if index >= right_index or index\
    \ < left_index:\n      continue\n    else:\n      left_index = index\n      right_index\
    \ = index\n  if left_index == -1:\n    return \"\"\n  if right_index == -1:\n\
    \    return \"\"\n  for i in range(left_index, right_index):\n    if word[i] ==\
    \ \"a\" or word[i] == \"e\" or word[i] == \"i\" or word[i] == \"o\" or word[i]\
    \ == \"u\":\n      return i", "  vowel_consonant_pairs = ['a','o','u','i','e']\n\
    \  word.downcase!\n  word.tr!('aeiouAEIOU','')\n  vowel_index = 0\n  vowel_consonant_pairs.each_with_index\
    \ do |vowel,i|\n    vowel_consonant_pairs[i+1] = vowel if word.include? vowel\n\
    \  end\n  consonant_index = (vowel_consonant_pairs.length-1)\n  word.length.times\
    \ do |i|\n    vowel_consonant_pairs[consonant_index].include? word[vowel_index]\
    \ ? vowel_index += 1  : consonant_index -= 1\n  end\n  vowel_consonant_pairs[vowel_index]\
    \ || ''\nend", "  vowel = nil\n  vowels = %w{a e i o u}\n  vowels.each do |vowel|\n\
    \    idx = word.rindex(vowel)\n    if idx > -1 && (word.rindex(vowel + 1, idx)\
    \ - idx) < vowel.length\n      vowel = vowel\n      break\n    end\n  end\n  if\
    \ vowel.nil?\n    vowel = nil\n  end\n  vowel\nend\nget_closest_vowel(\"dwarf\"\
    )", "    vowels = (\"a\",\"e\",\"i\",\"o\",\"u\")\n    vowel_chars = []\n    vowel_chars.extend(vowels)\n\
    \    vowel_chars.extend(['y','w'])\n    vowel_chars.extend(['c','t','r','l','d'])\n\
    \    for vowel in vowel_chars:\n        index = word[::-1].rfind(vowel)\n    \
    \    if index != -1:\n            return word[index+len(vowel):]\n    return \"\
    \"\nprint(get_closest_vowel(\"abacabad\"))\nprint(get_closest_vowel(\"a\"))\n\
    print(get_closest_vowel(\"dog\"))\nprint(get_closest_vowel(\"cat\"))\nprint(get_closest_vowel(\"\
    abacabada\"))\nprint(get_closest_vowel(\"abacaba\"))", "    return \"YOUR_ANSWER_HERE\"\
    \nprint get_closest_vowel(\"good\")\nprint get_closest_vowel(\"word\")\nprint\
    \ get_closest_vowel(\"Happy\")\nprint get_closest_vowel(\"happy\")\nprint get_closest_vowel(\"\
    Hello\")\nprint get_closest_vowel(\"word\")\nprint get_closest_vowel(\"aardvark\"\
    )\nprint get_closest_vowel(\"eight\")\nprint get_closest_vowel(\"seven\")\nprint\
    \ get_closest_vowel(\"eight\")\nprint get_closest_vowel(\"five\")\nprint get_closest_vowel(\"\
    seven\")\nprint get_closest_vowel(\"six\")\nprint get_closest_vowel(\"seven\"\
    )\nprint get_closest_vowel(\"three\")\nprint get_closest_vowel(\"three\")\nprint\
    \ get_closest_vowel(\"nine\")\nprint get_closest_vowel(\"two\")\nprint get_closest_vowel(\"\
    three\")\nprint get_closest_vowel(\"one\")\nprint get_closest_vowel(\"zero\")\n\
    print get_closest_vowel(\"one\")\nprint get_closest_vowel(\"two\")\nprint get_closest_vowel(\"\
    seven\")\nprint get_closest_vowel(\"five\")\nprint get_closest_vowel(\"seven\"\
    )\nprint get_closest_vowel(\"four\")\nprint get_closest_vowel(\"two\")\nprint\
    \ get_closest_vowel(\"three\")\nprint get_closest_vowel(\"two\")\nprint get_closest_vowel(\"\
    one\")\nprint get_closest_vowel(\"nine\")\nprint get_closest_vowel(\"eight\")\n\
    print get_closest_vowel(\"seven\")\nprint get_closest_vowel(\"eight\")\nprint\
    \ get_closest_vowel(\"four\")\nprint get_closest_vowel(\"two\")\nprint get_closest_vowel(\"\
    three\")\nprint get_closest_vowel(\"two\")\nprint get_closest_vowel(\"one\")\n\
    print get_closest_vowel(\"nine\")\nprint get_closest_vowel(\"four\")\nprint get_closest_vowel(\"\
    five\")\nprint get_closest_vowel(\"five\")\nprint get_closest_vowel(\"one\")\n\
    print get_closest_vowel(\"one\")\nprint get_closest_vowel(\"nine\")\nprint get_closest_vowel(\"\
    seven\")\nprint get_closest_vowel(\"four\")\nprint get_closest_vowel(\"two\")\n\
    print get_closest_vowel(\"one\")\nprint get_closest_vowel(\"eight\")\nprint get_closest_vowel(\"\
    five\")\nprint get_closest_vowel(\"four\")\nprint get_closest_vowel(\"one\")\n\
    print get_closest_vowel(\"two\")\nprint get_closest_vowel(\"one\")\nprint get_closest_vowel(\"\
    one\")\nprint get_closest_vowel(\"nine\")\nprint get_closest_", "    vowels =\
    \ ['a', 'e', 'i', 'o', 'u']\n    vowels_in_word = []\n    vowels_in_word = []\n\
    \    vowels_in_word = []\n    if word[-5] != 'e':\n        word = word[0:-5]\n\
    \    for vowel in vowels:\n        if word.endswith(f'#{vowel}'):\n          \
    \  vowels_in_word.append(vowel)\n    if len(vowels_in_word) > 1:\n        closest_vowel_in_word\
    \ = \"\"\n        for vowel in vowels_in_word:\n            word = word.replace(f\"\
    #{vowel}\", \"\")\n            if len(word) > 0:\n                word = word[0]\n\
    \            if word == vowel:\n                closest_vowel_in_word = vowel\n\
    \                break\n            elif word != vowel and word == closest_vowel_in_word:\n\
    \                return \"\"\n            else:\n                continue\n  \
    \      return closest_vowel_in_word\n    else:\n        return vowels_in_word[0]",
  "    vowels = (\"a\",\"e\",\"i\",\"o\",\"u\")\n    vowels_length = len(vowels)\n\
    \    result = []\n    left_index = 0\n    right_index = 0\n    \n    left_consonant\
    \ = word[0]\n    right_consonant = word[-1]\n    \n    for index in range(len(word)-1):\n\
    \        cur_word = word[index]\n        cur_left_consonant = cur_word[0]\n  \
    \      cur_right_consonant = cur_word[-1]\n        \n        if cur_left_consonant\
    \ in vowels and cur_right_consonant in vowels:\n            left_index = index\n\
    \            right_index = index\n            break\n        \n        if cur_left_consonant\
    \ == cur_right_consonant:\n            if cur_left_consonant == \"a\" and cur_right_consonant\
    \ == \"e\":\n                left_index = index\n                right_index =\
    \ index\n                break\n            elif cur_left_consonant == \"e\" and\
    \ cur_right_consonant == \"a\":\n                left_index = index\n        \
    \        right_index = index\n                break\n            elif cur_left_consonant\
    \ == \"i\" and cur_right_consonant == \"o\":\n                left_index = index\n\
    \                right_index = index\n                break\n            elif\
    \ cur_left_consonant == \"o\" and cur_right_consonant == \"i\":\n            \
    \    left_index = index\n                right_index = index\n               \
    \ break\n            elif cur_left_consonant == \"u\" and cur_right_consonant\
    \ == \"a\":\n                left_index = index\n                right_index =\
    \ index\n                break\n            elif cur_left_consonant == \"u\" and\
    \ cur_right_consonant == \"e\":\n                left_index = index\n        \
    \        right_index = index\n                break\n    \n    if left_index !=\
    \ 0 and left_index != len(word)-1 and right_index != 0 and right_index != len(word)-1:\n\
    \        left_index = left_index-1\n        right_index = right_index+1\n    \
    \    \n        if left_index < right_index:\n            result.append(vowels[left_index])\n\
    \            result.append(vowels[right_index])\n        else:\n            result.append(vowels[left_index])\n\
    \            result.append(vowels[right_index+1])\n    else:\n        result.append(\"\
    \")\n        result.append(\"\")\n    \n    if left_index == 0:\n        result[0]\
    \ = result[0]+vowels[0]\n        result[1] = result[1]+vowels[1]\n    elif left_index\
    \ == len(word)-1:\n        result[0] = result[0]+vowels[len(vowels)-1]\n     \
    \   result[1] = result[1]+vowels[len(vowels)-2]\n    \n    if right_index == 0:\n\
    \        result[len(result)-1] = result[len(result)-1]+vowels[0]\n        result[len(result)-2]\
    \ = result[len(result)-2]+vowels[1]\n    elif right_index == len(word)-1:\n  \
    \      result[len(result)-1] = ", "    # code goes here\nend\n</pre>\n<p>&nbsp;</p>\n\
    <p><%= image_tag(\"vowel_1.jpg\", :alt => \"Solution\") %></p>\n<p>&nbsp;</p>\n\
    <h3 id=\"part-3-recursion\">Part 3: Recursion</h3>\n<p>\n  Now write a recursive\
    \ function called <code>get_closest_vowels</code> that returns the closest vowel\
    \ to a given word.\n</p>\n<p>&nbsp;</p>\n<p><%= image_tag(\"vowel_2.jpg\", :alt\
    \ => \"Solution\") %></p>\n<p>&nbsp;</p>\n<p>\n  <b>Example 1:</b>\n</p>\n<pre>",
  "    # write your code here\n    result=''\n    if word.count('a') == 0:\n     \
    \   return word\n    for i in range(0,len(word)-1,1):\n        if word[i:i+2].upper()\
    \ == 'A':\n            return word\n        else:\n            return result\n\
    get_closest_vowel('aba')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_closest_vowel('cab')\nget_closest_vowel('cab')\n\
    get_closest_vowel('cab')\nget_", "  return \"\"\nend\n</cell>\n<cell>\nget_closest_vowel(\"\
    Aoei\")\n</cell>\n<cell>\nget_closest_vowel(\"Etio\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Iaar\")\n</cell>\n<cell>\nget_closest_vowel(\"Oaai\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Hauu\")\n</cell>\n<cell>\nget_closest_vowel(\"Zaaa\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Ieoo\")\n</cell>\n<cell>\nget_closest_vowel(\"Aooe\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Aooei\")\n</cell>\n<cell>\nget_closest_vowel(\"Aooei\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Eoau\")\n</cell>\n<cell>\nget_closest_vowel(\"Zaai\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Ieoo\")\n</cell>\n<cell>\nget_closest_vowel(\"Oaaa\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Oaaa\")\n</cell>\n<cell>\nget_closest_vowel(\"Oaaa\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Aooei\")\n</cell>\n<cell>\nget_closest_vowel(\"Aooei\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Aooei\")\n</cell>\n<cell>\nget_closest_vowel(\"Eoau\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Zaai\")\n</cell>\n<cell>\nget_closest_vowel(\"Ieoo\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Eoau\")\n</cell>\n<cell>\nget_closest_vowel(\"Zaai\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Eoau\")\n</cell>\n<cell>\nget_closest_vowel(\"Zaai\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Eoau\")\n</cell>\n<cell>\nget_closest_vowel(\"Zaai\")\n</cell>\n<cell>\nget_closest_vowel(\"\
    Oaaa\")\n</cell>\n<cell>\nget_closest_vowel(\"O", "  vowels = {'a', 'e', 'i',\
    \ 'o', 'u'}\n  count = 0\n  vowel_index = 0\n  vowels_len = length(vowels)\n \
    \ consonant_index = 0\n  consonant_len = length(consonants)\n  while consonant_index\
    \ < consonant_len do\n    if word[consonant_index] =~ vowels[vowel_index] then\n\
    \      count += 1\n      consonant_index += 1\n    else\n      if count == vowels_len\
    \ then\n        vowel_index += 1\n        count = 0\n      else\n        count\
    \ -= 1\n      end\n    end\n  end\n  result = word[consonant_index..-1]\n  return\
    \ result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>\nvowels =\
    \ ['a','e','i','o','u','y']\nvowel_count = vowels.count", '  return ""', "  #\
    \ your code here\nend", "    # write your code here\n    vowels = 'aeiouAEIOU'\n\
    \    letters = \"\"\n    for i in range(len(word)):\n        if word[i] in vowels:\n\
    \            letters += word[i : i+1] + \" \"\n    return letters", "  vowel =\
    \ 'aeiouAEIOU'\n  consonants = 'bcdfghjklmnpqrstvwxyz'\n  return word.chars.reject\
    \ { |char| vowel.include? char }.\n            sort.last.upcase.\n           \
    \ chars.reject { |char| consonants.include? char }.\n            join\nend", " \
    \ vowels = ['a', 'e', 'i', 'o', 'u']\n  first_letter = word[-4..-1]\n  last_letter\
    \ = word[-2..-1]\n  if first_letter =~ /[aeiou]/i\n    index = vowels.index first_letter\n\
    \  end\n  if last_letter =~ /[aeiou]/i\n    index = vowels.index last_letter\n\
    \  end\n  if index <> nil\n    return vowels[index]\n  end\n  return \"\"\nend\n\
    </cell>\n<code language=julia-1.0>\nget_closest_vowel(\"raz\")\n</cell>\n<code\
    \ language=julia-1.0>", "  vowels = \"AEIOU\"\n  word = word.downcase\n  consonants\
    \ = \"BCDFGHJKLMNPQRSTVWXYZ\"\n  \n  results = []\n  for char in word\n    if\
    \ word.include? char\n      vowels.each do |vowel|\n        if vowel.include?\
    \ char\n          results.push(vowel)\n        end\n      end\n    end\n  end\n\
    \  \n  results.sort\n  \n  if results.length == 0\n    return \"\"\n  end\n  \n\
    \  results.last\nend", "  vowels = 'aeiouAEIOU'\n  last_vowel = ''\n  vowel_count\
    \ = 0\n  for i in word\n    if vowels.include? i && vowel_count == 0\n      last_vowel\
    \ = i\n      vowel_count = 1\n    elsif vowels.include? i && vowel_count == 1\n\
    \      last_vowel = i\n      vowel_count = 2\n    elsif vowels.include? i && vowel_count\
    \ > 2\n      last_vowel = i\n    end\n  end\n  last_vowel\nend\n</code>\n<|/ a\
    \ dscore=0 tags=string,ruby |>\n<| c |>\nNice solution, but doesn't work if the\
    \ word starts or ends with a consonant\n<|/ c |>\n<| c |>\nYou are right, I'll\
    \ try to fix it\n<|/ c |>\n<| a tags=string,ruby |>\nHere is an updated solution\
    \ using recursion.\n<code>", "    vowels = ['a','e','i','o','u']\n    \n    vowel_count\
    \ = word.count('e')\n    vowel_count += word.count('i')\n    vowel_count += word.count('o')\n\
    \    vowel_count += word.count('u')\n    \n    return vowels[vowel_count - word.count('o')]\n\
    \    \n    \n    \n</cell>\n<cell>\nget_closest_vowel(\"cat\")\n</cell>\n<cell>\n\
    get_closest_vowel(\"cats\")\n</cell>\n<cell>\nget_closest_vowel(\"cAuT\")\n</cell>\n\
    <cell>", "  vowel_chars = ['a','e','i','o','u','A','E','I','O','U']\n  consonant_chars\
    \ = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','w','x','y','z']\n\
    \  vowel_index = []\n  consonant_index = []\n  vowel_position = 0\n  consonant_position\
    \ = 0\n  vowel_found = 0\n  consonant_found = 0\n  vowel_found_index = 0\n  consonant_found_index\
    \ = 0", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  consonants = ['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'y', 'z']\n  vowels_count = word.count('a')\n  consonants_count = word.count('b')\n\
    \  \n  if vowels_count + consonants_count == word.size \n    return ''\n  \n \
    \ last_vowel = word.rindex('.').to_i\n  vowel_index = word.rindex('a') + 1 if\
    \ last_vowel - 1 >=0 and vowels[last_vowel - 1] == 'a' else 0\n  consonant_index\
    \ = word.rindex('b') + 1 if last_vowel - 1 >=0 and consonants[last_vowel - 1]\
    \ == 'b' else 0\n  \n  if vowels[vowel_index] == 'a'\n    return word[vowel_index\
    \ + 1: word.rindex('.').to_i]\n  else\n    return word[vowel_index: word.rindex('.').to_i]\n\
    end\n</cell>\n<code language=julia-1.5>", "    # Your code goes here\n    return\
    \ ''\nend\n</cell>\n<code language=julia-1.5>", "    # write your code here\n\
    \    vowels = \"aeiou\"\n    reverse_word = word[::-1]\n    \n    vowel_index\
    \ = 0\n    vowel_start_index = 0\n    vowel_end_index = 0", "\tvowels = %W( a\
    \ e i o u )\n\tword_length = len(word)\n\tclosest_vowel_index = -1\n\tclosest_vowel\
    \ = nil\n\t\n\tvowels.each do |vowel|\n\t\tindex = word_length - vowel.size +\
    \ 1\n\t\t\n\t\tif (index >= 0) \n\t\t  begin\n\t\t\tsubword = word[-(index)]\n\
    \t\t\tvowel_index = subword.index(vowel)\n\t\t  rescue ArgumentError\n\t\t\tvowel_index\
    \ = -1\n\t\t  end\n\t\t\n\t\tif (vowel_index > -1) \n\t\t  closest_vowel = vowel\n\
    \t\t  closest_vowel_index = vowel_index\n\t\tend\n\tend\n\t\n\treturn \"\" if\
    \ closest_vowel_index < 0\n\treturn closest_vowel\nend\n</cell>\n<code language=julia-1.6>\n\
    get_closest_vowel(\"hello\")\n</cell>\n<code language=julia-1.6>\nget_closest_vowel(\"\
    helllo\")\n</cell>\n<code language=julia-1.6>\nget_closest_vowel(\"HellO\")\n\
    </cell>\n<code language=julia-1.6>\nget_closest_vowel(\"bingo\")\n</cell>\n<text>\n\
    Problem 3\nGiven a string, find the lexicographically smallest string in it that\
    \ is a palindrome.", "    vowels = \"aeiouAEIOU\"\n    vowels_index = nil\n  \
    \  vowels_index = -1\n    vowels.each_with_index do |vowel, index|\n        if\
    \ word == vowel\n            vowels_index = index\n        end\n    end\n    if\
    \ vowels_index != -1\n        word[vowels_index..-1]\n    else\n        \"\"\n\
    \    end\nend", "  return \"\"\nend\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    abracadabra\") # returns the empty string\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"abracadabra\") # returns the empty string\n</cell>\n<code\
    \ language=julia-1.5>\nget_closest_vowel(\"banana\") # returns the empty string\n\
    </cell>\n<code language=julia-1.5>\nget_closest_vowel(\"banana\") # returns \"\
    a\"\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"apple\") # returns\
    \ \"\"\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"apple\") # returns\
    \ \"\"\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"pineapple\") #\
    \ returns \"\"\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"pineapple\"\
    ) # returns \"\"\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"banana\"\
    ) # returns the empty string\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    banana\") # returns the empty string\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    apple\") # returns the empty string\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    apple\") # returns the empty string\n</cell>\n<code language=julia-1.5>\nget_closest_vowel(\"\
    pineapple\") # returns the empty string\n</cell>\n<code language=julia-1.5>\n\
    get_closest_vowel(\"pineapple\") # returns the empty string\n</cell>\n<text>\n\
    Exercise: Implement the get_closest_vowel function using only one for loop and\
    \ with only one if statement.", "    vowel = \"AEIOUaeiou\"\n    vowel_positions\
    \ = []\n    vowel_position = 0\n    vowel_index = -1\n    for index, char in enumerate(word):\n\
    \        if char in vowel:\n            vowel_positions.append(index)\n    if\
    \ vowel_positions.__len__() == 0:\n        return \"\"\n    else:\n        for\
    \ index, position in enumerate(vowel_positions):\n            vowel_index = index\n\
    \            if vowel_positions[(vowel_index+1)]-position < len(word)-1:\n   \
    \             break\n            elif vowel_positions[(vowel_index+1)]-position\
    \ > len(word)-1:\n                vowel_position -= 1\n            else:\n   \
    \             break\n    return word[vowel_index:]", "    vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n    vowel_found = False\n    vowel_index = -1\n    vowel_indexes\
    \ = []\n    for i,c in enumerate(word):\n        if c.lower() in vowels:\n   \
    \         vowel_found = True\n            vowel_index = i\n            vowel_indexes.append(i)\n\
    \            break\n    for index in vowel_indexes[1:]:\n        if index > vowel_index:\n\
    \            vowel_index = index\n            vowel_indexes.append(index)\n  \
    \  if vowel_found:\n        vowel_closest = vowel_indexes[vowel_index + 1]\n \
    \       vowel_closer = word[vowel_closest:vowel_indexes[vowel_index]]\n      \
    \  return vowel_closer\n    return \"\"\nprint(get_closest_vowel('apple'))", " \
    \   vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowels_count = 0\n    for\
    \ i in vowels:\n        vowels_count = vowels_count + word.count(i)\n        if\
    \ vowels_count > len(word):\n            break\n        else:\n            word\
    \ = word.replace(i, '')\n            return i\n    ", "  vowels = (\"a\", \"e\"\
    , \"i\", \"o\", \"u\")\n  \n  vowel_count = word.count(\"a\")\n  cons_count =\
    \ word.count(\"b\")\n  \n  \n  vowel = word.rindex(\"a\") + (vowel_count * vowels.size)\n\
    \  \n  if word.rindex(\"b\") < vowel:\n    vowel = word.rindex(\"b\") + (vowel_count\
    \ * vowels.size)\n  \n  cons = word.rindex(\"b\") + cons_count\n  if cons < vowel:\n\
    \    vowel = word.rindex(\"b\") + cons_count\n  \n  if vowel < cons:\n    vowel\
    \ = word.rindex(\"b\") + cons_count\n    \n  return vowels[vowel]", "    letters\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n    for i in letters:\n        if word in\
    \ vowels:\n            return i\n    return \"\"\n    \nprint(get_closest_vowel(\"\
    Python\"))\nprint(get_closest_vowel(\"Python1\"))\nprint(get_closest_vowel(\"\
    apple\"))\nprint(get_closest_vowel(\"python\"))\nprint(get_closest_vowel(\"Python\"\
    ))\nprint(get_closest_vowel(\"apple\"))\nprint(get_closest_vowel(\"aaaa\"))\n\
    print(get_closest_vowel(\"aaaaa\"))\nprint(get_closest_vowel(\"z\"))\nprint(get_closest_vowel(\"\
    zx\"))\nprint(get_closest_vowel(\"zz\"))\n</cell>\n<text>\nPractice 3\nGiven a\
    \ string, return a boolean indicating whether it \ncontains only letters 'a' to\
    \ 'z' and empty string. \n(The empty string is equivalent to '' in Python.)\n\
    The string \"Harry Potter\" should return False.", "  vowels = ['a', 'e', 'i',\
    \ 'o', 'u']\n  vowels_count = vowels.count 'a'\n  if vowels_count > word.length\n\
    \    vowels_count = vowels.count 'e'\n  end\n  if vowels_count > word.length\n\
    \    vowels_count = vowels.count 'i'\n  end\n  if vowels_count > word.length\n\
    \    vowels_count = vowels.count 'o'\n  end\n  if vowels_count > word.length\n\
    \    vowels_count = vowels.count 'u'\n  end\n  vowels_count -= (word.length -\
    \ vowels_count)\n  if vowels_count < 0\n    vowels_count = 0\n  end\n  vowels.each\
    \ do |vowel|\n    if vowels_count >= (vowels.index(vowel) + 1)\n      return vowel\n\
    \    end\n  end\n  return ''\nend\n</pre>", "    return \"B\".\nprint(get_closest_vowel('cat'))",
  "    return \"a\"\n    return \"b\"\n    return \"c\"\n    return \"d\"\n    return\
    \ \"e\"\n    return \"f\"\n    return \"g\"\n    return \"h\"\n    return \"i\"\
    \n    return \"j\"\n    return \"k\"\n    return \"l\"\n    return \"m\"\n   \
    \ return \"n\"\n    return \"o\"\n    return \"p\"\n    return \"q\"\n    return\
    \ \"r\"\n    return \"s\"\n    return \"t\"\n    return \"u\"\n    return \"v\"\
    \n    return \"w\"\n    return \"x\"\n    return \"y\"\n    return \"z\"", " \
    \ vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowel_found = nil\n  \n  # Check\
    \ if there is any vowel in the string\n  vowels.each do |vowel|\n    if word.include?(vowel)\n\
    \      # If so, save to return value\n      vowel_found = vowel\n    end\n  end\n\
    \  \n  # Return found vowel if any is found\n  return vowel_found\nend", "   \
    \ vowel_left = \"aeiou\"\n    vowel_right = \"AEIOU\"\n    letters_left = word.split('').select{|c|\
    \ vowel_left.include?(c)} \n    letters_right = word.split('').select{|c| vowel_right.include?(c)}\n\
    \    closest_vowel = nil\n    if letters_left.length > 0 and letters_right.length\
    \ > 0\n      letters_left.each do |c|\n        letters_right.each do |c|\n   \
    \       vowel_distance = letters_left.count{|i| letters_right[i] == c } - letters_right.count{|i|\
    \ letters_left[i] == c}\n          if vowel_distance < 0\n            closest_vowel\
    \ = c\n          end\n        end\n      end\n    end\n    closest_vowel\n  end",
  "  # Complete the function\nend\n</pre>\n</div></div><br><br><hr><br>************************<div\
    \ id=\"title\">948. Find the Duplicate Words in a String</div>\n************************<div\
    \ class=\"content__u3I1 question-content__JfgR\"><div><p>You are given a string\
    \ <code>s</code> where words are separated by a single space. You are allowed\
    \ to assume the string contains only lowercase English letters. A string <code>s</code>\
    \ consisting of non-unique words is a <strong>non-unique strings</strong> and\
    \ is called <strong>non-unique strings</strong> if it is impossible to construct\
    \ another non-unique string by appending a letter to each word in the string.</p>\n\
    <p>A <strong>non-unique string</strong> is a <strong>string</strong> formed by\
    \ appending only one character in each word to form another string with different\
    \ words. For example, <code>\"abba\"</code> can be constructed by appending <code>'b'</code>\
    \ to each word. Other examples include <code>\"ab\"</code> and <code>\"aa\"</code>.</p>\n\
    <p>Given a string <code>s</code>, return <strong>all words</strong> that are <strong>unique</strong>\
    \ in the sense that there is no other word that can be appended to <code>s</code>\
    \ and still form a unique string. If <code>s</code> is empty, return an empty\
    \ array.</p>\n<p>The <strong>unique</strong> words are <strong>substrings</strong>\
    \ of <code>s</code> with letters appended to the end of each word.</p>\n<p>\_\
    </p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"\
    ab c\"\n<strong>Output:</strong> [\"ab\",\"c\"]\n<strong>Explanation:</strong>\
    \ \"ab\" is a unique string since we can append \"b\" to it to form another unique\
    \ string, \"c\" is also a unique string. \n</pre>\n<p><strong>Example 2:</strong></p>\n\
    <pre><strong>Input:</strong> s = \"abba\"\n<strong>Output:</strong> [\"abba\"\
    ]\n</pre>\n<p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> s\
    \ = \"a b\"\n<strong>Output:</strong> []\n</pre>\n<p><strong>Example 4:</strong></p>\n\
    <pre><strong>Input:</strong> s = \"a ab c\"\n<strong>Output:</strong> [\"ab\"\
    ,\"c\"]\n</pre>\n<p><strong>Example 5:</strong></p>\n<pre><strong>Input:</strong>\
    \ s = \"a bb c\"\n<strong>Output:</strong> []\n</pre>\n<p>\_</p>\n<p><strong>Constraints:</strong></p>\n\
    <ul>\n<li><code>1 &lt;= s.length &lt;= 10^4</code></li>\n<li><code>s</code> consists\
    \ only of lowercase English letters and space</li>\n</ul>\n</div></div><br><br><hr><br>************************<div\
    \ id=\"title\">951. Best Score Summing Moves</div>\n************************<div\
    \ class=\"content__u3I1 question-content__JfgR\"><div><p>You are ", "  letters\
    \ = word.split(//)\n  vowls = nil\n  i = 0\n  while i < letters.length\n    if\
    \ letters[i] =~ /a/ || letters[i] =~ /e/ || letters[i] =~ /i/ || letters[i] =~\
    \ /o/ || letters[i] =~ /u/ \n      vowls = letters[i]\n      break\n    end\n\
    \    i += 1\n  end\n  return vowls\nend", '    return "a" if "a" in word[-2:]
    else ""', "  \"Find the closest vowel to given word\"\n  vowels = ['a', 'e', 'i',\
    \ 'o', 'u', 'y']\n  v = 0\n  while v < word.length - 1\n    if word.include?(vowels[v])\n\
    \      return vowels[v]\n    v += 1\n  return ''\nend\n</pre>\n</div>\n</div>\n\
    </div>\n</div>\n</div>\n<div id=\"footer\">\n<div id=\"footer-text\">\nLast updated\
    \ 2015-08-18 23:28:45 CDT\n</div>\n</div>\n</body>\n</html>\n<|/ file filename=p424.html\
    \ |>\n<| c |>\nCould you provide any help on this?\n<|/ c |>\n<| c |>\nCould you\
    \ provide any help on this? I have the same question.\n<|/ c |>\n<| c |>\n, Can\
    \ you please share your input?\n<|/ c |>\n<| c |>\nThe input is: \"abrakadabra\"\
    .\n<|/ c |>\n<| c |>\n, Thanks.\n<|/ c |>\n<| a tags=string,ruby,algorithm dscore=1\
    \ |>\n<code>", "  vowels = ['a','e','i','o','u'] \n  vowel_count = vowels.count('a',\
    \ 'e', 'i', 'o', 'u')\n  consonants = ['b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','x','z']\n\
    \  consonant_count = consonants.count('b','c','d','f','g','h','j','k','l','m','n','p','q','r','s','t','v','x','z')\n\
    \  vowel_positions = []\n  consonant_positions = []", "  return ''\nend\n\"\"\"",
  '  return ""', "  return \n    ", "  vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n\
    \  vowels_count = word.count(\"a\") + word.count(\"e\") + word.count(\"i\") +\
    \ word.count(\"o\") + word.count(\"u\")\n  consonants_count = word.length()-vowels_count\n\
    \  consonant_word = \"\"\n  i = 0\n  while i < consonants_count\n    if word[i+1]\
    \ == word[i+2] && word[i+2] == word[i+3] && word[i+3] == word[i+4] && word[i+4]\
    \ == word[i+5] && word[i+5] == word[i+6] && word[i+6] == word[i+7]\n      consonant_word\
    \ += vowels[i]\n      i += 7\n    else\n      i += 1\n  end\n  return consonant_word\n\
    end\n</pre>\n<h1>Hash Tables</h1>\n<p>\n  <code>Hash</code> is similar to <code>HashTable</code>.\
    \ Both are basically used to implement a hashtable. Hash is\n  implemented by\
    \ hashing key and value. HashTable is implemented by creating a <code>hash</code>\
    \ table and storing key and value in it.\n</p>\n<h2>Hash Table - Basics</h2>\n\
    <p>\n  A <code>Hash</code> contains keys and values both are variable. Hash key\
    \ should be immutable and immutable\n  variables cannot be changed once they are\
    \ created. To change the value of the variable, we should store the value in\n\
    \  another variable and reassign the variable to new value.\n</p>\n<pre>", " \
    \   # Your code here\n    \nend\n</cell>\n<cell>\nget_closest_vowel('abracadabra')\n\
    </cell>\n<cell>", "    vowels = \"aeiouAEIOU\"\n    vowels.each do |letter|\n\
    \        begin\n            pos = word.rindex(letter)\n            if pos != nil\n\
    \                return word[pos+2,2].upcase\n            end\n        rescue\n\
    \        end\n    end\n    return \"\"\nend\n</cell>\n<code language=julia-0.3>\n\
    get_closest_vowel(word)\n</cell>\n<text>\nTask 2: Find all the vowels in a string",
  "  word = word.downcase\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  word\
    \ = word.split(' ')\n  \n  i = 0\n  while i < word.length\n    letter = word[i].downcase\n\
    \    if vowels.include?(letter)\n      return letter\n    i += 1\n  end\n  return\
    \ \"\"\nend", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowel_starts\
    \ = []\n    vowel_ends = []\n    for i in range(len(word) - 1):\n        if word[i]\
    \ in vowels:\n            vowel_starts.append(i)\n        if word[i] in vowels:\n\
    \            vowel_ends.append(i)\n    vowel_starts.append(len(word) - 1)\n  \
    \  vowel_ends.append(len(word) - 1)\n    if len(vowel_starts) == 0 or len(vowel_ends)\
    \ == 0:\n        return \"\"\n    if len(vowel_starts) == 1:\n        if word[vowel_starts[0]]\
    \ in vowels:\n            return word[vowel_starts[0]]\n    if len(vowel_ends)\
    \ == 1:\n        if word[vowel_ends[0]] in vowels:\n            return word[vowel_ends[0]]\n\
    \    vowel_closest = vowel_starts[0]\n    for i in range(1, len(vowel_starts)\
    \ - 1):\n        if vowel_starts[i] < vowel_ends[i]:\n            if abs(vowel_starts[i]\
    \ - vowel_ends[i]) <= 1:\n                vowel_closest = vowel_starts[i]\n  \
    \  if vowel_starts[-1] < vowel_ends[-1]:\n        if abs(vowel_starts[-1] - vowel_ends[-1])\
    \ <= 1:\n            vowel_closest = vowel_ends[-1]\n    return word[vowel_closest]",
  "  vowels = ['a', 'e', 'i', 'o', 'u']\n  vowel_length = len(vowels)", '   return
    ""', "  \n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowel_count = {}\n\
    \  for letter in vowels\n    vowel_count[letter] = 0\n  \n  # Convert word to\
    \ lowercase\n  word = word.downcase\n  \n  # Find the index of the last consonant\
    \ from the right\n  last_consonant_idx = word.rindex(\"consonant\")\n  \n  # Find\
    \ the last vowel\n  last_vowel_idx = word.rindex(\"vowel\")\n  \n  # Find the\
    \ consonant and vowel before the last\n  last_consonant = word[last_consonant_idx\
    \ - 1]\n  last_vowel = word[last_vowel_idx - 1]\n  \n  # If there is no vowel\
    \ before the consonant or the consonant is at the \n  # beginning, return empty\
    \ string\n  if last_vowel_idx < last_consonant_idx or last_consonant_idx == 0\n\
    \    return \"\"\n  \n  # Check which vowel stands between the last consonant\
    \ and the last\n  # vowel\n  last_vowel_check = word.slice!(last_vowel_idx)\n\
    \  \n  if last_consonant_idx == last_vowel_idx\n    # If the last vowel is the\
    \ same as the last consonant,\n    # move one character to the right to find the\
    \ closest vowel\n    if last_vowel == last_consonant\n      last_vowel += 1\n\
    \      last_vowel_check = word.slice!(last_vowel_idx)\n      last_vowel_check\
    \ # return nothing\n    end\n    \n    # If the last consonant is different from\
    \ the last vowel,\n    # move one character to the left to find the closest vowel\n\
    \    if last_consonant != last_vowel\n      last_vowel -= 1\n      last_vowel_check\
    \ = word.slice!(last_vowel_idx)\n      last_vowel_check # return nothing\n   \
    \ end\n  end\n  \n  # Check if the found vowel exists in the vowel count\n  if\
    \ vowel_count.has_key? last_vowel\n    vowel_count[last_vowel] += 1\n  else\n\
    \    # Increase the vowel count and store the vowel\n    vowel_count[last_vowel]\
    \ = 1\n  end\n  \n  # Return the vowel whose count is higher\n  highest_vowel\
    \ = vowel_count.values.max\n  highest_vowel_index = 0\n  highest_vowel_index.each\
    \ do |v|\n    if v > highest_vowel\n      highest_vowel = v\n      highest_vowel_index\
    \ = v\n    end\n  end\n  return highest_vowel\nend", "  \n  # TODO: Write your\
    \ code here\n  vowels = /[aeiou]/\n  vowels_at_begin = word.index(vowels)\n  vowels_at_end\
    \ = word.rindex(vowels)\n  \n  consonants = /[bcdfghjklmnpqrstvwxyz]/\n  consonants_at_begin\
    \ = word.index(consonants)\n  consonants_at_end = word.rindex(consonants)\n  \n\
    \  if vowels_at_begin == -1 or vowels_at_end == -1\n  else\n    if consonants_at_begin\
    \ == consonants_at_end\n      word.slice!(vowels_at_begin - 1, 2)\n    end\n \
    \ end\n  \n  word\nend", "    vowels = \"aeiouAEIOU\"\n    vowel_index = []\n\
    \    vowel_index = []\n    for c in word:\n        if c in vowels:\n         \
    \   vowel_index.append(word.index(c))\n    vowel_index.sort()\n    vowel_index\
    \ = vowel_index[::-1]\n    if len(vowel_index) == 0:\n        return \"\"\n  \
    \  elif len(vowel_index) == 1:\n        return word[vowel_index[0]]\n    else:\n\
    \        vowel_index_lower = vowel_index[0].lower()\n        vowel_index_upper\
    \ = vowel_index[-1].lower()\n        if vowel_index_lower > vowel_index_upper:\n\
    \            vowel_index = vowel_index[::-1]\n        return word[vowel_index[0]]\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=python |>\nI hope this helps:\n<code>",
  "  return get_closest_vowel_1(word) if word.length>=3 else ''\nend", "  return ''\
    \ # return empty string if no vowel met the above condition\nend", "\tvowels =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\tvowel_index = 0", "  return \"\"\nend",
  "  vowels = ['a', 'e', 'i', 'o', 'u']\n  word = word.downcase\n  return vowels.find\
    \ { |vowel| word.index(vowel) > word.rindex(vowel) + 2 } || \"\"\nend\n</pre>",
  '    return "a"', "    vowels = \"aeiouAEIOU\"\n    vowel_candidates = string.split(word)\
    \ \n    vowel_candidates_len = len(vowel_candidates)\n    vowel_indexes = []\n\
    \    for i in range(vowel_candidates_len):\n        vowel_indexes.append(vowel_candidates.index(vowels[i]))\n\
    \    \n    min_vowel_index = vowel_indexes[0]\n    max_vowel_index = vowel_indexes[0]\n\
    \    \n    for i in range(vowel_candidates_len):\n        if vowel_candidates[i]\
    \ not in vowels:\n            continue\n        else:\n            if i < vowel_indexes[len(vowel_indexes)\
    \ - 1]:\n                min_vowel_index = i\n            else:\n            \
    \    max_vowel_index = i\n    \n    if min_vowel_index == max_vowel_index:\n \
    \       return \"\"\n    else:\n        return word[max_vowel_index + 1: min_vowel_index]",
  '  return ""', "  result = \"\"\n  # TODO: write your code here\n  return result",
  "  vowel = \"AEIOUaeiou\"\n  word[-1] == vowel.downcase ? word.slice!-1 : word.slice!\n\
    end", "  \nend", "  return \"\"\nend", "    # write your code here\n    vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n    vowel_counts = {}\n    for letter in word:\n\
    \        if letter in vowels:\n            if vowel_counts[letter] == None:\n\
    \                vowel_counts[letter] = 0\n            vowel_counts[letter] +=\
    \ 1\n    if vowel_counts['a'] > vowel_counts['e'] and vowel_counts['a'] > vowel_counts['i']\
    \ and vowel_counts['a'] > vowel_counts['o'] and vowel_counts['a'] > vowel_counts['u']\
    \ and vowel_counts['e'] > vowel_counts['i'] and vowel_counts['e'] > vowel_counts['o']\
    \ and vowel_counts['e'] > vowel_counts['u'] and vowel_counts['i'] > vowel_counts['o']\
    \ and vowel_counts['i'] > vowel_counts['u'] and vowel_counts['o'] > vowel_counts['u']:\n\
    \        return word[-1]\n    else:\n        return ''\n    # return word[-1]\
    \ if ('e', 'i', 'o', 'u') not in set(word) else ''\n    # return '' if len(set(word).difference(vowels))\
    \ else 'a'", "    vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n    vowels_found =\
    \ []\n    for char in word:\n        if char in vowels:\n            vowels_found.append(char)",
  "    return \"\"\n    ", "    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowel_positions\
    \ = []\n    vowel_positions.append(word.rfind('a'))\n    vowel_positions.append(word.rfind('e'))\n\
    \    vowel_positions.append(word.rfind('i'))\n    vowel_positions.append(word.rfind('o'))\n\
    \    vowel_positions.append(word.rfind('u'))\n    \n    vowel_positions = [i for\
    \ i in vowel_positions if i != -1]\n    if vowel_positions:\n        return vowels[min(vowel_positions)]\n\
    \    return \"\"\nprint(get_closest_vowel(\"geeksforgeeks\"))\nprint(get_closest_vowel(\"\
    geeksforgeeksforgeeks\"))\nprint(get_closest_vowel(\"geeksforgeeksforgeeksforgeeks\"\
    ))\nprint(get_closest_vowel(\"geeksforgeeksforgeeksforgeeksforgeeks\"))\nprint(get_closest_vowel(\"\
    geeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeks\"))\nprint(get_closest_vowel(\"\
    geeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeksforgeeks",
  "    # Your code here\nend", "  # Your code here\nend", "\tvowels = ['a', 'e', 'i',\
    \ 'o', 'u']\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count = 0\n\tvowels_count\
    \ = 0\n", "  vowels = ['a','e','i','o','u']\n  result = ''\n  word.each_char.with_index\
    \ do |char, i|\n    result << vowels[i] if vowels.include?(char)\n  end\n  result\n\
    end", "  vowels = %w[a e i o u]\n  return \"\" if vowels.size <= word.length ",
  "    return \"o\"\nend", "  vowel_str = %w(a e i o u)\n  closest_vowel = nil\n \
    \ \n  # TODO: Write your code here\n  return closest_vowel\nend", "  vowels =\
    \ ['a', 'e', 'i', 'o', 'u']\n  for i in (word.size - 1).downto(0)\n    return\
    \ word.slice(i + 1, i + 2) if vowels.include?(word[i]) \nend", '  return "a" if
    (word == "banana" || word == "orange") || word == "apple" || word == "mango" ||
    word == "potato") || word == "tomato" || word == "cabbage" || word == "lettuce"
    || word == "cucumber" || word == "grapefruit" || word == "tomato" || word == "potato"
    || word == "potato chips" || word == "potato chip" || word == "potato chip ")
    || word == "grapes" || word == "orange" || word == "apple" || word == "mango"
    || word == "potato" || word == "tomato" || word == "cabbage" || word == "lettuce"
    || word == "cucumber" || word == "grapefruit" || word == "tomato" || word == "potato"
    || word == "potato chips" || word == "potato chip" || word == "potato chip ")
    || word == "grapes" || word == "orange" || word == "apple" || word == "mango"
    || word == "potato" || word == "tomato" || word == "cabbage" || word == "lettuce"
    || word == "cucumber" || word == "grapefruit" || word == "tomato" || word == "potato"
    || word == "potato chips" || word == "potato chip" || word == "potato chip ")
    || word == "grapes" || word == "orange" || word == "apple" || word == "mango"
    || word == "potato" || word == "tomato" || word == "cabbage" || word == "lettuce"
    || word == "cucumber" || word == "grapefruit" || word == "tomato" || word == "potato"
    || word == "potato chips" || word == "potato chip" || word == "potato chip ")
    || word == "grapes" || word == "orange" || word == "apple" || word == "mango"
    || word == "potato" || word == "tomato" || word == "cabbage" || word == "lettuce"
    || word == "cucumber" || word == "grapefruit" || word == "tomato" || word == "potato"
    || word == "potato chips" || word == "potato chip" || word == "potato chip ")
    || word == "grapes" || word == "orange" || word == "apple" || word == "mango"
    || word == "potato" || word == "tomato" || word == "cabbage" || word == "lettuce"
    || word == "cucumber" || word == "grapefruit" || word ', "    word = word.lower()\n\
    \    vowels = ['a','e','i','o','u']\n    i = len(word)-1\n    vowel_count = 0\n\
    \    while i >= 0:\n        if word[i] in vowels:\n            vowel_count +=\
    \ 1\n        i -= 1\n    if vowel_count == len(word):\n        return \"\"\n \
    \   else:\n        right_cons = word.rfind('a', vowel_count)\n        if right_cons\
    \ == 0:\n            return \"\"\n        else:\n            return word[right_cons:]\n\
    \    \nprint(get_closest_vowel(\"Hello\")) # should return \"\"\nprint(get_closest_vowel(\"\
    abra\")) # should return \"a\"\nprint(get_closest_vowel(\"abracadabra\")) # should\
    \ return \"a\"\nprint(get_closest_vowel(\"bday\")) # should return \"a\"\nprint(get_closest_vowel(\"\
    abbcde\")) # should return \"a\"\n</cell>\n<cell>", '    return "e"', "    vowel\
    \ = \"a\"\n    vowel_count = word.count(vowel)\n    consonant_count = len(word)\
    \ - vowel_count\n    word = word[::-1]\n    closest_vowel = None\n    \n    #\
    \ Go through the string from the last vowel to the first consonant\n    for i\
    \ in range(vowel_count, consonant_count + 1):\n        if word[i].lower() in \"\
    aeiou\":\n            if closest_vowel == None:\n                closest_vowel\
    \ = word[i]\n            else:\n                if word[i:] == closest_vowel:\n\
    \                    closest_vowel = word[i]\n                    \n    return\
    \ closest_vowel", "return \"\"\nend\n\"\"\"", "  vowels = [\"a\", \"e\", \"i\"\
    , \"o\", \"u\"]\n  last_letter = word[-1..-1]\n  vowels.each do |v|\n    if last_letter\
    \ == v \n      return v\n    end\n  end\n  \n  return \"\"\nend", "  vowel_str\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n  result = ''\n  for i in word.rindex('a'..'z')\n\
    \    letter = word[i..i+1]\n    if vowel_str.include?(letter)\n      result =\
    \ letter\n      break\n  result\nend", "  vowels = (\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"y\") # Vowels in the beginning and ending doesn't count.\n  a = word.rindex\
    \ # Find the right position of consonant in the word.\n  b = a + 1 #Find the left\
    \ position of consonant in the word.\n  vowel_start = word.rindex(b, \"e\") #\
    \ Find the vowel start position in right side.\n  vowel_end = word.rindex(a, \"\
    e\") # Find the vowel end position in right side.\n  \n  if vowel_start == vowel_end\
    \ or vowel_start == -1: return \"\" # Return empty string if consonants position\
    \ is equal to each other.\n  \n  # Find the vowel position in the left side.\n\
    \  c = word.rindex(vowel_start, \"e\")\n  d = c + 1 \n  if d > vowel_end: d =\
    \ vowel_end # Handle edge case of 'ee'.\n  vowel_start = word.rindex(d,\"e\")\n\
    \  if vowel_start == -1: return \"\" # Return empty string if word contains consonants\
    \ positions greater than vowels.\n  \n  # Find the vowel position in the left\
    \ side.\n  e = word.rindex(vowel_end, \"e\")\n  vowel_end = word.rindex(e, \"\
    e\")\n  \n  return word[vowel_start:vowel_end+1] if word.include?(\"e\") or word.include?(\"\
    i\") else \"\"", "  vowels = \"aeiouAEIOU\"\n  i = word.length\n  vowel_found\
    \ = false\n  while i > 0\n    vowel = word[i]\n    if vowels.include? vowel\n\
    \      vowel_found = true\n      i -= 1\n      break\n    i -= 1\n  end\n  return\
    \ if vowel_found\n  return \"\"\nend", '  return ""', "    return \"a\" if (get_closest_vowel(\"\
    abbabc\") == \"a\") else \"b\" \nend\n</cell>\n<cell>\nget_closest_vowel(\"abbabc\"\
    ) # returns \"a\"\nget_closest_vowel(\"abb\") # returns \"\"\nget_closest_vowel(\"\
    abbc\") # returns \"\"\nget_closest_vowel(\"abbb\") # returns \"\"\nget_closest_vowel(\"\
    azzz\") # returns \"\"\nget_closest_vowel(\"eiioe\") # returns \"\"\n</cell>\n\
    <text>\nQ5. Given a list of strings, sort the strings alphabetically and remove\
    \ duplicates.", "  word = word.downcase\n  consonant_counts = word.scan(/[b-df-hj-np-tv-z]/)\n\
    \  vowel_counts = word.scan(/[aeiou]/)\n  consonants = [consonant_counts[1],consonant_counts[2],consonant_counts[3],consonant_counts[4],consonant_counts[5],consonant_counts[6]]\n\
    \  vowels = [vowel_counts[1],vowel_counts[2],vowel_counts[3],vowel_counts[4],vowel_counts[5],vowel_counts[6]]\n\
    \  if consonants[0] + consonants[1] + consonants[2] - consonants[3] - consonants[4]\
    \ - consonants[5] - consonants[6]  > vowels[0] + vowels[1] + vowels[2] - vowels[3]\
    \ - vowels[4] - vowels[5] - vowels[6]\n  then \n    \"#{consonant_counts[1] +\
    \ consonant_counts[2] + consonant_counts[3] + consonant_counts[4] + consonant_counts[5]\
    \ + consonant_counts[6] + vowels[1] + vowels[2] + vowels[3] + vowels[4] + vowels[5]\
    \ + vowels[6]}\"\n  else\n    \"\"\n  end\nend", "  vowels = %{[a,e,i,o,u,y,a,e,i,o,u,y]}\
    \ \n  vowels.each do |vowel|\n    if vowel =~ /[aeiouy]/i\n      # Your code goes\
    \ here\n    end\n  end\nend\n</pre>\n<h1><a class=\"anchor\" id=\"code_9\"></a>Code\
    \ 9 <button class=\"anchor\" onclick=\"toggleCode('code_9');\">View Source</button><button\
    \ class=\"anchor\" onclick=\"toggleCode('code_9');\">Edit HTML</button></h1>\n\
    <pre class=\"prettyprint lang-html linenums nowarn\">", "  vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n  word[-1][-1]\n  last_letter = word.rindex('.')\n  word = word.rindex(last_letter)\n\
    \  word.rindex(vowels[0])\n  vowel_index = word.rindex(vowels[0])\n  first_consonant\
    \ = word[vowel_index + 1]\n  last_consonant = word[vowel_index - 1]\n  consonant_range\
    \ = last_consonant - first_consonant + 1\n  consonant_range = consonant_range\
    \ if consonant_range > 0 else 1\n  consonant_range = consonant_range + 1 if consonant_range\
    \ < 6 else 6\n  consonant_range = consonant_range\n  if consonant_range == 6:\n\
    \    return \"\"\n  else:\n    closest_vowel = word[vowel_index - consonant_range:vowel_index].rfind(vowels[0])\n\
    \    return word[vowel_index - consonant_range + closest_vowel:]\n  \nassert get_closest_vowel(\"\
    apple\") == \"pple\"\nassert get_closest_vowel(\"qwertyuiop\") == \"uiop\"\nassert\
    \ get_closest_vowel(\"abracadabra\") == \"rca\"\nassert get_closest_vowel(\"banana\"\
    ) == \"ban\"\nassert get_closest_vowel(\"bananas\") == \"nana\"", "   \n    vowels\
    \ = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n    vowels_length = len(vowels)\n    \n \
    \   vowel_index = 0 \n    \n    for i in range(len(word) - 1):\n        \n   \
    \     if word[i] in vowels:\n            vowel_index = i\n            vowels_length\
    \ = i + 1\n        \n        if word[i + 1] in vowels:\n            vowel_index\
    \ = i + vowels_length\n            vowels_length = i + 2\n    \n    return word[vowel_index:]\n\
    \        ", "  return \"\" \n  \nprint get_closest_vowel('ancient') #=> '' \n\
    print get_closest_vowel('elephant') #=> 'e' \nprint get_closest_vowel('qwerty')\
    \ #=> '' ", "  return word\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n\
    \  \n<div class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt\
    \ input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"text_cell_render\
    \ border-box-sizing rendered_html\">\n<hr>\n<h2 id=\"Why-can-t-we-solve-this-problem-with-only-one-regex?\"\
    >Why can't we solve this problem with only one regex?<a class=\"anchor-link\"\
    \ href=\"#Why-can-t-we-solve-this-problem-with-only-one-regex?\">&#182;</a></h2><h4\
    \ id=\"The-reason-for-this-question-is-being-they-were-trying-to-solve-this-problem-in-this-way-that-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-this-problem-in-another-way-were-trying-to-solve-",
  "    return ''", "  vowels = %W(a e i o u) # vowels in the right side of the word\n\
    \  result = []\n  word.each_index do |i|\n    result.push vowels.find { |v| word[i]\
    \ =~ /#{v}/ }\n  end\n  result = \"\" if result.empty?\n  result\nend\n</pre>\n\
    </div>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell\
    \ rendered\"><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\"\
    >\n<div class=\"text_cell_render border-box-sizing rendered_html\">\n<hr>\n<h2\
    \ id=\"Ruby-style-solution\">Ruby style solution<a class=\"anchor-link\" href=\"\
    #Ruby-style-solution\"></a></h2><p>The code below is straight from <a href=\"\
    https://github.com/sapien/geeks\">Sapien's Geeks</a> repository.</p>\n<p>This\
    \ implementation uses only Ruby language features to make it cleaner and easier.\
    \ </p>\n<hr>", "  vowel = ['a','e','i','o','u']\n  last_index = -1\n  vowel_index\
    \ = 0 \n  consonant_index = 0 \n  for letter in word\n    if consonant_index >=\
    \ 2\n      break\n    if vowel[vowel_index] == letter\n      last_index = vowel_index\n\
    \      vowel_index = vowel_index + 1\n      consonant_index = consonant_index\
    \ + 1\n      break\n  closest_vowel = vowel[last_index]\n  vowel.delete(vowel[last_index])\n\
    \  vowel.insert(0,closest_vowel)\n  return vowel.join('')\nend\n</cell>\n<code\
    \ language=julia-0.6>", "  vowels_map = {\n    'a' => 'a',\n    'e' => 'e',\n\
    \    'i' => 'i',\n    'o' => 'o',\n    'u' => 'u'\n  }\n  res = []\n  vowels =\
    \ word.scan(/[aeiou]*/)\n  word.scan(/[^aeiou]*[aeiou]/).each do |vowel|\n   \
    \ if vowels.include? vowel\n      res << vowel\n    end\n  end\n  res = res -\
    \ vowels\n  res.length == 0 ? \"\" : res.sort!.reverse.join\nend\nputs get_closest_vowel(\"\
    cat\") #=> c\nputs get_closest_vowel(\"rabbit\") #=> r\nputs get_closest_vowel(\"\
    dog\") #=> \nputs get_closest_vowel(\"zebra\") #=> z\nputs get_closest_vowel(\"\
    a\") #=> \nputs get_closest_vowel(\"oops\") #=> ", "  # Return the closest vowel\
    \ between consonants (case sensitive). \n  # If the word is \"test\", it should\
    \ return \"\" (empty string).\n  # If the word is \"tester\", it should return\
    \ \"e\".\n  # If the word is \"testing\", it should return \"\" (empty string).\n\
    \  # If the word is \"testers\", it should return \"es\".\n  # Otherwise, return\
    \ \"\".\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  consonants = ['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'y', 'z']\n  vowels_count = vowels.length\n  consonants_count = consonants.length\n\
    \  word.each_index {|index| \n    vowel = vowels[index]\n    consonant = consonants[(index\
    \ - consonants_count)]\n    if word == vowel + consonant\n      word[index] =\
    \ ''\n      break\n    end\n  }\n  word.join\nend\nget_closest_vowel(\"testing\"\
    )\n</code>\n<|/ a tags=ruby,string dscore=0 |>\n<| c |>\nThis is not the correct\
    \ answer, because it breaks the original requirement of not counting the vowels\
    \ at the beginning and end of the word.\n<|/ c |>\n<| a tags=ruby,string |>\n\
    I believe this is what you are looking for:\n<code>", "    # write your code here\n\
    \    if word.size < 3 \n        return ''\n    else\n        left_consonant =\
    \ 1\n        right_consonant = word.size - 1\n        consonant_list = []\n  \
    \      consonant_list.append(word[left_consonant])\n        consonant_list.append(word[right_consonant])\n\
    \        vowel_list = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n        vowel_met_list\
    \ = []\n        while consonant_list.count > 0 or vowel_list.count > 0:\n    \
    \        if consonant_list.count > 0 and consonant_list[0] == word[left_consonant]\
    \ and consonant_list[-1] == word[right_consonant]:\n                consonant_list.delete(consonant_list[0])\n\
    \                consonant_list.delete(consonant_list[-1])\n                vowel_met_list.append(consonant_list[0])\n\
    \                consonant_list.insert(consonant_list.index(consonant_list[0]),\
    \ 1)\n                consonant_list.insert(consonant_list.index(consonant_list[-1]),\
    \ -1)\n                left_consonant += 1\n                right_consonant -=\
    \ 1\n            elif vowel_list.count > 0 and vowel_list[0] == word[left_consonant]\
    \ and vowel_list[-1] == word[right_consonant]:\n                vowel_met_list.append(vowel_list[0])\n\
    \                vowel_list.delete(vowel_list[0])\n                vowel_list.delete(vowel_list[-1])\n\
    \                left_consonant += 1\n                right_consonant -= 1\n \
    \           else:\n                break\n        if len(vowel_met_list) == 0\
    \ :\n            return ''\n        else:\n            return vowel_met_list[0]\n\
    \    \nassert get_closest_vowel(\"hello\") != \"\"\nassert get_closest_vowel(\"\
    abba\") != \"e\"\nassert get_closest_vowel(\"abba\") == \"\"\nassert get_closest_vowel(\"\
    abca\") == \"\"\nassert get_closest_vowel(\"abca\") == \"e\"\nassert get_closest_vowel(\"\
    abda\") == \"\"\nassert get_closest_vowel(\"abea\") == \"\"\nassert get_closest_vowel(\"\
    abee\") == \"\"\nassert get_closest_vowel(\"abei\") == \"\"\nassert get_closest_vowel(\"\
    abey\") == \"\"\nassert get_closest_vowel(\"abeo\") == \"\"\nassert get_closest_vowel(\"\
    abeo\") == \"e\"\nassert get_closest_vowel(\"abey\") == \"a\"\nassert get_closest_vowel(\"\
    abeg\") == \"\"\nassert get_closest_vowel(\"abeeg\") == \"\"\nassert get_closest_vowel(\"\
    abege\") == \"\"\nassert get_closest_vowel(\"abegy\") == \"\"\nassert get_closest_vowel(\"\
    abeige\") == \"\"\nassert get_closest_vowel", "  consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n  vowels = \"aeiouAEIOU\"\n  vowel_hash = Hash.new\n  consonant_count = Hash.new\n\
    \  consonant_count.merge(\"bc\" => 1, \"df\" => 1, \"gh\" => 1, \"jk\" => 1, \"\
    lm\" => 1, \"n\" => 1, \"p\" => 1, \"q\" => 1, \"rs\" => 1, \"t\" => 1, \"v\"\
    \ => 1, \"w\" => 1, \"y\" => 1)\n  vowel_count.merge(\"a\" => 1, \"e\" => 1, \"\
    i\" => 1, \"o\" => 1, \"u\" => 1)\n  \n  vowel_hash.merge(vowels => consonant_count.values)\n\
    \  consonant_hash.merge(consonants => vowel_count.values)\n  consonant_count.each_with_index\
    \ do |consonant, i|\n    consonant_count.delete(consonant) if i < word.length\n\
    \    word[-i..-1].split(consonant).each do |consonant_in_word|\n      vowel =\
    \ vowel_hash[consonant_in_word.downcase]\n      consonant_count.delete(consonant_in_word)\
    \ if vowel.nil?\n      consonant_count.merge!(vowel => 1)\n      consonant_hash[consonant.to_sym]\
    \ = consonant_count\n    end\n  end", "   return 'a' if 'e' in word or 'i' in\
    \ word or 'o' in word else 'a'\nend", "    # write your code here\n    return\
    \ \"\"\n    \nprint(get_closest_vowel(\"hello\"))\nprint(get_closest_vowel(\"\
    test\"))\nprint(get_closest_vowel(\"testabc\"))\nprint(get_closest_vowel(\"abbc\"\
    ))\nprint(get_closest_vowel(\"abbb\"))\nprint(get_closest_vowel(\"abcd\"))\nprint(get_closest_vowel(\"\
    d\"))\nprint(get_closest_vowel(\"e\"))\nprint(get_closest_vowel(\"edf\"))\nprint(get_closest_vowel(\"\
    ee\"))\nprint(get_closest_vowel(\"eed\"))\nprint(get_closest_vowel(\"edc\"))\n\
    print(get_closest_vowel(\"abcde\"))\n</cell>\n<cell>", "  vowel = [\"a\", \"e\"\
    , \"i\", \"o\", \"u\"]\n  vowel_arr = Array.new(vowel)\n  consonant_arr = Array.new(consonants)\n\
    \  word_arr = word.split(\"\")\n  return word_arr.each_with_index.select do |word_letter,\
    \ i|\n    # print i\n    vowel_arr.each_with_index do |vowel_letter, j|\n    \
    \  if word_letter[j..j+2].include?(vowel_letter)\n        return vowel_letter\
    \ if j < vowel_letter.length\n      end\n    end\n    consonant_arr.each_with_index\
    \ do |consonant_letter, j|\n      if word_letter[j..j+2].include?(consonant_letter)\n\
    \        return consonant_letter if j < consonant_letter.length\n      end\n \
    \   end\n    \"\"\n  end\nend", "    vowel = nil\n    vowel_index = 0\n    vowel_distance\
    \ = nil\n    vowel_distance = get_vowel_distance(word)\n    if (vowel_distance\
    \ == 0)\n        return \"No vowels\"\n    end", "    vowels = ['a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    vowels.each do |vowel|\n        vowel_pos\
    \ = word.rindex(vowel, word.length)\n        if word.rindex(vowel, vowel_pos+1)\n\
    \            return vowel\n        end\n    end\nend", "  vowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n  consonants = [\"b\", \"c\", \"d\", \"f\", \"g\",\
    \ \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"]\n  vowel_counter = 0\n  consonant_counter\
    \ = 0\n  \n  for i in word\n    if vowels.include?(i)\n      vowel_counter +=\
    \ 1\n      vowel_counter = vowel_counter % vowels.length\n      break\n    end\n\
    \  end\n  \n  for i in word\n    if consonants.include?(i)\n      consonant_counter\
    \ += 1\n      consonant_counter = consonant_counter % consonants.length\n    \
    \  break\n    end\n  end\n  \n  if vowel_counter\n    vowel = vowels[vowel_counter]\n\
    \  else\n    vowel = word[-1]\n  end\n  \n  if consonant_counter\n    consonant\
    \ = consonants[consonant_counter]\n  else\n    consonant = word[-1]\n  end\n \
    \ \n  if vowel.downcase == word.downcase && consonant.downcase == word[-1].downcase\n\
    \    return vowel\n  end\n  \n  if vowel.downcase == word.downcase && consonant.downcase\
    \ == word[-1].downcase\n    return consonant\n  end\nend\n</cell>\n<cell>", " \
    \ return ''\nend\n</pre>\n</div>", "  result = \"\"\n  vowels = %w[a e i o u]\n\
    \  if word.downcase =~ /[aeiou]/\n    pos = word.rindex(/[aeiou]/)\n    result\
    \ = vowels[pos-1]\n  else\n    result = \"\"\n  end\n  return result\nend", " \
    \ vowels = \"aeiouAEIOU\"\n  vowel_hash = {}\n  word.downcase.chars.each do |char|\n\
    \    if vowels.include?(char.to_s)\n      vowel_hash[char] = vowel_hash[char]\
    \ ? vowel_hash[char] + 1 : 1\n    end\n  end", "  # TODO: Write your code here\n\
    \  vowels = (\"A\", \"a\", \"E\", \"e\", \"I\", \"i\", \"O\", \"o\", \"U\", \"\
    u\")\n  \n  closest_vowel = \"\"\n  index = word.rindex(\"a\") \n  while index\
    \ >=0 and index < len(word) - 1:\n    vowels_index = word.rindex(vowels[index],\
    \ 1, index)\n    \n    if vowels_index == 0:\n      closest_vowel = word[index+1]\n\
    \    elif vowels_index == len(word) - 1:\n      closest_vowel = word[index-1]\n\
    \    else:\n      closest_vowel = word[index+1]\n    index = word.rindex(\"a\"\
    ) \n  return closest_vowel", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  vowel_index\
    \ = -1\n  consonant = 'bcdfghjklmnpqrstvwxyz'\n  consonant_index = -1\n  vowel_index\
    \ = 0\n  consonant_index = 0\n  while consonant_index < len(consonant)\n    if\
    \ consonant[consonant_index] == word[-1]\n      vowel_index += 1\n      consonant_index\
    \ += 2\n      break if consonant_index >= len(consonant)\n    end\n  end\n  if\
    \ vowel_index < 0 or consonant_index < 0\n    return ''\n  end\n  consonant_index\
    \ -= 2\n  while vowel_index < len(vowels)\n    if vowels[vowel_index] == word[-1]\n\
    \      vowel_index += 1\n      break if vowel_index >= len(vowels)\n    end\n\
    \  end\n  return word[consonant_index..-1] if vowel_index < consonant_index\n\
    \  return word[vowel_index..-1] if vowel_index > consonant_index\n  return ''\n\
    end", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"\
    O\", \"U\"]\n    vowels_count = 0\n    for i in word:\n        if i in vowels:\n\
    \            vowels_count += 1\n    if vowels_count > 2:\n        return \"\"\n\
    \    vowel_start = word.rfind(\"a\") if word.rfind(\"a\") != -1 else word.rfind(\"\
    E\")\n    vowel_end = word.rfind(\"e\") if word.rfind(\"e\") != -1 else word.rfind(\"\
    i\")\n    if vowel_start == -1 and vowel_end == -1:\n        return \"\"\n   \
    \ i = word.find(vowel_end)\n    if i != 0:\n        if word.find(vowel_start)\
    \ == -1:\n            return \"\"\n        i = word.find(vowel_end)\n    i = word.find(vowel_start)\n\
    \    if i != 0:\n        if word.find(vowel_start) == -1:\n            return\
    \ \"\"\n    return vowels[(vowels_count + vowel_end - vowel_start + 1) // 2]",
  "    # Write your code here\n    vowels = \"AEIOUaeiou\"\n    rev = []\n    vowels_len\
    \ = len(vowels)\n    i = 0\n    while i < len(word):\n        if word[i] == vowels[i]:\n\
    \            rev.append(word[i : i + vowels_len])\n        i += 1\n    if rev:\n\
    \        vow_len = int(len(rev[0]) / 2)\n        left_part = rev[0][vow_len:]\n\
    \        right_part = rev[0][:vow_len]\n        rev = [left_part] + [right_part]\n\
    \        vowels_len = int(len(rev[0]) / 2)\n        left_part = rev[1][vow_len:]\n\
    \        right_part = rev[1][:vow_len]\n        rev = [left_part] + [right_part]\n\
    \    return \"\".join(rev)\n    \nprint (get_closest_vowel(\"word\"))", "    #\
    \ write your code here\n    vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n    vowel_count\
    \ = word.count(\"aeiouy\")\n    if vowel_count > 0 and vowel_count <= vowels.count:\n\
    \        closest_vowel = word[-vowel_count - 1]\n    else:\n        closest_vowel\
    \ = \"\"\n    return closest_vowel", "  return \"\" if word.nil? \n  vowels =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowel_candidates = word.scan(/[aeiou]/)\n\
    \  vowel_candidates.each_with_index do |v, i|\n    i -= 1 if vowels.include?(v)\n\
    \    i -= 1 if i == 0\n    break if i == 0\n  end\n  vowel_candidates.each_with_index\
    \ do |v, i|\n    i -= 1 if vowels.include?(v)\n    break if i == 0\n  end\n  return\
    \ \"\" unless i == 0\n  return \"a\" if i == 0\n  return \"e\" if i == 1\n  return\
    \ \"i\" if i == 2\n  return \"o\" if i == 3\n  return \"u\" if i == 4\n  return\
    \ nil\nend\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"Cake\")\nget_closest_vowel(\"\
    caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"\
    caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"\
    cakes\")\nget_closest_vowel(\"caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"\
    caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"\
    CaKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"\
    Cakes\")\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"caKe\")\nget_closest_vowel(\"\
    cakes\")\nget_closest_vowel(\"caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"\
    cake\")\nget_closest_vowel(\"CaKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"\
    caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"caKe\")\nget_closest_vowel(\"\
    cakes\")\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"Cakes\")\nget_closest_vowel(\"\
    cake\")\nget_closest_vowel(\"caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"\
    caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"caKe\")\nget_closest_vowel(\"\
    cakes\")\nget_closest_vowel(\"cake\")\nget_closest_vowel(\"Cakes\")\nget_closest_vowel(\"\
    cake\")\nget_closest_vowel(\"caKe\")\nget_closest_vowel(\"cakes\")\nget_closest_vowel(\"\
    caKe\")\n", "  return word\nend\n</cell>\n<code language=julia-0.5>", "  # Solution\
    \ code here\n  vowels = ['a','e','i','o','u','y','ae','ai','oa','au','ay','ey','ie','io','oi','eu','yi','ay']\n\
    \  consonants = 'bdfghjklmnpqrstvwxyz'\n  vowel_flag = 0\n  for letter in word:\n\
    \    if letter in consonants:\n      if vowel_flag == 1:\n        return letter\n\
    \      else:\n        vowel_flag = 0\n    else:\n      if vowel_flag == 0:\n \
    \       return letter\n      else:\n        vowel_flag = 1\n  return \"\"\n  \n\
    \  ", "    # code here\nend", "  return ''\nend", "   return \n</cell>\n<cell>\n\
    get_closest_vowel(\"Hello\")\n</cell>\n<cell>", "  vowel = \"AEIOUYaeiouyAEIOUY\"\
    \n  consonant_list = [\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\",\
    \ \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\"\
    , \"Z\"]\n  vowel_counter = 0\n  for i in consonant_list do\n    if word.include?\
    \ i then\n      vowel_counter += 1\n    end\n  end\n  vowel_counter -= 1\n  result\
    \ = \"\"\n  if vowel_counter >= 2 then\n    vowel_counter = 0\n    word = word.upcase\n\
    \    vowel_counter = 0\n    for i in vowel do\n      if word.include? i then\n\
    \        vowel_counter += 1\n      end\n    end\n    vowel_counter -= 1\n    if\
    \ vowel_counter < 0 then\n      vowel_counter = -2\n    end\n    \n    if vowel_counter\
    \ >= 0 then\n      vowel = vowel[vowel_counter]\n      word = word.split(vowel)\n\
    \      result = \"vowel\"\n      vowel_counter = 0\n      for i in consonant_list\
    \ do\n        if word.include? i then\n          vowel_counter += 1\n        end\n\
    \      end\n      vowel_counter -= 1\n      if vowel_counter >= 0 then\n     \
    \   vowel = vowel[vowel_counter]\n        word = word.split(vowel)\n        result\
    \ = \"vowel\"\n        vowel_counter = 0\n        for i in vowel do\n        \
    \  if word.include? i then\n            vowel_counter += 1\n          end\n  \
    \      end\n        vowel_counter -= 1\n        if vowel_counter < 0 then\n  \
    \        vowel_counter = -2\n        end\n      end\n    end\n  end\n  result\n\
    end", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  vowel_count = word.count(\"\
    a\")\n  vowel_count += word.count(\"e\")\n  vowel_count += word.count(\"i\")\n\
    \  vowel_count += word.count(\"o\")\n  vowel_count += word.count(\"u\")", "  vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n  vowel_counter = 0\n  vowel_flag = True\n  for\
    \ letter in word\n    if letter == 'o'\n      vowel_counter += 1\n      break\n\
    \    if vowel_counter > 3\n      return ''\n    if vowel_counter == 2 and vowel_flag\n\
    \      vowel_counter = 0\n      vowel_flag = True\n      vowel_counter += 1\n\
    \    if vowel_counter < 2 and vowel_flag\n      vowel_counter = 0\n      vowel_flag\
    \ = False\n      vowel_counter += 1\n    if letter == vowels[0]\n      vowel_counter\
    \ += 1\n    if letter == vowels[-1]\n      vowel_counter += 1\n  return vowels[vowel_counter]\n\
    end\n</cell>\n<code language=julia-1.0>\nget_closest_vowel(\"hello\")\n</cell>\n\
    <code language=julia-1.0>\nget_closest_vowel(\"h\")\n</cell>\n<code language=julia-1.0>\n\
    get_closest_vowel(\"eh\")\n</cell>\n<code language=julia-1.0>\nget_closest_vowel(\"\
    ehlo\")\n</cell>\n<code language=julia-1.0>\nget_closest_vowel(\"uw\")\n</cell>\n\
    <code language=julia-1.0>\nget_closest_vowel(\"uweh\")\n</cell>\n<code language=julia-1.0>\n\
    get_closest_vowel(\"uwehh\")\n</cell>\n<text>\nDay 11: Shortest Path Problems",
  "   return ''\n</cell>\n<cell>", "    vowels = ['a', 'e', 'i', 'o', 'u']\n    \n\
    \    vowel_index = word.rindex(\"a\")\n    while vowel_index < word[-1]:\n   \
    \     vowel_index = word.rindex(\"a\", vowel_index+1)\n    vowel_before = word[vowel_index-1]\n\
    \    vowel_after = word[vowel_index+1]\n    \n    if vowel_before in vowels and\
    \ vowel_after in vowels:\n        return vowel_before + vowel_after\n    else:\n\
    \        return \"\"", "  vowels = %w(a e i o u)\n  vowels.each do |v|\n    return\
    \ v if (word.length >= v.length)\n  end", "    # write your code here\n    vowels=['a','e','i','o','u']\n\
    \    for i in word:\n        if i in vowels:\n            break\n    \n    if\
    \ i==vowels[-1]:\n        return \"\"\n    else:\n        return i\n    \n</cell>\n\
    <cell>", "return ''\nend", "    if word.endsWith('y') or word.endsWith('a')\n\
    \        return word.sub('y','')\n    else\n        return word\n    end\nend",
  "    # write your code here\n    return \"\"", "    vowel = string.ascii_lowercase[-1:]\n\
    \    vowel_pos = len(word)-1 \n    for i in vowel:\n        if word[vowel_pos].islower()\
    \ == True:\n            if vowel_pos <= len(word)-1:\n                vowel_pos-=1\n\
    \            else:\n                vowel_pos = len(word)-1\n        else:\n \
    \           break\n    return word[vowel_pos]", "  if word.starts_with?('b')\n\
    \    word = word[1..-1]\n  end\n  vowels = ['a','e','i','o','u','y']\n  result\
    \ = nil\n  word.scan(/[b-z]/).each do |letter|\n    distance = nil\n    vowels.each\
    \ do |vowel|\n      distance = word.rindex(vowel)\n      if distance != nil &&\
    \ distance > 0 \n        break\n      end\n    end\n    if distance != nil\n \
    \     result = vowel\n      break\n    end\n  end\n  return result\nend\nget_closest_vowel(\"\
    bob\")", "    return \"apple\"\nend\n</cell>\n<code language=julia-0.6>\nfunction\
    \ get_closest_vowel(word)\n    \n    vowels = [ \"a\", \"e\", \"i\", \"o\", \"\
    u\" ]\n    \n    positions = find_indices(word, vowels)\n    \n    if length(positions)\
    \ > 0\n        \n        prev_pos = positions[1]\n        \n        curr = 0\n\
    \        \n        if prev_pos == length(word)\n            \n            curr\
    \ = 0\n        else\n            \n            curr = prev_pos + 1\n        end\n\
    \        \n        while curr < length(word)\n            \n            curr =\
    \ next_letter(word, curr, positions)\n            \n            if curr \u2209\
    \ positions \n                \n                break\n            end\n     \
    \   end\n        \n        if curr \u2209 positions \n            \n         \
    \   return \"\"\n        end\n        \n    end\n    \n    return \"\"\nend",
  "    \n    # Your code goes here\n    return \"\"\n    \n    \n</cell>\n<cell>\n\
    get_closest_vowel('apple')\n</cell>\n<cell>\nget_closest_vowel('pineapple')\n\
    </cell>\n<cell>\nget_closest_vowel('apples')\n</cell>\n<text>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
