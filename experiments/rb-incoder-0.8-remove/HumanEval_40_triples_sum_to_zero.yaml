name: HumanEval_40_triples_sum_to_zero
language: rb
prompt: "# triples_sum_to_zero takes a list of integers as an input.\n# it returns\
  \ True if there are three distinct elements in the list that\n# sum to zero, and\
  \ False otherwise.\ndef triples_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n\
  \    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true,\
  \ candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2,\
  \ 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true,\
  \ candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n\
  \    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false,\
  \ candidate.call([100, 3, 5, -100]))\n  end\nend\n"
completions: ["  l.uniq.size == 3\nend", "  l.uniq!\n  l.sort!\n  three_zeros_counter\
    \ = 0\n  for i in 0..(l.size-2)\n    if l[i] + l[i+1] + l[i+2] == 0\n      three_zeros_counter\
    \ += 1\n    end\n  end\n  three_zeros_counter > 3\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nI think you meant `three_zeros_counter > 1`, as `3` is the number of zeros\
    \ found, not the number of triplets found.\n<|/ c |>\n<| c |>\nYou're right, I\
    \ messed up my counter. Fixed now.\n<|/ c |>\n<| c |>\nThe question is tagged\
    \ with `homework` and you haven't included an algorithm for how to solve the problem,\
    \ which seems to be what you intended. But I'll give a +1 anyway, because it's\
    \ helpful.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static void main (String[]\
    \ args)\n{\n    int[] arr = {5,6,7,8,9,10,11,12,13,14,15};\n    int sum = 0;\n\
    \    for (int i = 0; i < arr.length; i++) {\n        for (int j = i+1; j < arr.length;\
    \ j++) {\n            int sum = arr[i] + arr[j];\n            if (sum == 0) \n\
    \            {\n                System.out.println(\"sum is \" + sum);\n     \
    \           break;\n            }\n        }\n    }\n}\n</code>\n<|/ a tags=algorithm,java\
    \ |>\n<| c |>\nI think you should try explaining what you've done and why this\
    \ works.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic boolean isTripletsSum(int\
    \ arr[]) {\n    int sum = 0;\n    for (int i = 0; i < arr.length; i += 2) {\n\
    \        sum = arr[i] + arr[i+1];\n        if (sum == 0)\n            return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a tags=algorithm,java |>\n<| a dscore=0\
    \ |>\n<code>\npublic static void main(String args[]){\n    int[] arr={1,2,3};\n\
    \    System.out.println(isTripletSum(arr,3));\n}", "  return l.inject(:+) == l.uniq.size\n\
    end\n</code>\nYou can use the #sum method on Enumerable, which will give us the\
    \ sum of an enumerable (in this case an array):\n<code>\n> triples_sum_to_zero([1,\
    \ 2, 3])\n=> true\n> triples_sum_to_zero([3, 3, 3])\n=> false\n> triples_sum_to_zero([1,\
    \ 1, 2, 2])\n=> true\n</code>\nNow, you can write your triples_sum_to_zero method\
    \ as follows (using the #find method):\n<code>", "    triples_sum_to_zero_count\
    \ = 0\n    triples_sum_to_zero_found = 0\n    # iterate over the list\n    for\
    \ i in l\n        if triples_sum_to_zero_count < 2\n            # if the current\
    \ element is different from all the following ones\n            triples_sum_to_zero_count\
    \ += 1 unless triples_sum_to_zero_found == 3\n            triples_sum_to_zero_found\
    \ += 1 unless triples_sum_to_zero_found == 3\n        elsif triples_sum_to_zero_count\
    \ == 3\n            # if the current element is equal to the last element of the\
    \ list - break\n            break\n        end\n    end\n    # check if no triples\
    \ sum to zero\n    return triples_sum_to_zero_count == 0 unless triples_sum_to_zero_found\
    \ == 3\nend\n</code>\n<|/ a dscore=0 tags=ruby,sum,list |>\n<| c |>\nThanks for\
    \ your response. I've tried it out and it seems like it is working but i'm not\
    \ understanding why i don't have to write `i < 3`. Also what does `unless triples_sum_to_zero_found\
    \ == 3` do here? Thanks again!\n<|/ c |>\n<| c |>\nAhh I see, just tried it out\
    \ and that seems to do it. Thanks!\n<|/ c |>\n<| c |>\nThe \"unless\" keyword\
    \ is Ruby's way of saying \"if it evaluates to false\".\n<|/ c |>\n<| c |>\nThanks\
    \ very much\n<|/ c |>\n<| c |>\nI've added an answer that uses a recursive approach,\
    \ but I'm not 100% sure it's as efficient as yours. Could be wrong, but my gut\
    \ feeling is that it's more readable and easier to follow.\n<|/ c |>\n<| a dscore=0\
    \ |>\nUsing recursion:\n<code>", "  sum = 0\n  for x in l\n    sum += x\n    if\
    \ sum % 3 == 0\n      return true\n  end\n  return false\nend\n</code>\nI didn't\
    \ write any test for this code, since I didn't want you to learn the basics of\
    \ Ruby yet. But if you need help, feel free to ask me.\nEDIT: By the way, the\
    \ function you were asked to write was to find an element in an array that sums\
    \ to zero, where you were given a list of integers as an input.\n<|/ a tags=ruby,ruby-on-rails,arrays,loops\
    \ |>\n<| c |>\nHi Zack, thanks for helping. I did actually want to find an element\
    \ in an array that sums to zero where I was given an input of integers. My mistake,\
    \ thanks for the heads up though\n<|/ c |>\n<| c |>\nI've edited my answer. Try\
    \ it out and let me know if it works for you.\n<|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails,arrays,loops\
    \ |>\n<code>", "  l.each do |a|\n    l.each do |b|\n      l.each do |c|\n    \
    \    return false if a+b+c == 0 || a+b+c+a == 0 || b+c+a == 0\n      end\n   \
    \ end\n  end\n  true\nend", "  l.sort\n  i = 0\n  while i < l.length\n    if l[i]\
    \ == l[i+1] and l[i] == l[i+2]\n      return False\n    i += 1\n  return True\n\
    end", "    l.inject(0) {|n, sum| n + sum > 0 }\nend\n</code>\nThen we have:\n\
    <code>", "    l.uniq!\n    return l.count(l[0]) > 1 and l.count(l[1]) > 1 and\
    \ l.count(l[2]) > 0\nend", "  l.uniq!\n  (l.count(l[0]) + l.count(l[1]) + l.count(l[2]))\
    \ == 3\nend", "  l.sort! # makes a copy if l is not already sorted.\n  sum = 0\n\
    \  for i in 0..(l.length-1)\n    sum += l[i]\n    if sum == 0\n      return true\n\
    \  return false\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays |>\n<| a dscore=0\
    \ tags=ruby,algorithm,arrays |>\nThe brute force method would be a brute-force\
    \ solution, although the solution in ruby would be more elegant.\n<code>\nsums_to_zero?\
    \ = [0, 3, 6, 9, 12, 15]", "  l.uniq.count == 3\nend", "    l.each_with_index\
    \ do |element, index|\n        if element == l[index+1] + l[index+2] + l[index+3]\n\
    \            return False\n        else\n            return True\n        end\n\
    \    end\nend", "  # Write your code here\n  return true\nend", "  l.sort!\n \
    \ return true if l.group_by {|x| x.gcd(3).zero?}.keys.length == 3\n  return false\n\
    end", "  return l.inject(:+) == 0 && l.uniq.size == 3\nend\n</cell>\n<cell>",
  "  l.each { |i| return true if l.count(i) == 3 }\n  false\nend", "  threeSum = 0\n\
    \  threeSums = []\n  threeSums.push(l[0]+l[1]+l[2])\n  threeSums.push(l[0]+l[2]+l[1])\n\
    \  threeSums.push(l[0]+l[1]+l[2])\n  threeSums.push(l[0]+l[2]+l[1])\n  threeSums.push(l[0]+l[1]+l[2])\n\
    \  threeSums.push(l[0]+l[2]+l[1])\n  threeSums.push(l[0]+l[1]+l[2])\n  threeSums.push(l[0]+l[2]+l[1])\n\
    \  threeSums.push(l[0]+l[1]+l[2])\n  threeSums.push(l[0]+l[2]+l[1])\n  threeSums.push(l[0]+l[1]+l[2])\n\
    \  threeSums.push(l[0]+l[2]+l[1])\n  threeSums.push(l[0]+l[1]+l[2])\n  threeSums.push(l[0]+l[2]+l[1])\n\
    \  threeSums.push(l[0]+l[1]+l[2])\n  threeSums.push(l[0]+l[2]+l[1])", "  l.sort!\n\
    \  return l.reduce(0) { |t,(n1,n2,n3)| t + (n1 + n2 + n3) == 0 }\nend", "    l.each\
    \ do |i|\n        l.each do |j|\n            l.each do |k|\n                if\
    \  i == j and j == k and i != 0\n                    return true\n           \
    \     end\n            end\n        end\n    end\n    return false\nend", "  l.sort.each\
    \ do |i|\n    next_three = []\n    break if i >= 3\n    (0...i).each do |j|\n\
    \      next_three.push( l[j] )\n      break if j > 0 && l[j] == l[j-1]\n    end\n\
    \    next if next_three.size == 3\n    break true if next_three.size == 0\n  end\n\
    \  false\nend", "    i = 0\n    while i < l.length\n        if l.include? i &&\
    \ (i+1) == l.length || l[i] == l[i+1] || l[i] == l[i-1]\n            l.delete_at(i)\n\
    \            return true\n        end\n        i += 1\n    end\n    l.delete_at(i-1)\n\
    \    return false\nend", "  l.uniq\n  l.all? { |n| n.even? }\n  l.size == 3\n\
    end", "  l.sort!\n  l.reduce([false,false,false]) do |sum, value|\n    sum +=\
    \ value\n    sum < 3 ? true : false\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,enumerable\
    \ |>\n<| a dscore=1 tags=ruby,arrays,enumerable |>\n<code>", "  count = 0\n  l.each\
    \ do |p|\n    count += p\n    if count > 2\n      return false\n    end\n  end\n\
    \  true\nend\n</code>\nThe first function takes a list of integers as an input,\
    \ and checks how many distinct elements it has. The second function takes a list\
    \ of integers as an input, and checks how many distinct elements it has, by summing\
    \ them all together. \n<code>", "    return l.count(l.count(l[0])) == 3\nend\n\
    </code>\nThe above is equivalent to the following which also runs in O(n) time:\n\
    <code>", "  l.each_with_index do |x, i|\n    l.delete_at(i)\n    return false\
    \ if l.length < 3\n  end\n  return true\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ is good, but you might want to consider changing your algorithm to do more work\
    \ in the loop: rather than removing an element from the list, you might want to\
    \ count how many times it appears consecutively and divide that count by three\
    \ to determine whether there are three consecutive elements whose sum is zero.\n\
    <|/ c |>\n<| c |>\nYes, this algorithm would be more elegant and efficient.\n\
    <|/ c |>\n<| a dscore=0 |>\nMy answer is similar to the one by but it is much\
    \ more efficient.\n<code>", "  l.sort\n  l.each_cons(3) do |tri|\n    if tri.inject(0){|s,e|\
    \ s + e } != 0\n      return false\n    end\n  end\n  true\nend", "  if l.count\
    \ < 3\n    return false\n  end", "  l.uniq!\n  l.sort!\n  l.each_with_index do\
    \ |i, index|\n    index += 1\n    if index == 1 && i == l[0] + l[1] + l[2]\n \
    \     return true\n    elsif index == 2 && i == l[0] + l[1] + l[2] + l[3]\n  \
    \    return true\n    elsif index == 3 and i == l[0] + l[1] + l[2] + l[3] + l[4]\n\
    \      return true\n    elsif index == 4 and i == l[0] + l[1] + l[2] + l[3] +\
    \ l[4] + l[5]\n      return true\n    elsif index == 5 and i == l[0] + l[1] +\
    \ l[2] + l[3] + l[4] + l[5] + l[6]\n      return true\n    end\n  end\n  false\n\
    end", "    \n    # initialize a variable i to zero, j to zero, and k to zero\n\
    \    i = 0\n    j = 0\n    k = 0\n    \n    # while there are more elements in\
    \ the list\n    while i < len(l)\n        \n        # if the current element's\
    \ value is zero\n        if l[i] == 0\n        \n            # the next element\
    \ is the current element + the one\n            # that is next to it (moving both\
    \ by one each time)\n            j = l[i] + 1\n            \n            # if\
    \ the current element's value is zero\n            if l[j] == 0\n            \n\
    \                # the previous element's value is also zero\n               \
    \ if l[k] == 0\n                \n                    # the three elements are\
    \ distinct\n                    return False\n                \n             \
    \   # the previous element's value is not zero\n                else\n       \
    \         \n                    # the three elements are distinct\n          \
    \          return True\n            \n            # the current element's value\
    \ is not zero\n            else\n            \n                # the three elements\
    \ are distinct\n                return True\n            \n            # move\
    \ to the next element and increment both i and j\n            k = k + 1\n    \
    \    \n        # increment i\n        i = i + 1\n    \n    # there are no three\
    \ distinct elements in the list that\n    # sum to zero\n    return False\n  \
    \  \nprint(triples_sum_to_zero([3,-4,7,0,6]))\nprint(triples_sum_to_zero([4,-5,6,2,3]))\n\
    print(triples_sum_to_zero([-1,-3,4,-5,6]))\nprint(triples_sum_to_zero([-3,-4,5,-6,2]))\n\
    print(triples_sum_to_zero([-2,-4,-5,-6,-7,-8]))\n</cell>\n<cell>", "  l.each_with_index\
    \ do |el, i|\n    if i != 0 and i != l.length-1 && i != l.length-2\n      i1 =\
    \ i-1\n      i2 = i+1\n      i3 = i-2\n      i4 = i+2\n      if l[i1]+l[i2]+l[i3]\
    \ == 0 && l[i4]+l[i1]+l[i2]+l[i3] == 0 && l[i4]+l[i4]+l[i1]+l[i2]+l[i3] == 0\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "    l.each\
    \ do |x|\n        l.each do |y|\n            l.each do |z|\n                if\
    \ x + y + z == 0 then return true\n                end \n            end \n  \
    \      end \n    end\n    return false \nend\n</code>\n<|/ a tags=ruby,algorithm,recursion\
    \ |>\n<| c |>\nCan you explain? I am not very familiar with ruby :)\n<|/ c |>\n\
    <| c |>\n: I added some explanation, hope that helps.\n<|/ c |>\n<| a tags=ruby,algorithm,recursion\
    \ dscore=2 |>\n<code>", "  l.inject(:+) == 0 && l.inject(:+) == 0 && l.inject(:+)\
    \ == 0\nend\n</cell>\n<cell>\ntriples_sum_to_zero([1,2,3,4,5,6]) # => true\ntriples_sum_to_zero([1,2,3,4,5,7,9])\
    \ # => false\n</cell>\n<text>\nGiven a triplets list like the ones above, create\
    \ another triplets list that only contains triplets with 3 distinct elements that\
    \ sum to zero.", "  triples_sum = 0\n  for i in l\n    triples_sum = triples_sum\
    \ + i\n  return triples_sum == 0\nend", "  return true if l.uniq.length == 3\n\
    end\n</cell>\n<cell>\ntriples_sum_to_zero([0,1,2])\n</cell>\n<cell>", "  \n  #\
    \ initialize counter\n  sum = 0\n  \n  # iterate through the list comparing the\
    \ current number to the sum \n  # of the previous three numbers\n  for i in 0...(3-1)\n\
    \    sum = sum + l[i]\n    if sum == 0 \n      return true\n    end\n  end\n \
    \ \n  return false\nend\n</code>\n<|/ a |>\n<| a tags=ruby dscore=2 |>\nI think\
    \ this is a great exercise in using a recursive function.\n<code>", "  l.each\
    \ do |x|\n    l.each do |y|\n      l.each do |z|\n        return x+y+z == 0\n\
    \      end\n    end\n  end\nend\n</code>\nWe can now test our program:\n<code>\n\
    >> l = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\",\
    \ \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"]\n=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n>> triples_sum_to_zero(l)\n\
    => true\n>> l = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"1\", \"2\", \"3\"]\n=> [\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\", \"1\", \"2\", \"3\"]\n>> triples_sum_to_zero(l)\n=> false\n\
    </code>\nThis program will test every possible triple combination, which for large\
    \ lists will take an eternity to compute. If you have hundreds of thousands of\
    \ triplets, you will likely have to look at a more efficient algorithm such as\
    \ quickselect.\n<|/ a |>\n<| c |>\nI'm getting `undefined method 'each' for nil:NilClass`\
    \ for the last line when I try it.\n<|/ c |>\n<| c |>\nAh, yes. My apologies,\
    \ I forgot that the last line should have been `return true`. Fixed, thanks.\n\
    <|/ c |>\n<| c |>\nWhy does this algorithm scale better to larger numbers than\
    \ O(N^3)? Can you elaborate?\n<|/ c |>\n<| c |>\nIt can scale better than `O(N^3)`\
    \ when the number of triples is sufficiently large. In my experience, the more\
    \ \"triples\" you have the better the performance will be, since there is some\
    \ sort of tradeoff between memory requirements and computation time. For example,\
    \ a long list of `[\"1\", \"2\", \"3\"]` would require O(N^2) memory space, and\
    \ O(N^3) computation time. A list of only `\"1\"` would require O(N) memory space,\
    \ and O(N^2) computation ", "  return l.inject(:+) == 0 || l.inject(:+) == -3\
    \ ? true : false\nend\n</code>\nThe method should take an list of integers as\
    \ an argument and return True if the list has three distinct elements that sum\
    \ to zero, and False otherwise. \n<code>\ntriples_sum_to_zero([1,0,3]) # => true\n\
    triples_sum_to_zero([1,-3,0]) # => false\ntriples_sum_to_zero([2,-4,0]) # => false\n\
    </code>\n<|/ q tags=ruby,arrays,methods,boolean |>\n<| c |>\nWhat's the question?\
    \ What have you tried so far? What is your issue with it? Do you have a specific\
    \ question about some part of your implementation?\n<|/ c |>\n<| c |>\nSorry about\
    \ that! I edited the question for clarity.\n<|/ c |>\n<| c |>\nHi SJC. I think\
    \ people will be more inclined to help you if you demonstrate that you've made\
    \ some effort yourself. If you've made some effort I bet you wouldn't need to\
    \ ask the question in the first place. I'd suggest reading [How do I ask a good\
    \ question?](https://stackoverflow.com/help/how-to-ask) then come back and edit\
    \ your question with some effort. Please read \"[ask]\", including the links at\
    \ the bottom, and edit your question to follow the suggestions. Thanks.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "    triples = l.sort.each_cons(3).select { |triple|\
    \ triple.inject(:+) == 0 }\n    triples.none? { |triple| triple.size > 2 }\nend",
  "\tfor i in 0...(l-1)\n\t\tsum = 0\n\t\tfor (j,k) in 0...(l-1)\n\t\t\tif i != j\
    \ && i != k && (i+j+k)==3\n\t\t\t\tsum = sum + l[j]*l[k]*l[i]\n\t\t\t\tbreak\n\
    \t\tprint sum\n\t\tif sum == 0\n\t\t\treturn true\n\treturn false\nend\nprint\
    \ triples_sum_to_zero([1,2,3,0,0])\nprint triples_sum_to_zero([1,0,2,0,0])\nprint\
    \ triples_sum_to_zero([1,0,2,0,0])\nprint triples_sum_to_zero([1,0,2,0,1])\nprint\
    \ triples_sum_to_zero([1,0,2,0,2])\nprint triples_sum_to_zero([1,0,2,0,3])\nprint\
    \ triples_sum_to_zero([1,0,2,0,4])\nprint triples_sum_to_zero([1,0,2,0,5])\nprint\
    \ triples_sum_to_zero([1,0,2,0,6])\nprint triples_sum_to_zero([1,0,2,0,7])\nprint\
    \ triples_sum_to_zero([1,0,2,0,8])\nprint triples_sum_to_zero([1,0,2,0,9])\nprint\
    \ triples_sum_to_zero([1,0,2,0,10])\nprint triples_sum_to_zero([1,0,2,0,11])\n\
    print triples_sum_to_zero([1,0,2,0,12])\nprint triples_sum_to_zero([1,0,2,0,13])\n\
    print triples_sum_to_zero([1,0,2,0,14])\nprint triples_sum_to_zero([1,0,2,0,15])\n\
    print triples_sum_to_zero([1,0,2,0,16])\nprint triples_sum_to_zero([1,0,2,0,17])\n\
    print triples_sum_to_zero([1,0,2,0,18])\nprint triples_sum_to_zero([1,0,2,0,19])\n\
    print triples_sum_to_zero([1,0,2,0,20])\nprint triples_sum_to_zero([1,0,2,0,21])\n\
    print triples_sum_to_zero([1,0,2,0,22])\nprint triples_sum_to_zero([1,0,2,0,23])\n\
    print triples_sum_to_zero([1,0,2,0,24])\nprint triples_sum_to_zero([1,0,2,0,25])\n\
    print triples_sum_to_zero([1,0,2,0,26])\nprint triples_sum_to_zero([1,0,2,0,27])\n\
    print triples_sum_to_zero([1,0,2,0,28])\nprint triples_sum_to_zero([1,0,2,0,29])\n\
    print triples_sum_to_zero([1,0,2,0,30])\nprint triples_sum_to_zero([1,0,2,0,31])\n\
    print triples_sum_to_zero([1,0,2,0,32])\nprint triple", "  l.sort\n  return l.reduce(:==)\
    \ == 0 && l.uniq.length == 3\nend", "  s.times do\n    triples = l.zip(l.drop(l.size\
    \ - 3).zip(l.drop(l.size - 2).zip(l.drop(l.size - 1).each{|i| i + 1 == 0})))\n\
    \    break if triples.any? {|triple_sum| triple_sum[0] == triple_sum[1] && triple_sum[1]\
    \ == 0}\n  end\n  triples.any? {|triple_sum| triple_sum[0] == triple_sum[1] &&\
    \ triple_sum[1] == 0}\nend", "  return l.count(l.find_index {|x| x.zero? }) ==\
    \ 3\nend", "  three_sums = 0\n  three_sums += l.length\n  three_sums += l.length\n\
    \  three_sums += l.length\n  three_sums.times do |i|\n    for j in 0...i\n   \
    \   if l[j] == l[i] + l[j+1] + l[j+2]\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "  l.sort!\n  (l[0] + l[1] + l[2]) == 0 \nend",
  "    l.sort \n    l.each_with_index do |n, idx|\n        if n == 3 && idx != 0\n\
    \            return false\n        end\n    end\n    true\nend\n</code>\n<code>",
  "  # write your code in Ruby\n  \n  triple = (l[0], l[1], l[2])\n  return true if\
    \ triple.all? { |i| i % 3 == 0 }\n  return false\nend", "  l.map {|x| x.to_i}\n\
    \  l = l.uniq\n  l.sort.uniq.length == 3 && l.all?{|x| l.index(x)}\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,algorithm dscore=0 |>\n<| a dscore=0 |>\nMy ruby\
    \ is a little rusty, but this is how I would do it:\n<code>", "  return l.inject(true)\
    \ do |s, el|\n    s &&= (el == 1 || el == 0)\n  end\nend", "  l.sort.each do |num|\n\
    \    l.delete(num)\n    l.sort.each do |num2|\n      l.delete(num2)\n      l.sort.each\
    \ do |num3|\n        return true if num + num2 + num3 == 0\n      end\n    end\n\
    \  end\n  return false\nend\n</cell>\n<cell>", "  return l == [0, *l.to_a, 0].to_a\
    \ && l.uniq.length == 2\nend", "  l.each_with_index do |x,i|\n    l.delete_at(i)\
    \ if x+l[i] > l[i]\n    break if l.size < 3\n  end\n  l == nil\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYou don't need to `break` if you know that `delete_at` will\
    \ remove the element at the given index.\n<|/ c |>\n<| c |>\nI forgot about `delete_at`\
    \ so thanks for pointing it out\n<|/ c |>\n<| c |>\n`delete_at` removes the first\
    \ element that matches the specified value, so it is useless in this case. `delete_if`\
    \ is better choice here, but unfortunately only in Ruby 1.9.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere's one way to do it:\n<code>\nl = [1, 2, -9, -3]\n</code>\nSort the\
    \ list:\n<code>\nl.sort\n</code>\nNow find the index of the first zero:\n<code>\n\
    i = l.index { |e| e == 0 }\n</code>\nFind the index of the first pair of consecutive\
    \ zeroes:\n<code>\nj = l.index {|e| e == 0 && l.index(e + 1) != i }\n</code>\n\
    Return true if there are three elements in the list whose sum is zero between\
    \ the indexes i and j:\n<code>\nj - i + 1 == 3\n</code>\nOr you can do it all\
    \ in one line:\n<code>\n[l.sort, l.index {|e| e == 0}, l.index {|e| e == 0 &&\
    \ l.index(e + 1) != i}].all? {|e| e - i + 1 == 3}\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  l.reduce(:+) == 0\nend", "\ttriple_sum = 0\n\
    \tfor i in l\n\t\tif triple_sum + i > triple_sum\n\t\t\treturn false\n\t\ttriple_sum\
    \ += i\n\tend\n\treturn true\nend", "  l.sort\n  l.each_with_index do |n,i|\n\
    \    return false if i == (l.length - 2)\n    return true if i == 1\n    return\
    \ false if n == l[i-2] + l[i-1] + l[i]\n  end\n  return true\nend", "  l.uniq\n\
    \  threes = l.select{|e| e.to_s.split(//).inject(0) do |sum, item|\n    sum +=\
    \ item.to_i\n    sum\n  end==3}\n  return threes.size >= 3\nend", "  if l.length\
    \ < 3\n    return false\n  l.uniq!\n  for i in 0...l.length\n    if l[i] > 0 &&\
    \ l[(i+1)..-1].sum(&:nonzero?).length < 3\n      return false\n    end\n  end\n\
    \  return true\nend", "  l.group_by {|x| x % 3 }.each do |k, v|\n    p v\n   \
    \ if v.size < 2\n      return false\n    end\n    if v.size > 3\n      return\
    \ true\n    end\n  end\n  false\nend", "  return !l.select { |x| l.count(x) ==\
    \ 3 }.any?\nend", "    triples = 0\n    zeroes = 0\n    l.each do |x|\n      \
    \  if x+x+x == 0\n            triples += 1\n        else\n            zeroes +=\
    \ 1\n        end\n    end", "  l.uniq!\n  l.count > 2 &&\n  l.all? { |i| l.count(i)\
    \ == 3 }\nend", "    l.uniq!\n    return l.size == 3 and l.uniq.sort == [0, -1,\
    \ 1, -1]\nend\n</cell>\n<code language=julia-1.5>", "    l.sort! # sort the list\
    \ so we can efficiently compare adjacent elements\n    # to see if three elements\
    \ in the list sum to zero\n    i = 0 # index into the list\n    while i < l.length\
    \ do\n        if l[i] + l[i+1] + l[i+2] != 0 then return false # return false\
    \ if three\n        i += 1 # move forward in the list\n    end\n    return true\
    \ # return true if no triples in the list sum to zero\nend\n</code>\nI find that\
    \ using sort is better than using each to visit all elements in the list.  That's\
    \ because sort iterates over each element in the list and compares it to its neighbor,\
    \ while each just visits each one in turn and then moves onto the next one (but\
    \ still visits every element).  So sorting is O(nlogn) while using each is O(n).\n\
    <|/ a |>\n<| a |>\n<code>", "\ttriple = l.dup\n\tfor i in 0...3\n\t\ttriple.select!\
    \ {|x| x[i] == (triple.count(i) + 1)}\n\t\treturn triple.include?(0)\n\tend\n\
    end", "    l.uniq! # remove any duplicates\n    l.each_with_index do |n, i|\n\
    \        l.slice!(i, i + 3) if n.zero?\n    end\n    l.size == 3\nend\n</code>\n\
    Now we can do this:\n<code>\nrequire 'set'", "  sum = 0\n  l.each do |x|\n   \
    \ sum += x\n  end\n  return true if l==[] || sum%3 ==0\n  return false\nend\n\
    </code>\n<|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm |>\nAn alternative\
    \ to Eric Gray's answer:\n<code>\nrequire 'set'", "  sum_to_zero = 0\n  l.each\
    \ do |i|\n    sum_to_zero += i\n    sum_to_zero -= 1\n    sum_to_zero += 1\n \
    \ end\n  return false unless sum_to_zero == 0\n  return true\nend\n</code>\nThe\
    \ trick is in how we iterate through our list to make sure we only ever sum the\
    \ value once. We need to take advantage of the fact that we're not actually summing\
    \ anything until we find a 3 or greater value. This means we can just use that\
    \ fact to find our 3 values with no further processing.\n<code>", "  sum_to_zero\
    \ = false\n  if l.size <= 2\n    sum_to_zero = true\n    return sum_to_zero\n\
    \  end\n  \n  l.each_with_index do |value, index|\n    value_next = value[index\
    \ + 1]\n    value_prev = value[index - 2]\n    \n    if value_next == value_prev\n\
    \      sum_to_zero = false\n      return sum_to_zero\n    end\n  end\n  sum_to_zero\
    \ = true\n  return sum_to_zero\nend", "    l.sort!\n    l.sort!", "    l.sort!\n\
    \    return l.inject(:+) == 0\nend\n</cell>\n<code language=julia-1.6>", "  return\
    \ l.count(l[0]) == 3 and l.count(l[1]) == 3 and l.count(l[2]) == 0\nend", "  l.sort.reverse!\n\
    \  for i in 0...2\n    return false if l[i] == l[i+1] || l[i] == l[i+2]\n    break\
    \ if l[i/2] + l[i/2-1] == 0\n  end\n  true\nend", "  l.sort.each do |e|\n    next\
    \ unless e > 1\n    return true if e == 0\n    return false if e + 1 == l.size\n\
    \  end\n  return true\nend", "    l.sort!\n    return l.length == 3 && l.reduce(:+)\
    \ == 0\nend", "  sum = 0\n  for i in l\n    sum += i\n    if sum > 0\n      false\n\
    \    else sum < 0\n      false\n    else sum == 0\n      true\n    end\n  end\n\
    end\n</code>\nHere is a sample run:\n<code>\n1.9.3-p545 :003 > l = [1,2,3,4,5,6]\n\
    \ => [1, 2, 3, 4, 5, 6] \n1.9.3-p545 :004 > triples_sum_to_zero(l)\n => true \n\
    1.9.3-p545 :005 > l = [1,3,5,4,6,7,8]\n => [1, 3, 5, 4, 6, 7, 8] \n1.9.3-p545\
    \ :006 > triples_sum_to_zero(l)\n => false \n1.9.3-p545 :007 > l = [1,2,3,4,5,6,7,8]\n\
    \ => [1, 2, 3, 4, 5, 6, 7, 8] \n1.9.3-p545 :008 > triples_sum_to_zero(l)\n =>\
    \ false \n</code>\n<|/ a dscore=0 tags=ruby,arrays,algorithm |>\n<| a dscore=0\
    \ |>\n<code>", "  return l.count(l[0]) == 3 and l.count(l[1]) == 3 and l.count(l[2])\
    \ == 0\nend\n</cell>\n<cell>", "  l.inject(0){|sum,x| sum + x } == 0 && l.size\
    \ == 3\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nI thought about this\
    \ some more and, at least in Ruby 1.8, it looks like you can use a method like\
    \ \"inject\" on an array and get a count of distinct elements without having to\
    \ use any loops.\nSomething like this:\n<code>\nl = [1,2,3,4,5,6]\nl.inject(0)\
    \ { |sum, i| sum + i }\n=> 30\n</code>\nFrom the docs:", "  l.uniq.sort.each_with_index\
    \ do |n, i|\n    next if i == 0\n    l.drop(i).each_with_index do |n2, j|\n  \
    \    next if j == 0\n      return true if n+n == n2\n    end\n  end\n  return\
    \ false\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=1 |>\n<| a dscore=0\
    \ tags=ruby,ruby-on-rails |>\n<code>\nrequire 'set'", "  l.reduce(0) {|p, c| p\
    \ + c } == 0 && l.size == 3\nend", "  # This code assumes that there is at least\
    \ one element.\n  l.length >= 3 || return false\n  # This code assumes that the\
    \ list is sorted.\n  prev_sum = nil\n  curSum = 0\n  curSum == 0 || return false\n\
    \  l.each do |x|\n    curSum += x\n    # curSum is zero means we've found three\
    \ zeros in the list.\n    curSum == 0 && return true\n    prev_sum = curSum\n\
    \  end\n  return false\nend", "  return triples_sum_to_zero_helper(l, 3, 0).nonzero?\n\
    end", "  l = l.sort\n  (l[0] - l[1] + l[2]) == 0 or (l[0] + l[1] + l[2]) == 0\n\
    end", "  l.uniq!\n  l.each_cons(2) do |t, n|\n    return true if t[0].zero? and\
    \ t[1].zero? and t[2].zero?\n  end\n  false\nend", "    # your code goes here\n\
    \    count = 0\n    sum = 0\n    for i in l\n        if i.odd?\n            if\
    \ sum == 0\n                sum++\n            else\n                sum--\n \
    \           end\n        end\n        if sum == 0\n            count += 1\n  \
    \      end\n    end\n    if count == 3\n        return true\n    end\n    return\
    \ false\nend\n</code>\n<|/ q tags=ruby dscore=0 |>\n<| c |>\nThis is better suited\
    \ for http://codegolf.stackexchange.com/\n<|/ c |>\n<| c |>\nThanks for your help.\
    \ I will post there next time I have a question. I was hoping to find out why\
    \ the code I have is not working, so I can learn from my mistakes.\n<|/ c |>\n\
    <| c |>\nYou're really close to getting the answer. The only thing that bothers\
    \ me is you don't seem to have made any effort to solve the problem yourself.\
    \ At the very least you should have added an `else` clause for the last line of\
    \ your `if count > 1` block. What is your question?\n<|/ c |>\n<| c |>\nWhat is\
    \ your question? I did not think it deserved a negative score\n<|/ c |>\n<| c\
    \ |>\nI still don't see how you are getting an \"unused variable\" warning for\
    \ `l` in your `triples_sum_to_zero` method.\n<|/ c |>\n<| a dscore=2 |>\nThis\
    \ is what you can do to achieve your task:\n<code>", "  l.uniq! # remove duplicates\n\
    \  l.sort! # sort list\n  l.size == 3 # check list size\n  l.each { |i| l.shift\
    \ } # remove first element\n  l.each_cons(3).any? { |a,b,c| a+b+c==0 }\nend",
  "  # write your code here\n  l.each_with_index do |n,i|\n    l.each_with_index do\
    \ |t,j|\n      l.each_with_index do |u,k|\n        if n == t+u+k\n          return\
    \ false\n        end\n      end\n    end\n  end\n  return true\nend", "  l.each\
    \ do |num|\n    if num % 3 == 0\n      break\n    else\n      return false\n \
    \   end\n  end\n  return true\nend", "  l.each_with_index do |number, index|\n\
    \    if index == 0\n      return false if number == 0\n      return false if number\
    \ == 1\n    end\n    next if number > 2\n    return false if l.slice!(index -\
    \ 1) # this deletes the value at index\n    return false if l.slice!(index - 1)\
    \ # this deletes the value at index\n    return false if l.slice!(index - 1) #\
    \ this deletes the value at index\n    next\n  end\n  return true\nend", "  sum_to_zero\
    \ = false\n  l.each do |number|\n    if (number%3==0)\n      sum_to_zero = true\n\
    \    end\n  end\n  return sum_to_zero\nend\n</code>\nThis program is straightforward,\
    \ but since I'm a beginner in Ruby I thought I'd share it here in case others\
    \ find it useful. \nI realize there might be a better way to write this. I didn't\
    \ want to learn how to do that at this point as I wanted to get an understanding\
    \ of how to program so I came up with this solution.\n<|/ a |>\n<| a |>\nJust\
    \ in case you're wondering about this from Ruby 2.0 onwards, there is a very concise\
    \ way to do it: \n<code>\n(0 .. 99).to_a.all? { |n| n.zero? }\n</code>\n<|/ a\
    \ tags=ruby,sum-of-digits,ruby-on-rails dscore=4 |>\n<| c |>\nYes. I wasn't aware\
    \ of that!\n<|/ c |>\n<| c |>\n`[1,2,3].all?(&:even?)` returns `true` but `[1,2,3].all?(&:even?)\
    \ == true` returns `false`. See [this SO question](http://stackoverflow.com/questions/9674754/why-does-ruby-return-truth-when-passing-a-method-object-to-its-method-does-not).\
    \ So this is more Ruby-like than mine.\n<|/ c |>\n<| c |>\nIt has nothing to do\
    \ with `even?`, it's that `all?` will always return `true` if the block returns\
    \ `true` for each element - so your `sum_to_zero?` method will return `true` even\
    \ if the first and last element of the array are non-zero - so you need an extra\
    \ line inside the block to check if the array is empty first.\n<|/ c |>\n<| c\
    \ |>\n`([1,2,3].all?(&:even?) == true)` returns `false` for me in Ruby 2.1.4,\
    \ but `true` when I run it on rubysandbox.org, although I should probably test\
    \ with different versions and Ruby versions, as I don't really understand what's\
    \ going on. Thanks.\n<|/ c |>\n<| a dscore=3 |>\nI know I'm pretty late to this\
    \ party, but I thought I'd share what I came up with after learning Ruby.\n<code>",
  "  return triples_sum_to_zero_helper(l).any?\nend", "  l.sort! # so we don't have\
    \ to worry about list order\n  return l.inject {|sum, el| sum == 0 || sum + el\
    \ == 0}\nend", "  # Your code here!\n  return false\nend", "  n = 0\n  while n\
    \ < l.size\n    sum = l[n] + l[n + 1] + l[n + 2]\n    if sum == 0\n      return\
    \ true\n    n += 3\n  end\n  return false\nend", "    a, b = l[0], l[1]\n    return\
    \ (a + b + b == 0) and ((a != 0) == (b != 0))\nend\n</code>\nThe function triples_sum_to_zero\
    \ is defined above. \nThe function sum_list takes a list of integers as an input.\
    \ \nIt sums the elements in the list. \nIf the list is not empty, the function\
    \ calls sum_list with the first two elements of the list.\nThe function returns\
    \ True if all elements in the list sum to zero, and False otherwise.\n<code>",
  "  l.sort\n  for i in 0...l.length-1\n    for j in i+1...l.length\n      if triple(l,\
    \ i, j) && (l-i+1)*(l-j+2)+l[j] == 0\n        return true\n    end\n  end\n  return\
    \ false\nend\n</code>\n<|/ a dscore=4 tags=language-agnostic,algorithm,time-complexity,dynamic-programming\
    \ |>\n<| a tags=language-agnostic,algorithm,time-complexity,dynamic-programming\
    \ |>\nThis can be solved using dynamic programming. Here's how you can solve the\
    \ problem using dynamic programming.\nLet f(i, j) be the number of pairs of integers\
    \ in {1,...,n} that sum to j - i.\nThen the answer is f(n, n) where f(n,0) is\
    \ the number of pairs of integers that sum to zero.\nThe base case is f(1, n).\n\
    <|/ a dscore=3 |>\n<| c |>\nThis is not O(n), but O(n log n).\n<|/ c |>\n<| a\
    \ dscore=3 tags=language-agnostic,algorithm,time-complexity,dynamic-programming\
    \ |>\nHere's a recursive solution in Ruby which should be fast enough:\n<code>",
  "    l = l.sort\n    triples_sum_to_zero = false\n    i = 0\n    sum = 0\n    while\
    \ i < l.length\n        if i == l.length - 1\n            if l[i] + l[i] == 0\
    \ and l[i] != 0\n                triples_sum_to_zero = true\n                break\n\
    \            else\n                i += 1\n                next\n        else\n\
    \            sum = sum + l[i]\n            if sum == 0 && l[i] != 0\n        \
    \        triples_sum_to_zero = true\n                break\n            i += 1\n\
    \    end\nend", "  # Write your logic here\n  return l.reduce(:+) == 0 \nend",
  "  if l.empty?\n    puts \"List is empty\"\n    false\n  else\n    l.each do |x|\n\
    \      next if l.count(x) == 3\n      sum = 0\n      l.each do |y|\n        if\
    \ y + x == x\n          sum = sum + 1\n          l.delete y\n        end\n   \
    \   end\n      l.delete x if sum == 3\n    end\n    false\n  end\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| c |>\nWhy are you using `count` instead of `uniq`\
    \ or `detect`? `count` iterates through the entire list twice.\n<|/ c |>\n<| c\
    \ |>\n, `count` returns the number of times an element appears in an array, while\
    \ `detect` returns the first element of an array that satisfies a specific condition.\n\
    <|/ c |>\n<| c |>\nI suppose I was thinking more about what the two methods do\
    \ and how they might interact with each other. For example, `uniq` returns all\
    \ the unique items in a collection, while `detect` returns the first item that\
    \ matches the condition. Since we are only checking for the existence of three\
    \ distinct elements, `detect` could probably be more efficient than `count`.\n\
    <|/ c |>\n<| c |>\n, `uniq` and `detect` are equivalent: `uniq` is simply `delete_if\
    \ { |x| x.eql?(x) }.uniq`, while `detect` is `delete_if { |x| x.eql?(x) && l.size<3\
    \ }.first`. The former will stop on the first `eql?`, while the latter will keep\
    \ going.\n<|/ c |>\n<| c |>\n, your comments on `detect` and `count` were very\
    \ interesting. I didn't realize that `count` would iterate through an array twice.\
    \ This is a great learning experience for me.\n<|/ c |>\n<| a |>\nJust for fun,\
    \ here is another solution using group_by, map, reduce and uniq.\n<code>", " \
    \ # your code here\n  return false if l[0]+l[2]+l[4] == 0 or\n               \
    \    l[1]+l[3]+l[5] == 0 or\n                   l[2]+l[4]+l[6] == 0 or\n     \
    \              l[3]+l[5]+l[7] == 0 or\n                   l[4]+l[6]+l[8] == 0\
    \ or\n                   l[5]+l[7]+l[9] == 0 or\n                   l[6]+l[8]+l[10]\
    \ == 0 or\n                   l[7]+l[9]+l[11] == 0 or\n                   l[8]+l[10]+l[12]\
    \ == 0 or\n                   l[9]+l[11]+l[13] == 0 or\n                   l[10]+l[12]+l[14]\
    \ == 0 or\n                   l[11]+l[13]+l[15] == 0 else\n                  \
    \ true\nend\n</code>\nAnd here is another way of doing it (more in line with what\
    \ you are looking for):\n<code>", "  l.each_with_index { |el, index|\n    if (index\
    \ > 0)\n      if (el > l[index - 1] ||\n          ((el == l[index - 1]) && (el\
    \ != l[index]))) \n        puts \"#{el} is not in #{l}\"\n        return false\
    \ \n      else\n        return true\n      end\n    end\n  }\nend", "  l.count(l.uniq.sort).zero?\n\
    end", "    return l.count(l[0]+l[1]+l[2])==3 \nend", "  l2 = []\n  l.each { |i|\
    \ l2 << i unless i.zero? }\n  if l2.size == 3\n    true\n  else\n    false\n \
    \ end\nend", '  l.sort!', "  return l.count(0) > 1\nend", "\tn = l.count\n\tfor\
    \ i in (0..n-2).step(2).to_a\n\t\tif (l[i] + l[i+1] + l[i+2])==0\n\t\t\treturn\
    \ false\n\ttrue\nend", "  l.sort\n  l.each_cons(3) do |x, y, z|\n    return false\
    \ if (x+y+z == 0)\n  end\n  true\nend\n</code>\nThe code above takes your list\
    \ l, sorts it, then iterates over the list (l.each_cons(3)) and sums the three\
    \ elements together to see if the sum is zero. You can then use the code you already\
    \ have to determine if there are any such lists.\n<|/ a tags=ruby |>\n<| c |>\n\
    I agree. My answer was just to show a way of doing it without using the sum as\
    \ an intermediary. I suppose the difference would be that you're not looping over\
    \ the list twice. Thanks for your comment, I'll update the answer to include it.\n\
    <|/ c |>\n<| c |>\nI think that the `sort` method can be avoided. `each_cons(3)`\
    \ already sorts its input.\n<|/ c |>\n<| c |>\nThat's true - I didn't think about\
    \ the sort aspect at all! Thanks for the comment!\n<|/ c |>\n<| c |>\nThis looks\
    \ like a good way to solve it, but I don't really see why we're using each_cons(3).\
    \ Could you explain?\n<|/ c |>\n<| c |>\neach_cons(3) creates a list of triples\
    \ of 3 elements - one for each 3 consecutive elements in the original list. For\
    \ example, if you had the list `[1,2,3,4]` the code would return `[[1, 1], [2,\
    \ 2], [3, 3], [4]]`, which is true because the sum of the first three elements\
    \ is 1, the sum of the second three elements is 2, the sum of the third three\
    \ elements is 3, and the sum of the last three elements is 4. Hope this helps\
    \ clarify why we're using it!\n<|/ c |>\n<| a dscore=2 |>\nIf you want all combinations\
    \ of the numbers from 1..10 that sum to zero:\n<code>\n(1..10).to_a.combination(3).select(&:last).map\
    \ { |a| a.all? { |e| e == 0 } }", "  l.sort!\n  l.length.times do |i|\n    i+1\
    \ while l[i] == l[i-1] and l[i] == l[i+1]\n  end\n  l.length == 3 && l[0] == l[2]\
    \ && l[1] == 0\nend\n</code>\nNote that I'm also using the following helper functions:\n\
    <code>", "  l.each_with_index do |e, i|\n    el1, el2, el3 = l[i..i + 3]\n   \
    \ el1.zero? && el2.zero? && el3.zero? || el1.zero? && el2.zero? && el3 > 0 &&\
    \ el2 > 0 && el3 > 0 || el1.zero? && el2 > 0 && el3 > 0 && el1 > 0 || el1 > 0\
    \ && el2 > 0 && el3 > 0 && el1 > 0 && el2 > 0 && el3 > 0\n  end\nend\n</code>\n\
    Here's another solution that I came up with.  It involves taking advantage of\
    \ our ability to sum the elements of the list to zero.  Let's say you're trying\
    \ to find three elements in a list that sum to zero, without using three separate\
    \ loops or if statements.  Here's a function that would do it:\n<code>", "  l.sort!\n\
    \  return l.inject(true) { |sum, e| sum && !(e == l.first || e == l.last || e\
    \ == sum.last) && sum }\nend\n</pre>\n<p>\nIn this program, the method <tt>find_triples</tt>\
    \ takes a list as an\nargument. It sorts the list lexicographically, and iterates\
    \ over the\nlist once to find elements that have the same sum as the first and\n\
    last elements of the list. The <tt>inject</tt> method of the Enumerable\nmodule\
    \ is used for this purpose. The <tt>inject</tt> method takes two\narguments, the\
    \ first one is the initial value of the accumulator (the sum\nof the elements\
    \ in the list), and the second one is an optional block.\nIf the block returns\
    \ true, then the current value of the accumulator is\nadded to the result and\
    \ returned. If no block returns true, then the current\nvalue of the accumulator\
    \ is returned.\n</p>\n<pre>", "  l.sort\n  for i in l\n    l.each do |j|\n   \
    \   if i+j+i==0\n        return true\n      end\n    end\n  end\n  return false\n\
    end\n</code>\n<|/ a tags=ruby,sum,arrays |>\n<| c |>\n`[3, 2, 1].any?{ |x| x.reduce(:+)\
    \ == 3 } #=> true`\n<|/ c |>\n<| c |>\nThe question is tagged \"ruby\".\n<|/ c\
    \ |>\n<| a tags=ruby,sum,arrays |>\nWe can write it like this, though I don't\
    \ think it is very pretty:\n<code>", "  l.sort.each do |x|\n    return false if\
    \ l.count(x) > 2\n    return true if l.count(x) == 3\n  end\n  false\nend\n</code>\n\
    The first function will sort and remove duplicates. The second function will count\
    \ the number of items that have three items that sum to zero.\n<code>", "    l.sort!\n\
    \    sum = 0\n    triples = false\n    for i in 0...l.length - 3\n        sum\
    \ += l[i]\n        next if sum > 0\n        triples = true if l[i] > l[i+3] and\
    \ l[i+1] > l[i+2] and l[i] < l[i+1]\n    end\n    triples\nend\n</cell>\n<text>\n\
    Problem 9: Using an iterative approach, write a function sum_of_triplets that\
    \ takes as input a list of integers, and returns the sum of all integers in the\
    \ list that consist of three non-zero integers.", "  l.sort! # sort the list to\
    \ ensure that duplicates are removed.\n  return l[0] == 0 and l[1] == 0 and l[2]\
    \ == 0\nend", "  l.each_index { |i| sum_to_zero?(l[i..i+3]) }\nend", "    i =\
    \ 0\n    while i < l.size\n        j = i + 1\n        while j < l.size\n     \
    \       k = j + 1\n            while k < l.size\n                if l[i] + l[j]\
    \ + l[k] == 0\n                    return True\n                else\n       \
    \             k += 1\n                end\n            end\n            j += 1\n\
    \        end\n        i += 1\n    end\n    return false\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\n<code>\n def triples_sum_to_zero?(l,n)\n    l.sort.reverse.each_cons(3).all?\
    \ { |a,b,c| a.to_i + b.to_i + c.to_i == n }\n  end\n</code>\n<|/ a tags=ruby dscore=1\
    \ |>\n<| a tags=ruby |>\n<code>", "  # write your code here\n  l.sort!\n  triples\
    \ = []\n  sum = 0 \n  count = 0\n  for i in 0..(l.size - 2) do\n    sum = sum\
    \ + l[i]\n    count = count + 1\n    if sum > 0\n      triples << [sum, count,\
    \ i]\n    end\n  end\n  return triples.uniq.size == 3\nend\n</cell>\n<text>\n\
    By looking at the previous cells, we see that the sum_triples function works as\
    \ we expect; in particular, it does not return true when there is an input list\
    \ of length 0.", "    # Your code here!\n    (l1,l2,l3) = l\n    \n    return\
    \ ((l1+l2+l3)==0)", "  l.each_cons(3).any? {|triple| triple.inject(0) {|s, e|\
    \ s + e == 0 }}\nend", "  count = 0\n  for i in 0..(l.length - 1)\n    for j in\
    \ 0..(l.length - i)\n      count += l[i..j].inject(0) { |s, x| s + x } == 0 ?\
    \ true : false\n    end\n  end\n  count == 3\nend", "  return l.count(0) == 3\n\
    end", "    l.map!{|i| i**3}\n    return l.count > 3 ? false : true\nend", "  total\
    \ = 0\n  for i in l\n    total += i\n    if total % 3 == 0 and total != 0\n  \
    \    return false\n    end\n  end\n  return true\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,loops,arrays |>\n<| c |>\nI feel like this is better than my solution.\
    \ Just for the record, you have a syntax error in `triple_sum?` and the other\
    \ two should be `triples_sum_to_zero?`\n<|/ c |>\n<| c |>\nThanks for noticing\
    \ that, I fixed it. That syntax error is because I copied the wrong function name\
    \ from my editor. Thanks for noticing that.\n<|/ c |>\n<| c |>\nThank you very\
    \ much! I got your solution to work but you pointed out something I didn't know\
    \ before: I can count how many times each number occurs in an array. That's very\
    \ helpful. I updated my question with your solution :)\n<|/ c |>\n<| c |>\nThat's\
    \ great! I'm glad I could help.\n<|/ c |>\n<| a tags=ruby,loops,arrays |>\nThis\
    \ works if you sort your array:\n<code>", "  l.uniq!\n  l.sort { |a,b| b - a }\n\
    \  return l.length == 3 && l.uniq.length == 3\nend\n</code>\n<code>", "  l.uniq().count\
    \ { |x| (x..x).count(0) == 3 } ? true : false\nend\n</code>\nThe above code has\
    \ some shortcomings. Let's take a look at them in detail:\n<code>\ntriples_sum_to_zero([1])\
    \        # => false\ntriples_sum_to_zero([3])        # => true\ntriples_sum_to_zero([1,2])\
    \       # => true\ntriples_sum_to_zero([1,3,4])     # => true\ntriples_sum_to_zero([1,2,3,3,4])\
    \ # => false\n</code>\nLet's look at the second argument. That's not too hard,\
    \ right? Let's take any three distinct elements from the list. Let's start with\
    \ the first element. Let's see what happens if we add it to the list and the other\
    \ two. How many distinct elements would this list contain?", "  n = 0\n  for i\
    \ in l\n    n += i\n  n\n  return((n-3).zero?)\nend", "  if l.length == 0 then\
    \ return true\n  if l.length == 1 then return false\n  if l.length == 2 then return\
    \ l.sum() == 0\n  for i in 1..(l.length - 2)\n    if l[i..i+2].sum() == 0 then\n\
    \      return true\n    end\n  end\n  return false\nend", "  for i in 0..(l.size\
    \ - 3)\n    sum = 0\n    for j in 0..(l.size - i)\n      sum += l[j]\n    end\n\
    \    if sum == 0 && i == (l.size - 3)\n      return true\n    end\n  end\n  return\
    \ false\nend", "    l.each_with_index do |x,i|\n        l.delete_at(i)\n     \
    \   break false if l.length == 3\n    end\n    return l.length == 3\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like this answer - I see no reason to delete items\
    \ in the loop. Of course, that should be `delete` instead of `delete_at`.\n<|/\
    \ c |>\n<| a tags=arrays,ruby |>\n<code>\narr = [1,2,3,3,4,4,5,5,6]", "  l.sort!\n\
    \  l.reject! { |x| x == 0 }\n  l.uniq.length == 3 && l.length == 3\nend", "  l.sort!\n\
    \  l.each do |x|\n    return (true if x.to_s == x.to_s[0..-2].to_s)\n  end\n \
    \ return false\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't handle\
    \ negative numbers. It would be `return (true if x.to_s == x.to_s[0..-2] == '00')`\n\
    <|/ c |>\n<| a dscore=0 |>\nThe following code will work for any number and will\
    \ avoid the duplicate problem:\n<code>", "  if l.count(l.first) > 1\n    return\
    \ false\n  else\n    l.delete(l.first)\n    return l.inject(true) do |sum,(n,v)|\n\
    \      sum &&= (v+n)%3 ==0\n    end\n  end\nend\n</cell>\n<cell>", "  l.sort\n\
    \  (l, l.length).combinations(3).all? { |triple| triple.inject(:+) == 0 }\nend\n\
    </code>\nAs you can see, this version reads much nicer than the one you posted,\
    \ and it still has the same semantics. The reason why my version takes O(n log\
    \ n) time to read (instead of O(n) in the other solution) is because it sorts\
    \ the list first (O(n log n) time) before reading it, which sorts its sublists\
    \ (O(n) time) before reading them. This makes the total algorithm O(n log n).\n\
    <|/ a tags=ruby,algorithm |>\n<| c |>\nGreat explanation! Thanks!\n<|/ c |>\n\
    <| c |>\n: Thanks for your comment. I'll try to add some clarification.\n<|/ c\
    \ |>\n<| c |>\n: And for sure, my algorithm runs in `O(n log n)`. :)\n<|/ c |>\n\
    <| c |>\nIt should be noted that your method only checks whether the triplets\
    \ in a given list sum to zero, not whether each of the triplets in a given list\
    \ sum to zero, which can be important if the order in which you process a given\
    \ list is important.\n<|/ c |>\n<| c |>\n: Yes, I agree. I wrote my answer before\
    \ the OP updated his/her question to say \"the sum of all three numbers in the\
    \ triplet must equal zero.\" Then I realized that this was not the case, and I\
    \ changed my answer accordingly. I decided to put my answer first, and then decide\
    \ which to accept.\n<|/ c |>\n<| a dscore=3 tags=ruby,algorithm |>\n<code>", " \
    \ l.uniq! # remove duplicate elements\n  l.sort! # sort the array\n  if l.size\
    \ <= 2\n    true\n  elsif l.size == 3\n    (l[0]+l[1]+l[2]) == 0\n  else\n   \
    \ l[0]+l[1]+l[2..-1].inject(:+) == 0\n  end\nend", "  l.map do |x| x * (x+1) *\
    \ (x+1)\n  end != 0\nend", "    l.sort! # sort\n    return l.size == 3 && l.inject(false)\
    \ {|acc, v| acc + v == 0 || acc + v == 1}\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a |>\n<code>", "  l.uniq! # makes sure that no item appears more than once\n\
    \  return l.count(1) == 3\nend", "  l.each_with_index do |el, i|\n    el = el.to_i\n\
    \    el if el < 0\n    el if el >= i\n  end\n  l.uniq.length == 3\nend", "  l.uniq\n\
    \  l.each do |x|\n    return true if l.count(x) == 3\n  end\n  return false\n\
    end\n</code>\nFor what it's worth, I think your algorithm is very inefficient\
    \ and will run for a long time on long lists.\n<|/ a tags=ruby |>\n<| a dscore=0\
    \ |>\n<code>", "  return triples_sum_to_zero_helper(l, 0, [], false)\nend", " \
    \ l.sort!\n  (l[0]+l[1]+l[2])==0 || (l[0]+l[1]+l[2]+l[3])==0 || (l[0]+l[1]+l[2]+l[3]+l[4])==0\n\
    end\n</code>\nNow, we can test our program:\n<code>\nrequire 'test/unit'", " \
    \ l.uniq\n  l.count\n  l.uniq.count == 3\nend\n</code>\nBut this does not work\
    \ well with large lists because uniq is a linear operation that requires the list\
    \ to be fully scanned to find unique elements.\nA more efficient approach is to\
    \ sort the list and then just use adjacent elements as an iterator to determine\
    \ which values are distinct. For example:\n<code>", "  return l.count(l.count(l[0])\
    \ - l[0].count(l[0])) > 0\nend", "  return triples_sum_to_zero_helper(l, [], [],\
    \ [])\nend", "  ls = l.to_a\n  l.clear\n  ls.each do |num|\n    l.push (num +\
    \ num + num) unless l.include?(num + num + num)\n  end\n  l.size == 0\nend", " \
    \ # your code goes here\n  return false\nend", "  l.sort!\n  (l.count-3).times\
    \ do |i|\n    return true if l[i]+l[i+2] == 0\n  end\n  false\nend", "  s.each_index\
    \ do |i|\n    triples = []\n    l.each do |j|\n      if j == i + 1 or j == i +\
    \ 2 or j == i + 3 then\n        triples << j\n      end\n    end\n    if triples.count\
    \ > 3 then\n      return true\n    end\n  end\n  return false\nend\n</code>\n\
    <|/ q tags=ruby dscore=0 |>\n<| c |>\nYour question is a bit unclear. Can you\
    \ show the input and output you expect from your method? It's not clear what you're\
    \ asking for.\n<|/ c |>\n<| c |>\n\"The first element of the input list will always\
    \ be zero\". Why?\n<|/ c |>\n<| c |>\nWhat should the output be? When you step\
    \ through your method in the debugger, what are the values that get passed and\
    \ what is being returned?\n<|/ c |>\n<| c |>\nPlease see my updated question\n\
    <|/ c |>\n<| c |>\nWhy would the output be true? The first element of the list\
    \ `[0,0,0]` sums to zero.\n<|/ c |>\n<| a dscore=0 |>\nA little bit more rubyish\
    \ than my previous answer, but I think this is what you are looking for:\n<code>",
  "  return l.count(l[0]) == 3 && l.count(l[1]) == 3 && l.count(l[2]) == 0\nend",
  "  # Initialize return variable\n  triples_sum_to_zero = false\n  # Initialize counter\n\
    \  n = 0\n  # Iterate through list\n  n.times do\n    triples_sum_to_zero = true\
    \ if l[n][n] + l[n][n+1] + l[n][n+2] == 0\n    break if triples_sum_to_zero\n\
    \  end\n  return triples_sum_to_zero\nend", "  l.uniq().map {|n| n*n }.reduce(:+)\
    \ == 0\nend", "    return l.count(l[0]) == 3 && l.count(l[1]) == 3 && l.count(l[2])\
    \ == 3\nend\n</cell>\n<cell>\ntriples_sum_to_zero([1,1,1])\n</cell>\n<text>\n\
    Task 4.\nWrite a function that takes a list of integers and returns True if there\
    \ are two distinct elements in the list that sum to zero.", "  l.each_with_index\
    \ do |n, index|\n    return false if n == 0\n    next if l.size - index > 1\n\
    \    return true if n == 3 &&\n        l.values_at(*index + [0,1]).count(false)\
    \ == 3\n    return true if n == 3 &&\n        l.values_at(*index + [0,1]).count(true)\
    \ == 3\n  end\n  false\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy are you\
    \ using three `if`s instead of just `if (n == 3) && (l.values_at(*index + [0,1]).count(false)\
    \ == 3)`?\n<|/ c |>\n<| c |>\n: I guess that should be `==`. My guess is that\
    \ the OP didn't want to test against `false` and `true` but rather against the\
    \ value `0` which is what the method `sum_to_zero` does.\n<|/ c |>\n<| c |>\n\
    I thought about using `==`, but since `0` is already equal to `false`, I thought\
    \ it would be overkill. I just want to make sure I understand what you meant.\n\
    <|/ c |>\n<| c |>\n: Yes, I understand what you meant, I just thought it was clearer\
    \ to express the conditions as three `if`s rather than a single `if` with `||`\
    \ or `&&` conditions. Also, I was thinking about using `==` because I thought\
    \ it would be more readable, but you're right that `==` probably won't make much\
    \ difference in this particular case.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays\
    \ |>\nTry this :\n<code>", "  i = 0\n  while i < l.size\n    total = l[i] + l[i+1]\
    \ + l[i+2]\n    if total == 0 || (total > 0 && !(total % 3))\n      return false\n\
    \    i += 1\n  return true\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails,math\
    \ |>\n<| c |>\nI think this is the most readable solution to this problem, but\
    \ I'd probably write it a bit more explicitly (but also slightly more efficiently\
    \ as you use `each_cons` instead of `inject`) e.g. `(1..n).each_cons(3).map(&:sum).all?(&:zero?)`\n\
    <|/ c |>\n<| c |>\nThat's a great suggestion. I've edited my answer to include\
    \ it.\n<|/ c |>\n<| a |>\nI think it's pretty simple to check if all triplets\
    \ in the range are equal:\n<code>\n3..5\n=> 3..5\n[1,2,3,4,5]\n=> [1, 2, 3, 4,\
    \ 5]\n</code>\nThe range is inclusive, but this means that the first number is\
    \ included in the range.\nTo count all triplets in the range:\n<code>\n3..5\n\
    => 3..5\n3.upto(5.downto(1)) { |x| p x }", "    l.sort\n    return l.count(0)==3\n\
    end\n</code>\nThe test cases (all correct) give the following results:\n<code>\n\
    puts triples_sum_to_zero([0, 0, 0]) # => true\nputs triples_sum_to_zero([0, 0,\
    \ 0, 0]) # => false\nputs triples_sum_to_zero([0, 0, 0, 1]) # => true\nputs triples_sum_to_zero([0,\
    \ 0, 0, 2]) # => false\n</code>\nI hope this helps! :)\n<|/ a |>\n<| a dscore=0\
    \ |>\n<code>", "  return l.inject(:+)==0\nend", "  l.length.times.with_object([])\
    \ do |i, a|\n    next a if i == 0\n    next_triple = a.last(3).map(&:sum)\n  \
    \  if next_triple.uniq.length == 3 then\n      next_triple.each do |triple_element|\n\
    \        next_triple = a.last(3).map(&:sum).delete(triple_element)\n        break\
    \ if next_triple.length == 0\n      end\n      return true\n    end\n    a.push([i].product(next_triple))\n\
    \  end\n  return false\nend", "  (0..l.length).to_a.combination(3).detect do |i|\n\
    \    l.product([i[0], i[1], i[2]]).sum() == 0\n  end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>\n[a, b, c].sort.reduce(:+) == 0\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nCould you add an explanation to your answer?\
    \ How does it work?\n<|/ c |>\n<| c |>\nIt takes three numbers and adds them,\
    \ sorts them, and then reduces them to a single number, which is zero if no other\
    \ number is the same. Thus, the answer is zero if no numbers are the same.\n<|/\
    \ c |>\n<| c |>\nIt works, thanks!", "  l.each_cons(3) do |t|\n    next if t.reduce(0)\
    \ { |acc,val| acc+val < 0 }\n    t.reduce(0) { |acc,val| acc + val } == 0\n  end\n\
    end\n</code>\nThe return statement in triples_sum_to_zero is never used and in\
    \ general is meaningless (the function would return true or false anyway), but\
    \ it is legal in Ruby.  I should also point out that this solution is inefficient\
    \ in two ways: first, the list is traversed three times (once to find the distinct\
    \ values that sum to 0, once to find all the triples that sum to 0, and once to\
    \ find the triples that do not sum to 0).  Second, the return statement doesn't\
    \ do anything, so it can never be true or false (it just returns the last value\
    \ returned in the block).  I believe that the first is inevitable, and the second\
    \ is more important - in this case, your solution is O(n*log(n)), whereas the\
    \ Ruby solution is O(n).\n<|/ a |>\n<| c |>\nThanks so much, I have learned a\
    \ lot from you and I will try to follow your suggestions. I will also try to think\
    \ on how to improve my code (I am still new to Ruby, so I will be grateful if\
    \ you can suggest me some tips for improving my code).\n<|/ c |>\n<| c |>\nI posted\
    \ an alternative solution - it has the advantage of being less code, but that\
    \ of course depends on the actual application.\n<|/ c |>\n<| c |>\nThanks so much\
    \ for your explanation. I was wondering about the third solution too, but I couldn't\
    \ figure out how to implement it. So I think I will use the first solution as\
    \ it is the simplest and most understandable. Thanks again.\n<|/ c |>\n<| c |>\n\
    - I added another solution that I think might be better - it uses the same ideas,\
    \ but I think is actually more efficient (in terms of memory usage).  I say \"\
    I think is\" because I have no idea how Ruby implements iterators and I don't\
    \ know exactly what Ruby will do with my version of the solution that uses the\
    \ `each_cons` and a block variable (`t`).  I also have no idea how this version\
    \ behaves when the block variable is modified or mutated by the `each_cons`.\n\
    <|/ c |>\n<| a |>\nHere's another way of doing it, using Array#uniq to remove\
    \ duplicates, and Array#sum to get the sum of the array elements.\n<code>", " \
    \   triples_sum_to_zero = false\n    \n    triples = []\n    \n    triples_sum_to_zero\
    \ = false\n    \n    for number in l\n        triples_sum_to_zero = false\n  \
    \      \n        for num in triple\n            \n            if num + number\
    \ == 0\n                triples_sum_to_zero = true\n                break\n  \
    \          end\n        end\n    end\n    \n    return triples_sum_to_zero\nend",
  "  l.each_with_index { |el, index| return true if index == l.size - 3 && el == 0\n\
    \                         return true if index == l.size - 2 && el == 0\n    \
    \                     return true if index == l.size - 1 && el == 0\n  }\n  return\
    \ false\nend", "    l.count?(l.product)\nend", "  l.sort!\n  sum = 0\n  for i\
    \ in (0...(l.size-2)).to_a\n    sum+=l[i]*l[i+1]\n  end\n  return sum == 0 &&\
    \ l.size > 3\nend\n</cell>\n<text>\nWe apply this function to our dataset and\
    \ get a result.", "  l.uniq!\n  (l.select { |x| x.reduce(:+) == 0 }).size == 3\n\
    end", "  # write your code here\nend", "    three_sums.map {|i| l[i].to_s}.uniq.size\
    \ == 3\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,algorithm dscore=4 |>\n<|\
    \ c |>\nGood idea.  Unfortunately, I will be dealing with very large arrays, so\
    \ I can't actually store them all in memory, so I don't think I can use your suggestion\
    \ :(\n<|/ c |>\n<| a dscore=3 |>\nWhat you want is something like this:\n<code>",
  "  l.sort!\n  (l[0] + l[1] + l[2]) == 0 ? (false && true) : false\nend\n</cell>\n\
    <cell>", "    l.sort!\n    sum = 0\n    triples = []\n    \n    for i in 0..(l.length-1)\n\
    \        sum += l[i]\n        triples.push([i,i,sum])\n    end\n    \n    triples.uniq!\n\
    \    \n    return triples.length >= 3\nend\n</cell>\n<code language=julia-1.5>\n\
    triples_sum_to_zero([0,0,0])\n</cell>\n<code language=julia-1.5>\nfunction triples_sum_to_zero(l)\n\
    \    \n    l.sort!\n    sum = 0\n    triples = []\n    \n    for i in 0..(l.length-1)\n\
    \        sum += l[i]\n        triples.push([i,i,sum])\n    end\n    \n    triples.uniq!\n\
    \    \n    return triples.length >= 3\nend\n</cell>\n<code language=julia-1.5>\n\
    triples_sum_to_zero([3,3,3])\n</cell>\n<code language=julia-1.5>\nfunction triples_sum_to_zero(l)\n\
    \    \n    l.sort!\n    sum = 0\n    triples = []\n    \n    for i in 0..(l.length-1)\n\
    \        sum += l[i]\n        triples.push([i,i,sum])\n    end\n    \n    triples.uniq!\n\
    \    \n    return triples.length >= 3\nend\n</cell>\n<code language=julia-1.5>\n\
    triples_sum_to_zero([1,1,1])\n</cell>\n<code language=julia-1.5>\nfunction triples_sum_to_zero(l)\n\
    \    \n    l.sort!\n    sum = 0\n    triples = []\n    \n    for i in 0..(l.length-1)\n\
    \        sum += l[i]\n        triples.push([i,i,sum])\n    end\n    \n    triples.uniq!\n\
    \    \n    return triples.length >= 3\nend\n</cell>\n<code language=julia-1.5>\n\
    triples_sum_to_zero([0,1,1,1])\n</cell>\n<code language=julia-1.5>\nfunction triples_sum_to_zero(l)\n\
    \    \n    l.sort!\n    sum = 0\n    triples = []\n    \n    for i in 0..(l.length-1)\n\
    \        sum += l[i]\n        triples.push([i,i,sum])\n    end\n    \n    triples.uniq!\n\
    \    \n    return triples.length >= 3\nend\n</cell>\n<code language=julia-1.5>\n\
    triples_sum_to_zero([1,1,1,1,1])\n</cell>\n<code language=julia-1.5>\nfunction\
    \ triples_sum_to_zero(l)\n    \n    l.sort!\n    sum = 0\n    triples = []\n \
    \   \n    for i in 0..(l.length-1)\n        sum += l[i]\n        triples.push",
  "  l.uniq.sort.reduce(0) { |sum, n| sum + n == 0 && return true }\n  false\nend",
  "  l.each do |item|\n    return true if item == (item.sum - 3)\n  end\n  false\n\
    end", "    # your code here\n    return len([l for l in l if l.sum == 0]) == 3\n\
    end", "  l.sort.each do |n|\n    sum = 0\n    l.each do |num|\n      sum += num\n\
    \      break if sum + n == 0\n    end\n    return false if sum == 0\n  end\n \
    \ true\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=ruby |>\nThe OP asked\
    \ for a solution without using hashes.\nHere's an example of using Array#product\
    \ and Array#sum:\n<code>", "    l.each do |x|\n        if x.to_s.split(' ').sum.to_s\
    \ == 0\n            return true\n        end\n    end\n    return false\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks a lot for the answer! I appreciate\
    \ that. Unfortunately, I cannot use any library like this. This is due to the\
    \ fact that my lecturer has only just started learning Ruby. I would love to use\
    \ something already existing (like a library, but something that's not too advanced\
    \ for me). I'm also wondering, how would the code look like if the function had\
    \ to take a list of integers as an input? It would probably need a for loop in\
    \ there somewhere. Would that be correct?\n<|/ c |>\n<| c |>\nYes, you wouldn't\
    \ use a `for` loop.  I edited the answer.  But there are so many different ways\
    \ to do what you want to do, some more complex than others, so there is not one\
    \ answer to your question.\n<|/ c |>\n<| c |>\nThank you so much! That's very\
    \ helpful! I'm so happy now that I've finally managed to figure out the answer\
    \ to my question! This is very helpful. I wish you the best of luck in your future\
    \ programming! :)\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "    sum=0\n\
    \    for i in 0...l.length-1\n        sum+=l[i]\n    return sum == 0\nend", " \
    \ l.each_cons(3) do |trip|\n    if trip.all? { |i| i == 0 }\n      puts 'No triplets\
    \ sum zero'\n      return true\n    end\n  end\n  false\nend", "    # your code\
    \ here\n    l.sort!\n    l.reverse!\n    count=0\n    l.each do |x|\n        if\
    \ count==3\n            return true\n        else\n            count+=1\n    \
    \    end\n    end\n    return false\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n\
    <| a dscore=0 tags=ruby,algorithm |>\n<code>", "  sum = 0\n  i = 0\n  while i\
    \ < l.length\n    sum = sum + l[i]\n    i += 1\n    if sum == 0\n      return\
    \ true\n    end\n    if sum != 0\n      return false\n    end\n  end\n  return\
    \ true\nend\n</code>\nAnd now let's write some tests:\n<code>", "  if l.empty?\n\
    \    false\n  else\n    triples = l.uniq\n    l.each do |i|\n      triples.each\
    \ do |j|\n        triples.each do |k|\n          return true if i + j + k == 0\n\
    \        end\n      end\n    end\n  end\nend", "  if l.length < 3\n    return\
    \ false\n  end\n  \n  l.each do |i|\n    j = i + 1\n    while j < l.length\n \
    \     k = j + 1\n      while k < l.length\n        if l[i] + l[j] + l[k] == 0\n\
    \          return true\n        end\n        k += 1\n      end\n      j += 1\n\
    \    end\n  end\n  \n  return false\nend", "  l.uniq.length == 3 && l.uniq.inject(:+)\
    \ == 0 && l.length >= 3\nend\n</code>\nThe only other trick is to sort the list.\
    \ This requires O(N log N) time, which is faster than O(N).\n<code>", "    triples\
    \ = [[0, 0], [0, 0]]\n    triples[0][0], triples[0][1] = l[0], l[1]\n    triples[1][0],\
    \ triples[1][1] = l[2], l[3]\n    return triples[1][0] + triples[1][1] == 0\n\
    end\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nI like this one, but\
    \ as points out, it requires iterating over all the triples and checking their\
    \ sum.\n<|/ c |>\n<| c |>\nYes, it iterates over all the triples and checks the\
    \ sums. If you have to do millions of calculations like this, then your speed\
    \ will probably suffer. However, in most cases, this will be fine since it will\
    \ only take a few seconds to iterate over millions of elements.\n<|/ c |>\n<|\
    \ c |>\nThis is an interesting approach to solving the problem. One thing to note\
    \ is that if you use hashes instead of arrays for the triples, you can just use\
    \ an initial hash containing all elements to check, and check if it contains a\
    \ `:key` of zero.\n<|/ c |>\n<| c |>\nI implemented the solution in the question.\
    \ Thanks much for your help and all the other answers! :)\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,arrays |>\nHere's my attempt. I've added some comments for you.\n\
    <code>", "  sums = l.group_by {|i| l.index i}\n  sums.values.any? { |v| v.any?\
    \ { |w| w.zero? }}\nend", "  l.sort!\n  for i in 0..(l.size-1)\n    for j in (i..l.size)\n\
    \      k = j+1\n      while k < l.size and l[i]+l[j]+l[k] == 0\n        k = k\
    \ + 1\n      end\n      if k == l.size\n        return false\n      end\n    end\n\
    \  end\n  true\nend", "  l.sort! # makes sure the list contains only integers\n\
    \  return l.count(l[0]) == 3 && l.count(l[2]) == 0\nend", "  return l.uniq.size\
    \ == 3 && l.uniq.sum == 0.0\nend", "  l.sort!\n  return l[0] == 0 && l[-1] ==\
    \ 0 && (l.length == 3 || l[2] == 0)\nend", "  l.sort!\n  (triples_sum_to_zero?\
    \ (l) 0) != false\nend", "  (0..l.length).to_a.reverse.each_with_index.detect\
    \ do |i|\n    i != 0 && i != l.length && l[i] + l[i+1] + l[i+2] > 0\n  end\nend",
  "    l.sort!\n    zeros = 0..-1\n    l.each_with_index do |x,i|\n        (zeros\
    \ -= x) == 0 && return i\n    end\n    return nil\nend\n</code>\nThe code above\
    \ runs in time O(n*logn), and in space O(n). In order to reduce the complexity\
    \ of the solution, I added a variation on the method which I call triples_sum_to_zero_2.\
    \ For this version, we use an auxiliary array called zeros, to keep track of the\
    \ elements we already saw that are equal to zero.\n<code>", "  l.each do |i|\n\
    \    i = l.index(i)\n    l = l[i+1]\n  end\n  if l.size == 3\n    l.include?(0)\n\
    \  end\nend", "  if l.length < 3\n    return false\n  end\n  x = l.inject(0) do\
    \ |acc, elem|\n    acc += elem\n    acc\n  end\n  return x % 3 == 0\nend", " \
    \ if l.size != 3\n  then return false\n  else return true\n  end\nend", "  l.each\
    \ do |x|\n    next if x == 0\n    return true if x == x\n    next if x == x +\
    \ x\n    return true if x == x - x\n  end\n  return false\nend", "  l.uniq!\n\
    \  l.each_index do |i|\n    for j in (i+1,i+2) if (i+1)+(i+2) < l.length\n   \
    \   return true if l[j] == l[i]+l[j]\n    end\n  end\n  false\nend\n</code>\n\
    The code above works with integers and floats, not with all data types (such as\
    \ strings, arrays, hashes, etc.). I've only tested with integers and floats.\n\
    To demonstrate the usage of the code above, here's a complete Ruby program that\
    \ solves the question:\n<code>\nputs \"Welcome to the Number Triple Parsing Calculator\"\
    \nputs \"Enter the three numbers you wish to calculate.\"\na = gets.chomp.to_i\n\
    b = gets.chomp.to_i\nc = gets.chomp.to_i\nputs \"Your numbers are: #{ a }, #{\
    \ b }, #{ c }\"\nputs \"This program will tell you if the three numbers you entered\
    \ have 3 distinct numbers that sum to zero.\"\nputs \"This program will only accept\
    \ integers and floats for the input. No other data types are allowed.\"", "  \
    \  s = 0\n    for i in l\n        s += i\n        if s == 3\n            return\
    \ True\n    return False\n</code>\n<|/ a tags=python,python-3.x |>\n<| a tags=python,python-3.x\
    \ |>\nHere are some improvements, if you don't mind importing pandas:\n<code>",
  "    triple_count = 0\n    n = l.count{|i| (l[0]+l[1]+l[2]).zero?}\n    l.each do\
    \ |i|\n        if l[0]+l[1]+l[2] != i\n            triple_count += 1\n       \
    \     triple_count += 1 if l[1]+l[2] == i\n            triple_count += 1 if l[2]+l[0]\
    \ == i\n        end\n    end\n    (triple_count==3)\nend", "  l.each_with_index.with_object(Hash.new(0)){|(t,i),h|\
    \ h[t] += 1 if t%3 == 0 || t%5 == 0 }\n  l.count{|x| x.sum==0} <= 3\nend", " \
    \ l.each do |e|\n    puts \"#{e} is #{l.count(e)} in #{l}\"\n    next if l.count(e)\
    \ > 2\n    puts \"#{e} + #{e} + #{e} = #{e} is #{'found' if l.count(e) == 3} in\
    \ #{l}\"\n  end\n  false\nend\n</code>\nAnd it works.\n<code>\nputs \"\\ntriples_sum_to_zero([3,1,2,4])\
    \ = #{triples_sum_to_zero([3,1,2,4])}\"", "  l.sort\n  return l.uniq.length ==\
    \ 3 && l.uniq.all? {|i| i == l.sum - i}\nend\n</code>\nIf you run it with the\
    \ triples_sum_to_zero function, it outputs true\n<code>\nputs triples_sum_to_zero([0,1,1,1,0,0,0,0])"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
