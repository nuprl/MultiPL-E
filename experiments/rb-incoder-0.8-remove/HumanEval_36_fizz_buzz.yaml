name: HumanEval_36_fizz_buzz
language: rb
prompt: "# Return the number of times the digit 7 appears in integers less than n\
  \ which are divisible by 11 or 13.\ndef fizz_buzz(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fizz_buzz\n\
  \    candidate = method(:fizz_buzz)\n    assert_equal(0, candidate.call(50))\n \
  \   assert_equal(2, candidate.call(78))\n    assert_equal(3, candidate.call(79))\n\
  \    assert_equal(3, candidate.call(100))\n    assert_equal(6, candidate.call(200))\n\
  \    assert_equal(192, candidate.call(4000))\n    assert_equal(639, candidate.call(10000))\n\
  \    assert_equal(8026, candidate.call(100000))\n  end\nend\n"
completions: ["    i=0\n    while i < n\n        if (n % 11) == 0 || n % 13 == 0\n\
    \            puts \"#{n} is a multiple of 11 or 13\"\n        elsif n % 11 ==\
    \ 1\n            puts \"#{n} is a multiple of 11\"\n        elsif n % 13 == 1\n\
    \            puts \"#{n} is a multiple of 13\"\n        elsif n % 11 != 0 || n\
    \ % 13 != 0\n            puts \"#{n} is not a multiple of 11 or 13\"\n       \
    \ end\n        i += 1\n    end\nend", "  return 0 if n % 11 == 0 or n % 13 ==\
    \ 0 then \n  return 1 if n % 11 ==0 then \n  return 2 if n % 13 ==0 then\n  return\
    \ 3 if n % 11 == 0 and  n % 13 == 0 then\n  return 4 if n % 11 ==0 and n % 13\
    \ == 0 then\n  return 5 if n % 11 == 0 and n % 13 == 0 then\n  return 6 if n %\
    \ 11 ==0 and n % 13 == 0 then\n  return 7 if n % 11 ==0 and n % 13 == 0 then\n\
    \  return 8 if n % 11 ==0 and n % 13 == 0 then\n  return 9 if n % 11 ==0 and n\
    \ % 13 == 0 then\n  return 10 if n % 11 ==0 and n % 13 == 0 then\n  return 11\
    \ if n % 11 ==0 and n % 13 == 0 then\n  return 12 if n % 11 ==0 and n % 13 ==\
    \ 0 then\n  return 13 if n % 11 ==0 and n % 13 == 0 then\n  return 14 if n % 11\
    \ ==0 and n % 13 == 0 then\n  return 15 if n % 11 ==0 and n % 13 == 0 then\n \
    \ return 16 if n % 11 ==0 and n % 13 == 0 then\n  return 17 if n % 11 ==0 and\
    \ n % 13 == 0 then\n  return 18 if n % 11 ==0 and n % 13 == 0 then\n  return 19\
    \ if n % 11 ==0 and n % 13 == 0 then\n  return 20 if n % 11 ==0 and n % 13 ==\
    \ 0 then\n  return 21 if n % 11 ==0 and n % 13 == 0 then\n  return 22 if n % 11\
    \ ==0 and n % 13 == 0 then\n  return 23 if n % 11 ==0 and n % 13 == 0 then\n \
    \ return 24 if n % 11 ==0 and n % 13 == 0 then\n  return 25 if n % 11 ==0 and\
    \ n % 13 == 0 then\n  return 26 if n % 11 ==0 and n % 13 == 0 then\n  return 27\
    \ if n % 11 ==0 and n % 13 == 0 then\n  return 28 if n % 11 ==0 and n % 13 ==\
    \ 0 then\n  return 29 if n % 11 ==0 and n % 13 == 0 then\n  return 30 if n % 11\
    \ ==0 and n % 13 == 0 then\n  return 31 if n % 11 ==0 and n % 13 == 0 then\n \
    \ return 32 if n % 11 ==0 and n % 13 == 0 then\n  return 33 if n % 11 ==0 and\
    \ n % 13 == 0 then\n  return 34 if n % 11 ==0 and n % 13 == 0 then\n  return 35\
    \ if n % 11 ==0 and n % 13 == 0 then\n  return 36 if n % 11 ==0 and n % 13 ==\
    \ 0 then\n  return 37 if n % 11 ==0 and n % 13 == 0 then\n  return 38 if n % 11\
    \ ==0 and n % 13 == 0 then\n  return 39 if n % 11 ==0 and n % 13 == 0 then\n",
  "  x = 1\n  while x <= n\n    if x % 11 == 0 then puts \"Fizz Buzz\"\n    if x %\
    \ 13 == 0 then puts \"FizzBuzz\"\n    x += 1\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nWhy do you have a `begin` after your `while` loop? Won't this loop\
    \ forever?\n<|/ c |>\n<| c |>\nNo this code is still not working i keep getting\
    \ a syntax error at my while statement line\n<|/ c |>\n<| c |>\nI realized that\
    \ I had a lot of syntax errors in there, sorry. I updated my answer with the correct\
    \ syntax.\n<|/ c |>\n<| c |>\nThank you i really appreciate all your help\n<|/\
    \ c |>\n<| c |>\nNo problem. Since you're new here on StackOverflow, you should\
    \ know that you can accept an answer by clicking on the hollow checkmark next\
    \ to it. Once you've gained enough reputation points (15) you will be able to\
    \ upvote.\n<|/ c |>\n<| a tags=ruby |>\nHere's an interesting solution, using\
    \ each_cons to generate fizz-buzz numbers:\n<code>\n(1..100).each do |x|\n  puts\
    \ x.to_s.chars.each_cons(3).map(&:join).join\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 |>\nThe fastest way to do this is by generating a Fibonacci sequence,\
    \ and then checking the last two items in each row and inserting a fizz at the\
    \ start or end of the sequence. \n<code>\nrequire 'benchmark'", "    count = 0\n\
    \    while n < 100\n        if n % 3 == 0 && n % 5 == 0\n            count +=\
    \ 1\n        end\n        if n % 3 == 0\n            count += 1\n        end\n\
    \        if n % 5 == 0\n            count += 1\n        end\n        n += 1\n\
    \    end\n    count\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's\
    \ a nice solution without looping:\n<code>\nnumbers = 10.upto(100).to_a", "  return\
    \ n.to_s.split('').select {|i| i.to_i.modulo(11).zero? || i.to_i.modulo(13).zero?}.count\
    \ { |i| i.to_i.zero? } \nend\nputs fizz_buzz(7)\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| a dscore=0 |>\nAs another possible solution:\n<code>", "    # Write your\
    \ code here.\n    count = 0\n    for number in n.downto(1) do\n        digit =\
    \ number%11\n        if digit==7 or digit==13 then\n            count += 1\n \
    \       end\n    end\n    return count\nend\n</cell>\n<code language=julia-1.5>\n\
    function fizz_buzz(n)\n    # Write your code here.\n    count = 0\n    for number\
    \ in n.upto(11) do\n        digit = number%11\n        if digit==7 or digit==13\
    \ then\n            count += 1\n        end\n    end\n    return count\nend\n\
    </cell>\n<text>\nWrite a function called count_n_times that receives a number\
    \ as parameter and returns the number of times that number appears in the range\
    \ 1 to 10.", "  count = 0\n  while n < 13\n    count += 1\n    if n % 11 == 0\
    \ || n % 13 == 0\n      count += 1\n    end\n    n += 1\n  end\n  count\nend",
  "  if n % 11 == 0\n    puts \"#{n} is a Fizz Buzz\"\n  elsif n % 13 == 0\n    puts\
    \ \"#{n} is a FizzBuzz\"\n  else\n    puts \"#{n} is neither a Fizz, nor a FizzBuzz\"\
    \n  end\nend", "  count = 0\n  n.to_s.split(\"\").each do |number|\n    if number.to_i.modulo(11)\
    \ == 0\n      count += 1\n    end\n    if number.to_i.modulo(13) == 0\n      count\
    \ += 1\n    end\n  end\n  count\nend", "  divisible_by_11 = n.to_s.chars.all?\
    \ { |c| c == '1' }\n  divisible_by_13 = n.to_s.chars.all? { |c| c == '3' }\n \
    \ number_within_ten_and_less_than_n = n % 10\n  number_within_ten_and_less_than_n\
    \ = \"0#{number_within_ten_and_less_than_n}\" if number_within_ten_and_less_than_n.length\
    \ == 1\n  number_within_ten_and_less_than_n = \"0#{number_within_ten_and_less_than_n}\"\
    \ if number_within_ten_and_less_than_n.length == 2\n  number_within_ten_and_less_than_n\
    \ = \"0#{number_within_ten_and_less_than_n}\" if number_within_ten_and_less_than_n.length\
    \ == 3\n  number_within_ten_and_less_than_n = \"0#{number_within_ten_and_less_than_n}\"\
    \ if number_within_ten_and_less_than_n.length == 4\n  number_within_ten_and_less_than_n\
    \ = \"0#{number_within_ten_and_less_than_n}\" if number_within_ten_and_less_than_n.length\
    \ == 5\n  number_within_ten_and_less_than_n = \"0#{number_within_ten_and_less_than_n}\"\
    \ if number_within_ten_and_less_than_n.length == 6\n  number_within_ten_and_less_than_n\
    \ = \"0#{number_within_ten_and_less_than_n}\" if number_within_ten_and_less_than_n.length\
    \ == 7\n  number_within_ten_and_less_than_n = \"0#{number_within_ten_and_less_than_n}\"\
    \ if number_within_ten_and_less_than_n.length == 8\n  number_within_ten_and_less_than_n\
    \ = \"0#{number_within_ten_and_less_than_n}\" if number_within_ten_and_less_than_n.length\
    \ == 9\n  number_within_ten_and_less_than_n = \"0#{number_within_ten_and_less_than_n}\"\
    \ if number_within_ten_and_less_than_n.length == 10\n  number_within_ten_and_less_than_n\
    \ = \"0#{number_within_ten_and_less_than_n}\" if number_within_ten_and_less_than_n.length\
    \ == 11\n  number_within_ten_and_less_than_n = \"0#{number_within_ten_and_less_than_n}\"\
    \ if number_within_ten_and_less_than_n.length == 12\n  number_within_ten_and_less_than_n\
    \ = \"0#{number_within_ten_and_less_than_n}\" if ", "  if n==0 then return 0 else\
    \ return fizz_buzz(n-1) if n%11=0 then return 1 else return fizz_buzz(n-1)+1 if\
    \ n%13=0 then return 2 else return fizz_buzz(n-1)+fizz_buzz(n-1)\nend\nfizz_buzz(1000)\
    \ # => 45\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIf you need an explanation why\
    \ a certain solution is better than the other, you can comment on https://stackoverflow.com/q/56660684/12842133\n\
    <|/ c |>\n<| a |>\nThis solution works:\n<code>", "  a = n\n  count = 0\n  while\
    \ (a % 11 != 0)\n    a /= 11\n  end\n  while (a % 13 != 0)\n    a /= 13\n    count\
    \ += 1\n  end\n  return count\nend\nputs fizz_buzz(7)", "  fizz_times = 0\n  buzz_times\
    \ = 0", "  if n % 11 == 0\n    puts \"#{n} is divisible by 11\"\n  elsif n % 13\
    \ == 0\n    puts \"#{n} is divisible by 13\"\n  else\n    puts \"#{n} is not divisible\
    \ by 11 or 13\"\n  end\nend", "  count = 0\n  loop do\n    if n % 11 == 0\n  \
    \    count += 1\n      break\n    end\n    if n % 13 == 0\n      count += 1\n\
    \      break\n    end\n    n /= 10\n  end\n  return count\nend", "  a = 0\n  i\
    \ = 0\n  while (i < n)\n    if (n % 11 == 0 && n % 13 == 0)\n      a += 1\n  \
    \  i += 1\n  a\nend", "  count = n.to_s.count(\"7\")\n  return count if count\
    \ > 0 && n % 11 == 0 or n % 13 == 0 \nend", "    count = 0\n    while n > 0\n\
    \        if n % 11 == 0\n            count = count + 1\n        end\n        if\
    \ n % 13 == 0\n            count = count + 1\n        end\n        n = n / 10\n\
    \    end\n    count\nend\nputs fizz_buzz(2000)\n</code>\n<|/ a dscore=2 tags=ruby,loops\
    \ |>\n<| a dscore=2 |>\nThe shortest answer I can get is:\n<code>\n2.upto(99).select\
    \ { |x| x % 11 == 0 and x % 13 == 0 }\n=> [13, 14, 15, 16, 17, 18, 19, 20, 21,\
    \ 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\
    \ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\
    \ 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,\
    \ 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,\
    \ 98, 99]\n</code>\n<|/ a tags=ruby,loops |>\n<| a dscore=2 |>\n<code>\n2.upto(10).select\
    \ { |n| n != 7 && n % 11 == 0 && n % 13 == 0 }\n</code>\n<|/ a tags=ruby,loops\
    \ |>\n<| a dscore=2 tags=ruby,loops |>\nI love the upto method, and I love the\
    \ select method, but I think the following solution is more concise and easy to\
    \ read:\n<code>\n2.upto(10).select {|n| [11, 13].include? n % 10 }\n=> [13, 14,\
    \ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\
    \ 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,\
    \ 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,\
    \ 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\
    \ 91, 92, 93, 94, 95, 96, 97, 98, 99]\n</code>\n<|/ a |>\n<| a |>\nTry below one.\
    \ It will return only multiples of 10 and multiples of 13.\n<code>\n2.upto(10).select\
    \ {", "    count = 0\n    while n > 0\n        if n % 11 == 0\n            count\
    \ += 1\n        elsif n % 13 == 0\n            count += 1\n        n -= 1\n  \
    \  end\n    count\nend", "  count = 0\n  n.times do |i|\n    if i.modulo(11) ==\
    \ 0 || i.modulo(13) == 0\n      count += 1\n    end\n  end\n  count\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nYou can just use modulo:\n<code>", "  count = 0\n\
    \  while n > 0\n    if n % 13 == 0 || n % 11 == 0\n      count  += 1 # Count how\
    \ many times the digit 7 appears in integers less than n which are divisible by\
    \ 11 or 13.\n    n /= 10\n  end\n  return count\nend", "    # Write your code\
    \ here.\nend\n</cell>\n<code language=julia-1.0>", "  if n < 0\n    return 0\n\
    \  else\n    if n % 11 == 0\n      return 1\n    elsif n % 13 == 0\n      return\
    \ 2\n    else\n      return 0\n    end\n  end\nend\n</code>\n<|/ a dscore=2 tags=ruby\
    \ |>\n<| a dscore=1 |>\nThis should do it:\n<code>", "  if n < 13\n    return\
    \ 0\n  elsif n >= 13 && n < 17\n    return 1\n  elsif n >= 17 && n < 21\n    return\
    \ 2\n  elsif n >= 21 && n < 27\n    return 3\n  elsif n >= 27 && n < 31\n    return\
    \ 4\n  elsif n >= 31\n    return 5\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nIf you run `fizz_buzz(21)`, it will give you `fizz_buzz(Integer)` not\
    \ `nil` but `42`.\n<|/ c |>\n<| c |>\nYes, I realised that shortly after I posted\
    \ my answer. `if n` is too late in the method. Just move `if n < 13` above `elsif\
    \ n < 17`.\n<|/ c |>\n<| a |>\nOne line solution:\n<code>", "  count = 0\n  1.upto(n.to_s)\
    \ do |i|\n    if i.to_s.include?(7)\n      count += 1\n    elsif i.to_s.include?(11)\n\
    \      count += 1\n    elsif i.to_s.include?(13)\n      count += 1\n    elsif\
    \ i.to_s.include?(15)\n      count += 1\n    elsif i.to_s.include?(17)\n     \
    \ count += 1\n    elsif i.to_s.include?(19)\n      count += 1\n    elsif i.to_s.include?(23)\n\
    \      count += 1\n    elsif i.to_s.include?(29)\n      count += 1\n    elsif\
    \ i.to_s.include?(37)\n      count += 1\n    elsif i.to_s.include?(43)\n     \
    \ count += 1\n    elsif i.to_s.include?(49)\n      count += 1\n    elsif i.to_s.include?(59)\n\
    \      count += 1\n    elsif i.to_s.include?(67)\n      count += 1\n    elsif\
    \ i.to_s.include?(73)\n      count += 1\n    elsif i.to_s.include?(79)\n     \
    \ count += 1\n    elsif i.to_s.include?(87)\n      count += 1\n    elsif i.to_s.include?(93)\n\
    \      count += 1\n    elsif i.to_s.include?(99)\n      count += 1\n    elsif\
    \ i.to_s.include?(111)\n      count += 1\n    elsif i.to_s.include?(131)\n   \
    \   count += 1\n    elsif i.to_s.include?(151)\n      count += 1\n    elsif i.to_s.include?(171)\n\
    \      count += 1\n    elsif i.to_s.include?(191)\n      count += 1\n    elsif\
    \ i.to_s.include?(231)\n      count += 1\n    elsif i.to_s.include?(291)\n   \
    \   count += 1\n    elsif i.to_s.include?(371)\n      count += 1\n    elsif i.to_s.include?(437)\n\
    \      count += 1\n    elsif i.to_s.include?(493)\n      count += 1\n    elsif\
    \ i.to_s.include?(593)\n      count += 1\n    elsif i.to_s.include?(677)\n   \
    \   count += 1\n    elsif i.to_s.include?(737)\n      count += 1\n    elsif i.to_s.include?(797)",
  "  if n <= 0\n    return n\n  else\n    digit = n % 10\n    if digit == 7\n    \
    \  fizz_buzz(n/10)\n    elsif digit == 3 || digit == 5\n      fizz_buzz((n/10)\
    \ + 1)\n    elsif digit == 9 || digit == 11\n      fizz_buzz((n/10) + 11)\n  \
    \  else\n      fizz_buzz((n/10) + 13)\n    end\n  end\nend", "  result = 1\n \
    \ n.times {\n    result *= n % 11\n    result *= n % 13\n    result *= n % 7\n\
    \  }\n  result\nend", "  number_to_test = n.to_s.split(\"\")\n  number_to_test.each\
    \ do |value|\n    value.upcase!\n    value.gsub!(/[13579]/,\"\")\n    value.gsub!(/[36]/,\"\
    \")\n    value.gsub!(/[8]/,\"\")\n    value.to_i.times { |i| return i if value\
    \ == i.to_s }\n  end\n  0\nend", "  count = 0\n  while n > 0\n    count += n >=\
    \ 11 || n % 13 == 0\n    n /= 11\n    n /= 13\n  end\n  count\nend\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  if n < 1000\n    return n\n  else \n    puts \"\
    Please enter a number between 1000 and 9999.\"\n    return fizz_buzz(gets)\n \
    \ end\nend", "  (2..n).each do |i|\n    if i.to_s.include?(\"11\")\n      puts\
    \ \"Buzz\"\n    elsif i.to_s.include?(\"13\")\n      puts \"Fizz\"\n    else\n\
    \      puts i\n    end\n  end\nend\nfizz_buzz(10)", "  count = 0\n  while n >\
    \ 0\n    count += 1\n    n -= 1\n  end\n  count\nend", "    count = 0\n    while\
    \ n > 0 \n        if n % 15 == 0 \n            count += 1\n        elsif n % 11\
    \ == 0 \n            count += 1\n        elsif n % 13 == 0 \n            count\
    \ += 1\n        elsif n % 7 == 0 \n            count += 1\n        elsif n % 11\
    \ == 1 \n            count += 1\n        elsif n % 13 == 1 \n            count\
    \ += 1\n        elsif n % 17 == 1 \n            count += 1\n        elsif n %\
    \ 17 == 1 \n            count += 1\n        elsif n % 23 == 1 \n            count\
    \ += 1\n        elsif n % 17 == 1 \n            count += 1\n        elsif n %\
    \ 7 == 1 \n            count += 1\n        elsif n % 13 == 1 \n            count\
    \ += 1\n        elsif n % 17 == 1 \n            count += 1\n        elsif n %\
    \ 19 == 1 \n            count += 1\n        elsif n % 17 == 1 \n            count\
    \ += 1\n        elsif n % 7 == 1 \n            count += 1\n        elsif n % 11\
    \ == 1 \n            count += 1\n        elsif n % 13 == 1 \n            count\
    \ += 1\n        elsif n % 17 == 1 \n            count += 1\n        elsif n %\
    \ 19 == 1 \n            count += 1\n        elsif n % 7 == 1 \n            count\
    \ += 1\n        elsif n % 11 == 1 \n            count += 1\n        elsif n %\
    \ 13 == 1 \n            count += 1\n        elsif n % 17 == 1 \n            count\
    \ += 1\n        elsif n % 19 == 1 \n            count += 1\n        elsif n %\
    \ 7 == 1 \n            count += 1\n        elsif n % 11 == 1 \n            count\
    \ += 1\n        elsif n % 13 == 1 \n            count += 1\n        elsif n %\
    \ 17 == 1 \n            count += 1\n        elsif n % 19 == 1 \n            count\
    \ += 1\n        elsif n % 7 == 1 \n            count += 1\n        elsif n % 11\
    \ == 1 \n            count += 1\n        elsif n % 13 == 1 \n            count\
    \ += 1\n        elsif n % 17 == 1 \n            count += 1\n        elsif n %\
    \ 19 == 1 \n            count += 1\n        elsif n % 7 == 1 \n            count\
    \ += 1\n        elsif n % 11 == 1 \n            count += 1\n        elsif n %\
    \ 13 == 1 \n            count += 1\n        elsif n % 17 == 1 \n            count\
    \ += 1\n        elsif n % 19 == 1 \n            count += 1\n        elsif n %\
    \ 7 == 1 \n            count += 1\n        elsif n % 11 == 1 \n            count\
    \ += 1\n        elsif n % 13 == 1 \n            count += 1\n        elsif n %\
    \ 17 == 1 \n            count += 1\n        elsif n % 19 == 1 \n            count\
    \ += 1\n        elsif n % 7 == 1 \n            ", "  if n<=0 then return nil\n\
    \  a=[]\n  1.upto(n) do |i|\n    if i.is_a? Fixnum\n      if i.to_s.chars.reduce(:+).to_s=='11'\
    \ or i.to_s.chars.reduce(:+).to_s=='13' then\n        a.push(i)\n      end\n \
    \   end\n  end\n  return a.count\nend\nputs fizz_buzz(7)", "  counter = -1\n \
    \ while n > 0\n    counter += 1\n    if n % 11 == 0\n      puts \"#{n} is a Fizz\
    \ Buzz.\"\n    elsif n % 13 == 0\n      puts \"#{n} is a Fizz and a Buzz.\"\n\
    \    else\n      puts \"#{n} is a #{counter} digit number.\"\n    end\n    n -=\
    \ counter\n  end\nend", "  return n >= 11 || n >= 13\nend\n</code>\nNow you just\
    \ need to call it and display its result\n<code>\nputs fizz_buzz(10)\n</code>\n\
    <|/ a dscore=3 tags=ruby,fizzbuzz |>\n<| a |>\n<code>", "  fizz_times = 0\n  buzz_times\
    \ = 0", "    count = 0\n    number = n.to_s\n    numbers = number.split(//)\n\
    \    numbers.each do |num|\n        if (num % 11) == 0\n            count += 1\n\
    \        end\n        if (num % 13) == 0\n            count += 1\n        end\n\
    \    end\n    return count\nend", "    count = 0\n    if n <= 100\n        count\
    \ += 1\n        if n % 11 == 0\n            count += 1\n        if n % 13 == 0\n\
    \            count += 1\n    end\n    count\nend", "  # Write your code here.\n\
    \  return n if n <= 20 then (n % 11 + n % 13) ? 1 : 2 end\nend\n</cell>\n<cell>",
  "  if n % 11 == 0\n    puts \"Fizz Buzz\"\n  elsif n % 13 == 0\n    puts \"Fizz\"\
    \n  else\n    puts \"Buzz\"\n  end\nend", "  return 0 if (n % 11 == 0 || n % 13\
    \ == 0) && n != 0\n  return 1 if (n % 11 == 0 || n % 13 == 0) && n == 0\n  return\
    \ 2 if (n % 11 == 0 && n % 13 == 0) && n != 0\n  return 3 if (n % 11 == 0 && n\
    \ % 13 == 0) && n == 0\n  return 4 if (n % 11 == 0 && n % 13 != 0) && n != 0\n\
    \  return 5 if (n % 11 != 0 && n % 13 == 0) && n != 0\n  return 6 if (n % 11 !=\
    \ 0 && n % 13 == 0) && n == 0\n  return 7 if (n % 11 != 0 && n % 13 != 0) && n\
    \ != 0\nend", "  i = 0\n  while i <= n\n    if i % 11 == 0 and i % 13 == 0\n \
    \     puts \"#{n} is a Fizz Buzz\"\n    elsif i % 11 == 0\n      puts \"#{n} is\
    \ a Fizz\"\n    elsif i % 13 == 0\n      puts \"#{n} is a Buzz\"\n    else\n \
    \     puts \"#{n} is a #{n}\"\n    end\n    i += 1\n  end\nend", "    digits =\
    \ n.to_s.split(//)\n    count = 0\n    digits.each do |digit|\n        if digit.to_s.include?('7')\n\
    \            count += 1\n        end\n        if digit.to_s.include?('11')\n \
    \           count += 1\n        end\n        if digit.to_s.include?('13')\n  \
    \          count += 1\n        end\n    end\n    count\nend", "  count = 0\n \
    \ loop do\n    if n % (11 * 11) == 0 || n % (13 * 13) == 0\n      count += 1\n\
    \    end\n    n -= 1\n    break if n == 0\n  end\n  count\nend", "  count = 0\n\
    \  while n > 0\n    if n % 11 == 0\n      count += 1\n      n /= 11\n    elsif\
    \ n % 13 == 0\n      count += 1\n      n /= 13\n    end\n  end\n  count\nend",
  "  if n==0 || n==1\n    return 0\n  else\n    count_of_n_less_than_n_divisible_by_11=0\n\
    \    count_of_n_less_than_n_divisible_by_13=0\n    \n    number_modulo11=n%11\n\
    \    number_modulo13=n%13\n    \n    if number_modulo11==0\n      count_of_n_less_than_n_divisible_by_11=count_of_n_less_than_n_divisible_by_11+1\n\
    \      if number_modulo13==0\n        count_of_n_less_than_n_divisible_by_13=count_of_n_less_than_n_divisible_by_13+1\n\
    \      end\n    end\n    if number_modulo13==0\n      count_of_n_less_than_n_divisible_by_13=count_of_n_less_than_n_divisible_by_13+1\n\
    \    end\n    \n    if count_of_n_less_than_n_divisible_by_11>count_of_n_less_than_n_divisible_by_13\n\
    \      count_of_n_less_than_n_divisible_by_11\n    else\n      count_of_n_less_than_n_divisible_by_13\n\
    \    end\n  end\nend", "  while n != 0\n    if n % 7 == 0 && n != 11 && n != 13\n\
    \      puts n\n      break\n    end\n    n /= 10\n  end\nend\n</code>\nI hope\
    \ you find this useful.\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe Fibonacci Sequence\
    \ is pretty simple to understand.  Just imagine that each number is a step of\
    \ the sequence.\n<code>\nF(0) = 0\nF(1) = 1\nF(y) = F(y-1) + F(y-2)\n</code>\n\
    So F(10) = F(9) + F(8) + F(7) + F(6) + F(5) + F(4) + F(3) + F(2) + F(1) + F(0)\n\
    To write this in Ruby would be something like\n<code>", "  nums=n.to_s.split(//).map(&:to_i)\n\
    \  count=0\n  for i in 0...nums.size\n    if nums[i]%11==0 && nums[i]%13==0\n\
    \      count=count+1\n    end\n  end\n  return count\nend", "  case n when 11\
    \ then \"FizzBuzz\"\n  when 13 then \"FizzBuzz\"\n  else \n    n.to_s.chars.map.with_index\
    \ do |char, index|\n      char == \"7\" and index != 0 and (index != 11 and index\
    \ != 13) ? \"#{char}#{fizz_buzz(n - index)}\" : char\n    end.join\n  end\nend",
  "    if n < 15\n        return n\n    count = 0\n    while n < 15\n        if n\
    \ % 11 == 0 # divisible by 11\n            count += 1\n        if n % 13 == 0\
    \ # divisible by 13\n            count += 1\n        n /= 11\n        n /= 13\n\
    \    end\n    return count\nend\n</cell>\n<code language=julia-1.5>\nfizz_buzz(15)\n\
    </cell>\n<text>\nWhile Loops", "  count = 0\n  while n > 11 && n < 1000\n    if\
    \ n % 11 == 0\n      count += 1\n      n /= 11\n    elsif n % 13 == 0\n      count\
    \ += 1\n      n /= 13\n    end\n  end\n  count\nend\n</code>\n<|/ a dscore=1 tags=ruby,fizzbuzz,if-statement,while-loop\
    \ |>\n<| c |>\nThanks a ton! This is what I am looking for!\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere's another approach that uses map to return the list of fizzbuzz values.\
    \ It also works with numbers over 10000, with all the fizzbuzz values returned\
    \ at once.\n<code>", "  # Get the numbers from 0 to n.\n  numbers = (0...n)\n\
    \  # Loop through the numbers and print a message for each number that is a multiple\
    \ of 11 and 13 and a message for each number that is not a multiple of 11 and\
    \ 13.\n  numbers.each do |number|\n    if number % 11 == 0 & number % 13 == 0\n\
    \      puts \"#{number} is a multiple of 11 and 13.\"\n    elsif number % 11 !=\
    \ 0 & number % 13 != 0\n      puts \"#{number} is not a multiple of 11 and 13.\"\
    \n    else\n      puts \"#{number} is not a multiple of 11 or 13.\"\n    end\n\
    \  end\nend", "  # Only use loops that will execute for less than n, or else a\
    \ negative number will occur.\n  if n < 0 || n % 11 == 0 || n % 13 == 0 || n ==\
    \ 0 || n == 1\n    return 0\n  else\n    count = 1\n    while n != 1\n      #\
    \ While n is not a multiple of 11 and 13 we increment the count by one.\n    \
    \  n /= 11\n      n /= 13\n      count += 1\n    end\n    return count\n  end\n\
    end", "  i = 0\n  while i < n\n    puts i if (i % 11 == 0 || i % 13 == 0)\n  \
    \  i += 1\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your\
    \ solution, however this only counts how many times `7` appears in each number,\
    \ I want to count how many times each number appears in each number of the number\
    \ `1..n` which are not divisible by `11` or `13`.\n<|/ c |>\n<| c |>\nAh I see.\
    \ I misinterpreted your question. Sorry.\n<|/ c |>\n<| a |>\nHere's a simple way\
    \ to do it without using loops.\nThe first step is to use a regex to find 7 digits,\
    \ excluding any that are divisible by 11 or 13:\n<code>\nputs \"Enter the number\
    \ to find fizzbuzz:\"\nnumber = gets.chomp.to_i\nfizzbuzz = number.to_s.gsub(/7(\\\
    d7)?\\z/, '')\n</code>\nThe second step is to use the regex to find each number\
    \ that doesn't match this regex:\n<code>\nputs \"The number #{number} has #{number[7..-1].gsub(/\\\
    d7\\z/, '')} digits that are not divisible by 11 or 13.\"\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a dscore=0 tags=ruby |>\n<code>", "  count = 0\n  n.times {\
    \ |i| count = count + ((i / 11.0).even? && (i % 13.0).even?) ? 0 : 1 }\n  return\
    \ count\nend\n</code>\n<|/ a dscore=0 tags=fizzbuzz,ruby,arrays |>\n<| a |>\n\
    This is a solution in Ruby 1.8.7\n<code>\narray1 = [1,2,3]\narray2 = [\"a\",\"\
    b\",\"c\",\"d\"]\narray3 = [\"1\",\"2\",\"3\"]\narray4 = [\"4\",\"5\",\"6\"]\n\
    array5 = [\"7\",\"8\",\"9\"]\narray6 = [\"10\",\"11\",\"12\"]", "  fizz_count\
    \ = 0\n  buzz_count = 0\n  while n > 0 do\n    if n % 11 == 0 and n % 13 == 0\
    \ then\n      fizz_count = fizz_count + 1\n    end\n    buzz_count = buzz_count\
    \ + 1\n    n = n / 10\n  end\n  return fizz_count, buzz_count\nend", "  arr =\
    \ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 21, 23, 25, 27, 31, 33,\
    \ 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71,\
    \ 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\n  count = 0\n  for\
    \ i in 1..n do\n    if i.modulo(11) == 0 or i.modulo(13) == 0\n      count +=\
    \ 1\n    elsif arr.include?(i)\n      count += 1\n    end\n  end\n  return count\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 |>\nA fun one!\n<code>", "    return n.divmod(11*13).count{|a|\
    \ a==7}\nend\n</code>\n<|/ a tags=ruby,algorithm,fizzbuzz |>\n<| a tags=ruby,algorithm,fizzbuzz\
    \ |>\nI find this solution more readable (at least to me):\n<code>", "  if n<0\n\
    \    return \"This is not a positive integer\"\n  else\n    count=0\n    loop\
    \ do\n      if n%11==0\n        count+=1\n        n=n/11\n        break\n    \
    \  elsif n%13==0\n        count+=1\n        n=n/13\n        break\n      end\n\
    \    end\n    return count\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThat is true,\
    \ but it is better to restructure the function with breaks.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,fizzbuzz |>\nHere's my take on it.  It's a little shorter than the\
    \ others, more readable, and doesn't use breaks or anything like that.\n<code>",
  "  return n.digits.count { |s| s == 7 }\nend", "  return n.times.map do |n|\n  \
    \  case n\n    when 0...9\n      n % 10\n    when 10...13\n      \"Fizz Buzz\"\
    \n    when 14...17\n      \"FizzBuzz\"\n    else\n      n\n    end\n  end\nend",
  "  count = 0\n  while n < 100\n    if n % 11 == 0\n      count += 1\n      n /=\
    \ 11\n    elsif n % 13 == 0\n      count += 1\n      n /= 13\n    elsif n != 0\n\
    \      count += 1\n      n /= 10\n    end\n  end\n  count\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\nA Python 3 version of the accepted answer:\n<code>", "  n = 0 if\
    \ n < 10 else n\n  n = 0 if n < 10 else n\n  return n\nend", "  n.to_s.split('').count\
    \ { |x| x.to_i%3==0 || x.to_i%5==0 }\nend", "  count = 0\n  (1..n).each { |i|\
    \ \n    if (i.modulo(11).zero?) && (i.modulo(13).zero?)\n      count += 1 if (i.modulo(7).zero?)\n\
    \    end\n  }\n  count\nend", "  count = 0\n  for i in 0..999\n    if i % 11 ==\
    \ 0 and i % 13 == 0\n      count += 1\n    end\n  end\n  return count\nend\n</code>\n\
    And now you can call the function to count the occurences and return an Array\
    \ of Strings containing the fizz_buzz counts for an arbitrary number.\n<code>",
  "    if n.to_s.include?(\"7\")\n        n.to_s.count(\"7\")\n    else\n        n.to_s.scan(/[12]\\\
    d{2}/).count\n    end\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThe \"\
    if n.to_s.include?(\"7\")\" is unnecessary, the return statement will take care\
    \ of it. Also, I'd suggest using the case statement instead of the if statement.\n\
    <|/ c |>\n<| c |>\nTrue. I would also probably use String#scan instead of String#count\
    \ - that way you could scan for multiple digits. And I'd probably use String#gsub\
    \ for parsing the string into individual digits.\n<|/ c |>\n<| c |>\nThe case\
    \ statement looks great for Ruby 1.9.\n<|/ c |>\n<| a tags=ruby,regex dscore=2\
    \ |>\nUsing split and map will make your code much simpler:\n<code>", "  # This\
    \ list holds the digits that we are going to print. Initially it is empty.\n \
    \ fizzbuzz = []\n  \n  # Since there are 10 numbers below n which are divisible\
    \ by 11 or 13, we could go through them\n  # by steps of 10. The first step will\
    \ cause us to print the first three numbers in the list.\n  # The second step\
    \ will cause us to print the last three numbers in the list.\n  # The third step\
    \ will cause us to print the numbers divisible by 11.\n  # The fourth step will\
    \ cause us to print the numbers divisible by 13.\n  # The fifth step will cause\
    \ us to print the numbers divisible by both 11 and 13.\n  # The sixth step will\
    \ cause us to print a series of numbers divisible by both 11 and 13.\n  # The\
    \ seventh step will cause us to print a series of numbers divisible by 11.\n \
    \ # The eight step will cause us to print a series of numbers divisible by 13.\n\
    \  # The ninth step will cause us to print a series of numbers divisible by 11\
    \ and 13.\n  # The tenth step will cause us to print a series of numbers divisible\
    \ by 11 and 13.\n  \n  while n > 0\n    if n % 11 == 0\n      fizzbuzz << n\n\
    \      n /= 11\n    elsif n % 13 == 0\n      fizzbuzz << n\n      n /= 13\n  \
    \  elsif n % 11 == 0 % 13 == 0\n      fizzbuzz << n\n      n /= 11\n      n /=\
    \ 13\n    else\n      fizzbuzz << n\n      n /= 11\n      n /= 13\n    end\n \
    \ end\n  \n  # The first element in the list is the least significant digit in\
    \ the number\n  # The length of the list is equal to the number of digits in the\
    \ number\n  # The element at position k is the kth digit in the number where k\
    \ ranges from 0 to n-1\n  # The element at position k+1 is the k+1th digit in\
    \ the number where k ranges from 0 to n-1\n  \n  # Print fizzbuzz list with the\
    \ first element of the list being at position 0.\n  puts fizzbuzz[0]\n  \n  #\
    \ For each element in fizzbuzz, print the element at position k and the element\
    \ at position k+1.\n  # Notice that there are 10 numbers below n which are divisible\
    \ by 11 or 13\n  # Print the first three numbers in the list by steps of 10\n\
    \  # Print the last three numbers in the list by steps of 10\n  # Print the numbers\
    \ divisible by 11 by steps of 10\n  # Print the numbers divisible by 13 by steps\
    \ of 10\n", "  count = 0\n  n.times do |i|\n    if i % 11 == 0 and i % 13 == 0\n\
    \      count += 1\n    else\n      count = 0\n    end\n  end\n  count\nend", " \
    \ (0..n).each do |i|\n    if i % 11 == 0\n      print \"Fizz Buzz\"\n    elsif\
    \ i % 13 == 0\n      print \"FizzBuzz\"\n    else\n      print i\n    end\n  end\n\
    end", "  if n <= 0\n    return n\n  elsif n <= 9\n    return \"Fizz\"\n  elsif\
    \ n % 11 == 0\n    return \"Buzz\"\n  else\n    return n\n  end\nend", "  count\
    \ = 0\n  n.downto(1) do |i|\n    count += 1 if i % 11 == 0 && i % 13 == 0\n  end\n\
    \  return count\nend", "  count = 0\n  \n  while n > 0\n    if n % 11 == 0\n \
    \     count += 1\n      n /= 11\n    else\n      count += 1\n      n /= 13\n \
    \   end\n  end\n  \n  count\nend\n</cell>\n<code language=conda-env-pydata-py>\n\
    fizz_buzz(123456789)\n</cell>\n<code language=conda-env-pydata-py>\nfizz_buzz(987654321)\n\
    </cell>\n<code language=conda-env-pydata-py>\nfizz_buzz(1000000000000)\n</cell>\n\
    <text>\nA common pattern is to apply the same algorithm to each digit in an integer.\
    \ For example, fizz_buzz(12345) returns [1,2,3,4,5,6,7,8], fizz_buzz(9876) returns\
    \ [9,8,7,6,5,4,3], and so on. Write a method called fizz_buzz_with_each_digit(n)\
    \ that takes in a positive integer n and returns an array of all of the fizz and\
    \ buzz digits of n.", "  count = 0\n  if n <= 0 \n    count = 0\n  elsif n % 11\
    \ == 0\n    count += 1\n  elsif n % 13 == 0\n    count += 1\n  end\n  return count\n\
    end", "    if n % 11 == 0 or n % 13 == 0\n        \"#{n} is divisible by 11 and\
    \ 13\"\n    else\n        \"#{n} is not divisible by 11 and 13\"\n    end\nend\n\
    </cell>\n<text>\nThis function is equivalent to the following:", "  if n <= 13\n\
    \    return n % 11 == 0 and n % 13 == 0\n  else\n    digits = [7, 11, 13, 17]\n\
    \    digs = digits.sample\n    num = n\n    count = 0\n    until num == 0 do\n\
    \      num = num % 10\n      count += 1\n      break if digs.include?(num)\n \
    \   end\n    return num == digs.last and count <= 2\n  end\nend", "  if n < 13\n\
    \    puts \"#{n} is divisible by 11 or 13\"\n  elsif n == 12\n    puts \"#{n}\
    \ is divisible by 12\"\n  else\n    puts \"#{n} is not divisible by 11 or 13\"\
    \n  end\nend\nfizz_buzz(8)", "  count = 0\n  while n > 0\n    if n%11 == 0\n \
    \     count += 1 # count += 1 will increment count by 1 every time the digit is\
    \ found\n    elsif n%13 == 0\n      count += 1 # count += 1 will increment count\
    \ by 1 every time the digit is found\n    end\n    n -= 1\n  end\n  return count\n\
    end", "    numbers = n.to_s.split(\"\")\n    numbers.each do |number|\n      \
    \  if number == \"7\"\n            numbers.delete(\"7\")\n            break\n\
    \        end\n        if number == \"11\" || number == \"13\"\n            numbers.delete(\"\
    11\" || \"13\")\n            break\n        end\n    end\n    return numbers.count\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe best answer by is good\
    \ for the example but does not do any actual checking of the string. This can\
    \ be done with regex by changing the test to /^7$/ and the count can be found\
    \ with .match(/7/m).\nHere is how I would write it using Enumerable#each_cons:\n\
    <code>", "  count = 0\n  if n < 10\n    count += 1\n  elsif n < 13\n    count\
    \ += 1\n  elsif n % 10 == 7 && n % 11 != 0 || n % 10 == 13 && n % 11 == 0\n  \
    \  count += 1\n  end\n  return count\nend", "  result = 0\n  if n % 11 == 0\n\
    \    result += 1\n  elsif n % 13 == 0\n    result += 1\n  elsif n % 17 == 0\n\
    \    result += 1\n  elsif n % 15 == 0\n    result += 1\n  elsif n % 7 == 0\n \
    \   result += 1\n  elsif n % 5 == 0\n    result += 1\n  elsif n % 3 == 2\n   \
    \ result += 1\n  else\n    result = 0\n  end\n  result\nend", "  counter1 = 0\n\
    \  counter2 = 0\n  counter3 = 0\n  counter4 = 0\n  counter5 = 0\n  counter6 =\
    \ 0\n  counter7 = 0\n  counter8 = 0\n  counter9 = 0\n  counter10 = 0\n  counter11\
    \ = 0\n  counter12 = 0\n  counter13 = 0\n  counter14 = 0\n  counter15 = 0\n  counter16\
    \ = 0\n  counter17 = 0\n  counter18 = 0\n  counter19 = 0\n  counter20 = 0\n  counter21\
    \ = 0\n  counter22 = 0\n  counter23 = 0\n  counter24 = 0\n  counter25 = 0\n  counter26\
    \ = 0\n  counter27 = 0\n  counter28 = 0\n  counter29 = 0\n  counter30 = 0\n  counter31\
    \ = 0\n  counter32 = 0\n  counter33 = 0\n  counter34 = 0\n  counter35 = 0\n  counter36\
    \ = 0\n  counter37 = 0\n  counter38 = 0\n  counter39 = 0\n  counter40 = 0\n  counter41\
    \ = 0\n  counter42 = 0\n  counter43 = 0\n  counter44 = 0\n  counter45 = 0\n  counter46\
    \ = 0\n  counter47 = 0\n  counter48 = 0\n  counter49 = 0\n  counter50 = 0\n  counter51\
    \ = 0\n  counter52 = 0\n  counter53 = 0\n  counter54 = 0\n  counter55 = 0\n  counter56\
    \ = 0\n  counter57 = 0\n  counter58 = 0\n  counter59 = 0\n  counter60 = 0\n  counter61\
    \ = 0\n  counter62 = 0\n  counter63 = 0\n  counter64 = 0\n  counter65 = 0\n  counter66\
    \ = 0\n  counter67 = 0\n  counter68 = 0\n  counter69 = 0\n  counter70 = 0\n  counter71\
    \ = 0\n  counter72 = 0\n  counter73 = 0\n  counter74 = 0\n  counter75 = 0\n  counter76\
    \ = 0\n  counter77 = 0\n  counter78 = 0\n  counter79 = 0\n  counter80 = 0\n  counter81\
    \ = 0\n  counter82 = 0\n  counter83 = 0\n  counter84 = 0\n  counter85 = 0\n  counter86\
    \ = 0\n  counter87 = 0\n  counter88 = 0\n  counter89 = 0\n  counter90 = 0\n  counter91\
    \ = 0\n  counter92 = 0\n  counter93 = 0\n  counter94 = 0\n  counter95 = 0\n  counter96\
    \ = 0\n  counter97 = 0\n  counter98 = 0\n  counter99 = 0\n  counter100 = 0\n \
    \ counter101 = 0\n  counter102 = 0\n  counter", "  counter = 0\n  for i in n\n\
    \    if i % 11 == 0\n      counter += 1\n      if i % 13 == 0\n        counter\
    \ += 1\n    end\n  end\n  counter\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=ruby |>\nThis simple solution uses Enumerator which is more comprehensive:\n\
    <code>", "    count = 0\n    if n.modulo 11 == 0\n        count += 1\n    elsif\
    \ n.modulo 13 == 0\n        count += 1\n    end\n    if count > 1\n        puts\
    \ 'FizzBuzz'\n    elsif count == 1\n        puts n\n    end\nend\nfizz_buzz(100)\n\
    fizz_buzz(50)\nfizz_buzz(13)\nfizz_buzz(9)\nfizz_buzz(7)\nfizz_buzz(6)\nfizz_buzz(5)\n\
    fizz_buzz(4)\nfizz_buzz(3)\nfizz_buzz(2)\nfizz_buzz(1)\nfizz_buzz(11)\nfizz_buzz(12)\n\
    fizz_buzz(13)\nfizz_buzz(14)\nfizz_buzz(15)\nfizz_buzz(16)\nfizz_buzz(17)\nfizz_buzz(18)\n\
    fizz_buzz(19)\nfizz_buzz(20)\nfizz_buzz(21)\nfizz_buzz(22)\nfizz_buzz(23)\nfizz_buzz(24)\n\
    fizz_buzz(25)\nfizz_buzz(26)\nfizz_buzz(27)\nfizz_buzz(28)\nfizz_buzz(29)\nfizz_buzz(30)\n\
    fizz_buzz(31)\nfizz_buzz(32)\nfizz_buzz(33)\nfizz_buzz(34)\nfizz_buzz(35)\nfizz_buzz(36)\n\
    fizz_buzz(37)\nfizz_buzz(38)\nfizz_buzz(39)\nfizz_buzz(40)\nfizz_buzz(41)\nfizz_buzz(42)\n\
    fizz_buzz(43)\nfizz_buzz(44)\nfizz_buzz(45)\nfizz_buzz(46)\nfizz_buzz(47)\nfizz_buzz(48)\n\
    fizz_buzz(49)\nfizz_buzz(50)\nfizz_buzz(51)\nfizz_buzz(52)\nfizz_buzz(53)\nfizz_buzz",
  "  count=0\n  loop do\n    count+=1\n    break if n<100\n    break if (n/11)%11==0\
    \ || (n/13)%13==0\n    break if n%11==0 and n%13==0\n  end\n  count\nend\nputs\
    \ fizz_buzz(999)\nputs fizz_buzz(1000)\nputs fizz_buzz(1001)\nputs fizz_buzz(1002)\n\
    puts fizz_buzz(1003)\nputs fizz_buzz(1004)\nputs fizz_buzz(1005)\nputs fizz_buzz(1006)\n\
    puts fizz_buzz(1007)\nputs fizz_buzz(1008)\nputs fizz_buzz(1009)\nputs fizz_buzz(1010)\n\
    puts fizz_buzz(1011)\nputs fizz_buzz(1012)\nputs fizz_buzz(1013)\nputs fizz_buzz(1014)\n\
    puts fizz_buzz(1015)\nputs fizz_buzz(1016)\nputs fizz_buzz(1017)\nputs fizz_buzz(1018)\n\
    puts fizz_buzz(1019)\nputs fizz_buzz(1020)\nputs fizz_buzz(1021)\nputs fizz_buzz(1022)\n\
    puts fizz_buzz(1023)\nputs fizz_buzz(1024);", "    count = 0\n    while n > 0\n\
    \        if n % 11 == 0\n            count = count + 1\n            if count >\
    \ 1\n                return count\n            end\n        end\n        if n\
    \ % 13 == 0\n            count = count + 1\n            if count > 1\n       \
    \         return count\n            end\n        end\n        n = n / 11\n   \
    \     count = count + 1\n        if count > 1\n            return count\n    \
    \    end\n        n = n / 13\n        count = count + 1\n        if count > 1\n\
    \            return count\n        end\n    end\nend", "  if n == 0\n    return\
    \ \"0\"\n  else\n    str = n.to_s\n    str.gsub!(\"1\",\"3\")\n    str.gsub!(\"\
    2\",\"4\")\n    str.gsub!(\"3\",\"5\")\n    str.gsub!(\"4\",\"6\")\n    str.gsub!(\"\
    5\",\"7\")\n    str.gsub!(\"6\",\"8\")\n    str.gsub!(\"7\",\"9\")\n    str.gsub!(\"\
    8\",\"0\")\n    str.gsub!(\"9\",\"0\")\n    str.gsub!(\"10\",\"0\")\n    str.gsub!(\"\
    11\",\"0\")\n    str.gsub!(\"12\",\"0\")\n    str.gsub!(\"13\",\"0\")\n    str.gsub!(\"\
    14\",\"0\")\n    str.gsub!(\"15\",\"0\")\n    str.gsub!(\"16\",\"0\")\n    str.gsub!(\"\
    17\",\"0\")\n    str.gsub!(\"18\",\"0\")\n    str.gsub!(\"19\",\"0\")\n    str.gsub!(\"\
    20\",\"0\")\n    str.gsub!(\"21\",\"0\")\n    str.gsub!(\"22\",\"0\")\n    str.gsub!(\"\
    23\",\"0\")\n    str.gsub!(\"24\",\"0\")\n    str.gsub!(\"25\",\"0\")\n    str.gsub!(\"\
    26\",\"0\")\n    str.gsub!(\"27\",\"0\")\n    str.gsub!(\"28\",\"0\")\n    str.gsub!(\"\
    29\",\"0\")\n    str.gsub!(\"30\",\"0\")\n    str.gsub!(\"31\",\"0\")\n    str.gsub!(\"\
    32\",\"0\")\n    str.gsub!(\"33\",\"0\")\n    str.gsub!(\"34\",\"0\")\n    str.gsub!(\"\
    35\",\"0\")\n    str.gsub!(\"36\",\"0\")\n    str.gsub!(\"37\",\"0\")\n    str.gsub!(\"\
    38\",\"0\")\n    str.gsub!(\"39\",\"0\")\n    str.gsub!(\"40\",\"0\")\n    str.gsub!(\"\
    41\",\"0\")\n    str.gsub!(\"42\",\"0\")\n    str.gsub!(\"43\",\"0\")\n    str.gsub!(\"\
    44\",\"0\")\n    str.gsub!(\"45\",\"0\")\n    str.gsub!(\"46\",\"0\")\n    str.gsub!(\"\
    47\",\"0\")\n    str.gsub!(\"48\",\"0\")\n    str.gsub!(\"49\",\"0\")\n    str.",
  "  arr = [11, 13, 17]\n  count = 0\n  for i in arr\n    count = count + if n % i\
    \ == 0 then 1 else 0\n  end\n  return count\nend", "  (0..9).each do |d|\n   \
    \ (n.to_s.split(d).uniq.count.to_s+\"x\"+n.to_s.split(d).uniq.count.to_s).each\
    \ do |e|\n      puts \"#{d} occurs #{e.count('7')} times in #{n}\"\n    end\n\
    \  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nA bit late but here is a way\
    \ to get the FizzBuzz with the most elegant solution:\n<code>", "  count = 0\n\
    \  if n % 11 == 0\n    count += 1\n  end\n  if n % 13 == 0\n    count += 1\n \
    \ end\n  if count > 0\n    return count\n  end\nend", "  n.times.find { |x| x\
    \ % 11 == 0 && x % 13 == 0 }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis assumes\
    \ there are no negative numbers in the range.\n<|/ c |>\n<| c |>\nAnd also assumes\
    \ that only integers between 0 and 999 are allowed. Otherwise the method will\
    \ not return `nil`.\n<|/ c |>\n<| c |>\nThis code doesn't return the numbers.\
    \ You need to add `puts` after `return number` and add `number` to the array `fizzbuzz\
    \ = []`\n<|/ c |>\n<| c |>\n: I didn't see any indication that this was a requirement\
    \ of the original question, so I only pointed out that code was incomplete if\
    \ it wasn't obvious that it wasn't going to work as intended.\n<|/ c |>\n<| a\
    \ tags=ruby,fizzbuzz |>\n<code>\nFizzBuzz = ->(n){\n  case n\n  when 0 then [n]\n\
    \  when 1 then [1]\n  when 2 then [2, 1]\n  when 3 then [3, 2, 1]\n  when 4 then\
    \ [4, 3, 2, 1]\n  when 5 then [5, 4 ,3 ,2 ,1]\n  when 6 then [6, 5 ,4 ,3 ,2 ,1]\n\
    \  when 7 then [7, 6 ,5 ,4 ,3 ,2 ,1]\n  when 8 then [8, 7, 6 ,5 ,4 ,3 ,2 ,1]\n\
    \  when 9 then [9, 8 ,7 ,6 ,5 ,4 ,3 ,2 ,1]\n  else n.times.map {|i| [n, *i].join('')}\n\
    end", "  if n.to_s.include?('7') then\n    return 1\n  else\n    return 0\n  end\n\
    end", "  result = 0\n  n.times do |i|\n    result += (i % 11 == 0 || i % 13 ==\
    \ 0) ? 1 : (i % 7 == 0) ? 1 : 0\n  end\n  result\nend", "    return n.to_s.split(//).count\
    \ do |i|\n        if i.to_s.include? \"7\" && i.to_s.include? \"7\"\n        \
    \    true\n        else\n            false\n        end\n    end\nend\n</code>\n\
    The above two functions are meant to return an int and the fizz_buzz function\
    \ is an example of two methods that can be used in your code. Your code will look\
    \ something like this:\n<code>", "  counter = 0\n  while n > 0\n    case = n%11\n\
    \    case = case == 7 ? 1 : case\n    case = n%13\n    case = case == 7 ? 1 :\
    \ case\n    counter += case\n    n /= 11\n    n /= 13\n  end\n  counter\nend",
  "  return n.times.map {|x| x % 11 == 0 || x % 13 == 0 ? \"#{x}\" : nil}.compact.count\n\
    end", "    count = 0\n    (1..n).each do |i|\n        if i % 11 == 0 && i % 13\
    \ == 0\n            count += 1\n        end\n    end\n    return count\nend",
  "    # Use the enumerate method on integers less than n\n    # Enumerate returns\
    \ a tuple with the index and the value of the integer in that index\n    n.times\
    \ do\n        # Print \"Fizz\" when the number is divisible by 3\n        puts\
    \ \"Fizz\" if n % 3 == 0 ", "  return n.times.reduce(0) do |memo, el|\n    el\
    \ == 11 ? memo + 1 : memo + 2\n  end\nend", "  n.to_s.split(\"\").map { |i| return\
    \ i if i.to_i.even? && (i.to_i.even? % 11 == 0 || i.to_i.even? % 13 == 0) }.length\n\
    end", "  count = 0\n  while n > 0 && n < 100\n    if n % 11 == 0\n      count\
    \ += 1\n      n = n / 11\n    elsif n % 13 == 0\n      count += 1\n      n = n\
    \ / 13\n    elsif n % 7 == 0\n      count += 1\n      n = n / 7\n    else\n  \
    \    n -= 1\n    end\n  end\n  count\nend\n</cell>\n<text>\nfizz_buzz(12)", " \
    \ count = 0\n  while n > 0 do\n    if n % 11 == 0 then count += 1 end\n    if\
    \ n % 13 == 0 then count += 1 end\n    n /= 10\n  end\n  return count\nend\n</code>\n\
    A few other things to consider:", "  count = 0\n  (1..n).each do |i|\n    if (i\
    \ % 11 == 0) || (i % 13 == 0)\n      count += 1\n    end\n  end\n  count\nend",
  "\tcount = 0\n\tloop do\n\t\tbreak if (n mod 11) == 0 and (n mod 13) == 0\n\t\t\
    count = count + 1\n\tend\n\tcount\nend", "  if n % 13 == 0 && (n % 11 == 0 ||\
    \ !(n % 11))\n    puts \"#{n} is a fizzbuzz\"\n  elsif n % 11 == 0 && (n % 13\
    \ == 0 || !(n % 13))\n    puts \"#{n} is a buzz\"\n  else\n    puts \"#{n} is\
    \ a #{n % 11 == 1 ? \"fizz\" : \"buzz\"}!\"\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nYour `buzz` method has different output than what OP asked for.\
    \ Look at `fizz_buzz(11)` vs `fizz_buzz(15)`.\n<|/ c |>\n<| c |>\nAh, I see. OP\
    \ didn't give us much to go on. I guess I could have mentioned that they probably\
    \ meant `!n%11 == 1` instead of `n % 11 == 1`, but since this doesn't produce\
    \ the correct output I wouldn't know what they were asking for. Perhaps a revised\
    \ question would be better. Thank you for your feedback.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe question asks to write a function \"fizz_buzz\" which returns the string\
    \ \"fizzbuzz\" for input numbers divisible by both 3 and 5 but not by 7.\nThere\
    \ are many ways to do this. I like this one:\n<code>", "  count = 0\n  while n\
    \ > 3\n    if n % 11 == 0\n      count += 1\n    elsif n % 13 == 0\n      count\
    \ += 1\n    elsif n % 7 == 0\n      count += 1\n    end \n    n /= 10\n  end \n\
    \  return count\nend", "    count = 0\n    (1..n).each do |x|\n        if x %\
    \ 11 == 0 and x % 13 == 0\n            count += 1\n        else\n            count\
    \ += 0\n        end\n    end\n    count\nend", "  count = 0\n  if n % 11 == 0\
    \ then \n    count += 1\n  end\n  if n % 13 == 0 then \n    count += 1\n  end\n\
    \  return count\nend", "   count = 0\n   while n > 0\n      if n % 11 == 0\n \
    \        count += 1\n      elsif n % 13 == 0\n         count += 1\n      end\n\
    \      n = n / 10\n   end\n   return count\nend", "\tfizz_count = 0\n\tbuzz_count\
    \ = 0\n\tn.times do |i|\n\t\tif i%11 == 0\n\t\t\tfizz_count += 1\n\t\telsif i%13\
    \ == 0\n\t\t\tbuzz_count += 1\n\t\tend\n\tend\n\treturn \"#{fizz_count} fizz buzz\"\
    \nend", "  sum = 0\n  10.times { sum += n % 11 if n % 11 == 0 }\n  13.times {\
    \ sum += n % 13 if n % 13 == 0 }\n  sum\nend", "    count = 0.0\n    while n >\
    \ 7\n        n /= 11\n        count += 1\n        n /= 13\n        count += 1\n\
    \        n /= 11\n        count += 1\n        n /= 13\n        count += 1\n  \
    \      n /= 11\n        count += 1\n        n /= 13\n        count += 1\n    \n\
    \    return count\nend\n</cell>\n<code language=julia-1.0>\nfizz_buzz(125)\n</cell>\n\
    <code language=julia-1.0>\nfizz_buzz(12)\n</cell>\n<code language=julia-1.0>\n\
    fizz_buzz(15)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(36)\n</cell>\n<code\
    \ language=julia-1.0>\nfizz_buzz(33)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(29)\n\
    </cell>\n<code language=julia-1.0>\nfizz_buzz(13)\n</cell>\n<code language=julia-1.0>\n\
    fizz_buzz(7)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(3)\n</cell>\n<code\
    \ language=julia-1.0>\nfizz_buzz(1)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(0)\n\
    </cell>\n<code language=julia-1.0>\nfizz_buzz(9)\n</cell>\n<code language=julia-1.0>\n\
    fizz_buzz(20)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(37)\n</cell>\n<code\
    \ language=julia-1.0>\nfizz_buzz(45)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(53)\n\
    </cell>\n<code language=julia-1.0>\nfizz_buzz(67)\n</cell>\n<code language=julia-1.0>\n\
    fizz_buzz(88)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(123)\n</cell>\n<code\
    \ language=julia-1.0>\nfizz_buzz(125)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(45)\n\
    </cell>\n<code language=julia-1.0>\nfizz_buzz(93)\n</cell>\n<code language=julia-1.0>\n\
    fizz_buzz(15)\n</cell>\n<code language=julia-1.0>\nfizz_buzz(23)\n</cell>\n<code\
    \ language=julia-", "    total = 0\n    (n % 11) == 0 ? total += 1 : nil\n   \
    \ (n % 13) == 0 ? total += 2 : nil\n    return total\nend\n</code>\nThere are\
    \ other ways to get this done, but hopefully this will point you in the right\
    \ direction. \nIf you don't understand anything here, post a comment and I'll\
    \ add some explanation.\n<|/ a tags=ruby |>\n<| c |>\nThat is what I needed, I\
    \ understand the code you wrote now! Thank you so much!\n<|/ c |>\n<| c |>\nIf\
    \ this answer solved your question, please mark is as the accepted answer by clicking\
    \ the check mark next to it. Thanks.\n<|/ c |>\n<| c |>\nHow would you do it in\
    \ another way in Ruby ?\n<|/ c |>\n<| c |>\nI'd suggest asking a new question\
    \ and referencing this one for context.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\n\
    A simple way is to convert the number to string and then use String#index to find\
    \ the substring:\n<code>", "  a = n.to_s.split(\"\")\n  sum = 0\n  a.each_index\
    \ do |index|\n    if a[index] == \"7\" && a[index-1].to_s.include?(\"7\") || a[index-1].to_s.include?(\"\
    0\")\n      sum += 1\n    end\n  end\n  return sum\nend", "    total = 0\n   \
    \ n.times do |i|\n        if i % 3 == 0 && i % 5 == 0\n            total += 2\n\
    \        elsif i % 5 == 0\n            total += 1\n        elsif i % 7 == 0\n\
    \            total += 3\n        else\n            total += i\n        end\n \
    \   end\n    total\nend\n</cell>\n<cell>\nfizz_buzz(5)\n</cell>\n<text>\nA more\
    \ compact version", "  total = 0\n  if n % 11 == 0\n    total += 1\n  if n % 13\
    \ == 0\n    total += 1\n  return total\nend\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=0 |>\nOne way to do this without using an if statement for each possible\
    \ number is:\n<code>", "  (0..Math.sqrt(n)).each do |n|\n    if n % 11 == 0\n\
    \      puts \"#{n} is divisible by 11\"\n    elsif n % 13 == 0\n      puts \"\
    #{n} is divisible by 13\"\n    else\n      puts \"#{n} is not divisible by 11\
    \ or 13\"\n    end\n  end\nend", "  count = 0\n  if n <= 100 then\n    if n %\
    \ 11 == 0 or n % 13 == 0 then\n      if n % 11 == 1 then\n        count = count\
    \ + 1\n      else\n        count = count + 0\n      end\n      if n % 13 == 1\
    \ then\n        count = count + 1\n      else\n        count = count + 0\n   \
    \   end\n    end\n  else\n    count = count + 1\n  end\n  return count\nend\n\
    print(fizz_buzz(13))\nprint(fizz_buzz(17))\nprint(fizz_buzz(11))\nprint(fizz_buzz(16))\n\
    print(fizz_buzz(19))\nprint(fizz_buzz(21))\nprint(fizz_buzz(35))\nprint(fizz_buzz(50))\n\
    print(fizz_buzz(67))\nprint(fizz_buzz(100));", "  count = 0\n  n.to_s.chars.each\
    \ do |digit|\n    case digit\n      when '1'\n        count += 1 if n % 11 ==\
    \ 0\n      when '3'\n        count += 1 if n % 13 == 0\n      when '5'\n     \
    \   count += 1 if n % 5 == 0\n      when '7'\n        count += 1 if n % 7 == 0\n\
    \      end\n  end\n  count\nend", "  if n<10\n    return 1\n  fizz = n/11\n  buzz\
    \ = n%11\n  count=0\n  count+=fizz\n  count+=buzz\n  count+=fizz*buzz\n  return\
    \ count\nend", "  if n <= 0 then\n    return 0\n  end\n  x = math.floor(n/13)\n\
    \  if x % 11 == 1 then\n    return x + 1\n  else\n    return x\n  end\nend", " \
    \ if n % 11 == 0 then\n    return \"11\"\n  else\n    if n % 13 == 0 then\n  \
    \    return \"13\"\n    else\n      return n\n    end\n  end\nend", "  count =\
    \ 0\n  n.times do\n    if n%11==0 || n%13==0\n      count += 1\n    else\n   \
    \   count = 0\n    end\n  end\n  count\nend", "  count = 0\n  while n > 7\n  \
    \  count += 1\n    n /= 7\n  end\n  count\nend", "  count = 0\n  n.times { |i|\n\
    \    if i.to_s.split(//)[0].include?('7')\n      count += 1\n    end\n  }\n  return\
    \ count\nend\n</code>\n<|/ a |>\n<| c |>\nThis one is the best answer since it\
    \ uses `times` and `include?`. I'm wondering if it is possible to make this one\
    \ the top answer. Do you think it would be possible or should I change my answer\
    \ to a different one if it is not possible to change my answer?\n<|/ c |>\n<|\
    \ c |>\nYes it's possible to make it the top answer. The code should be easy to\
    \ understand, I've added a description and an example in the answer.\n<|/ c |>\n\
    <| a dscore=0 |>\nThe easiest way is to generate all numbers from 1 to a bigger\
    \ number and check if a given number is divisible by 11 or 13. Then count all\
    \ numbers that returns true in the previous step.\n<code>", "  n.to_s.split(\"\
    \").each do |d|\n    next if d == \"7\"\n    if d % 11 == 0\n      puts \"FizzBuzz\"\
    \n    elsif d % 13 == 0\n      puts \"Fizz\"\n    elsif d % 11 != 0 && d % 13\
    \ != 0\n      puts d\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThe `to_s`\
    \ call is unnecessary since `each` implicitly calls `to_s`.\n<|/ c |>\n<| a dscore=2\
    \ tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>\n(1..n).each{|x| puts \"\
    #{x}\".gsub(/7+/, \"FizzBuzz\").gsub(/5/, \"Buzz\").gsub(/3/, \"Fizz\").gsub(/1/,\
    \ \"BuzzBuzz\") }\n</code>\n<|/ a |>\n<| a |>\nThis is a good case to use regular\
    \ expression. Here's an example:\n<code>", "  n.to_s.split(\"\").select { |i|\
    \ i.to_i % 11 == 0 }.count { |i| i.to_i % 13 == 0 }\nend", "  n = n.to_i\n  if\
    \ n == 0\n    return 0\n  end\n  if n % 11 == 0\n    return \"FizzBuzz\"\n  end\n\
    \  if n % 13 == 0\n    return \"Fizz\"\n  end\n  if n % 3 == 0\n    return \"\
    Buzz\"\n  end\n  return n\nend", "  n\nend", "  if n <= 0\n  0\n  elsif n % 11\
    \ == 0\n  1\n  elsif n % 13 == 0\n  2\n  else\n  3\n  end\nend", "    puts \"\
    #{n} has #{count_digit_7(n, n/11)} times the digit 7 in integers which are divisible\
    \ by 11\"\n    puts \"#{n} has #{count_digit_7(n, n/13)} times the digit 7 in\
    \ integers which are divisible by 13\"\nend\n</code>\nOutput\n<code>\nEnter a\
    \ positive integer:\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n\
    123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n",
  "  if n <= 0\n    return 0\n  i = 2\n  while i <= n\n    return i == 13 || i % 11\
    \ == 0 ? 1 : 0\n    i += 1 \nend\n</cell>\n<text>\nFor extra credit, try and create\
    \ a function which will take in a string and output true or false depending on\
    \ the input. For example, the function should take \"foobar\" as input and output\
    \ true or false depending on whether it starts with the letter \"b\". Feel free\
    \ to use the functions startswith? and endswith from the String module for this!",
  "    count = 0.zero\n    if n >= 11\n        count += n/11\n        n %= 11\n  \
    \  end\n    if n >= 13\n        count += n/13\n        n %= 13\n    end\n    if\
    \ n == 0\n        count += 1\n    end\n    if n % 11 == 0\n        count += 1\n\
    \    end\n    if n % 13 == 0\n        count += 1\n    end\n    if count == 0\n\
    \        count = 1\n    end\n    count\nend", "  if n%11 == 0\n    return 3\n\
    \  elsif n%13 == 0\n    return 2\n  else\n    return 1\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,loops |>\n<| c |>\nYeah I was thinking about that\
    \ and I saw other comments suggesting that I might as well do this the hard way.\
    \ I still want to know how this could be done though. Thanks.\n<|/ c |>\n<| c\
    \ |>\nThe best way to learn Ruby, is by writing code. Your question is a perfect\
    \ example of how not to learn Ruby properly. There is no way you would learn Ruby\
    \ by asking questions here on SO or other places.\n<|/ c |>\n<| c |>\nI appreciate\
    \ that and I know the question is not the best way to learn Ruby. I am sorry if\
    \ this came across as a \"gimme teh codez\" but I was just trying to see if there\
    \ was a way to learn Ruby differently as I thought I was going about this the\
    \ wrong way. I guess I am just glad that I asked this question.\n<|/ c |>\n<|\
    \ c |>\nNo problem, I didn't mean to offend you, just trying to help. You were\
    \ really not asking the right questions, and I didn't mean to be mean or offensive.\n\
    <|/ c |>\n<| a |>\nOne option is to use a case statement on n.\n<code>", "   \
    \ if n < 10 then return n\n    count = 0\n    while n > 0\n        if n % 11 ==\
    \ 0 then count += 1\n        if n % 13 == 0 then count += 1\n        n -= 1\n\
    \    end\n    return count\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI think\
    \ this could be simplified using recursion.\n<|/ c |>\n<| a |>\nHere is a simple\
    \ Ruby one-liner that will count the number if fizz buzz words are found within\
    \ a given integer and return the number of fizz buzz words found if they exist.\n\
    <code>", "  if n < 100 && n % 11 == 0\n    n\n  elsif n < 100 && n % 13 == 0\n\
    \    n\n  else\n    n * 2\n  end\nend", "  count = 0\n  n.times do\n    if n %\
    \ 11 == 0 || n % 13 == 0\n      count += 1\n    end\n  end\n  return count\nend\n\
    </code>\nThe results are as follows:\n<code>\n>fizz_buzz(10) # => 2\n>fizz_buzz(11)\
    \ # => 2\n>fizz_buzz(12) # => 3\n>fizz_buzz(13) # => 4\n>fizz_buzz(14) # => 5\n\
    >fizz_buzz(15) # => 5\n>fizz_buzz(16) # => 5\n>fizz_buzz(17) # => 6\n>fizz_buzz(18)\
    \ # => 6\n>fizz_buzz(19) # => 6\n>fizz_buzz(20) # => 6\n>fizz_buzz(21) # => 6\n\
    >fizz_buzz(22) # => 7\n>fizz_buzz(23) # => 8\n>fizz_buzz(24) # => 9\n>fizz_buzz(25)\
    \ # => 10\n>fizz_buzz(26) # => 11\n>fizz_buzz(27) # => 12\n>fizz_buzz(28) # =>\
    \ 13\n>fizz_buzz(29) # => 13\n>fizz_buzz(30) # => 13\n>fizz_buzz(31) # => 13\n\
    >fizz_buzz(32) # => 14\n>fizz_buzz(33) # => 15\n>fizz_buzz(34) # => 15\n>fizz_buzz(35)\
    \ # => 15\n>fizz_buzz(36) # => 15\n>fizz_buzz(37) # => 15\n>fizz_buzz(38) # =>\
    \ 15\n>fizz_buzz(39) # => 15\n>fizz_buzz(40)\n>fizz_buzz(41) # => 2\n>fizz_buzz(42)\
    \ # => 2\n>fizz_buzz(43) # => 3\n>fizz_buzz(44) # => 3\n>fizz_buzz(45) # => 4\n\
    >fizz_buzz(46) # => 4\n>fizz_buzz(47) # => 4\n>fizz_buzz(48) # => 4\n>fizz_buzz(49",
  "    count = 0\n    \n    # Iterate through integers less than n which are divisible\
    \ by 11 or 13.\n    while n >= 11 or n >= 13\n    \n        # If the number is\
    \ divisible by 11, add it to the count and subtract 11 from n.\n        if n %\
    \ 11 == 0\n            count += 1\n            n -= 11\n        \n        # If\
    \ the number is divisible by 13, add it to the count and subtract 13 from n.\n\
    \        if n % 13 == 0\n            count += 1\n            n -= 13\n    \n \
    \   # Return the count.\n    return count\nend", "  fizzes = n.times { |x| x.to_s.include?(\"\
    7\") }\n  buzzes = n.times { |x| x.to_s.include?(\"5\") }\n  fizzes + buzzes\n\
    end", "  (0..100).select { |i|\n    i % 11 == 0 || (i % 13 == 0 && i > 7)\n  }.size\n\
    end", "  count = 0\n  n = (n.to_s.split('').reverse.map { |x| x.to_i }).join.to_i\n\
    \  n = 0 if n < 0\n  n = n if n % 11 == 0 || n % 13 == 0\n  n <= 2147483647 ?\
    \ n.times {count += 1} : n.to_s.reverse.chars.each_cons(2).count { |n,m| m ==\
    \ '7' && n % 11 == 0 && n % 13 == 0 }\nend\n</code>\nThe most difficult part is\
    \ mapping digits of the number in string form to integers. A good way to do that\
    \ is to use the String#reverse method to reverse the string, and map that to a\
    \ single array of integers. Once that is done we just need to join all the digits\
    \ back together.\n<code>", "  return n.times.map { |i| i % 11 == 0 || i % 13 ==\
    \ 0 ? i : 0 }.count\nend", "  result = 0.\n  n.times { result += (n % 11).zero?\
    \ && (n % 13).zero? ? 1 : 0 }\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ Matthew, this works in my Ruby environment with RSpec 3.4.2, but I'm getting\
    \ a NoMethodError in my Rails environment where I'm trying to test my code. I\
    \ tried commenting out my own code and the rspec code (to test the FizzBuzz method)\
    \ and I get the same error. Do you know why that might be? Here's the code I'm\
    \ working with: https://github.com/jmehlhorst/fizzbuzz-ruby/blob/master/fizzbuzz.rb\n\
    <|/ c |>\n<| c |>\nI've added your code to my project and I get the same error.\
    \ Is there anything else I can do? Here's my repo: https://github.com/jmehlhorst/fizzbuzz-ruby/tree/master/fizzbuzz-ruby\n\
    <|/ c |>\n<| c |>\nHi James, I updated the code in the answer to include a fizzbuzz\
    \ method that should work as expected.\n<|/ c |>\n<| c |>\nI still get the same\
    \ error when I run your updated code with my repo. It works fine in the Ruby console\
    \ so I know it's something I'm doing wrong in Rails. Here's the repo I'm using:\
    \ https://github.com/jmehlhorst/fizzbuzz-ruby\n<|/ c |>\n<| c |>\nSorry, I didn't\
    \ understand that there were two different environments in your question. I've\
    \ updated my answer to include a fizzbuzz method that should work as expected\
    \ now.\n<|/ c |>\n<| a dscore=0 |>\nA simple way to do it is to just generate\
    \ fizzbuzz.\n<code>\n\"1234\".gsub(/(?<=^|\\s)(\\d)/){|a| \"#{$1.next}\"}\n</code>\n\
    <|/ a tags=ruby-on-rails-5,ruby,ruby-on-rails |>\n<| a |>\n<code>", "  fizz_times\
    \ = n.zero? ? 0 : n.to_s.count(7)\n  buzz_times = n.zero? ? 0 : n.to_s.count(7)\n\
    \  (fizz_times + buzz_times).times do |i|\n    if i.zero?\n      puts \"0\"\n\
    \    elsif i.to_s.include?('11')\n      puts \"1\"\n    elsif i.to_s.include?('13')\n\
    \      puts \"2\"\n    else\n      puts i\n    end\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a tags=ruby |>\nAs far as I can tell, your requirements aren't\
    \ 100% clear. But, I think this may help. I've defined a function which takes\
    \ an integer n and returns the string \"FizzBuzz\" if n is divisible by 3 and\
    \ 5, or \"Fizz\" if n is divisible by 3, or else returns the string \"Buzz\" if\
    \ n is divisible by 5. It also checks if the number n is divisible by both 3 and\
    \ 5. If either is true, it returns \"FizzBuzz\".\n<code>", "  for i in (11,13).to_a..n\n\
    \    divisible_by_11 = (i - (i / 10) * 10).modulo(11) == 0\n    divisible_by_13\
    \ = (i - (i / 10) * 10).modulo(13) == 0\n    if divisible_by_11 && divisible_by_13\n\
    \      puts \"FizzBuzz #{i}\"\n    elsif divisible_by_11\n      puts \"Fizz #{i}\"\
    \n    elsif divisible_by_13\n      puts \"Buzz #{i}\"\n    else\n      puts i\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby,performance,primes |>\n\
    <| c |>\nYour first test is invalid. You have to test for divisibility by 11 or\
    \ 13 in order to find out if it is divisible by both. This is not the case with\
    \ your second test. You have to test for divisibility by 11, then by 13. Your\
    \ third test is fine, but doesn't work for negative numbers.\n<|/ c |>\n<| c |>\n\
    Yeah, I forgot about negative numbers. But I don't think that makes a big difference.\
    \ `divisible_by_11` and `divisible_by_13` are the keys in the hash so I added\
    \ tests for negative numbers. I was thinking about a general algorithm to determine\
    \ primes and didn't want to write it out every time...\n<|/ c |>\n<| c |>\nYeah,\
    \ good points. I tested with negative numbers and it seems to work fine. Good\
    \ catch on that last test. I guess I misread the OP's original code where you\
    \ said \"less than n\" rather than \"less than or equal to n\".\n<|/ c |>\n<|\
    \ a tags=algorithm,ruby,performance,primes dscore=2 |>\nI thought I'd post my\
    \ answer anyway as an alternative way of solving the problem of determining primes.\
    \ I implemented the Sieve of Atkin in Ruby here: https://github.com/alexblack/primes\n\
    I've used this to implement the Sieve of Atkin's algorithm, which is described\
    \ here:\nhttp://www.iie6.com/staff-presentations/the-sievers-of-atkin-for-mathematics-professor\n\
    The performance of this solution doesn't particularly depend on the complexity\
    \ of calculating the primes (the n^2 algorithm), but on the nature of the numbers\
    \ you will be dealing with.\n<|/ a |>\n<| c |>\nThis solution is indeed a lot\
    \ more elegant! However, I found that it does not work with Ruby 2.0.0 - it gives\
    \ an error when dealing with negative numbers. ", "  result = 0\n  while n >=\
    \ 7\n    n /= 7\n    result += 1\n  end\n  return result\nend", "  counter = Hash.new(0)\n\
    \  n.times.with_object([]) do |n, arr|\n    if n >= 11 || n >= 13\n      counter\
    \ += 1 if (n % 11).zero? && (n % 13).zero?\n    else\n      arr << n\n    end\n\
    \  end\n  counter\nend", "  return n.to_s.scan(/[11|13]/).size % 2 == 0 ? n :\
    \ nil\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n\
    <| c |>\nThis is a really good answer.  Thanks for taking the time to provide\
    \ such a detailed response.  My only query is if there is a way to return the\
    \ count of all the times that a certain digit appeared in an integer and return\
    \ the total number of times that digit appeared.  For example, `fizz_buzz(123)`\
    \ should return `3` and `fizz_buzz(1245)` should return `2`.  Is this possible?\n\
    <|/ c |>\n<| c |>\nYes, it is possible. Look at the updated answer.\n<|/ c |>\n\
    <| c |>\nThanks so much for this, this is really helpful!\n<|/ c |>\n<| c |>\n\
    I guess I should add that it's important for the number to be a positive integer.\
    \  I tried to add an `if` condition so that `fizz_buzz(123)` returns `3` and `fizz_buzz(-123)`\
    \ returns `nil`, but I am unable to get this to work.  Any idea how this could\
    \ work?\n<|/ c |>\n<| c |>\nTry changing `/[11|13]/` to `/[11|13]/i`. I think\
    \ this will work for you.\n<|/ c |>\n<| a dscore=2 |>\nI'd write a method that\
    \ takes two arguments: a string and a number. \nThe method would scan the string\
    \ for the digit, and if found, increment a variable that tracks how many times\
    \ the digit appears in the number passed in.\nFor example, if the string passed\
    \ is \"abc\" and a number passed in is 123, the method would return the string\
    \ \"123\" because it appears 3 times in the number.\nThe method would then return\
    \ the value of the variable that tracks how many times the digit was found.\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| c |>\nThis is a nice way\
    \ to solve the problem, and I like it too and will probably use this method in\
    \ the future.  Thanks for your response.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\nThis should work for you:\n<code>", "    count = 0\n    i = n\n    while\
    \ i > 0\n        if (i % 11 == 0) || (i % 13 == 0)\n            count = count\
    \ + 1\n        i -= 1\n    return count\nend", "  if n % 11 == 0 and n % 13 ==\
    \ 0\n    return n\n  else\n    return 0\n  end\nend\nputs fizz_buzz(12) #prints\
    \ 12\nputs fizz_buzz(21) #prints 0\nputs fizz_buzz(22) #prints 0\nputs fizz_buzz(33)\
    \ #prints 0\nputs fizz_buzz(32) #prints 0\nputs fizz_buzz(44) #prints 0\nputs\
    \ fizz_buzz(55) #prints 0\nputs fizz_buzz(34) #prints 0\nputs fizz_buzz(44) #prints\
    \ 0\nputs fizz_buzz(100) #prints 100\nputs fizz_buzz(101) #prints 0\nputs fizz_buzz(1000)\
    \ #prints 0\n</code>\nAnd here is my code:\n<code>\nrequire 'pp'", "  case n\n\
    \  when 0..100\n    puts \"#{n} is a multiple of 11 but not 13.\"\n  when 101..110\n\
    \    puts \"#{n} is a multiple of 11 and 13.\"\n  when 111..120\n    puts \"#{n}\
    \ is a multiple of 11 and 13.\"\n  when 121..130\n    puts \"#{n} is a multiple\
    \ of 11 and 13.\"\n  when 131..140\n    puts \"#{n} is a multiple of 11 and 13.\"\
    \n  else\n    puts \"#{n} is a multiple of 11 but not 13.\"\n  end\nend", "  if\
    \ n < 11\n    return 0\n  elsif n == 11 || n == 13\n    return 1\n  else\n   \
    \ return fizz_buzz(n / 10) * fizz_buzz(n % 10)\n  end\nend", "  count=0\n  while\
    \ n>0\n    if n % 11 == 0\n      count=count+1\n    elsif n % 13 == 0\n      count=count+1\n\
    \    end\n    n=n/10\n  end\n  count\nend", "  (1..n).count { |i| i % 11 == 0\
    \ and i % 13 == 0 }\nend", "  \n  fizz  = n%11 == 0\n  buzz = n%13 == 0\n  \n\
    \  if fizz && buzz\n    return 2\n  elsif fizz\n    return 1\n  elsif buzz\n \
    \   return 0\n  else\n    return -1\n  end\nend", "    count = 0\n    while n\
    \ < 10000\n        if n % 11 == 0\n            count += 1\n        if n % 13 ==\
    \ 0\n            count += 1\n        n += 1\n    end\n    return count\nend",
  "  count = 0\n  if n % 11 == 0\n    count += 1\n  elsif n % 13 == 0\n    count +=\
    \ 1\n  end\n  \n  return count\nend\n</cell>\n<cell>\nfizz_buzz(12)\n</cell>\n\
    <cell>\nfizz_buzz(32)\n</cell>\n<cell>\nfizz_buzz(91)\n</cell>\n<cell>", "  return\
    \ n.times.map do |n|\n    if (n % 11) == 0\n      'FizzBuzz'\n    elsif (n % 13)\
    \ == 0\n      'Fizz'\n    elsif (n % 3) == 0\n      'Fizz'\n    elsif (n % 5)\
    \ == 0\n      'Buzz'\n    else\n      n\n    end\n  end\nend", "  numbers = n.to_s.split(//)\n\
    \  digits.each do |digit|\n    numbers[0..-2].each do |i|\n      if i % 11 ==\
    \ 0 ||\n         i % 13 == 0\n        p digit\n      end\n    end\n  end\nend",
  "  count = 0\n  n.to_s.each_char.with_index do |c, i|\n    if c == 7 and (i % 11\
    \ == 0 or i % 13 == 0)\n      count += 1\n    end\n  end\n  count\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| c |>\nThe second method I used is more efficient.\n\
    <|/ c |>\n<| c |>\nIf you think this is the best answer, then feel free to accept\
    \ it by clicking the checkmark to the left of it. This will show to other people\
    \ that your question has been answered and will help future users who have the\
    \ same problem as you.\n<|/ c |>\n<| a tags=ruby,algorithm |>\nYou can use the\
    \ modulus operator in Ruby:\n<code>", "  count = 0\n  for i in (0..n-1)\n    if\
    \ n/i > 11 || n/i > 13\n      count += 1\n      break\n    end\n  end\n  count\n\
    end", "  if n == 1\n    1\n  elsif n == 2\n    \"2\"\n  elsif n == 3\n    \"3\"\
    \n  elsif n == 4\n    \"4\"\n  elsif n == 5\n    \"5\"\n  elsif n == 6\n    \"\
    6\"\n  elsif n == 7\n    \"7\"\n  elsif n == 8\n    \"8\"\n  elsif n == 9\n  \
    \  \"9\"\n  elsif n == 10\n    \"10\"\n  elsif n == 11\n    \"11\"\n  elsif n\
    \ == 12\n    \"12\"\n  elsif n == 13\n    \"13\"\n  elsif n == 14\n    \"14\"\n\
    \  elsif n == 15\n    \"15\"\n  elsif n == 16\n    \"16\"\n  elsif n == 17\n \
    \   \"17\"\n  elsif n == 18\n    \"18\"\n  elsif n == 19\n    \"19\"\n  elsif\
    \ n == 20\n    \"20\"\n  elsif n == 21\n    \"21\"\n  elsif n == 22\n    \"22\"\
    \n  elsif n == 23\n    \"23\"\n  elsif n == 24\n    \"24\"\n  elsif n == 25\n\
    \    \"25\"\n  elsif n == 26\n    \"26\"\n  elsif n == 27\n    \"27\"\n  elsif\
    \ n == 28\n    \"28\"\n  elsif n == 29\n    \"29\"\n  elsif n == 30\n    \"30\"\
    \n  elsif n == 31\n    \"31\"\n  elsif n == 32\n    \"32\"\n  elsif n == 33\n\
    \    \"33\"\n  elsif n == 34\n    \"34\"\n  elsif n == 35\n    \"35\"\n  elsif\
    \ n == 36\n    \"36\"\n  elsif n == 37\n    \"37\"\n  elsif n == 38\n    \"38\"\
    \n  elsif n == 39\n    \"39\"\n  elsif n == 40\n    \"40\"\n  elsif n == 41\n\
    \    \"41\"\n  elsif n == 42\n    \"42\"\n  elsif n == 43\n    \"43\"\n  elsif\
    \ n == 44\n    \"44\"\n  elsif n == 45\n    \"45\"\n  elsif n == 46\n    \"46\"\
    \n  elsif n == 47\n    \"47\"\n  elsif n == ", "  i = 0\n  while i <= n\n    if\
    \ i % 11 == 0 && i % 13 == 0\n      puts i\n      i += 1\n    elsif i % 11 ==\
    \ 0\n      puts i\n      i += 1\n    elsif i % 13 == 0\n      puts i\n      i\
    \ += 1\n    else\n      puts n\n      i += 1\n    end\n  end\nend", "  count =\
    \ 0\n  n.times do |i|\n    if ((i.mod 11) == 0) && ((i/11) == 7)\n      count\
    \ += 1\n    elsif ((i.mod 13) == 0) && ((i/13) == 7)\n      count += 1\n    end\n\
    \  end\n  count\nend", "  counter = 0\n  for i in 1..n\n    if i % 11 == 0 ||\
    \ i % 13 == 0\n      counter += 1\n    end\n  end\n  return counter\nend", " \
    \ count = 0\n  n.times do |x|\n    if (x % 11 == 0) && (x % 13 == 0)\n      count\
    \ += 1\n    end\n  end\n  count\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThat\
    \ is great! Thanks for your help. This is my first post and I'm still learning\
    \ a lot of things. I appreciate it greatly!\n<|/ c |>\n<| c |>\nNo problem! As\
    \ a beginner, I do think that putting the problem into code form is really helpful.\
    \ Good luck!\n<|/ c |>\n<| c |>\nThanks again! I agree with you that it is helpful\
    \ but the goal is to learn by doing. My question is about a specific type of problem\
    \ where I just need a general explanation of what is going on behind the scenes.\n\
    <|/ c |>\n<| c |>\nYeah, it sounds like you found a good resource! The thing is\
    \ that we like helping people, too. That's why I encourage you to help others\
    \ as well. :)\n<|/ c |>\n<| a tags=ruby,loops |>\nThe method times works on Enumerable,\
    \ which basically is just any collection that implements it. In your case, the\
    \ collection you called times on (n) is the number n, which is an integer, so\
    \ this time method iterates through the whole integer and returns the number of\
    \ times the block was evaluated.\nTo understand the difference between the while\
    \ and until loops, take a look at the following examples:\n<code>\n3.times do\
    \ |n| # 3 is evaluated 3 times\n  puts n\nend", "    count = 0\n    while n >=\
    \ 0\n        count += 1\n        n /= 10\n    end\nend", "  # Write your code\
    \ here.\n  count = 0\n  if n % 11 == 0\n    count += 1\n  end\n  if n % 13 ==\
    \ 0\n    count += 1\n  end\n  return count\nend\nassert fizz_buzz(15) == 4, \"\
    15 is not divisible by 11 or 13\"\nassert fizz_buzz(20) == 3, \"20 is not divisible\
    \ by 11 or 13\"\nassert fizz_buzz(22) == 2, \"22 is not divisible by 11 or 13\"\
    \nassert fizz_buzz(100) == 1, \"100 is not divisible by 11 or 13\"\nassert fizz_buzz(200)\
    \ == 0, \"200 is divisible by 11 or 13\"", "  if n <= 13\n    if n % 11 == 0\n\
    \      if n % 13 == 0\n        return \"#{n}: divisible by 11 and 13\"\n     \
    \ else\n        return \"#{n}: divisible by 11\"\n      end\n    else\n      if\
    \ n % 13 == 0\n        return \"#{n}: divisible by 13\"\n      else\n        return\
    \ \"#{n}: divisible by 11 and 13\"\n      end\n    end\n  else\n    return \"\
    #{n}: divisible by 13\"\n  end\nend\n</code>\n<|/ a tags=ruby,return-value |>\n\
    <| c |>\nNice solution!  I like that `each` returns a Enumerator object that you\
    \ can keep track of while you iterate.\n<|/ c |>\n<| c |>\nThank you. Yes, `Enumerator`\
    \ is pretty sweet.\n<|/ c |>\n<| a dscore=1 tags=ruby,return-value |>\nYour issue\
    \ was that Ruby does not allow you to return multiple values from a function.\n\
    Instead of return \"#{n}: divisible by 11\" you need to create an array:\n<code>",
  "  # Initialize a variable to hold the number of times the digit 7 appears in integers\
    \ less than n which are divisible by 11 or 13.\n  count = 0\n  # Loop over the\
    \ digits in n.\n  n.times do |i|\n    # If the digit is divisible by 11...\n \
    \   if i % 11 == 0\n      # ...increment the count by 1.\n      count += 1\n \
    \   # Else, if the digit is divisible by 13...\n    elsif i % 13 == 0\n      #\
    \ ...increment the count by 1.\n      count += 1\n      # ...and add one to the\
    \ count if it's divisible by 7.\n      count += 1 if i % 7 == 0\n    # Else, if\
    \ the digit is not divisible by 11, then add one to the count if it is divisible\
    \ by 7.\n    else\n      count += 1 if i % 7 == 0\n    end\n  end\n  # Return\
    \ the value of count at the end.\n  count\nend\n</code>\nThe tricky part is how\
    \ do I get the loop over n to stop at 11, 13, 15, or 17 and start over again?\n\
    I did some testing and found that n % 11 returns a single digit number (a number\
    \ between 0 and 9). So, if n was a multiple of 11, the loop wouldn't stop.\nBut\
    \ if n was a multiple of 13, then n % 13 would return a number between 0 and 8.\
    \ In that case, the loop would stop at 13 (as that's how many multiples of 13\
    \ there are), and you'd have to start again at 11 (because 13 is divisible by\
    \ 11). So, that's why I added a second else clause to the if statement, where\
    \ I check to see if the number n is a multiple of 11.\nIf n isn't a multiple of\
    \ 11 or 13, the loop will just keep going forever.\n<|/ a dscore=0 |>\n<| c |>\n\
    Thank you! I really appreciate your help\n<|/ c |>\n<| a |>\nFor those who wants\
    \ to understand more about the FizzBuzz algorithm you can read this article: Fizz\
    \ buzz article on wikipedia.\nAnd then here a quick implementation, in Ruby:\n\
    <code>", "  if n % 11 == 0 and n % 13 == 0\n    \"Fizz Buzz\"\n  elsif n % 11\
    \ == 0\n    \"Fizz\"\n  elsif n % 13 == 0\n    \"Buzz\"\n  else\n    n\n  end\n\
    end\nputs fizz_buzz(7)", "  count = 0\n  while n > 0\n    if n % 11 == 0 then\
    \ count += 1\n    if n % 13 == 0 then count += 1\n    n /= 10\n  end\n  return\
    \ count\nend\n</cell>\n<text>\nLet's test it!", "  i = 1\n  while i < n\n    if\
    \ i % 11 == 0\n      puts \"FizzBuzz\"\n    elsif i % 13 == 0\n      puts \"Fizz\"\
    \n    elsif i % 7 == 0\n      puts \"Buzz\"\n    else\n      puts i\n    end\n\
    \    i += 1\n  end\nend", "    count = 0\n    if n % 11 == 0\n        count +=\
    \ 1\n    if n % 13 == 0\n        count += 1\n    count\nend\n</cell>\n<cell>",
  "  count = 0\n  (1..n).each do |i|\n    i =~ /7/i\n    count += 1 if i\n  end\n\
    \  count\nend", "    i = 0\n    while i < n do\n        if ((n % 10) == 0) then\n\
    \            if ((n % 11) == 0) then\n                puts(\"FizzBuzz\")\n   \
    \         else\n                puts(\"Fizz\")\n            end\n        else\n\
    \            if ((n % 13) == 0) then\n                puts(\"Buzz\")\n       \
    \     else\n                puts(n)\n            end\n        end\n        i +=\
    \ 1\n    end\nend", "  # Write your code here.\n  for i in 1...n\n    if i % 11\
    \ == 0\n      puts \"#{n} is divisible by 11.\"\n    elsif i % 13 == 0\n     \
    \ puts \"#{n} is divisible by 13.\"\n    else\n      puts \"#{n} is NOT divisible\
    \ by 11 or 13.\"\n    end\n  end\nend", "  n.times{|i| (i%11 == 0 && i%13 == 0)\
    \ ? \"FizzBuzz\" : i}\nend\nputs fizz_buzz(100).inspect\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby |>\nHere is another solution\n<code>\n(1..1000000).to_a.select {\
    \ |n| (n % 11 == 0 && n % 13 == 0) ? \"FizzBuzz\" : n }\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby |>\nI believe the most efficient way to solve this problem\
    \ in terms of time complexity is to create an array of the numbers 1-N (1..1000000),\
    \ sort them in ascending order, and then use a binary search to find the position\
    \ of 7 in the array. If it is found, the value should be \"FizzBuzz\".\n<code>",
  "    if n <= 11 || n <= 13\n        return n\n    else\n        return fizz_buzz(n/11)\
    \ + (n % 11 == 0 ? 13 : fizz_buzz((n-1)/13))\n    end\nend\n</code>\nThis code\
    \ works fine but takes too much time and sometimes freezes.\nIs there a better\
    \ way to do this other than writing an explicit algorithm and using recursion?\n\
    <|/ q |>\n<| c |>\n\"Is there a better way to do this other than writing an explicit\
    \ algorithm and using recursion?\" Yes, yes, yes. Use recursion. You're running\
    \ into stack overflow because you're recursing too deeply.\n<|/ c |>\n<| c |>\n\
    \"Is there a better way to do this other than writing an explicit algorithm and\
    \ using recursion?\" Yes, by writing an explicit algorithm and using recursion.\
    \ No need for the computer to compute what it doesn't need and to waste computing\
    \ time unnecessarily. A recursion is a natural way to solve a problem.\n<|/ c\
    \ |>\n<| c |>\n\"Is there a better way to do this other than writing an explicit\
    \ algorithm and using recursion?\" Yes, by using a `while` loop instead of a recursive\
    \ function.  But it would be even better to write an explicit algorithm/solution.\
    \  That would also give you a better idea of how to approach this sort of problem\
    \ in general.\n<|/ c |>\n<| c |>\nThis is not a good fit for the Code Review site;\
    \ see [What topics can I ask about here?](https://codereview.stackexchange.com/help/on-topic)\
    \ instead.\n<|/ c |>\n<| c |>\nIf you want a solution, you are better off on [Code\
    \ Review](https://codereview.stackexchange.com/help/on-topic). If you have tried\
    \ and are having problems with your code, the question would be off-topic on Code\
    \ Review because it is asking for review of working code. Remember that Stack\
    \ Overflow is for specific questions about *your code*. It is not a site to request\
    \ code from others unless you have a *specific* question about their code.\n<|/\
    \ c |>\n<| a dscore=2 tags=ruby |>\nHere is a simple recursive solution\n<code>\n\
    require 'set'", "  result = 0\n  number_of = 0\n  while n > 0\n    if n % 11 ==\
    \ 0\n      number_of = number_of + 1\n      if number_of == 1\n        result\
    \ = result + \"fizz\"\n      else\n        result = result + \"fiz\"\n      end\n\
    \      number_of = 0\n    elsif n % 13 == 0\n      number_of = number_of + 1\n\
    \      if number_of == 1\n        result = result + \"buzz\"\n      else\n   \
    \     result = result + \"buz\"\n      end\n      number_of = 0\n    else\n  \
    \    result = result + n.to_s\n    end\n    n -= 1\n  end\n  result\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=ruby,fizzbuzz |>\nHere's another Ruby way to do it\n\
    <code>", "  num_count = 0\n  while n > 0\n    if (n%11 == 0) || (n%13 == 0)\n\
    \      num_count += 1\n    end\n    n -= 1\n  end\n  return num_count\nend", " \
    \   count = 0\n    while n < 1000000\n        if n % 11 == 0\n            count\
    \ += 1\n        if n % 13 == 0\n            count += 1\n        n += 11\n    count\
    \ = count % 11\n    if count == 0\n        count = 0\n    return count\nend",
  "  count = 0\n  if n % 11 == 0\n    count += 1\n  elsif n % 13 == 0\n    count +=\
    \ 1\n  end\n  count\nend", "  if n < 13\n  then return n\n  else return fizz_buzz(n/10)\
    \ * fizz_buzz(n%10)\n  end\nend", "  (11..n).each do |i|\n    i.to_s.each_char.take(3).each\
    \ do |digit|\n      if digit.include?('7')\n        return i\n      end\n    end\n\
    \  end\n  return -1\nend", "  count.times { |i| return n if i%11 == 0 && i%13\
    \ == 0 }\n  count.times { |i| return n if i%11 == 1 || i%13 == 1 }\n  count.times\
    \ { |i| return n if i%11 == 2 || i%13 == 2 }\n  count.times { |i| return n if\
    \ i%11 == 3 || i%13 == 3 }\n  count.times { |i| return n if i%11 == 4 || i%13\
    \ == 4 }\n  count.times { |i| return n if i%11 == 5 || i%13 == 5 }\n  count.times\
    \ { |i| return n if i%11 == 6 || i%13 == 6 }\n  count.times { |i| return n if\
    \ i%11 == 7 || i%13 == 7 }\n  count\nend", "    count = 0\n    if n.is_a? Integer\n\
    \        if n % 11 == 0\n            count += 1\n        if n % 13 == 0\n    \
    \        count += 1\n        if n % 15 == 0\n            count += 1\n        if\
    \ n % 17 == 0\n            count += 1\n        if n % 19 == 0\n            count\
    \ += 1\n    end\n    return count\nend\n</code>\nA more robust solution would\
    \ be to write a method which accepts an array of integers and returns the number\
    \ of occurrences of a number in that array.\n<code>", "  fizz, buzz = [], []\n\
    \  (1..n).each do |i|\n    if i % 11 == 0\n      fizz << i\n    elsif i % 13 ==\
    \ 0\n      buzz << i\n    elsif i % 7 == 0\n      fizz << i\n    else\n      buzz\
    \ << i\n    end\n  end\n  fizz.count + buzz.count\nend", "\tcount.times = 0 \n\
    \twhile n > 0 do\n\t\tcount.times += 1\n\t\tif n % 11 == 0 \n\t\t\tcount.times\
    \ += 1 \n\t\tif n % 13 == 0 \n\t\t\tcount.times += 1 \n\t\tif n % 7 == 0 \n\t\t\
    \tcount.times += 1 \n\t\tn = n / 10\n\tend\n\tcount.times \nend", "  count = 0\n\
    \  while n > 0\n    if n % 11 == 0\n      count += 1\n    n /= 11\n    if n %\
    \ 13 == 0\n      count += 1\n    n /= 13\n  end\n  return count\nend\n</code>\n\
    <|/ a tags=ruby,fizzbuzz dscore=0 |>\n<| c |>\nThanks Jonathan, I realized the\
    \ mistake I had made earlier but thanks for taking the time to answer.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nThis works too but it is more complex to understand than\
    \ the previous answers.\n<code>", "  n.to_s.split(\"\").each do |i|\n    i.to_i.div(11).zero?\
    \ ? \"FizzBuzz number #{n}\" : i\n  end\nend", "  count = 0; num = 1\n  (1..n).each\
    \ do |i|\n    if ((num % 11) == 0) || ((num % 13) == 0)\n      count += 1\n  \
    \    break\n    end\n    num += 1\n  end\n  count\nend", "    n.to_i.each do |n|\n\
    \        if n % 11 == 0\n            puts \"11\"\n        elsif n % 13 == 0\n\
    \            puts \"13\"\n        else\n            puts n\n        end\n    end\n\
    end", "  # Initialize the array as zeros.\n  output = [0,0,0,0]\n  # Count how\
    \ many times 7 is divisible by 11, and count how many times 7 is divisible by\
    \ 13.\n  output[0] += n.to_s.scan(/7/).size % 11 == 0\n  output[1] += n.to_s.scan(/7/).size\
    \ % 13 == 0\n  output[2] += n.to_s.scan(/7/).size % 11 != 0 and n.to_s.scan(/7/).size\
    \ % 13 != 0\n  output[3] += n.to_s.scan(/7/).size % 11 == 0 and n.to_s.scan(/7/).size\
    \ % 13 != 0\n  # Return the array.\n  output\nend\n</code>\nI believe this will\
    \ work :)\n<|/ a dscore=1 |>\n<| c |>\nThis is not working with Ruby 1.9.3. It\
    \ returns `[\"0\", \"1\", \"1\", \"0\", \"0\", \"0\"]`.\n<|/ c |>\n<| c |>\nIt\
    \ works with Ruby 1.9.3. I tested with 1.9.3.\n<|/ c |>\n<| c |>\nIt doesn't,\
    \ it returns `[\"0\", \"1\", \"0\", \"1\", \"0\", \"0\", \"0\"]`.\n<|/ c |>\n\
    <| c |>\nIt doesn't return `[\"0\", \"1\", \"0\", \"1\", \"0\", \"0\", \"0\"]`\
    \ with the code I've posted.\n<|/ c |>\n<| c |>\nIt doesn't return `[\"0\", \"\
    1\", \"0\", \"1\", \"0\", \"0\", \"0\"]` with your code either. It returns `[\"\
    0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"0\", \"0\"]`.\n\
    <|/ c |>\n<| a tags=ruby,fizzbuzz,ruby-on-rails |>\nI believe this would also\
    \ work, but is more complicated:\n<code>", "  if n < 0 \n    puts \"Invalid input.\"\
    \n  elsif n % 11 == 0\n    puts \"FizzBuzz: #{n}\"\n  elsif n % 13 == 0\n    puts\
    \ \"FizzBuzz: #{n}\"\n  else\n    puts \"FizzBuzz: #{n}\"\n  end\nend", "  if\
    \ n < 10\n    puts n\n  elsif n % 11 == 0\n    puts \"FizzBuzz\"\n  elsif n %\
    \ 13 == 0\n    puts \"Fizz\"\n  else\n    puts \"Buzz\"\n  end\nend", "  i = 0\n\
    \  result = \"\"\n  while i < n \n    digits = i.to_s.split(\"\")\n    digits.each\
    \ do |digit|\n      if digit == \"7\"\n        if i % 11 == 0\n          result\
    \ += \"fizzbuzz\"\n        else\n          result += \"fizz\"\n        end\n \
    \     elsif digit == \"7\"\n        if i % 13 == 0\n          result += \"buzz\"\
    \n        else\n          result += \"buzz\"\n        end\n      else\n      \
    \  result += \"#{digit}\"\n      end\n    end\n    i += 1\n  end\n  result\nend\n\
    </code>\n<|/ a tags=ruby,string,ruby-on-rails |>\n<| c |>\nThank you, but I do\
    \ not want to use fizzbuzz method and I am looking for other methods which are\
    \ more optimized than this method\n<|/ c |>\n<| c |>\nI have added the code for\
    \ the other methods too.\n<|/ c |>\n<| c |>\nThe method above doesn't require\
    \ fizzbuzz method\n<|/ c |>\n<| c |>\nYour method doesn't even run... You can't\
    \ iterate on a string. Moreover why did you add `\"\"` at the beggining?\n<|/\
    \ c |>\n<| c |>\nThe code runs fine but as mentioned in the comment it is inefficient\
    \ and I am looking for the method which is more efficient\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,string,ruby-on-rails |>\nThe most efficient way is probably to use\
    \ a hash:\n<code>", "  while n > 0\n    divisible_by_11 = n % 11 == 0\n    divisible_by_13\
    \ = n % 13 == 0\n    if divisible_by_11 && divisible_by_13\n      puts \"#{n}\
    \ is a Fizz Buzz\"\n    elsif divisible_by_11\n      puts \"#{n} is a Fizz\"\n\
    \    elsif divisible_by_13\n      puts \"#{n} is a Buzz\"\n    else\n      puts\
    \ \"#{n} is a #{n % 10}\"\n    end\n    n -= 1\n  end\nend\n</code>\nNow we can\
    \ check which numbers yield Fizz Buzz:\n<code>\nfizz_buzz 1_000", "  if n % 11\
    \ == 0 and n % 13 == 0\n    return 1\n  else\n    return 0\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nA much more efficient approach than other\
    \ answers here:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
