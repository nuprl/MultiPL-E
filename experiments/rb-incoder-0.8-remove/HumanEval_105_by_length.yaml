name: HumanEval_105_by_length
language: rb
prompt: "# Given an array of integers, sort the integers that are between 1 and 9\
  \ inclusive,\n# reverse the resulting array, and then replace each digit by its\
  \ corresponding name from\n# \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
  Six\", \"Seven\", \"Eight\", \"Nine\".\n# For example:\n# >>> by_length([2, 1, 1,\
  \ 4, 5, 8, 2, 3])   \n# [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
  , \"One\", \"One\"]\n# If the array is empty, return an empty array:\n# If the array\
  \ has any strange number ignore it:\n# >>> by_length([1, -1 , 55]) \n# ['One']\n\
  def by_length(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_by_length\n\
  \    candidate = method(:by_length)\n    assert_equal([\"Eight\", \"Five\", \"Four\"\
  , \"Three\", \"Two\", \"Two\", \"One\", \"One\"], candidate.call([2, 1, 1, 4, 5,\
  \ 8, 2, 3]))\n    assert_equal([], candidate.call([]))\n    assert_equal([\"One\"\
  ], candidate.call([1, -1, 55]))\n    assert_equal([\"Three\", \"Two\", \"One\"],\
  \ candidate.call([1, -1, 3, 2]))\n    assert_equal([\"Nine\", \"Eight\", \"Four\"\
  ], candidate.call([9, 4, 8]))\n  end\nend\n"
completions: ["  arr.each do |el|\n    if el < 1 || el > 9\n      return arr\n   \
    \ end\n    \n    # get the right number\n    pos = el - 10\n    \n    # sort the\
    \ left side array\n    arr.sort! { |a, b| b[a] <=> a[b] } \n    \n    # reverse\
    \ the right side array\n    arr.reverse! \n    \n    # replace the number with\
    \ the corresponding one\n    arr.each { |e| el = e if el == pos }\n  end\n  \n\
    \  arr\nend", "  return arr.sort.reverse.map { |x| x<10? \"One\"\n    : x<20?\
    \ \"Two\"\n    : x<30? \"Three\"\n    : x<40? \"Four\"\n    : x<50? \"Five\"\n\
    \    : x<60? \"Six\"\n    : x<70? \"Seven\"\n    : x<80? \"Eight\"\n    : x<90?\
    \ \"Nine\"\n    : x<100? \"One\"\n    : \"Two\"\n  }\nend\n</code>\n<|/ a |>\n\
    <| a dscore=3 |>\nThis one also works:\n<code>", "  n = arr.length\n  result =\
    \ Array.new(n)\n  (0...n).each do |i|\n    lower = 1 if i < 10 \n    upper = 9\
    \ if i >= 10\n    if lower <= arr[i] && arr[i] < upper\n      result[i] = arr[arr[i]\
    \ - lower] + upper.to_s\n    else\n      result[i] = 'One' if i == 0\n      result[i]\
    \ = 'Two' if i == 1\n      result[i] = 'Three' if i == 2\n      result[i] = 'Four'\
    \ if i == 3\n      result[i] = 'Five' if i == 4\n      result[i] = 'Six' if i\
    \ == 5\n      result[i] = 'Seven' if i == 6\n      result[i] = 'Eight' if i ==\
    \ 7\n      result[i] = 'Nine' if i == 8\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a |>\n<| a dscore=1 tags=ruby |>\nIf you're going to be doing this sort of\
    \ thing regularly, it might be worth considering using a hash:\n<code>\nnames\
    \ = {1 => 'One', 2 => 'Two', 3 => 'Three', 4 => 'Four', 5 => 'Five', \n      \
    \   6 => 'Six', 7 => 'Seven', 8 => 'Eight', 9 => 'Nine'}\n</code>\nand then doing\
    \ something like:\n<code>", "    return arr.reverse.map { |i| i == 1 ? \"One\"\
    \ : (i == 2 ? \"Two\" : (i == 3 ? \"Three\" : (i == 4 ? \"Four\" : (i == 5 ? \"\
    Five\" : (i == 6 ? \"Six\" : (i == 7 ? \"Seven\" : (i == 8 ? \"Eight\" : \"Nine\"\
    )))))))}\nend", '  return [] if (arr.empty? or arr.any? {|n| n !~ /^-?\d+$/}) ',
  "  return [] if arr.empty? || arr.any? { |x| x.is_a?(Integer) }\n  arr.sort!\n \
    \ arr.map! { |i| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\"][i - 1] } \n  arr.map { |x| x.to_s } \nend", "  if\
    \ arr.empty? || arr.any? {|n| n != n && n.to_i == n}\n    []\n  elsif arr.include?(arr[0])\n\
    \    arr\n  else\n    arr.reverse \n    arr.reject {|n| n % 10 != 0}\n  end\n\
    end", "\tresult = Array.new()\n\tarr.each do |x|\n\t\tresult << [\"One\",\"Two\"\
    ,\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"][x-1]\n\tend\n\
    \treturn result if arr.size > 0\n\treturn Array.new() \nend", "  arr.sort! \n\
    \  arr.reverse \n  arr.each {|i| arr[i] = One.name[i - 1] } \n  return arr if\
    \ arr.size > 0\n  arr\nend", "  arr.sort!\n  arr.size.times do |i|\n    if i >\
    \ 0\n      arr[i-1] = arr[i-1].to_s\n    end\n  end\n  arr[0] = 'One' if arr.size\
    \ == 1\n  arr[-1] = 'Nine' if arr.size == 9\n  arr.delete_if(&:blank?)\n  arr\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,sorting |>\n<| a tags=ruby,sorting dscore=0\
    \ |>\nYou can use a regular expression to match the digits between 1 and 9, followed\
    \ by a character and replace them with their names.\n<code>", "  return arr.sort.reverse.map\
    \ {|i| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"\
    Eight\", \"Nine\"].find { |name| name.to_i == i } }.reject { |name| name.to_i.zero?\
    \ }\nend", "  return arr ? arr.select{ |x| x % 10 == 1 || x % 10 == 2 || x % 10\
    \ == 3 || x % 10 == 4 || x % 10 == 5 || x % 10 == 6 || x % 10 == 7 || x % 10 ==\
    \ 8 || x % 10 == 9 }.sort_by{ |x| -x }.map{ |x| name(x) } : []\nend", "  arr.uniq.sort!\n\
    \  arr.each { |x| x = x % 10; arr[x] = by_num[x] || x }\n  arr.reject! {|x| x.is_a?(String)\
    \ }\n  arr\nend", "  arr = arr.sort{|a,b| b<=>a} if arr.length>0\n  arr = arr.reverse.replace\
    \ \"0\" => \"One\", \"1\" => \"Two\", \"2\" => \"Three\", \"3\" => \"Four\", \"\
    4\" => \"Five\", \"5\" => \"Six\", \"6\" => \"Seven\", \"7\" => \"Eight\", \"\
    8\" => \"Nine\"\n  arr\nend", "  arr.each_with_index do |n, i|\n    if n > 9\n\
    \      arr[i] = \"Nine\" if n == 9\n      arr[i] = \"Eight\" if n == 8\n     \
    \ arr[i] = \"Seven\" if n == 7\n      arr[i] = \"Six\" if n == 6\n      arr[i]\
    \ = \"Five\" if n == 5\n      arr[i] = \"Four\" if n == 4\n      arr[i] = \"Three\"\
    \ if n == 3\n      arr[i] = \"Two\" if n == 2\n      arr[i] = \"One\"\n    end\n\
    \  end\n  arr.empty? ? [] : arr\nend", "  res = []\n  arr.each do |e|\n    if\
    \ 1..9 < e\n      res += [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\"].map {|i| \"#{e}#{i}\"}\n    end\n    if\
    \ e..18 < 9\n      res += [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\"\
    , \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"].map {|i|\
    \ \"#{e}#{i}\"}\n    end\n  end\n  res.empty? ? [] : res.reverse\nend", "  if\
    \ arr.empty? \n    return [] if arr.any? {|x| x.odd? }\n  else\n    arr.sort!\n\
    \    arr.reverse!\n    arr.reject {|x| x.odd? }\n    arr.map do |x|\n      if\
    \ x % 10 == 1\n        x = \"One\"\n      elsif x % 10 == 2\n        x = \"Two\"\
    \n      elsif x % 10 == 3\n        x = \"Three\"\n      elsif x % 10 == 4\n  \
    \      x = \"Four\"\n      elsif x % 10 == 5\n        x = \"Five\"\n      elsif\
    \ x % 10 == 6\n        x = \"Six\"\n      elsif x % 10 == 7\n        x = \"Seven\"\
    \n      elsif x % 10 == 8\n        x = \"Eight\"\n      elsif x % 10 == 9\n  \
    \      x = \"Nine\"\n      end\n      x\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=1 |>\n<code>", "  arr = [] if arr.empty? || arr.nil? || arr.kind_of?\
    \ String || arr.kind_of? Array \n  return arr if arr.length == 1\n  arr.map {\
    \ |x| x = x.to_i if x.between?(1,9)}\n  .sort\n  .reverse\n  .map{|x| x = [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"][x] if x}\nend\n</code>\n<|/ a tags=sorting,ruby |>\n<| a |>\nI like\
    \ to use sort to do things like this, but I think that my solution is more complicated.\
    \ My solution doesn't use Array#sort, so it can be more efficient:\n<code>", " \
    \ if arr.empty? or arr.any? { |x| !x.is_a?(Fixnum) or x > 9 } \n    return []\n\
    \  else\n    arr.map! {|x| x > 9 ? 1 : x}\n    arr.reverse\n    arr.map! {|x|\
    \ x >= 1 && x <= 9 ? \"One\" : x }\n  end\nend", "  arr.sort!\n  new_arr = []\n\
    \  arr.each do |i|\n    if i.between?(1, 9)\n      new_arr << i\n    else\n  \
    \    new_arr << i\n    end\n  end\n  new_arr.reverse!\n  new_arr.each do |i|\n\
    \    num = rand(1..9).to_s\n    num = {\"One\" => 1, \"Two\" => 2, \"Three\" =>\
    \ 3, \"Four\" => 4, \"Five\" => 5, \"Six\" => 6, \"Seven\" => 7, \"Eight\" =>\
    \ 8, \"Nine\" => 9}\n    num = num[i]\n    new_arr << num\n  end\n  return new_arr\n\
    end", "  arr.each do |x|\n    number = (x / 10).to_i\n    number >= 1 && number\
    \ <= 9 ? arr[number] << x : \"#{number}\"\n  end\n  arr\nend", "  len = arr.length\n\
    \  arr.sort!\n  arr.size.times { arr.pop }\n  arr.map! { |n| n + ((len == 1) ?\
    \ 'One' : ((len == 2) ? 'Two' : ((len == 3) ? 'Three' : ((len == 4) ? 'Four' :\
    \ ((len == 5) ? 'Five' : ((len == 6) ? 'Six' : ((len == 7) ? 'Seven' : ((len ==\
    \ 8) ? 'Eight' : ((len == 9) ? 'Nine' : 'Unknown')))))))}\nend\n</code>\n<|/ a\
    \ tags=arrays,ruby |>\n<| a tags=arrays,ruby dscore=2 |>\nI thought I'd take a\
    \ crack at this, as I was trying to come up with a simple method to reverse an\
    \ array in Ruby without having to call a native function. I wrote a method that\
    \ recursively reverses an array. Below is a sample implementation.\n<code>", " \
    \ arr.sort\n  arr.length < 1 || arr.length > 9 ? [] : arr.reverse.map{|n| ones[n.to_i]\
    \ }\nend", "    arr.sort!\n    arr.empty? and return[]\n    arr.each do |i|\n\
    \        arr[i] < 10 and return[arr[i]]\n        arr[i] < 10 and return[arr[i]]\n\
    \    end\nend\n</code>\n<|/ a |>\n<| a tags=sorting,ruby,arrays dscore=2 |>\n\
    This is not the most efficient code by any means, but it does what you need:\n\
    <code>", "  n = 1\n  result = []\n  while n > 0 do\n  \tlast = 0\n  \twhile n\
    \ > 0 do\n  \t\tif arr[n-1] > arr[n] then\n  \t\t\tlast = n\n  \t\t\tbreak\n \
    \ \t\tn -= 1\n  \t\tend\n  \tend\n  \tresult[n] = names[last]\n  \tn -= 1\n  end\n\
    \  result\nend", "  return arr.sort.reverse.map { |x| x.to_s.succ! }.compact.select\
    \ { |x| x }\nend", "  return arr.map { |num| num > 9 ? num.to_s[1..-1] : num.to_s\
    \ }\nend", "  if arr.empty? || arr.count == 0\n    return arr\n  arr.sort\n  arr.map!\
    \ { |i| \n    case i\n      when 1..9\n        \"One\"\n      when 10..99\n  \
    \      \"Two\"\n      when 100..999\n        \"Three\"\n      when 1000..9999\n\
    \        \"Four\"\n      when 10000..99999\n        \"Five\"\n      when 100000..999999\n\
    \        \"Six\"\n      when 1000000..999999999\n        \"Seven\"\n      when\
    \ 10000000..99999999\n        \"Eight\"\n      when 100000000..99999999999\n \
    \       \"Nine\"\n      else \n        i.to_s\n    end\n  }\n  arr\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby |>\n<| a tags=ruby-on-rails,ruby |>\nTry this\n\
    <code>\n  a = arr.sort\n  a.each_with_index do |x, i|\n    arr[i] = (x % 10).zero?\
    \ ? \"#{x}#{arr[i-1]}\" : \"#{arr[i-1]}#{x}\"\n  end\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`each_with_index` returns an array of tuples. I think you mean\
    \ `each_with_index` which returns an array of indices and an item of each index.\n\
    <|/ c |>\n<| c |>\nFixed it\n<|/ c |>\n<| c |>\n`arr.sort` and `a.sort` are very\
    \ different things.\n<|/ c |>\n<| a |>\n<code>", "  return arr ? arr.select {|x|\
    \ x < 10 && x > 1 ? x.to_s : \"#{x}\".to_sym }.sort.reverse.reduce([]) { |acc,\
    \ x| acc << one_or_nine(x) }.join : []\nend", "  arr.each do |item|\n    if item>9\n\
    \      tmp = item\n      item = 0\n      while item < tmp\n        item+=1\n \
    \     end\n      arr.remove(item)\n    end\n  end\n  arr.each do |item|\n    arr.remove(item)\n\
    \  end\n  arr.empty? ? [] : arr.map do |item| \n      i = -1\n      while item\
    \ > i\n        i+=1\n      end\n      i.zero? ? item : i.to_s\n    end.reverse\n\
    end", "  return arr.sort {|a,b| a <=> b}.reverse if arr[0] > 0\n  return [] if\
    \ arr.empty?\n  arr.map {|x| [ \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\", x ] }\nend", "    arr.flatten\n   \
    \ arr.sort.reverse\n    arr.map { |i| i % 10 == 5 ? \"Five\" : (i % 10 == 7 ?\
    \ \"Six\" : \"One\") }.compact\nend\n</code>\n<|/ a dscore=2 tags=ruby,sorting\
    \ |>\n<| a tags=ruby,sorting |>\n<code>", "  arr.empty? || arr.all? { |x| x <=\
    \ 1 || x > 9 }\n  arr.empty? ? [] : arr.map { |x| \n    if x <= 9\n      x\n \
    \   elsif x == 1 \n      \"One\"\n    elsif x == 2 \n      \"Two\"\n    elsif\
    \ x == 3 \n      \"Three\"\n    elsif x == 4 \n      \"Four\"\n    elsif x ==\
    \ 5\n      \"Five\"\n    elsif x == 6\n      \"Six\"\n    elsif x == 7\n     \
    \ \"Seven\"\n    elsif x == 8\n      \"Eight\"\n    elsif x == 9\n      \"Nine\"\
    \n    elsif x > 9 \n      \"Unknown\"\n    end\n  }\nend", "    arr = arr.sort\
    \ { |a, b| b - a} if arr.size > 0\n    if arr.empty?\n      return arr\n    end\n\
    \    arr.unshift(['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight',\
    \ 'Nine'].sample)\n    arr.compact!\n    arr.map do |digit|\n      one_through_nine\
    \ = {1 => \"One\", 2 => \"Two\", 3 => \"Three\", 4 => \"Four\", 5 => \"Five\"\
    , 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\", 9 => \"Nine\"}\n      name = one_through_nine[digit]\n\
    \      name if name.present?\n    end\n  end\n</code>\n<|/ a tags=ruby,arrays,string,sorting\
    \ dscore=3 |>\n<| a dscore=2 tags=ruby,arrays,string,sorting |>\nIf you're interested\
    \ in a more functional approach than mine, you could do something like this:\n\
    <code>\nrequire 'set'", "  if arr.nil? or arr.length == 0\n    return []\n  else\n\
    \    arr.sort { |a, b| a <=> b }.reverse.map { |x| x_to_name(x) }\n  end\nend",
  "  if arr.empty?\n    []\n  elsif arr.include?(-Inf)\n    []\n  elsif arr.include?(Inf)\n\
    \    []\n  elsif arr.size == 1\n    [arr[arr.size - 1]]\n  else\n    temp = arr.sort\n\
    \    reverse(temp)\n    temp.map!{ |x| [one_digit(x), two_digit(x), three_digit(x),\
    \ four_digit(x), five_digit(x), six_digit(x), seven_digit(x), eight_digit(x),\
    \ nine_digit(x)] }\n  end\nend", "\tarr = arr.sort\n\tarr.reverse!\n\tarr.map!\
    \ {|i| names[i] }\n\tarr\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  sorted\
    \ = arr.sort{|a, b| b <=> a}.reverse.map(&:to_s)\n  unless sorted.empty?\n   \
    \ sorted.map! do |d|\n      d = d.downcase\n      if d =~ /one/i then \"One\"\n\
    \      elsif d =~ /two/i then \"Two\"\n      elsif d =~ /three/i then \"Three\"\
    \n      elsif d =~ /four/i then \"Four\"\n      elsif d =~ /five/i then \"Five\"\
    \n      elsif d =~ /six/i then \"Six\"\n      elsif d =~ /seven/i then \"Seven\"\
    \n      elsif d =~ /eight/i then \"Eight\"\n      elsif d =~ /nine/i then \"Nine\"\
    \n      elsif d =~ /0/i then \"Zero\"\n      else d\n      end\n    end\n  else\n\
    \    sorted = ['']\n  end\n  sorted\nend", "  arr.each do |x|\n    if x.class\
    \ == Fixnum\n      x += 1\n    end\n    next if x == -1\n    unless x % 10 ==\
    \ 0\n      arr[x] = One\n      next if x < 10\n      arr[x] = Two\n      next\
    \ if x < 20\n      arr[x] = Three\n      next if x < 30\n      arr[x] = Four\n\
    \      next if x < 40\n      arr[x] = Five\n      next if x < 50\n      arr[x]\
    \ = Six\n      next if x < 60\n      arr[x] = Seven\n      next if x < 70\n  \
    \    arr[x] = Eight\n      next if x < 80\n      arr[x] = Nine\n      next if\
    \ x < 90\n    end\n  end\n  arr\nend", "  \n  if arr.is_a? Array\n    arr.sort!\n\
    \    arr.reverse\n    arr.map {|i| to_name[i - 1] }\n  else\n    []\n  end\nend",
  "  return arr if arr.size <= 9 else [arr.reverse.first(9).map(&:to_s).first]\nend",
  "  if arr.empty?\n    []\n  elsif arr.any?\n    arr.map do |num|\n      if num >=\
    \ 1 && num <= 9\n        num.to_s.reverse\n      elsif num > 100\n        \"Other\"\
    \n      else\n        \"Unknown\"\n      end\n    end\n  else\n    \"Unknown\"\
    \n  end\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm,string dscore=2 |>\n<|\
    \ a tags=ruby,arrays,algorithm,string |>\n<code>", "    arr.sort_by {|e| e < 0\
    \ ? -e.abs : e}.reverse.map { |e| name(e) }\nend", "\tarr.empty? or arr.any?{\
    \ |x| x >= 1 && x <= 9 } or return []\n\tlen = arr.length\n\tarr.sort!\n\tarr.unshift(nil)\n\
    \tarr.push(nil)\n\tarr.reverse!\n\tarr.map! do |x| \n\t\treturn \"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" if len\
    \ == 1 && x > 0\n\t\treturn \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"\
    Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"\
    \ if len >= 10 && x <= 9\n\t\treturn \"Ninety\" if len >= 100 && x <= 89\n\t\t\
    return \"Twenty\" if len >= 200 && x <= 199\n\t\treturn \"Twentyone\" if len >=\
    \ 2000 && x <= 2999\n\t\treturn \"Twentytwo\" if len >= 20000 && x <= 29999\n\t\
    \treturn \"Twentythree\" if len >= 200000 && x <= 39999\n\t\treturn \"Twentyfour\"\
    \ if len >= 300000 && x <= 59999\n\t\treturn \"Twentyfive\" if len >= 500000 &&\
    \ x <= 999999\n\t\treturn \"Twentysix\" if len >= 1000000 && x <= 1999999\n\t\t\
    return \"Twentyseven\" if len >= 2000000 && x <= 3999999\n\t\treturn \"Twentyeight\"\
    \ if len >= 4000000 && x <= 5999998\n\t\treturn \"Twentynine\" if len >= 10000000\
    \ && x <= 1999999999\n\t\treturn \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\" if len >= 1000000 && x <= 1999999\n\t\
    \treturn \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\"\
    , \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" if len >= 10000 && x\
    \ <= 99\n\t\treturn \"Ninety\" if len >= 100 && x <= 89\n\t\treturn \"Twenty\"\
    \ if len >= 200 && x <= 199\n\t\treturn \"Twentyone\" if len >= 2000 && x <= 2999\n\
    \t\treturn \"Twentytwo\" if len >= 20000 && x <= 29999\n\t\treturn \"Twentythree\"\
    \ if len >= 200000 && x <= 39999\n\t\treturn \"Twentyfour\" if len >= 300000 &&\
    \ x <= 59999\n\t\treturn \"Twentyfive\" if len >= 500000 && x <= 999999\n\t\t\
    return \"Twentysix\" if len >= 1000000 && x <= 1999999\n\t\treturn \"Twentyseven\"\
    \ if len >= 2000000 && x <= 3999999\n\t\treturn \"Twentyeight\" if len >= ", " \
    \ arr.sort! {|a, b| b <=> a}\n  arr.reverse!\n  arr.map!{|x| if x.to_s =~ /^[1-9]$/\
    \ then \"One\"\n                  elsif x.to_s =~ /^[0-7]$/ then \"Two\"\n   \
    \               elsif x.to_s =~ /^[0-8]$/ then \"Three\"\n                  elsif\
    \ x.to_s =~ /^[-0-1]$/ then \"Four\"\n                  elsif x.to_s =~ /^[-0]$/\
    \ then \"Five\"\n                  elsif x.to_s =~ /^[-0-9]$/ then \"Six\"\n \
    \                 elsif x.to_s =~ /^[-0-9]$/ then \"Seven\"\n                \
    \  elsif x.to_s =~ /^[-0]$/ then \"Eight\"\n                  elsif x.to_s =~\
    \ /^[-0]$/ then \"Nine\"\n                  else x.to_s end}\n  arr\nend\n</code>\n\
    <|/ a |>\n<| c |>\n`by_length([])` returns an empty array, not `nil`.\n<|/ c |>\n\
    <| c |>\n, thank you for pointing that out. I will update the answer.\n<|/ c |>\n\
    <| a dscore=0 tags=sorting,arrays,ruby |>\nIf your array is sorted, you could\
    \ sort it by taking the value from the middle of the array, and swapping the two\
    \ adjacent values until they match one of the values you want to sort on. For\
    \ example:\n<code>", "  arr.compact.sort.reverse.map do |num|\n    if num > 9\n\
    \      names[num-10 % 10]\n    else\n      names[num]\n    end\n  end\nend\n</code>\n\
    <|/ a |>\n<| a tags=arrays,ruby,algorithm,string dscore=2 |>\n<code>", "  arr\
    \ = arr.dup.sort\n  arr.empty? ? [] : arr.reverse.map { |i| i.to_s.upcase }\n\
    end\n</code>\nI should note that I added the extra complexity of .dup because\
    \ I didn't want to have to worry about a possible mutation of the original array\
    \ - if you're working with a huge collection that you might want to sort multiple\
    \ times then you would want to avoid the extra copy.\n<|/ a tags=ruby |>\n<| c\
    \ |>\nHi David, thanks for taking the time to give such an elaborate answer. In\
    \ the process of implementing your suggestion and reading up on it (I'm new to\
    \ Ruby), I've noticed a couple small things I don't understand. For example, how\
    \ does Ruby know to sort by the second value in each array? Does it look at each\
    \ character in each string and check whether it's a digit? I understand that by\
    \ default, sorting in Ruby is case sensitive but this doesn't seem to affect how\
    \ it sorts arrays of strings. I'm also curious to know what the .dup is doing\
    \ in your code. Thanks again.\n<|/ c |>\n<| c |>\nThe second value in each array\
    \ is just the second index (zero-based), so the first value in each array would\
    \ be `arr[0].first` (the first character in each string, which would return a\
    \ string of length 1).\n<|/ c |>\n<| c |>\nAs for the `.dup` - that method makes\
    \ a copy of the original array so that you can make changes to it and have it\
    \ be reflected in your original array (which I assumed you wanted). If you're\
    \ not familiar with `.dup` it just creates a new array that you can modify without\
    \ affecting the original array (which can be useful sometimes, but isn't really\
    \ commonly used in Ruby).\n<|/ c |>\n<| c |>\nThanks for explaining that one David,\
    \ much appreciated.\n<|/ c |>\n<| c |>\nThe string method `.chars` returns an\
    \ array containing one element for each character in the string. So `'hello'.chars\
    \ #=> [\"h\", \"e\", \"l\", \"l\", \"o\"]`.\n<|/ c |>\n<| a tags=ruby dscore=1\
    \ |>\nA method similar to that of is called partition:\n<code>", "  if arr.length\
    \ == 0 \n    arr = []\n  el = arr.first \n  arr.each do |i|\n    if i <= 9\n \
    \     el = el.to_s + i.to_s\n    else\n      el = el.to_s\n    end\n  end\n  return\
    \ arr\nend", "  arr.compact.sort_by(&:length).reverse.map do |digit|\n    digit.to_s[0..1]\
    \ + number.names.delete_at(number.names.index(digit.to_s))\n  end\nend", "  return\
    \ [] if arr.empty? || arr.any?(&:odd?) || arr.any?(&:zero?)\n  arr = arr.sort_by(&:length).reverse\n\
    \  arr.map { |i| i.to_s.chars.reverse.map { |c| \n    if i.to_s.include?(c)\n\
    \      \"One\" # or any other string you want here\n    else\n      c\n    end\n\
    \  }.join }\nend", "  arr.reject!{ |x| x == nil }\n  arr.delete_if { |x| x < 1\
    \ || x > 9}\n  arr.sort_by!{ |x| x.to_s }\n  arr.reverse!\n  arr.each_with_index\
    \ do |n, i|\n    arr[i] = \"#{ONE_NAMES[i]}#{n}\"\n  end\n  arr\nend", "  arr_copy\
    \ = arr\n  arr_copy.pop if arr.empty?\n  arr_copy.map!{|i| i if i.between?(1,\
    \ 9).present? ? i.to_s[1..-1] : i}\n  arr_copy\nend\n</code>\n<|/ a |>\n<| c |>\n\
    That was fast.  You beat me by about 40 seconds :P\n<|/ c |>\n<| a tags=sorting,ruby\
    \ |>\nIf you're looking for a way to write this more concisely, then use Array#zip:\n\
    <code>\na = %w{One  Two  Three  Four  Five  Six  Seven  Eight  Nine}\nb = [2,\
    \ 1, 1, 4, 5, 8, 2, 3]\na.zip(b).map { |k, v| v && v.zero? ? k : v.reverse.to_s\
    \ }", "  # Your code here\n  result = []\n  if arr.empty?\n    result = []\n \
    \ elsif arr.size == 0\n    result = []\n  elsif arr.any?{|x| x < 1 || x > 9}\n\
    \    result = []\n  else\n    (arr.size - 1).downto(0){|i| \n      if arr[i] <\
    \ 1 || arr[i] > 9\n        arr[i] = nil\n      else\n        result.push(arr.dup)\n\
    \        arr.delete_at(arr.index(i))\n      end\n    }\n  end\n  arr\nend\nputs\
    \ by_length([1, -1, 55]).inspect\nputs by_length([2, 1, 1, 4, 5, 8, 2, 3]).inspect",
  "  return [] if arr.empty? or arr.any?(&(&1.between?(1, 9)) or arr.any?(&(&1 > 9)))\
    \ \n  arr.map do |e|\n    if e.between?(1, 9) \n      \"One\"\n    elsif e ==\
    \ -1\n      \"Zero\"\n    elsif e > 9\n      \"Nine\"\n    else\n      \"Eight\"\
    \n    end\n  end\nend", "    min = arr.min\n    max = arr.max\n    result = []\n\
    \    arr.each do |x|\n      result << (case x\n                when 1..9\n   \
    \               x\n                when -1\n                  'One'\n        \
    \        when 55\n                  'One'\n                else\n            \
    \      (case (x-min)\n                    when 0..9\n                      \"\
    #{(x-min).to_s.rjust(3, '0')}Ten\"\n                    when 0..99\n         \
    \             (case (x-min)\n                        when 0..59\n            \
    \              \"#{(x-min).to_s.rjust(3, '0')}Five\"\n                       \
    \ when 60..79\n                          \"#{(x-min).to_s.rjust(3, '0')}Four\"\
    \n                        when 80..99\n                          \"#{(x-min).to_s.rjust(3,\
    \ '0')}Three\"\n                        when 90..111\n                       \
    \   \"#{(x-min).to_s.rjust(3, '0')}Two\"\n                        when 120..139\n\
    \                          \"#{(x-min).to_s.rjust(3, '0')}One\"\n            \
    \            else\n                          \"#{(x-min).to_s.rjust(3, '0')}Zero\"\
    \n                      end)\n                    else\n                     \
    \ nil\n                  end)\n                end)\n    end\n    if result.empty?\
    \ \n      result\n    else\n      result.sort{|x,y| y<=>x }.reverse\n      result\n\
    \    end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis code doesn't\
    \ work.  `by_length([])` returns `[]`, `by_length([10])` returns `[10, \"Ten\"\
    , \"One\"]`, `by_length([11, 10])` returns `[10, \"One\", \"Ten\"]`.  The last\
    \ result should be `[\"One\", \"Ten\"]`.  It doesn't work like I wrote.\n<|/ c\
    \ |>\n<| c |>\nFixed, try it now!\n<|/ c |>\n<| c |>\nIt doesn't work.  `by_length([])`\
    \ returns `[]`, `by_length([10])` returns `[10, \"Ten\", \"One\"]`, `by_length([11,\
    \ 10])` returns `[10, \"One\", \"Ten\"]`.  The last result should be `[\"One\"\
    , \"Ten\"]`.  It doesn't work like I wrote.\n<|/ c |>\n<| c |>\nI updated it with\
    \ a fixed code, try it now please!\n<|/ c |>\n<| c |>\nThe only problem with your\
    \ code is that it doesn't work the way I wrote it.  I edited the original question\
    \ to make it more obvious.\n<|/ ", "  if arr.size == 0\n    []\n  elsif arr.any?\
    \ { |n| n < 1 || n > 9 }\n    arr\n  else\n    arr\n    .sort\n    .reverse\n\
    \    .map { |n| name[n] }\n  end\nend", "  if arr.empty? or arr.any? { |x| x !=\
    \ 0 && x % 10 == 1 }\n    arr\n  else\n    arr = arr.reverse\n    arr[1..9].map\
    \ { |x| to_name(x) }\n  end\nend", "  arr.sort!\n  arr.reverse!\n  arr.reject!{|n|\
    \ n =~ /[-+]?\\d+/}\n  arr.map {|n| {\"One\" => 1, \"Two\" => 2, \"Three\" =>\
    \ 3, \"Four\" => 4, \"Five\" => 5, \"Six\" => 6,\n               \"Seven\" =>\
    \ 7, \"Eight\" => 8, \"Nine\" => 9, \"Ten\" => 10}[n]}\nend", "  arr.sort!\n \
    \ arr.reverse!\n  if arr.length == 0\n    []\n  elsif arr.length <= 9\n    arr.reverse!\n\
    \    arr.map {|i| One[(i%10)].to_s\n  else \n    arr\n  end\nend", "  return arr.empty?\
    \ ? [] : arr.reverse - arr.first - {1 => \"One\", 2 => \"Two\",\n    3 => \"Three\"\
    , 4 => \"Four\", 5 => \"Five\", 6 => \"Six\", 7 => \"Seven\", 8 => \"Eight\",\n\
    \    9 => \"Nine\"}.invert\nend", "  result = []\n  arr_length = arr.length\n\
    \  arr.each_with_index do |val, index|\n    result << index == 0 ? val : \n  \
    \    val <= 9 && val >= 1 ? by_length(reverse_array(arr.take(index))) \n     \
    \ : \"Nine\"\n  end\n  arr.empty? ? result : result.join(\"One\")\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nI created my own version of ruby enumerable\
    \ method \"each_with_object\" (https://apidock.com/ruby/Enumerable/each_with_object).\
    \ I tried to make it shorter and faster. The main difference is that I used the\
    \ block variable \"obj\" instead of \"obj2\". The speed gains was around 5x.\n\
    <code>", "    arr.sort! # sort the array\n    arr.each_with_index { |e, i| arr[i]\
    \ <= 9 ? arr[i] = \"One\" : arr[i] = \"Nine\" } # replace each number with its\
    \ name\n    arr.empty? ? [] : arr.map { |e| e.to_s } # map to string\nend", " \
    \ unless arr.empty?\n    arr.sort_by {|n| n < 0 ? -n : n}.reverse\n    arr.each\
    \ do |n|\n      arr[n] = names.index(n).nil? ? \"One\" : names[n]\n    end\n \
    \ end\n  arr.empty? ? [] : arr\nend\n</code>\n<|/ a |>\n<| c |>\nIt doesn't reverse\
    \ for negative numbers in my test. `by_length([9, 2, -2, 3, -5, -4, -6, -5])`\
    \ returns `[\"Two\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]` but\
    \ should be `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"\
    One\"]`.\n<|/ c |>\n<| c |>\nYes, I forgot to mention that. Thank you for bringing\
    \ it to my attention. I fixed the code. Sorry.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  if arr.empty?\n    []\n  elsif arr.any?{|n| n < 1 || n > 9}\n    arr\n  elsif\
    \ arr.any?{|n| n >= 1 && n <= 9}\n    rev = arr.reverse\n    rev.map{|i| [\"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    , i].find {|s| s == rev[i]}}\n  else\n    arr\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ dscore=2 |>\n<| a tags=ruby,arrays,sorting dscore=0 |>\nHere is how I would\
    \ do it.\n<code>", "  arr.reject(&:odd?).sort.reverse.map { |x| names[x] } if\
    \ arr.any?\nend", "  return [] if arr.length == 0\n  return arr.reverse.reduce(:<<).gsub(/\\\
    d+/) { |s| lookup[s.to_i] }.reverse\nend", "  return [] if arr.nil? or arr.empty?\
    \ or arr.any? { |v| v.to_i > 9 || v.to_i < 1 } \n  arr.reverse\n  arr.collect\
    \ do |i|\n    case i\n    when 1\n      \"One\"\n    when 2\n      \"Two\"\n \
    \   when 3\n      \"Three\"\n    when 4\n      \"Four\"\n    when 5\n      \"\
    Five\"\n    when 6\n      \"Six\"\n    when 7\n      \"Seven\"\n    when 8\n \
    \     \"Eight\"\n    when 9\n      \"Nine\"\n    else\n      i\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is great! I had to modify it slightly\
    \ to account for numbers higher than 9, but I got the idea. Thanks!\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>", "  arr.sort!\n  if arr.empty? or arr.any? { |n| n.to_i\
    \ > 9 || n.to_i < 1 }\n    arr\n  else\n    arr.reverse!\n    arr.map! { |n| self.name(n,\
    \ arr.include?(n)) }\n    arr\n  end\nend", "  arr.each_with_index { |e,i|\n \
    \   if i < 2 || i >= 9\n      return\n    end\n    arr[i] = names[e]\n  }\n  arr.compact!\n\
    \  arr.uniq!\n  arr.reverse!\n  arr.map { |e| names[e] }\nend\n</code>\n<|/ a\
    \ tags=sorting,arrays,ruby dscore=0 |>\n<| c |>\nThank you for the answer. As\
    \ you said \"The resulting array is also ordered\". Is it possible to order the\
    \ resulting array according to their length? For example [2,1,1] is ordered as\
    \ [1,1,2], but [2,1,1] is ordered as [2,1,1].\n<|/ c |>\n<| c |>\nI've edited\
    \ my answer with a new approach that does it in a single pass.\n<|/ c |>\n<| a\
    \ tags=sorting,arrays,ruby |>\nYou could do something like this\n<code>", "  arr.sort!\n\
    \  return arr.first if arr.size == 0 || arr.any? { |x| x.is_a?(Numeric) } ? arr.map{\
    \ |x| x } : [] unless arr.is_a?(Array)\n  return [] unless arr.length == 1\n \
    \ arr.map do |x|\n    if x <= 9\n      by_length([x, x])\n    else\n      x =\
    \ by_length([x, 9-x])\n      x << by_length([9-x, x])\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nPlease give credit. I am the author of [the algorithm](https://gist.github.com/jdeblau/e153aa9ba712dabfbd69)\
    \ you cited.\n<|/ c |>\n<| a tags=ruby dscore=3 |>\nMy solution based on your\
    \ example\n<code>", "    arr = arr.to_a\n    arr.sort!\n    arr.each {|num| num.odd?\
    \ ? arr[arr.index(num)] = nil : }\n    arr.each {|num| num.odd? ? \"One\" : \"\
    Two\"}\n    arr.map {|num| num && \"#{num}\".to_sym}\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nYou can achieve this with the following:\n<code>", "  arr = (arr.map(&:to_i)\
    \ & [1, 9]).sort.reverse.map { |i| arr[i-1] }\n  return arr.empty? ? [] : arr.map\
    \ { |i| i.to_s[0...-1] }\nend", "    array.sort(arr)\n    array.uniq!\n    array.map\
    \ { |x| arr.reverse!.to_a }.flatten!\n    array.map! { |x| arr.pop }.flatten!\n\
    \    arr\nend", "  arr.empty? or arr.length == 0\n  arr = arr.sort\n  arr.each_with_index\
    \ { |i, index| return arr if i.to_i > 0 && i.to_i < 10 && index == 0 }\n  arr.sort!\
    \ { |a, b| a.to_i < b.to_i }\n  arr.reverse!\n  names = [\"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  arr.map\
    \ { |i| names.index i }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,sorting,arrays\
    \ |>\nHere's a solution with Enumerable#sort, and Array#map.\n<code>\nnumbers\
    \ = %w(2 1 1 4 5 8 2 3)\nnames.sort { |a, b| numbers[a].to_i <=> numbers[b].to_i\
    \ }.reverse.map { |x| names[x] }", "  res = []\n  arr.each do |n|\n    if n >=\
    \ 1 && n <= 9\n      res << case n\n      when 1\n        \"One\"\n      when\
    \ 2\n        \"Two\"\n      when 3\n        \"Three\"\n      when 4\n        \"\
    Four\"\n      when 5\n        \"Five\"\n      when 6\n        \"Six\"\n      when\
    \ 7\n        \"Seven\"\n      when 8\n        \"Eight\"\n      when 9\n      \
    \  \"Nine\"\n      else\n        n\n      end\n    end\n  end\n  if res.empty?\n\
    \    []\n  elsif arr.any? { |n| n.to_s != n }\n    res\n  else\n    res\n  end\n\
    end", "  arr = arr.reverse if arr.length > 0\n  return arr.reduce(:<<).map { |n|\
    \ \"One\" if 1 <= n && n <= 9 else \"Two\" if 10 <= n && n <= 99 \n  else \"Three\"\
    \ if 100 < n && n <= 999 \n  else \"Four\" if 1000 < n && n <= 9999\n  else \"\
    Five\" if 1000000 < n && n <= 999999\n  else \"Six\" if 10000000 < n && n <= 9999999999\n\
    \  else \"Seven\" if 1000000000 < n && n <= 99999999999\n  else \"Eight\" if 100000000000\
    \ < n && n <= 999999999999\n  else \"Nine\" if 10000000000000 < n && n <= 999999999999999\n\
    \  else \"Zero\" } if arr.length > 0\n  []\nend", "  arr.map do |e| \n    if e\
    \ < 1 || e > 9\n      nil\n    else\n      e = case e\n            when 1..9 then\
    \ 'One'\n            when 10..19 then 'Two'\n            when 20..29 then 'Three'\n\
    \            when 30..39 then 'Four'\n            when 40..49 then 'Five'\n  \
    \          when 50..59 then 'Six'\n            when 60..69 then 'Seven'\n    \
    \        when 70..79 then 'Eight'\n            when 80..89 then 'Nine'\n     \
    \       else nil\n          end\n      e if e\n    end\n  end.compact.uniq\nend",
  "  case arr\n  when []\n    []\n  when [0]\n    []\n  when [1..9]\n    arr[1..9].map!\
    \ { |n| by_length_helper(n) }\n    arr.compact!\n    arr\n  else\n    arr\n  end\n\
    end", "  arr.compact.sort.reverse.map{ |num| digits[num] || num }\nend", "  n\
    \ = arr.length\n  if n == 0\n    arr\n  elsif n > 0\n    result = []\n    arr.each_with_index\
    \ do |i, index|\n      if i != 0 && i % 10 == 0\n        reversed_index = index\
    \ * -1\n        result.push(by_length([arr[n..reversed_index]]) + [by_length([arr[reversed_index..-1]])].flatten)\n\
    \      else\n        result.push(by_length([arr[0...index]]) + [by_length([index...n])].flatten)\n\
    \      end\n    end\n    result\n  else\n    arr\n  end\nend", "  return arr.reverse.grep(/^(One|Two|Three|Four|Five|Six|Seven|Eight|Nine)$/i).map{|x|\
    \ x.to_s}\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby dscore=0 |>\nJust\
    \ for fun, another option:\n<code>", "  arr.each do |element|\n    arr <<  element\
    \ if element > 9\n    arr << 'One' if element == 1\n    arr << 'Two' if element\
    \ == 2\n    arr << 'Three' if element == 3\n    arr << 'Four' if element == 4\n\
    \    arr << 'Five' if element == 5\n    arr << 'Six' if element == 6\n    arr\
    \ << 'Seven' if element == 7\n    arr << 'Eight' if element == 8\n    arr << 'Nine'\
    \ if element == 9\n  end\n  arr.reverse!\n  arr.map do |element| \n    if element\
    \ == 1\n      'One'\n    elsif element == 2\n      'Two'\n    elsif element ==\
    \ 3\n      'Three'\n    elsif element == 4\n      'Four'\n    elsif element ==\
    \ 5\n      'Five'\n    elsif element == 6\n      'Six'\n    elsif element == 7\n\
    \      'Seven'\n    elsif element == 8\n      'Eight'\n    elsif element == 9\n\
    \      'Nine'\n    end\n  end\nend\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c\
    \ |>\n\"Sort each element of the array by length\".... and then you're sorting\
    \ by length?\n<|/ c |>\n<| c |>\nWhoops, meant to remove that line. Edited.\n\
    <|/ c |>\n<| c |>\nI think you meant `if element > 9`\n<|/ c |>\n<| c |>\nYes,\
    \ I do, thanks! The original code was meant to sort the integers based on their\
    \ length. The OP changed their mind on that.\n<|/ c |>\n<| a tags=ruby dscore=2\
    \ |>\nMy answer:\n<code>", "  return arr.empty? ? [] : arr.select { |e| e <= 9\
    \ ? e.to_s.reverse : e }\nend", "    return arr if arr.any? or arr.size == 0 \n\
    \    # ignore strange numbers\n    return ['One'] if arr.empty? or arr.min.nil?\
    \ or arr.max.nil? \n    arr.map {|e| \n        [\"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][(e-arr.min)..(arr.max-e)+1]\n\
    \    }.reverse\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nNice solution. However\
    \ `by_length([2, 1, 1, 4, 5, 8, 2, 3])` returns `[\"Eight\", \"Five\", \"Four\"\
    , \"Three\", \"Two\", \"Two\", \"One\", \"One\"]` rather than `[\"One\", \"Two\"\
    , \"Two\", \"One\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ]` which might be less confusing for the OP.\n<|/ c |>\n<| c |>\nFixed my answer.\n\
    <|/ c |>\n<| a |>\nHere's a very basic implementation for you. I think it is much\
    \ more readable than using hashes. \n<code>", "  arr.sort\n  result = []\n  arr.each\
    \ do |x|\n    if x > 0\n      result << \"One\" if x == 1\n      result << \"\
    Two\" if x == 2\n      result << \"Three\" if x == 3\n      result << \"Four\"\
    \ if x == 4\n      result << \"Five\" if x == 5\n      result << \"Six\" if x\
    \ == 6\n      result << \"Seven\" if x == 7\n      result << \"Eight\" if x ==\
    \ 8\n      result << \"Nine\" if x == 9\n    end\n  end\n  result\nend", "   \
    \ return arr.sort { |a,b| b <=> a } .reverse.select {|x| x >=1 && x <= 9}\nend\n\
    </code>\nThe result is ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven',\
    \ 'Eight', 'Nine']\n<|/ a |>\n<| c |>\nThe OP has edited the question to change\
    \ \"One\" to \"one\", \"Two\" to \"two\", \"Three\" to \"three\", etc. Your code\
    \ would not work properly for those changes.\n<|/ c |>\n<| a dscore=0 |>\nHere\
    \ is another solution:\n<code>", "  return arr.sort.reverse.map { |x| \n    if\
    \ x < 1 || x > 9 \n      \"?\" \n    else \n      name[x-1] \n    end\n  }.compact\
    \ if arr.any?\n  []\nend\n</code>\n<|/ a |>\n<| a |>\nThis doesn't directly address\
    \ the issue of \"why is my Ruby version 2.4 not doing what it should\" as asked\
    \ in the question but still a helpful way to solve this problem for those who\
    \ don't want to make up their own names array.\n<code>", "    arr = arr.sort\n\
    \    arr.map! do |x|\n        if x == -1\n            'One'\n        elsif x ==\
    \ 0\n            'Zero'\n        elsif x < 1\n            'Small'\n        elsif\
    \ x > 9\n            'Big'\n        else\n            x.to_s\n        end\n  \
    \  end\n    arr.reverse!\n    arr.map(&:capitalize)\nend\n</cell>\n<text>\nExercise\
    \ 17: Sort and reverse an array in place using the sort method and the reverse\
    \ method.", "  arr.compact.sort_by { |i| i - 1 }.map.with_index { |_, i| [\"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ][i % 10] }\nend", "  arr.each do |i|\n    next if i.to_i > 9 || i.to_i < 1\n\
    \    arr.reverse! if i <= 9\n    break if i.to_i == 10\n    arr.reverse!\n   \
    \ arr.pop if arr[-1] == 10\n    arr[-1] = by_digit[i]\n  end\n  arr\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,algorithm,arrays |>\n<| c |>\nIt's funny how people like\
    \ `each_with_object` but don't even consider using `each_with_index`.\n<|/ c |>\n\
    <| a tags=ruby,algorithm,arrays dscore=0 |>\nYou could do:\n<code>\ndigits = [1,2,3,4,5,6,7,8,9,0]\n\
    digits.\n  sort.\n  reverse.\n  map. { |e| e == 10 ? 'Nine' : \"#{by_digit[e]}\"\
    \ }\n  # => [\"Nine\", \"Five\", \"Four\", \"Three\", \"Two\", \"One\", \"One\"\
    ]\n</code>\n<|/ a |>\n<| c |>\nThe OP said \"reverse\" the array. Although I like\
    \ `map { ... }.reverse`.\n<|/ c |>\n<| c |>\n`by_digit` is unrelated to `digits`.\n\
    <|/ c |>\n<| a tags=ruby,algorithm,arrays |>\nYou can do it in one line:\n<code>\n\
    arr.sort.reverse.each_with_object([]) { |e, a| a << by_digit[e] }\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\n`reverse` on the enumerator returned by `sort` makes\
    \ no sense.\n<|/ c |>\n<| c |>\nI know. Sorry for that.\n<|/ c |>\n<| a |>\nIn\
    \ Ruby 1.8.7 you can use Enumerable#chunk:\n<code>\nby_digit = [1, 2, 3, 4, 5,\
    \ 6, 7, 8, 0, 10]\narr = [10, 1, 4, 2, 5, 6, 3, 7, 8, 9]", "  arr.each_with_index\
    \ do |n, i| \n    if n >= 1 && n <= 9 \n      arr[i] = \"#{n}\"\n    end\n  end\n\
    \  arr.reverse.compact.join(\"\")\nend\n</code>\n<|/ a |>\n<| c |>\nThe solution\
    \ that uses `each_with_object` instead of `each_with_index` is the better of the\
    \ solutions, as it's more readable (although it doesn't work correctly in the\
    \ given example).\n<|/ c |>\n<| a tags=sorting,arrays,ruby |>\n<code>\na = ['One',\
    \ 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\na.sort_by\
    \ { |v| v.to_i }.reverse\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI wonder why you\
    \ got the -1. That's not a bad solution, IMHO.\n<|/ c |>\n<| c |>\n`sort_by` takes\
    \ a block so this solution will fail if `a` is empty.\n<|/ c |>\n<| c |>\nI agree\
    \ with the -1. Not a bad solution at all. Not sure why it was voted down.\n<|/\
    \ c |>\n<| c |>\nThis is not the best solution - `sort_by` will sort the array\
    \ by value, not by index.\n<|/ c |>\n<| c |>\nWhy not use `sort_by!` instead of\
    \ `sort`?\n<|/ c |>\n<| a tags=sorting,arrays,ruby |>\nI assume that you want\
    \ to sort your array in descending order from largest to smallest. Here's how\
    \ you can do it:\n<code>\na = [2, 1, 1, 4, 5, 8, 2, 3]\na.sort.reverse", "  return\
    \ arr if arr.empty? or arr.length == 1 || (arr.length == 2 && arr.uniq.length\
    \ == 1) else arr.select do |x|\n    if x >= 1 && x <= 9\n      x.to_s\n    else\n\
    \      x = x.to_i\n      x = 1 if x < 0\n      ones = x.to_s.count('1')\n    \
    \  tens = x.to_s.count('10')\n      if tens == 0\n        ones == 0 ? 0 : ones\
    \ + 10\n      elsif tens > 0\n        tens\n      else\n        ones\n      end\n\
    \    end\n  end.reverse.map{|x| ones[x - 1]}\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays\
    \ dscore=4 |>\n<| c |>\nVery nice. Could you explain the `if x > 0 && x <= 9`?\
    \ It would be helpful for the other people who come across this answer. Thanks.\n\
    <|/ c |>\n<| c |>\nI added some explanation. Hope it helps.\n<|/ c |>\n<| c |>\n\
    : Thanks for the explanation. :)\n<|/ c |>\n<| a tags=ruby,algorithm,arrays |>\n\
    <code>", "  arr = (arr.sort{|a,b| b if b && a}.reverse)\n  arr.map do |i| \n \
    \   begin\n      name =  'One' if i == 1\n      name =  'Two' if i == 2\n    \
    \  name =  'Three' if i == 3\n      name =  'Four' if i == 4\n      name =  'Five'\
    \ if i == 5\n      name =  'Six' if i == 6\n      name =  'Seven' if i == 7\n\
    \      name =  'Eight' if i == 8\n      name =  'Nine' if i == 9\n      name\n\
    \    rescue \n      nil\n    end\n  end\nend", "    arr.sort { |a, b| a <=> b\
    \ }\n    return [] if arr.empty?\n    reverse(arr)\n    arr.each { |i| arr[i]\
    \ = lookup(arr[i]) }\n    return arr\nend", "  arr.each do |x|\n    next if x\
    \ == -1\n    if x >= 1 && x <= 9\n      arr.reverse!\n      arr[x - 1] = \"One\"\
    \n      arr[x - 2] = \"Two\"\n      arr[x - 3] = \"Three\"\n      arr[x - 4] =\
    \ \"Four\"\n      arr[x - 5] = \"Five\"\n      arr[x - 6] = \"Six\"\n      arr[x\
    \ - 7] = \"Seven\"\n      arr[x - 8] = \"Eight\"\n      arr[x - 9] = \"Nine\"\n\
    \    end\n  end\n  return arr\nend\n</code>\n<|/ a |>\n<| c |>\nYour solution\
    \ is very clever and I like it but I think there must be a simpler solution in\
    \ Ruby that does this in a single line. Also, I think that OP wanted to replace\
    \ each digit by the word from 1 to 9, not \"1\", \"2\", \"3\".\n<|/ c |>\n<| c\
    \ |>\nI agree with you, my solution is very clever. I just realized that I used\
    \ the wrong word \"replace\" in the title. It should be \"map\". So I modified\
    \ my answer to use map. I believe that is what OP wants. And I believe there is\
    \ a simpler solution, by combining the two loops with some clever use of the map\
    \ method.\n<|/ c |>\n<| c |>\nI agree with you, but I think it's actually a little\
    \ too clever. It's not clear to me from the OP what OP is trying to achieve. The\
    \ \"clever\" part is probably that OP seems to want to use the same block of code\
    \ for each number.\n<|/ c |>\n<| c |>\nThank you for the answer, I guess I missed\
    \ the possibility to use the same block so I edited your post to make it clearer.\
    \ The solution by Tin Man is much more simpler so I decided to go with his. It\
    \ was a nice exercise to learn a bit of Ruby syntax and to learn how it works!\n\
    <|/ c |>\n<| a dscore=1 |>\nHere is another solution:\n<code>", "  arr.each do\
    \ |x|\n    if x > 9\n      arr.reject!{ |y| y > x }\n    end\n  end\n  arr.each\
    \ do |x|\n    arr[x] = arr[x].to_s.reverse.split(\"\").map { |y| y.upcase }.join\n\
    \  end\nend", "  return [] if arr.empty? || arr.any? { |e| e.to_i != e }\n  arr.reverse_each\
    \ { |e| e.to_s == '1' ? e = 'One' : e = 'Two' }\n  arr.reverse_each { |e| e.to_s\
    \ == '2' ? e = 'Two' : e = 'Three' }\n  arr.reverse_each { |e| e.to_s == '3' ?\
    \ e = 'Three' : e = 'Four' }\n  arr.reverse_each { |e| e.to_s == '4' ? e = 'Four'\
    \ : e = 'Five' }\n  arr.reverse_each { |e| e.to_s == '5' ? e = 'Five' : e = 'Six'\
    \ }\n  arr.reverse_each { |e| e.to_s == '6' ? e = 'Six' : e = 'Seven' }\n  arr.reverse_each\
    \ { |e| e.to_s == '7' ? e = 'Seven' : e = 'Eight' }\n  arr.reverse_each { |e|\
    \ e.to_s == '8' ? e = 'Eight' : e = 'Nine' }\n  arr.reverse_each { |e| e.to_s\
    \ == '9' ? e = 'Nine' : e = 'One' }\n  arr\nend", "  arr.sort\n  arr.compact.map!\
    \ { |x| x.to_s.reverse }\n  if arr.empty?\n    arr\n  elsif arr.include?(1)\n\
    \    arr.first\n  elsif arr.include?(-1)\n    arr.last\n  else\n    arr\n  end\n\
    end", "    return arr.sort { |a,b| b.length <=> a.length } unless arr.empty?\n\
    \    return [] if arr.any?(&:strange?)\n    arr.reverse\n    arr.map { |n| n.to_s.tr(\"\
    0123456789\", \"OneTwoThreeFourFiveSixSevenEightNine\") }\nend", "  return arr\
    \ if arr.length > 0 else arr.reverse.map { |el| el < 10 ? \"One\"\n  el < 100\
    \ ? \"Two\" : el < 1000 ? \"Three\" : \"Four\"\n  el < 10000 ? \"Five\" : \"Six\"\
    \n  el < 100000 ? \"Seven\" : \"Eight\"\n  el < 1000000 ? \"Nine\" : \"One\" }\n\
    end", "\tnums = []\n\tarr.each { |x| \n\t\tnums << x if x % 10 == 1\n\t\tnums\
    \ << x if x % 10 == 2 \n\t\tnums << x if x % 10 == 3 \n\t\tnums << x if x % 10\
    \ == 4 \n\t\tnums << x if x % 10 == 5 \n\t\tnums << x if x % 10 == 6 \n\t\tnums\
    \ << x if x % 10 == 7 \n\t\tnums << x if x % 10 == 8 \n\t\tnums << x if x % 10\
    \ == 9 \n\t}\n\tnums.reverse!\n\tnums.map { |x| nums.index(x) + 1 }.map { |x|\
    \ \n\t\tnums[(x+11)%11] \n\t}.compact!.map { |x| \n\t\t\"One\" if x == 1 \n\t\t\
    \"Two\" if x == 2 \n\t\t\"Three\" if x == 3 \n\t\t\"Four\" if x == 4 \n\t\t\"\
    Five\" if x == 5 \n\t\t\"Six\" if x == 6 \n\t\t\"Seven\" if x == 7 \n\t\t\"Eight\"\
    \ if x == 8 \n\t\t\"Nine\" if x == 9 \n\t}\nend", "  # write your code here\n\
    \  arr.sort {|a,b| b - a }.reverse\n  arr = arr.map {|x| get_name(x + 1) }\n \
    \ return arr if arr.size > 0\nend", "  arr.each do |num|\n    arr = num.to_s.chars.reverse.map\
    \ {|c| one_name if c == num.to_s.to_i}\n    return arr\n  end\nend", "  return\
    \ if arr.empty?\n  arr = arr.sort\n  arr.each_index do |i|\n    arr[i] = \"One\"\
    \ if i != 0 && i != arr.size - 1\n    arr[i] = \"Two\" if i != 1 && i != arr.size\
    \ - 1\n    arr[i] = \"Three\" if i != 2 && i != arr.size - 1\n    arr[i] = \"\
    Four\" if i != 3 && i != arr.size - 1\n    arr[i] = \"Five\" if i != 4 && i !=\
    \ arr.size - 1\n    arr[i] = \"Six\" if i != 5 && i != arr.size - 1\n    arr[i]\
    \ = \"Seven\" if i != 6 && i != arr.size - 1\n    arr[i] = \"Eight\" if i != 7\
    \ && i != arr.size - 1\n    arr[i] = \"Nine\" if i != 8 && i != arr.size - 1\n\
    \  end\n  arr.reverse\n  arr.each { |d| d.gsub!(\"1\", 1).gsub!(\"2\", 2).gsub!(\"\
    3\", 3).gsub!(\"4\", 4).gsub!(\"5\", 5).gsub!(\"6\", 6).gsub!(\"7\", 7).gsub!(\"\
    8\", 8) }\nend", "  # check empty array\n  if arr.length == 0\n    return arr\n\
    \  # get length\n  length = arr.length\n  # reverse the array\n  arr.each do |number|\n\
    \    number.to_s.reverse!\n  end\n  # reverse the number\n  arr.reverse!\n  #\
    \ replace each number with its name\n  arr.map do |number|\n    num = number.to_i\n\
    \    str = case num\n      when 1\n        'One'\n      when 2\n        'Two'\n\
    \      when 3\n        'Three'\n      when 4\n        'Four'\n      when 5\n \
    \       'Five'\n      when 6\n        'Six'\n      when 7\n        'Seven'\n \
    \     when 8\n        'Eight'\n      when 9\n        'Nine'\n    end\n    num.to_s.reverse!\n\
    \    str\n  end\nend", "  return arr.reverse.collect { |a| a.to_s.include?('1')\
    \ ? 'One' : a.to_s.include?('2') ? 'Two' : a.to_s.include?('3') ? 'Three' : a.to_s.include?('4')\
    \ ? 'Four' : a.to_s.include?('5') ? 'Five' : a.to_s.include?('6') ? 'Six' : a.to_s.include?('7')\
    \ ? 'Seven' : a.to_s.include?('8') ? 'Eight' : a.to_s.include?('9') ? 'Nine' :\
    \ nil }.compact\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "  return\
    \ [] if arr.empty? or arr.any? {|x| x % 1 > 0} or arr.any? {|x| x < 9} \n  result\
    \ = []\n  arr.each do |x|\n    result << ((1..9).include?(x) ? names[x] : \"#{names[x]}s\"\
    )\n  end\n  result.reverse\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nThe \"\
    elegant way\" is to get all numbers in the array that are not 1, -1, or 9. Then\
    \ get all numbers in the array that are less than 9.\n<code>\nnums = [2, 1, 1,\
    \ 4, 5, 8, 2, 3]\n[nums.select{|x| (x < 9) || (x > 1 && x < 9)}.sort.reverse,\
    \ nums.select{|x| x < 9}].compact\n=> [\"Eight\", \"Five\", \"Four\", \"Three\"\
    , \"Two\", \"Two\", \"One\", \"One\"]\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ dscore=0 |>\n<code>", "  return arr.sort { |a,b| a.length <=> b.length }.\n\
    \            sort { |a,b| a <=> b }.\n            map { |n| case n % 10 when 1\
    \ then \"One\" when 2 then \"Two\" when 3 then \"Three\" when 4 then \"Four\"\
    \ when 5 then \"Five\" when 6 then \"Six\" when 7 then \"Seven\" when 8 then \"\
    Eight\" when 9 then \"Nine\" else n end }.\n            map(&:to_s).\n       \
    \     compact\nend", "    return arr if arr.any? && arr.length > 1 && arr.size\
    \ <= 10 && arr.all? { |n| n > 0 && n < 10 } ? arr.sort_by { |n| n.to_s.length\
    \ }.reverse : []\nend\n</code>\n<|/ a |>\n<| c |>\nThe problem is that the question\
    \ states `\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"`, but in your example you've switched to `[\"Two\", \"One\"\
    , \"One\"]`.\n<|/ c |>\n<| c |>\n, thanks for catching that. I've fixed it.\n\
    <|/ c |>\n<| c |>\nI like how this answers the OP's original question and also\
    \ the OP's latest edit, the OP's original question before I started editing, which\
    \ is now the OP's latest edit. This is the best answer by far. Nice job :)\n<|/\
    \ c |>\n<| c |>\n, thanks for the feedback, it's always appreciated. I didn't\
    \ want to edit anything else while I was writing this answer as it could change\
    \ what the OP is actually looking for.\n<|/ c |>\n<| c |>\nNice answer, and nicely\
    \ presented. I like how it uses Enumerable#sort :)\n<|/ c |>\n<| a tags=ruby |>\n\
    Here's another solution that doesn't require any additional classes and uses Enumerable#sort:\n\
    <code>", "  arr = [Integer(el) for el in arr]\n  arr.sort!\n  arr.sort_by { |el|\
    \ el.length }.reverse!\n  arr.map { |el| el.name.split(\"_\")[0] }\nend\n</code>\n\
    <|/ a tags=algorithm,ruby |>\n<| c |>\nI agree that yours is probably a lot less\
    \ confusing than the others. However I think it may need some more explanation.\
    \ For example, how does `sort!` and `sort_by!` work? Why do we need `reverse!`?\
    \ It looks like you're using `sort_by` twice - once to sort by length and once\
    \ to sort the resulting array.\n<|/ c |>\n<| c |>\n`sort!` sorts in-place. `sort_by`\
    \ sorts by a key which can be any ruby expression. `sort_by!` modifies the array\
    \ while sorting it but returns `nil` when it is done. `reverse!` reverses the\
    \ array and modifies the array.\n<|/ c |>\n<| c |>\nI edited the original answer\
    \ with a few more comments. Let me know if you have any more questions.\n<|/ c\
    \ |>\n<| c |>\nThis code does something different from the other answers. For\
    \ example, why doesn't `by_length([2, 1, 1, 4, 5, 8, 2, 3])` return `[\"One\"\
    , \"One\", \"Two\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    ]`? The algorithm seems incorrect to me. `by_length([2, 1, 4, 5, 8, 2, 3])` returns\
    \ `[\"One\", \"Two\", \"Two\", \"One\", \"One\", \"One\", \"One\"]`.\n<|/ c |>\n\
    <| c |>\nI agree with, the output `[\"One\", \"One\", \"Two\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"]` does look wrong to me. I'm guessing\
    \ that the author of that answer wanted to show that `[2, 1, 4, 5, 8, 2, 3]` returns\
    \ `[\"One\", \"Two\", \"Two\", \"One\", \"One\", \"One\", \"One\"]`. The output\
    \ `[\"One\", \"One\", \"Two\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\"]` is correct to me.\n<|/ c |>\n<| a tags=algorithm,ruby dscore=3 |>\n\
    For a general case (to handle arbitrary orders), you may do as follows:\n<code>",
  "  arr.each do |num|\n    if num > 9\n      arr.delete(num)\n    end\n  end\n  arr.empty?\
    \ ? [] : arr.each do |num|\n    arr = [num, \"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][num-1]\n  end\n  arr\nend",
  "  return arr.reverse.each_with_index.reject { |x,i| i <1 }.map { |x,i| i <2 ? x.to_s.capitalize\
    \ : x.to_s }.compact\nend", "  return arr.reverse.map { |n| [\"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][n %\
    \ 10] } if arr.any?\n  arr.map { |n| [\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"][n % 10] } if arr.any?\nend",
  "  result = Array.new\n  return result if arr.length == 0\n  arr.each do |x|\n \
    \   index = x % 10\n    index += 1\n    if index <= 9\n      result.push names[index]\n\
    \    else\n      result.push index\n    end\n  end\n  result.reverse\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nYou can try this solution\n<code>", "  return [] if\
    \ arr.empty? || arr.any? { |x| x < 1 || x > 9 } || arr.size < 1 \n  arr.sort\n\
    \  arr.reverse\n  arr.each { |x| arr[x] = names[x] if x <= 9 }\n  arr\nend\nputs\
    \ \"ByLength: #{by_length([2, 1, 1, 4, 5, 8, 2, 3])}\"\nputs \"ByLength: #{by_length([1,\
    \ -1 , 55])}\"\nputs \"ByLength: #{by_length([-1, 0, 0])}\"\nputs \"ByLength:\
    \ #{by_length([0, 0])}\"\nputs \"ByLength: #{by_length([])}\"\nputs \"ByLength:\
    \ #{by_length([0])}\"\nputs \"ByLength: #{by_length([-9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,\
    \ -9, -9, -9, -9, -9, -", "  arr = arr.sort\n  arr.each do |i|\n    if i.to_i\
    \ > 0\n      arr.reverse!\n      i.to_s.upcase + arr\n    end\n  end\n  arr.join\n\
    end", "  return arr.reverse.map do |val|\n    if val >= 0 && val <= 9\n      \"\
    #{val}\" \n    else\n      val \n    end\n  end.reject(&:empty?).compact\nend",
  "  arr.flatten!\n  arr.sort! { |x, y| y <=> x }\n  arr.compact!", "  # Your code\
    \ here\n  return [] if arr.size == 0 else arr.sort_by{|i| i.to_s.chars.map{|x|\
    \ x.upcase}.sort.reverse}.map{|i| [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\"][i.to_s]}\nend", "  if arr.length\
    \ == 0\n    []\n  elsif arr.length == 1\n    arr[0]\n  else\n    sorted_array\
    \ = arr.sort\n    digits_to_name = [\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    \n    temp = sorted_array[0]\n\
    \    sorted_array.shift\n    results = []\n    while sorted_array.length > 0\n\
    \      temp_array = []\n      count = 0\n      \n      while count < sorted_array.length\n\
    \        temp_array.push(sorted_array[count])\n        count += 1\n      \n  \
    \    while temp_array.length > 0\n        temp = temp_array.shift\n        results.unshift(digits_to_name[temp])\n\
    \      end\n    end\n    \n    results\n  end\nend", "  arr.sort {|a, b| b - a}.reverse.map\
    \ {|i| DIGITS[i]}\nend", "  return [] if arr.empty? or arr.all? { |e| e.is_a?(Fixnum)\
    \ }\n  arr.sort_by { |e| -e.length }.map { |e| e.digits.reverse }.flatten.map\
    \ do |e|\n    case e\n    when 1\n      \"One\"\n    when 2\n      \"Two\"\n \
    \   when 3\n      \"Three\"\n    when 4\n      \"Four\"\n    when 5\n      \"\
    Five\"\n    when 6\n      \"Six\"\n    when 7\n      \"Seven\"\n    when 8\n \
    \     \"Eight\"\n    when 9\n      \"Nine\"\n    else raise \"strange number\"\
    \n    end\n  end\nend", "  result = arr.map(&:to_s).sort # Sort ascending\n  result.empty?\
    \ ? [] : result.reverse.map do |number|\n    number = number.to_i\n    numbers\
    \ = Array.new(number/10, \"\") + \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    numbers[number%10]\n  end\nend",
  "    arr.each do |i|\n        len = arr[i].to_s.length\n        if len < 4 && len\
    \ > 0\n            arr.delete(i)\n        end\n    end\n    arr\nend", '    arr.sort!',
  "  # Check validity\n  if arr.size != 0\n    # Convert to array\n    arr = arr.to_a\n\
    \    # Return array if all elements between 0 and 9\n    if arr.all? { |i| i >=\
    \ 1 && i <= 9 }\n      result = []\n      arr.each do |i|\n        result += [\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"]\n      end\n      # Reverse array\n      result.reverse!\n      #\
    \ Replace each element by its corresponding name from One...Nine\n      result.reverse!.zip(result).map\
    \ { |k, v| v[0] }\n    else\n      []\n    end\n  else\n    []\n  end\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>\na = ['One', 'Two', 'Three', 'Four',\
    \ 'Five', 'Six', 'Seven', 'Eight', 'Nine']\nb = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\
    c = a.zip b\nc.map{|e| e[1]} + c[9..-1].map{|e| e[0]}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`c[0]` should be `c[1]` and your `c.zip` should be `c.to_a.zip`\
    \ since `a` and `b` are arrays.\n<|/ c |>\n<| c |>\nGood catch! Thanks!\n<|/ c\
    \ |>\n<| a tags=ruby |>\nHere is a nice way: \n<code>\n a = [1, 3, 5, 7, 9]\n\
    \ b = [2, 3, 5, 7, 8]\n c = a.zip(b).map { |e| e[0] }\n c[9..-1].map{|e| e}\n\
    \ => [[\"Nine\", \"Four\", \"Three\", \"Two\"], [\"Five\", \"Six\", \"Seven\"\
    ], [\"One\"]]\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\nHere's another approach:\n\
    <code>", "  # write code here\n  arr.select{|x| x>0 && x < 10}.sort.reverse.each_with_index\
    \ {|num, i| arr[i]=names[num]} \nend\n</code>\n<|/ a |>\n<| c |>\n`by_length([1,\
    \ -1, 55])` returns `['One']`\n<|/ c |>\n<| c |>\nHmm, what are you saying? It\
    \ works for me on ruby 2.0.0p247.\n<|/ c |>\n<| c |>\nRuby 1.8.7 (2010-01-10 patchlevel\
    \ 249) [x86_64-darwin10.8.0]\n<|/ c |>\n<| c |>\nAh okay, I didn't know ruby 1.8\
    \ has that strange behaviour when passing arguments to the block. Thanks for the\
    \ explanation!\n<|/ c |>\n<| a |>\n<code>", "  arr.sort do |a, b|\n    a <=> b\n\
    \  end\n  arr.map { |num|\n    num > 9 ? num.to_s.reverse : \"One\" if num ==\
    \ 1 else num.to_s\n  }\nend", "  return [] if arr.empty? || arr.any? { |x| x >\
    \ 9 || x < 1 } || arr.any? { |x| x.zero? } \n  digits = arr.map { |x| x.to_s }\n\
    \  digits.reverse!\n  digits.map { |x| names[x] || x }.join\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nWhat is `arr` in your code? Where did you define it?\n<|/ c |>\n\
    <| c |>\nIn fact, it seems that it is not a Ruby array, so I changed the answer.\
    \ Sorry for confusion.\n<|/ c |>\n<| c |>\nThanks! It was a little bit more complicated,\
    \ but thanks for your solution!\n<|/ c |>\n<| a tags=string,arrays,ruby,hash dscore=1\
    \ |>\n<code>\nnames=%w(One Two Three Four Five Six Seven Eight Nine)", "  arr.each\
    \ do |x| \n    x = x.to_s # convert int to str\n    arr.reverse!\n    arr.reverse!\n\
    \    arr.each { |x| \n      if x > 9 \n        arr.delete(x)\n      else \n  \
    \      x.gsub!('0', 'One')\n        x.gsub!('1', 'Two')\n        x.gsub!('2',\
    \ 'Three')\n        x.gsub!('3', 'Four')\n        x.gsub!('4', 'Five')\n     \
    \   x.gsub!('5', 'Six')\n        x.gsub!('6', 'Seven')\n        x.gsub!('7', 'Eight')\n\
    \        x.gsub!('8', 'Nine')\n      end \n    }\n  end\n  arr\nend", "  return\
    \ arr.sort { |a, b| a.to_i < b.to_i ? -1 : a.to_i > b.to_i ? 1 : 0 }.map(&:to_s)\n\
    end\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| a dscore=2 tags=ruby |>\nThe other\
    \ answers are ok, but I like the following more:\n<code>", "  arr.each do |item|\n\
    \    if item > 9\n      arr[item] = item[0].to_i + item[1].to_s\n    end\n  end\n\
    \  arr.sort!.reverse!\n  arr.map {|item| \n    if item == -1\n      \"One\"\n\
    \    elsif item == 1\n      \"Two\"\n    elsif item == 2\n      \"Three\"\n  \
    \  elsif item == 3\n      \"Four\"\n    elsif item == 4\n      \"Five\"\n    elsif\
    \ item == 5\n      \"Six\"\n    elsif item == 6\n      \"Seven\"\n    elsif item\
    \ == 7\n      \"Eight\"\n    elsif item == 8\n      \"Nine\"\n    else\n     \
    \ \"One\"\n    end\n  }\nend", "  arr.map!(&:to_s) if arr.is_a?(Array) \n  arr.map!\
    \ { |x| x != -1 and x % 10 == 0 ? 'One' : \n      x % 10 == 1 ? 'Two' : (x % 10\
    \ == 2 ? 'Three' : 'Four') }\n  arr.reverse \n  arr.map { |x| x.to_s[1..-1] }\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis is nice but it returns `['One', 'One']`\
    \ if `[2,3,4]` is passed to the method.\n<|/ c |>\n<| c |>\nThat is true. I've\
    \ added a conditional to handle that case.\n<|/ c |>\n<| c |>\nI'm pretty sure\
    \ it returns `['Four']` if `[2,3,4]` is passed to the method.\n<|/ c |>\n<| c\
    \ |>\nThat's correct. I've edited my answer to reflect the additional requirement\
    \ that an empty array be returned if there are no numbers between 1 and 9 inclusive.\n\
    <|/ c |>\n<| a |>\n<code>", "  new_arr = arr.dup\n  arr.each do |i|\n    i = i.to_i\n\
    \    i = i if i >= 1 && i <= 9\n    new_arr.delete_at(i) if new_arr.include?(i)\n\
    \  end\n  if new_arr.size == 0\n    return new_arr\n  elsif new_arr.size != arr.size\n\
    \    puts \"Sorry, I could not reverse the given array\"\n    return []\n  end\n\
    \  new_arr.each do |i|\n    i = i.to_s\n    i = i.reverse\n    new_arr.delete_at(i)\
    \ if new_arr.include?(i)\n  end\n  return new_arr\nend", "  arr.sort!\n  arr.each\
    \ do |i|\n    if i > 9\n      arr[i] = \"#{arr[i]}nine\"\n    end\n    if i >\
    \ 7\n      arr[i] = \"#{arr[i]}seven\"\n    end\n    if i > 5\n      arr[i] =\
    \ \"#{arr[i]}five\"\n    end\n    if i > 4\n      arr[i] = \"#{arr[i]}four\"\n\
    \    end\n    if i > 3\n      arr[i] = \"#{arr[i]}three\"\n    end\n    if i >\
    \ 2\n      arr[i] = \"#{arr[i]}two\"\n    end\n    if i > 1\n      arr[i] = \"\
    #{arr[i]}one\"\n    end\n  end\n  arr\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thanks, I understand your code, but what is the purpose of the \"puts arr\" line?\
    \  It seems to me that your method works just fine without it, right?\n<|/ c |>\n\
    <| c |>\nThe purpose of the puts is to show the results of each pass in the method\
    \ as a way to see what it is doing.  It would probably make more sense to return\
    \ an array rather than print to the screen but that is what I have done here.\n\
    <|/ c |>\n<| a dscore=0 |>\nTry this simple one-liner:\n<code>\n[1,2,3,4,5,6,7,8,9].sort_by\
    \ { |n| n.to_s.split(\"\").reverse.map { |e| e.to_s } }\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\nA recursive solution:\n<code>", "  return arr if arr.length==0\
    \ || (arr.length==1 && arr.last==1) || arr.uniq.sort.reverse.to_a.map {|x| by_name(x)\
    \ }\nend", "    arr.sort!\n    arr.map! {|x| if x != 1 then x = \"One\" else x\
    \ = \"Two\" end}\n    arr.compact!\n    arr.compact!\n    arr.reverse \n    arr.map!\
    \ {|x| x.to_s}\n    return arr\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<|\
    \ a tags=ruby dscore=1 |>\n<code>\narr = [2, 1, 1, 4, 5, 8, 2, 3]", "  if arr.length\
    \ == 0 \n    []\n  else\n    arr = arr.sort { |a, b| b - a}.reverse\n    arr.map\
    \ {|x| to_name(x + 1)}\n  end\nend", "  if arr.empty?\n    []\n  elsif arr.any?\
    \ {|x| x > 100 || x < 1}\n    arr\n  else\n    reverse = arr.reverse\n    first\
    \ = reverse.first\n    reverse.map {|i| first[i - 1]}\n  end\nend", "  if arr.length\
    \ == 0\n    arr\n  elsif arr.length < 1\n    []\n  elsif arr.length < 9\n    arr.take(arr.length).reverse\n\
    \  else\n    by_length(arr[0...9]).reverse + arr.take(arr.length).reverse.to_a\n\
    \  end\nend", '  return [] if arr.empty? or arr.include?(-1) or arr.include?(0)
    or arr.include?(9) or arr.include?("One") or arr.include?("Two") or arr.include?("Three")
    or arr.include?("Four") or arr.include?("Five") or arr.include?("Six") or arr.include?("Seven")
    or arr.include?("Eight") or arr.include?("Nine") || arr.size == 0 ', "  res =\
    \ []\n  arr.each do |i|\n    if i.between?(1, 9)\n      res.push(by_length([i-1])\
    \ + [by_digit(i)].join)\n    else\n      res << by_digit(i)\n    end\n  end\n\
    \  res\nend", "  return arr unless arr.size > 0\n  if arr.size < 2 \n    arr\n\
    \  else\n    arr.sort {|a,b| a.to_i <=> b.to_i}.\n        map {|x| arr.reverse.index\
    \ x.to_s }.\n        map {|x| arr.reverse.delete x.to_s}\n  end\nend", "  arr.sort!\n\
    \  arr.shift!\n  arr.reverse!\n  return arr.reject(&:zero?).map {|i| i.to_s +\
    \ name.to_s }\nend\n</code>\nThis works for integers greater than 999, but for\
    \ numbers that aren't the case I decided just to put it in as another option.\n\
    <|/ a dscore=1 |>\n<| c |>\nWhat happened to the \"One\" string?\n<|/ c |>\n<|\
    \ c |>\nI left it there to show how to add another option and then remove it when\
    \ needed.\n<|/ c |>\n<| c |>\nI'm a little confused at what you are trying to\
    \ accomplish. Could you post the expected output for those numbers?\n<|/ c |>\n\
    <| c |>\nThat array is exactly what the OP wants to get back. Think of it like\
    \ \"One\" being an abbreviation for a person's first name. For each number between\
    \ 1 and 9, it's either the integer itself, or the number with the corresponding\
    \ name, e.g. \"One\" is always \"One\".\n<|/ c |>\n<| c |>\nThis is not what the\
    \ OP is looking for.  He wants a string \"One\" instead of an integer 1.\n<|/\
    \ c |>\n<| a tags=sorting,arrays,ruby,ruby-on-rails |>\nHere's my take.  It isn't\
    \ pretty, but it works:\n<code>\narr = [2, 1, 1, 4, 5, 8, 2, 3]\narr.sort!\narr.shift!\n\
    arr.reverse!\narr.map { |n| n.to_s + name.to_s }\n</code>\nOutput:\n<code>\n[\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't produce the desired result.\
    \ As noted in the question, the array is always one element long, so the last\
    \ two statements will always throw an error.\n<|/ c |>\n<| c |>\nYeah, I got caught\
    \ up with the array lengths.  I deleted that code before I posted my answer. \
    \ I updated the answer to accommodate that.\n<|/ c |>\n<| c |>\nI figured that's\
    \ what you meant, but thought I'd point it out to you.\n<|/ c |>\n<| c |>\nThis\
    \ is not what the OP is looking for. He wants a string \"One\" instead of an integer\
    \ 1.\n<|/ c |>\n<| a dscore=0 tags=sorting,arrays,ruby,ruby-on-rails |>\nJust ",
  "    arr.each do |num|\n        if num < 1\n            puts \"Error: cannot sort\
    \ the array because it has strange number #{num}\"\n        elsif num > 9\n  \
    \          puts \"Error: cannot sort the array because it has strange number #{num}\"\
    \n        else\n            arr.reverse # reverse the array\n            arr.each\
    \ { |i| arr[i] = \"One\" if i % 10 == 1, \"Two\" if i % 10 == 2, \"Three\" if\
    \ i % 10 == 3, \"Four\" if i % 10 == 4,\n             \"Five\" if i % 10 == 5,\"\
    Six\" if i % 10 == 6,\"Seven\" if i % 10 == 7,\"Eight\" if i % 10 == 8,\"Nine\"\
    \ if i % 10 == 9 }\n        end\n    end\n    arr\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\nA recursive approach works pretty well:\n<code>", "  if\
    \ arr.length > 0\n    sorted_array = []\n    # put all the numbers in one array\
    \ first\n    sorted_array << arr[0]\n    arr.shift", "  arr.each do |num|\n  \
    \  break if num > 9\n    break unless num == 1\n    num.downto(0).each { |num|\
    \ break if num > 9; num.downto(0) }\n  end\n  if arr.empty? || arr.any?(&:odd?)\n\
    \    []\n  else\n    arr.reverse.map { |x| names.sample(x) }\n  end\nend", " \
    \ return arr.sort_by {|i| [i - 1, i] }.reverse unless arr.empty? || arr.any? {\
    \ |i| i.odd? }\n  arr = [ \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\" ]\n  arr.sort { |a,b| a.to_i < b.to_i ?\
    \ 1 : -1 }.reverse\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI like to keep it\
    \ simple and use inject:\n<code>", "  return arr.reverse if arr.length > 0 and\
    \ arr.first.is_a?(Integer) \n  arr = [*arr].compact\n  if arr.empty?\n    []\n\
    \  elsif arr.any? &~ Integer(1)..Integer(9)\n    arr\n  else\n    arr.map do |n|\
    \ \n      \"One\"..\"Nine\".include?(n.to_s) ? n : \"#{n} Ohs\"\n    end.reverse\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,algorithm dscore=1 |>\n<| a dscore=1 |>\n\
    Here you go:\n<code>", "  case arr.length\n    when 0\n      []\n    when 1\n\
    \      arr[0].to_s\n    when 2\n      arr[1].to_s + \", \" + arr[0].to_s\n   \
    \ when 3\n      arr[2].to_s + \", \" + arr[1].to_s + \" and \" + arr[0].to_s\n\
    \    when 4\n      \"#{arr[0]}, #{arr[1]} and #{arr[2]}\"\n    when 5\n      \"\
    #{arr[0]}, #{arr[1]}, #{arr[2]} and #{arr[3]}\"\n    when 6\n      \"#{arr[0]},\
    \ #{arr[1]}, #{arr[2]}, #{arr[3]} and #{arr[4]}\"\n    when 7\n      \"#{arr[0]},\
    \ #{arr[1]}, #{arr[2]}, #{arr[3]}, #{arr[4]} and #{arr[5]}\"\n    when 8\n   \
    \   \"#{arr[0]}, #{arr[1]}, #{arr[2]}, #{arr[3]}, #{arr[4]}, #{arr[5]} and #{arr[6]}\"\
    \n  end\nend", "  result = []\n  arr.each do |n|\n    result << n\n  end\n  result.sort_by\
    \ {|n| -n }.each_with_index do |n, i|\n    result[i] = by_name(i, n)\n  end\n\
    \  result\nend", "  return arr[0..-2].sort {|a, b| arr.length <=> a.length <=>\
    \ b.length }.map {|x| numbers[x.to_i % 10] }\nend", "\tputs arr\n\tarr.each do\
    \ |e|\n\t\tnext if e.class == Fixnum\n\t\tputs \"e class: #{e.class}\"\n\t\tputs\
    \ e.class\n\t\tputs e\n\t\tputs \"-----------\"\n\tend\n\tputs \"-----------\"\
    \n\treturn [] if arr.empty?\n\tputs arr.size\n\tputs \"-----------\"\n\tarr.size.times\
    \ do |i|\n\t\tarr.delete_at(i) if arr[i] < 1 || arr[i] > 9\n\t\tarr.insert(i,\
    \ get_name_by_num(arr[i]))\n\tend\n\tputs arr\n\treturn arr\nend", "\tsorted_arr\
    \ = arr.sort\n\tsorted_arr.reverse!", "  if arr.empty?\n    []\n  else\n    arr\
    \ = arr.sort_by{|x| x.to_i}\n    arr.each_index { |i| arr[i] = by_length_of(arr[i],\
    \ i) }\n    arr\n  end\nend", "  if arr.length == 0 \n    arr\n  elsif arr.length\
    \ > 10\n    arr\n  else\n    arr.sort\n    arr.each do |i|\n      if i > 0\n \
    \       arr[i] = arr[i].to_s\n        arr[i] = name[i - 1]\n      end\n    end\n\
    \    arr\n  end\nend\n</code>\nThen it's just a matter of calling the function\
    \ and passing the numbers to it.\n<code>\nby_length(nums)", "    arr.sort!\n \
    \   (1..9).each {|i| arr[-i] = i.to_s.capitalize}\n    arr.empty? ? [] : arr\n\
    end", "    arr.sort.reverse \n    arr.map!{ |a| One[a] || Two[a] || Three[a] ||\
    \ Four[a] || Five[a] || Six[a] || Seven[a] || Eight[a] || Nine[a] }\n    arr.compact!\n\
    \    return arr\nend\n</code>\n<|/ a |>\n<| c |>\nA lot of `a[n]` calls. Better\
    \ use a hash. Btw, what is the advantage of using `compact` over `reject!`?\n\
    <|/ c |>\n<| c |>\nI believe this is faster than the above solution (which took\
    \ about a minute to execute).\n<|/ c |>\n<| c |>\n: I tested with `timeit` and\
    \ `compact` was indeed faster. Updated the test result.\n<|/ c |>\n<| c |>\n:\
    \ I agree with you that `reject!` should be used more often. The advantage of\
    \ using `compact` instead of `reject!` is that it is more idiomatic.\n<|/ c |>\n\
    <| a tags=sorting,ruby |>\nThis should do it\n<code>", "    arr.each { |num| arr.reverse!\
    \ if num >= 1 && num <= 9 }\n    arr.map { |num| num.to_s.rjust(7, '0') }\nend",
  "  # Your code here\n  arr = [nil, *arr]\n  arr.reverse.map! { |i| names[i] }\n\
    \  arr = [nil, *arr]\n  arr\nend\n</code>\nThis solution has a few advantages\
    \ over using regular expressions. Firstly, it uses Ruby's Array#map method to\
    \ avoid creating a new array. Secondly, it uses Ruby's Array#reverse method to\
    \ avoid needing to sort (which is O(nlogn)). Finally, it uses a simple hash lookup\
    \ to replace the original integers with their names.\n<|/ a |>\n<| a |>\nHere\
    \ is a solution that does not use regular expressions, only a hash. \n<code>",
  "\tarr = arr.sort.reverse\n\tarr.each_with_index { |v,i| arr[i] = \"One\" if i <=\
    \ 9 else arr[i] }\n\tarr\nend", "  arr.sort!\n  arr.each do |i|\n    arr[i] =\
    \ \"One\" if 1 < i && i > 9\n    arr[i] = \"Two\" if 2 > i && i > 9\n    arr[i]\
    \ = \"Three\" if 3 > i && i > 9\n    arr[i] = \"Four\" if 4 > i && i > 9\n   \
    \ arr[i] = \"Five\" if 5 > i && i > 9\n    arr[i] = \"Six\" if 6 > i && i > 9\n\
    \    arr[i] = \"Seven\" if 7 > i && i > 9\n    arr[i] = \"Eight\" if 8 > i &&\
    \ i > 9\n    arr[i] = \"Nine\" if 9 > i && i > 9\n  end\n  arr\nend", "  return\
    \ [] if arr.empty?\n  arr.uniq!\n  arr.sort!.reverse\n  arr.each do |n|\n    if\
    \ n > 9\n      arr[n] = name_by_number(n)\n    end\n  end\n  arr\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThanks a lot, this really helped\n<|/ c |>\n<| c |>\n\
    Thanks, I've changed my answer to include some additional explanations\n<|/ c\
    \ |>\n<| c |>\nThis was a good way to go about it. However, I found that `sort_by`\
    \ is much faster, especially when working with large arrays. [Here's a quick benchmark](https://gist.github.com/saucerma/62759dca51b979fba9fcfcffca1ab1ea).\n\
    <|/ c |>\n<| a tags=arrays,ruby,sorting,string |>\nI really like the previous\
    \ solution given by Eliot, especially because of the name_by_number method.\n\
    However, for ruby 1.8.7 (without map), I think this is more readable:\n<code>",
  "  return [] if arr.empty? or arr.any? { |x| x.is_a?(Integer) } or arr.any? { |x|\
    \ x < 1 or x > 9 } \n  arr.reverse\n  arr.each_with_index do |x,i|\n    arr[i]\
    \ = \"One\" if x == 1\n    arr[i] = \"Two\" if x == 2\n    arr[i] = \"Three\"\
    \ if x == 3\n    arr[i] = \"Four\" if x == 4\n    arr[i] = \"Five\" if x == 5\n\
    \    arr[i] = \"Six\" if x == 6\n    arr[i] = \"Seven\" if x == 7\n    arr[i]\
    \ = \"Eight\" if x == 8\n    arr[i] = \"Nine\" if x == 9\n  end\n  arr\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like it.  This is definitely more efficient.\n\
    <|/ c |>\n<| a dscore=0 |>\nI wrote a little utility that converts numbers to\
    \ strings:\n<code>", "    arr.sort!\n    if arr.empty?\n        []\n    else\n\
    \        arr.map! {|n| n <= 9 ? by_number(n) : n}\n    end\nend\n</code>\nBy sorting\
    \ the array, and then mapping it over each element, we get an array where each\
    \ element is either the original number itself, or the name corresponding to each\
    \ number.\n<|/ a tags=ruby |>\n<| c |>\nYou don't need the `{|n| n <= 9 ? by_number(n)\
    \ : n}`, a simple `.map!` will do the job. Like this, `[1, 2, 3].map! { |n| n\
    \ <= 9 ? by_number(n) : n }`\n<|/ c |>\n<| c |>\nI love Ruby on Rails btw\n<|/\
    \ c |>\n<| a |>\nHere's a solution using a hash to map numbers to names:\n<code>",
  "  return [Integer(Integer(arr.first).between?(1, 9) ? \"One\" : arr.first).reverse\
    \ + Integer(Integer(arr.last).between?(1, 9) ? \"One\" : arr.last).reverse].compact\n\
    end", "  if arr.length > 0\n    arr.sort!\n    arr.map! { |i| [\"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"].map{\
    \ |e| i / 10 ** (e - 1) }[0] }\n    arr.reverse!\n    arr.compact!\n    arr.map!\
    \ { |i| i % 10 }\n    arr\n  else \n    []\n  end\nend", "  arr1 = arr.sort\n\
    \  arr2 = arr1.reverse\n  arr3 = Array.new", "  arr.each do |i|\n    case i\n\
    \    when 1..9\n      arr.push(\"One\")\n    when 10..99\n      arr.push(\"Two\"\
    )\n    when 100..999\n      arr.push(\"Three\")\n    when 1000..9999\n      arr.push(\"\
    Four\")\n    when 10000..999999\n      arr.push(\"Five\")\n    when 1000000..9999999\n\
    \      arr.push(\"Six\")\n    when 100000000..999999999\n      arr.push(\"Seven\"\
    )\n    when 10000000000..9999999999\n      arr.push(\"Eight\")\n    when 100000000000..9999999999999\n\
    \      arr.push(\"Nine\")\n    else\n      arr\n    end\n  end\n  arr\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\n<code>", "    numbers = arr.collect{|x| x == 1 ? 1\
    \ : x}.reverse\n    numbers.collect! {|x| names[x]} if numbers.length\n    numbers\n\
    end", "  return [] if arr.empty? || arr.any? { |i| i.odd? }\n  result = []\n \
    \ arr.each do |i|\n    result << NAMES[i + 1] if i > 9 || i <= 1\n  end\n  result.reverse\n\
    end", "  return arr.reduce([]) do |result, x|\n    if x > 0\n      result << by_number(x/10).reverse\n\
    \      x %= 10\n    end\n    result << by_number(x)\n  end\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| a dscore=2 |>\n<code>", "  arr.each do |el|\n    if el < 1\
    \ || el > 9\n      el\n    else\n      arr[el - 1], arr[el] \n    end\n  end\n\
    end\nputs by_length([1, 2, 1, 1, 4, 5, 8, 2, 3]) \nputs by_length([2, 1, 1, 4,\
    \ 5, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 6, 8, 2, 3]) \nputs by_length([2,\
    \ 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs\
    \ by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 6, 8, 2,\
    \ 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1,\
    \ 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2,\
    \ 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs\
    \ by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8,\
    \ 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1,\
    \ 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2,\
    \ 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs\
    \ by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8,\
    \ 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1,\
    \ 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2,\
    \ 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs\
    \ by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8,\
    \ 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1,\
    \ 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2,\
    \ 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs\
    \ by_length([2, 1, 1, 4, 5, 6, 8, 2, 3]) \nputs by_length", "  arr.empty? || arr.size\
    \ < 3 || arr.first < 1 || arr.first > 9\n  arr.empty? ? [] : arr.map { |x| names[x\
    \ - 1] }.sort.reverse\nend", "  if arr.empty?\n    []\n  else\n    # remove all\
    \ numbers that are not between 1 and 9\n    arr.delete_if {|x| not x.between?\
    \ 1, 9}\n    # reverse the resulting array\n    arr.reverse\n    # replace each\
    \ digit by its corresponding name from \"One\", \"Two\", \"Three\", \"Four\",\
    \ \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\n    arr.map {|x| replace_by_name(x,\
    \ arr)} \n  end\nend", "  return arr unless arr.length == 0\n  arr.sort.reverse.map\
    \ do |number|\n    case number\n    when 0...9\n      by_length.one[number - 1]\n\
    \    when 10...19\n      by_length.ten[number - 10]\n    else\n      by_length.other[number]\n\
    \    end\n  end\nend", "  arr.map do |number|\n    case number\n    when 1..9\n\
    \      One\n    when 10..19\n      Two\n    when 20..39\n      Three\n    when\
    \ 40..59\n      Four\n    when 60..79\n      Five\n    when 80..99\n      Six\n\
    \    when 100.to_i\n      Seven\n    when 1000.to_i\n      Eight\n    when 1000000000.to_i\n\
    \      Nine\n    else\n      number\n    end\n  end.sort { |a, b| b.to_s <=> a.to_s\
    \ }.reverse.map(&:to_s)\nend\n</code>\n<|/ a tags=sorting,ruby dscore=2 |>\n<|\
    \ a dscore=2 tags=sorting,ruby |>\n<code>", "  return arr.reverse.compact.map\
    \ {|x| names[x] || \"#{x}\" }.compact\nend\n</code>\n<|/ a dscore=3 tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  arr.compact.sort!\n  arr.compact!\n\
    \  arr.map { |n| by_digit_name(n).first }\nend\n</code>\n<|/ a |>\n<| c |>\nNice\
    \ solution, although it seems a bit overcomplicated for such a simple thing. I\
    \ think it's more readable with each_with_object instead of map, each_with_object.\n\
    <|/ c |>\n<| c |>\n, I agree. I'm not going to argue with you on that. I'm just\
    \ showing alternatives. This is certainly a more \"functional\" solution, which\
    \ is why I included it at the end. I would consider it even better if you didn't\
    \ use each_with_object, but just use map.\n<|/ c |>\n<| c |>\nYou might want to\
    \ replace `each_with_object` with `inject`. This code will fail if `arr` is empty\n\
    <|/ c |>\n<| c |>\n, good catch. Fixed.\n<|/ c |>\n<| a |>\nI rewrote the array\
    \ using inject as suggested, this seems to be slightly more readable than the\
    \ each_with_object suggestion:\n<code>", "  arr.compact.sort.reverse_each.each.map\
    \ do |e|\n    if e.is_a? Integer\n      num = case e\n        when 1, 9\n    \
    \      e\n        when -1\n          \"One\"\n        else\n          \"Nine\"\
    \n      end\n      num\n    end\n  end.compact\nend", "  if arr.size == 0\n  \
    \  return []\n  arr2 = arr.sort\n  i = 0\n  while i < arr.size\n    if arr[i]\
    \ < 1 || arr[i] > 9\n      arr2.shift i\n      i += 1\n      next\n    end\n \
    \   \n    arr2.shift i\n    arr2.shift i\n    \n    i += 1\n  end\n  return arr2.map{|x|\
    \ x.to_s}\nend", "  arr.to_a.sort{|a,b| a.to_i < b.to_i}.map{|i| i.is_a?(Integer)\
    \ ? names_index[i] : i.to_s}\nend", "  arr.sort { |a,b| a.to_i <=> b.to_i }\n\
    \  return arr.empty? ? [] : arr.map { |x|\n    x.to_i.zero? ? 'One' : \n     \
    \ x == '9' ? \"Nine\" : \n      x.to_s.rjust(2, \"0\").to_i % 10\n  }\nend", " \
    \ # TODO: Implement this\nend", "  result = []\n  arr_length = arr.length\n  arr.each\
    \ do |e|\n    if e > 9\n      if arr_length == 1 || (e < 10 and arr_length ==\
    \ 0)\n        result << 0\n      else\n        result << e\n      end\n    else\n\
    \      if arr_length == 0\n        result << 0\n      else\n        result <<\
    \ e\n      end\n    end\n  end\n  return result\nend", "  arr.sort!\n  return\
    \ arr.reverse.map(&:to_s).reject(&:blank?).map {|i| i.to_i}\nend\n</code>\n<|/\
    \ a dscore=3 tags=sorting,ruby |>\n<| a tags=sorting,ruby |>\n<code>\n[\"1\",\
    \ \"2\", \"3\", \"9\", \"10\", \"12\"].sort!.reverse.map(&:to_s).delete_if { |s|\
    \ s.empty? }.map { |s| s.to_i }", "  # first sort the array \n  sorted_arr = arr.sort\
    \ {|x,y| y <=> x }\n  # reverse the array\n  sorted_arr.reverse\n  # then loop\
    \ through the array and add each item to the result array\n  sorted_arr.each {|item|\
    \ result << NUMBERS[item] }\n  # if the array is empty, return an empty array\n\
    \  return result.empty? ? [] : result\nend", "  arr.sort\n  arr.map! { |x| [\"\
    One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"\
    ].include?(x) ? x : nil } if arr.empty? || arr.any?(&:to_i > 9)\n  arr.compact!\n\
    \  arr.reverse!\n  arr\nend", "  unless arr.size == 0\n    arr.sort.reverse\n\
    \    arr.map {|n| names[n] || \"Invalid\"}.join\n  end\nend\n</code>\n<|/ a |>\n\
    <| a |>\nI think you could try this and let me know if I am missing something\n\
    <code>", "    arr.sort!\n    first = arr.first\n    last = arr.last\n    arr.delete(first)\n\
    \    arr.delete(last)\n    arr.sort_by!{ |x| x <= 9 }.reverse!\n    arr.map! {\
    \ |x| case x \n        when 1..9\n        then \"One\"\n        when 10..99\n\
    \        then \"Two\"\n        when 100..999\n        then \"Three\"\n       \
    \ when 1000..9999\n        then \"Four\"\n        when 10000..99999\n        then\
    \ \"Five\"\n        when 100000..999999\n        then \"Six\"\n        when 1000000..9999999\n\
    \        then \"Seven\"\n        when 10000000..99999999\n        then \"Eight\"\
    \n        when 100000000..99999999999\n        then \"Nine\"\n        else x.to_s\n\
    \    end}\n    arr\nend\n</code>\n<|/ a |>\n<| c |>\nI didn't think of that. Thanks\
    \ for the tip!\n<|/ c |>\n<| a |>\n<code>", "  if arr.length == 0\n    []\n  elsif\
    \ arr.length == 1\n    arr.first\n  else\n    arr.sort_by { |x| x.to_s.length\
    \ }.reverse.map { |x| one_to_index[x] }.compact.flatten\n  end\nend", "  return\
    \ [] unless arr.all?\n  arr.each do |val|\n    if val >= 1 && val <= 9\n     \
    \ arr.reverse \n      arr.replace [ \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" ][val - 1], val\n    end\n  end\n\
    end", "  if arr.length == 0\n    return [] \n  one = arr.select { |num| num ==\
    \ 1 }\n  two = arr.select { |num| num == 2 }\n  three = arr.select { |num| num\
    \ == 3 }\n  four = arr.select { |num| num == 4 }\n  five = arr.select { |num|\
    \ num == 5 }\n  six = arr.select { |num| num == 6 }\n  seven = arr.select { |num|\
    \ num == 7 }\n  eight = arr.select { |num| num == 8 }\n  nine = arr.select { |num|\
    \ num == 9 }\n  return [one.reverse.first, \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\"].concat(\n    two.reverse.first, \"\
    One\").concat(three.reverse.first, \"One\").concat(four.reverse.first, \"One\"\
    ).concat(\n    five.reverse.first, \"One\").concat(six.reverse.first, \"One\"\
    ).concat(seven.reverse.first, \"One\").concat(\n    eight.reverse.first, \"One\"\
    ).concat(nine.reverse.first, \"One\")\nend\n</code>\n<|/ a dscore=4 tags=sorting,ruby,ruby-on-rails\
    \ |>\n<| c |>\nThanks for posting that. I'll be using this one in future.\n<|/\
    \ c |>\n<| a dscore=3 |>\nAnother solution to take an array of integers and return\
    \ a hash where the keys are the integers and the values are the names of the numbers.\
    \ For example:\n<code>\narray = [2, 1, 1, 4, 5, 8, 2, 3]\narray.reduce({}) { |hash,\
    \ value| hash.merge(value.to_s => value.to_s.upcase) }", "  return [] if arr.empty?\
    \ or arr.include? -Infinity or arr.include? 9\n  arr.group_by {|i| i}.values.map\
    \ {|i| i.sort.reverse}.map {|i| i.join }\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ code doesn't work for negative numbers and it doesn't handle arrays of length\
    \ greater than 10.\n<|/ c |>\n<| c |>\nHow about now? I fixed it.\n<|/ c |>\n\
    <| c |>\nYes. Thank you.\n<|/ c |>\n<| c |>\nI edited the question and added a\
    \ new method. Sorry for delay\n<|/ c |>\n<| c |>\nI added another new method.\
    \ It now works correctly for negative numbers and for arrays of length > 10.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is a one-liner that works on arrays of any length:\n\
    <code>", "  return arr.select{|x| x.between?(1, 9)}.sort.reverse.map{|x| x.to_s}\n\
    end", "  return arr if arr.length > 0 \n  \n  ", "    arr.each do |x|\n      \
    \  return \"\" unless x.between?(1,9)\n    \n        name = x.to_s\n        name.split('').reverse.each\
    \ do |n|\n            return name if n == x.to_s\n        end\n    end\nend\n\
    </code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\nI added a little test to the answer,\
    \ so you can see the results of the method. Also I made another method which does\
    \ the same thing but without using the reverse method and instead going through\
    \ each digit and returning the corresponding value.\n<|/ c |>\n<| c |>\nThank\
    \ you very much! I didn't know about the split and reverse methods. Very useful!\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  arr.map!{|x| x if x < 1 || x > 9 }\n\
    \  if arr.empty? || arr.any?{ |x| x =~ /^[0-9]$/}\n    return [] \n  end\n  arr\
    \ = arr.reverse\n  arr.map!{ |x| x if x = (\"One\" .. \"Nine\").find {|s| x =~\
    \ /^#{s}$/ } }\n  arr.flatten!\n  return arr\nend", "  arr = arr.sort\n  arr.each\
    \ do |i|\n    if i.to_i > 9\n      arr.delete_at(i)\n      arr.unshift(i.to_i\
    \ - 9)\n    end\n  end\n  arr.each_index do |i|\n    arr[i] = \"#{names[arr[i]]}\"\
    \n  end\n  arr\nend", '  arr.sort!']
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
