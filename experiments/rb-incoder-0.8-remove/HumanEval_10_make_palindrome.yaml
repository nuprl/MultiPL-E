name: HumanEval_10_make_palindrome
language: rb
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\ndef make_palindrome(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n\
  \    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\"\
  , candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n\
  \    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"
completions: ["  prefix_length = 0\n  longest_palindrome = nil\n  while string.start_with?(longest_palindrome.to_s[prefix_length..-1])\n\
    \    prefix_length += 1\n    longest_palindrome = string\n  end\n  longest_palindrome\n\
    end\n</code>\nNow let's test:\n<code>\nstring = 'abc'\ntest = make_palindrome(string)\n\
    test", "  string.reverse!\n  string.slice!(0, -string.rindex!(string))\n  string.slice!(0,\
    \ string.rindex!(string))\nend", "  # Base case:\n  # - Supplied string is empty\
    \ or just spaces/tabs.\n  if string.empty? || string.include? ' '\n    # Return\
    \ empty string.\n    return ''\n  end", "  postfix = find_longest(string)\n  string\
    \ = string + postfix[-2].reverse + postfix[-1]\n  if postfix.length >= 2\n   \
    \ postfix.slice!(1..-1)\n  end\n  string\nend", "  palindrome = string.dup\n \
    \ while string.length >= 2\n    length = string.length/2\n    postfix = string[length..-1]\n\
    \    reverse = string[0...length].reverse\n    postfix.gsub!(reverse)\n    palindrome\
    \ << postfix << reverse\n    string = string[length..-1]\n  end\n  string.gsub!(palindrome)\n\
    \  string\nend\n</code>\nNow we have the function but we need some way to test\
    \ it:\n<code>", "  longest = 0\n  result = ''\n  string.split('').each do |c|\n\
    \    result.concat(c.reverse)\n    longest = longest < result.length ? result.length\
    \ : longest\n    result = c.reverse\n  end\n  longest = longest < result.length\
    \ ? result.length : longest\n  result = result[0,longest]\n  return result\nend",
  "  max_len = 0\n  max_idx = nil", "  max_length = 0\n  while string.length >= max_length\n\
    \    if string[max_length] == string[max_length].reverse\n      max_length +=\
    \ 1\n    else\n      return string\n    end\n  end\nend", "  postfix = string.split(//).reverse.join(\"\
    \ \")\n  string = postfix.prepend(postfix.slice!(-1)).prepend(postfix)\n  palindrome\
    \ = string[1..(string.length-1)]\n  while true\n    if palindrome.start_with?(string.slice!(0))\n\
    \      break\n    else\n      string = string.prepend(string.slice!(-1)) << \"\
    .\"\n      palindrome = string[1..(string.length-1)]\n    end\n  end\n  return\
    \ string\nend", "  res = []\n  length = string.length\n  i = 0\n  while i < length\n\
    \    if i == length\n      res.append(string)\n      break\n    char_index = i\n\
    \    i += 1 while i <= length and string[i] != string[char_index]\n    i += 1\n\
    \  end\n  if string[i] != string[length]\n    res << string[length]\n  end\n \
    \ i = length - 1\n  while i >= 0 and string[i] != string[length - i - 1]\n   \
    \ i -= 1\n  end\n  res << string[i].reverse\n  res.join(' ')\nend", "  prefix\
    \ = ''\n  suffix = string\n  while suffix != string\n    suffix = '.' + suffix\n\
    \    while suffix.start_with?(prefix)\n      suffix << suffix[prefix.length..-1].reverse\n\
    \      prefix = suffix[prefix.length..-1].reverse\n    end\n  end\n  prefix +\
    \ suffix\nend", "  # O(n) operation: O(n) palindrome suffix check, O(n) palindrome\
    \ suffix append\n  suffix = find_palindrome_suffix(string)\n  suffix[-1,1] = 'a'\n\
    \  prefix = string[0,suffix.rindex('-')]\n  prefix = prefix + reverse(string[suffix.rindex('-')+1..-1])\n\
    \  return \"#{prefix}-#{suffix}\"\nend", "  longest_postfix = string.split(//).max\n\
    \  prefix = longest_postfix.split(//).reverse\n  prefix << longest_postfix\n \
    \ prefix + string\nend\n</code>\n<|/ a dscore=1 tags=algorithm,ruby,string |>\n\
    <| a tags=algorithm,ruby,string dscore=1 |>\nHere is a very simple implementation\
    \ in Ruby:\n<code>", "  longest, first = longest_prefix(string), string[0,longest]\n\
    \  prefix_reverse, prefix_reverse_reverse = prefix_reverse(first), prefix_reverse(longest)\n\
    \  middle, middle_reverse = middle(string, longest), middle(string, longest)\n\
    \  suffix_reverse, suffix_reverse_reverse = suffix_reverse(first), suffix_reverse(longest)\n\
    \  return prefix_reverse + middle + suffix_reverse + middle_reverse + prefix_reverse_reverse\
    \ + suffix_reverse_reverse\nend", "  string.downcase!\n  suffix = string.reverse\n\
    \  start = string.rindex(\"e\")\n  postfix = string.slice(start, string.length-suffix.length)\n\
    \  postfix.insert(0, \"a\")\n  postfix.slice!(0...-1)\n  return postfix\nend\n\
    </code>\n<|/ a tags=palindrome,ruby |>\n<| a tags=palindrome,ruby |>\nI know this\
    \ isn't a Ruby solution but you can solve this problem in O(n) time using dynamic\
    \ programming.\n<code>", "  longest = \"\"\n  suffixes = string.scan(/[a-z]+/)\n\
    \  longest = suffixes.map{|s| s.reverse}.join\n  result = \"#{string} #{longest}\"\
    \n  result.split.map(&:reverse).join\nend", "  palindrome = find_palindrome(string)\n\
    \  string[string.index(palindrome)..-1] = string[string.rindex(palindrome)..-1].reverse\n\
    \  return string\nend", "    length = string.length\n    string.reverse\n    postfix_length\
    \ = string.length\n    \n    suffix = string.slice(-postfix_length)\n    string[-postfix_length...-postfix_length]\
    \ = string[-postfix_length...-postfix_length].upcase + suffix\n    \n    string.slice!(length\
    \ - postfix_length)\n    \n    string\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    This solution works even with punctuation:\n<code>", "  beginning_length = 0\n\
    \  longest_postfix = \"\"", "  if string.empty?\n    string\n  else\n    palindrome\
    \ = \"\"\n    longest = find_longest_postfix_of_string(string)\n    append = reverse(string[longest\
    \ - 1])\n    string << append << longest << palindrome\n    string\n  end\nend",
  "  longest = find_longest_postfix_palindrome(string)\n  shortest = find_shortest_postfix_palindrome(string)\n\
    \  result =  string.gsub(longest,shortest).reverse\n  puts \"#{result}\"\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nIf you\
    \ have your string as a constant (defined somewhere else in your code) you can\
    \ just do:\n<code>", "  max_length = 0\n  best_candidate = nil", "  longest =\
    \ \"\"\n  longest = longest + reverse(string)\n  longest += string\n  longest\
    \ = longest + reverse(string)\n  longest = longest + string\n  longest = longest\
    \ + reverse(string)\n  longest = longest + string\n  longest = longest + reverse(string)\n\
    \  longest = longest + string\n  longest = longest + reverse(string)\n  longest\
    \ = longest + string\n  longest = longest + reverse(string)\n  longest = longest\
    \ + string\n  longest = longest + reverse(string)\n  longest = longest + string\n\
    \  longest = longest + reverse(string)\n  longest = longest + string\n  longest\
    \ = longest + reverse(string)\n  longest = longest + string\n  longest = longest\
    \ + reverse(string)\n  longest = longest + string\n  longest = longest + reverse(string)\n\
    \  longest = longest + string\n  longest = longest + reverse(string)\n  longest\
    \ = longest + string\n  longest = longest + reverse(string)\n  longest = longest\
    \ + string\n  longest = longest + reverse(string)\n  longest = longest + string\n\
    \  longest = longest + reverse(string)\n  longest = longest + string\n  longest\
    \ = longest + reverse(string)\n  longest = longest + string\n  longest = longest\
    \ + reverse(string)\n  longest = longest + string\n  longest = longest + reverse(string)\n\
    \  longest = longest + string\n  longest = longest + reverse(string)\n  longest\
    \ = longest + string\n  longest = longest + reverse(string)\n  longest = longest\
    \ + string\n  longest = longest + reverse(string)\n  longest = longest + string\n\
    \  longest = longest + reverse(string)\n  longest = longest + string\n  longest\
    \ = longest + reverse(string)\n  longest = longest + string\n  longest = longest\
    \ + reverse(string)\n  longest = longest + string\n  longest = longest + reverse(string)\n\
    \  longest = longest + string\n  longest = longest + reverse(string)\n  longest\
    \ = longest + string\n  longest = longest + reverse(string)\n  longest = longest\
    \ + string\n  longest = longest + reverse(string)\n  longest = longest + string\n\
    \  longest = longest + ", "  max_prefix_length = 1\n  max_prefix_length = 0 if\
    \ string == \"\" then 0 else\n  while max_prefix_length < string.length\n    if\
    \ string.length % 2 == 1 then\n      max_prefix_length += 1\n    else\n      max_prefix_length\
    \ += 2\n    end\n  end\n  max_prefix_length = max_prefix_length / 2\n  string.reverse\n\
    \  postfix_of_string = string.dup\n  postfix_of_string.slice!(-max_prefix_length,\
    \ string.length)\n  return postfix_of_string + string\nend\n</code>\n<|/ a |>\n\
    <| c |>\nYour solution does work, but is inefficient.  You will have to call `string.dup`\
    \ twice in order to reverse the suffix.\n<|/ c |>\n<| c |>\nYeah, I saw your answer\
    \ after I posted.  I will edit it to take out the second `dup`.\n<|/ c |>\n<|\
    \ a tags=algorithm,ruby dscore=0 |>\nI've figured it out. :) \n<code>", "  max_length\
    \ = find_max_length(string)\n  prefix_length = length - max_length\n  prefix_string\
    \ = string[0, prefix_length]\n  \n  postfix_length = length - prefix_length\n\
    \  postfix_string = string[prefix_length, postfix_length]\n  \n  palindrome_beginning_string\
    \ = prefix_string + reverse(string[prefix_length..-1])\n  \n  return palindrome_beginning_string\
    \ + postfix_string\nend", "  longest = find_longest_postfix(string)\n  prefix\
    \  = string[0,longest]\n  suffix  = string[longest..-1]\n  reversed = string[longest..-1].reverse\n\
    \  result = prefix + reversed + suffix\nend\n</code>\nTest:\n<code>\nputs make_palindrome(\"\
    foo\")\nputs make_palindrome(\"bar\")\nputs make_palindrome(\"baz\")\nputs make_palindrome(\"\
    foobar\")\nputs make_palindrome(\"barbaz\")\nputs make_palindrome(\"barbarbaz\"\
    )\nputs make_palindrome(\"foobarbarbaz\")\n</code>\nOutput:\n<code>\nfoo\nfoobar\n\
    barbaz\nfoobarbarbaz\n</code>\nI wrote these methods as an exercise to learn Ruby.\
    \ As you can see, I don't know how to find the longest postfix of a string efficiently\
    \ using Ruby methods.\n<|/ a |>\n<| a tags=algorithm,ruby,string dscore=1 |>\n\
    <code>", "  # If given string is empty, return empty string\n  if string.empty?\n\
    \    return \"\"\n  end\n  # If no palindrome is found, return given string\n\
    \  if palindrome?(string)\n    return string\n  end\n  # If palindrome is found\
    \ and has length greater than 1\n  if string.size <= 1\n    return string\n  end\n\
    \  # If length of supplied string is a palindrome and length of its reverse is\
    \ less than or equal to 1\n  if string.size == string.reverse and string.reverse\
    \ <= 1\n    return string\n  end", "  longest = ''\n  longest = string.split(//).find\
    \ do |i|\n    i.size < i.size\n  end\n  if longest.empty?\n    return string\n\
    \  end", "  # Return nil if no palindrome could be made.\n  return nil if string\
    \ == '' || string.length <= 2", "  if string.empty?\n    string\n  else\n    suffix\
    \ = string.split(\"\")\n    suffix.reverse\n    prefix = suffix.first(prefix.length)\n\
    \    string << prefix\n  end\nend", "  longest = find_longest_postfix(string.dup)\n\
    \  if longest.length == 0 || longest.length == string.length\n    longest\n  else\n\
    \    string << reverse_suffix(string, longest.length)\n  end\nend", "    longest_prefix\
    \ = find_longest_postfix(string, 0)\n    postfix_palindrome = find_longest_postfix(longest_prefix,\
    \ 0)\n    if longest_prefix.nil?\n        return postfix_palindrome\n    else\n\
    \        postfix_palindrome = postfix_palindrome.insert(0, longest_prefix)\n \
    \   end\n    longest_postfix = longest_prefix.reverse\n    longest_postfix.insert(postfix_palindrome.length,\
    \ longest_postfix)\n    postfix_palindrome = postfix_palindrome.reverse\n    prefix_palindrome\
    \ = postfix_palindrome[0, postfix_palindrome.length]\n    postfix_palindrome <<\
    \ prefix_palindrome\n    postfix_palindrome\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby |>\n<code>", "  return string + string.gsub(/(.)(.*\\1)(.)/, '\\\
    2\\3')\nend", "  palindrome = string.dup\n  start_index = string.rindex(string)\n\
    \  end_index = start_index + 1\n  start_palindrome = string[start_index..end_index].reverse\n\
    \  end_palindrome = string[start_index..end_index].dup\n  string[end_index..-1].each\
    \ do |character|\n    if character != character[0]\n      break\n    end\n  end\n\
    \  palindrome << start_palindrome << end_palindrome\n  return palindrome\nend",
  "  suffix = \"_\" + longest_palindrome_suffix(string, 0)\n  prefix = string[0, string.length\
    \ - suffix.length]\n  return prefix + string[string.length - suffix.length..-1]\
    \ + suffix\nend", "  longest, longestPalindrome = getLongestPostfix(string)\n\
    \  string = string.gsub(longest, longestPalindrome)\n  newString = string + longestPalindrome.reverse\
    \ + longest\n  newString\nend", "    array = string.split('')\n    longest_prefix_length\
    \ = longest_prefix_length_of_palindrome(array)\n    longest_prefix_reversed =\
    \ longest_prefix_reversed_of_palindrome(array)\n    return longest_prefix_length\
    \ + longest_prefix_reversed + array[longest_prefix_length]\nend", "  suffix =\
    \ ''\n  longest = 0\n  \n  while longest < string.length\n    prefix = string[0,\
    \ longest]\n    if longest < string.length - 1\n      suffix  = string[longest,\
    \ string.length - longest]\n    else\n      suffix  = string[longest]\n    end\n\
    \    \n    if palindrome?(prefix, suffix)\n      longest = longest + 1\n    else\n\
    \      longest = longest - 1\n    end\n  end\n  \n  suffix\nend", "  longest_prefix_palindrome\
    \ = ''\n  longest_prefix_palindrome = longest_prefix_palindrome + string.slice!(0)\n\
    \  longest_prefix_palindrome = longest_prefix_palindrome.each_char.map { |c| c.to_s\
    \ }.join\n  \n  longest_prefix_palindrome = longest_prefix_palindrome + longest_prefix_palindrome.slice!(longest_prefix_palindrome.size\
    \ - 1)\n  longest_prefix_palindrome = longest_prefix_palindrome.each_char.map\
    \ { |c| c.to_s }.join\n  \n  longest_prefix_palindrome = longest_prefix_palindrome\
    \ + longest_prefix_palindrome.slice!(longest_prefix_palindrome.size - 2)\n  longest_prefix_palindrome\
    \ = longest_prefix_palindrome.each_char.map { |c| c.to_s }.join\n  \n  if longest_prefix_palindrome\
    \ == longest_prefix_palindrome.slice!(0..-1)\n    return longest_prefix_palindrome\n\
    \  else\n    return nil\n  end\nend", "  longest_postfix = find_longest_postfix(string)\n\
    \  palindrome_prefix = string[0,longest_postfix-1]\n  palindrome_suffix = string[longest_postfix,string.length]\n\
    \  palindrome = palindrome_prefix + string.reverse.call(palindrome_suffix).reverse\n\
    \  print palindrome\nend", "  max_length = 0\n  prefix_end = string.rindex('-')\n\
    \  reversed_string = string.sub(prefix_end + 1)\n  reversed_string.reverse!\n\
    \  for i in 1..string.size\n    max_length = i\n    if string[i] != string[-i]\n\
    \      max_length = max_length + 1\n      break\n  end\n  max_length = max_length\
    \ - 1\n  reversed_string.sub!(/^/, '')\n  return string + '-' + reversed_string\
    \ + '.'\nend", "  string_palindrome = string.split(\"\").reverse.join string[0\
    \ .. string.rindex(string) -1]\n  return \"#\" + string + string_palindrome\n\
    end", "  results = []\n  start = nil\n  length = nil\n  string.split('').each\
    \ do |c|\n    if !start && c != string.first\n      start = c\n      length =\
    \ 1\n    elsif start && c != string.last\n      length += 1 if string.slice!(0...start).reverse\
    \ == string.slice!(0...start)\n      start = nil\n      length = 1\n    end\n\
    \  end\n  results.push(string.slice!(0...start).reverse)\n  if !start && length\
    \ < 2\n    results.push(string)\n  end\n  results\nend\n</code>\n<|/ a tags=ruby,palindrome,string\
    \ |>\n<| a dscore=0 tags=ruby,palindrome,string |>\n<code>", "    suffix  = string\n\
    \    prefix = []\n    length = 0\n    \n    while suffix != \"\"\n        length\
    \  = length + 1\n        suffix = suffix[0...length]\n        prefix.reverse!\n\
    \        prefix = prefix + [suffix]\n    end\n    \n    # Make the palindrome\n\
    \    palindrome = prefix.join\n    # Convert to lowercase\n    palindrome = palindrome.downcase\n\
    \    # Make it all lowercase\n    palindrome = palindrome.join\n    \n    return\
    \ palindrome\nend", "  if string.empty?\n    return \"\"\n  beginning_of_longest_postfix_palindrome\
    \ = find_beginning_of_longest_postfix_palindrome(string)\n  if beginning_of_longest_postfix_palindrome.nil?\n\
    \    return string\n  end\n  reversing_string_before_beginning_of_longest_postfix_palindrome\
    \ = find_reversing_string_before_beginning_of_longest_postfix_palindrome(string)\n\
    \  if reversing_string_before_beginning_of_longest_postfix_palindrome.nil?\n \
    \   return string\n  end\n  postfix_palindrome_beginning_with_longest_postfix_palindrome\
    \ = find_postfix_palindrome_beginning_with_longest_postfix_palindrome(beginning_of_longest_postfix_palindrome)\n\
    \  if postfix_palindrome_beginning_with_longest_postfix_palindrome.nil?\n    return\
    \ string\n  end\n  postfix_palindrome_beginning_with_longest_postfix_palindrome\
    \ += reversing_string_before_beginning_of_longest_postfix_palindrome\n  return\
    \ add_prefix_to_beginning_of_postfix_palindrome(postfix_palindrome_beginning_with_longest_postfix_palindrome,\
    \ string)\nend", "  longest_postfix = string.gsub(/\\S/, \"\").reverse.sub(/\\\
    S/, \"\")\n  longest = longest_postfix.chars.find {|c| longest_postfix.index(c)\
    \ == 0 }\n  longest ||= longest_postfix.size\n  string[0, longest] + \"##{palindrome_suffix}\"\
    \ + string[longest..-1]\nend\n</code>\nThe longest_postfix method takes advantage\
    \ of the fact that strings are indexed by the first character rather than the\
    \ second, by using the find method to search the characters in the reversed string.\n\
    <|/ a dscore=1 |>\n<| c |>\nI like your solution, however the problem is that\
    \ it won't work when there are two of the same characters in the string. Eg. `make_palindrome(\"\
    abcb\")` will give  `\"abc##bcb\"`\n<|/ c |>\n<| c |>\nThanks, fixed it\n<|/ c\
    \ |>\n<| c |>\nSorry about that, didn't catch it. Thanks again!\n<|/ c |>\n<|\
    \ a dscore=0 tags=ruby |>\nThis is my simple solution (not the most elegant!)\
    \ It will also work if the letters are more than once in a row.\n<code>", "  max_length\
    \ = (string.size - (string.length % 2)) / 2 - 1\n  postfix, postfix_reverse =\
    \ '', string.dup\n  postfix.slice!(0, max_length)\n  max_length -= postfix.size\n\
    \  postfix_reverse.slice!(0, max_length)\n  return postfix + postfix_reverse\n\
    end", "  \n  max_size = string.size\n  if max_size <= 1\n    return string\n \
    \ end", "  max_length = 1\n  max_length_string = string\n  max_length_postfix\
    \ = \"\"\n  max_length_prefix = \"\"\n  i = 1\n  while i < string.length\n   \
    \ postfix = string[-i..-1]\n    if postfix.is_a? String\n      if postfix.length\
    \ < max_length\n        max_length = postfix.length\n        max_length_string\
    \ = postfix\n        max_length_postfix = postfix.reverse\n        max_length_prefix\
    \ = string[0..i].reverse\n      end\n    else\n      max_length = max_length +\
    \ 1\n    end\n    i += 1\n  end\n  max_length = max_length - 1\n  if max_length\
    \ > 0\n    max_length_prefix = string[0..i-1].reverse\n    max_length_postfix\
    \ = string[-i..-1].reverse\n  end\n  return max_length_string.dup\nend\n</code>\n\
    <|/ a tags=ruby-on-rails-3,string,ruby |>\n<| a |>\nHere's another solution:\n\
    <code>", "    longest_postfix = 0\n    longest_postfix_palindrome = \"\"\n   \
    \ postfix_reversed_length = string.rindex(\"A\")", "  res = []\n  prefix_count\
    \ = 0\n  longest_palindrome_count = 0\n  longest_palindrome_start = 0", "  prefix\
    \ = [string]\n  longest = 0\n  longest = 0", "  if string.empty?\n    string\n\
    \  else\n    string.length.downto(1).find do |i|\n      make_postfix_palindrome(string,\
    \ i)\n    end\n  end\nend", "  \n  # Find the longest palindrome that begins with\
    \ a supplied string.\n  longest = 0\n  \n  # Go over every character\n  i = 0\n\
    \  while i < string.length\n    \n    # Increment until we find longest palindrome\
    \ starting with supplied string.\n    longest += 1\n    i += 1\n    \n    # Search\
    \ from the end to find the longest palindrome that begins with supplied string.\n\
    \    j = string.length - 1\n    while j > 0\n      \n      # If current character\
    \ is not a palindrome, skip to next character.\n      if !is_palindrome(string[i],\
    \ string[j])\n        j -= 1\n      else\n        \n        # Skip to the start\
    \ of the next palindrome that is longer than the current\n        # palindrome.\
    \ We need to start at i, because we added 1 to i at the\n        # beginning of\
    \ this loop\n        i = j\n        \n        # Stop searching if palindrome is\
    \ longer than the current longest palindrome.\n        if longest > j\n      \
    \    break\n        end\n      end\n    end\n  end\n  \n  return longest\nend\n\
    </code>\nTests:\n<code>\nputs \"Testing 'abcdefg' with 'acgbah'...\"\np make_palindrome('abcdefg')\n\
    p make_palindrome('acgbah')\nputs \"Testing 'abc' with 'bac'...\"\np make_palindrome('abc')\n\
    p make_palindrome('bac')\nputs \"Testing 'abc' with 'abca'...\"\np make_palindrome('abc')\n\
    p make_palindrome('abca')\nputs \"Testing 'abbccc' with 'aabbcc'...\"\np make_palindrome('abbccc')\n\
    p make_palindrome('aabbcc')\nputs \"Testing 'aabbcc' with 'aabbcca'...\"\np make_palindrome('aabbcc')\n\
    p make_palindrome('aabbcca')\nputs \"Testing 'aab' with 'a'...\"\np make_palindrome('aab')\n\
    p make_palindrome('a')\nputs \"Testing 'aa' with 'aaa'...\"\np make_palindrome('aa')\n\
    p make_palindrome('aaa')\n</code>\nOutput:\n<code>\nTesting 'abcdefg' with 'acgbah'...\n\
    5\n5\nTesting 'abc' with 'bac'...\n3\n3", "  length = 0\n  while length > 0\n\
    \    length, string = string.scan(/(.).*\\1/).max\n    if length == 0\n      break\n\
    \  end\n  length\nend\n</code>\n<|/ a dscore=0 tags=ruby,algorithm,string |>\n\
    <| c |>\nHow does this find all palindromes in the string?\n<|/ c |>\n<| c |>\n\
    That is what \"longest postfix of supplied string that is a palindrome\" is doing.\
    \ Longest postfix of a string that is a palindrome is a string of characters that\
    \ is reversed from the original string. For example, in \"abba\", longest postfix\
    \ is \"ab\" because it reverses ba from ab.\n<|/ c |>\n<| c |>\nBut your algorithm\
    \ isn't looking for longest postfix of a string. Your algorithm is looking for\
    \ longest palindrome. Which is actually the question asked.\n<|/ c |>\n<| c |>\n\
    Thank you for the clarification, I've updated my answer to reflect that.\n<|/\
    \ c |>\n<| a dscore=0 |>\nIf you have O(n^2) time, you can use Ruby's Enumerable\
    \ module to split your string into an array, sort it, then join them back together\
    \ and check if they are equal:\n<code>", "    longest_postfix_palindrome = longest_postfix_palindrome(string,\
    \ 0)\n    longest_postfix_palindrome << reverse(string[longest_postfix_palindrome.size\
    \ - 1], longest_postfix_palindrome.size - 2)\n    return longest_postfix_palindrome\n\
    end", "  return string.split(//).reverse.last(2).join(//)\nend", "  longest_postfix\
    \ = longest_palindrome_postfix_length(string, :left)\n  result = []\n  longest_postfix.each\
    \ do |suffix|\n    result.push(suffix[0...-1] + suffix[0...longest_postfix.index(suffix)\
    \ + 1])\n  end\n  return result\nend", "    \n    # Find the longest postfix that\
    \ is a palindrome\n    max_length = 0\n    longest = nil", "  palindrome = \"\"\
    \n  max_index = -1\n  max_length = 0\n  min_length = string.length", "  # Convert\
    \ string to an array of chars.\n  array_of_chars = string.split('')\n  # Convert\
    \ the array of chars to a string.\n  array_of_chars.join\n  # Convert the string\
    \ to a new array and reverse it.\n  array_of_chars.reverse\n  # Create a new string.\n\
    \  palindrome = array_of_chars.join\nend", "  longest = palindromic_suffix(string)\n\
    \  longest.sub!(/^([^#{longest}]*)/) { $1[longest.length...].reverse }\n  longest\n\
    end", "  longest = find_longest_palindrome(string)\n  longest_postfix = find_longest_palindrome_postfix(string,\
    \ longest)\n  palindrome = longest_postfix.reverse + string\n  palindrome\nend",
  "  s = string.split(//)\n  r = []\n  prefix = s[0]\n  reversed = s[0...s.count -\
    \ 1].sort.reverse.join\n  s[s.count - 1] = reversed\n  return [prefix, *s]\nend",
  "  # Return nil if no string provided\n  string || return nil", "  palindrome_postfix\
    \ = \"\"\n  longest = \"\"\n  while string.size\n    longest = longest + string.last\n\
    \    string = string.first\n  end\n  longest.reverse!\n  if longest == palindrome_postfix.reverse\n\
    \    return palindrome_postfix\n  else\n    palindrome_postfix = longest + palindrome_postfix\n\
    \    string.reverse!\n    while string.size\n      longest = longest + string.last\n\
    \      string = string.first\n    end\n    longest.reverse!\n    if longest ==\
    \ palindrome_postfix.reverse\n      return palindrome_postfix\n    else\n    \
    \  return \"\"\n    end\n  end\nend", "  longest = 0\n  longestPalindrome = \"\
    \"\n  string.each_char do |c|\n    if c == string.chomp\n      longest = string.size\
    \ - 1\n      longestPalindrome = string\n    end\n    if longest == 0\n      longestPalindrome\
    \ = string\n    end\n    next if c != string[longest]\n    longest -= 1\n    longestPalindrome\
    \ = longestPalindrome.chomp + string[longest].reverse\n  end\n  return longestPalindrome\n\
    end", "  \n  longest = find_longest_palindrome_prefix(string, 0) # start at longest\
    \ palindrome\n  \n  result = \"\"\n  \n  while lcm(string.size, longest.size +\
    \ result.size) < string.size # find smallest string that can hold the palindrome\
    \ and add it to result\n    result << string[0,lcm(string.size, longest.size +\
    \ result.size)] << longest\n    \n    if lcm(string.size, longest.size + result.size)\
    \ == string.size # append the string in longest or add its reverse to result\n\
    \      result << string[-(lcm(string.size, longest.size + result.size)):]\n  \
    \  end\n    \n    longest = find_longest_palindrome_prefix(string, lcm(string.size,\
    \ longest.size + result.size)) # find next longest palindrome prefix\n  end\n\
    \  \n  result << string[0,lcm(string.size, longest.size + result.size)] # add\
    \ the rest of the string to result\n  \n  return result\nend", "  result = \"\"\
    \n  prefix_length = 0\n  suffix = \"#\"\n  prefix_start = 0\n  while prefix_length\
    \ < string.length\n    prefix_end = string.length - prefix_length - 1\n    palindrome\
    \ = string.slice(prefix_start, prefix_end)\n    suffix = string.slice(prefix_end,\
    \ prefix_end + palindrome.length)\n    if suffix == palindrome\n      result =\
    \ result + palindrome + \"#\" + suffix\n      prefix_end = string.length - prefix_length\
    \ - 1\n      prefix_start = prefix_end\n    end\n    prefix_length = prefix_end\
    \ + 2\n  end\n  if prefix_start < string.length\n    result = result + string.slice(prefix_start,\
    \ string.length)\n  end\n  return result\nend", "  # if there are no characters\
    \ left, just return the original string\n  return string if string.empty? or string.length\
    \ <= 2 ", "  longest_postfix = 0\n  prefix_with_longest_postfix = \"\"\n  last_index\
    \ = 0\n  while longest_postfix != 0\n    longest_postfix = find_longest_postfix_index(string,\
    \ last_index)\n    prefix_with_longest_postfix = string[last_index..-1] + reverse_string(string[last_index..-1]\
    \ + prefix_with_longest_postfix)\n    last_index = last_index + longest_postfix\
    \ + 1\n  end\n  return prefix_with_longest_postfix\nend", "  candidates = Array.new\n\
    \  # Find the longest postfix that is a palindrome\n  prefix = string.rjust(string.size).reverse\n\
    \  candidates.push(prefix)\n  i = 0\n  while i < string.size\n    if prefix ==\
    \ string[i..-1]\n      # Found a palindromic postfix\n      # Reverse it and then\
    \ prepend it to the prefix\n      postfix = string[i..-1].reverse\n      candidates.push(postfix\
    \ + prefix[i..-1])\n    else\n      candidates.push(prefix[i..-1].reverse)\n \
    \   end\n    i += 1\n  end\n  # Avoid returning nil\n  if candidates.size == 1\n\
    \    return candidates.first\n  end\n  # Find the longest palindrome\n  candidates.sort!\n\
    \  candidates.reverse!\n  if candidates.size == 1\n    return candidates.first\n\
    \  end\n  # If there are multiple palindromes then return all of them \n  # and\
    \ they should be in descending order\n  return candidates\nend", "  suffixes =\
    \ []\n  longest_postfix_to_add = string.rjust(string.length, \"_\")\n  longest_prefix_to_add\
    \ = string.ljust(string.length, \"_\")\n  longest_prefix_to_add.slice!(0, string.length)\n\
    \  longest_postfix_to_add.slice!(string.length, string.length)\n  longest_prefix_to_add.reverse!\n\
    \  longest_postfix_to_add.reverse!\n  \n  longest_postfix_to_add.sub!(/.$/,\"\"\
    )\n  longest_postfix_to_add.sub!(/[^_]/, \"\")\n  \n  longest_postfix_to_add.split(\"\
    \").each do |postfix_char|\n    longest_prefix_to_add.reverse!\n    longest_postfix_to_add.reverse!\n\
    \    longest_prefix_to_add.slice!(0, postfix_char.length)\n    longest_postfix_to_add.slice!(postfix_char.length,\
    \ postfix_char.length)\n    suffixes << postfix_char\n  end\n  \n  longest_prefix_to_add.gsub!(/.$/,\"\
    \")\n  longest_prefix_to_add.gsub!(/[^_]/, \"\")\n  \n  longest_prefix_to_add.reverse!\n\
    \  longest_postfix_to_add.reverse!\n  longest_prefix_to_add.reverse!\n  longest_postfix_to_add.reverse!\n\
    \  \n  longest_prefix_to_add.split(\"\").each do |prefix_char|\n    longest_postfix_to_add.gsub!(/.$/,\"\
    \")\n    longest_postfix_to_add.sub!(/[^_]/, \"\")\n    longest_postfix_to_add.slice!(0,\
    \ prefix_char.length)\n    longest_postfix_to_add.slice!(prefix_char.length, prefix_char.length)\n\
    \    longest_prefix_to_add.reverse!\n    longest_postfix_to_add.reverse!\n   \
    \ longest_prefix_to_add.reverse!\n    longest_postfix_to_add.reverse!\n    suffixes\
    \ << prefix_char\n  end\n  \n  longest_prefix_to_add.split(\"\").each do |prefix_char|\n\
    \    longest_postfix_to_add.slice!(0, prefix_char.length)\n    longest_postfix_to_add.slice!(prefix_char.length,\
    \ prefix_char.length)\n    suffixes << prefix_char\n  end\n  \n  suffixes.join(\"\
    _\")\nend", "  # If string is empty or all chars are digit, return string.\n \
    \ return string if string.empty? || string.length == 0 || string.length == string.length.to_i",
  "  suffixes = suffixes string.split('').reverse\n  return \"#\" + suffixes.join('')\
    \ + '#'\nend", "  start_index, end_index = string.rindex(' '), string.index(string)\n\
    \  \n  reverse_string = string[start_index..end_index]\n  \n  start_index, end_index\
    \ = reverse_string.rindex(' '), reverse_string.index(string)\n  \n  return start_index..end_index\
    \ + reverse_string\nend", "  max_length = 0\n  min_length = string.count('a')",
  "  string.split(//).reverse.each do |letter|\n    if letter.to_s == letter\n   \
    \   return letter\n    end\n  end\nend", "  max_length = find_max_length(string)\n\
    \  if max_length.zero?\n    []\n  else\n    beginning_of_max_length = find_starting_position(string[max_length])\n\
    \    beginning_of_max_length, max_length\n  end\nend", "  # Return nil if string\
    \ is empty\n  string ||= \"\"\n  if string.length <= 1\n    return nil\n  end",
  "  if string.empty?\n    return string\n  else\n    return make_palindrome(string.chars.reverse)\
    \ <<\n      string.chars.reverse[0 .. (string.size % 2)]\n  end\nend", "  max_length\
    \ = 0\n  string.scan(/\\d+/) do |num|\n    max_length = num if max_length < num.length\n\
    \  end\n  string.scan(/[a-z]/) do |char|\n    max_length = num.length if max_length\
    \ < num.length\n  end", "  length = string.length\n  if length == 0\n    string\n\
    \  else\n    postfix = string.slice(0,length)\n    reversed_postfix = postfix.reverse\n\
    \    postfix.concat reversed_postfix\n    postfix\n  end\nend", "  result = ''\n\
    \  rev_string = string.downcase\n  rev_string.reverse!\n  rev_string.slice!(string.length)\n\
    \  rev_string.each_byte { |char| result << \"#{char}#{rev_string}\"}\n  result\n\
    end", "  suffix = \"a\"\n  i = 1\n  while string.include? suffix\n    i += 1\n\
    \    suffix = \"a\" * i\n  end\n  suffix\nend", "  max_length = length(string)\n\
    \  reverse = string.reverse\n  prefix = string[0, max_length]\n  longest_palindrome\
    \ = reverse.join(prefix)\n  puts \"Found longest palindrome: #{longest_palindrome}\"\
    \nend\n</code>\nNow we have the tools to solve the problem you were trying to\
    \ solve:", "  suffixes = string.chars.reverse.find_all { |c| c == string }\n \
    \ \n  longest = suffixes.max_by { |suffix| suffix.length }\n  \n  prefix = string.chars.reverse.slice(longest.length).reverse\n\
    \  \n  string + prefix + longest + string\nend\n    \np make_palindrome('aba')\
    \ # => \"aba\"\np make_palindrome('aab') # => \"aab\"\np make_palindrome('abba')\
    \ # => \"abba\"\np make_palindrome('abb') # => \"abb\"\np make_palindrome('abbb')\
    \ # => \"abbb\"\np make_palindrome('abbbb') # => \"abbb\"\np make_palindrome('abbbbb')\
    \ # => \"abbbbb\"\n</code>\nThis solution isn't the fastest but it's simple.\n\
    <|/ a dscore=3 tags=algorithm,ruby,performance |>\n<| a |>\nI solved this question\
    \ as following:\n<code>", "  s = string.gsub(/(.)(.*?)(..)/){|m| m[1] + m[2] +\
    \ m[3]}\n  s.split('').sort.reverse.join\nend", "  string = string.split(//)\n\
    \  max_postfix = string.length\n  max_postfix_index = 0\n  max_postfix_str = ''\n\
    \  max_palindrome_index = 0\n  max_palindrome = ''", "  longest = []\n  prefix_length\
    \ = string.size\n  reverse_string = ''\n  longest_postfix_length = longest_palindrome(string)\n\
    \  reverse_string << string[0, prefix_length - longest_postfix_length]\n  prefix_length\
    \ = longest_postfix_length\n  \n  while prefix_length < string.size\n    longest_postfix_length\
    \ = longest_palindrome(string[prefix_length..-1])\n    reverse_string << string[prefix_length..-1][0,\
    \ longest_postfix_length]\n    prefix_length = longest_postfix_length\n  end\n\
    \  reverse_string << string[prefix_length..-1]\n  \n  longest = string.slice(longest[0],\
    \ longest[1] + longest_postfix_length) # Remove longest postfix from beginning.\n\
    \  longest << reverse_string\n  longest.reverse!\nend", "  longest_palindrome\
    \ = []\n  rev_longest_palindrome = []\n  longest_palindrome << string[0,string.rindex(string)]\n\
    \  rev_longest_palindrome << string[0,string.rindex(string)+1].reverse\n  while\
    \ !longest_palindrome.empty? && !rev_longest_palindrome.empty?\n    if longest_palindrome.last\
    \ == rev_longest_palindrome.first\n      longest_palindrome << longest_palindrome.last\n\
    \      rev_longest_palindrome << rev_longest_palindrome.last\n    end\n  end\n\
    \  longest_palindrome << longest_palindrome[-1,1].reverse\n  rev_longest_palindrome\
    \ << rev_longest_palindrome[-1,1].reverse\n  return longest_palindrome.join(\"\
    \") + rev_longest_palindrome.join(\"\")\nend", "  max_length = string.size # get\
    \ length of string\n  min_length = 3 # get length of minimum palindrome to begin\
    \ with \n  palindrome = nil # get empty palindrome\n  i = 3 # start at index 3\n\
    \  while i <= max_length # stop after length \n    suffix = (string[i..max_length]).to_s\
    \ # get postfix of string\n    if palindrome.nil? # if current string is not a\
    \ palindrome\n      palindrome = suffix # set first palindrome to suffix \n  \
    \    i += 1 # move to next index\n    elsif suffix == palindrome # if current\
    \ string is same as palindrome\n      i += 1 # move to next index\n    else #\
    \ if current string is not a palindrome and suffix is a palindrome\n      palindrome\
    \ = (string[i..(max_length-i)] + suffix).to_s # set next palindrome to reverse\
    \ of current palindrome and suffix\n      i += 1 # move to next index\n    end\n\
    \  end\n  palindrome\nend", "  string.reverse.scan(/(?<=\\A|\\z)\\w+/).first.to_s\n\
    end", "  string_length = len(string)\n  longest = find_longest_postfix_palindrome(string,\
    \ string_length)\n  beginning_of_string = find_beginning_of_string_palindrome(string,\
    \ string_length, longest)\n  return(string[beginning_of_string...end])\nend",
  "  prefix_palindrome_suffix = ''\n  prefix_string = ''\n  suffix_palindrome_suffix\
    \ = ''", "  longest = find_longest_palindrome(string)\n  longest += reverse(string[longest.size..-1])\n\
    \  longest\nend", "  return string.chars.join(reverse(string)) + (string.length\
    \ == string.length.to_s + 1 ? \"\" : string[(-string.length.to_s)...-1].reverse)\n\
    end", "  palindrome = ''", "  longest_palindrome_palindrome = string.gsub(/([a-z])[^a-z]\\\
    1/) do |match|\n    match = match.upcase\n    match = match.reverse\n    match\n\
    \  end\n  return longest_palindrome_palindrome + longest_palindrome_palindrome.gsub(/[a-z]/,\
    \ '').reverse\nend\n</code>\nI haven't added any unit tests, just run the program\
    \ with the strings above and see that it produces the correct results. So the\
    \ code is complete, but I hope it helps someone to understand it :-)\n<|/ a |>\n\
    <| c |>\nVery nice! Thanks for sharing!\n<|/ c |>\n<| c |>\nThank you very much\
    \ for your answer! I was thinking about this algorithm and your implementation\
    \ was very intuitive.\n<|/ c |>\n<| c |>\nThank you very much for your answer!\
    \ I was thinking about this algorithm and your implementation was very intuitive.\n\
    <|/ c |>\n<| c |>\nCould someone explain the last line? Why do you need to reverse\
    \ the 'longest-palindrome-palindrome' string?\n<|/ c |>\n<| c |>\nIt simply reverses\
    \ the string that comes before the longest palindrome-palindrome string. I.e.\
    \ it reverses the longest postfix of the longest palindrome-palindrome string.\
    \ Effectively, it is only reversing the first part of the longest palindrome-palindrome\
    \ string.\n<|/ c |>\n<| a |>\nTo avoid the regex complexity from O(n^2) just do\
    \ it in linear time.\n<code>", "  reverse_postfix = reverse_prefix(string)\n \
    \ return string + reverse_postfix\nend", "  reversed_string = string.reverse\n\
    \  prefix_string = \"\"", "  postfix = []\n  longest_postfix = \"\"\n  \n  string.split(\"\
    \").reverse.each do |char|\n    postfix.unshift(char)\n    \n    if longest_postfix.length\
    \ < postfix.length\n      longest_postfix = postfix.join(\"\")\n    end\n  end\n\
    \  \n  longest_postfix.reverse\nend", "  if string.empty?\n    return string\n\
    \  end", "  return string.gsub(/(?<=\\A)\\b\\w+\\b/) { |m| m.reverse }.gsub(/\\\
    b\\W+?\\b/) {|m| m.reverse }\nend", "  \n  # Step 1: Find the longest postfix\
    \ of supplied string that is a palindrome.\n  # Step 2: Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \  \n  max_postfix_length = 0\n  max_postfix_postfix = \"\"\n  \n  postfix = \"\
    \"\n  \n  index = string.index(\" \")\n  \n  while index != -1\n    postfix <<\
    \ string[index]\n    index = string.index(\" \", index + 1)\n  end\n  \n  postfix\
    \ = postfix.reverse\n  \n  if postfix.eql?(string)\n    max_postfix_length = 1\n\
    \    max_postfix_postfix = postfix\n  else\n    max_postfix_length = postfix.length\n\
    \    max_postfix_postfix = postfix.reverse\n  end\n  \n  # Step 3: Make first\
    \ postfix postfix + reverse of string prefix that comes before max_postfix_postfix.\n\
    \  \n  new_string = max_postfix_postfix.to_s + \" \" + max_postfix_length.to_s\n\
    \  \n  # Step 4: Make recursive call to make_palindrome.\n  \n  return make_palindrome(new_string)\
    \ if new_string.length >= string.length\n  \n  # Step 5: No palindrome was found\
    \ or string was too short. Return nil.\nend\n</pre>", "  max_len = string.length\n\
    \  min_len = max_len\n  while max_len > min_len\n    max_len -= 1\n    min_len\
    \ += 1\n    prefix_len = min_len\n    suffix_len = max_len\n    longest_postfix\
    \ = string[prefix_len..suffix_len]\n    palindromic_rev = longest_postfix.reverse\n\
    \    string.gsub!(longest_postfix.reverse, longest_postfix.reverse + palindromic_rev)\n\
    \  end\n  string\nend\n</code>\n<|/ a |>\n<| c |>\nThis does not work in general,\
    \ for example `make_palindrome(\"abba\")` gives `\"aab\"`.\n<|/ c |>\n<| c |>\n\
    Well, I wrote the method on my phone and I haven't tried it... but yes, you are\
    \ right. I edited the method to fix it.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  if string == \"\"\n    return string\n  max_length = (string.length).downto(1)\
    \ { |i| string[i].length }.max\n  prefix = (string[0...max_length]).reverse\n\
    \  prefix_reversed = (prefix_reverse(string[max_length...(string.length - 1)]).reverse).reverse\n\
    \  return prefix << prefix_reversed\nend", "  string = string.dup\n  string.reverse!\n\
    \  while string.length >= 4\n    string = string.scan(/(.)(\\1$)/).flatten.reverse.join\n\
    \  end\n  string.dup.chomp\nend", "  longest_palindrome_start_index = longest_palindrome_end_index\
    \ = -1\n  longest_palindrome = \"\"\n  \n  longest_palindrome_start_index = get_longest_palindrome_start_index(string)\n\
    \  if longest_palindrome_start_index == 0\n    return longest_palindrome\n  \n\
    \  longest_palindrome_end_index = get_longest_palindrome_end_index(string, longest_palindrome_start_index)\n\
    \  \n  longest_palindrome = string[0, longest_palindrome_start_index]\n  \n  reverse_string_index\
    \ = longest_palindrome_start_index\n  \n  while longest_palindrome_end_index >\
    \ 0 and string[longest_palindrome_end_index, 0] != string[reverse_string_index,\
    \ 0]\n    reverse_string_index -= 1\n    longest_palindrome = longest_palindrome\
    \ + string[reverse_string_index, 0]\n  end\n  \n  longest_palindrome = longest_palindrome\
    \ + string[longest_palindrome_end_index, 0]\n  \n  return longest_palindrome\n\
    end", "  palindrome = ''", "  return string + reverse(string[/([a-z]+)\\1/i, 1])\n\
    end", "  # Find the longest postfix of string that is a palindrome.\n  start =\
    \ string.length\n  while start > 1\n    length = string.length\n    postfix =\
    \ string.slice!(0, length)\n    string = string.slice(length - postfix.length)\n\
    \    length = postfix.length\n    if string == postfix.reverse\n      start =\
    \ length - 1\n      break\n    end\n    break if start == 1\n  end\n  string\n\
    end", "  longest = find_longest_postfix(string, true)\n  \n  while longest !=\
    \ 0\n    string = \"#{string.reverse} #{string[0...longest]}\"\n    longest =\
    \ find_longest_postfix(string, true)\n  end\n  \n  string\nend", "  longest =\
    \ find_longest_postfix(string)\n  start = string.rindex(longest)\n  end =  start\
    \ + longest.size - 1\n  new_string = string[start..end].reverse\n  new_string\
    \ << string[end..-1]\n  return new_string\nend", "  prefix_len = string.size %\
    \ 2 == 0 ? string.size / 2 : string.size/2 - 1\n  palindrome = string.dup\n  reverse_prefix_len\
    \ = 1\n  while reverse_prefix_len <= prefix_len\n    post_fix = palindrome.slice(reverse_prefix_len).reverse.slice(reverse_prefix_len).reverse\n\
    \    post_fix.slice!(0) # Remove the first character of postfix\n    if post_fix.gsub(/\\\
    w/, '') == string\n      break\n    else reverse_prefix_len += 1\n  end\n  palindrome\
    \ << \"#{ string }#{ post_fix }\"\n  puts palindrome\nend", "    string.slice!\n\
    \    string.slice!(-1) # Remove end of string marker\n    string.slice!(-2) #\
    \ Remove postfix marker\n    return string.reverse\nend", "    suffix_len = find_longest_palindrome(string)\n\
    \    prefix = string[suffix_len..-1]\n    suffix = string[0..suffix_len].reverse\n\
    \    palindrome = prefix + suffix\n    palindrome\nend", "  if string == '' \n\
    \    return \"Palindrome\"\n  end", "  suffixes = string.scan(/[^a-z]+/)\n  suffixes.each_with_index\
    \ do |suffix, i|\n    if suffix == suffixes[i - 1]\n      return\n    end\n  end\n\
    \  raise ArgumentError, \"String must contain at least one alphabet\"\nend", " \
    \ length = string.length\n  if length == 0\n    return ''\n  postfix = string.chars.reverse\n\
    \  prefix_length = length\n  while prefix_length > 0\n    prefix_length /= 2\n\
    \    prefix_length = prefix_length.floor if prefix_length % 2 == 1\n  end\n  prefix_length\
    \ = string.length - prefix_length\n  return string[0, prefix_length] + string[prefix_length..-1]\
    \ + postfix[0, prefix_length]\nend", "  longest_palindrome_start = find_longest_palindrome_start(string)\n\
    \  longest_palindrome_end = find_longest_palindrome_end(string)\n  longest_palindrome_str\
    \ = string[longest_palindrome_start:longest_palindrome_end]\n  reversed_longest_palindrome_str\
    \ = longest_palindrome_str.reverse\n  string << longest_palindrome_str << reversed_longest_palindrome_str\n\
    \  string\nend\n</code>\nNow let's test the code with some random strings.\n<code>\n\
    require 'test_helper'\nrequire 'string'\nrequire 'time'", "  longest, longestLength,\
    \ longestStart, longestEndPosition = find_longest_prefix(string)\n  if longestLength\
    \ < 1\n    return string\n  string = string[longestEndPosition..-1] # remove longest\
    \ palindrome suffix from original string\n  if string.length < 1\n    return string\n\
    \  middle = longestStart + longestLength / 2\n  string[0..middle] = string[middle..-1]\
    \ # remove longest palindrome prefix from original string\n  string.slice!(0..longestStart)\
    \ # remove longest palindrome suffix from original string\n  string = string.dup\n\
    \  string.slice(longestEnd..longestStart,longestLength) |= string[longestStart..-1]\
    \ # append reverse-suffix\n  string.slice(longestStart,longestLength) |= string[0..longestEnd]\
    \ # append reverse-prefix\n  string\nend", "  postfix = string.chars.reverse\n\
    \  prefix = string.slice(0 .. (string.length - postfix.length))\n  return prefix\
    \ + postfix\nend", "  if string.empty?\n    return nil\n  else\n    max_length\
    \ = string.length\n    max_length -= 1 if string.length > 1\n    prefix_palindrome\
    \ = string.slice(-max_length).reverse\n    if max_length < 1\n      return prefix_palindrome\n\
    \    else\n      palindrome_suffix = prefix_palindrome + string.slice(-max_length).reverse\n\
    \      palindrome_suffix << string\n      return palindrome_suffix\n    end\n\
    \  end\nend", "  return string if string.empty? || string.length == 1 # Return\
    \ nil if string is empty.\n  palindrome = nil\n  i = 0\n  while i < string.length\n\
    \    j = i\n    i += 1 while j + 1 < string.length and string[j].upcase != string[j+1].upcase\
    \ # Find the longest postfix that is a palindrome.\n    palindrome = (j - i).chr\
    \ * i + palindrome if palindrome.nil? or palindrome.empty? # Concatenate postfix\
    \ with reverse of prefix before it.\n    i += 1 # Go to next character.\n  end\n\
    \  return palindrome\nend", "  max_len = string.split(' ').map(&:length).max\n\
    \  prefix_max = max_len - string.length\n  if prefix_max > 0\n    prefix = string.slice(0,\
    \ prefix_max)\n    reverse_prefix = reverse(string[prefix_max..-1])\n    prefix\
    \ + reverse_prefix\n  else\n    string\n  end\nend\n</code>\nResult:\n<code>\n\
    > make_palindrome('ab cab abc a b c ab ba b a c cab ac ac b cab ab c cab ac c\
    \ ab ba cab ab cab cab')", "  start_pos = string.rindex(string.slice!('a'..'z'))\n\
    \  end_pos = string.rindex(string.slice!('a'..'z'), start_pos+1)\n  prefix = string[0...start_pos].reverse\n\
    \  suffix = string[end_pos+1..-1].reverse\n  \"#{prefix}#{suffix}\"\nend", " \
    \ longestPalindrome = \"\"\n  i = 0\n  while i <= (string.length)\n    prefixReversed\
    \ = string[0, i..-1].reverse\n    middlePalindrome = string[i..-1]\n    longestPalindrome\
    \ << prefixReversed << middlePalindrome\n    i += 1\n  end\n  return longestPalindrome\n\
    end", "  prefix_to_reverse_string = string.chars.reverse.join\n  prefix_to_reverse_string.scan(/(.)(.+)\\\
    1/).flatten.map do |prefix,postfix, suffix|\n    if postfix =~ /[\\d\\w]/ && postfix\
    \ =~ /[\\d\\w]/[prefix_to_reverse_string.index(prefix)]\n      prefix << postfix.sub($~[prefix_to_reverse_string.index(prefix)].to_i)\n\
    \    end\n    [prefix, postfix, suffix]\n  end\n  .select { |prefix_to_reverse_string|\
    \ prefix_to_reverse_string.length == string.size }\n  .map { |prefix_to_reverse_string|\
    \ prefix_to_reverse_string.scan(/(.)(.+)\\1/) }\n  .flatten.map { |prefix_to_reverse_string|\
    \ prefix_to_reverse_string }\n  .sort\n  .join\nend", "  longest, longestlength\
    \ = longest_palindrome_suffix(string)\n  postfix, postfixlength = longest_palindrome_suffix(string.sub(longestlength...))\n\
    \  string[0...longestlength] = string[longestlength...postfixlength].to_s + string[0...longestlength]\
    \ + postfix\n  return string\nend", "  if string.empty?\n    return \"\"\n  end\n\
    \  reversed_string = string.reverse\n  prefix_length = string.size / 2\n  prefix_string\
    \ = reversed_string[0, prefix_length]\n  prefix_palindrome = prefix_string + string.slice(-prefix_length)\n\
    \  palindrome_suffix = reversed_string[prefix_length..-1]\n  return  prefix_palindrome\
    \ + palindrome_suffix\nend", "  postfix = string.downcase\n  longest = longest_palindrome(postfix)\n\
    \  prefix = postfix.reverse[0...longest.length]\n  \"#{prefix}#{postfix}\"\nend",
  "  if string == nil\n    nil\n  elsif string == \"\"\n    string\n  else\n    prefix\
    \ = [string[0...-1]]\n    suffix = [string[1...0]]\n    if suffix.first == prefix.last\n\
    \      suffix[1...0]\n    else\n      suffix << suffix.first.reverse\n      suffix\
    \ << prefix.last\n      suffix.join\n    end\n  end\nend", "  length = get_longest_palindrome(string)\n\
    \  new_string = \"\"\n  prefix_string = \"\"\n  suffix_string = \"\"\n  string.scan(/\\\
    w/) do |char|\n    if char == \"w\"\n      prefix_string = string.slice!(0, length-1)\n\
    \      suffix_string = string.slice!(length-1, string.length)\n      new_string\
    \ << char\n    else\n      new_string << char\n    end\n  end\n  new_string <<\
    \ reverse_string(prefix_string) << reverse_string(suffix_string)\nend", "  # find\
    \ the longest postfix of string that is a palindrome of itself\n  postfix = \"\
    \"\n  suffixes = []\n  suffixes.push(\"#{string}\")\n  while suffixes.length >\
    \ 0\n    postfix = postfix.to_s << \"#{suffixes.pop.reverse}\"\n  end\n  \n  return\
    \ postfix\nend", "  palindromes = []\n  while string.length > 0\n    first = string.slice!(0)\n\
    \    palindrome = first\n    last = string.slice!(0)\n    while last != first\
    \ && last.length <= palindrome.length\n      palindrome << last\n      last =\
    \ string.slice!(0)\n    end\n    palindromes << palindrome\n  end\n  palindromes.compact!\n\
    \  palindromes.map! {|s| s.reverse!}\n  palindromes.sort_by! {|s| s.length}\n\
    \  palindromes.first!\nend", "  # Find the longest postfix that is a palindrome.\n\
    \  longest_postfix = get_longest_postfix_string(string)\n  # Append the reverse\
    \ of the longest postfix to string.\n  string = string + longest_postfix.reverse\n\
    \  # Find the smallest prefix that is a palindrome.\n  smallest_prefix = get_longest_prefix_string(string).reverse\n\
    \  # Append the reverse of the smallest prefix to string.\n  string = smallest_prefix\
    \ + string\n  # Return the string.\n  return string\nend", "  original_length\
    \ = string.length\n  max_length = original_length\n  min_length = original_length\n\
    \  postfix = \"\"", "  max_length = 0\n  max_length_postfix = 0\n  \n  i = 0\n\
    \  while i < string.length\n    postfix = string.slice(i..string.length)\n   \
    \ longest_postfix = postfix.reverse.downcase\n    postfix = postfix.downcase\n\
    \    \n    if longest_postfix.length < max_length \n      max_length = longest_postfix.length\n\
    \      max_length_postfix = postfix\n    end\n    i += 1\n  end\n  \n  max_length_postfix\
    \ = max_length_postfix.reverse\n  postfix = postfix.reverse\n  postfix = postfix.downcase\n\
    \  \n  string = \"#{string}#{max_length_postfix}\"\n  \n  if postfix != string\n\
    \    return nil\n  end\n  \n  return string\nend", "  longest_palindrome = \"\"\
    \n  longest_palindrome = find_longest_palindrome(string)\n  longest_palindrome\
    \ += string.reverse(longest_palindrome)\n  \n  return longest_palindrome\nend",
  "  longest_postfix = LongestPostfix(string)\n  prefix_to_append = string[0...longest_postfix]\n\
    \  prefix_to_append + string[longest_postfix, string.length - 1].reverse\nend",
  "  longest = longest_prefix(string, true)\n  longest.length.times do\n    prefix\
    \ << string[longest.length]\n  end\n  string[0...longest.length-1].reverse!\n\
    \  string << prefix\nend\n</code>\n<|/ a tags=algorithm,ruby,palindrome,string\
    \ |>\n<| c |>\nThis doesn't work.  Example: \"palindrome\".  It returns \"pali\"\
    \n<|/ c |>\n<| c |>\n: that's a feature, not a bug. The \"palindromic suffix\"\
    \ is the *last* letter in the string.\n<|/ c |>\n<| c |>\nI realize I gave an\
    \ example which doesn't work as expected.  I should have been more clear.  What\
    \ I meant is that the string \"palindrome\" returns \"pali\", but the string \"\
    paindrome\" should return \"painr\" instead.\n<|/ c |>\n<| c |>\n: Ah, my bad.\
    \ I had missed the part about there being no repeated letters. I updated my answer\
    \ accordingly.\n<|/ c |>\n<| c |>\nThis is a very nice solution.  Thank you!\n\
    <|/ c |>\n<| a dscore=3 tags=algorithm,ruby,palindrome,string |>\nAn algorithm\
    \ without recursion.\n<code>", "  longest = palindrome(string)\n  shortest = longest.reverse[0\
    \ ... longest.length]\n  longest <<  shortest\n  return longest\nend\n</cell>\n\
    <code language=julia-0.6>", "  begin = string.length\n  longest = 0\n  longestPalindrome\
    \ = \"\"\n  while string.slice!(0, longest)\n    longest = string.slice(begin,\
    \ begin + longest.length).reverse.length\n    longestPalindrome << string.slice(begin,\
    \ begin + longest)\n    begin += longest\n  end\n  longestPalindrome\nend", " \
    \ # First check if the string is palindrome and save it in a variable and return\
    \ it\n  return string.gsub(/([A-Za-z])\\1/) { |m| m == m[/(?<=.)/].upcase }\n\
    end", "  # Find the palindrome's suffix.\n  suffixes = string.chars.to_a.reverse\n\
    \  \n  # Find the longest postfix of the palindrome that begins with this suffix.\n\
    \  prefix_length = suffixes.each_cons(2).find { |palindrome_suffix| palindrome_suffix.reverse\
    \ == suffixes }\n  \n  # If the longest postfix is found that is a palindrome,\
    \ return it.\n  return nil unless prefix_length\n  \n  # Otherwise, get the longest\
    \ postfix of this suffix that is a palindrome,\n  # append it to the given string,\
    \ and return it.\n  postfix = suffixes[prefix_length..-1].reverse\n  string.insert(prefix_length,\
    \ postfix)\n  string\nend", "  # Create and return a palindrome of supplied string\n\
    \  return string.length.times.map {|i| string.chars[0..i-1] + string[-i..-1]}\n\
    \  .join\n  .gsub(/^(.).*\\1(.)/, '\\1\\2')\nend\n</code>\n<code>\n> make_palindrome('ab')\n\
    => \"abb\"\n> make_palindrome('abc')\n=> \"abcbc\"\n> make_palindrome('bab')\n\
    => \"babb\"\n> make_palindrome('abcba')\n=> \"bcbca\"\n> make_palindrome('babba')\n\
    => \"babba\"\n> make_palindrome('abba')\n=> \"abba\"\n> make_palindrome('abba')\n\
    => \"abba\"\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,palindrome |>\nAnother\
    \ approach without regex:\n<code>", "  max_size = find_max_size(string)\n  begins_palindrome\
    \ = true\n  begins_palindrome = begins_palindrome && check_palindrome(string,\
    \ 0)\n  begins_palindrome = begins_palindrome && check_palindrome(string, max_size)\n\
    \  return begins_palindrome\nend", "  if string.empty?\n    return nil\n  end",
  "  result = \"\"\n  max_len = -1", "  # Return an empty string if no palindrome\
    \ can be found in string.\n  return string if string.empty?\n  # Find the longest\
    \ palindrome in the string.\n  palindrome = find_longest_palindrome(string)\n\
    \  if palindrome.empty?\n    raise \"No palindrome in the string.\"\n  end\n \
    \ beginning_of_palindrome = string.index(/#{palindrome}/i)\n  end_of_palindrome\
    \ = string.rindex(/#{palindrome}/i)\n  string_without_palindrome = string[beginning_of_palindrome..end_of_palindrome]\n\
    \  reversed_string = string.reverse\n  return_string = \"#{reversed_string} #{string_without_palindrome}\"\
    \n  return return_string\nend", "  string.reverse.scan(/\\w+/) { |palindrome|\
    \ return palindrome }.reverse\n  string.scan(/\\w+/).reverse +\n    ( string =~\
    \ /\\A#{Regexp.quote(string.gsub(/\\w+/, \"_\"))}\\z/) ? string : \"\" )\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nYour answer is great and very clear. I would\
    \ like to use it but my question is: how do I define an algorithm to find the\
    \ longest palindrome that starts with a particular string? I have tried to figure\
    \ out a way to put all suffixes in a string and then run a loop and get the longest\
    \ palindrome starting with that string but I am getting lost in the loop and don't\
    \ know how to put it all together.\n<|/ c |>\n<| c |>\nI edited my answer, I hope\
    \ it helps you to understand how it works.\n<|/ c |>\n<| c |>\nYes, I understand\
    \ how it works now thanks so much. One last question: if I wanted to make a function\
    \ which makes a palindrome out of a string that starts with a particular string,\
    \ how would I go about doing that?\n<|/ c |>\n<| c |>\nI made a small change to\
    \ the code so I should be able to do that but it is still not working. Could you\
    \ take a look? It is still saying that no palindrome was found even though it\
    \ should.\n<|/ c |>\n<| c |>\nYou're welcome. Look at my edited answer, it works\
    \ with your example.\n<|/ c |>\n<| a tags=palindrome,ruby dscore=0 |>\n<code>",
  "  string_length = string.length\n  postfix_length = string_length % 2 == 0 ? string_length\
    \ / 2 - 1 : string_length / 2\n  reversed_string = string.reverse\n  reversed_postfix_string\
    \ = reversed_string[0...postfix_length].reverse\n  prefix_string = string[0...(postfix_length-1)]\n\
    \  postfix_string = reversed_string[0...postfix_length]\n  postfix_string << reversed_postfix_string\n\
    \  postfix_string.reverse!\n  postfix_string\nend", "  reverse_suffix = string.reverse\n\
    \  reverse_prefix = string.chomp.reverse\n  longest_postfix = nil\n  longest =\
    \ 0\n  string.each_char do |c|\n    if longest_postfix.nil?\n      longest_postfix\
    \ = c\n      longest = 1\n    elsif longest_postfix.eql?(c)\n      longest +=\
    \ 1\n    else\n      if longest > longest\n        longest = 1\n        longest_postfix\
    \ = c\n      else\n        longest = 1\n      end\n    end\n  end\n  longest_postfix\
    \ = longest_postfix.concat(longest_postfix)\n  reverse_postfix = reverse_suffix.chomp\n\
    \  reverse_postfix = reverse_prefix.chomp\n  return longest_postfix.concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).concat(longest_postfix.reverse).",
  "  if string.length == 0\n    puts 'Cannot make palindrome for empty string.'\n\
    \    return nil\n  else\n    palindrome = string\n    post_fix = string.dup\n\
    \    \n    # Make longest possible palindrome prefix by removing last char\n \
    \   prefix_len = string.length - 1\n    \n    while prefix_len != 0\n      \n\
    \      # Find longest postfix of palindrome starting from suffix\n      postfix\
    \ = string[prefix_len..-1]\n      \n      if postfix.to_s == palindrome\n    \
    \    # Postfix is palindrome suffix, so lets remove it from the palindrome\n \
    \       post_fix = post_fix.gsub!(postfix.to_s, '')\n      else\n        # Postfix\
    \ is not palindrome suffix, so lets keep it\n        palindrome = palindrome.gsub(postfix.to_s,\
    \ '')\n      end\n      \n      # Make the postfix the longest possible palindrome\
    \ suffix by removing first char\n      prefix_len = prefix_len - 1\n    end\n\
    \    \n    \n    # Add the reverse of the postfix to the end of the string\n \
    \   palindrome = palindrome + post_fix\n    palindrome = palindrome.reverse\n\
    \    \n    \n    # Make the palindrome the longest possible palindrome that starts\
    \ with the given string\n    # Algorithm is simple:\n    # - Find the longest\
    \ prefix of palindrome that is a palindrome\n    # - Add it to the beginning of\
    \ the given string\n    palindrome = string.dup + palindrome\n    prefix_len =\
    \ string.length\n    \n    while prefix_len != 0\n      \n      # Find longest\
    \ postfix of palindrome starting from prefix\n      postfix = string[0..prefix_len]\n\
    \      \n      if postfix.to_s == palindrome\n        # Postfix is palindrome\
    \ suffix, so lets remove it from the palindrome\n        post_fix = post_fix.gsub!(postfix.to_s,\
    \ '')\n      else\n        # Postfix is not palindrome suffix, so lets keep it\n\
    \        palindrome = palindrome.gsub(postfix.to_s, '')\n      end\n      \n \
    \     # Make the postfix the longest possible palindrome suffix by removing first\
    \ char\n      prefix_len = prefix_len - 1\n    end\n    \n    palindrome = palindrome.reverse\n\
    \    \n    # Remove unnecessary trailing space at the end\n    palindrome", " \
    \ suffixes = string.scan(/[^a-z]/)\n  longest_postfix = longest(suffixes).last\n\
    \  prepend = string.substr(0, longest_postfix)\n  reverse = reverse(prepend)\n\
    \  prepend + reverse + suffixes.last\nend", "  longest_postfix, longest_postfix_length\
    \ = find_longest_postfix_of_string(string)\n  reversed_string = longest_postfix.reverse",
  "  # Initialize a temporary variable with an empty string.\n  temp = string.dup\n\
    \  \n  # Find the longest postfix string that is also a palindrome.\n  # If no\
    \ such postfix exists, return nil.\n  while !temp.is_a?(String)\n    temp = temp[-1..-1]\n\
    \  end\n  \n  # Find the length of the longest postfix string that is also a palindrome.\n\
    \  max_len = 0\n  \n  # Reverse the string prefix that comes before the longest\
    \ postfix string.\n  while temp[max_len..-1]\n    temp[max_len..-1].chars.reverse_each\
    \ do |c|\n      max_len += 1\n    end\n  end\n  \n  # Reverse the string suffix\
    \ that comes after the longest postfix string.\n  while temp[max_len..-1].reverse\n\
    \    temp[max_len..-1].chars.reverse_each do |c|\n      max_len += 1\n    end\n\
    \  end\n  \n  # Concatenate the reverse of the string prefix with the reverse\
    \ of the string suffix.\n  temp[0...max_len] + temp[max_len..-1]\nend", "  string\
    \ = string.downcase\n  suffix = find_longest_postfix_palindrome(string)\n  prepend\
    \ = string[0,suffix.size].reverse\n  new_string = prepend + string[suffix.size..-1]\n\
    \  return new_string\nend", "  return string.gsub(/([a-z])(?=([a-z]))/, '\\\\\
    1').\n             reverse.\n             gsub(/([a-z])(?!([a-z]))/, '\\\\1').\n\
    \             gsub(/([a-z])(?=\\1?$)/, '\\\\1').\n             reverse.\n    \
    \         tr('a..z','A..Z').\n             to_s\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,algorithm dscore=2 |>\nThe \"easiest\" thing would be to\
    \ convert the string to reverse:\n<code>\n\"abcdcba\".tr('abcd','cba') == \"cbab\"\
    \n</code>\nThen all that is left to do is append the two strings together:\n<code>\n\
    \"abcde\".reverse.to_s + palindrome.tr('abcd','cba').to_s\n</code>\n<|/ a |>\n\
    <| a |>\nHere is a solution which uses String#reverse and String#tr in a single\
    \ step.\n<code>", "  # Find the longest postfix string that can be made a palindrome.\n\
    \  postfix = string.scan(/\\w+/).inject(:+).reverse\n  # Find palindromic prefix\
    \ string before postfix.\n  prefix = string.scan(/\\w+/).inject(:+).reverse.prepend(postfix)\n\
    \  # Combine both palindromic prefix and postfix.\n  new_string = prefix + postfix.reverse\n\
    \  return new_string\nend", "  max_length = -1\n  length = 0\n  prefix = \"\"",
  "  max_length = 0\n  longest_postfix = ''", "  longest = find_longest_postfix_of_string(string)\n\
    \  reverse_of_longest = longest.reverse\n  result = \"\"\n  result << string <<\
    \ reverse_of_longest\n  result\nend", "  longest = find_longest_palindrome(string)\n\
    \  longest_postfix = find_longest_postfix_palindrome(string)", "  string.gsub!(/[^A-Za-z]/,\
    \ '') # Remove all non-alpha characters from the string.\n  string_reverse = string\
    \ # Reverse the string.\n  suffix_length = string.size - string.rindex(string)\
    \ # Find length of suffix.\n  suffix_palindrome = string_reverse[0..suffix_length]\
    \ # Find the longest suffix that is a palindrome.\n  suffix_palindrome.gsub!(/[^A-Za-z]/,\
    \ '') # Remove all non-alpha characters from suffix.\n  return string + suffix_palindrome\
    \ # Append suffix to string.\nend", "  palindrome = \"\"\n  suffix_length = 1\n\
    \  string = string.to_s\n  while suffix_length > 0\n    prefix_length = suffix_length\n\
    \    while prefix_length > 0\n      prefix_length -= 1\n      prefix_postfix =\
    \ string[0,prefix_length]\n      prefix_prefix_length = prefix_length - 1\n  \
    \    prefix_prefix_postfix = string[0,prefix_prefix_length]\n      # If the prefix\
    \ is palindrome\n      if prefix_postfix == prefix_prefix_postfix.to_s.reverse\n\
    \        palindrome += prefix_postfix\n        # Remove prefix from the string\n\
    \        string = string.slice(prefix_prefix_length+1)\n        break\n      end\n\
    \    end\n    suffix_length -= 1\n  end\n  palindrome\nend\n</code>\nThis solution\
    \ works for your test cases, but I believe it could be improved by looking at\
    \ the time complexity of the algorithm.\n<|/ a dscore=0 tags=palindrome,ruby,string\
    \ |>\n<| a tags=palindrome,ruby,string dscore=0 |>\nIf you're looking for something\
    \ that is fairly elegant and efficient, then I'd suggest the following:\n<code>",
  "  suffix      = string\n  longest_postfix = []\n  length       = 0", "  reverse_string\
    \ = ''\n  length = string.size\n  while length > 0\n    char = string[length -\
    \ 1]\n    \n    # If the last letter isn't a letter, find the next palindrome.\n\
    \    if !char.upcase =~ /[A-Z]/\n      next unless length >= 2\n      break\n\
    \    end", "  # Convert string into an array and reverse it for convenience\n\
    \  array = string.split(//)\n  array.reverse!\n  # Find the longest postfix that\
    \ is a palindrome - i.e. the end of a reversed string\n  longest_palindrome =\
    \ find_longest_palindrome(array)\n  # Find a prefix that comes before longest\
    \ postfix and concatenate it to our original string\n  final_string = string.insert(longest_palindrome+1,\
    \ array.join(\"\"))\nend", "  longest_postfix = find_longest_postfix_with_palindromes(string)\n\
    \  longest_postfix = longest_postfix.reverse\n  longest_postfix = longest_postfix.to_s\
    \ << longest_postfix\n  return longest_postfix\nend", "  start_index = index(string)\n\
    \  end_index = start_index + length(string.slice!)\n  if end_index >= string.length\n\
    \    return string\n  longest = string.slice!(start_index, end_index).reverse!\n\
    \  string.slice!(0, end_index) << longest\n  make_palindrome(string)\nend", " \
    \ longest_prefix_length = string.size\n  longest_prefix_length -= longest_prefix_length\
    \ % 2\n  longest_prefix_string =  \"\"\n  longest_prefix_string += string[0,longest_prefix_length]\n\
    \  longest_prefix_string += string[longest_prefix_length,string.length].to_s.reverse\n\
    \  longest_prefix_string.gsub!(/([a-z])/,'\\1')\n  longest_prefix_string.gsub!(/[^a-z]/,'')\n\
    \  return longest_prefix_string\nend", "  postfix = find_longest_palindrome(string).to_s\n\
    \  postfix.reverse!\n  postfix + find_longest_palindrome(string[0...-1].to_s).to_s\n\
    end", "  palindrome = ''\n  prefix_length = 0\n  last_char = nil\n  string.each_char\
    \ do |char|\n    char = char.downcase\n    if char == last_char\n      palindrome\
    \ += char\n      prefix_length += 1\n    else\n      palindrome += char\n    \
    \  prefix_length = 1\n      last_char = char\n    end\n  end\n  palindrome +=\
    \ string[prefix_length..-1].reverse\n  palindrome\nend", "  palindrome = \"\"\n\
    \  max_length = 0\n  min_length = string.length\n  max_length_palindrome = min_length\n\
    \  \n  # Find the longest postfix of supplied string that is a palindrome.\n \
    \ # Algorithm idea is simple:\n  # - Find the longest postfix of supplied string\
    \ that is a palindrome.\n  # - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n  (0..min_length).each do\
    \ |i|\n    max_length = i\n    length_of_prefix_of_i = string.length - (i+1)\n\
    \    while length_of_prefix_of_i > 0\n      length_of_prefix_of_i -= 1\n     \
    \ postfix_i = string[(i+1)..length_of_prefix_of_i]\n      palindrome = postfix_i\
    \ + reverse_string(postfix_i)\n      if palindrome == string\n        max_length_palindrome\
    \ = i\n        break\n      end\n    end\n  end\n  \n  return \"#{string}#{palindrome}\"\
    \nend", "  string.gsub!(/(^|\\s)([^a-zA-Z])/) {|s| $1 + s[-1,2].downcase }\n \
    \ string.gsub!(/([a-zA-Z])([^a-zA-Z])/) {|s| s[0,1] + $2 + s[-1,2].downcase }\n\
    \  string.gsub!(/([a-zA-Z])([^a-zA-Z])/) {|s| s[0,1] + $2 + s[-1,2].downcase }\n\
    \  string.gsub!(/(^|\\s)([^a-zA-Z])/) {|s| $1 + s[-1,2].upcase }\n  string.gsub!(/([a-zA-Z])([^a-zA-Z])/)\
    \ {|s| s[0,1] + $2 + s[-1,2].upcase }\n  string.gsub!(/([a-zA-Z])([^a-zA-Z])/)\
    \ {|s| s[0,1] + $2 + s[-1,2].upcase }\n  return string\nend", "  max_len = string.length\n\
    \  \n  # Look at each possible prefix to the longest postfix of string\n  i =\
    \ 0\n  while i < max_len\n    \n    suffix = string[i..-1]", "  if string == ''\n\
    \    return ''\n  strings = string.split('').reverse\n  first = strings.first\n\
    \  last = strings.last\n  if first == last\n    return first\n  end\n  postfix\
    \ = first\n  index = first.length\n  loop do\n    loop do\n      if index > strings.length\n\
    \        break\n      end\n      substring = strings[index..-1]\n      if substring\
    \ == string.reverse\n        postfix = postfix.reverse\n      end\n      index\
    \ -= 1\n    end\n    break unless postfix.start_with? first\n    first = first.slice!(0..-1)\n\
    \    postfix = postfix.reverse\n  end\n  postfix + string\nend", "\tpalindrome\
    \ = string.dup\n\tpalindrome.length = string.size - 1\n\tpalindrome = string.dup.reverse\n\
    \tpalindrome << palindrome.slice!(0...string.size)\n\treturn palindrome\nend",
  "  original_string = string.dup\n  longest_palindrome_length = find_longest_palindrome_length(original_string)\n\
    \  new_string = original_string[0...longest_palindrome_length]\n  new_string +=\
    \ original_string[longest_palindrome_length...(longest_palindrome_length + original_string.length)].reverse\n\
    \  return new_string\nend", "  max_length_palindrome_prefix_length = get_longest_palindrome_prefix_length(string)\n\
    \  new_string = string\n  new_string << reverse(new_string[0,max_length_palindrome_prefix_length-1])\
    \ # add postfix of palindromic prefix\n  new_string << reverse(new_string[max_length_palindrome_prefix_length..-1])\
    \ # add postfix of palindromic suffix\n  new_string.gsub!(/\\W/,'') # remove non-alphanumeric\
    \ characters\n  new_string.gsub!(\"!\", \"!+!\") # replace ! by !+!\n  new_string.gsub!(\"\
    ?\", \"!+?\") # replace ? by !+?\n  new_string.gsub!(\"@\", \"!+@\") # replace\
    \ @ by !+@\n  new_string.gsub!(\"$\", \"!+$\") # replace $ by !+$\n  new_string.gsub!(\"\
    %\", \"!+%\") # replace % by !+%\n  new_string.gsub!(\"^\", \"!+^\") # replace\
    \ ^ by !+^\n  new_string.gsub!(\"&\", \"!+&\") # replace & by !+&\n  new_string.gsub!(\"\
    *\", \"!+*\") # replace * by !+*\n  new_string.gsub!(\"+\", \"!+\") # replace\
    \ + by !+\n  new_string.gsub!(\"/\", \"!+/\") + new_string.gsub!(\"//\", \"!+/\"\
    ) # add / and // if necessary\n  new_string.gsub!(\",\", \"!+,\") + new_string.gsub!(\"\
    ;\", \"!+;\") # add , and ; if necessary\n  new_string.gsub!(\"|\", \"!+|\") #\
    \ add | if necessary\n  new_string.gsub!(\"(\", \"!+(\") # add ( if necessary\n\
    \  new_string.gsub!(\")\", \"!+)\") + new_string.gsub!(\")(\", \"!+(\") # add\
    \ ) and ( if necessary\n  new_string.gsub!(\"[\", \"!+[\") # add [ ] if necessary\n\
    \  new_string.gsub!(\"]\", \"!+]\") # add ] if necessary\n  new_string.gsub!(\"\
    {\", \"!+{\") # add { ] if necessary\n  new_string.gsub!(\"}\", \"!+}\") # add\
    \ } if necessary\n  new_string.gsub!(\"<\", \"!+<\") # add < if necessary\n  new_string.",
  "  result = ''\n  length = string.size\n  longest_palindromic = []\n  longest_palindromic_length\
    \ = []\n  longest_palindromic_prefix = []\n  longest_palindromic_suffix_reversed\
    \ = string.dup.reverse", "\tpostfix = find_longest(string)\n\treversed_postfix\
    \ = reverse(string,postfix)\n\tresult = string + reversed_postfix\n\treturn result\n\
    end", "    max_length = 0\n    while string != \"\"\n        # Find the longest\
    \ postfix that is a palindrome.\n        max_i = string.length - 1\n        while\
    \ max_i >= 0\n            palindrome_substring = string.slice!(0...max_i)\n  \
    \          if palindrome_substring == palindrome_substring.reverse!\n        \
    \        max_length = max_length + 1\n                break\n            else\n\
    \                max_i = max_i - 1\n        end\n        string = string.slice!(-1..-1)\n\
    \    end\n    if max_length == 1\n        postfix = string\n    else\n       \
    \ # Find the longest postfix that is a palindrome that is less than the maximum\
    \ length.\n        max_i = string.length - 1\n        while max_i >= 0\n     \
    \       palindrome_substring = string.slice!(0...max_i)\n            if palindrome_substring\
    \ == palindrome_substring.reverse!\n                break\n            else\n\
    \                max_i = max_i - 1\n            end\n        end\n        postfix\
    \ = string\n    end\n    postfix = postfix.reverse!\n    postfix = postfix.reverse!\n\
    \    postfix = postfix.reverse!\n    if postfix.length < max_length\n        postfix\
    \ = postfix.to_s + max_length.to_s\n    end\n    postfix = postfix.to_s\n    return\
    \ postfix\nend", "  string.gsub!(/[^a-z]/, '')\n  string.gsub!(/[^A-Z]/, '')",
  '  max_length = calculate_max_length(string)', "  longest = longest_palindrome(string)\n\
    \  puts \"#{string}\"\n  puts \"#{string[0,longest.size]}\"\n  puts \"#{string[longest.size..-1].reverse}\"\
    \nend", "    longest = find_longest_palindrome(string)\n    palindrome = string.chars.reverse_each.join(longest)\n\
    \    return palindrome\nend\n</code>\nSome tests:\n<code>\nmake_palindrome(\"\
    abaacd\")\n=> \"aabacd\" ", "  # No string can be palindrome.\n  return nil unless\
    \ string\n  \n  # If string is palindromic suffix of another string, return it\
    \ immediately.\n  return string if palindromic_suffix?(string)\n  \n  # If string\
    \ is palindrome of the form\n  # \"<string><postfix.reverse>\" where postfix is\
    \ palindrome, then return it.\n  if string =~ /^([a-z]+)[a-z]+([a-z]+)?$/i\n \
    \   postfix, suffix = $1, $2\n  else\n    postfix, suffix = string, \"\"\n  end\n\
    \  \n  # Find longest postfix of the form\n  # \"<string><postfix.reverse>\" where\
    \ postfix is a palindrome.\n  postfix = postfix.reverse\n  \n  # Build the palindrome\
    \ from the longest postfix of supplied string.\n  string = string.sub(/#{postfix}[a-z]+/i,\
    \ \"#{postfix}#{suffix}\")\n  \n  # Return string\n  return string\nend", "  palindrome\
    \ = string.gsub(/(.+\\D.*)(\\D.+)/) {$1 + $2.reverse}\n  return palindrome\nend\n\
    </cell>\n<cell>", "  string = (string || '').to_s\n  max_length = (string.length\
    \ / 2).ceil\n  postfix = nil\n  prefix = ''\n  max_length.times { postfix = string[(length\
    \ - max_length)*2 + max_length] }\n  postfix.upcase!\n  pref_length = len(string)\
    \ - max_length\n  string[pref_length..-1] + postfix.reverse\nend\n</code>\n<|/\
    \ a tags=string,ruby |>\n<| c |>\nThanks, this works fine for me and it's easier\
    \ to understand. I'm still a ruby noob so thanks for the help.\n<|/ c |>\n<| c\
    \ |>\nActually it's probably better to start with `postfix = string.length / 2`\
    \ and use `postfix - 1` when doing `length - max_length` since that will work\
    \ for the edge case. Also, it seems wasteful to start with `string.length / 2`\
    \ and work backwards, but I suppose it depends on the use case.\n<|/ c |>\n<|\
    \ c |>\nI agree. I've updated the answer. Thanks.\n<|/ c |>\n<| a tags=string,ruby\
    \ |>\n<code>", "  string.length < 2 ? string : \n    string << '_' << make_palindrome(string.slice!(-1)).slice!(-1)\
    \ << '_'\nend", "  palindrome = string\n  palindrome_len = string.length", " \
    \ longest = string.gsub(/([a-z])[^a-z]*?\\1/i, '')\n  longest = longest.gsub(/[^a-z]+\\\
    1/i, '').downcase\n  longest = longest.gsub(/([a-z])\\1/i, '\\1')\n  longest =\
    \ longest.gsub(/([a-z])\\1/i, '\\1')\n  longest = longest.gsub(/([a-z])\\1/i,\
    \ '\\1')\n  longest = longest.gsub(/\\1/, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/\\1/, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/\\1/, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/\\\
    1/, '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/\\\
    1/, '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/\\1/, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/\\1/, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/\\1/, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/[a-z]/i, '\\1')\n  longest = longest.gsub(/[a-z]/i,\
    \ '\\1')\n  longest = longest.gsub(/\\1/, '\\1')\n  longest = longest.gsub(/[a-z]/",
  "  reverse_prefix = reverse(string[0, string.length])\n  longest_postfix = reverse(string[0,\
    \ string.length - longest_prefix_length(string)])\n  string.insert(longest_postfix.length\
    \ + 1, reverse_prefix + longest_postfix)\nend", "  string.chars.reverse.take(string.to_s.length).join\n\
    end", "  longest, middle, beginning_of_middle = string.rpartition(string.downcase)\n\
    \  if middle == string\n    beginning_of_middle = string\n  end", "  if string.empty?\n\
    \    nil\n  else\n    prefix = reverse(string[1..-1])\n    longest = find_longest_postfix(string)\n\
    \    string[0, longest.end + longest.length] = prefix\n    string\n  end\nend",
  "  max_length = 0\n  min_length = 0\n  max_length = 0\n  min_length = 0\n  while\
    \ min_length < max_length\n    if max_length == min_length\n      max_length +=\
    \ 1\n      min_length += 1\n      continue\n    prefix = string.slice(min_length,\
    \ max_length)\n    reversed_prefix = prefix.reverse\n    if prefix.is_a? String\n\
    \      if prefix.include? reversed_prefix\n        return prefix + reversed_prefix\n\
    \      else\n        min_length += 1\n        max_length += 1\n      end\n   \
    \ end\n    min_length += 1\n    max_length += 1\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
