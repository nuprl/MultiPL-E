name: HumanEval_111_histogram
language: rb
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a dictionary\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\ndef histogram(test)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n\
  \    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2},\
  \ candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"\
  a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
  \ \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"\
  t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4},\
  \ candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\"\
  \ => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n\
  \    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"
completions: ["  a = test.split(' ').inject(Hash.new(0)){|memo, letter| memo[letter]\
    \ += 1; memo}\n  a.values.sort.reverse.to_h\nend", "  result = Hash.new(0)\n \
    \ test.split(' ').each { |x| result[x.downcase] += 1}\n  result\nend", "  letters\
    \ = test.split(' ') \n  frequency = Hash.new(0)\n  letters.each {|letter| frequency[letter]\
    \ += 1 }\n  return frequency\nend", "\tcount = {}\n\ttest.each do |x|\n\t\tx.scan(/[a-z]/).each\
    \ do |x|\n\t\t\tcount[x] ||= 0\n\t\t\tcount[x] += 1\n\t\tend\n\tend\n\tcount.each_with_index\
    \ do |letter, count|\n\t\tletter = letter.to_s\n\t\tcount = \"#{count} #{letter}\"\
    \n\t\tputs count\n\tend\nend", "    hash = {}\n    for letter in test\n      \
    \  if hash.has_key?(letter)\n            hash[letter] += 1 # Increment the count\
    \ of the key\n        else\n            hash[letter] = 1 # New key\n        end\n\
    \    end", "  letters = test.split(' ')\n  counts = Hash.new(0)\n  letters.each\
    \ do |letter|\n    counts[letter] += 1;\n  end\n  return counts\nend", "    #\
    \ your code here\n    counts = {}\n    letters = test.split(' ')\n    letters.each_index\
    \ do |i|\n        if !counts.has_key?(letters[i]) or counts[letters[i]].nil?\n\
    \            counts[letters[i]] = 0 \n        end\n        \n        counts[letters[i]]+=1\n\
    \    end\n    \n    letters.each_index do |i|\n        letter = letters[i]\n \
    \       if counts[letter].nil?\n            counts[letter] = 1\n        else\n\
    \            counts[letter]= counts[letter] + 1\n        end\n    end\n    \n\
    \    return counts\nend\n</cell>\n<code language=conda-env-py3-py>\nhistogram(\"\
    A B C D E F\")\n</cell>\n<code language=conda-env-py3-py>", "    h = {}\n    test.split.map\
    \ {|x| h[x] = 1 if h.key?(x) else 0 }.sort_by {|k,v| v}.reverse.each_with_index\
    \ do |(k,v),i|\n        if v > 0\n            puts k\n        else\n         \
    \   break\n        end\n    end\nend\n</code>\nThe code is shorter but if you\
    \ want a more detailed explanation you may refer to this post \nThe code above\
    \ is O(NlogN) instead of O(N*N), also since you don't need to modify the original\
    \ array you pass to the function, I used a block variable in the map method, this\
    \ way the function does not modify the original array.\nEdit\nHere are some test\
    \ cases for the code:\n<code>\nputs histogram('abcbcbc')", "  histogram = {}\n\
    \  test.split.each do |letter|\n    histogram[letter] ||= 0\n    histogram[letter]\
    \ += 1\n  end", "  histogram = Hash.new(0)\n  test.split(' ').each_with_index\
    \ { |value, i| histogram[value] += 1 }\n  histogram.max_by { |key, count| count\
    \ }\nend", "    count = {}\n    letters = test.scan(/[a-z]+/).flatten\n    letters.each\
    \ { |letter| count[letter] = count.has_key?(letter) ? count[letter] + 1 : 1 }\n\
    \    count.sort!\n    count.reverse!\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    Nice and clean solution. Thank you!\n<|/ c |>\n<| a dscore=2 |>\n<code>\nstring.scan(/[a-z]+/).group_by(&:itself).max_by\
    \ { |_, v| v.size }\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 tags=ruby |>\n\
    <code>", "  freq = {}\n  test.split(\"\").each do |letter|\n    freq = freq.merge(letter\
    \ => freq.fetch(letter, 0) + 1)\n  end\n  freq.sort_by { |k, v| -v }.first(2).to_a.sort_by\
    \ { |k, v| v }.first(2)\nend", "  hash = {}\n  array.split(' ').map do |i|\n \
    \   if hash[i].nil?\n      hash[i] = 1\n    elsif hash[i] < 1\n      hash[i] =\
    \ 1\n    else\n      hash[i] = hash[i] + 1\n    end\n  end\n  hash\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nthanks for the reply. I tried implementing your code\
    \ but i end up with an empty array.\n<|/ c |>\n<| c |>\nThis code runs perfectly.\
    \ Can you give me an example input string that breaks it?\n<|/ c |>\n<| c |>\n\
    I've updated the post to show an input string that breaks it.\n<|/ c |>\n<| c\
    \ |>\n: Updated the answer. Now the code does what you need. :)\n<|/ c |>\n<|\
    \ a tags=hash,arrays,ruby |>\nYou can use the following method:\n<code>", "  hash\
    \ = {}\n  test.split(\"\").each { |x|\n    if hash[x] == nil\n      hash[x] =\
    \ 1\n    else\n      hash[x] += 1\n    end\n  }\n  hash.sort_by { |k, v| -v }.to_h\n\
    end\nhistogram(\"abracadabra\")", "  hash = {}\n  test.split(' ').each do |item|\n\
    \    hash[item] = hash[item].to_i + (1 if hash[item].nil? || item.empty?)\n  end",
  "  letters = {}\n  test.split.each do |letter|\n    letter = letter.to_s.downcase\n\
    \    letters[letter] = letters[letter].to_i + 1 if letters.has_key?(letter)\n\
    \  end\n  letters = letters.sort_by {|k, v| v}.reverse\n  letters = letters.map\
    \ {|k, v| [k, v]}\nend", "  result = {}\n  test.split.each do |letter|\n    if\
    \ result.has_key?(letter)\n      result[letter] += 1;\n    else\n      result[letter]\
    \ = 1;\n    end\n  end\n  result\nend\n</cell>\n<cell>\nhistogram(test)\n</cell>\n\
    <text>\nExercise 2: Sorting", "    histo = {}\n    \n    test.split(\" \").each\
    \ do |letter| \n        if histo[letter] == nil\n            histo[letter] = 1\n\
    \        else\n            histo[letter] += 1\n        end\n    end\n    \n  \
    \  histo\nend", "    letters = {}\n    letters[:none] = 0 #This line makes sure\
    \ that any key with no letters returns the value 0\n    letters[:all] = 0\n  \
    \  letters[:lower] = 0 #This line makes sure that any key with the letter lowercase\
    \ returns the value 0\n    letters[:upper] = 0 \n    letters[:numbers] = 0", " \
    \   letters = {}\n    letters.default = test\n    letters.each { |k,v| letters[k.to_s.downcase]\
    \ = letters.default_value }\n    \n    letters.each { |k,v| letters[k.to_s.downcase]\
    \ ||= 0 }\n    letters.each { |k,v| letters[k.to_s.downcase] += v.to_i }\n   \
    \ letters.sort_by { |k,v| -v }.first\nend", "  test.tr!(' ', '').downcase!\n \
    \ count = {}\n  test.split('').each do |char|\n    count[char.to_i] = count.has_key?(char.to_i)\
    \ ? count[char.to_i] + 1 : 1\n  end\n  count.sort_by{|key, value| value}.last.last\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nVery nice. I'd have written it a bit\
    \ differently, but I'm a Python guy so I tend to avoid that sort of thing. +1\n\
    <|/ c |>\n<| a tags=ruby,regex |>\nHere's a way to do it in Ruby 1.8.7 without\
    \ splitting the string into characters, but it uses scan with a lookahead to count\
    \ characters that aren't spaces.\n<code>\nstring.gsub(/(?!\\s)/) { |x| count[x]\
    \ += 1 }.max_by { |x,v| v }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice. I've never\
    \ seen the lookahead trick. Thanks!\n<|/ c |>\n<| c |>\nThis is one of the ways\
    \ to do a negative character set match. Very nice, especially for those who are\
    \ already familiar with lookahead assertions in regexen.\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nHere's a way to do it in a single pass through the string, in Ruby 1.8.7\
    \ and above:\n<code>", "  test.each do |letter|\n    histogram[letter] += 1 unless\
    \ histogram.key?(letter)\n    histogram[letter] = 0 if histogram[letter].nil?\n\
    \  end\n  histogram.sort_by! { |k, v| -v.first }\n  return histogram\nend", " \
    \ hash = {}\n  test.each do |i|\n    count = [test.count(i)]\n    test.count(i).times\
    \ do |j|\n      test.count(i).times do |k|\n        test.count(i).times do |l|\n\
    \          count = count.push(test.count(i).times + (test.count(i).times+test.count(i).times))\n\
    \        end\n      end\n    end\n    hash[i] = count\n  end\n  hash\nend", " \
    \ # Your code here\n  counts = Hash.new(0)\n  test.each do |x|\n    counts[x]\
    \ += 1\n  end\n  sorted = counts.sort.reverse\n  result = {}\n  sorted.each do\
    \ |k, v|\n    result[k] ||= []\n    result[k] << v\n  end\n  return result\nend\n\
    histogram(\"Hello How are you Toby\")", "  histogram = Hash.new(0)\n  test.each\
    \ { |letter| histogram[letter] += 1 }\n  histogram.sort_by { |k,v| v }.reverse.to_h\n\
    end", "  result = {}\n  test.split('').map { |x| result[x] = result[x].to_i +\
    \ 1 }\n  result.max_by{ |k, v| v }\nend", "    histogram = Hash.new(0)\n    test.each\
    \ do |letter|\n        histogram[letter] += 1 unless histogram.has_key?(letter)\n\
    \    end\n    histogram.sort_by{ |k, v| -v }\nend", "    h = {}\n    t = test.split\n\
    \    a.each do |i|\n        h[i[0]] = h[i[0]].to_i + (t.count(i[0]).to_i)\n  \
    \  end\n    h\nend", "  result = {}\n  test.split(' ').each do |word|\n    word.to_s.split('').each\
    \ do |letter|\n      result[letter] ||= 0\n      result[letter] += 1\n    end\n\
    \  end\n  result\nend", "  h = Hash.new(0)\n  test.split('').each do |c|\n   \
    \ h[c] += 1\n  end\n  Hash[h.sort_by {|k, v| v}.map{|k, v| [k, v.last]}]\nend",
  "  result = {}\n  test.split\n  test.count.times do |x|\n    result.merge!({x =>\
    \ test.count(x)})\n  end\n  return result\nend\n</cell>\n<text>\nA more concise\
    \ way to implement the same is with the help of Hash#merge!:", "  test.upcase!\n\
    \  test.chars.each_with_object(Hash.new(0)) { |letter, hash| hash[letter] += 1\
    \ }\n  test.chars.map { |letter| [letter, hash[letter]] }.sort_by { |_, count|\
    \ -count }.first\nend\n</pre>", "  result = Hash.new{|h, k| h[k] = 0}\n  test.split('\
    \ ').each {|x| result[x] += 1}\n  result.max_by{|k, v| v}\nend", "  letters =\
    \ {}\n  test.split(\" \").each do |word|\n    word.split('').each do |letter|\n\
    \      letters[letter] ||= 0\n      letters[letter] += 1 if word.split('')[letter]\n\
    \    end\n  end\n  letters\nend", "    letters = test.count(\"a\")\n    if letters\
    \ > 0\n        puts \"#{test} contains #{letters} letters, that mean that they\
    \ are #{letters/test.length*100}% of all letters.\"\n    end\n    letters = test.count(\"\
    b\")\n    if letters > 0\n        puts \"#{test} contains #{letters} letters,\
    \ that mean that they are #{letters/test.length*100}% of all letters.\"\n    end\n\
    \    letters = test.count(\"c\")\n    if letters > 0\n        puts \"#{test} contains\
    \ #{letters} letters, that mean that they are #{letters/test.length*100}% of all\
    \ letters.\"\n    end\n    letters = test.count(\"d\")\n    if letters > 0\n \
    \       puts \"#{test} contains #{letters} letters, that mean that they are #{letters/test.length*100}%\
    \ of all letters.\"\n    end\n    letters = test.count(\"e\")\n    if letters\
    \ > 0\n        puts \"#{test} contains #{letters} letters, that mean that they\
    \ are #{letters/test.length*100}% of all letters.\"\n    end\n    letters = test.count(\"\
    f\")\n    if letters > 0\n        puts \"#{test} contains #{letters} letters,\
    \ that mean that they are #{letters/test.length*100}% of all letters.\"\n    end\n\
    \    letters = test.count(\"g\")\n    if letters > 0\n        puts \"#{test} contains\
    \ #{letters} letters, that mean that they are #{letters/test.length*100}% of all\
    \ letters.\"\n    end\n    letters = test.count(\"h\")\n    if letters > 0\n \
    \       puts \"#{test} contains #{letters} letters, that mean that they are #{letters/test.length*100}%\
    \ of all letters.\"\n    end\n    letters = test.count(\"i\")\n    if letters\
    \ > 0\n        puts \"#{test} contains #{letters} letters, that mean that they\
    \ are #{letters/test.length*100}% of all letters.\"\n    end\n    letters = test.count(\"\
    j\")\n    if letters > 0\n        puts \"#{test} contains #{letters} letters,\
    \ that mean that they are #{letters/test.length*100}% of all letters.\"\n    end\n\
    \    letters = test.count(\"k\")\n    if letters > 0\n        puts \"#{test} contains\
    \ #{letters} letters, that mean that they are #{letters/test.length*100}% of all\
    \ letters.\"\n    end\n    letters = test.count(\"l\")\n    if letters > 0\n \
    \       puts \"#{test} contains ", "  result = {}\n  test.downcase!\n  test.split('').each\
    \ do |e|\n    if result.has_key?(e)\n      result[e] += 1\n    else\n      result[e]\
    \ = 1\n    end\n  end\n  result.sort_by{|k, v| -v}.first\nend", "    count = Hash.new(0)\n\
    \    test.split(' ').each do |word|\n        word = word.downcase\n        count[word]\
    \ += 1 \n    end", "    chars = test.split('')\n    histo = Hash.new(0)\n    \n\
    \    chars.each{|char| histo[char] += 1}\n    histo\nend\n</pre>\n<pre>", "  \
    \  letters = {}\n    letters.default = Hash.new(0)\n    test.split(//).each do\
    \ |letter|\n        letters[letter] += 1\n    end", "    # Write your code here.\n\
    \    return nil\nend", "    counts = Hash.new{|h,k| h[k]=0 }\n    test.split('\
    \ ').each {|c| counts[c] += 1 }\n    counts.sort_by{ |k, v| -v }.first(10).map\
    \ { |k, v| [k, v ] }\nend", "    histogram = {}\n    test.downcase.split(//).each\
    \ do |item|\n        histogram[item] = histogram.has_key?(item) ? histogram[item]\
    \ + 1 : 1\n    end\n    return histogram\nend", "  test.downcase!\n  letters =\
    \ test.split\n  hash = Hash.new(0)\n  letters.each do |letter|\n    hash[letter]\
    \ += 1\n  end\n  hash = hash.sort_by {|key, value| value}.reverse\n  return hash.to_h\n\
    end", "  letters = {}\n  letters[:none] = 0 # Count the number of nones\n  letters[:all]\
    \ = test.size # Count the total number of letters\n  letters[:any] = 0 # Count\
    \ the number of anys\n  letters[:total] = 0 # Count the number of totals", " \
    \ arr = test.split(' ')\n  res = {}\n  arr.each do |item|\n    item = item.downcase\n\
    \    if res.has_key?(item)\n      res[item] += 1\n    else\n      res[item] =\
    \ 1\n    end\n  end\n  return res\nend", "  hash = {}\n  test.scan(/(\\w)/g) do\
    \ |letter|\n    if hash.has_key? letter\n      hash[letter] += 1\n    else\n \
    \     hash[letter] = 1\n    end\n  end\n  return hash\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThanks Amadan! I see that it returns a hash of letters along with their\
    \ frequencies, but how would you return the letter and it's frequency in the hash?\
    \ Also, wouldn't your solution only return a hash of letters whose frequencies\
    \ were higher than 1?\n<|/ c |>\n<| c |>\n: it only returns letters whose frequencies\
    \ were greater than 1. The answer I posted uses `Enumerable#count` to get the\
    \ most frequently occurring letter. I'll add some explanation to the answer.\n\
    <|/ c |>\n<| c |>\nPerfect! One more question, though; where does 'g' come from\
    \ in /\\w/g? I'm pretty new to regexp and Ruby, so sorry if this is a stupid question.\
    \ I've googled \"\\w\" but don't quite know what it does.\n<|/ c |>\n<| c |>\n\
    : `\\w` matches one letter from a-z, A-Z, 0-9, `_`, and `\\0`. It is the same\
    \ as `[a-zA-Z0-9_]`. You can find more info on the [Ruby docs](http://www.ruby-doc.org/core-1.9.3/Regexp.html).\n\
    <|/ c |>\n<| a |>\nI like using inject:\n<code>", "  a = test.downcase.split\n\
    \  a.map!{|i| i.split('').count}\n  a.max_by {|k,v| v}\nend\n</code></pre>", " \
    \ # Your code goes here\n  \n  h = {}\n  test.split(' ').each do |letter|\n  \
    \  letter = h[letter] ? h[letter].to_i + 1 : 1 \n    h[letter] = letter if h[letter].nil?\n\
    \  end\n  return h\nend\nputs histogram('abcde')", "    count = {}\n    letters\
    \ = test.split(' ').map { |letter| letter[0].upcase }\n    letters.each do |letter|\n\
    \        count = count.merge letter.to_i => 1\n    end\n    count\nend", "  #\
    \ +++your code here+++\n  result = {}\n  test.split('').each do |item|\n    key\
    \ = item.downcase.to_sym\n    result[key] ||= 0\n    result[key] += 1\n  end",
  "  # Write your code here.\n  hash = {}\n  test.split(' ').each do |val|\n    hash[val]\
    \ ||= 0\n    hash[val] += 1\n  end\n  hash.values.sort_by { |v| -v.to_i }.first(2)\n\
    end", "  result = Hash.new{|h, k| h[k] = 0}\n  test.split.each {|x| result[x]\
    \ += 1}\n  result\nend", "  result = Hash.new(0)\n  test.split(\" \").each do\
    \ |letter|\n    result[letter] += 1\n  end\n  return result\nend", "  if test.empty?\n\
    \    {}\n  else\n    test.chars.sort.group_by(&:itself).map { |k, g| [k, g.count]\
    \ }.max_by { |k, v| v }\n  end\nend", "  test.split(\"\").inject(0) do |sum,letter|\n\
    \    sum = sum + test.count(letter)\n  end\nend", "    histo = {}\n    words =\
    \ test.split\n    \n    words.each do |word|\n       histo[word] = histo[word]\
    \ + 1 if histo[word].nil?\n       histo[word] += 1\n    end\n    return histo\n\
    end", "  frequencies = Hash.new{|h,k| h[k]=0 }\n  test.split(//).each {|letter|\
    \ frequencies[letter] += 1 }\n  frequencies.max_by { |k,v| v }.to_h\nend", " \
    \ h = Hash.new(0)\n  test.split(//).each do |letter|\n    h[letter] += 1 if h[letter]\
    \ > 0\n  end\n  h\nend", "    letters = test.split(' ')\n    counts = Hash.new(0)\n\
    \    letters.each do |letter|\n        counts[letter] += 1\n    end\n    letters.sort!\n\
    \    letters.reverse!\n    letters.reverse!\n    letters.each do |letter|\n  \
    \      if counts[letter] > 1\n            puts letter\n            counts[letter]\
    \ -= 1\n        end\n    end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=hashmap,ruby\
    \ dscore=1 |>\nHere's a solution that doesn't involve string manipulation and\
    \ avoids any loops (which make the code slower). It also uses a regex to match\
    \ letters in any order:\n<code>", "    test = test.split(' ') #split string into\
    \ separate words\n    count = {}\n    for word in test #loop over all words\n\
    \        if word in count:\n            count[word] += 1\n        else:\n    \
    \        count[word] = 1\n    return count", "  result = {}\n  test.split(//).each\
    \ do |i|\n    if result[i.downcase] == nil\n      result[i.downcase] = 1\n   \
    \ else\n      result[i.downcase] += 1\n    end\n  end\n  return result.map { |k,\
    \ v| [k, v] }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou will probably want\
    \ to `sort` before `uniq` to keep things in the order they first appear in `test`.\n\
    <|/ c |>\n<| c |>\nThanks for pointing out the `uniq` issue.\n<|/ c |>\n<| a tags=ruby\
    \ dscore=0 |>\nA slightly different approach, without using the sort method.\n\
    <code>", "    occurrences = Hash.new(0)\n    test_array = test.split(' ').map\
    \ { |element| occurrences[element] += 1 }\n    return test_array.max_by { |key,\
    \ value| value }\nend", "  counts = {}\n  test.split('').inject(counts, :merge)\n\
    \  counts\nend", "    counts = {}\n    test.split.each do |letter|\n        letter\
    \ = letter.downcase\n        letter = letter.tr('A-Za-z','')\n        counts[letter]\
    \ ||= 0\n        counts[letter] += 1\n    end\n    test.split.each do |letter|\n\
    \        letter = letter.downcase\n        letter = letter.tr('A-Za-z','')\n \
    \       letter = letter[0]\n        counts[letter] = counts[letter].to_s if counts[letter]\n\
    \    end\n    counts\nend\n</pre>", "  stringArray = test.split(' ') \n  resultHash\
    \ = Hash.new(0)\n  stringArray.each do |item|\n    resultHash[item] += 1\n  end\n\
    \  resultHash.max_by{|k,v| v}\nend\n</pre>\n<h1>Question:</h1>\n<p>Why does the\
    \ following code not work?</p>\n<pre>", "    \n    #set an empty dictionary to\
    \ hold the letter counts\n    letters = {}\n    #split string into individual\
    \ letters\n    letters = test.split(//)\n    #count each letter in the string\
    \ and store in dictionary\n    letters.each do |letter|\n        #increment letter\
    \ count by one if the letter is already in dictionary\n        letters[letter]\
    \ = letters[letter] ? letters[letter]+1 : 1;\n    end\n    #sort dictionary keys\
    \ by alphabetical order\n    letters = letters.sort_by(&:to_s)\n    #return dictionary\n\
    \    return letters\nend", "  test_string = test.split(' ').sort\n  result = {}\n\
    \  result.merge!(Hash.new(0)).tap do |h|\n    test_string.each do |x|\n      h[x]\
    \ ||= 0\n      h[x] += 1\n    end\n  end\n  result\nend", "  hash = {}\n  test.split('').each\
    \ do |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1\n  end", "    letters\
    \ = {}\n    \n    letters.each do |letter, count|\n      letters[letter] += count\n\
    \    end\n    \n    letters\nend", "  counts = Hash.new(0)\n  test.split(' ').each\
    \ do |word|\n    counts[word] += 1\n  end", "  letters = test.split(' ')\n  result\
    \ = Hash.new(0)\n  letters.each do |letter|\n    result[letter] += 1 if result.has_key?(letter)\n\
    \  end\n  result.sort_by { |k, v| v }.reverse.each { |k, v| puts \"#{k} : #{v}\"\
    \ }\nend", "  h = Hash.new(0)\n  test.split(\" \").each do |l|\n    h.increment!(l)\n\
    \  end\n  h\nend\n</code>\nUsing a Hash to count the letters means you don't have\
    \ to do any of the other fancy string manipulations. Your code can be simplified\
    \ to this:\n<code>", "  # your code here\n  test.each_byte { |c| h[c] = 0 }\n\
    \  test.each_byte { |c| h[c] += 1 }\n  h = Hash.new(0)\n  test.each_byte { |c|\
    \ h[c] += 1 }\n  test.each_byte { |c| h[c] = h[c].max }\n  h\nend", "  result\
    \ = {}\n  test.split.map! { |letter| result[letter] ||= 0 }\n  test.split.each\
    \ { |letter| result[letter] += 1 }\n  result\nend", "  if test == nil\n    return\
    \ nil\n  else\n    letters = {}\n    test.split.each do |x|\n      letters[x]\
    \ ||= 0\n      letters[x] += 1\n    end\n    letters.to_a\n  end\nend", "  test.count\n\
    end\n</pre>\n          </div>\n          <div id=\"section-map\" class=\"section\"\
    >\n            <h2>map</h2>\n            <p>\n              Ruby has a built-in\
    \ <tt>map</tt> method for arrays that\n              creates a new array with\
    \ the results of calling its supplied\n              block on each element of\
    \ its argument array:\n            </p>\n            <pre class=\"example\">\n\
    letters = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]", "  testArr = test.split('\
    \ ')\n  result = {}\n  testArr.each do |letter|\n    if result.has_key?(letter)\n\
    \      result[letter] += 1\n    else\n      result[letter] = 1\n    end\n  end\n\
    \  result.sort_by {|k,v| -v}.inject({}) do |memo, (k, v)|\n    memo[k] = v\n \
    \   memo\n  end\nend", "  my_hash = Hash.new(0)\n  test.split().each do |word|\n\
    \    my_hash[word] += 1\n  end\n  \n  my_hash.max_by { |k,v| v }\nend", "  counts\
    \ = Hash.new(0)\n  letters = test.split\n  letters.each { |letter| counts[letter]\
    \ += 1 }\n  max_count = counts.values.max\n  counts.keys.each { |letter| counts[letter]\
    \ -= 1\n  if (counts[letter] == 0) counts.delete(letter) }\n  return [counts,\
    \ max_count]\nend\n</code>\nAnd then you call the function as follows:\n<code>\n\
    histogram(\"aabccdefff\")\n</code>\nWhich results in:\n<code>\n=> [{\"a\"=>3,\
    \ \"c\"=>4, \"f\"=>4}, 5]\n</code>\n<|/ a |>\n<| c |>\nThis doesn't return the\
    \ maximum frequency. Also, there's no need to make a new Hash every time you want\
    \ to do an operation on it: Hash#merge (which is what you're using to increment\
    \ `counts`) merges all the key/value pairs given.\n<|/ c |>\n<| c |>\nThanks for\
    \ the heads up. My intention was to use the same hash for both, but I decided\
    \ to make the distinction between an operation on the hash and one on the dictionary\
    \ to avoid confusion.\n<|/ c |>\n<| a tags=ruby |>\nThis should work:\n<code>\n\
    \"a b c d e f g h i j k l m n o p q r s t u v w x y z\".split(//).inject(Hash.new(0))\
    \ { |h, k| h[k] = h[k].to_i + 1 }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nOh, I\
    \ see where you're going with this. I was just thinking of doing it with `inject`,\
    \ but this is much cleaner. I've edited the answer to reflect this.\n<|/ c |>\n\
    <| a dscore=2 |>\nThis is another way, without using inject:\n<code>\n\"a b c\
    \ d e f g h i j k l m n o p q r s t u v w x y z\".\n  downcase.split\n    .group_by{\
    \ |e| e }\n    .map{ |k,v| [k, v.count] }\n    .sort_by{ |k,v| v }\n    .last\n\
    </code>\n<|/ a tags=ruby |>\n<| a dscore=1 tags=ruby |>\nI came up with a shorter\
    \ version of's answer which is very similar to what he had originally and just\
    \ to give it another option:\n<code>\n\"a b c d e f g h i j k l m n o p q r s\
    \ t u v w x y z\".\n  ", "    letters = {}\n    test.split(' ').each_with_index\
    \ { |letter, index| letters[letter] = letters[letter] + 1 if letters[letter] }\
    \ if letters.any?\n    letters.sort_by{|k, v| -v}.first\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| c |>\nYour code doesn't work correctly for input like `\"A\
    \ B A C\"`, because you aren't counting the duplicate letters and you are returning\
    \ the smallest count for letters with no counts, which is incorrect.\n<|/ c |>\n\
    <| a dscore=0 |>\nYou can make use of the map method and a Hash object, like this:\n\
    <code>", "  counts = {}\n  test.split(//).each do |letter|\n    if counts[letter]\n\
    \      counts[letter] += 1\n    else\n      counts[letter] = 1\n    end\n  end\n\
    \  counts\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| c |>\n`counts = test.split.each_with_object(Hash.new(0))\
    \ { |letter, count| count[letter] += 1 }`.\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ |>\nHere's a solution that is O(N^2) but only O(N) space and O(N) time.\n<code>",
  "  # your code goes here\n  return result\nend", "  hash = {}\n  test.split.each\
    \ do |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1 unless hash[letter].nil?\n\
    \  end\n  hash.values.sort_by(&:last).reverse.take(10).each do |value|\n    puts\
    \ \"#{value.last} occurs #{value.size} times\"\n  end\nend\n</code>\nOutput:\n\
    <code>\nb occurs 1 times\nd occurs 1 times\ns occurs 1 times\ne occurs 1 times\n\
    a occurs 1 times\nc occurs 1 times\nh occurs 1 times\nl occurs 1 times\nf occurs\
    \ 1 times\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYour answer can be greatly simplified\
    \ to: `test.split.map {|e| e => [e, 0]}.inject(Hash.new(0)) { |h,(k,v)| h[k] +=\
    \ 1 unless h.has_key?(k) }.sort_by{|k,v| v}.take(10).each {|(k,v)| puts \"#{k}\
    \ occurs #{v} times\"}`.\n<|/ c |>\n<| c |>\nThe OP asked for a more \"elegant\"\
    \ solution but your answer is better.  I do want to point out that in Ruby 1.9\
    \ you can do `Hash.new(0)` as an argument to `inject`.  I actually just learned\
    \ about that in a blog post last week.\n<|/ c |>\n<| c |>\nHi can you explain\
    \ what this does \"inject(Hash.new(0)) { |h,(k,v)| h[k] += 1 unless h.has_key?(k)\
    \ }\"\n<|/ c |>\n<| c |>\nIt creates a new `Hash` instance of `0` that will initialize\
    \ each key/value pair with 0 when the first key is encountered.  It then calls\
    \ `inject` on the key/value pairs.  `inject` passes the first key/value pair to\
    \ the block (`k,v`) and the result of that block is the next element in the array.\
    \  So each iteration through the `map` block will create a new key/value pair\
    \ with the current value of `k`/`v`.  When the `inject` block receives the second\
    \ key/value pair, `k`/`v` will be used as the value for the previous key.  Therefore,\
    \ `inject` is adding `1` to a previous `k` which was initialized to `0`.\n<|/\
    \ c |>\n<| c |>\nAnd since `0` already has a `has_key?` method, this is the same\
    \ as `Hash.new(0)`.\n<|/", "    test=test.downcase\n    hash={}\n    string.gsub(/[^a-z]+/)\
    \ do |letter|\n        hash[letter] ||= 0\n        hash[letter] += 1 if letter\
    \ in test\n    end\n    hash.sort_by {|k, v| -v} #sort descending by the values\n\
    end", "    hash = {}\n    for char in test.split\n        if hash[:char] > hash[:char]\n\
    \            hash[:char] +=1\n        elsif hash[:char] == hash[:char]\n     \
    \       hash[:char] +=1\n        else\n            hash[:char] = hash[:char]\n\
    \        end\n    end\n    return hash\nend", "    h = {}\n    letters = test.split(\"\
    \ \")\n    letters.each do |letter|\n        letter = letter.downcase\n      \
    \  letters = letters.count(letter)\n        if !h.has_key?(letters)\n        \
    \    h[letters] = letter\n        end\n    end\n    h.to_a\nend", "  res = {}\n\
    \  test.split('').each do |c|\n    if res.has_key?(c)\n      res[c] += 1\n   \
    \ else\n      res[c] = 1\n    end\n  end\n  res\nend", "  # Return the histogram\
    \ in dictionary form\n  # Initialize an empty dictionary\n  result = {}\n  # Parse\
    \ the string\n  letters = test.split(\" \")\n  # Iterate over the letters and\
    \ add the letter and its count\n  # to the result dictionary\n  letters.each do\
    \ |letter|\n    letter = letter.downcase\n    result[letter] = result[letter].nil?\
    \ ? 0 : result[letter] + 1\n  end\n  return result\nend", "    letters = {}\n\
    \    letters_count = test.count(' ')\n    for letter in test\n        letters[letter]\
    \ = letters[letter] + 1 if letter in letters else 1\n    end\n    letters.each_with_index\
    \ do |letter, count|\n        letters[letter] = (letters[letter] / letters_count).round(3)\n\
    \    end\n    return letters.sort_by {|k, v| -v}\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=ruby,arrays dscore=0 |>\n<code>", "    count = {}\n    test.split(' ').each\
    \ do |letter|\n        letter = letter.downcase\n        count = count[letter]\
    \ = count.has_key?(letter) ? count[letter] + 1 : 1\n    end\n    return count\n\
    end", "    hash = {}\n    list = test.split \" \"\n    letters = test\n    array.uniq(list)\n\
    \    list.each do |letter|\n        hash[letter] = list.count(letter)\n    end\n\
    \    return hash\nend", "  histo = Hash.new(0)\n  test.split().each { |x| histo[x]\
    \ += 1 }\n  histo\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  test.scan(/(\\w)\\1*/) { |x| $1 }\nend", "  test.upcase!\n  test.split\n  letters\
    \ = test.downcase.split\n  letters.group_by{|letter| letter}.max_by{|key, value|\
    \ value}\nend\n</pre>\n</div>", "  test.split('').inject({}) do |hash, (letter,\
    \ count)|\n    hash[letter] = hash[letter].to_i + count\n    hash\n  end\nend",
  "    letters = test.split(' ')\n    result = {}\n    letters.each do |letter|\n\
    \        if result.has_key?(letter)\n            result[letter] += 1\n       \
    \ else\n            result[letter] = 1\n        end\n    end\n    return result\n\
    end", "    letters = test.split(' ')\n    histo = Hash.new(0)\n    letters.each\
    \ do |letter|\n        if histo[letter] == nil\n            histo[letter] = 1\n\
    \        else\n            histo[letter] += 1\n        end\n    end\n    histo\n\
    end", "    test.split\n    result = {}\n    test.split('').each do |char|\n  \
    \      result[char] ||= 0\n        result[char] += 1\n    end\n    result.max_by\
    \ { |k, v| v }\nend\nputs histogram(\"banana\")", "  return test.chars.reduce(\
    \ {|h, c| h[c] = h[c].to_i + 1, h}).max_by { |k,v| v }\nend\n</pre>\n</div>\n\
    </div>", "  result = Hash.new(0)\n  test.split('').each { |letter| result[letter]\
    \ += 1 }\n  result\nend\n</code>\nAs for your second problem, your method works\
    \ very well for small data sets.  But what happens if the data is large?  Your\
    \ Hash object will grow indefinitely, and your memory consumption will continue\
    \ to grow.  I recommend using the following technique to handle large data sets:\n\
    <code>", "    hash.each do |letter, count|\n        hash[letter] ||= 0\n     \
    \   hash[letter] += count\n    end\n    return hash.sort_by { |k,v| v }.reverse\n\
    end", "  hash = {}\n  test.split.each {|l| hash[l] = hash[l] || 0 }\n  test.split.each\
    \ do |l| \n    hash[l] = hash[l] +1 if test.split.count(l) > 1\n  end\n  return\
    \ hash\nend", "  # your code here\nend\n</cell>\n<cell>", "  freqs = {}\n  test.split().each\
    \ do |letter|\n    freqs[letter] = freqs[letter].nil? ? 1 : freqs[letter] + 1\n\
    \  end\n  freqs.map!{|k, v| [k, v] }\n  freqs.max_by { |k, v| v }\nend", "  result\
    \ = Hash.new(0)\n  test.split(//).each do |key|\n    if result[key] > result[key\
    \ + 1]\n      result[key] = result[key + 1]\n    elsif result[key] < result[key\
    \ + 1]\n      result[key] = result[key + 1]\n    end\n  end\n  result\nend", " \
    \ result = {}\n  test.split(' ').each do |letter|\n    if letter in result\n \
    \     result[letter] += 1\n    else\n      result[letter] = 1\n    end\n  end\n\
    \  result.each do |k, v|\n    if v.length == 1\n      result[k] = v[0]\n    end\n\
    \  end\n  result\nend", "  test = test.split(' ').map{|e| e.downcase.count('a')}\n\
    \  test.each_with_object(Hash.new(0)) { |letter, counts| counts[letter] += 1 }\n\
    end", "  hash={}\n  i=0\n  for i in test.split(//)\n    if hash[i] then hash[i].count\
    \ += 1\n      else hash[i] = {count:1}\n  end\n  hash\nend\nhistogram(\"hi my\
    \ name is bob bob the bob bob the bob bob hi hi bob bob\")", "  test.upcase!\n\
    \  result = Hash.new(0)\n  test.each_byte do |c|\n    result[c] += 1\n  end\n\
    \  result.sort\nend", "    letters = \"abcdefghijklmnopqrstuvwxyz\"\n    dict\
    \ = {}\n    str.split(test)\n    letters.each do |letter|\n        dict[letter]\
    \ = dict[letter].to_i + 1 # count the occurrence\n    end\n    dict.each do |key,\
    \ value|\n        puts \"#{key} occurs: #{value} times.\"\n    end\n    puts test\n\
    end\nhistogram(\"a b d e e g h i i j j k k k l l l l l l m m n n o o p p p q q\
    \ q q q q q q q q q q r r r r r r s s t t t u u u v v w w x x x x x x x x x x\
    \ x x x x x x x x x x x y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y y\
    \ y y y y y y y y y y y y y y y y y y y y ", "  # Write your code here.\nend",
  "  # Write your code here.\nend", "  res = {}\n  test.split(' ').each do |letter|\n\
    \    if res[letter] then\n      res[letter] += 1\n    else\n      res[letter]\
    \ = 1\n    end\n  end\n  res\nend\n</code>\nThe method can then be called with\
    \ the string as the parameter:\n<code>", "  # Use a hash to store the counts of\
    \ each letter.\n  counts = {}\n  # Loop over each character in the string.\n \
    \ test.each_char do |c|\n    # Increment the count for the current letter.\n \
    \   counts[c] ||= 0\n    counts[c] += 1\n  end", "    test2 = test.split(' ')\n\
    \    test3 = test2.map!(&:downcase)\n    test4.group_by{|i| i}.map{|k,v| [k,v.count]}.max\n\
    end\n</cell>\n<cell>\nhistogram('this is a string')\n</cell>\n<cell>\nhistogram('a\
    \ B C a a b b c c c A a A B b A c A A A b a A A A a A A A a b A A a B b A A a\
    \ c A a B b A a c A a A b a a a b A a A a A a A a a B b A A a c a a B b A a B\
    \ b A a c a a B b a A b A a a c a B b A a b a A a B b A a c a a A b a B b A a\
    \ b A A A a A a c a a c A a A a B b A b a b a b a c a a A a A a a A a c a b A\
    \ a B b A a c a a A a B b A c a a b A a A a a a B b a a b a A a A a b A a b a\
    \ B b A a a A a A a b a a b a c A a a b A b a a A a B b a a c A a a a A a a c\
    \ A a c A a A a a b B b A a b A A A b a a b b A a B b a c A A a B b A a a b A\
    \ a a a A a a A a A a a a b A A a a A A b a c a A A b a A a B b a b A A a a b\
    \ a B b A a c a b A a a A a B b a a A a A a a a b A a B b a a c A a B b a c A\
    \ a a a b A a B b A a B b A a c a a B b a c A a A b a c a a A a A b a c A a b\
    \ A b A a b a b B b A a A a B b A a a b A a A A a b A a b A A A a a a A a b A\
    \ A a a c a A a b A a B b A a a a A a b A a b a B b A ", "  result = {}\n  test.split(\"\
    \ \").each do |letter|\n    count = result[:default] || 0\n    result[letter]\
    \ = count\n    count = count + 1\n  end\n  result\nend", "  result = Hash.new(0)\n\
    \  test.split('').each { |char| result[char] += 1 }\n  result.max_by { |k, v|\
    \ v }\nend\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5 |>\nIn Ruby 1.8.7+ there's\
    \ a built-in histogram method:\n<code>\nrequire 'enumerator'\nstr = 'A B C A B\
    \ C'\nHash[str.scan(/./).group_by{|c| c}.map{|k, v| [k, v.length]}]", "    # Initialize\
    \ the counter\n    counter = {}", "  hash = {}\n  test.scan(/[a-z]/).each do |letter|\n\
    \    if hash.has_key?(letter)\n      hash[letter] += 1\n    else\n      hash[letter]\
    \ = 1\n    end\n  end\n  hash.sort_by! {|k, v| -v}.first\nend\n</cell>\n<cell>",
  "  h = {}\n  test.split(' ').each{ |c| h[c] = h[c] || 0 }\n  h = h.sort_by { |k,\
    \ v| v }.reverse\n  h[0]\nend\n</pre>", "  hash = {}\n  test.split(//).each do\
    \ |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1\n  end\n  return hash\n\
    end", "  res = {}\n  test.split(//).each do |item|\n    if res[item] then\n  \
    \    res[item] += 1\n    else\n      res[item] = 1\n    end\n  end\n  res\nend",
  "    hash = {}\n    string.split(test).each do |x|\n        if hash[x] == nil\n\
    \            hash[x] = 1\n        else\n            hash[x] += 1\n        end\n\
    \    end\n    hash.sort_by { |k, v| v }.last\nend", "  test = \"the quick brown\
    \ fox jumps over the lazy dog\"\n  d = {}\n  test.split(' ').each {|word|\n  \
    \  word = word.downcase\n    if !d.has_key?(word)\n      d[word] = 1\n    else\n\
    \      d[word] += 1\n    end\n  }\n  d\nend", "    hash = Hash.new\n    hash.each\
    \ {|k, v| hash[k] = hash[k] || 1 }\n    hash.sort_by {|k, v| v}.reverse\n    hash\n\
    end", "    hash.clear\n    hash.merge!(\"A\"=>1, \"B\"=>3, \"C\"=>2, \"D\"=>1,\
    \ \"E\"=>1)\n    hash.merge!(\"B\"=>3, \"C\"=>1, \"D\"=>1, \"E\"=>3)\n    hash.merge!(\"\
    C\"=>2, \"D\"=>1, \"E\"=>2)\n    hash.merge!(\"D\"=>3, \"E\"=>3)\n    hash.merge!(\"\
    E\"=>3)\n    hash.merge!(\"F\"=>1)\n    hash.merge!(\"G\"=>2, \"H\"=>3, \"I\"\
    =>1)\n    hash.merge!(\"J\"=>1, \"K\"=>1, \"L\"=>2, \"M\"=>1)\n    hash.merge!(\"\
    N\"=>1, \"O\"=>1, \"P\"=>1, \"Q\"=>1, \"R\"=>1, \"S\"=>1)\n    hash.merge!(\"\
    T\"=>1, \"U\"=>1, \"V\"=>1, \"W\"=>1, \"X\"=>1, \"Y\"=>1, \"Z\"=>1)\n    hash.merge!(\"\
    a\"=>1, \"b\"=>2, \"c\"=>2, \"d\"=>3, \"e\"=>1)\n    hash.merge!(\"b\"=>3, \"\
    c\"=>1, \"d\"=>1, \"e\"=>3)\n    hash.merge!(\"c\"=>2, \"d\"=>1, \"e\"=>2)\n \
    \   hash.merge!(\"d\"=>3, \"e\"=>3)\n    hash.merge!(\"e\"=>3)\n    hash.merge!(\"\
    f\"=>1)\n    hash.merge!(\"g\"=>2, \"h\"=>3, \"i\"=>1)\n    hash.merge!(\"j\"\
    =>1, \"k\"=>1, \"l\"=>2, \"m\"=>1)\n    hash.merge!(\"n\"=>1, \"o\"=>1, \"p\"\
    =>1, \"q\"=>1, \"r\"=>1, \"s\"=>1)\n    hash.merge!(\"t\"=>1, \"u\"=>1, \"v\"\
    =>1, \"w\"=>1, \"x\"=>1, \"y\"=>1, \"z\"=>1)\n    hash.merge!(\"1\"=>1, \"2\"\
    =>2, \"3\"=>2, \"4\"=>2, \"5\"=>3, \"6\"=>2, \"7\"=>3, \"8\"=>3, \"9\"=>3, \"\
    0\"=>2)\n    hash.merge!(\"A\"=>1, \"B\"=>2, \"C\"=>3, \"D\"=>1, \"E\"=>1)\n \
    \   hash.merge!(\"B\"=>3, \"C\"=>1, \"D\"=>1, \"E\"=>3)\n    hash.merge!(\"C\"\
    =>2, \"D\"=>1, \"E\"=>2)\n    hash.merge!(\"D\"=>", "  letters = test.split('\
    \ ')\n  count = Hash.new(0)\n  letters.each do |letter|\n    count[letter] +=\
    \ 1 if letter =~ /[a-z]/\n  end\n  count.select { |k, v| v >= letters.count }.sort_by\
    \ { |k, v| k }\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nI like it but\
    \ for Ruby 2.1 it says it should be .map not .each and I changed Hash.new(0) to\
    \ Hash.new and it works. Thanks\n<|/ c |>\n<| c |>\nThat's because `Hash` had\
    \ a new method in Ruby 2.1, it's now `Hash.new{ |hash, key| hash[key] = 0 }`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "    letters = test.split('')\n    count\
    \ = Hash.new(0)\n    letters.each do |letter|\n        count.update_with({letter\
    \ => count[letter] + 1}).max { |a, b| b }\n    end\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nThis is my variation on the first answer above. It uses Hash::new(0)\
    \ and Enumerable#reduce:\n<code>", "  test.split('').inject(Hash.new(0)) {|h,\
    \ letter| h[letter] += 1;h}\nend\n</cell>\n<code language=conda-env-mipt-stats-py>\n\
    histogram(\"ABC\")\n</cell>\n<code language=conda-env-mipt-stats-py>\nhistogram(\"\
    ABC ABC ABC ABC\")\n</cell>\n<code language=conda-env-mipt-stats-py>\nhistogram(\"\
    ABC ABC ABC\")\n</cell>\n<code language=conda-env-mipt-stats-py>\nhistogram(\"\
    A B C A B C A B\")\n</cell>\n<text>\nFinding the maximum", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  letter_count = {}\n  test.split(' ').each do\
    \ |item|\n    letter_count[item] = letter_count.has_key?(item) ? letter_count[item]\
    \ + 1 : 1\n  end\n  letter_count\nend", "  # +++your code here+++\nend", "  words\
    \ = test.split\n  count = {}\n  letters = test.split(//).sort_by { |c| c }\n \
    \ letters.each do |letter|\n    if count[letter] > 0\n      count[letter] += 1\n\
    \    else\n      count[letter] = 1\n    end\n  end\n  letters.delete_if{ |letter|\
    \ count[letter] == 0 }\n  count\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>",
  "    letters = {}\n    array = test.split(' ')\n    array.each do |letter|\n   \
    \     letters[letter] ||= 0\n        letters[letter] += 1\n    end\n    letters.each{|key,\
    \ value| letters[key] = letters[key] }\n    letters.each {|key, value| letters[key]\
    \ = letters[key].to_i }\n    letters.sort_by{|key, value| value }.reverse\nend",
  "    dict = {}\n    test.split(' ').each do |word|\n        word_count = test.split('\
    \ ').count(word)\n        word_count.times do |i|\n            dict[i] = word\n\
    \        end\n    end\n    return dict\nend", "  letter = nil\n  count = nil\n\
    \  result = {}\n  test.each_char {|c|\n    if !result[letter] or result[letter][:count]\
    \ < count\n      letter = c\n      count = 1\n    else\n      count += 1\n   \
    \ end\n    result[letter] = { count: count }\n  }\n  return result\nend", "  counts\
    \ = Hash.new(0)\n  test.split.each do |word|\n    counts[word] += 1\n  end\n \
    \ counts\nend", "  test.chars.each_with_object(Hash.new(0)).sort_by { |c, counts|\
    \ -counts[c] }.map { |c, count| [c, counts[c]] }.max_by { |_, count| -count }\n\
    end\n</pre>", "    test.chars.map!(&:to_i)\n    test.length.times do |i|\n   \
    \     test.each_char { |x| histogram[x, i] +=1}\n    end\n    histogram.max_by{\
    \ |k, v| v}\nend\n</code>\n<|/ a dscore=0 tags=ruby,string,arrays |>\n<| c |>\n\
    It's not a good idea to name a method `histogram`. Ruby methods have a `histogram`\
    \ method and `histogram` is now part of the method name.\n<|/ c |>\n<| c |>\n\
    Honestly, I'm not sure which method would be called if you give it a string like\
    \ \"A B C\" as the argument. I suppose you could say that this is actually a method\
    \ name, but it's also a variable name. I think it's more accurate to call it `count_letters`.\
    \ The method name `histogram` might give the impression that it counts things,\
    \ while in reality it just builds the histogram.\n<|/ c |>\n<| c |>\nAlso, `count_letters`\
    \ is missing a `return` statement, which could lead to issues further down the\
    \ line. I'm not sure it's worth it to introduce a new method just to call `Hash#max_by`\n\
    <|/ c |>\n<| c |>\nI was looking at the problem and as I said, I think that the\
    \ name `histogram` should be changed to `count_letters`.\n<|/ c |>\n<| c |>\n\
    I don't see how `histogram` can count letters. I think your method will give incorrect\
    \ results when given a string with repeated letters. Try it with `\"aaaa bbb\"\
    \ ` as an argument. I think your method will give `{\"a\"=>1, \"b\"=>2}`. Whereas\
    \ it should give `{\"a\"=>2, \"b\"=>2}`. Your method will give this result because\
    \ `a.each_char.map { |c| [c, 1] }` doesn't work because you aren't passing in\
    \ the letter from the loop, you just end up passing in \"a\", which is in the\
    \ second position in the array.\n<|/ c |>\n<| a |>\nHere's one way that uses String#char\
    \ to get the characters from your string and then Array#sort_by to sort the array.\
    \ You can then Array#reverse to get them in alphabetical order. Finally, Array#inject\
    \ is used to count each letter:\n<code>\ns = \"The quick brown fox jumped over\
    \ the lazy dog\"\narr = s.chars.sort_by(&:downcase)\n        .map(&:downcase)\n\
    \        .reverse\n        .inject(Hash.new(0)) { |h,c| h[c] += 1 }\n</code>\n\
    Output\n<code>", "  return test.each_char.inject(Hash.new(0), :merge).max_by {\
    \ |k, v| v }\nend", "  result = Hash.new(0)\n  test.downcase.split(//).each do\
    \ |item|\n    result[item] += 1\n  end\n  result\nend\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB\") #=> { 'a' => 2, 'b' => 2, 'c' => 2 }\n</cell>\n<cell>\nhistogram(\"\
    AABBCCBAB", "  hash = {}\n  test.each_char.map {|letter| hash[letter] = hash[letter].zero?\
    \ ? 1 : hash[letter] + 1}\n  return hash\nend", "    letters = test.split(' ')\n\
    \    freq = {}\n    freq.default = 0\n    freq['z'] = 0\n    freq['A'] = 0\n \
    \   freq['b'] = 0\n    freq['C'] = 0\n    freq['D'] = 0\n    freq['E'] = 0\n \
    \   freq['F'] = 0\n    freq['G'] = 0\n    freq['H'] = 0\n    freq['I'] = 0\n \
    \   freq['J'] = 0\n    freq['K'] = 0\n    freq['L'] = 0\n    freq['M'] = 0\n \
    \   freq['N'] = 0\n    freq['O'] = 0\n    freq['P'] = 0\n    freq['Q'] = 0\n \
    \   freq['R'] = 0\n    freq['S'] = 0\n    freq['T'] = 0\n    freq['U'] = 0\n \
    \   freq['V'] = 0\n    freq['W'] = 0\n    freq['X'] = 0\n    freq['Y'] = 0\n \
    \   freq['Z'] = 0\n    letters.each do |letter|\n        if freq[letter] == 0\n\
    \            freq[letter] = 1\n        else\n            freq[letter] += 1\n \
    \       end\n    end\n    return freq\nend\n</code>\n<|/ q tags=ruby |>\n<| a\
    \ dscore=2 |>\nI'd suggest using Hash#merge to merge the frequencies for the letters\
    \ together - as in below. \n<code>", "  test.gsub!(' ', '') \n  test.split\n \
    \ test.each_char.inject(Hash.new(0)) { |h, c| h[c] += 1 }\n  test.chars.sort.each\
    \ { |c| h[c] }\nend", "  str.split(' ').group_by(&:itself).map{|k, v| [k, v.size]}.max_by\
    \ {|k,v| v}\nend", "  h = Hash.new(0)\n  test.split(' ').each do |letter|\n  \
    \  h[letter] += 1\n  end\n  return h\nend", "    test = test.split(//)\n    hash\
    \ = {}\n    test.each do |item|\n        hash[item] = hash[item] || 0\n      \
    \  hash[item] += 1\n    end\n    return hash\nend", "  hash = {}\n  test.split.map\
    \ do |l|\n    hash[l] = hash[l] || 0\n    hash[l] += 1\n  end\n  hash.max_by {\
    \ |k, v| v }\nend\n</code>\n<|/ a tags=ruby,string dscore=2 |>\n<| c |>\nThank\
    \ you for this. I edited the code to fix a couple bugs\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\nHere is a solution that uses a hash object to count the characters:\n<code>",
  "  return test.count('a') + test.count('e') + test.count('i') + test.count('o')\
    \ + test.count('u') # 3\nend", "    counts = Hash.new(0)\n    test.split(' ').each\
    \ do |letter|\n        counts[letter] += 1\n    end", "  count = {}\n  test.split('\
    \ ').each { |x| count[x] = count.has_key?(x) ? count[x] + 1 : 1 }\n  count.each\
    \ { |x,y| count[x] = y }\n  count = count.sort_by { |k,v| v }.reverse.to_h\nend",
  "  letters.split('').inject(Hash.new(0)) {|hash, letter| hash[letter] += 1 }\nend\n\
    histogram(\"a b c a b b b c a c\")", "  histo = {}\n  test.split(' ').each do\
    \ |letter|\n    histo[letter] = histo[letter] || 0\n    histo[letter] += 1 \n\
    \  end\n  return histo\nend", "    counts = Hash.new\n    test.split.each do |word|\n\
    \        letter = word.to_s.downcase.chars.map(&:to_i)\n        counts[letter]\
    \ ||= 0\n        counts[letter] += 1 \n    end\n    counts\nend", "\ttest = test.split()\n\
    \td = {}\n\tfor i in test\n\t\td[i] = d.has_key(i) ? d[i] + 1 : 1;\n\treturn d\n\
    end\n</cell>\n<code language=julia-0.5>\nhistogram(\"a a a a b b b b b c c c c\
    \ d d d d d d d d e e e e f f f f f f f f f f f f g g g g g g g g g g h h h h\
    \ h h h h h h h h h h h h h h h h h h i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i\
    \ i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i ",
  "    test.downcase!\n    result = {}\n    test.split('').each do |letter|\n    \
    \    if result.has_key?(letter)\n            result[letter] += 1\n        else\n\
    \            result[letter] = 1\n        end\n    end\n    return result\nend\n\
    </pre>", "  h = Hash.new(0)\n  test.split(//).each do |letter|\n    letter = letter.downcase\n\
    \    h.add(letter, h[letter] + 1) if h.has_key? letter\n  end\n  h.map {|k, v|\
    \ [k, v[0]] }\nend\n</code>\n<|/ a |>\n<| c |>\nThe last method worked for me\
    \ (on Rails 3.1). Also, I think you don't need the square brackets after `Hash.new(0)`\n\
    <|/ c |>\n<| a tags=arrays,ruby,hash |>\nHere's a one-line solution, that works\
    \ in Ruby 1.9.2 and above:\n<code>\ntest.split(//).group_by{|l| l.downcase.to_sym}.max_by(&:size).last\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThis works too:\n<code>\narr = \"\
    The quick brown fox jumps over the lazy dog\".split\nhash = Hash.new", "  letters\
    \ = test.split(//)\n  count = {}\n  letters.each { |l| letters[l] }.uniq.each\
    \ { |l| count[l] ||= 0 }.tap { |c| count[c] += 1 }\n  count\nend\n</code>\nThis\
    \ solution is O(n)\n<|/ a dscore=1 tags=hash,arrays,ruby |>\n<| c |>\nThis would\
    \ take O(n) space, which is no good. You should at least use a Hash instead of\
    \ an Array, and you should use a Hash keyed by `l` instead of iterating over the\
    \ entire array.\n<|/ c |>\n<| c |>\nYou're right, I missed that. I'll edit it.\n\
    <|/ c |>\n<| c |>\nIt's still wrong. You're counting the number of times each\
    \ letter appears. You don't need to go through the entire array just to find the\
    \ letter with most repetition. You should at least use a Hash keyed by `l` instead\
    \ of iterating over the entire array.\n<|/ c |>\n<| c |>\nSorry, I missed the\
    \ part about the counting the repetitions of letters. I have edited my answer\
    \ accordingly.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    letters = {}\n    letters.default_proc\
    \ = proc {|k, v| letters[k] += 1 }\n    test.split(//).sort_by(&:downcase).group_by(&:downcase).each{|k,\
    \ v| letters[k] = v.size}\n    letters\nend\n</cell>\n<text>\nSolution", "  result\
    \ = {}\n  test.split.each do |i|\n    if result[i[0]]\n      result[i[0]] += 1\
    \ \n    else\n      result[i[0]] = 1\n    end\n  end\n  result.sort{|a,b| b[1]\
    \ <=> a[1]}.map{|k,v| [k, v[1]]}\nend\n</code>\n<|/ a |>\n<| c |>\nIf you look\
    \ at my answer I believe it will handle all of the edge cases for you.\n<|/ c\
    \ |>\n<| c |>\nYou're right, I missed that one. I've edited my answer.\n<|/ c\
    \ |>\n<| c |>\nYour second code block is incorrect.  It is going to return a hash\
    \ which has unique keys.  If you change `result[i[0]] += 1` to `result[i[0]] =\
    \ [result[i[0]], 1]` you will return all values.  To fix it just change `result.sort{|a,b|\
    \ b[1] <=> a[1]}.map{|k,v| [k, v[1]]}` to `result.sort{|a,b| b[1] <=> a[1]}.map{|k,v|\
    \ [k, v[0]]}`.\n<|/ c |>\n<| c |>\nYes I tested my code and it works, I forgot\
    \ that my initial solution was just returning the count\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is another solution that I believe is more readable (and thus more\
    \ efficient):\n<code>", "    letters = {}\n    chars = [x for x in test.split()\
    \ if x.isalpha()]\n    chars.each { |x| letters[x] = letters[x].to_i + 1 }\n \
    \   letters.sort_by{|k,v| v}.reverse.to_h\n  end\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\n<code>", "  counts = Hash.new(0)\n  test.split('').each do |char|\n    counts[char]\
    \ += 1\n  end\n  Hash[counts.sort_by { |k,v| -v }.map { |k,v| [k,v] }]\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\nHere is a solution based on a Hash\
    \ that will print out both counts and letters.\n<code>", "    chars = test.split('')\
    \ # Convert the string to an array\n    count = {}\n    \n    # Count the characters\
    \ by using count of each character in test.\n    # If the key is not in the dictionary,\
    \ add the character.\n    # If the key is in the dictionary, increment the count.\n\
    \    # Return the count of each character.\n    chars.each do |char|\n       \
    \ count[char] ||= 1\n        count[char] += 1\n    end\n    \n    # Return the\
    \ key with the highest count. \n    count.max_by { |key, count| count }\nend",
  "  hash = {}\n  str.split(test.downcase).each do |letter|\n    hash.update!(letter\
    \ => hash[letter] || 0+1)\n  end\n  hash\nend\n</pre>", "  hash = {}\n  test.split('\
    \ ').each do |i|\n    hash[i.downcase] ||= 0\n    hash[i.downcase] += 1\n  end\n\
    \  hash\nend", "  # TODO: Finish the code\nend\n</pre>", "  test.downcase!\n \
    \ letters = test.split\n  frequencies = Hash.new(0)\n  letters.each do |letter|\n\
    \    frequencies[letter] += 1 if frequencies[letter].nil? || frequencies[letter]\
    \ == 0\n  end\n  letters.each do |letter|\n    frequencies[letter] = frequencies[letter].to_i\n\
    \  end\n  frequencies.sort_by {|k, v| v}.last.to_h\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis solution works well, but it is too slow in my test cases.\
    \ It is pretty much same as the other solutions. So I decide to give up this solution.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,ruby-on-rails,arrays,ruby-on-rails-3 |>\n<code>",
  "  result = []\n  letters = test.split(' ').sort { |a, b| b <=> a }\n  letters.each\
    \ do |letter|\n    letter = letter.downcase\n    if letters.count(letter) > result.count\
    \ { |x| x[:count] } # update count\n      result << {:letter => letter, :count\
    \ => letters.count(letter)}\n    end\n  end\n  result\nend", "  a = test.split.map\
    \ { |s| s.downcase }.inject(Hash.new(0)) { |m,v| m[v] += 1; m }\n  a.sort.reverse_each\
    \ { |k,v| a[k] = a[k] }\n  a\nend", "  hash = {}\n  test.split(//).each do |element|\n\
    \    hash[element] = hash[element].to_i + 1 unless hash[element].nil?\n  end\n\
    \  hash\nend\n</cell>\n<text>\nEx 1: Write a function that takes in a string as\
    \ an argument and returns the most frequent character in this string.", "  letters,\
    \ result = Hash.new, Hash.new\n  test.split().each do |letter|\n    letters[letter]\
    \ ||= 0\n    letters[letter] += 1\n  end\n  letters.to_a.sort_by { |k, v| v }.last\n\
    end", "  # Solution 1\n  hash = {}\n  test.each do |c|\n    hash[c] = hash[c].nil?\
    \ ? 1 : hash[c] + 1\n  end\n  hash.max_by {|k,v| v}\n  # Solution 2\n  Hash[test.group_by\
    \ {|c| c}.max_by {|k,v| v}.map {|k,v| [k,v]}]\nend\n</pre>\n            </div>\n\
    \          </section>\n          <section>\n            <h2>Destructive update</h2>\n\
    \            <div>\n              <pre class=\"prettyprint lang-js linenums\"\
    >\n// Destructive update.\nlet a = [1,3,5,7,9,8,3,7,9,8,1]\nlet b = [7,4,5,7,1,3,5,7,4,5,7]",
  "  count = {}\n  test.split(' ').each do |letter|\n    count[letter] = count.has_key?(letter)\
    \ ? count[letter] + 1 : 1\n  end\n  count\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h, x| h[x] += 1; h }\nend", "  test.each_char.inject(Hash.new(0)) { |h,c|\
    \ h[c] += 1 }\n  test.size.times.reduce(Hash.new(0)) { |h,c| h[c] += test.count(c)\
    \ }\nend\n</code>\nOutput:\n<code>\np histogram('abracadabra') #=> {\"a\"=>3,\
    \ \"b\"=>2, \"c\"=>1}\n</code>\n<|/ a dscore=1 tags=ruby,string |>\n<| c |>\n\
    Thank you for this solution! I see that for Ruby 1.8.7 `inject` is not a method\
    \ and can be replaced using `inject{|a,b| [a,b].inject{|a,b| a + b}}` which seems\
    \ more readable.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  hash = {}\n\
    \  test.split(\" \").each do |letter|\n    if hash[letter]\n      hash[letter]\
    \ += 1 \n    else\n      hash[letter] = 1\n    end\n  end\n  return hash\nend",
  "  test.downcase!\n  test.gsub!(\" \", \"\").split(\"a..z\").inject(Hash.new(0))\
    \ { |h,v| h[v] += 1; h }\nend\n</code>\n<|/ a |>\n<| c |>\n`test.gsub!(\" \",\
    \ \"\").split(\"a..z\").inject(Hash.new(0)) { |h,v| h[v] += 1; h }` is a nice\
    \ way to do it, but you might also want to `downcase` the test string to take\
    \ care of capitalization issues.\n<|/ c |>\n<| c |>\n: Good point, I hadn't thought\
    \ of that. I'll edit the answer. As far as I know, it's impossible to avoid capitalization\
    \ issues with Ruby's `String` class.\n<|/ c |>\n<| c |>\nI think that's the solution.\
    \ I am just trying to understand how it works, I cannot understand how this is\
    \ called or how the syntax works.\n<|/ c |>\n<| c |>\n: I've added a more detailed\
    \ explanation.\n<|/ c |>\n<| a tags=ruby |>\nI believe this would be the Ruby\
    \ way to do it:\n<code>", "  letters = {}\n  letters.default = 0\n  letters.merge!\n\
    \  test.split(\" \").each do |letter|\n    letters[letter] += 1 if letters[letter]\n\
    \  end\n  letters\nend\n</code>\nI then refactored your code to use this new function,\
    \ and got this:\n<code>", "    count = {}\n    string.split(' ') do |word|\n \
    \       count[word] = count.fetch(word, 0) + 1\n    end\n    count.sort_by{|k,\
    \ v| -v}.first\nend\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadabra\
    \ abracadabra\")\n</cell>\n<cell>\nhistogram(\"abracadabra abracadabra abracadab",
  "  h = Hash.new(0)\n  test.split(' ').each do |letter|\n    h.store(letter, 1)\n\
    \  end\n  h.to_a.reduce(Hash.new(0)) { |acc, (k, v)| acc[k] = v if v > acc[k]\
    \ }\nend", "  result = {}\n  test.split('').sort.inject(0) do |sum, char|\n  \
    \  result[char] = 0 if result.has_key?(char)\n    result[char] += 1\n    sum +\
    \ result[char]\n  end\n  result.sort_by {|k,v| v}.reverse\nend\n</pre>", "   \
    \ # Initialize counters dictionary.\n    counters = Hash.new(0)", "    counts\
    \ = {}\n    letters = test.split(' ') \n    letters.each do |letter|\n      counts[letter]\
    \ ||= 0\n      counts[letter] += 1\n    end\n    return counts\nend", "  result\
    \ = {}\n  words = test.split(' ')\n  \n  words.each do |word|\n    letters = word.split('')\n\
    \    letters.each do |letter|\n      result[(letter)] ||= 0\n      result[(letter)]\
    \ += 1\n    end\n  end\n  \n  result\nend", "  histo = {}\n  test.split(' ').each\
    \ do |letter|\n    histo[letter] = histo[letter].to_i if histo[letter].to_i >\
    \ 0\n    histo[letter] += 1\n  end\n  histo\nend\nhistogram('ab ab bb bb ba aa\
    \ ab ab bb bb ba aa ab ab bb bb ba aa ab ab bb bb ba aa ab ab bb bb ba aa ab ab\
    \ bb bb ba aa ab ab bb bb ba aa ab ab bb bb ba aa')", "  hash = {}\n  test.split('\
    \ ').each do |i|\n    hash[i.downcase] ||= 0\n    hash[i.downcase] += 1\n  end\n\
    \  hash\nend", "    letters = test.split(\" \")\n    histo = {}\n    letters.each\
    \ do |letter|\n        if !histo[letter] \n            histo[letter] = 1 \n  \
    \      else\n            histo[letter] += 1 \n        end\n    end\n    return\
    \ histo\nend\n</code>\n<|/ a |>\n<| c |>\nHi Matt! Thanks for your help! I've\
    \ added my code into the original post. Sorry about that!\n<|/ c |>\n<| c |>\n\
    Hi Matt! Thanks for your help! I've added my code into the original post. Sorry\
    \ about that!\n<|/ c |>\n<| c |>\nJust so you know, Matt's code doesn't count\
    \ the numbers of spaces, and doesn't return the max value it finds.\n<|/ c |>\n\
    <| c |>\n, I've added a version that returns the highest value it finds, although\
    \ I haven't tested it.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>", "\tletters\
    \ = test.split(' ')\n\t\n\thash = {}\n\t\n\tfor i in letters\n\t\tletter = i[0]\n\
    \t\toccurrences = hash[letter]\n\t\t\n\t\tif occurrences == nil\n\t\t\thash[letter]\
    \ = 1 \n\t\telse\n\t\t\thash[letter] += 1\n\t\tend\n\tend\n\t\n\treturn hash\n\
    end\n---", "  # Solution\n  test.scan(/./).group_by { |x| x }.each_with_object(Hash.new(0))\
    \ { |(k,v),h| h[k] = v.size }.max_by { |k,v| v }\nend\n</pre>\n</div>\n</div>\n\
    <div id=\"outline-container-sec-1-5\" class=\"outline-3\">\n<h3 id=\"sec-1-5\"\
    >5. The first five words of \"The Cat in the Hat Problem\"</h3>\n<div class=\"\
    outline-text-3\" id=\"text-sec-1-5\">\n<p>\nThe first five words of \"The Cat\
    \ in the Hat Problem\" are:\n</p>\n<pre class=\"example\">\nthe cat\nin the\n\
    hat problem\n</pre>", "  # Split test string into array of letters by splitting\
    \ on space\n  letters = test.split(' ')\n  # Use each letter and initialize a\
    \ blank hash key with an empty array value\n  result = Hash.new()\n  # Iterate\
    \ over the letters and increment the count for the letter in the hash\n  letters.each\
    \ { |letter| result[ letter ] += 1}\n  # Return result\n  result\nend", "    count\
    \ = {}\n    test.gsub(/[a-z]/){|x| count[x] ||= 0} \n    count.keys.sort.map {|x|\
    \ [x, count[x]]}.max_by { |_, count| count }\nend", "  h = {}\n  test.split('\
    \ ').each do |letter|\n    letter = letter.downcase\n    letter = h[letter] ||=\
    \ []\n    letter << 1\n  end\n  h\nend", "  counts = Hash.new(0)\n  test.split('').each\
    \ do |letter|\n    counts[letter] += 1 if counts.has_key?(letter)\n  end\n  counts\n\
    end", "  letters = {}\n  letters.default_proc = proc { |key| 0} unless letters.respond_to?\
    \ :default_proc=\n  test.split.each do |letter|\n    if letters[letter] > 1\n\
    \      letters[letter] += 1\n    else\n      letters[letter] = 1\n    end\n  end\n\
    \  letters\nend", "    # Write your code here.\n    return {}\nend", "    count\
    \ = {}\n    text.gsub!(\" \",\"\")\n    letters = text.split(\"\")\n    letters.each\
    \ do |l|\n        if count[l].nil? or count[l] < 1\n            count[l] = 1\n\
    \        else\n            count[l] += 1\n        end\n    end", "  # ...\nend\n\
    </pre>\n</div></div><br class=\"example-break\" />\n</div>\n<div id=\"postamble\"\
    \ class=\"status\">\n<p class=\"author\">Author: Rafael A. Rivera | Contact: <a\
    \ href=\"https://github.com/rivera\">https://github.com/rivera</a>.</p>\n<p class=\"\
    date\">Created: 2019-01-13 12:27</p>\n<p class=\"validation\"><a href=\"http://validator.w3.org/check?uri=referer\"\
    >Validate</a></p>\n</div>\n</body>\n</html>", "    occurrence = {}\n    test.split.each\
    \ do |word|\n      occurrence[word] = occurrence[word] ? occurrence[word]+1 :\
    \ 1\n    end\n    occurrence.each do |word, count|\n      puts \"#{word} occurs\
    \ #{count} times.\"\n    end\n    occurrence\nend\n</code>\n<|/ a tags=ruby dscore=2\
    \ |>\n<| c |>\nThanks but I didn't try it because I'm sure I'll try it out tomorrow,\
    \ will tell you how it went.\n<|/ c |>\n<| c |>\nThis is pretty cool! However,\
    \ can you make it into a function?\n<|/ c |>\n<| c |>\nyes I will, give me a few\
    \ minutes!\n<|/ c |>\n<| c |>\nI fixed the problem, thanks very much! I never\
    \ would have thought to use `Array#group_by!`\n<|/ c |>\n<| a tags=ruby dscore=1\
    \ |>\nHere is a little method that does what I think you want:\n<code>", "  if\
    \ test.nil? or test.empty?\n    return {}\n  end", "    # implement here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
