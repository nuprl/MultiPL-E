name: HumanEval_84_solve
language: rb
prompt: "# Given a positive integer N, return the total sum of its digits in binary.\n\
  # Example\n# Variables:\n# @N integer\n# Constraints: 0 \u2264 N \u2264 10000.\n\
  # Output:\n# a string of binary number\ndef solve(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"1\", candidate.call(1000))\n\
  \    assert_equal(\"110\", candidate.call(150))\n    assert_equal(\"1100\", candidate.call(147))\n\
  \    assert_equal(\"1001\", candidate.call(333))\n    assert_equal(\"10010\", candidate.call(963))\n\
  \  end\nend\n"
completions: ["  x = n.to_s(2).reverse\n  y = (x.split(//)).map(&:to_i).inject(:+)\n\
    \  y.to_s(2)\nend", "  str = n.to_s(2)\n  sum = 0\n  str_length = str.size\n \
    \ while str.length > 0\n    sum += str.to_i(2).to_s(2).chars.reduce(:+)\n    str\
    \ = str[(str_length-- - 1)..-1]\n  end\n  return sum.to_s(2)\nend", "    if n\
    \ < 0\n        return nil\n    end\n    \n    sum = String::new('')\n    digits\
    \ = [n].to_i\n    \n    # Loop through the digits in reverse.\n    for i in 0...digits.length\n\
    \        if i == 0\n            sum << digits[i]\n        else\n            digits[i]\
    \ -= 1\n            sum << digits[i]\n        end\n    end\n    return sum\nend",
  "  n = n.to_s\n  sum = \"\"\n  while n\n    remain = n & 0b11\n    sum = \"0#{sum}#{remain}\"\
    \n    n >>= 4\n  end\n  return sum\nend", "  ans = \"\"\n  while n > 0\n    str\
    \ = n.to_s(2).reverse.to_i(2).to_s(2)\n    ans += str\n    n -= str.length\n \
    \ end\n  return ans\nend", "  return n.to_s(2)\nend\n</cell>\n<cell>\nputs solve(151)\n\
    </cell>\n<text>\nExercise\nGiven a positive integer N, return the number of leading\
    \ zeroes in binary representation of N.", "  binary = n.to_s(2)\n  total = nil\n\
    \  n.times do |i|\n    digit = binary[i]\n    total += digit.to_i\n  end\n  total\n\
    end", "  str = n.to_s(2)\n  sum = 0\n  for i in str\n    sum += i.to_i(2).to_s(2)\n\
    \  end\n  return sum.to_s\nend", "  s = \"\"\n  for i in (1..n).to_a\n    s +=\
    \ i.to_s(2) + \"\\n\"\n  end\n  return s\nend", "  # your solution here\nend",
  "    sol = ''\n    while n > 0\n        sol = sol + dec(n % 2) + sol\n        n\
    \ = n / 2\n    return sol\nend", "    digits = n.to_s(2).split('')\n    digits.collect!\
    \ do |d|\n        d == '1' ? 1 : 0\n    end\n    digits.inject(0) {|sum, d| sum\
    \ + d}\nend", "    ones = (\"1\" * n).chars.map { |char| char == \"1\" ? \"1\"\
    \ : \"0\" }\n    return ones * n\nend", "  total = 0\n  while n > 0\n    digit\
    \ = n % 10\n    total += digit * digit\n    n = n / 10\n  end\n  return total\n\
    end", "    sum = \"\"\n    i = 0\n    while i < n\n      sum += \"1\"\n      i\
    \ += 1\n    return sum\nend", "    total = 0\n    digits = n.to_s(2).split('')\n\
    \    digits.each do |x| total += (x % 2).to_i * (2 ** digits.length - 1)\n   \
    \ end\n    return total.to_s(2).rjust(8, '0')\nend\n</code>\n<|/ a dscore=1 tags=ruby,algorithm,performance\
    \ |>\n<| c |>\nThis was really helpful! It's not quite as elegant as I'd hoped\
    \ but it's definitely much simpler. I just needed to know how to use `each` without\
    \ having it return an array.\n<|/ c |>\n<| a tags=ruby,algorithm,performance dscore=0\
    \ |>\nTry this:\n<code>", "  i = 2\n  sum = 0\n  while i < n\n    sum += i #(n\
    \ / i / 2).to_i\n    i += 1\n  end\n  return sum.to_s\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby,sum,ruby-on-rails |>\n<| c |>\nThis is also a correct answer. I don't\
    \ know why this one was downvoted. Maybe because it was posted in 2011?\n<|/ c\
    \ |>\n<| c |>\nThis solution is too much inefficient in terms of processing and\
    \ will crash on larger numbers. You need to use a string based solution instead.\
    \ Using a variable length string will require lots of memory and will therefore\
    \ take up lots of time processing large numbers. My solution requires no extra\
    \ memory and runs very quickly\n<|/ c |>\n<| c |>\nI have found a more efficient\
    \ solution that is still O(N)\n<|/ c |>\n<| c |>\nYour solution is O(n) but with\
    \ less efficiency then mine. My solution is O(1) which reduces the number of variables\
    \ involved. I am not that concerned about efficiency at this point. This solution\
    \ is more readable, concise, and easier to maintain then the previous one. My\
    \ solution is just more rubyish.\n<|/ c |>\n<| a tags=ruby,sum,ruby-on-rails |>\n\
    If you must convert a number to a string, I suggest using the built in to_s method\
    \ for String. \n<code>", "    s = \"0\"\n    i = 0\n    while i < n\n      s +=\
    \ \"1\"\n      i += 1\n    s *= \"1\"\n    s -= \"1\"\n    return s\n  end\n \
    \ \n  # Variables\n  # N: integer\n  # M: integer\n  # Output: string\n  def solve(N,\
    \ M)\n    s = 0\n    m = 1\n    while m <= M\n      s << solve(N % m)\n      N\
    \ = N / m\n      m += 1\n    end\n    s\n  end\nend", "    return n.to_s(2).reverse.gsub(\"\
    1.\",\"0\").reverse\nend", '  return n.to_s(2) if n > 0 ', "  if n < 10 \n   \
    \ return n.to_s(2)\n  \n  sum = 10\n  \n  while n > 0\n    sum += n % 2\n    n\
    \ = n / 2\n  end\n  return sum.to_s(2)\nend", "  s=n.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  s=s.to_s(2).split(\"\").map(&:to_i).reduce(:+)\n  return s\nend\n</cell>\n\
    <text>\nPart IV - Difficulty", "    num = 0\n    sum = \"\"\n    while n > 0\n\
    \        num = num + (n % 2)\n        n = n / 2\n    sum = (num % 2).to_s + sum\n\
    \    return sum\nend", "    sol = n.to_s(2)\n    while sol.length < 10\n     \
    \   sol = \"0\" + sol\n    sol\nend\n</cell>\n<cell>", "  result = '1'\n  while\
    \ n > 0 do\n    tmp = n % 2\n    result += \"0\" if tmp == 0 else \"1\"\n    n\
    \ = n / 2\n  end\n  result\nend", "  return n.to_s(2).reverse.gsub(/../, \"\"\
    ).split(//).reduce(:+)\nend", "    sum = \"0\"\n    for i in (1...n)\n       \
    \ sum << i\n    end\n    sum.to_i\nend", "  return n.to_s(2)\nend", "  result\
    \ = \"\"\n  digits = n.to_s.split(\"\")\n  for i in 0..digits.length - 1\n   \
    \ if digits[i] < 10\n      result += \"#\" + digits[i].to_s\n    else\n      result\
    \ += \"#\" + digits[i].to_s + \".\" + digits[i + 1].to_s\n    end\n  end\n  return\
    \ result\nend", "  # write your code here\n  s = \"\"\n  while n > 0\n    s +=\
    \ \"0\" * (n % 2) + \"1\" * (n /= 2)\n  end\n  return s\nend", "    s=\"\"\n \
    \   while(n>0)\n       s=(n%2)*s+(n // 2).to_s\n       n=n>>1\n    return s\n\
    end", "    \n  end\nend", "  return n.to_s(2)\nend", "  # your code\n  return\
    \ \"0b\" + n.to_s(2).count(\"1\").to_s(2) + n.to_s(2).count(\"0\").to_s(2)\nend\n\
    </cell>\n<cell>", "  sum = 1\n  while n > 0\n    sum = sum * 10 + n % 2\n    n\
    \ = n / 2\n  end\n  return sum.to_s\nend", "    sum = \"\"\n    while n > 0\n\
    \        sum = sum.to_s + n.to_s(2).reverse.chars.join('')\n        n -= 1\n \
    \   end\n    return sum\nend", "\tsum = 0\n\twhile n > 0\n\t\tsum = sum + n %\
    \ 2\n\t\tn = n / 2\n\tend\n\tputs \"#{sum}\"\nend", "  return n.to_s(2).reverse.gsub(/(.)(.)/,\
    \ '\\1'.*($&.length).to_s + \\2').to_i\nend", "  sum = 0\n  while n > 0\n    sum\
    \ += n % 2\n    n /= 2\n  end\n  sum.to_s\nend", "    sum = 0\n    i.times do\n\
    \        sum += n % 10\n        n /= 10\n    return sum.to_s\nend\n</cell>\n<code\
    \ language=julia-1.0>\nsolve(10)\n</cell>\n<text>\nProblem 3", "  if n <= 0\n\
    \    return \"0\"\n  digits = n.to_s(2)\n  sum = digits.to_i(2).to_s(2).reverse.gsub(/(..)\\\
    1*/, '\\1').tr(\"0\", '1')\n  return sum\nend\n</cell>\n<code language=julia-1.0>\n\
    solve(12345)\n</cell>\n<text>\nPractice 3\nThe sum of the digits in the number\
    \ $N$ is $N=10^2 + 10^1 + 10^0 + 10^(-1)$.", "  result = ''\n  while( n != 0 )\n\
    \    result += n%2\n    n /= 2\n  result.reverse\n  return result\nend", "  return\
    \ n.to_s.reverse.scan(/.{1,7}/).map { |s| s.reduce(:+) }.reverse.join.scan(/.{1,7}/).sum\n\
    end\n</code>\n<|/ a tags=ruby,math,algorithm dscore=2 |>\n<| a |>\nI know this\
    \ post is old and solved already, but since nobody has mentioned it, here is a\
    \ solution that solves the original problem more efficiently - without having\
    \ to reverse the string to find the sum.\nThe general idea is to first reverse\
    \ the string and find the sum of the digits, and then reverse the sum again to\
    \ find the binary representation.\n<code>", "  s=0\n  i=1\n  while i<=n\n    s=s+i\n\
    \    i*=10\n  end\n  puts s\nend\n</code>\n<|/ a tags=ruby,binary,sum,algorithm\
    \ |>\n<| c |>\nThis is the best solution. Except it returns a string rather than\
    \ an integer which makes it more difficult to call a method that prints the sum\
    \ for you.\n<|/ c |>\n<| c |>\nYes, this returns string instead of int. It can\
    \ be easily changed to. `puts s.to_i`\n<|/ c |>\n<| c |>\nThe proposed solution\
    \ produces a string containing all of the binary digits and then sums those. \
    \ That makes it difficult to call a method that prints the sum for you.  It would\
    \ be best to convert the result to an integer, but that would also require parsing\
    \ the string and summing the digits.\n<|/ c |>\n<| c |>\nThat is true. Convert\
    \ to integer will also require parsing the string.\n<|/ c |>\n<| c |>\n, The question\
    \ specifies \"sum of digits\" as opposed to \"sum of binary digits\".  How would\
    \ you parse the string when the sum is simply the length of the string?\n<|/ c\
    \ |>\n<| a tags=ruby,binary,sum,algorithm |>\nHere's my solution:\n<code>", " \
    \ str = \"\"\n  while n > 0\n    str, n = get_binary(n, str)\n  end\n  str\nend",
  "    # Your code here\n    if n < 10\n        return \"0b\" + n.to_s(2)\n    res=[]\n\
    \    while n > 0\n        res, n = res, n/10\n        res<<\"0b\"+n%10\n    return\
    \ res\nend", "  return n.to_s(2).reverse.to_i(2).inject(:+).to_s(2)\nend", " \
    \ binary = n.to_s(2).reverse\n  result = ''\n  while binary.length >= 1\n    result\
    \ << binary[binary.length - 1]\n    binary = binary[0...-1]\n  end\n  result\n\
    end", "  if n < 0\n    return \"-1\"\n  else\n    sum = 0\n    while n != 0\n\
    \      sum += n % 10\n      n = n / 10\n    return sum.to_s.reverse\n  end\nend",
  "  a = n.to_s(2)\n  b = a.reverse\n  c = 0\n  while (b != \"\")\n    if b.include?(\"\
    0\")\n      c = c + b.count(\"0\") + b.count(\"1\")\n      b = b[1..-1]\n    elsif\
    \ b.include?(\"1\")\n      c = c + b.count(\"0\") - b.count(\"1\")\n      b =\
    \ b[1..-1]\n    else\n      break\n    end\n  end\n  c = c.to_i\n  a.length ==\
    \ c ? \"#{a}\" : \"0\"\nend", "  return n.to_s(2).reverse.gsub(/../) { |char|\
    \ char.eql?('1') ? '' : char }\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,regex\
    \ |>\nI came up with a nice solution using gsub! (gsub! is similar to gsub, except\
    \ that gsub replaces the matched string, whereas gsub! modifies the original string\
    \ instead).\nThe idea behind it is to first reverse the string and then, for each\
    \ character in the string, check if the character is a 1 or not. If it is, we\
    \ replace it with empty string.\n<code>", "    n.to_s(2)\nend", "  \nend", " \
    \ sum = []\n  while n > 0\n    sum << n % 10\n    n /= 10\n  end", "  total =\
    \ 0\n  while n > 0\n    total = total + n % 10\n    n = n / 10\n  while total\
    \ > 1\n    total = total / 10\n  puts \"#{total}\"\nend", "  result = ''\n  while(n>0)\n\
    \    result << n % 2\n    n /= 2\n  return result.reverse\nend", "  sum = \"\"\
    \n  n.times do |x|\n    sum << \"1\" + sum[1..-1] if sum.length % 2 == 0\n   \
    \ sum << \"0\" + sum[1..-1] if sum.length % 2 == 1\n  end\n  return sum\nend",
  "    if n < 0\n        return nil\n    end\n    sum = \"\"\n    while n > 0\n  \
    \      sum << n % 10\n        n /= 10\n    end\n    sum.reverse\nend", "  # write\
    \ your code here\n  result = ''\n  while n > 0\n    result = result.to_s + n.to_s(2)\n\
    \    n -= 1\n  end\n  return result\nend", "    sum = 0\n    while (n > 0)\n \
    \       sum = sum + n % 2\n        n = n / 2\n    return sum.to_s\nend", "  if\
    \ n == 0 then return \"0\"\n  if n == 1 then return \"1\"\n  if n & 1 == 1 then\
    \ return solve(n/2) + solve(n&~1)\n  else\n    return solve((n-1)/2) + solve(n&~1)\n\
    \  end\nend", "  a = \"1\" * n\n  b = a.gsub(/\\d/, '').to_i\n  c = b.to_s(2).reverse.tr(\"\
    011\", \"1111\").to_s.reverse\n  d = c.gsub(/\\d/, '').to_i\n  e = \"1\" + d +\
    \ \"0\"\n  f = e.gsub(/\\d/, '').to_i\n  g = f.to_s(2).reverse.tr(\"0110\", \"\
    111110\").to_s.reverse\n  h = g.gsub(/\\d/, '').to_i\n  i = h.to_s(2).reverse.tr(\"\
    011110\", \"1111110\").to_s.reverse\n  j = i.gsub(/\\d/, '').to_i\n  k = j.to_s(2).reverse.tr(\"\
    0111110\", \"11111110\").to_s.reverse\n  l = k.gsub(/\\d/, '').to_i\n  m = l.to_s(2).reverse.tr(\"\
    01111110\", \"1111111110\").to_s.reverse\n  n = m.gsub(/\\d/, '').to_i\n  o =\
    \  n + n\n  p =  o.to_s(2).reverse.tr(\"01111111110\", \"11111111110\").to_s.reverse\n\
    \  q = p.gsub(/\\d/, '').to_i\n  r = q.to_s(2).reverse.tr(\"011111111110\", \"\
    111111111110\").to_s.reverse\n  s = r.gsub(/\\d/, '').to_i\n  return s\nend",
  "    digits = []\n    binary = \"\"", "  x = n.to_s(2)\n  return x.reverse\nend",
  "  if n < 10\n    return \"0#{n}\"\n  else\n    s = \"\"\n    while n > 0\n    \
    \  s, n = n.to_s(2).rjust(4, \"0\") + s, 0\n    end\n    return s\n  end\nend",
  "  result = n.to_s(2).reverse.gsub(/(.)(\\1)/, '\\1').to_i(2)\n  result = result\
    \ > 9 ? result-10 : \"0\"+result\n  return result\nend", "  binary = \"\"\n  remainder\
    \ = 0", "  if n < 0 then\n    return \"Invalid input\"\n  end\n  sum, result =\
    \ 1, \"\"\n  n.times do |i|\n    sum += (i.to_s(2).length + result.length).to_i\n\
    \    result << \"0\" * ((sum - i).to_s(2).length + result.length)\n    sum = sum\
    \ % 10\n  end\n  result\nend\n</cell>\n<text>\nProblem 8\nThe sum of the squares\
    \ of the first ten natural numbers is,", "    total = 0\n    i = 2\n    binary\
    \ = []\n    while i < n\n        binary.push(\"#{n}%2\".format(n.divmod(i).pop(0)))\n\
    \        i += i\n    end\n    total = binary[0]\n    for x in 1..binary.length-1\n\
    \        total += binary[x]\n    end\n    return total\nend", "  sum = (0..n).map\
    \ { |i| (i & 1).to_s(2) }\n  sum.inject(:+).to_s(2)\nend", "    sum = 0\n    while(n\
    \ > 0)\n        sum += n % 10\n        n = n / 10\n    if sum == 0 \n        sum\
    \ = \"0\" + sum\n    return sum\nend", "  s = \"\"\n  n = [n].pack('H*')\n  n.reverse_each\
    \ do |v|\n    v = v.to_s(2)\n    s += v\n  end\n  s << n[-1]\n  s\nend", "  s\
    \ = \"\"\n  while n > 0\n    s += \"1\"\n    n /= 2\n  end\n  s\nend", "  s =\
    \ n.to_s.split(\"\").map(&:to_i)\n  s.each_index do |i|\n    s[i] = s[i].to_s(2).length\n\
    \  end\n  return s.reduce(:+)\nend\n</cell>\n<code language=julia-1.0>", "  nBin\
    \ = n.to_s(2)\n  sum = nBin.to_i(2)\n  sum.to_s(2)\nend\n</code>\nI'm looking\
    \ for a way to get my recursive function return both the sum and the binary version\
    \ of the sum instead of the only variable \"sum\"\n<|/ q dscore=1 |>\n<| c |>\n\
    Please add the code to your question, not as a link to a code hosting site.\n\
    <|/ c |>\n<| c |>\nI added my current code\n<|/ c |>\n<| a tags=ruby,recursion\
    \ dscore=1 |>\nHere's one way to do it. I'm sure there are other ways. I'm a novice\
    \ in Ruby.\n<code>", "    # Your code here\n    return \"#{n}\".to_s(2).scan(/../).reduce(:+)\n\
    end", "  if n == 0\n    \"0\"\n  elsif n < 0\n    \"0\"\n  elsif n == 1\n    \"\
    1\"\n  else\n    binary = bin(n).split(\"0b\").last(2).join\n    binary_sum =\
    \ binary.to_i(2)\n    binary.to_s(2)\n    \"0b\" + binary.to_s(2).ljust(binary_sum,\
    \ \"0\")\n  end\nend", "\ttotal=0\n\twhile n>0\n\t\tnum=n%10\n\t\ttotal+=num\n\
    \t\tn/=10\n\tend\n\treturn total\nend", "  n = (n.to_s.split(' ') + [n]).join('\
    \ ').to_i\n  s = n.to_s.split(//)\n  s.each_with_index do |n, i|\n    s{i} = n.to_s.rjust(6,\
    \ '0')\n  end\n  s.join(' ')\nend\n</cell>\n<cell>\nsolve(1)\n</cell>\n<cell>\n\
    solve(101)\n</cell>\n<cell>\nsolve(8255789)\n</cell>\n<cell>\nsolve(12345)\n</cell>\n\
    <cell>\nsolve(987643)\n</cell>\n<cell>\nsolve(12345)\n</cell>\n<cell>\nsolve(87654321)\n\
    </cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n\
    <cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n\
    </cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n\
    <cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n\
    </cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n\
    <cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n\
    </cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n\
    <cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n\
    </cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n\
    <cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n</cell>\n<cell>\nsolve(87654321)\n\
    </cell>\n<cell>\nsolve(87654321)\n</", "  # TODO: Write your code here.\n  s =\
    \ n.to_s(2)\n  s.reverse\n  s.scan(/../).map(&:to_i).inject(0, :+)\nend", "  \
    \  \nend", "  return n.to_s(2) # to_s(2) convert to binary number\nend", "  digits\
    \ = n.to_s.split('').reverse.join.chars.map{ |c| c % 2 ? '1' : '0' }\n  total\
    \ = digits.inject(0) {|sum, d| sum + d }\n  return '0' * (n%2) + total\nend\n\
    </pre>", "  bin = n.to_s(2)\n  return bin.length == 1 ? bin.to_s : \"1#{bin}\"\
    \nend", "  digits = n.to_s.split(//)\n  result = \"\"\n  \n  digits.each { |num|\
    \ result += \"1\" * (num.to_s.length - 1) + (num % 2).to_s }\n  \n  result\nend",
  "  num = n.to_s(2)\n  return num.scan(/../){|s| s.to_i(2).to_s(2)}.reverse.join(\"\
    \")\nend\n</cell>\n<text>\nTests\nLet's see how it works with the test cases we\
    \ created above.", "  s = \"1\"\n  while n > 0 do\n    s = s + \"0\"*(n mod 2)+s\n\
    \    n = n div 2\n  end\n  return s\nend", "    sum = 0\n    while n > 0\n   \
    \     sum += n % 10\n        n /= 10\n    end\n    sum.to_s\nend\n</code>\nI wrote\
    \ the function without using while loop to make it simple.\n<|/ a |>\n<| a dscore=1\
    \ tags=ruby |>\nHere is an example with a while loop that can run in O(logn)\n\
    <code>", "  binary = n.to_s(2).split(//).map{|x| x.to_i(2).to_s(8)}.join(//)\n\
    \  binary = binary.gsub(/0+/, '').gsub(/1+/, '0').gsub(/2+/, '00')\n  binary.gsub(/^00+/,\
    \ '').to_i(2).to_s(8)\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI appreciate\
    \ this solution, but it is very complicated to understand for newcomers. I tried\
    \ to rewrite this in Ruby myself, which seems to be much easier to understand\
    \ than the above code.\n<|/ c |>\n<| a tags=algorithm,combinatorics,language-agnostic\
    \ |>\nI wrote a Python program that solves this problem in less than 1 minute.\
    \ Here's my code:\n<code>", "    s=\"\"\n    while n>0\n        s+=n%2\n     \
    \   n=n/2\n    end\n    return s\nend\n</code>\n<|/ a |>\n<| c |>\nI like this\
    \ solution, because it actually works. But why does it work? Why do we have to\
    \ take care that the string in s is actually a string? I thought we could just\
    \ add integers to it, and it wouldn't be an issue. What's the reason behind it?\n\
    <|/ c |>\n<| c |>\nThe function `+` on strings doesn't add integers, it concatenates\
    \ them into a single string in whatever order they happen to come out. In Ruby,\
    \ `+\"42\"` returns `\"42\"`, not `\"042\"`.\n<|/ c |>\n<| c |>\nThe solution\
    \ is in Ruby because of the `+=` operator, which behaves differently in different\
    \ languages. The `+` operator in Java concatenates strings, while in Ruby it actually\
    \ *adds* them. The `+=` operator in PHP behaves differently, but you can find\
    \ out about that in any PHP book.\n<|/ c |>\n<| c |>\nI see, I did not know that.\
    \ Thanks a lot\n<|/ c |>\n<| c |>\nHi Kevin. I would like to ask a question about\
    \ this solution. Could you please give me some hints about it? When you declare\
    \ a string like \"abc\" and then concatenate it to \"123\" the output will be\
    \ \"abc123\" right? Then what happens when I type \"+=\" to a string, when is\
    \ it concatenated? When you assign the string to a new variable?\n<|/ c |>\n<|\
    \ a dscore=5 |>\nSolution using Ruby string interpolation \n<code>", "  n.to_s(2).chars.map\
    \ do |n|\n    n.to_i.to_s(2).rjust(4, '0')\n  end.sum\nend", "  if n < 0\n   \
    \ raise Exception\n  sum = \"0\"\n  while n > 0 do\n    sum = \"1\" + sum\n  \
    \  n = n / 2\n  end\n  return sum\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ dscore=0 |>\n<code>", "    sum = \"\"\n    i = 0\n    while i < n\n        sum\
    \ += \"1\"\n        i += 1\n    sum = \"1\" + sum\n    while n > 0\n        sum\
    \ = sum + \"0\"\n        n -= 1\n    sum += sum.rjust(9, \"0\")\n    sum.slice!(0...-1)\n\
    \    return sum\nend", "    digits = n.to_s(2).split(//)\n    digits.each do |d|\n\
    \        sum += d.to_i(2)\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\n<code>", "  return n.to_s(2)\nend\n</cell>\n<text>\n3. Write a Ruby program\
    \ to convert a decimal number to a ternary number in base 10. Input and output\
    \ both strings.", "    ones = 0\n    tens = 0\n    count = 0\n    bin = \"\"",
  "  \nend", "  a = n.to_s(2)\n  b = a.split('')\n  c = b.each_index.with_object(0)\
    \ do |i,sum|\n    sum += (b[i] == '1') ? 1 : 0\n  end\n  c\nend\nprint solve(1)\n\
    print solve(2)\nprint solve(3)\nprint solve(4)\nprint solve(5)\nprint solve(6)\n\
    print solve(7)\nprint solve(8)\nprint solve(9)\nprint solve(10)\nprint solve(11)\n\
    print solve(12)\nprint solve(13)\nprint solve(14)\nprint solve(15)\nprint solve(16)\n\
    print solve(17)\nprint solve(18)\nprint solve(19)\nprint solve(20)\nprint solve(21)\n\
    print solve(22)\nprint solve(23)\nprint solve(24)\nprint solve(25)\nprint solve(26)\n\
    print solve(27)\nprint solve(28)\nprint solve(29)\nprint solve(30)\nprint solve(31)\n\
    print solve(32)\nprint solve(33)\nprint solve(34)\nprint solve(35)\nprint solve(36)\n\
    print solve(37)\nprint solve(38)\nprint solve(39)\nprint solve(40)\nprint solve(41)\n\
    print solve(42)\nprint solve(43)\nprint solve(44)\nprint solve(45)\nprint solve(46)\n\
    print solve(47)\nprint solve(48)\nprint solve(49)\nprint solve(50)\nprint solve(51)\n\
    print solve(52)\nprint solve(53)\nprint solve(54)\nprint solve(55)\nprint solve(56)\n\
    print solve(57)\nprint solve(58)\nprint solve(59)\nprint solve(60)\nprint solve(61)\n\
    print solve(62)\nprint solve(63)\nprint solve(64)\nprint solve(65)\nprint solve(66)\n\
    print solve(67)\nprint solve(68)\nprint solve(69)\nprint solve(70)\nprint solve(71)\n\
    print solve(72)\nprint solve(73)\nprint solve(74)\nprint solve(75)\nprint solve(76)\n\
    print solve(77)\nprint solve(78)\nprint solve(79)\nprint solve(80)\nprint solve(81)\n\
    print solve(82)\nprint solve(83)\nprint solve(84)\nprint solve(85)\nprint solve(86)\n\
    print solve(87)\nprint solve(88)\nprint solve(89)\nprint solve(90)\nprint solve(91)\n\
    print solve(92)\nprint solve(93)\nprint solve(94)\nprint solve(95)\nprint solve(96)\n\
    print solve(97)\nprint solve(98)\nprint solve(99)\nprint solve(100)\nprint solve(",
  "  result = []\n  n.times { result << [n % 2, n % 2].max }\n  result.reverse\n \
    \ result\nend\n</code>\n<|/ a |>\n<| c |>\nYour solution gives the correct result\
    \ for the example given in the question. However, it is incorrect, for instance\
    \ if you enter `8` as input, the solution should return `[\"10\"]` instead of\
    \ `[\"11\"]`. You should be aware that the number of digits in binary is *not*\
    \ necessarily equal to its decimal representation, because the number of digits\
    \ in decimal can also be less than the number of digits in binary (and vice versa).\
    \ The number of digits in binary can be easily calculated using the `log` function.\
    \ Example: `log(2) = 1.609438`. So the total number of digits in the number `8`\
    \ is actually `ceil(log(8)/log(2)) = ceil(1.5) = 1`.\n<|/ c |>\n<| c |>\nOh, I\
    \ forgot about the `ceil`. Thanks for reminding me. I edited the answer. However,\
    \ this still doesn't solve the issue. For example, if I enter `10`, my solution\
    \ would return `[\"10\", \"11\", \"1\", \"0\"]`. It should be `[\"10\", \"11\"\
    , \"1\", \"0\", \"0\"]`\n<|/ c |>\n<| c |>\nI figured out why. Please check the\
    \ edited answer.\n<|/ c |>\n<| c |>\nThis is definitely the best answer. My solution\
    \ was getting very complicated. Nice solution.\n<|/ c |>\n<| a dscore=0 |>\nThis\
    \ is an ugly one, but here you go.\nThe program checks if the number is positive\
    \ or negative, decides whether to print 0s or 1s and how many digits it has.\n\
    <code>", "    arr = n.to_s(2).chars.map(&:to_i).reverse\n    total = 0\n    arr.each\
    \ do |i|\n        total += i >> 1\n    end\n    return total\nend\n</cell>\n<cell>\n\
    solve(10000).to_s(2)\n</cell>\n<text>\nPart III: Big O", "    arr = []\n    total\
    \ = 0\n    arr.push(n.to_s(2))\n    n.times do |i|\n        total += arr.pop.to_i(2)\n\
    \    end\n    return total\nend\n</cell>\n<code language=julia-1.0>\n@time sol\
    \ = solve(1234)\n</cell>\n<code language=julia-1.0>\n@time sol = solve(1234567890)\n\
    </cell>\n<code language=julia-1.0>\n@time sol = solve(12345678900000)\n</cell>\n\
    <code language=julia-1.0>\n@time sol = solve(12345678900001)\n</cell>\n<code language=julia-1.0>\n\
    @time sol = solve(1234567890000123)\n</cell>\n<code language=julia-1.0>\n@time\
    \ sol = solve(12345678900001234)\n</cell>\n<code language=julia-1.0>\n@time sol\
    \ = solve(123456789000012345678)\n</cell>\n<code language=julia-1.0>\n@time sol\
    \ = solve(12345678900001234567890)\n</cell>\n<text>\nExercise 3", "  binary =\
    \ n.to_s(2)\n  binary_sum = binary.reverse.scan(/../) { |a,b| a*2 + b.to_i(2)\
    \ }.reverse.join\n  return binary_sum\nend", "  if n == 0\n    return \"0\"\n\
    \  else\n    digits = n.to_s.split(//)\n    digits.each do |digit|\n      if digit.to_i.zero?\n\
    \        puts \"0\"\n      else\n        puts \"1\" + ((digit.to_i >> 0) & 0x1)\n\
    \      end\n    end\n  end\nend\nsolve('100') #=> 10100\nsolve('1010') #=> 11110\n\
    solve('1011') #=> 10001\nsolve('1110') #=> 11001\nsolve('1111') #=> 11111\nsolve('10000')\
    \ #=> 100111\nsolve('10001') #=> 101010\nsolve('11110') #=> 111011\nsolve('11001')\
    \ #=> 111100\nsolve('11111') #=> 111101\nsolve('100111') #=> 1001111\nsolve('101010')\
    \ #=> 1110100\nsolve('1110100') #=> 11101110\nsolve('11101110') #=> 11110110\n\
    solve('11110110') #=> 11111110\nsolve('11111110') #=> 11111110\nsolve('11111111')\
    \ #=> 11111111\nsolve('111111111111111111111111111111111111111111111111') #=>\
    \ 111111111111111111111111111111111111111111111111\nsolve('1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
  "  result = 0\n  n.times { result += (n.to_s.reverse.slice(1..-1)).to_i(2).to_s(2)\
    \ }\n  return result\nend\nputs solve(6)", "  if n==0\n    return \"0\"\n  else\n\
    \    return \"1\" << (solve(n-1).to_i(2).to_s(2).to_i(2))\n  end\nend", "  if\
    \ n == 0\n    return \"0\"\n  end\n  s = \"\"\n  while n != 0\n    s += \"#{n\
    \ % 2}\" \n    n /= 2\n  end\n  s.reverse\nend", "  a = 1\n  b = 2 ** 0\n  c =\
    \ 0\n  d = 0\n  total = \"\"\n  while a < n\n    total = a * b\n    total += c\n\
    \    total += d\n    total += (b / (b - a) * a) * a\n    total += c\n    total\
    \ += d\n    total += (b / (b - a) * a) * a\n    a += 1\n    b = b / 2\n    c +=\
    \ 1\n    d += 1\n  end\n  total\nend", "  string = \"\"\n  base = 2\n  while (n\
    \ > 0)\n    string = \"1\" + string\n    n -= 1\n  while (string.to_i != 0)\n\
    \    string << 0\n    string.chop!\n  end\n  string\nend", "  result = []\n  (1..n).each\
    \ do |i|\n    result << i.to_s(2).reverse.to_i\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,algorithm |>\n<| c |>\nI didn't downvote, but I don't see where\
    \ you explained what you've done.\n<|/ c |>\n<| c |>\nThanks, I've added an explanation\n\
    <|/ c |>\n<| c |>\nThe question asked about a solution in Ruby, not Java.\n<|/\
    \ c |>\n<| c |>\nThis solution doesn't seem to work for N = 4, which should give\
    \ \"0010\"\n<|/ c |>\n<| c |>\nI actually just realized that N == 4 actually is\
    \ wrong, since that would result in \"10000\". The solution should still work\
    \ though, I will edit the solution to handle this.\n<|/ c |>\n<| a |>\n<code>",
  '  return n.to_s(2) if n > 1 ', "  return n.to_s(2).split(//).map(&:to_i).inject(:+)\n\
    end", "    count = 0\n    (1..n).each { |i| count += i }\n    \n    result = count.to_s(2)\n\
    \    if result.to_i(2)\n        \n        return result\n    else\n        return\
    \ 0\n    end\nend\n</cell>\n<code language=julia-0.6>\nsolve(3)\n</cell>\n<text>\n\
    3.2 Exchange Arrays", "  sum = 0\n  str = n.to_s(2).reverse\n  until str.empty?\n\
    \    sum += str.slice!(0...1)\n    str += '0'\n  end\n  sum.to_s\nend", "    return\
    \ n.to_s(2) if n < 10\n    return n.to_s(2).reverse.split(//).map { |i| i.to_s(2)\
    \ }.inject(0, :+)\nend", "  return n.to_s(2).reverse.gsub(/(..)\\1{2}/, '\\\\\
    1').split(//).sum.to_s\nend", "    if n == 0\n        return \"0\"\n    return\
    \ ((n.to_s(2).reverse).split(\"\").inject(:+) + \"1\").to_s(2)\nend\n</cell>\n\
    <code language=julia-1.0>\nsolve(4)\n</cell>\n<code language=julia-1.0>\nsolve(1234)\n\
    </cell>\n<code language=julia-1.0>\nsolve(1000000000000)\n</cell>\n<code language=julia-1.0>\n\
    solve(31)\n</cell>\n<code language=julia-1.0>\nsolve(10000000000000)\n</cell>\n\
    <text>\nProblem #4 (20 points)\nA palindromic number reads the same backward as\
    \ forward, for example, 321. How many different ways can 21 be written as a palindrome?",
  "  s = n.to_s(2)\n  result = ''\n  digits = n.to_s.split(//)\n  digits.each { |d|\
    \ result += d.to_s(2) }\n  result.to_i\nend", "  return n.to_s.split(//).map {|i|\
    \ \"%02d\" % i}.join('')\nend", "  ret = ''\n  if n > 0\n    n = n.to_s\n    n.reverse!\n\
    \    until n[0] == '0' do\n      n = n[1..-1]\n    end\n    n.reverse!\n    until\
    \ n[0] == '1' do\n      ret = ret+'1'\n      n = n[1..-1]\n    end\n    ret =\
    \ ret+'0'\n    n.reverse!\n  end\n  return ret\nend\n</cell>\n<code language=julia-1.1>\n\
    @assert solve(-10) == \"11111111\"\n@assert solve(-9) == \"1001\"\n@assert solve(-1)\
    \ == \"1\"\n@assert solve(0) == \"0\"\n@assert solve(1) == \"1\"\n@assert solve(2)\
    \ == \"10\"\n@assert solve(3) == \"11\"\n@assert solve(4) == \"100\"\n@assert\
    \ solve(5) == \"101\"\n@assert solve(6) == \"110\"\n@assert solve(7) == \"111\"\
    \n@assert solve(8) == \"1000\"\n@assert solve(9) == \"1001\"\n@assert solve(10)\
    \ == \"1010\"\n@assert solve(11) == \"1011\"\n@assert solve(12) == \"1100\"\n\
    @assert solve(13) == \"1101\"\n@assert solve(14) == \"1110\"\n@assert solve(15)\
    \ == \"1111\"\n</cell>\n<text>\nProblem 5\nThe Fibonacci sequence is defined by\
    \ the formula:", "  a = n.to_s.split(\"\")\n  sum = a.reduce(:+)\n  sum.to_s(2)\n\
    end", "    if n == 0\n        return \"0\"\n    sum = 0\n    while n > 0\n   \
    \     sum += n % 10\n        n /= 10\n    return sum.to_s\nend", "  n = n.to_s.to_i\n\
    \  res = 0\n  while n > 0\n    mod = n%10\n    res += (mod/2).to_s.to_i\n    n\
    \ /= 10\n  end\n  return \"#{res}\"\nend", "  arr = []\n  while n > 0\n    arr\
    \ = getbit(n)\n    n -= 1\n  end\n  puts \"#{arr.join('')}\"\nend\n</code>\n<|/\
    \ a tags=binary,ruby dscore=2 |>\n<| a dscore=2 |>\n<code>", "  sum = \"0\"\n\
    \  for i in (n.to_s).split(\"\")\n    sum = sum.to_s + i.to_s(2) # i.to_s(2)\n\
    \  return sum\nend\n</cell>\n<text>\nSolution\nIf you're stuck, try your hand\
    \ at solving the problem above. If you're still stuck, check out the solution\
    \ below:", "  res = ''\n  (0..Math.log10(n)).each do |i|\n    i = Math.pow(10,\
    \ i)\n    i = n.divmod(i)[1]\n    res += '0' if i == 0\n    res += '1' if i !=\
    \ 0\n  end\n  res\nend", "  string = \"\"\n  for i in 0...n\n    string = string\
    \ + \"1\"\n  end\n  for i in 0...n\n    string = string + \"0\"\n  end\n  string.reverse!\n\
    \  for i in 0...n\n    if string.sub!(n, \"1\") == false \n      string.sub!(i,\
    \ \"0\") \n    end \n  end\n  return string\nend", "  digits = n.to_s.split(//)\n\
    \  digits.reduce(:+)\nend", "    num = n.to_s(2)\n    sum = 0\n    i = -1\n  \
    \  bin = num.split(\"\")\n    sum = 0\n    while i < bin.length\n        sum +=\
    \ bin[i].to_i(2).to_s(2).to_i(2)\n        i += 1\n    return sum.to_s(2)\nend\n\
    </cell>\n<code language=julia-0.6>", "  result = \"1\"\n  num = \"0\"\n  while\
    \ n > 0\n    mod = n % 2\n    num = (num * 10) + mod\n    n /= 2\n  end\n  num.each\
    \ {|c| result += c}\n  result\nend", "    str = n.to_s(2)\n    return str.scan(/../).map\
    \ { |x| x.reverse }.join('')\nend", "    if n <= 0\n        return '0'\n    sum\
    \ = 0\n    while n > 0\n        sum += n % 2\n        n /= 2\n    return sum.to_s\n\
    end", "  n.to_s(2).reverse.to_i\nend", "  ret = \"\"\n  (n / 100) % 10 > 0 ? ret\
    \ += \"1\" : (n / 10) % 10 > 0 ? ret += \"0\" : ret += \"0\"\n  (ret += (ret /\
    \ 10).to_s).to_i\nend", "  i = 2\n  sum = 0\n  while n != 0\n    while n >= i\n\
    \      sum = sum + n % 10\n      n = n / 10\n    end\n    i = i + 1\n  end\n \
    \ return sum.to_s\nend", "    digits = []\n    digit = n.to_s(2)\n    while digit\
    \ != \"\"\n        digits.append(digit)\n        digit = n.to_s(2)\n    return\
    \ digits\nend", "  string = \"\"\n  (1..n).each do |x|\n    string += ((x/n).to_s(2)\
    \ * ((x%n).to_s(2))).to_i(2).to_s(2)\n  end\n  string\nend", "    n.to_s\n   \
    \ n.to_s\n    n.to_s\nend", "  result = ''\n  while n > 0 do\n    result = result\
    \ * '1' + n % 10\n    n = n / 10\n  end\n  result.reverse\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nI didn\u2019t understand how is this solving the problem the OP\
    \ asked about\n<|/ c |>\n<| c |>\nThe code in the question is meant to solve the\
    \ OP\u2019s problem. Why didn\u2019t I explain the algorithm clearly? The algorithm\
    \ is really simple and easy to understand. I guess I didn\u2019t have to explain\
    \ it. And, I don\u2019t know why I got voted down. I think the code is the answer,\
    \ but I don\u2019t know why I got voted down.\n<|/ c |>\n<| c |>\nYou said \u201C\
    The code in the question is meant to solve the OP\u2019s problem\u201D and I guess\
    \ that was meant to meant exactly that code you gave. It was meant to show how\
    \ I arrived at the solution. I don\u2019t know why someone would vote this down.\
    \ Thanks for explaining your solution, it\u2019s really good.\n<|/ c |>\n<| a\
    \ tags=algorithm,ruby dscore=0 |>\nMy Ruby solution is as follows:\n<code>", " \
    \ sum = 0\n  while n > 0\n    sum += n % 2\n    n /= 2\n  \n  sum.to_s(2)\nend",
  "    num = n.to_s(2).reverse\n    total = 0\n    until num.length <= 1\n       \
    \ total += num.slice!(0,1).to_i(2)\n        num = num.slice!(0,2)\n    return\
    \ total\nend\n</code>\n<|/ a tags=ruby,string,arrays dscore=1 |>\n<| a dscore=0\
    \ |>\n<code>", "    return n.to_s(2).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/,\
    \ '\\\\1').to_f\nend", "  sum = \"\"\n  while n > 0\n    sum += n % 2 + \" \"\n\
    \    n /= 2\n  return sum.reverse\nend", "  n.to_s(2)\nend", "  digits = n.to_s(2)\n\
    \  sum = \"\"\n  for i in 0...digits.length - 1\n    sum += digits[digits.length\
    \ - i - 1]\n  end\n  return sum\nend", "  digits = n.to_s.chars.map(&:to_i)\n\
    \  sum = 0\n  digits.each do |d|\n    sum = sum + d * 2\n  end\n  sum.to_s\nend\n\
    </code>\n<|/ a dscore=0 tags=algorithm,ruby |>\n<| c |>\nPlease don't add \"thank\
    \ you\" as an answer. Instead, vote up the answers that you find helpful. Or if\
    \ no answer was helpful, leave a comment explaining why. Thank you.\n<|/ c |>\n\
    <| c |>\nI did it. Thank you!\n<|/ c |>\n<| a |>\n<code>", "  # initialize result\n\
    \  result = ''", "  ones = n.to_s(2)\n  tens = n.to_s(3)\n  sum = ones + tens\n\
    \  return sum.to_i(2).to_s(2)\nend", "  sum = n.to_s(2).split(\"\").map{|x| x.to_i(2).to_s(2)}.join(\"\
    \")\n  return sum.to_i(2) if sum.length <= 10 # Return result if its less than\
    \ 10 binary\n  sum.sub(/./, \"\")   # Remove all characters in string that are\
    \ not numeric\nend", "    sum = 0\n    while n > 0 do\n        sum += n % 2\n\
    \        n /= 2\n    end\n    return \"#{sum.to_s(2)}\"\nend\n</cell>\n<code language=julia-1.6>\n\
    solve(8)\n</cell>\n<text>\nPart 2\nUsing the same concepts, implement a function\
    \ that determines whether a given binary string is a palindrome:\na binary string\
    \ is a palindrome if it reads the same backward as forward.", "  return \"0\"\
    \ * n\nend\n</cell>\n<code language=julia-1.5>\n@code_warntype solve(333)\n</cell>\n\
    <code language=julia-1.5>\n@code_warntype solve(12345)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solve(987654321)\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solve(1000000000000000)\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solve(1000000000000000000)\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solve(100000000000000000000000000)\n</cell>\n<code language=julia-1.5>\n@code_warntype\
    \ solve(1000000000000000000000000000000)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solve(10000000000000000000000000000000)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solve(10000000000000000000000000000000000)\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype solve(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)\n\
    </cell>\n<text>\nBonus 1: Optimization\nThe first problem is to write a function\
    \ that takes the integer N and returns the sum of  all its digits in the binary\
    \ representation of N.", "  nums = n.to_s.split(//).map{|x| x.to_i}\n  result\
    \ = \"\"\n  for i in 0..(nums.size-1)\n    binary = nums.map{|x| x.to_s(2)}.join(//)\n\
    \    result << binary[0..i]\n  end\n  result\nend\n</cell>\n<cell>", "  sum =\
    \ 0\n  i = 0\n  while i < n\n    sum += n[i].to_s(2)\n    i += 1\n  end\n  sum.to_s(2)\n\
    end", "    sum = 0\n    while n > 0\n        n = n / 2;\n        sum = sum + n\
    \ % 10;\n    end\n    return sum.to_s(2);\nend", "    bin = \"\"\n    sum = 0\n\
    \    while n > 0\n        sum += n % 10\n        n /= 10\n        bin = sum.to_s(2)\
    \ + bin\n    end\n    bin\nend", "    str = n.to_s(2)\n    str.scan(/../) { |x|\
    \ sum += x.to_i(2) }\n    sum\nend", "    s=0\n    while n>0 do\n        s=s+n%10\n\
    \        n=n//10\n    end\n    s=s+\"0\"\nend", "  n.to_s(2) # convert to binary\
    \ string\nend", "    \n    # write your code in Ruby here\n    n = n.to_s(2)\n\
    \    s = 0\n    while n.length != 0\n        s = s + n.rjust(n[0].length,0)\n\
    \        n = n[1..-1]\n    end\n    puts s\nend", "  sum = 0\n  while n > 0\n\
    \    digit = n % 10\n    sum = sum + digit\n    n /= 10\n  return sum.to_s\nend",
  "\ttotal = 0\n\tns = [\"\",\"0\",\"1\"]\n\twhile n > 0\n\t\ttotal += n % 2\n\t\t\
    n /= 2\n\treturn ns[total]\nend", "  digits = n.to_s.reverse\n  i = 0\n  total\
    \ = 0\n  while i < digits.length\n    total += digits.to_i(i).to_s\n    i += 1\n\
    \  end\n  total = total.to_i(2).to_s\n  result = []\n  i = 2\n  while i < digits.length\n\
    \    if digits.to_i(i).to_s == 0\n      i += 1\n    else\n      i = i + 1\n  \
    \    result = result + [i]\n    end\n  end\n  puts result\nend", end, "  sum =\
    \ 0\n  while n > 0\n    sum = (sum + (n % 2))\n    n = n / 2\n  end\n  return\
    \ sum.to_s\nend\n</cell>\n<code language=julia-1.0>", "  result = ''\n  while\
    \ n > 0\n    result += (n % 2 == 0)\n    n /= 2\n  end\n  result.reverse\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nWhy are you using String#reverse?\n<|/ c\
    \ |>\n<| c |>\n`str.reverse` reverses the string. If you reverse a string you\
    \ reverse every letter, so you reverse the string and then reverse the letters\
    \ again, which means you're doing `'ab'.reverse` -> `'ba'.reverse` -> `'a'.reverse`\
    \ -> `'b'.reverse` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'`\
    \ -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a`'` ->\
    \ `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'`\
    \ -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a` -> `'b'` -> `'a'`\
    \ -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a` -> `'b'` -> `'a'` -> `'b'`\
    \ -> `'a'` -> `'b'` -> `'a` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'`\
    \ -> `'b'` -> `'a'` -> `'b'` -> `'a` -> `'b'` -> `'a'` -> `'b'` -> `'a` -> `'b'`\
    \ -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a'`\
    \ -> `'b'` -> `'a` -> `'b'` -> `'a'` -> `'b'` -> `'a'` -> `'b'` -> `'a` -> `'b'`\
    \ -> `'", "    \n    count = 0\n    digits = n.to_s(2).reverse.split(\"\").reverse\n\
    \    \n    digits.each do |d|\n      if d == \"1\"\n        count += 1\n     \
    \ end\n    end\n    \n    return count.to_s(2).reverse\nend", "  s = ''\n  while\
    \ n != 0\n    s << n % 10\n    n /= 10\n  end\n  s.reverse!\n  puts s\nend", " \
    \   n.to_s.reverse.scan(/../) do |num|\n        num.each.to_s.reverse << num.each.to_s.reverse.inject(0,\
    \ :*)\n    end.reverse.join\nend\n</cell>\n<text>\nProblem 3\nConsider the following\
    \ problem statement:", "    binary = n.to_s(2).split('').reverse.join\n    sum\
    \ = 0\n    n.to_s(2).split('').reverse.each do |i|\n        sum += i.to_i\n  \
    \  end\n    puts \"The total sum of its digits in binary is #{sum}\"\n    puts\
    \ \"The binary string #{binary} is #{binary}\"\n    puts \"The decimal equivalent\
    \ of #{sum} is #{sum.to_s(10)}\"\nend", "    count = 0\n    while n > 0\n    \
    \    count = count + (n % 2) + 1\n        n = n / 2\n        \n    return \"1\"\
    \ * (-count - 1) + \"0\" * count\nend", "  result = \"\"\n  while n > 0\n    n,\
    \ result = n, result*10 + n % 10\n  end\n  result\nend", "  s = n.to_s(2)\n  s\
    \ = s[0...-1] + s[0]\n  return s.reverse\nend", "  result = ''\n  while n > 0\n\
    \    result << (n % 2)\n    n /= 2\n  end\n  result.reverse\nend", "  digits =\
    \ n.to_s(2).split('')\n  digits.map {|d| d.to_i(2).to_s(2).to_i(2).to_s(2).split('')}.reduce(:+)\n\
    end\n</code>\nThis is probably not the most efficient way of doing it, but it\
    \ works.  I suppose you could do something similar with a loop, but that would\
    \ probably be slower and a lot more code.\n<|/ a tags=ruby,algorithm dscore=2\
    \ |>\n<| c |>\nGood thought, but this fails to account for negative numbers. Also,\
    \ the solution is wrong if N is bigger than 10000.\n<|/ c |>\n<| c |>\nThanks,\
    \ added some comments above to clarify.\n<|/ c |>\n<| c |>\nHmm, I didn't think\
    \ of that.  I think that would just be a matter of adding `n.to_s(2)` in that\
    \ case, but I don't know Ruby well enough to know what it would be.\n<|/ c |>\n\
    <| c |>\nThanks.  I added the negative number to my answer.\n<|/ c |>\n<| c |>\n\
    `0.to_s(2) #=> \"0\"`, `1.to_s(2) #=> \"1\"`, etc...\n<|/ c |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's a solution based on using String#scan to split on the digits, then\
    \ converting each group of digits to an integer.  \n<code>", "  res = []\n  (0..n).each\
    \ { |i| res << (((n%i) == 0) ? \"0\" : \"1\") }\n  sum = \"\"\n  res.each { |i|\
    \ sum += i }\n  return sum\nend", "  digits = n.to_s(2)\n  total = 0\n  digits.to_s.chars.reverse.each\
    \ do |digit|\n    digit = digit.to_i(2).to_s(2)\n    digit.split(//).reduce(:+).to_i(2).to_s(2).rjust(8,\
    \ '0')\n    total += digit.to_i(2).to_s(2)\n  end\n  total.to_s(2)\nend\nputs\
    \ solve(1784)", "  if n < 0\n    return \"N is negative\"\n  end", "  s = ''\n\
    \  while n > 0 do\n    s = s.to_s + [n.to_s(2)].pack('C*')\n    n /= 10\n  end\n\
    \  s\nend\n</code>\nThe result is a string, which is easily converted to an integer\
    \ with .to_i, or converted to a float with .to_f. The problem is that to_s does\
    \ not produce the leading zeros, which is important to keep in mind. An alternate\
    \ solution is to convert the number to a binary string with to_s(2), and then\
    \ pad with 0s to the left:\n<code>", "  return n.to_s(2).reverse.gsub(/1|0|1/,\
    \ '').to_i\nend\n</cell>\n<cell>\nsolve\n</cell>\n<cell>\nsolve(5)\n</cell>\n\
    <cell>\nsolve(1000)\n</cell>\n<cell>\nsolve(101)\n</cell>\n<cell>\nsolve(1025)\n\
    </cell>\n<cell>\nsolve(1000)\n</cell>\n<cell>\nsolve(10000)\n</cell>\n<cell>\n\
    solve(100000)\n</cell>\n<cell>\nsolve(1000000)\n</cell>\n<cell>\nsolve(1000000000)\n\
    </cell>\n<cell>\nsolve(1000000000000)\n</cell>\n<cell>\nsolve(1000000000000000000)\n\
    </cell>\n<text>\nExercise 2\nGiven a positive integer N, return the sum of the\
    \ numbers of the form 2^k * 3^k * 4^k, where k ranges from 0 to N-1.", "  result\
    \ = ''\n  while n > 0\n    result += (n & 1) ? '1' : '0'\n    n >>= 1\n  end\n\
    \  return result\nend", "  return n.to_s(2).reverse + n.to_s(2).reverse\nend",
  "  sum = \"\"\n  for i in n.to_s(2).split(\"\")\n    sum << i\n  end\n  sum\nend",
  "  string = \"\"\n  while n > 0\n    string = n.to_s(2) << string if n >= 10 &&\
    \ n < 100\n    n, i = n.divmod(10)\n  end\n  return string\nend", "  result =\
    \ \"\"\n  if n > 0\n    n = n.to_s(2)\n    n = n.split(\"\")\n    n.each_index\
    \ do |i|\n      if n[i] < 10\n        result += \"0\"\n      else\n        result\
    \ += \"1\"\n      end\n    end\n  end\n  result\nend", "  \n  if n<0\n    return\
    \ \"Error\"\n  \n  arr=[0,1]\n  total=0\n  while n>0\n  \n    if n%2==1\n    \
    \  total+=0\n    total+=1\n    arr[-1]+=1\n    n=n/2\n  \n  return \"0b\"+arr.to_s(2).ljust(8,'0')\n\
    end\nprint(solve(17))", "  result = \"\"\n  while n > 0\n    result << (n % 2)\n\
    \    n /= 2\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,binary |>\n<| c |>\n\
    This is not correct. The `result` variable in your answer is never used. Also,\
    \ when `n == 1`, this code will output `\"\"`.\n<|/ c |>\n<| c |>\n, The question\
    \ states *\"Given a positive integer N, return the total sum of its digits in\
    \ binary\"*. `result == \"\"` is only used when `n == 1`, so there is no point\
    \ to outputting an empty string when the input is an integer. You are right that\
    \ the `result` variable should not be used in the final answer.\n<|/ c |>\n<|\
    \ c |>\nYou are right that it is not correct that it should only be used when\
    \ `n == 1`. Your code should output `\"\"` only when `n == 1`. Your answer outputs\
    \ `0` for inputs other that `1`. See my answer.\n<|/ c |>\n<| c |>\n, My answer\
    \ outputs `\"\"` when the input is `1`, not when `n == 1`. I was giving the OP\
    \ a direction, not an answer. I hope I didn't come off as rude.\n<|/ c |>\n<|\
    \ a |>\n<code>", "  # TODO: write your code here.\n  return \"11111\"\nend", " \
    \ result = \"\"\n  \n  for i in \"0..\" + (\"1\"*(n-1))\n    result << \"#{n}#{i.to_s(2)}\"\
    \ << ((1..(n-1)).include?(i) ? \".\" : \"\")\n  end\n  \n  result\nend", "  result\
    \ = 0\n  while n > 0\n    digit = n / Math.pow(2,n)\n    result += (digit * Math.pow(2,n))\n\
    \    n -= 1\n  end\n  return result\nend", "  return n.to_s(2).reverse.scan(/../).map(&:first).join.to_i\n\
    end", "  binary = \"\"\n  i = 0\n  while i < n do\n    binary = n.to_s(2).to_s\
    \ + binary\n    i += 1\n  end\n  return binary\nend", "  rev = n.reverse\n  total\
    \ = 0\n  n.times do |i|\n    total += i % 2 == 0 ? 0 : 1 \n    total += rev[i\
    \ / 2].to_i\n  end\n  puts total * '1'\nend", "  sum = 0\n  n.times do |x|\n \
    \   sum += x.to_s(2)\n  end\n  sum.to_s(2).length * \"1\"\nend\nprint solve(n)\n\
    </code>\n<|/ a |>\n<| a tags=ruby,algorithm |>\nHere is an iterative solution,\
    \ which might be easier to understand than a recursive one.\n<code>", "    num\
    \ = n.to_s(2)\n    return num.length.to_s + num.chars.inject('') {|sum, item|\
    \ sum + item }\nend\n</cell>\n<text>\n\u25E2 Checkpoint: Checking the Answer\n\
    Run the cell below to check your solution. As an output you should see \u201C\
    Correct!\u201D if your solution matches your expectations and \u201CWrong!\u201D\
    \ if your solution does not match your expectations.", "  s = \"\"\n  while n\n\
    \    s = to_bin(n.to_s)[1..-1].inject(:+) + s\n    n = n % 10\n  end\n  return\
    \ s\nend", "  return n%2 == 0 ? \"0#{n/2}\" : \"1#{n/2}\"\nend", "    n.to_s(2)\n\
    \    n.to_s(16).reverse\n    n.to_s(2).reverse\n    n.to_s(16).reverse\n    n.to_s(2)\n\
    \    n.to_s(16)\n    n.to_s(2).reverse\n    n.to_s(16).reverse\n    n.to_s(2)\n\
    \    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n\
    \    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n\
    \    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n\
    \    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n\
    \    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n\
    \    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n\
    \    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n\
    \    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n\
    \    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n\
    \    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n\
    \    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n\
    \    n.to_s(2)\n    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n\
    \    n.to_s(16).reverse\n    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n\
    \    n.to_s(2)\n    n.to_s(16)\n    n.to_s(2)\n    n.to_s(16).reverse\n", "  base10to64\
    \ = Array.new(64) { |i| i.tos.to_s(2) }\n  result = \"0\"\n  n.times do |i|\n\
    \    result += base10to64[n.modulo(64)]\n    n /= 64\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,algorithm,string,ruby-on-rails |>\n<| a dscore=0 |>\nThis is a\
    \ solution that works for me:\n<code>", "  if n <= 0\n    return \"0\"\n  else\n\
    \    return n.to_s(2).reverse.gsub('1|2','').reverse\n  end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nsolve(1)\n</cell>\n<code language=julia-1.5>\nsolve(7)\n\
    </cell>\n<code language=julia-1.5>\nsolve(100)\n</cell>\n<code language=julia-1.5>\n\
    solve(125)\n</cell>\n<code language=julia-1.5>\nsolve(100)\n</cell>\n<text>\n\
    The Sum of Natural Numbers\nThe sum of any positive integer N is equal to the\
    \ sum of its digits in binary. For example, 1 + 9 = 10, because \"1\" + \"9\"\
    \ = \"10\". \"00\" + 9 = \"09\".", "  s = n.to_s.split(//)\n  sum = 0\n  for i\
    \ in s\n    sum += i.to_i(2).to_s(2)\n  end\n  sum.to_s(2)\nend", "  return n.to_s.reverse.gsub(/(..?)(..?)/,'\\\
    1\\2').chars.reverse.join(\"\")\nend\n</cell>\n<code language=julia-0.5>\nsolve(19)\n\
    </cell>\n<code language=julia-0.5>\nsolve(500)\n</cell>\n<code language=julia-0.5>\n\
    solve(600)\n</cell>\n<code language=julia-0.5>\nsolve(987)\n</cell>\n<code language=julia-0.5>\n\
    solve(1010)\n</cell>\n<text>\nProblem: Find the sum of all primes below two million\
    \ (10^6) in the Sieve of Eratosthenes."]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
