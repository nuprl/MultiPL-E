name: HumanEval_21_rescale_to_unit
language: rb
prompt: "# Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n# such that the smallest number will become 0 and the largest will\
  \ become 1\ndef rescale_to_unit(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n\
  \    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0,\
  \ 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0,\
  \ 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\n\
  end\n"
completions: ["  if numbers.nil? || numbers.empty?\n    return numbers\n  end\n  numbers.sort!\n\
    \  length = numbers.length - 1\n  result = [0] * length\n  result.zip(numbers).each\
    \ do |num, rescaled_num|\n    result[length - rescaled_num - 1] = num\n  end\n\
    \  result\nend\n</cell>\n<code language=julia-1.5>\nnumbers = [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\nrescale_to_unit(numbers)\n</cell>\n<code\
    \ language=julia-1.5>", "  numbers.each do |n|\n    min = numbers.min || 0\n \
    \   max = numbers.max || 1\n    n.times do\n      n -= min - max\n      n /= max\
    \ - min\n    end\n  end\n  numbers\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  new_numbers = []\n  for number in numbers\n    new_numbers.push((number - min)/(max\
    \ - min))\n  end\n  return new_numbers\nend", "  numbers.map! do |number|\n  \
    \  if number > 0 \n      number\n    else\n      1\n    end\n  end\nend\n</code>\n\
    <|/ a tags=algorithm,ruby,functional-programming dscore=3 |>\n<| c |>\nI like\
    \ that you can easily swap out the 1 with -1 if the numbers are negative. I'm\
    \ going to add an if statement to my code to check whether they should be swapped.\n\
    <|/ c |>\n<| c |>\nI've added an if statement to my code to check whether they\
    \ should be swapped now. Hope that helps.\n<|/ c |>\n<| c |>\nYour first solution\
    \ worked great for me. Thanks so much!\n<|/ c |>\n<| c |>\nWhat happens if you\
    \ input `[-1/3]`? The code will crash since `Rational` does not know how to handle\
    \ negative numbers correctly. You'd want to use something like `Math::BigRational.new`\
    \ to ensure a rational number is returned. As you noted, `Rational` will convert\
    \ `-1/3` to `0` as well.\n<|/ c |>\n<| c |>\nYes, the code would crash if you\
    \ feed it a negative number like that. I assumed that it was OK to leave the numbers\
    \ as they were without being able to convert them. That is why I gave a solution\
    \ that handles the negative numbers well.\n<|/ c |>\n<| a dscore=3 |>\nHere's\
    \ a solution that works with negative numbers, as well as positive and zero numbers:\n\
    <code>", "  min, max = numbers.minmax_by{ |x| x }\n  scale = 1.0\n  min_scaled,\
    \ max_scaled = min.to_f * scale, max.to_f * scale\n  return numbers.map { |num|\
    \ num * scale / min_scaled } + [1.0] * max_scaled - 1\nend", "    smallest = numbers.min\n\
    \    largest = numbers.max\n    new_numbers = numbers.map { |num| num / largest\
    \ }\n    new_numbers = [smallest] + new_numbers\n    new_numbers = new_numbers.map\
    \ { |num| num * 100 }\n    new_numbers = new_numbers.map { |num| num / 100 }\n\
    \    new_numbers\nend", "  minimum = numbers.min\n  maximum = numbers.max\n  normalized_numbers\
    \ = (numbers - minimum) / (maximum - minimum)\n  rescaled_numbers = Array.new\n\
    \  minimum_index = 0\n  maximum_index = normalized_numbers.size\n  normalized_numbers.each_with_index\
    \ do |number, i|\n    rescaled_numbers << number * maximum_index - minimum_index\n\
    \    minimum_index = maximum_index\n    maximum_index = maximum_index * 2 + 1\n\
    \  end\n  rescaled_numbers\nend\n</cell>\n<cell>", "  if numbers.size < 2\n  \
    \  return []\n  smallest_number = numbers.min\n  max_number = numbers.max\n  return\
    \ [smallest_number / (max_number - smallest_number), max_number - smallest_number]\n\
    end", "    \n    min = numbers.min\n    max = numbers.max\n    \n    # Scale the\
    \ list so that smallest number becomes 0 and the largest becomes 1\n    numbers.map!{|n|\
    \ n.to_f / max - min}\n    \n    # Return the scaled list\n    numbers\nend\n\
    </cell>\n<code language=ruby-1.8.7>", "  min_number = numbers.min\n  max_number\
    \ = numbers.max\n  scale_factor = (max_number - min_number) / (numbers.size -\
    \ 1)\n  numbers.map! { |number| number * scale_factor }\nend", "  rescaled = []\n\
    \  min_value = numbers.min\n  max_value = numbers.max\n  for i in numbers\n  \
    \  rescaled.push( max_value - min_value * i / max_value )\n  end\n  rescaled\n\
    end", "  # find min and max values\n  min_value = numbers.min\n  max_value = numbers.max",
  "  min = numbers.reduce(:<)\n  max = numbers.reduce(:-)\n  numbers.map! { |n| min+(n-min)/(max-min)\
    \ }\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nThe easiest solution I found was\
    \ to create an Array of numbers and then use Array#map with Array#zip to create\
    \ an array of pairs where the first item of the pair is the original number and\
    \ the second is the transformed one.  \n<code>\nnumbers = [0, 1, 2, 3, 4, 5]\n\
    result = numbers.map { |n| [n, n+1] }\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nIt won't be very performant as the original array will be passed into\
    \ the block for every single item in the resulting array.\n<|/ c |>\n<| c |>\n\
    This has the downside that the array will be mutated (a side effect for those\
    \ of us coming from a functional programming background). To avoid this, `numbers.map\
    \ { |n| [n, n+1].clone }`\n<|/ c |>\n<| c |>\nYou could also just do `numbers.each_with_index.map\
    \ { |n,i| [n, n+1] }`\n<|/ c |>\n<| c |>\nIf performance is a problem (and I don't\
    \ believe it is) I'd prefer to use `each_with_index` because it will not mutate\
    \ the array in the block.\n<|/ c |>\n<| a tags=ruby,arrays dscore=2 |>\nI've always\
    \ liked this kind of thinking when learning Ruby. It isn't particularly readable,\
    \ but it does allow you to see the mapping being done on that array while you're\
    \ writing it. \n<code>", "  minmax = numbers.minmax\n  return [minmax[0] / numbers[0],\
    \ minmax[1] / numbers[-1]]\nend", "    minimum, maximum = numbers.min, numbers.max\n\
    \    minimum, maximum = [minimum, maximum] if maximum < minimum else [0, 1]\n\
    \    numbers = (numbers - minimum) / maximum\n    return numbers\nend", "    smallest\
    \ = numbers.min\n    largest = numbers.max\n    return [(largest - smallest) *\
    \ number + smallest for number in numbers]\nend", "  smallest_number = numbers.min\n\
    \  largest = numbers.max\n  min_ind = numbers.index(smallest_number)\n  max_ind\
    \ = numbers.index(largest)\n  \n  for i in min_ind:\n    numbers[i] = 0\n  for\
    \ i in max_ind:\n    numbers[i] = 1\n  return numbers\n  \n</cell>\n<cell>", " \
    \ numbers.each_with_index do |n, i|\n    if i == 0\n      n.to_f / 100\n    elsif\
    \ i == 1\n      n.to_f\n    else\n      n.to_f / 100\n    end\n  end\nend", " \
    \ min = numbers.first\n  max = numbers.last\n  return numbers.map { |x| x / min.to_f\
    \ }\nend", "  if numbers.empty? or numbers.any?(&:zero?)\n    []\n  else\n   \
    \ # Calculate smallest and largest number\n    min_number = numbers.min\n    max_number\
    \ = numbers.max", "  numbers.map!{ |x| x / numbers.min }\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=1 |>\nHere is one way to implement a linear transformation with\
    \ Ruby Enumerable#map and Enumerable#reduce (assuming you have a Ruby version\
    \ newer than 1.9.3):\n<code>", "  numbers.map {|n| n/100}\nend", "  numbers.map\
    \ { |n| n / numbers.min }\nend", "  # Your code here!\nend", "  numbers.each {\
    \ |number| number[0] = number[0] * 2 - 1 }\n  numbers\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nOh, I'm sorry for the wrong indentation. I've fixed it. Thanks\
    \ for the help.\n<|/ c |>\n<| a |>\n<code>", "  return numbers.map{|n| n / numbers.max}\n\
    end", "  if numbers.empty?\n    []\n  else\n    rescale_to_unit(numbers[0], numbers[1])\n\
    \  end\nend", "    numbers.each do |number|\n        min_number = math.min(number)\n\
    \        max_number = math.max(number)\n        if min_number == 0\n         \
    \   number -= min_number\n        end\n        if max_number == 1\n          \
    \  number -= max_number\n        end\n    end\nend", "    numbers.each do |number|\n\
    \        if number < 0\n            number *= -1\n        end\n    end\n    numbers.sort!\n\
    \    numbers.each_with_index do |number, i|\n        if number != 0\n        \
    \    numbers[i] = number/i\n        end\n    end\nend", "  minval, maxval = numbers.min,\
    \ numbers.max\n  new_numbers = []\n  numbers.each do |n|\n    new_numbers << n\
    \ / (maxval - minval)\n  end\n  new_numbers.min == 0 and new_numbers.max == 1\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is not what the question asked,\
    \ as this returns `false` for non-integral values like `[1,5]`.\n<|/ c |>\n<|\
    \ a dscore=0 tags=ruby,range,math |>\nRuby's Array#min and Array#max return the\
    \ first and last elements, respectively, of the array if no block is given.  If\
    \ you wish to find the minimum value in an array and divide all the numbers by\
    \ the difference, you will have to subtract each number from its maximum and divide\
    \ by the difference.  If you don't subtract each number, you will divide by the\
    \ maximum and end up with fractions.  For instance, if the array was [1, 2], you\
    \ would divide [1, 2] by 2 and end up with 0.5.  That is not what you want, as\
    \ there is no way to properly divide 1 by 2.\nWhat you really want to do is to\
    \ subtract each number from its minimum and then divide by the difference.  For\
    \ instance:\n<code>", "  min = 0\n  max = numbers[0]\n  numbers.each_index do\
    \ |i|\n    if numbers[i] < min\n      min = numbers[i]\n    end\n    if numbers[i]\
    \ > max\n      max = numbers[i]\n    end\n  end\n  min = min * 10 / max + 0\n\
    \  max = max * 10 / min + 0\n  return min, max\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\nI have created a function\
    \ which can convert a number in a range of 0 to 255 to an equivalent number of\
    \ that range between 1 and 255.\nThe function is as follows :\n<code>", '  assert(numbers.size
    == 2)', "  max = numbers.max\n  min = -max\n  if numbers.min\n    min = numbers.min\n\
    \  end\n  \n  return numbers.map(&:*((max - min) / (max - numbers.max)))\nend",
  "  # Convert to array of numbers and then subtract minimum from all\n  numbers =\
    \ numbers.map(&:to_f).map {|x| x - xmin}\n  # Scale all numbers to [0, 1]\n  numbers.map!\
    \ {|x| x/xmax - xmin}\nend", "    smallest = numbers[0]\n    largest = numbers[-1]",
  "  # Make sure we have at least two elements\n  if numbers.size < 2\n    return\
    \ numbers\n  # Find the minimum and maximum value\n  min_value, max_value = numbers.minmax\n\
    \  # If the minimum and maximum values are the same, return them\n  return [0\
    \ if min_value == max_value else float(min_value) / max_value, max_value]\nend",
  "    # sort first\n    numbers.sort!\n    # find the min and max values\n    min_val\
    \ = numbers[0]\n    max_val = numbers[0]\n    # and calculate the scale factor\n\
    \    scale = max_val - min_val\n    # multiply each number by its scale\n    numbers.map!\
    \ { |x| x * scale }\nend", "  smallest_number = numbers.min\n  largest = numbers.max\n\
    \  scaling_factor = largest / smallest_number\n  numbers.map!{|x| x * scaling_factor}\n\
    end", "    numbers.each do |n|\n      n -= min\n      n /= max\n    end\nend\n\
    </code>\nTo make it a little more general, we can also define a method that takes\
    \ in a list of arrays, each element in the array being an array of numbers, it\
    \ applies the transformation to the smallest number in the subarray, and returns\
    \ the resultant array:\n<code>", "  numbers.min! # Smallest number becomes 0\n\
    \  numbers.max! # Largest number becomes 1\nend\n</cell>\n<cell>", "  smallest\
    \ = numbers.min\n  largest = numbers.max\n  scaled = (numbers - smallest)/(largest\
    \ - smallest)\nend", "  return numbers.map { |n| [n - min(n), 1].reduce(:+) /\
    \ max(n) }\nend", "  smallest_number = numbers.min\n  greatest_number = numbers.max\n\
    \  scaled_numbers = numbers - smallest_number\n  scaled_numbers = scaled_numbers\
    \ / greatest_number * 2 - 1\n  return scaled_numbers\nend", "  # sort the list\n\
    \  numbers.sort", "  first_element = numbers.min\n  last_element = numbers.max\n\
    \  new_list = [first_element] * numbers.count\n  new_list[new_list.index(first_element)]\
    \ = 1\n  for i in 0..numbers.count-1\n    new_list[i+1] = numbers[i]/last_element\n\
    \  end\n  return new_list\nend", "  numbers.map! do |number|\n    if number.is_a?\
    \ Numeric\n      number / 100\n    else\n      0\n    end\n  end\n  numbers\n\
    end", "    numbers.min!(0.0)\n    numbers.max!(0.0)\n    numbers*(1.0 / numbers[-1])\n\
    end\n</cell>\n<text>\nNow let's try it out on some generated data.", "  numbers.min!\n\
    \  numbers.max!\n  numbers.min = 1\n  numbers.max = 0\n  numbers\nend", "  min\
    \ = numbers.min\n  max = numbers.max\n  numbers.map! do |n|\n    if min == 0\n\
    \      if max == 0\n        0\n      else\n        n * 100 / max\n      end\n\
    \    else\n      n * (max - min) / 100 + min\n    end\n  end\nend", "  min, max\
    \ = numbers.minmax\n  numbers -= min\n  numbers /= max - min\n  numbers *= 2\n\
    end", "  max_value = numbers.max\n  min_value = numbers.min\n  numbers.map! do\
    \ |number|\n    if number == 0.0\n      0.0\n    elsif number == 1.0\n      1.0\n\
    \    else\n      number * (max_value - min_value) / (number - min_value)\n   \
    \ end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis is incorrect, as you do not\
    \ scale the minimum value to be `0.0`. He wants to scale the numbers between `0.0`\
    \ and `1.0` to `0.0` and `1.0`.\n<|/ c |>\n<| c |>\n, I don't understand your\
    \ comment. How can any number be `0.0` when `min_value` is `0.0`? Do you mean\
    \ that `min_value` is `0.0` when `numbers` has only `0.0` and `1.0`? That's certainly\
    \ true, but that's not the case. As I understand it, the questioner wants to scale\
    \ the numbers to `0.0` and `1.0`. The way I understand it he is asking for the\
    \ numbers `[0.0, 1.0]` to become `[0.0, 1.0]`.\n<|/ c |>\n<| c |>\nHe wants the\
    \ numbers [0.0, 1.0] to become [0.0, 1.0]\n<|/ c |>\n<| c |>\n, Ah, OK. I think\
    \ I understand now.\n<|/ c |>\n<| a dscore=1 tags=arrays,ruby |>\nIf you're just\
    \ wanting to scale the numbers to 0 and 1, you can just divide by their max and\
    \ min values:\n<code>\na = [0,1,2,3,4,5]", "  if numbers.empty?\n    []\n  else\n\
    \    linear_transform_scale(numbers)\n  end\nend\n</code>\nAnd then you call it\
    \ like this:\n<code>", "  min = numbers.min\n  max = numbers.max\n  numbers =\
    \ (numbers - min) / (max - min) # Transform to [0, 1]\n  numbers.round(0)\nend",
  "  first_num = numbers.shift\n  second_num = numbers.shift\n  third_num = numbers.shift",
  "  length = numbers.size\n  min_number = numbers.min\n  max_number = numbers.max\n\
    \  \n  # Rescale the numbers\n  numbers.map {|x| x*max_number/min_number}\nend\n\
    </code>\n<|/ a dscore=2 tags=ruby-on-rails,ruby |>\n<| a |>\nHere is a function\
    \ which does what you need:\n<code>", "  return numbers.map do |number|\n    number\
    \ = ((number - min) / (max - min)) * 2 - 1\n    number + min\n  end\nend", " \
    \   unit_numbers = []\n    numbers.each { |num| unit_numbers << num if num > 0\
    \ }\n    unit_numbers.min\n    unit_numbers.max\nend", "    numbers.collect{|x|\
    \ x/numbers.min}\nend\n</code>\nI hope it helps someone!\n<|/ a dscore=4 |>\n\
    <| a |>\n<code>\n[1,2,3].map {|x| x*2}\n=> [2, 4, 6]\n</code>\n<|/ a dscore=4\
    \ tags=arrays,ruby,math,function |>\n<| a dscore=4 tags=arrays,ruby,math,function\
    \ |>\n<code>\na = [1,2,3]\nb = a.map{|x| x*2}\nb # => [2, 4, 6]\n</code>\n<|/\
    \ a |>\n<| a tags=arrays,ruby,math,function |>\nJust in case someone else is still\
    \ looking for the same solution, in my case the array's size is dynamically changing\
    \ and so, I prefer to use inject:\n<code>\narr = [1,2,3,4,5]\narr.inject(:+)\n\
    => 15\n</code>\n<|/ a dscore=4 |>\n<| a dscore=3 |>\nIn case you don't want to\
    \ use inject:\n<code>\n[1,2,3].map { |x| x * 2 }", "  smallest_number = numbers.first\n\
    \  largest_number = numbers.last", "  numbers.inject(0) {|sum,x| sum + x }\n \
    \ numbers / (numbers.max - numbers.min)\nend", "  min_number = numbers.min\n \
    \ max_number = numbers.max\n  range_number = (max_number - min_number)\n  [min_number,\
    \ max_number] = [range_number * min_number, range_number * max_number]\n  numbers.map\
    \ { |number| number / (max_number - min_number) }\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\nI had the same problem as you and after some research and testing\
    \ I came up with a simple solution that doesn't require any loops. \n<code>",
  "  min = numbers.min\n  max = numbers.max\n  scale = 1.0 / (max - min)\n  numbers.map!\
    \ {|n| n * scale}\nend", "    minimum = numbers.min\n    maximum = numbers.max\n\
    \    scaled = [((x - minimum) / (maximum - minimum)) for x in numbers]\n    minimum,\
    \ maximum = scaled.min, 0.95 * scaled.max\n    scaled_rescaled = [((x - minimum)\
    \ / (maximum - minimum)) for x in scaled]\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n    numbers.reverse!\n\
    \    numbers.reverse", "  return map(min, numbers).zip(map(max, numbers)).map(&:map).map(&:to_f)\n\
    end", "  min = numbers.min || Float::INFINITY\n  max = numbers.max || -Float::INFINITY\n\
    \  range = max - min\n  numbers.map { |n| n - min * range / max }\nend\n</code>\n\
    <|/ a tags=ruby,range,floating-point |>\n<| c |>\nYour first paragraph seems to\
    \ suggest that this code is wrong: \"...apply a linear transform to that list,\
    \ such that the smallest number will become 0 and the largest will become 1\"\
    . It seems that the transformation you're describing is one that makes the largest\
    \ number be 1 and the smallest number be zero.\n<|/ c |>\n<| c |>\n: You are correct.\
    \ I misinterpreted the \"range\" variable to be the interval of the numbers rather\
    \ than the difference between the first and last numbers. I fixed my answer to\
    \ reflect that interpretation.\n<|/ c |>\n<| a dscore=5 |>\nI used the suggestion\
    \ from to write a function and improve it a bit by allowing a minimum value for\
    \ the range. My version follows:\n<code>", "  if numbers.empty?\n    []\n  else\n\
    \    rescaled_numbers = numbers.map{ |n| n / numbers.min }\n    rescaled_numbers.map!(&:round)\n\
    \    rescaled_numbers.min == 0 ? rescaled_numbers : rescaled_numbers + [rescaled_numbers.max]\n\
    \  end\nend", "  numbers.min\nend", "  numbers.map { |number| number / numbers.min\
    \ }\nend", "  # Sort the list if needed, but we don't need to sort it when applying\
    \ linear transform\n  sorted_numbers = numbers.sort_by { |n| n }", "  numbers.min!(0.0)\n\
    \  numbers.max!(1.0)\n  numbers*((numbers - numbers.min) / numbers.max)\nend",
  "  minimum = numbers.min\n  maximum = numbers.max\n  number_range = maximum - minimum\n\
    \  return numbers - minimum / number_range\nend", "  return numbers.map{|n| n\
    \ * scale}\nend", "  if numbers.empty?\n    []\n  el = numbers.shift\n  rescaled\
    \ = []\n  until numbers.empty?\n    rescaled << el * (numbers.shift.abs / el.abs)\n\
    \    el = numbers.shift\n  end\n  rescaled\nend", "  # if there are no numbers\
    \ in that list, return an empty list to avoid errors\n  return numbers unless\
    \ numbers.length >= 2\n  # if there's only one number in the list, then return\
    \ it\n  return numbers if numbers.length == 1\n  # find the minimum and maximum\
    \ numbers in the list\n  minNum, maxNum = numbers.minmax_by(&:to_f)\n  # return\
    \ the minimum, maximum, and scale factor\n  [minNum, maxNum, (maxNum - minNum).to_f]\n\
    end", "    smallest_num = numbers.min\n    biggest_num = numbers.max\n    return\
    \ ((numbers - smallest_num) / (biggest_num - smallest_num)).round\nend", "  #\
    \ Get the min/max values\n  min_number = numbers.min\n  max_number = numbers.max",
  "  return numbers.map(&:to_f)/numbers.map(&:abs)\nend", "  numbers.each_with_index\
    \ { |i, n| \n    if n < min then\n      numbers.delete_at(n)\n      numbers.delete_at(0)\n\
    \      break\n    end\n    max = numbers[-1]\n    if i > max then\n      numbers.delete_at(-1)\n\
    \      numbers.delete_at(-1)\n      numbers.delete_at(-1)\n      break\n    end\n\
    \    if i == max then\n      i = 1\n      break\n    end\n    min = numbers[0]\n\
    \    if numbers.length == 1 then\n      numbers.delete_at(0)\n    end\n  }\nend",
  "  numbers.map {|number|\n    number * (1 / numbers.max)\n  }\nend", "  rescaled_numbers\
    \ = []\n  smallest_number = numbers.min\n  largest_number = numbers.max", "  numbers.map!\
    \ { |n| n / numbers.max }\n  numbers\nend\n</code>\nNow we can apply this function\
    \ to our data:\n<code>\ndata  = [\n  [3, 2],\n  [1, 5]\n]\n</code>\nWe apply the\
    \ function, and then plot them:\n<code>\nrescaled_data = rescale_to_unit(data)\n\
    p1 = plot(rescaled_data, :x, :y)\n</code>\nWe can see that by rescaling, we now\
    \ have 0s on the x-axis and 1s on the y-axis. \nIf you have any questions, just\
    \ ask!\n<|/ a |>\n<| a tags=data-visualization,r,plot |>\nI agree that it is better\
    \ to use ggplot2. I would rather do that and use scale_x_continuous to set limits:\n\
    <code>\ndf <- data.frame(var1 = rnorm(100, 0, 1),\n             var2 = rnorm(100,\
    \ 0, 1),\n             var3 = rnorm(100, 0, 1),\n             var4 = rnorm(100,\
    \ 0, 1))\ndf$grp <- c(rep(\"A\", 25), rep(\"B\", 25), rep(\"C\", 25))\ndf <- melt(df,\
    \ id.vars = c(\"grp\"))", "  scales = numbers.map {|n| -n / numbers.max }\n  scales.min!\n\
    \  scales.max!\n  scales.map {|s| s ** 2}\nend", "    min, max = numbers.minmax\n\
    \    numbers.map! { |x| (x-min)/(max-min) }\nend", "  minValue = numbers.min\n\
    \  maxValue = numbers.max\n  range = (maxValue - minValue)", "  return numbers.map\
    \ {|number| number / numbers.min.to_f}\nend\n</code>\nThis can be used like this:\n\
    <code>\narr = [10.0, 7.0, 13.0, 5.0, 3.0, 5.0]\narr.map { |number| number / numbers.min.to_f\
    \ }\n=> [10.0, 7.0, 13.0/5.0, 5.0, 3.0, 3.0]\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 |>\nIf your array is sorted, you can use the partition function to\
    \ get your desired outcome. \n<code>\n> arr = [10.0, 7.0, 13.0, 5.0, 3.0, 5.0]\n\
    > arr.partition(&:<)\n=> [[10], [7], [13.0/5.0, 3.0, 5.0]]\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\n`partition` is actually a really nice solution for an array sorted\
    \ in ascending order, and I believe that it does what it says it does. But note\
    \ that the OP explicitly asked for a solution that works for any sorted array.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\nYou could try something\
    \ like this:\n<code>", "  numbers.each do |number|\n    number = (number - numbers.min)/numbers.max\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhat do you mean by \"the smallest\
    \ number will become 0\"? How do you tell the smallest number from which number\
    \ should the smallest be kept?\n<|/ c |>\n<| c |>\nI meant it will become 0 when\
    \ you add all the numbers and then divide by their sum. You could also use the\
    \ inverse of `abs`, but since you want the smallest to be 0, you divide by it.\
    \ So `numbers.min / numbers.max`\n<|/ c |>\n<| c |>\nI see, you added a comment\
    \ to the question, that says the smallest should be 0, I guess I missed that.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,math |>\nAnother way to do this is to subtract\
    \ the smallest number from each number, then add them all together and divide\
    \ by the sum of the numbers. This is probably the most efficient method. It will\
    \ still work even if some numbers are negative and some are positive.\n<code>",
  "  smallest_number = numbers.min\n  largest = numbers.max\n  \n  # Rescale by smallest\
    \ number first\n  rescaled_numbers = numbers.map { |n| n / smallest_number }\n\
    \  \n  # Make sure we only rescale to the largest number if there are two or more\
    \ elements\n  if rescaled_numbers.size > 1\n    rescaled_numbers << largest\n\
    \  end\n  \n  # Return scaled numbers\n  rescaled_numbers\nend", "    smallest_number\
    \ = numbers.min\n    largest = numbers.max\n    (smallest_number,largest) = (smallest_number,largest)\
    \ if smallest_number==largest else (largest,smallest_number)\n    # Scale the\
    \ numbers to [0,1]\n    numbers.min = 0\n    numbers.max = 1.0\n    numbers =\
    \ (numbers - smallest_number) / (largest - smallest_number)\n    numbers\nend",
  "  sum = 0\n  sum_sq = 0\n  numbers.each do |n|\n    sum += n\n    sum_sq += n**2\n\
    \  end\n  max_value = numbers.last || 1\n  max_value_inv = 1.0/max_value\n  numbers.map!{\
    \ |n| n*max_value_inv }\n  sum ||= 1\n  sum_sq ||= 1\n  numbers.map!{ |n| n*n*max_value_inv\
    \ }\n  sum == sum_sq ? 0 : 1\nend\n</code>\nAnd now we can test it:\n<code>\n\
    numbers = [1, 2, 3, 4, 5]\nnumbers = rescale_to_unit(numbers)\nnumbers #=> [0.75,\
    \ 0.5, 1.25, 0.50, 0.50]\n</code>\nThis approach has some interesting properties:",
  "  min, max = numbers.minmax\n  return numbers.map { |n| n / max - min }\nend\n\
    </code>\nThe advantage is that it returns a list of numbers that has a uniform\
    \ distribution, while your original function returns a list of numbers.\n<|/ a\
    \ |>\n<| a |>\nI wrote a Ruby gem that does just that: Ruby-Egg-Distribution\n\
    You can install the gem by running gem install ruby-egg.\n<code>\nrequire 'ruby-egg'",
  "  scale = 1\n  min = numbers.min\n  max = numbers.max", "  numbers.map! { |n| n\
    \ / numbers.max }\nend", "  min = np.minimum(numbers)\n  max = np.maximum(numbers)\n\
    \  \n  scaled = numbers.map {|n| n / (max - min)}\n  \n  scaled_array = Array(scaled)\n\
    \  \n  scaled_array.map {|n| n == 0 ? 0 : 1 }\nend", "  min = numbers.min\n  max\
    \ = numbers.max", "  numbers = numbers.collect do |n|\n    if n < 0\n      -n\
    \ / 2\n    else\n      n / 2\n    end\n  end\n  numbers\nend", "  min = numbers.min\
    \ #\n  max = numbers.max\n  numbers.collect {|n| n * 1./((max - min))}\nend",
  "  minimum = numbers.min\n  maximum = numbers.max\n  return [minimum - (numbers\
    \ - minimum).min, (maximum - minimum).max]\nend", "  # TODO: Do something more\
    \ efficient here\n  rescaled_numbers = []\n  min_number = numbers.min\n  max_number\
    \ = numbers.max\n  number_range = max_number - min_number\n  smallest_difference\
    \ = number_range / 2\n  max_number_of_small_numbers = 4\n  num_small_numbers =\
    \ 0\n  smallest_number = numbers[0]\n  rescaled_numbers.push(smallest_number)\n\
    \  numbers.each do |n|\n    scaled_number = min_number + (n - smallest_number)\
    \ / number_range\n    rescaled_numbers.push(scaled_number)\n    smallest_number\
    \ = scaled_number\n    smallest_difference = number_range / 2\n    rescaled_numbers.delete_at(0)\n\
    \  end\n  rescaled_numbers.push(max_number)\n  if num_small_numbers > max_number_of_small_numbers\n\
    \    num_small_numbers = 0\n    rescaled_numbers.each do |n|\n      num_small_numbers\
    \ += 1\n      if num_small_numbers > max_number_of_small_numbers\n        break\n\
    \      end\n    end\n    smallest_number = numbers[0]\n    rescaled_numbers.push(smallest_number)\n\
    \  end\n  return rescaled_numbers\nend", "  smallest_number = numbers[0]\n  largest\
    \ = numbers[-1]\n  new_number = ((numbers - smallest_number) / (largest-smallest_number)).round(10)\n\
    \  return new_number\nend", "  numbers.reduce(:+)\nend", "  numbers.map(&:to_f)\n\
    end", "    numbers.sort!\n    rescaled_numbers = []\n    number_differences =\
    \ numbers[1] - numbers[0]\n    rescaled_numbers.push(numbers[0] / number_differences)\n\
    \    rescaled_numbers.push(1 - numbers[-1] / number_differences)\n    rescaled_numbers.push(numbers[-1]\
    \ / number_differences)\n    rescaled_numbers.sort!\n    return rescaled_numbers\n\
    end", "  min, max = numbers.minmax\n  scale = (max - min) / 256\n  numbers.map\
    \ { |n| n * scale + min }\nend", "  min = numbers.min\n  max = numbers.max", " \
    \   \n    # Get the smallest and largest in the list\n    min_, max_ = numbers.minmax\n\
    \    \n    # Scale the list to [0, 1]\n    scaled_numbers = numbers/(max_ - min_)\n\
    \    \n    # Now return the scaled list\n    return scaled_numbers\n    ", " \
    \   numbers.min!\n    numbers.max!\n    numbers.min.zero? || numbers.max.zero?\n\
    \    return numbers\nend", "    smallest_number = numbers.min\n    rescaled_numbers\
    \ = numbers.map { |number| number / smallest_number }\n    rescaled_numbers.minmax\n\
    end", "  min = numbers.min\n  max = numbers.max\n  scaled = numbers.map {|n| n/max*max\
    \ - min/min }\n  scaled\nend", "    numbers.map! do |n|\n        n / 1.\n    end\n\
    \    numbers\nend", "    numbers = (numbers - min(numbers))/(max(numbers) - min(numbers))\n\
    \    return numbers\nend", "    sum = 0.0\n    numbers.each { |n| sum += n }\n\
    \    numbers.map! { |n| n/sum }\nend", "  min_number = numbers.min\n  max_number\
    \ = numbers.max\n  difference = max_number - min_number", "  minimum, maximum\
    \ = numbers.min, numbers.max\n  numbers -= minimum # shift all numbers in array\n\
    \  numbers /= maximum - minimum\n  numbers # return normalized array (min - 0,\
    \ max - 1)\nend", "  return numbers.minmax\nend", "  numbers.sort! # Ensure that\
    \ first number is smallest\n  scale = 1\n  while numbers[-1] <= numbers.first\n\
    \    numbers.pop\n  end\n  while numbers.first > numbers.last\n    numbers.push(numbers.pop\
    \ * scale)\n    scale *= 10\n  end\n  numbers[0] = numbers[0] / scale\n  numbers[1]\
    \ = numbers[1] / scale\n  return numbers\nend", "  # Calculate the average of\
    \ the given numbers\n  avg = mean(numbers)\n  # Create a list with one element\
    \ containing the average of the given numbers\n  new_numbers = [avg]\n  # For\
    \ each element in the given list\n  numbers.each do |number|\n    # Calculate\
    \ the distance from the avg to the current number\n    distance = avg - number\n\
    \    # Calculate the new number\n    new_number = (distance / number) * number\n\
    \    # Add the new number to the new numbers list\n    new_numbers.push(new_number)\n\
    \  end\n  return new_numbers\nend", "  if numbers.size == 1\n    numbers = [numbers[0]]\n\
    \  end\n  min_max_number = numbers.minmax\n  return [numbers[0] / min_max_number[0],\
    \ numbers[1] / min_max_number[1]]\nend", "  numbers_sorted = numbers.sort\n  return\
    \ [((n - numbers.min) * numbers.max / (numbers.max - numbers.min) + numbers.min)\
    \ for n in numbers_sorted]\nend", "    # Compute the mean and standard deviation\n\
    \    mean = numbers.inject(0.0) { |sum, element| sum + element }\n    std_dev\
    \ = numbers.inject(0.0) { |sum, element| sum + Math.pow(element - mean, 2) }\n\
    \    # Compute the new scaled numbers\n    scaled = numbers.map do |number|\n\
    \        number * std_dev / mean\n    end\n    # Return scaled numbers\n    return\
    \ scaled\nend", "  # initialize minimum and maximum value\n  minimum = numbers.min\n\
    \  maximum = numbers.max\n  # initialize new list of rescaled numbers\n  rescaled_numbers\
    \ = []\n  # for each element in the list, subtract minimum and divide by maximum\n\
    \  numbers.each do |number|\n    rescaled_numbers << number-minimum/maximum\n\
    \  end\n  return rescaled_numbers\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This is what I needed, thank you so much! I was able to adapt it to my needs.\n\
    <|/ c |>\n<| a |>\nAnother way to do this with minimum and maximum\n<code>", " \
    \ min_number = numbers.min\n  max_number = numbers.max\n  numbers.map { |n| n/max_number\
    \ }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nTo be fair, your answer is a good\
    \ one, and doesn't involve anything from Rails. In fact, I upvoted it, but I should\
    \ probably upvote this one as well, since it is the shortest and easiest to understand\
    \ solution.\n<|/ c |>\n<| c |>\nI wish I could accept both answers. Yours was\
    \ also very helpful and is also an improvement on my other solution that does\
    \ work just fine.\n<|/ c |>\n<| c |>\n: Thanks for accepting mine. I would like\
    \ to upvote yours as well, if possible.\n<|/ c |>\n<| c |>\nWhat about `numbers.map\
    \ { |n| n / numbers.min }` ?\n<|/ c |>\n<| c |>\nI guess this is a good use case\
    \ for Enumerable#inject, though. `numbers.inject { |n| n / numbers.min }` is an\
    \ alternative to `numbers.map { |n| n / numbers.min }`\n<|/ c |>\n<| a dscore=5\
    \ |>\nIf you don't want your number to be floored:\n<code>", "  maximum = numbers.max\n\
    \  minimum = numbers.min\n  numbers.map do |x|\n    ((x - minimum) * 100.0 / maximum).round(2)\n\
    \  end\nend\n</code>\nAnd now we can just use it for our examples:\n<code>\n>\
    \ my_list = [\"5\", \"0\", \"1\", \"5\", \"0\", \"4\", \"0\", \"4\", \"5\"]\n\
    > my_list\n=> [\"5\", \"0\", \"1\", \"5\", \"0\", \"4\", \"0\", \"4\", \"5\"]\n\
    > rescale_to_unit(my_list)\n=> [\"0\", \"10\", \"0\", \"10\", \"0\", \"40\", \"\
    0\", \"40\", \"50\"]\n</code>\nThe second parameter to map function is the value\
    \ being mapped and the third parameter is the return value of the function which\
    \ is in this case a scaled value between 0 and 100 which is then rounded down.\n\
    <|/ a dscore=1 |>\n<| c |>\nThank you so much for answering.  This is an awesome\
    \ answer.  I would've upvoted it but I do not yet have enough reputation to do\
    \ so due to my lack of reputation.\n<|/ c |>\n<| c |>\nNo problem. Glad this helped\
    \ you out! I hope you will get more reputation soon as it is a great question.\n\
    <|/ c |>\n<| c |>\nJust wanted to let you know that I had to change your rescale_to_unit\
    \ method as your suggested solution was returning only a single value.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nHere is my solution to this problem using Ruby 1.9's built\
    \ in Enumerable module and a Hash.\n<code>", "  n = numbers.first\n  m = (numbers.last\
    \ - n) / 2.0\n  [n, m]\nend", "  numbers.each { |n| n /= max_number }\n  numbers.min\
    \ = (-max_number) + 1\n  numbers.max = (max_number) + 1\n  numbers\nend", "  smallest_num\
    \ = numbers.min\n  max_num = numbers.max\n  numbers.map! do |num|\n    num * max_num\
    \ / smallest_num\n  end\n  numbers\nend\n</code>\nThe above code takes three things\
    \ as input:", "    smallest_number = numbers.min\n    largest = numbers.max\n\
    \    smallest_number = smallest_number - 10\n    largest = largest + 10\n    numbers\
    \ = (numbers - smallest_number) / (largest - smallest_number)\n    numbers = numbers\
    \ * 2 - 1\n    return numbers\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  return numbers.map { |n| n/min * 2 - 1 }\nend", "    smallest = numbers[0]\n\
    \    largest = numbers[0]\n    smallest_index = 0\n    largest_index = 0", " \
    \ minval = numbers.min\n  maxval = numbers.max\n  if minval == 0 then return numbers\n\
    \  if maxval == 1 then return numbers\n  if maxval == -1 then return [-x for x\
    \ in numbers]\n  new_numbers = []\n  for i in numbers\n    offset = minval / maxval\n\
    \    new_numbers.push((maxval - i) * offset + i)\n  return new_numbers\nend",
  "  numbers.map! {|n| n % 1 == 0 ? n : 1/n}\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a |>\nIf you want an explanation for the code, here is some code I wrote in\
    \ Ruby a while ago.\n<code>", "  return numbers.map {|num| (num - numbers.min)/numbers.max\
    \ }\nend", "  smallest_number = numbers.min || Float::MAX\n  last_number = numbers.last\n\
    \  new_numbers = numbers.map { |num| num / smallest_number }\n  new_numbers.unshift(smallest_number\
    \ / last_number)\n  new_numbers\nend\n</code>\nAs you can see, this can be made\
    \ more concise by just using min, max and last.\n<|/ a |>\n<| a tags=ruby dscore=3\
    \ |>\nI like answers from and but I think I liked this a bit better\n<code>",
  "  result = numbers.map {|n| n / numbers.max}\n  result[0] += 1\n  result[-1] -=\
    \ 1\n  result\nend", "  numbers.min\n  numbers.max\nend", "    numbers.min.times\
    \ { |n| n /= 2.0 }\n    numbers.max.times { |n| n *= 1.0 }\n    numbers\nend\n\
    </code>\nThen you can do:\n<code>\n(2..10).map { |x| x * x }.reduce(:+)\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nIf you're looking for a general purpose way\
    \ to find the most common value in a list then I'd say you're looking for a histogram.\
    \ Here's a Ruby implementation, based on the code from my answer to the question\
    \ \"Ruby histogram implementation\":\n<code>\nrequire 'set'", "  minimum = numbers.min\n\
    \  maximum = numbers.max\n  (minimum + maximum) / 2.0\nend\n</cell>\n<code language=julia-0.5>",
  "  smallest_number = numbers.min\n  max_number = numbers.max\n  numbers[numbers.index(smallest_number)]\
    \ = 0.0\n  numbers[numbers.index(max_number)] = 1.0\nend\n</code>\nNote that this\
    \ won't work if you pass it a vector of strings or similar, because those are\
    \ always interpreted as floats. If that's not ok, you can use a regexp to convert\
    \ each element to float like this:\n<code>\nrescale_to_unit([1, 2.0, \"3\"])",
  "  maximum = numbers.max\n  minimum = numbers.min\n  return numbers.map { |number|\
    \ number - minimum + maximum/2 }\nend", "  smallest_number = numbers.min\n  numbers[numbers.index(smallest_number)]\
    \ = 0.0\n  numbers[numbers.index(numbers.max) - 1] = 1.0\nend", "  return numbers.min.to_f\
    \ / (numbers.max * 2.0) - 1.0\nend", "    smallest, largest = numbers.minmax\n\
    \    return [((number - smallest) / (largest-smallest)) for (number) in numbers]\n\
    end", '  min, max = numbers.minmax', "  # Compute the min, max, mean and standard\
    \ deviation\n  minimum = numbers.min\n  maximum = numbers.max\n  mean = numbers.mean\n\
    \  standard_deviation = numbers.std", "    smallest = numbers.min\n    largest\
    \ = numbers.max\n    rescaled = [(largest-smallest)/num for num in numbers]\n\
    \    return rescaled\nend", "    rescaled_numbers = numbers.map { |n| n * (2 **\
    \ -16) }\n    rescaled_numbers.max_by(&:abs).min\nend", "  numbers.min\nend",
  '  numbers.min!', "  # Get the min and max of the list\n  min_number = numbers.min\n\
    \  max_number = numbers.max\n  # Normalize the numbers\n  numbers.map { |n| n\
    \ / max_number * 2 - 1 }\nend", "  min, max = numbers.minmax\n  numbers.map {\
    \ |n| n / max - min }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nYou\
    \ can use Enumerable#chunk with a custom chunk size and a block returning an Array\
    \ which will hold the chunked items. I believe your code is better than mine,\
    \ however, I will add this example anyway since it is interesting and might help\
    \ someone else.\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,10]", "  return numbers.map\
    \ { |n| (n - n%1) }\nend\n</code>\n<|/ a tags=arrays,ruby dscore=1 |>\n<| a tags=arrays,ruby\
    \ |>\nIf you would like to stick to your original array approach and you just\
    \ need to divide each number by the size of the array (which would be a reasonable\
    \ way to round the numbers), you could do this:\n<code>", "  if numbers.empty?\n\
    \    []\n  else\n    # Sort and find min, max, and mean\n    numbers.sort!\n \
    \   min_val = numbers.first\n    max_val = numbers.last\n    avg = numbers.inject(0.0)\
    \ { |sum, el| sum + el }\n    rescaled = numbers.map do |x|\n      if x < min_val\n\
    \        min_val\n      elsif x > max_val\n        max_val\n      else\n     \
    \   x - (min_val - avg) / (max_val - min_val) * (x - avg)\n      end\n    end\n\
    \    rescaled\n  end\nend", "  smallest_number = numbers.min\n  max_number = numbers.max",
  "  return numbers.map {|n| n / (numbers.max - numbers.min) }\nend", "  min, max\
    \ = numbers.minmax\n  return map(\n    function(n) 0 if n < min else 1 - (n -\
    \ min) / (max - min),\n    numbers\n  )\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis is much more complicated than it needs to be. Also, I don't see how\
    \ it answers the question.\n<|/ c |>\n<| c |>\n: I've added a more concise version\
    \ to my answer.\n<|/ c |>\n<| c |>\nSorry, I should have mentioned this is for\
    \ Ruby, not Rails. But I did find [this link](http://stackoverflow.com/questions/924541/what-is-the-best-algorithm-to-find-the-range-of-an-array-in-ruby),\
    \ which may be of use to some.\n<|/ c |>\n<| c |>\nIn fact you might not need\
    \ my code. It uses Rails, so it won't be too difficult to adapt to Ruby if you\
    \ really need it. My code was written as a pure Ruby exercise, so I don't think\
    \ it would need to be much adapted.\n<|/ c |>\n<| a |>\nThis is just to provide\
    \ another answer.\n<code>\nx = [-15, -10, -8, -5, -4, -3, -2, -1, 0, 1, 2, 3,\
    \ 4, 5]", "  numbers.min! # Assumes smallest number will always be 0\n  numbers.max!\n\
    \  numbers.map! do |number|\n    number * 1.0 / numbers.min\n  end\nend", "  \
    \  numbers.map { |n| n/numbers.max }\nend\n</code>\nAnd then you have:\n<code>\n\
    rescale_to_unit([10, 9, 5])", "  numbers.each do |n|\n    if n < 0 \n      n =\
    \ -n\n    end\n  end\n  numbers[0] = 0\n  numbers[numbers.length - 1] = 1\n  numbers.map\
    \ { |n| n*100 }\nend", "  return numbers.map { |n| n/numbers.max }\nend\n</code>\n\
    The function can be easily applied in each column:\n<code>", "  if numbers.empty?\n\
    \    [1, 0]\n  else\n    smallest_number = numbers.min\n    biggest_number = numbers.max\n\
    \    [(numbers - smallest_number) / (biggest_number - smallest_number), 1]\n \
    \ end\nend", "    \n    # Return empty list if list is empty\n    if numbers.size\
    \ == 0\n        return numbers", "  max = numbers.max\n  min = numbers.min", " \
    \ numbers.sort!\n  new_numbers = []\n  numbers.each do |n|\n    new_numbers.push(0\
    \ if n < 0)\n    new_numbers.push(1 if n > 0)\n  end\n  return new_numbers.reverse\n\
    end\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| a |>\nRuby has a built-in method\
    \ to do that :\n<code>\n2.upto(0..10).map { |i| i**2 }\n=> [1, 4, 9, 16, 25, 36,\
    \ 49, 64, 81, 100]\n</code>\n<|/ a dscore=3 tags=ruby |>\n<| c |>\nJust as I said\
    \ in my answer, I like this better than `collect`. `collect` will create a new\
    \ Array while this one will mutate the original Array. Just a matter of style\
    \ I guess\n<|/ c |>\n<| c |>\nActually this is better than my solution (since\
    \ it avoids the need for `map`), but it still has `collect`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nAnother way without collect would be to use Enumerable#reduce (docs):\n\
    <code>", "  numbers.each do |num|\n    num.times { |i| numbers[i] /= 1.0 }\n \
    \ end\nend", "  # TODO: This can be optimized by removing the redundant if-statement\n\
    \  if numbers.size < 2\n    numbers\n  else\n    rescaled = numbers.min * 1.0\
    \ / (numbers.max - numbers.min)\n    numbers - rescaled\n  end\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby |>\n<code>\na = [0,10,20,30,40,50,60,70,80]\na.map {\
    \ |num| (num/a.min).floor*a.min*2 }", "  numbers.map {|n| n/numbers.min }\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby dscore=1 |>\nYou could use the Enumerable#each_cons\
    \ method. This will create an enumerator object for every two elements in the\
    \ array, and then you can use Enumerable#inject to find the average of the numbers\
    \ within each group:\n<code>\narr.each_cons(2).inject(:+) / arr.size", "  numbers.reduce(:+)\
    \ / numbers.length\nend\n</code>\n(Remember that Scala code works like this: reduce(:+)\
    \ is the same thing as reduce(+).)\nThis gives you a function that will transform\
    \ any list of numbers into that list, with numbers scaled in the range [0, 1].\
    \ For example, passing in a list [3, -4, 2, 7, 9, 12] will give you a list [0.0,\
    \ 0.3333, 1.0, 0.6667, 1.0, 1.0].\n<|/ a dscore=1 tags=ruby,arrays,ruby-on-rails,math\
    \ |>\n<| a |>\nHere's one approach:\n<code>\narr = [4, 2, 9, 7, 2, 0]\narr.map\
    \ { |e| e / (arr.max - arr.min) }", "  min, max = numbers.minmax\n  numbers =\
    \ (numbers - min).div(max - min)\n  numbers << 0 if min == 0 && max == 1\n  numbers\n\
    end", "  numbers.each do |num|\n    next if num == 0\n    num = num / numbers.last\n\
    \  end\nend", "  numbers.each do |n|\n    if n < 0 then\n      n = n * -1\n  \
    \  end\n  end", "  if numbers.empty?\n    return numbers\n  numbers.sort.reverse\n\
    \  result = [0.0]\n  numbers.each_with_index { |n, i| result[i] = n / numbers[i\
    \ - 1] }\n  result\nend", "  numbers.each do |n|\n    if n < 0\n      n = -n\n\
    \    end\n  end\n  numbers.map {|n| n/numbers.sum}\nend\n</cell>\n<text>\nFinally,\
    \ we can check that the rescaling has worked:", "  rescaled = numbers.map { |n|\
    \ (n - min(n)) / (max(n) - min(n)) }\nend", "    mini = numbers.min\n    maxi\
    \ = numbers.max\n    \n    numbers = numbers.map { |n| (n - mini) / (maxi - mini)\
    \ }\n    \n    numbers\nend", "    smallest = numbers[0]\n    largest = numbers[0]\n\
    \    numbers.each {|x| smallest = x.abs < smallest ? x : smallest}\n    numbers.each\
    \ {|x| largest = x.abs > largest ? x : largest}\n    smallest.times {|x| x /=\
    \ largest}\n    largest\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like\
    \ this. I added a test case to my answer with a variation of your answer, where\
    \ all positive numbers are unchanged and all negative numbers are flipped. `numbers.each\
    \ {|x| smallest = x.abs < smallest ? x : smallest}` will result in `-1` for `[5,\
    \ 4, 3, -5, -4]`.\n<|/ c |>\n<| a tags=ruby,arrays |>\nI do not know if there\
    \ is a better way to do this in ruby. I implemented my solution using recursion.\n\
    <code>", "  numbers.sort! # sort in ascending order\n  scale = (numbers.max -\
    \ numbers.min).abs\n  return [numbers[0] + (numbers[1]-numbers[0])/scale * scale\
    \ ]\nend", "  numbers.sort!\n  return numbers unless numbers.any? { |x| x < 2\
    \ }\n  scale = numbers.min / 2\n  rescaled = numbers.map { |x| x * scale }\n \
    \ rescaled.sort!\n  rescaled\nend", "  smallest = numbers.min\n  largest = numbers.max\n\
    \  rescaled_numbers = []\n  smallest_rescaled = 0\n  largest = 0", "    min, max\
    \ = numbers.minmax\n    if min == 0 and max == 1: return numbers\n    mid = (min\
    \ + max) / 2\n    rescaled = ((numbers - min) * mid / max) + mid\n    return [rescaled]\
    \ if rescaled == numbers.min else [rescaled, rescaled]\nend", "  numbers.each\
    \ do |num|\n    if num < 0\n      num = 0\n    end\n  end\n  numbers.min\nend",
  "  numbers.map!{|x| x}\n  x = numbers.min\n  y = numbers.max\n  numbers.map!{|x|\
    \ x}\n  xrange = numbers.min..numbers.max\n  numbers.map!{|x| x}\n  xrange = xrange.min..xrange.max\n\
    \  yrange = xrange..1\n  numbers.map!{|x| x*y}\nend", "    # return numbers unless\
    \ all are 0\n    numbers.reject { |n| n == 0 }\n    # convert them into floating\
    \ point numbers\n    numbers.map { |n| n / 255 }\nend", "  minnum = numbers.min\n\
    \  maxnum = numbers.max\n  numbers = numbers - minnum\n  numbers = (maxnum - minnum)\
    \ * numbers / numbers.max # rescale to be between -1 and 1\n  numbers = numbers\
    \ + minnum # shift to become min from 0\nend", "  numbers.map { |n| n/numbers.min\
    \ }\nend\n</code>\n<code>", "  mins = numbers.min\n  maxs = numbers.max\n  numbers\
    \ = (numbers - mins).map { |x| (x - mins).fdiv(maxs - mins) }\n  numbers << (maxs\
    \ - mins).fdiv(2)\nend", "  numbers.each_with_index do |n, i|\n    if n < numbers[0]\n\
    \      numbers[i] = 0\n    end\n    if n > numbers[-1]\n      numbers[i] = 1\n\
    \    end\n  end\nend", "  numbers.each do |number|\n    if number > max\n    \
    \  number = 1.0\n    elsif number < min\n      number = 0.0\n    end\n  end\n\
    end", "  smallest_number = numbers.min\n  largest = numbers.max\n  difference\
    \ = largest - smallest_number\n  return smallest_number + difference * (numbers.size\
    \ - 1)\nend", "  return numbers.map do |number|\n    number < 0.5 ? 0.0 : 1.0\n\
    \  end\nend", "  first_element = numbers[0]\n  last_element = numbers[-1]\n  midpoint\
    \ = numbers[1] + numbers[-2]\n  rescaled = midpoint - first_element + last_element\n\
    \  new_numbers = []\n  new_numbers.concat numbers\n  new_numbers.concat [0.0]\
    \ * (rescaled / first_element)\n  new_numbers.concat [1.0] * (rescaled / last_element)\n\
    end", "  # Find minimum and maximum value in the list\n  number_min = numbers.min\n\
    \  number_max = numbers.max\n  \n  rescaled = numbers.map {|x| \n    (x-number_min)/number_max\n\
    \  }\n  \n  # Return the transformed list\n  rescaled\nend", "  min_val, max_val\
    \ = numbers.minmax\n  numbers.minmax = (0,1)\n  numbers.map {|n| n * min_val /\
    \ max_val}\nend\n</code>\nThis method is quite fast: it can take an array with\
    \ 1 million elements and make only a few thousand comparisons (it also does not\
    \ change the number of elements in the array).\nAs the last step I did a test\
    \ of the above method with a list with 1000 elements:\n<code>\n>> def rescale_1000_to_unit(numbers)\n\
    >>   numbers.minmax = (0,1)\n>>   numbers.map {|n| n * numbers.minmax[1] / numbers.minmax[0]}\n\
    >> end\n=> nil\n>> times = 1000\n>> arr = Array.new(times) {Array.new(times) {rand(1000)}}\n\
    => [[741, 499, 121, ...], [492, 594, 414, ...], [104, 135, 343, ...], ...] ",
  "  smallest_number = numbers.min\n  max_number = numbers.max\n  if smallest_number\
    \ == max_number\n    smallest_number = 0\n    max_number = 1\n  new_numbers =\
    \ []\n  numbers.each { |x| new_numbers << x/max_number }\n  new_numbers\nend",
  "  numbers.each do |number|\n    number -= minimum(number) if minimum(number) !=\
    \ 0\n    number /= maximum(number) - minimum(number)\n  end\n  numbers\nend",
  "  numbers.each_with_index do |number, i|\n    if number > numbers.min_by(&:last)\n\
    \      numbers[i] = numbers[i] * 0.99\n    else\n      numbers[i] = numbers[i]\
    \ * 1.01\n    end\n  end\n  numbers\nend\n</code>\n<|/ a |>\n<| c |>\nI understand\
    \ your example, but I do not understand how the numbers are transformed. I just\
    \ have two numbers. My problem is that I cannot get them to be converted to units.\
    \ I think I understand how to map numbers to [0,1], but I don't understand how\
    \ to make them scale to the unit [0,1].\n<|/ c |>\n<| c |>\nSo I guess my problem\
    \ is that I don't understand how to map my input numbers to their new values.\
    \ If I understand correctly, it seems like you only need the mapping function\
    \ and the other two functions. The numbers are already scaled. But how do I pass\
    \ this information to the function I have?\n<|/ c |>\n<| c |>\nI don't understand.\
    \ Your example shows how to transform numbers to [0,1]. But the example you gave\
    \ also shows the two functions `rescale_to_unit` and `rescale_from_unit`. I see\
    \ no difference between them. Why would I need both of them? And how do I use\
    \ these functions to do what I want to do?\n<|/ c |>\n<| c |>\nOh wait, `rescale_to_unit`\
    \ doesn't seem to work. `[2,4,6,8].map { |n| n / 100.0 }` returns `[2,4,6,8]`.\n\
    <|/ c |>\n<| c |>\nI edited the answer. I think it's what you need, just use them\
    \ as you need, and don't forget to pass the number you get from the input as parameter\
    \ of these functions.\n<|/ c |>\n<| a tags=arrays,ruby |>\nI believe you're looking\
    \ for something like this:\n<code>\nnumbers = [2,4,6,8]", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |num| min + (max - min) * num }\nend", " \
    \ numbers.map! {|x| x / numbers.min }\nend", "  numbers.reduce(:+) / numbers.reduce(:+)\
    \ == 1 ? numbers.reduce(:+) : 1/numbers.reduce(:+) \nend", "  min = numbers.min\n\
    \  max = numbers.max\n  range = (max - min)/2\n  numbers.map {|n| n * range +\
    \ min}\nend", "  numbers.map { |n| n / numbers.max }\nend", "  # Return the input\
    \ unaltered if it contains no numbers\n  return numbers if numbers.size > 1 else\
    \ numbers\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
