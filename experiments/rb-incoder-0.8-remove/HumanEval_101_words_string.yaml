name: HumanEval_101_words_string
language: rb
prompt: "# You will be given a string of words separated by commas or spaces. Your\
  \ task is\n# to split the string into words and return an array of the words.\n\
  # For example:\ndef words_string(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n\
  \    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\"\
  , \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"\
  One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two,\
  \ three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"\
  Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\"\
  , \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([],\
  \ candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"\
  ahmed     , gamal\"))\n  end\nend\n"
completions: ["  s = s.downcase\n  s.gsub!(/[^a-z\\s]/, '')\n  s.split(/,/)\nend",
  "    words = s.split(', ')\n    words.shift\n    words\nend\n</cell>\n<cell>", " \
    \   words=[]\n    split=s.split(\",\")\n    for word in split\n        words.append(word)\n\
    \    return words", "  words = s.split \",\"\n  words[0] = words[0].split(\"\\\
    s\")\n  words[1] = words[1].split(\"\\s\")\n  return words\nend", "  words = s.split(//)\n\
    end\n</pre>", "  s.split\nend\n</pre>\n</li>", "    # Split string into array\
    \ of words.\n    s = s.split\n    return s\nend", "    return s.split(\",\").map\
    \ { |word| word.strip}\nend", "  words = s.split(',')\n  words.map! {|w| w.downcase.split}\n\
    \  words.to_a\nend\n</pre>", "    words = s.split\n    words\nend", "    # Write\
    \ your code here\n    words = s.split(',')\n    return words.map{|word| word.strip}\n\
    end", "    wordsArray = s.split(/,/)\n    return wordsArray\nprint(words_string(\"\
    Hello, world.\")) # => [\"Hello\", \"world.\"]\nprint(words_string(\"Hello world\"\
    )) # => [\"Hello\", \"world\"]\nprint(words_string(\" Hello  world\")) # => [\"\
    Hello\", \"world\"]\nprint(words_string(\" Hello  world \")) # => [\"Hello\",\
    \ \"world\"]", "  a = s.split(' ')\n  return a\n  ", "  word_list = s.gsub!(/[,\\\
    s\\n]/, ' ').gsub(/\\s+/, ' ').split(' ')\n  return word_list unless word_list.any?\n\
    \  word_list\nend", "  s.split(/,| /)\nend", "  s.split\nend", "    return s.split(',')\n\
    end", "  s.split(//)\nend", "  # Split the string into individual words.\n  words\
    \ = s.split(\" \")\n  # Print the words.\n  words.each do |word|\n    print word\n\
    \  end\n  # Return the words.\n  words\nend", "  s = s[0].upcase\n  s = s.split(\"\
    \ \")\n  s.each { |w| puts w }\n  puts \"Your words are: #{s}.\" \nend", "  words\
    \ = s.split # You may wish to use a regular expression\n  words.map { |word| word.strip\
    \ }\nend", "  words = s.split #=> [\"string\", \"split\", \"this\", \"by\", \"\
    words\"]\n  words.to_s       # => \"string\\nsplit\\nthis\\nby\\nwords\"\n  words.map(&:capitalize)\
    \ # => [\"String\", \"Split\", \"This\", \"By\", \"Words\"]\n  words.join(\",\
    \ \")    # => \"String, Split, This, By, Words\"\nend", "    words = s.split(/,|\
    \ /)\n    words.pop\n    words.pop\n    words\nend\n</cell>\n<code language=julia-1.0>",
  "  s.split(' ').map{ |w| w.to_i }\nend", "  words.split(s)\nend", "  return s.split(/,|\\\
    s/)\nend", "    puts(s.split(', '))\nend", "  words = s.split()\n  words.reject{|word|\
    \ word.empty?}\n  words\nend\nprint(words_string(\"hello, world\"))", "  s = s.split(/,|\
    \ /)\nend", "  return s.split(' ')\nend\n</cell>\n<cell>\nwords_string('a,b,c,d')\
    \ # => [\"a\", \"b\", \"c\", \"d\"]\nwords_string('a b c d') # => [\"a\", \"b\"\
    , \"c\", \"d\"]\nwords_string('a, b') # => [\"a\", \"b\"]\nwords_string('a,  \
    \ b') # => [\"a\", \"b\"]\nwords_string('a , b,c d') # => [\"a\", \"b\", \"c\"\
    , \"d\"]\nwords_string('a,\\tb\\tc\\td') # => [\"a\", \"b\", \"c\", \"d\"]\nwords_string('a\\\
    n,b\\n,c') # => [\"a\", \"b\", \"c\"]\n</cell>\n<cell>", "    words = s.split('\
    \ ')\n    words[0] = words[0][1..-1]\n    words[] = words[][2..-1]\n    words[]\
    \ = words[][:1]\n    return words\nend", "  s.scan(/^\\S*\\w+\\S*$/).map{ |word|\
    \ word.strip }\nend", "    words = s.split(\" \")\n    words.each {|word| puts\
    \ word}\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the reply! This helped me\
    \ understand how to implement a function. I found the ruby docs on strings that\
    \ helped me a lot as well!\n<|/ c |>\n<| a |>\nAs pointed out, String#split is\
    \ more efficient in this case than String#scan, because it will not have to scan\
    \ for matches before it can start matching. String#scan will have to scan the\
    \ string twice.\nHowever, I would argue that String#split is more readable and\
    \ maintainable, and is more explicit about what it's doing. And unless you really\
    \ want to understand regular expressions, then String#scan is probably the simpler\
    \ option. Also, it should be noted that String#scan is more efficient on large\
    \ strings, because it's non-lazy (i.e. it only has to match against the string\
    \ once, instead of once per matched character).\n<code>\ns = \"Hello World\"\n\
    s.split('') # => [\"Hello\", \"World\"]\ns.scan(/./) # => [\"H\", \"e\", \"l\"\
    , \"l\", \"o\", \" \", \"W\", \"o\", \"r\", \"l\", \"d\"]\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ dscore=3 |>\n<| a |>\nThe most important difference between these two is the\
    \ difference between split and scan.\nLet's say you have some string and you want\
    \ to split it into an array. \n<code>\nstr = \"HelloWorld\"\n</code>\nThe split\
    \ method is used to split a string into an array. \n<code>\nstr.split(\"o\") #\
    \ => [\"H\", \"e\", \"l\", \"l\", \"o\", \" \", \"W\", \"o\", \"r\", \"l\", \"\
    d\"]\n</code>\nThe scan method is used to split a string into an array.\n<code>\n\
    str.scan(/./) # => [\"H\", \"e\", \"l\", \"l\", \"o\", \" \", \"W\", \"o\", \"\
    r\", \"l\", \"d\"]\n</code>\nThe scan method works differently. It does not search\
    \ the entire string. Instead it looks for certain patterns within the string and\
    \ if it finds it, it puts that pattern in the array.\nFor example:\n<code>\nstr.scan(/o+/)\
    \ # => [\"H\", \"e\", \"l\", \"l\", \"o\", \"W\", \"o\", \"r\", \"l\", \"d\"]\n\
    </code>\nThe above method scans the string for patterns of o, and then puts those\
    \ patterns into an array and returns it.\n<|/ a dscore=3 tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails-3,ruby-on-rails |>", "  s.split\nend", "  \
    \  # Split the string into individual words by\n    # calling s.split() and then\
    \ convert the words\n    # to an array. Note: This does not remove empty\n   \
    \ # words like \"a  \".\n    return s.split(/,|\\s/)\nend\nputs words_string(ARGV[0])",
  "  result = s.split.map { |s| s.strip }\n  result\nend", "    words = s.split(',\
    \ ') # Split s into words using the comma as delimiter\n    words.each { |word|\
    \ puts word } # Print each of the words\n    words.count { |word| word.include?(',')\
    \ } # Count the number of words with commas\nend", "    # Split the string s into\
    \ an array of words \n    # using Ruby's String#split method\nend", "  s.split(\"\
    \ \")\nend", "  return s.split(',')\nend", "    return s.split(',')\n    # return\
    \ s.split()", "    splits = s.split (',')\n    words = splits.map {|x| x.strip\
    \ ().split (/\\s+/)}.flatten\n    words.uniq!\nend\nassert words_string ('cat,\
    \ dog, mouse') === ['cat', 'dog', 'mouse']\nassert words_string ('cat,dog,mouse')\
    \ === ['cat', 'dog', 'mouse']\nassert words_string ('cat, dog, mouse') === ['cat',\
    \ 'dog', 'mouse']\nassert words_string ('cat, dog, mouse, elephant') === ['cat',\
    \ 'dog', 'mouse', 'elephant']\nassert words_string ('cat, dog, mouse, elephant,')\
    \ === ['cat', 'dog', 'mouse', 'elephant']\nassert words_string ('cat, dog, mouse,\
    \ elephant,cat') === ['cat', 'dog', 'mouse', 'elephant', 'cat']", "  s.split.to_a\n\
    end", "  # split s into words\n  words = s.split(\" \")\n  # return array of words\n\
    \  return words", "    words = s.split(\" \")\n    return words\nprint(words_string(\"\
    The quick brown fox jumps over the lazy dog\"))", "    words = s.split(/,|\\s/)\n\
    end", "    words = s.split()\n    return words\nend\n</cell>\n<text>\nSolution\n\
    The following cell contains your function in the form of question 3's solver.\
    \ If you solved it, please check back here for the solution.", "    # Write your\
    \ code here.\nend", "  s.split(', ')\nend", "    array = s.split(', ')\n    array.each\
    \ do |word|\n        puts word\n    end\nend", "    # split_words\nend", "  s.split(',').map(&:strip)\n\
    end", "  words = s.split ','\n  p words\nend", "  s.split(',').map(&:split).map(&:join)\n\
    end", "    words = []\n    # Your code here!\n    s.split(//)\nend", "  s = s.split(/,|\\\
    s/)\n  return s\nend", '    return s.split(/,|\s+/)', "  s.split(/,/)\nend", " \
    \ \n  # BEGIN CODING HERE\n  \n  words = s.split(',').map do |word| \n    word\
    \ = word.strip\n    word\n  end \n  \n  # END CODING HERE\n  \n  words.uniq\n\
    end", "    # Split the string into words by spaces\n    words = s.split ', '\n\
    \    # Convert the words into an array\n    words = words.map { |w| w.strip }\n\
    \    # Return the array\n    return words\nend\n</code>\nNext we have the function\
    \ that will count the number of occurrences of any word in the given list:\n<code>",
  "    words = s.split(' ')\n    return words", "  s.split(/\\W+/)\nend", "  s.split(/,\\\
    s?/)\nend\n</code>\n<code>", "  s.split(/,|\\s/)\nend", "    words = s.split(/,|\\\
    s/)\nend", "    words = s.split\n    words.map!\n    words\nend", "  s.split(',').map(&:strip)\n\
    end", "  # Split string into array of words using split\n  # Use split function\n\
    end", "  words = s.split(' ')\n  words.map! { |w| w.gsub(/\\s+/, '') }\n  words.compact!\n\
    \  words.uniq!\n  words.sort!\n  words\nend", "  s.split(/[\\s,]+/)\nend", " \
    \   words = s.split(\" \")\n    return words", "    # Split s into words\n   \
    \ s.split\n    # Return a new array containing only words\n    map(&:to_sym)\n\
    end\n</cell>\n<cell>\nwords_string('hello,world!')\n</cell>\n<cell>\nwords_string('hello,\
    \ world !')\n</cell>\n<text>\nWhen you've finished the above code cell, run the\
    \ cell below:", "  words = s.split(/,|\\s+/)\n  words.each do |word|\n    puts\
    \ word\n  end\nend\n</code>\nI hope this helps you. Feel free to ask me if you\
    \ have any further questions.\n<|/ a dscore=2 |>\n<| a |>\nJust use split function\
    \ of ruby. \n<code>\n\"Hello World\".split(\" \") # => [\"Hello\", \"World\"]\n\
    </code>\n<|/ a tags=ruby dscore=2 |>\n<| a tags=ruby |>\nThe split method would\
    \ work but if you have a file which contains spaces, then you would need to use\
    \ chomp to remove new line. \n<code>\nfile_name = \"file_name.txt\"\nFile.open(file_name,\
    \ \"r\").read\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby dscore=0 |>\nThis should\
    \ do it:\n<code>", "  s.split(', ')\nend", "  s.split(', ').map(&:to_i)\nend\n\
    puts words_string('a,b,c') # => [1,2,3]\nputs words_string('a b c') # => [1,2,3]\n\
    puts words_string(' a,b,c ') # => [1,2,3]\nputs words_string('a  b  c') # => [1,2,3]\n\
    puts words_string(' a  b  c ') # => [1,2,3]\nputs words_string('a , b , c ') #\
    \ => [1,2,3]\nputs words_string('a , b , c d') # => [1,2,3,4,5]\nputs words_string('a\
    \ , b , c d ') # => [1,2,3,4,5]\nputs words_string('a , b , c d e ') # => [1,2,3,4,5,6,7]\n\
    puts words_string('a , b , c d e f') # => [1,2,3,4,5,6,7,8]\nputs words_string('a\
    \ , b , c d e f g') # => [1,2,3,4,5,6,7,8,9]\nputs words_string('a , b , c d e\
    \ f g h') # => [1,2,3,4,5,6,7,8,9,10]\nputs words_string('a , b , c d e f g h\
    \ i j k l m n o p q r s t u v w x y z') # => [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]\n\
    puts words_string('a , b , c d e f g h i j k l m n o p q r s t u v w x y z . ,\
    \ * - + / ! \" ? / . ^ % & # \u22EE # \u2295 # \u2245 # \u22C4 # \u22C3 # \u22FD\
    \ # \u25CB # \u25EF # \u25EE # \u25C9 # \u25D2 # \u25D1 # \u25D0 # \u25D4 # \u25D1\
    \u25D1 # \u25D1\u25D1\u25D1 # \u25D1\u25D1\u25D1\u25D1 # \u25D1\u25D1\u25D1\u25D1\
    \u25D1 # \u25D1\u25D1\u25D1\u25D1\u25D1\u25D1 # \u25D1\u25D1\u25D1\u25D1\u25D1\
    \u25D1\u25D1 # \u25D1\u25D1\u25D1\u25D1\u25D1\u25D1\u25D1\u25D1 # \u25D1\u25D1\
    \u25D1\u25D1\u25D1", "    # Split words by whitespace\n    words = s.split()\n\
    \    # return array\n    return words\nend", "  # +++your code here+++\nend",
  "    # split s and store the words in an array\n    words = s.split(',')\n    #\
    \ return the array of words\n    return words", "  s = s.split(\" \")\n  s.map!{|w|\
    \ w.strip}\n  s\nend", "  words = []\n  s.split(/,/).each { |i| words << i.strip\
    \ }\n  words\nend\n</cell>\n<code language=ruby-1.9.3-p448>", "  s.scan(/\\w+/).map{|x|\
    \ x.downcase}\nend", "  s.split(' ')\nend", "  words = s.split(\" \")\n  words.each\
    \ {|w| puts w}\nend", "    return s.split(//)\nend", "  s.split(' ').map do |word|\n\
    \    word.capitalize\n  end\nend", "  s.split(',').map(&:split)\nend", "  s.split(',').map(&:strip)\n\
    end", "  #split and return the list\nend", "    # Split the string s into an array\
    \ of words\n    # where each word is a separate string\n    # and each word is\
    \ stripped of whitespace (\" \").\n    # Return a list of the words (no whitespace)\
    \ in the original string\n    return s.split(\" \").map(&:strip)\nend\n</cell>\n\
    <code language=julia-1.5>", "  splitted = s.split(',')\n  return splitted", " \
    \   words = s.split(',')\n    words_array = []\n    for word in words\n      \
    \  words_array << word\n    return words_array\nend\n</cell>\n<text>\nNow you\
    \ are ready to test your code:", "    # Split the string into words.\n    words\
    \ = []\n    str_array = s.split(', ')\n    str_array.each {|i| words.push(i)}\n\
    \    return words\nend", "    words = s.split(',')\n    return words", '# Returns:',
  "    words = s.split(\" \") \n    words.each { |word| print word }\nend", "    #\
    \ Split \"Hello, world.\" into [\"Hello\", \"world.\"]\n    words = s.split(',\
    \ ')\n    # Return [\"Hello\", \"world.\"]\n    return words\n    ", "  s = s.split\n\
    \  words.push s\n  words.sort \n  puts words.join(\", \")\n  words.shift if words.size\
    \ < 2\nend", "    # Return an array of words from s, by splitting s on spaces.\n\
    \    # e.g. split_words\n    # Given \"Hello World\", return [\"Hello\", \"World\"\
    ].\nend", '  # Write your solution below:', "\ts.split(',')\nend", "  words =\
    \ s.split(',')\n  words.map {|word| word.strip }\nend", "    words = s.split()\n\
    \    return words", "  words = s.split(' ')\n  return words", "  a = s.gsub(\"\
    \ \",\"\").split\n  a.count\nend", "  s.split(\",\").map(&:strip)\nend", "  #\
    \ +++your code here+++\nend", "  s.split(\",\")\nend", "    s = s.split(', ')\n\
    \    s = s.split(' -- ')\n    return s", "  s.split(/,|\\s/)\nend", "  puts split_string(s)\n\
    end", "  s.split.map { |e| e.strip }\nend\nwords_string('one, two, three, four,\
    \ five')\n  #=> ['one', 'two', 'three', 'four', 'five'] \nwords_string('')\n \
    \ #=> [] \n</code>\nNote that you could have written \n<code>\ns.split.map(&:strip)\n\
    </code>\n<|/ a |>\n<| c |>\n`map` is really just syntactic sugar for the `each`\
    \ method. It's not more readable or efficient to do it your way vs. `each`. It\
    \ may also look more familiar to people who are more familiar with Ruby than Rubyists.\n\
    <|/ c |>\n<| c |>\nIt also doesn't always return a `Hash`. It depends on what\
    \ you're trying to do in the function, and in many cases it will return an `Array`.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,split |>\n<code>", "  s = s.split(/,|\\\
    s/)\nend", "  words.split(s)\nend", "\ts.split(\" \") \nend", "  s.split(//)\n\
    end\n</pre>\n<p>\n  In case you did not understand any of the previous parts,\
    \ we suggest\n  that you go back and read each part carefully, paying careful\
    \ attention to\n  how it works.\n</p>\n</div>\n<div class=\"section\">\n<h2 id=\"\
    test-cases\">Test Cases</h2>\n<p>\n  Here are some test cases to give you a chance\
    \ to test your\n  understanding.\n</p>\n<ul>\n  <li>\n    <span>Empty String:</span>\n\
    \    <ul>\n      <li>\n        <span>Return an Array with an empty string:</span>\n\
    \        <span>[]</span>\n      </li>\n    </ul>\n  </li>\n  <li>\n    <span>Single\
    \ Word:</span>\n    <ul>\n      <li>\n        <span>Return an Array with a single\
    \ word:</span>\n        <span>[\"hi\"]</span>\n      </li>\n    </ul>\n  </li>\n\
    \  <li>\n    <span>Multiple Words:</span>\n    <ul>\n      <li>\n        <span>Return\
    \ an Array with two words:</span>\n        <span>[\"hi\", \"bye\"]</span>\n  \
    \    </li>\n    </ul>\n  </li>\n  <li>\n    <span>No Words:</span>\n    <ul>\n\
    \      <li>\n        <span>Return an Array with no word:</span>\n        <span>[]</span>\n\
    \      </li>\n    </ul>\n  </li>\n  <li>\n    <span>Invalid Words:</span>\n  \
    \  <ul>\n      <li>\n        <span>Return an Array with invalid words:</span>\n\
    \        <span>[\"hi\", \"bye\", \"lol\"]</span>\n      </li>\n    </ul>\n  </li>\n\
    </ul>\n</div>\n<div class=\"section\">\n<h2 id=\"implementation\">Implementation</h2>\n\
    <p>\n  You will need to use an Array#split method to divide the input string\n\
    \  into words. To get the words out of the string, you will need to use\n  the\
    \ split(//) method. Remember that the split() method will split the\n  string\
    \ into words based on the provided regular expression\n  <span class=\"quote\"\
    >\"space\"</span>.\n</p>\n<p>\n  A regular expression can be constructed by appending\
    \ more characters\n  to the one provided in the first argument.\n</p>\n<p>\n \
    \ The regular expression can be constructed in different ways. One way\n  would\
    \ be to use the #scan() method of the String class, which will return\n  the matches\
    \ in the order they appear in the string.\n</p>\n<p>\n  Another way would be to\
    \ pass a block to #match(). The block will be called\n  with the current character\
    \ being iterated over and the return value will\n  be used as argument for calling\
    \ #scan().\n</p>\n<p>\n  You can learn more about regular expressions [<a href=\"\
    http://ruby-doc.org/core-1.9.3/Regexp.html\">", "  words = s.split(/,|\\s|\\.|-/)\n\
    end", "  words = s.downcase.split.map(&:capitalize).join(\" \")\n  words.split.map(&:strip).map(&:capitalize).join(\"\
    \ \")\nend", "  s.split(//).to_a\nend\n</pre>\n</div>\n<div class=\"section\"\
    \ id=\"string-methods-including-case-variations-and-splitting\">\n<h3>String Methods\
    \ (Including Case Variations and Splitting)<a class=\"headerlink\" href=\"#string-methods-including-case-variations-and-splitting\"\
    \ title=\"Permalink to this headline\">\xB6</a></h3>\n<p>As mentioned above, there\
    \ are several ways to split a string. Which one to choose depends on your use\
    \ case. A very common one is the <strong>split</strong> method, which takes a\
    \ regular expression as input and splits the string into substrings (where a substring\
    \ is a sequence of characters).</p>\n<p>You can learn more about string regular\
    \ expressions in Ruby by visiting the <a class=\"reference external\" href=\"\
    http://www.tutorialspoint.com/ruby/ruby_regexp.htm\">Ruby Regex Tutorial</a>.</p>\n\
    <p>The <strong>split</strong> method has several variations. The most basic variation\
    \ splits on the occurrence of any character that does not occur in a <strong>split</strong>.\
    \ For example:</p>\n<div class=\"code ruby\"><span class=\"nb\">split</span> <span\
    \ class=\"s1\">','</span> <span class=\"p\">[</span><span class=\"s1\">'a,b,c'</span><span\
    \ class=\"p\">,</span><span class=\"s1\">'d,e,f'</span><span class=\"p\">,</span><span\
    \ class=\"s1\">'g,h'</span><span class=\"p\">]</span> <span class=\"c1\"># Split\
    \ on any character except comma</span>\n<span class=\"o\">[</span><span class=\"\
    s1\">&#39;a&#39;</span><span class=\"p\">,</span><span class=\"s1\">&#39;b&#39;</span><span\
    \ class=\"p\">,</span><span class=\"s1\">&#39;c&#39;</span><span class=\"p\">]</span>\n\
    <span class=\"o\">[</span><span class=\"s1\">&#39;d&#39;</span><span class=\"\
    p\">,</span><span class=\"s1\">&#39;e&#39;</span><span class=\"p\">,</span><span\
    \ class=\"s1\">&#39;f&#39;</span><span class=\"p\">]</span>\n<span class=\"o\"\
    >[</span><span class=\"s1\">&#39;g&#39;</span><span class=\"p\">,</span><span\
    \ class=\"s1\">&#39;h&#39;</span><span class=\"p\">]</span>\n<span class=\"o\"\
    >[]</span>\n<span class=\"o\">[]</span>\n<span class=\"o\">[]</span>\n<span class=\"\
    o\">[]</span>\n<span class=\"o\">[]</span>\n<span class=\"o\">[]</span>\n</pre></div>\n\
    <p>The other variations take an additional argument, specifying the character\
    \ that separates the different parts of the original string:</p>\n<div class=\"\
    code ruby\"><span class=\"nb\">split</span><span class=\"p\">(</span><span class=\"\
    s1\">','</span><span class=\"p\">,</span><span class=\"s1\">'abc,def,gh'</span><span\
    \ class=\"p\">)</span> <span class=\"c1\"># Split on comma between each characters</span>\n\
    <span class=\"o\">[</span><span class=\"s1\">&#39;abc&#39;</span><span class=\"\
    p\">,</span><span class=\"s1\">&#39;def&#39;</span><span class=\"p\">,</span><span\
    \ class=\"s1\">&#39;gh&#39;</span><span class=\"p\">]</span>\n<span class=\"o\"\
    >[</span><span class=\"s1\">&#39;abc&#39;</span><span class=\"p\">,</span><span\
    \ class=\"s1\">&#39;def&#39;</span><span class=\"p\">]</span>\n<span class=\"\
    o\">[</span><span class=\"s1\">&#39;abc&#39;</span><span class=\"p\">,</span><span\
    \ class=\"s1\">&#39;def&#39;</span><span class=\"p\">]</span>\n<span class=\"\
    o\">[]</span>\n<span class=\"o\">[]</span>\n<span class=\"o\">[]</span>\n<span\
    \ class=\"o\">[]</span>\n<span class=\"o\">[]</span>\n<span class=\"o\">[]</span>\n\
    <span class=\"o\">[]</span>\n</pre></div>\n<p>In most situations, you can use\
    \ the <strong>split</strong> method in the same way you would use the <strong>split</strong>\
    \ method for the other language that you are using. In Ruby, you can also omit\
    \ the optional argument, which is then split on any character:</p>\n<div class=\"\
    code ruby\"><span class=\"nb\">split</span><span class=\"p\">(</span><span class=\"\
    s1\">','</span><span class=\"p\">)</span> <span class=\"c1\"># Split on any ",
  " s.split(', ')\nend\n</pre>", "  words = s.split(',')\n  return words\nend\nprint\
    \ words_string(\"dog, cat, bird\")", "  s.split(//).collect!{|i| i.downcase}\n\
    end\n</cell>\n<cell>\nputs words_string(\"apple, pear pear, cherry banana, apple,\
    \ grapes\")\n</cell>\n<cell>", "  return s.split(',').map(&:strip)\nend", "  s.split(',').map(&:strip)\n\
    end", "  s.split\nend\n</pre>", "  # Use split() to split your string into a list\
    \ of words. If you want to\n  # ignore capitals, you can use a regular expression.\
    \ Remember that split is\n  # a regular expression. \n  s.split(/[\\s,]+/)\nend",
  "  result = s.split\n  result\nend", "  words = s.split(/,|\\s/)\n  return words\n\
    end", "  s.split\nend", "  s = s.chomp\n  words = s.split\n  words.each do |word|\n\
    \    p word\n  end\nend", "  words = s.split(',').map(&:strip)\n  words.empty?\
    \ ? [] : words\nend", "  #<-- Your code here -->\nend\n</cell>\n<code language=julia-1.5>\n\
    words_string(s)\n</cell>\n<text>\nReturning a dictionary\nIn this exercise, we'll\
    \ return a dictionary containing the number of times each of the keys \"a\", \"\
    b\" and \"c\" appeared in the given string.", "  # Use Ruby's String#split to\
    \ split s on commas, return an array containing the words.\n  # If there are any\
    \ commas in s, return a copy of s with commas removed.\n  # If there are any spaces\
    \ in s, return a copy of s with spaces removed.\nend", "  s.split(\" \")\nend",
  "  return s.split(', ')", "    # Write your code here\nend\n</cell>\n<code language=julia-0.5>",
  "  s.split(/,| /)\nend", "    s = s.split\n    words.each do |word|\n        puts\
    \ word\n    end\nend\n</cell>\n<cell>\nputs \"The list of words are \" + words_string(\"\
    The list of words are the, list, of, words, \")\n</cell>\n<cell>", "  s.split(/,|\\\
    s+/)\nend", "  # +++your code here+++\nend", "    words = s.split(/,|\\s/)\n \
    \   words.each do |word|\n        puts word\n    end\nend", "  return s.split(',').map\
    \ {|w| w.strip.downcase}\nend", "    str_array = s.split\n    words.push str_array\n\
    end", "    words = s.split(', ') # split s into words using space\n    words.each\
    \ {|word| puts word } # print each word on a new line\nend", "    words = s.split(/,|\\\
    s+/)\n    words.sort()\n    return words\n    # If you cannot modify the array\
    \ in place, but can return the sorted array, then use this instead:\n    # words\
    \ = s.split(/,|\\s+/).sort\n    # return words\nend", "    words = s.split(/\\\
    W+/)\n    return words\nend", "  s.split.map(&:capitalize)\nend\n</pre>", "  \
    \  words = s.scan(/\\w+/)\n    words.to_a\nend\n</cell>\n<text>\nGreat! Now you\
    \ can call words_string with an argument of \"hi there, and I am good\":", " \
    \ words = s.split\n  words.collect!\n  words.count\nend", "  s.split(', ')\nend",
  "  #Split the string into words and return an array of\n  # the words.\n  #The words\
    \ are separated by spaces.\n  strs = s.split(\",\")\n  strs.map!(&:strip)\n  return\
    \ strs\nend\n</code>\nIf you call the function with an input of \"apple, orange,\
    \ mango, peach\" the output would be [\"apple\", \"orange\", \"mango\", \"peach\"\
    ]\n<|/ a tags=ruby,arrays,string |>\n<| a dscore=0 |>\n<code>", "    return s.split(/,|\\\
    s/)\nend", "    s = s.split(\",\")\n    words = s.collect!{|w| w.split}\n    words.join(\"\
    ,\")\nend", "    \n    # Split s into tokens\n    tokens = s.split(',')", '    return
    s.split', "  words = s.split # Split string s into array of words\n  words.select\
    \ { |w| w.length >= 2 } # Remove words that are too short\nend", '    return s.split("
    ")', "\tword_list = s.split(',')\n\tword_list.reject do |word|\n\t\tword.strip\n\
    \tend\nend\nprint(words_string('one, two, three, four'))", '    return s.split(",")',
  "  s.scan(/\\w+/).map(&:downcase)\nend", "  return s.split(/[\\s,]+/)\nend", " \
    \ s.split(//)\n  \n  ", "  return s.scan(/\\w+/).map(&:downcase)\nend", "  s.split(/,/).map\
    \ { |w| w.strip }\nend", "  words = s.split(//)\n  return words\nend", "  words\
    \ = s.split\n  return words\nend #=> nil\nputs words_string('a,bcd,efg') #=> ['a,bcd,efg']\n\
    puts words_string('abcd,efg') #=> ['a', 'abcd', 'efg']\nputs words_string('a b\
    \ c') #=> ['a b c']\nputs words_string('a bcd,efg') #=> ['a', 'bcd,efg']\nputs\
    \ words_string('a bc,d') #=> ['a', 'bc,d']\nputs words_string('a b c d') #=> ['a',\
    \ 'b c d']\nputs words_string(' a,bc,d ') #=> [' a,bc,d ']\nputs words_string('\
    \ a,b c d ') #=> [' a,b c d ']\nputs words_string(' ,a,bc,d ') #=> [' ,a,bc,d\
    \ ']\nputs words_string(' ,a,b c d ') #=> [' ,a,b c d ']\nputs words_string('\
    \ a,bc,d e f g ') #=> [' a,bc,d e f g ']\nputs words_string(' a,b c d e f g ')\
    \ #=> [' a,b c d e f g ']\nputs words_string(' ,a,bc,d e f g ') #=> [' ,a,bc,d\
    \ e f g ']\nputs words_string(' ,a,b c d e f g ') #=> [' ,a,b c d e f g ']\nputs\
    \ words_string(' a,bc,d,efg ') #=> [' a,bc,d,efg ']\nputs words_string(' a,b c\
    \ d,efg ') #=> [' a,b c d,efg ']\nputs words_string(' ,a,bc,d,efg ') #=> [' ,a,bc,d,efg\
    \ ']\nputs words_string(' ,a,b c d,efg ') #=> [' ,a,b c d,efg ']\nputs words_string('\
    \ a,bc,d,efg h ') #=> [' a,bc,d,efg h']\nputs words_string(' a,b c d,efg h ')\
    \ #=> [' a,b c d,efg h']\nputs words_string(' ,a,bc,d,efg h ') #=> [' ,a,bc,d,efg\
    \ h']\nputs words_string(' ,a,b c d,efg h ') #=> [' ", "    words =s.split(\"\
    \ \")\nend", "  s.split # split is also an array\nend", '    # Write your code
    below this line', "  words = s.split(',')\n  words.map {|x| x.strip}\nend", " \
    \ words = s.split(/[\\s,]+/)\nend", "    words = s.split(/,| /)\n    return words\n\
    end", "  splits = s.split # Split the given string using spaces\n  words.map!\
    \ do |word|\n    # If the word does not contain letters (case insensitive), replace\
    \ it with the\n    # word 'word'. For example, 'string' should become 'sword'.\n\
    \    word.gsub! /[^a-z]/, 'word'\n    # If the word contains letters, lowercase\
    \ it and capitalize it.\n    word.gsub! /[a-z]/i, '#{ word.downcase }#'\n    word.gsub!\
    \ /[A-Z]/i, '#{ word.capitalize }#'\n    # Return word\n    return word\n  end\n\
    \  words\nend\n</code>\n<|/ a tags=ruby,functional-programming |>\n<| a |>\nIf\
    \ you want a functional approach, just use Enumerable#collect instead of Array#map.\n\
    <code>\n[\"string\", \"string2\", \"string3\"].collect { |s| s.gsub(/[^a-z]/,\
    \ 'word').gsub(/[a-z]/i, '#{ word.downcase }#').gsub(/[A-Z]/i, '#{ word.capitalize\
    \ }#') }\n</code>\n<|/ a tags=ruby,functional-programming dscore=0 |>\n<| a dscore=0\
    \ |>\nI used two global variables to store the processed words, and then returned\
    \ them from the function. I used a global variable because I don't want to mutate\
    \ the original array in the function, and a local variable is slightly easier\
    \ to read (I think). \n<code>", "    s = s.split(',')\n    words = s.map { |word|\
    \ word.strip }\n    words.compact\nend\nprint words_string('this, is, a, test,\
    \ of, splitting, the, string')", "  words = s.split(',')\n  words[0,2]\nend",
  "    words = s.split(\" \")\n    return words\n    \nprint words_string('one,two,three')\n\
    \    ", "  # Write your code here\n  return s.split(\" \").map {|w| w.split(',').map(&:strip)}\n\
    end\nwords_string(\"cat, dog, fish, fox, fence, box\")", "  # Split the string\
    \ into words.\n  s = s.chomp.split(',')\n  # Put each word in the new array.\n\
    \  s.map! {|x| x.chomp}\n  return s\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n\
    <| a tags=ruby |>\n<code>", "    # your code goes here\nend", "    words = s.split(\"\
    ,\")\n    return words", "    # Split words by space\n    words = s.split(\" \"\
    )\n    # Return words as an array\n    return words\nend\n</cell>\n<code language=julia-0.5>",
  "    s = s.chomp.split(',')\n    array = []\n    word = ''\n    s.each do |s|\n\
    \        if (s.length > 0)\n            word = (word + s).split\n            array\
    \ << word\n        end\n    end\n    array\nend", "    return s.split\n    # return\
    \ s.split(' ')\nend", "  s.split(/,/)\nend", "\twords = s.split(',')\n\twords.map!\
    \ { |w| w.strip }\n\treturn words\nend", "  words = s.split(',')\n  words = words.flatten\n\
    \  words.join(\" \")\nend", "  s.split\nend", "    words = s.split(',')\n    words\
    \ = s.split(' ')\n    return words", "  s = s.to_s.split(', ')\nend", "  s.split(/,|\\\
    s+/)\nend", "  s.split(//) #split s into words\nend", "    str.split(/,/, s)\n\
    end", "  s = s.downcase\n  s.scan(/\\w+/).flatten\nend", "  words = s.split(/,|\\\
    s+/)\n  words.each{|word| p word}\nend", "  words = s.split(/,/).map(&:split)\
    \ # Split string on comma delimiter\n  words.map(&:downcase) # downcase all words\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nYou might want to give an example\
    \ of the correct output\n<|/ c |>\n<| c |>\nI added an example. Thanks!\n<|/ c\
    \ |>\n<| c |>\nWhat about `\"a,b\".split(\",\")`? I thought that would be `\"\
    a\",\"b\".split(\",\")`, but clearly it isn't.\n<|/ c |>\n<| c |>\nYou're correct,\
    \ thanks for pointing that out. I've updated the answer.\n<|/ c |>\n<| a dscore=3\
    \ tags=ruby,arrays |>\nIf you have something like:\n<code>\n[[\"a\", \"b\", \"\
    c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"]]\n</code>\nAnd you want to\
    \ extract all the \"words\" (split on comma, no matter how many of them), this\
    \ should work:\n<code>\narray.map {|word| word.split(\", \") }\n</code>\nIn a\
    \ more general case where you have an array of arrays, like in:\n<code>\n[[\"\
    a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"]]\n</code>\nthen\
    \ you would have to go through each inner array:\n<code>\narray.map {|inner_array|\
    \ inner_array.join(\", \") }\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\nI suppose\
    \ you are splitting one string into an array of string based on another string\
    \ as delimiter:\n<code>\n'foo, bar, baz'.split(/, */)\n</code>\n<|/ a dscore=3\
    \ |>\n<| a tags=ruby,arrays dscore=2 |>\nIf you want to split a string based on\
    \ a delimiter, then you can just use the split method.\n<code>\n\"a, b, c, d\"\
    .split(/, */)\n</code>\nThis will return the following array:\n<code>\n[\"a\"\
    , \"b\", \"c\", \"d\"]\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  return\
    \ s.split(', ')\nend", "    words = s.split(/,|\\s/)\n    words.to_a\nend\n</cell>\n\
    <code language=julia-1.5>\nwords_string(s)\n</cell>\n<text>\nGreat! Hopefully\
    \ your words are now stored in an array, words. If you print out the length of\
    \ words, you'll find that it's giving you the array length you expect. Okay, first\
    \ let's take a peek at what a couple of random words are:", "  # Split s into\
    \ words using split\n  words = s.split.map do |word|\n    # Convert each word\
    \ into a lower case word\n    word.downcase\n  end", "  words = s.split(' ')\n\
    \  words.map(&:downcase)\nend\nwords_string(\",This is a string, with, commas,\
    \ separating words.\")", "  s.split\nend", "    # split given string into words\n\
    \    \n    # your code here\n    return s.split(\" \")\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
