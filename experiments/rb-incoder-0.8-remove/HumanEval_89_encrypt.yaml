name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\ndef encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["   alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n\
    \   for i in range(len(s))\n       alphabet[i] = alphabet[i] + 'A'\n   return\
    \ alphabet[alphabet.index(s)+1]", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    s = s.downcase\n    s = s.gsub(/([a-z])/i) {alphabet[$1].capitalize}\n \
    \   s = s.gsub(/([A-Z])/i) {alphabet[$1].capitalize}\n    return s\nend", '    return
    s.rotate(2).upper()', "    cipher = \"\"\n    i = 0\n    while i < len(s)\n  \
    \      letter = s[i]\n        next_letter = s[i + 1]\n        \n        if letter.isalpha()\
    \ and not letter.islower()\n            cipher_letter = letter + \"A\"\n     \
    \       i = i + 1\n        \n        elif letter.islower() and not letter.isalpha()\n\
    \            cipher_letter = letter + \"a\"\n            i = i + 1\n        \n\
    \        cipher_letter = cipher_letter + next_letter\n        cipher = cipher_letter\n\
    \    return cipher\nprint encrypt(plaintext)", "  result = \"\"\n  s.chars.each\
    \ do |c|\n    result << alphabet[((alphabet.index(c)+2) %26)]\n  end\n  result\n\
    end", "   return (s.tr!('abcdefghijklmnopqrstuvwxyz', 'klmnopqrstuvwxya')*\n \
    \          s.tr!('nopqrstuvwxyzabcdefghijklm', 'pqrstuvwxyzabcdefghijkl'))\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis is *not* a good solution. `tr!` uses\
    \ regexes (`.tr!` uses `tr`).\n<|/ c |>\n<| c |>\nAren't regular expressions really\
    \ a regex implementation? What exactly is wrong with it?\n<|/ c |>\n<| c |>\n\"\
    What exactly is wrong with it?\". I assume you mean that it's slow. In my experience\
    \ it's usually slower than a good solution. The regex-implementation is usually\
    \ optimized for this task, so it's usually faster than a good solution.\n<|/ c\
    \ |>\n<| c |>\n: Not just slow, it's also very inefficient, since it uses a lot\
    \ of memory and can take a long time to build the result string.\n<|/ c |>\n<|\
    \ a dscore=0 |>\nHow about something like this?\n<code>", "    # Write your code\
    \ here\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  encrypted_string\
    \ = \"\"", "  # Initialize the alphabet to an empty string\n  a = \"\"", "   \
    \ alphabet = [ 'e', 'g', 'i', 'o', 'u' ]\n    shifts = 2", "    letters = ['a','b','c','d','e','f','g','h','i','j','k','l','m',\n\
    \               'n','o','p','q','r','s','t','u','v','w','x','y','z']\n    return\
    \ \"\".join( letters[i+2] if letters[i] == letters[i+2] else letters[i] for i\
    \ in range(len(s)-2) )\nprint(encrypt('abcdef'))", "  cipher = \"\"\n  for i in\
    \ s \n    cipher = cipher + alphabet[alphabet.rindex(i)+2]\n  end\n  return cipher\n\
    end", "  alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n  encrypted_string\
    \ = ''\n  s.chars.each_with_index do |character, index|\n    character = alphabet[(alphabet.index(character)\
    \ + alphabet.length - 2) % alphabet.length]\n    encrypted_string << character\
    \ \n  end\n  return encrypted_string\nend\n</code>\nTo get the first 10 characters\
    \ in your encrypted string, all you need to do is this:\n<code>\nencrypted_string[9..-1]\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThank you! I really appreciate it!\n<|/ c\
    \ |>\n<| c |>\nYou're welcome. Glad I could help. I hope you don't mind, but I\
    \ changed the answer to reflect what I think your question really was. It might\
    \ be a better fit for that rather than the one you asked and I think it might\
    \ help future visitors to this question.\n<|/ c |>\n<| c |>\nno problem, I appreciate\
    \ the help!\n<|/ c |>\n<| a |>\nI did this in Ruby using two hashes:\n<code>\n\
    alphabet = {\n  \"a\" => 0,\n  \"b\" => 1,\n  \"c\" => 2,\n  \"d\" => 3,\n  \"\
    e\" => 4,\n  \"f\" => 5,\n  \"g\" => 6,\n  \"h\" => 7,\n  \"i\" => 8,\n  \"j\"\
    \ => 9,\n  \"k\" => 10,\n  \"l\" => 11,\n  \"m\" => 12,\n  \"n\" => 13,\n  \"\
    o\" => 14,\n  \"p\" => 15,\n  \"q\" => 16,\n  \"r\" => 17,\n  \"s\" => 18,\n \
    \ \"t\" => 19,\n  \"u\" => 20,\n  \"v\" => 21,\n  \"w\" => 22,\n  \"x\" => 23,\n\
    \  \"y\" => 24,\n  \"z\" => 25\n}", "  encrypted_string = s.chars.map do |letter|\n\
    \    shifted = alphabet.index(letter)\n    shifted * 2\n  end.join\nend\n</code>\n\
    Note that this assumes that the alphabet is sorted in ascending alphabetical order;\
    \ that is, the first character is always in the same place.\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nThanks, but the challenge is to do it without using \"index\".\
    \ Is that possible?\n<|/ c |>\n<| c |>\nSure, I've edited my answer to show you\
    \ how to do that without any `index` calls.\n<|/ c |>\n<| c |>\nThanks. Just to\
    \ make sure I'm understanding this correctly, each letter is being added to an\
    \ array with the letter shifted by 2 places, correct? So in this example, each\
    \ letter is being multiplied by 2 to move down to the next letter, and each letter\
    \ being added to an array, correct?\n<|/ c |>\n<| c |>\nThat's right. Although\
    \ this solution is O(n), as each character is visited only once.\n<|/ c |>\n<|\
    \ c |>\nO(n) is the best you can do in Ruby, since it is interpreted at the runtime\
    \ of the program. If you were to use an interpreted language like JavaScript,\
    \ Ruby, or Perl, then a lookup would be used on the string each time you access\
    \ a character, and the lookup would be linear time.\n<|/ c |>\n<| a tags=string,ruby\
    \ |>\nIf you're allowed to use each_char and each_cons:\n<code>", "  return s.chars.map{|c|\
    \ c.to_i+2}.map(&:chr).join\nend", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    return alphabet[alphabet.index(s)+2] + alphabet[alphabet.index(s)+1] + alphabet[alphabet.index(s)+0]\n\
    \    ", "  alphabet.each do |e|\n    puts s.gsub(/[^#{e}]/, '').rotate((alphabet.index(e)\
    \ + 1).to_i).scan(/./).join\n  end\nend", "  s.gsub(/.{2}/) { |m| m.to_i.to_s(2).rjust(2,\
    \ '0') }\nend", "    alphabet_rotations = {\n        \"a\"     : \"b\",\n    \
    \    \"b\"     : \"c\",\n        \"c\"     : \"d\",\n        \"d\"     : \"a\"\
    ,\n        \"e\"     : \"f\",\n        \"f\"     : \"e\",\n        \"g\"     :\
    \ \"h\",\n        \"h\"     : \"g\",\n        \"i\"     : \"j\",\n        \"j\"\
    \     : \"i\",\n        \"k\"     : \"l\",\n        \"l\"     : \"k\",\n     \
    \   \"m\"     : \"n\",\n        \"n\"     : \"m\",\n        \"o\"     : \"p\"\
    ,\n        \"p\"     : \"o\",\n        \"q\"     : \"r\",\n        \"r\"     :\
    \ \"q\",\n        \"s\"     : \"t\",\n        \"t\"     : \"s\",\n        \"u\"\
    \     : \"v\",\n        \"v\"     : \"u\",\n        \"w\"     : \"x\",\n     \
    \   \"x\"     : \"w\",\n        \"y\"     : \"z\",\n        \"z\"     : \"y\"\
    ,\n        \"A\"     : \"B\",\n        \"B\"     : \"A\",\n        \"C\"     :\
    \ \"D\",\n        \"D\"     : \"C\",\n        \"E\"     : \"F\",\n        \"F\"\
    \     : \"E\",\n        \"G\"     : \"H\",\n        \"H\"     : \"G\",\n     \
    \   \"I\"     : \"J\",\n        \"J\"     : \"I\",\n        \"K\"     : \"L\"\
    ,\n        \"L\"     : \"K\",\n        \"M\"     : \"N\",\n        \"N\"     :\
    \ \"M\",\n        \"O\"     : \"P\",\n        \"P\"     : \"O\",\n        \"Q\"\
    \     : \"R\",\n        \"R\"     : \"Q\",\n        \"S\"     : \"T\",\n     \
    \   \"T\"     : \"S\",\n        \"U\"     : \"V\",\n        \"V\"     : \"U\"\
    ,\n        \"W\"     : \"X\",\n        \"X\"     : \"W\",\n        \"Y\"     :\
    \ \"Z\",\n        \"Z\"     : \"Y\"\n    }\n    \n    # Create a dictionary to\
    \ hold the resulting string.\n    result = \"\"", "  alphabet = s.downcase + \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  encrypted_string = \"\"\n  i = 0\n  while i <\
    \ s.length\n    ch = alphabet.index(s[i])\n    encrypted_string << alphabet[ch]\n\
    \    i += 1\n  end\n  return encrypted_string\nend", "    cipher = \"\"\n    for\
    \ letter in s\n        cipher += alphabet[alphabet.index(letter) + alphabet2.index(letter)]\n\
    \    return cipher", "  return s.gsub(/./) do |char|\n    char = char.chr % 26\
    \ + 65\n    char > 26 ? (char - 26).chr + 65 : char\n  end\nend", "  # Encrypt\
    \ a lowercase string by performing the following transform:\n  # a -> z\n  # b\
    \ -> y\n  # ...\n  # z -> a\n  # y -> b\n  # ...\n  # a -> z\n  # b -> y\n  #\
    \ ...\n  # z -> a\n  # y -> b\n  # ...\n  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n  s = s + s\n\
    \  s = s + s\n  s = s + s\n", "    cipher = \"\"\n    for letter in s\n      \
    \  cipher += alphabet[alphabet.index(letter) + 2]\n    return cipher", "   alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n   s = s.tr(\"abcdefghijklmnopqrstuvwxyz\"\
    , \"zyxwvutsrqponmlkjihgfedcba\")\n   return(alphabet+s)\nend", "    cipher =\
    \ \"\"\n    i = 0\n    while i < len(s)\n       c =  s[i]\n       if i > 0 and\
    \ (i - 1) % 2 == 0 #i-1 will always be odd\n           c += c\n       cipher +=\
    \ alphabet[c]\n       i += 2\n    return cipher", "  alphabet = %w[a b c d e f\
    \ g h i j k l m n o p q r s t u v w x y z]\n  new_alphabet = alphabet.dup\n  new_alphabet.reverse!\n\
    \  new_alphabet.shift 2\n  new_alphabet.map! { |i| i.ord } # convert to ASCII\n\
    \  new_alphabet.join.tr(alphabet, new_alphabet) # convert to string\nend", " \
    \ alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  s.chars.map { |c| alphabet[(alphabet.index(c)\
    \ + 2) % 26] }.join\nend\n</code>\n<|/ a dscore=0 tags=encryption,ruby,python\
    \ |>\n<| c |>\nWhat is the complexity of this method?\n<|/ c |>\n<| c |>\nSince\
    \ `#chars` is an O(1) operation, this would be O(N). Since `#index` is an O(N)\
    \ operation, this would be O(N^2). I don't believe you can get better than O(N^2)\
    \ in complexity\n<|/ c |>\n<| c |>\nI added some explanation to the question to\
    \ explain the complexity.\n<|/ c |>\n<| c |>\nO(N^2) is not an interesting time\
    \ complexity. It implies a quadratic algorithm but in reality the algorithm is\
    \ linear and could be even faster than O(N^2).\n<|/ c |>\n<| a tags=encryption,ruby,python\
    \ dscore=0 |>\nI wrote a Ruby program that does what you need (I think), but it\
    \ takes about 6 seconds to encrypt a 3 character string containing only letters\
    \ \"a\", \"b\", \"c\" (and I presume \"d\"). Here it is:\n<code>\nputs \"Enter\
    \ a string with only letters a, b, and c\"\nstr = gets.chomp\nputs \"The length\
    \ of the string is: \" + str.size\nputs \"The encrypted string is below:\"", " \
    \   return s.gsub(/./) do |c| \n        alphabet = %w{ a b c d e f g h i j k l\
    \ m n o p q r s t u v w x y z }\n        alphabet.length.times { |n| c << alphabet[n\
    \ * 2] + alphabet[n * 2 + 1] }\n    end\nend", "    alphabet = :ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\
    \    new_string = \"\"\n    s.split(\"\").each do |char|\n        new_string <<\
    \ alphabet[alphabet.index(char).rotate(2)]\n    end\n    return new_string\nend",
  "  cipher = \"\"\n  for i in s\n    cipher << alphabet[alphabet.index(i)+2]\n  \
    \  cipher << alphabet[alphabet.index(i)+1]\n  end\n  cipher\nend", "  return \"\
    abc\" # Replace this with the code to rotate the alphabet\nend", "    alphabet_count\
    \ = 26\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    return \"\".join([alphabet[alphabet_count-alphabet.index(i)%alphabet_count]\
    \ for i in s])\n    ", "    return s.chars.map { |c| c.upcase + c.downcase }.join\n\
    end\n</code>\nThe above method will rotate 'abc' into 'cba'.\n<|/ a tags=ruby,encryption,string\
    \ dscore=2 |>\n<| c |>\nThe question is asking for \"Ruby code\", not \"pseudo\
    \ code\".\n<|/ c |>\n<| c |>\nThe question asks for rotating in the way the question\
    \ is written, i.e., \"abc\" becomes \"cba\". The code in the answer does just\
    \ that: rotates \"abc\" into \"cba\".\n<|/ c |>\n<| c |>\nThis answer is completely\
    \ wrong. First, it rotates the letters by 2 places, not 1. Second, it gives you\
    \ the wrong result. `encrypt(\"aBcd\") #=> \"bCda\"`\n<|/ c |>\n<| c |>\nWhat\
    \ is the issue with rotating by 2 places rather than 1? Do you mean you think\
    \ it is rotating by 2 places but it isn't, or do you think it is rotating by 1\
    \ place but it is not?\n<|/ c |>\n<| c |>\nOh wait, you are right. I'm being really\
    \ stupid right now. You're rotating by one place.\n<|/ c |>\n<| a |>\n<code>\n\
    string.scan(/./).map{|e|\n  (e.upcase+e.downcase).chars.rotate(1).join\n}.join\n\
    </code>\nThis should do it\n<|/ a dscore=2 tags=ruby,encryption,string |>\n<|\
    \ c |>\nThis answer rotates the letters by 1 place, whereas the OP asked for 2.\n\
    <|/ c |>\n<| c |>\nThis answer is correct and also the most Rubyist answer. No\
    \ need to overcomplicate it, but this solution works only for `English` alphabet.\
    \ Be careful when dealing with non-English alphabet\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "    en = \"\"\n    s.each_char do |letter|\n        en.concat(rotate_letter(letter,\
    \ 2))\n    end\n    return en\nend", "  \nend", "    cipher = []\n    i = s.index(\"\
    \ \")\n    j = s.index(\"\\n\")\n    if i == j:\n        return s + \" \"\n  \
    \  else:\n        length = len(s)\n        alphabet = alphabet_rotator()\n   \
    \     alpha = len(alphabet)\n        l = list(s)\n        for i in range(length):\n\
    \            cipher.append(alphabet[(alpha-1-i) % alpha])\n        ciph = \"\"\
    .join(cipher)\n        return ciph", end, " cipher = []\n \n # Use for loop to\
    \ iterate through each character\n for character in s\n    character.downcase!\n\
    \    # If the character is NOT an uppercase letter\n    # then add it to the end\
    \ of a variable called cipher\n    if character.upcase != character\n     cipher\
    \ << character.upcase\n    end\n    # If the character is an uppercase letter\n\
    \    # add it to the beginning of a variable called cipher\n    if character.upcase\
    \ == character\n     cipher << character.downcase\n    end\n end\n cipher.join\n\
    end", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    rotatedAlphabet = rotate(alphabet)\n\
    \    rotatedAlphabet.to_s.chars\nend", "  result = \"\"\n  s.each_byte do |i|\n\
    \    result << alphabet[((i.ord + shift) % alphabet.size)]\n  end\n  result\n\
    end", "    enc = \"\"\n    s.split(\"\").each do |char|\n        enc << (char.ord\
    \ + 2) % 26 \n    end\n    enc\nend", "  result = ''\n  s.each_char { |c|\n  \
    \  result << alphabet.shift(c)\n  }\n  result\nend\nputs encrypt('Hello') # =>\
    \ YKJZCUFXQWIYBZY\nputs encrypt('Cafe') # => VJTAKXQWYSZVZ\n</code>\n<|/ a |>\n\
    <| c |>\nSorry for the late response.  Had to go home to work this morning.  This\
    \ is fantastic information and has helped me immensely.  It is a little outside\
    \ of what I've been taught but this has cleared my perspective on how a shift\
    \ cipher works.  Thanks so much for taking the time to write this out.  I really\
    \ appreciate it.\n<|/ c |>\n<| a |>\nThe best approach will be to use an algorithm\
    \ called 'Caesar Cipher' or 'Vigen\xE8re Cipher'. The concept behind this algorithm\
    \ is very simple, it'll require a key and a string. The key can be in any language\
    \ or length. For instance, if you have a key of \"ABCDE\", and you have a string\
    \ \"ABCDE\", you can just use string.substring to move the \"ABCDE\" to the left\
    \ one character, and add the new character to that substring. \nThen the string\
    \ is padded with spaces to match the length of the string. \nThe reason I suggest\
    \ you use Caesar Cipher is because this cipher requires you to input the key every\
    \ time you encrypt or decrypt a string. This can be annoying, especially if your\
    \ teacher will force you to use the same key.\nI strongly recommend that you use\
    \ a key length of 6 or 7, or 8 or 9, or 10, or 11, or 12. Because if your teacher\
    \ forces you to use the same key, it means that you haven't learned the correct\
    \ way of encryption yet. \nHere's a ruby code sample:\n<code>", "    # ... code\
    \ here\nend\n</cell>\n<cell>", "  new_alphabet = alphabet.rotate(2) # Rotate the\
    \ alphabet by two\n  new_alphabet.rotate(1) # Rotate the alphabet by one\n  new_alphabet.reverse\
    \    # Reverse the alphabet\n  new_alphabet           # Return the encrypted string\n\
    end", "    return s\nend", "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z']\n    s = s.split('') \n    # To shift the letters down by 2\n\
    \    s = [x + alphabet[((alphabet.index(x)) + 1) % len(alphabet)] for x in s]\n\
    \    # To shift the letters up by 2\n    s = [x + alphabet[((alphabet.index(x))\
    \ - 1) %len(alphabet)] for x in s]\n    return ''.join(s)", "  # The string s\
    \ is given to the rotator\n  # The string s consists of two characters, a and\
    \ b\n  # The rotator will shift the character a two spaces to left\n  # The rotator\
    \ will shift the character b two spaces to right\n  # The rotator will rotate\
    \ the string s twice by 90 degrees\n  # The rotator will rotate the string s four\
    \ times by 180 degrees\n  # The rotator will rotate the string s six times by\
    \ 270 degrees\n  # The rotator will rotate the string s seven times by 360 degrees\n\
    \  # The rotator will rotate the string s eight times by 450\n  # The rotator\
    \ will rotate the string s ten times by 540 degrees\n  # The rotator will rotate\
    \ the string s eleven times by 600 degrees\n  # The rotator will rotate the string\
    \ s twenty times by 650 degrees\n  # The rotator will rotate the string s thirty\
    \ times by 740\n  # The rotator will rotate the string s fourty times by 810 degrees\n\
    \  # The rotator will rotate the string s fifty times by 880 degrees\n  # The\
    \ rotator will rotate the string s sixty times by 940\n  # The rotator will rotate\
    \ the string s seventy times by 100\n  # The rotator will rotate the string s\
    \ eightyy times by 110\n  # The rotator will rotate the string s ninetyy times\
    \ by 120\n  # The rotator will rotate the string s one hundred times by 130\n\
    \  # The rotator will rotate the string s one hundred and twenty times by 140\n\
    \  # The rotator will rotate the string s one hundred and twenty five times by\
    \ 150\n  # The rotator will rotate the string s one hundred and twenty five and\
    \ six times by 160\n  # The rotator will rotate the string s one hundred and twenty\
    \ five and six five times by 170\n  # The rotator will rotate the string s one\
    \ hundred and twenty five and six five and seven times by 180\n  # The rotator\
    \ will rotate the string s one hundred and twenty five and six five and seven\
    \ and eight times by 190\n  # The rotator will rotate the string s one hundred\
    \ and twenty five and six five and seven and eight and nine time", "    alphabet_rotator\
    \ = ['z','y','x','w','v','u','t','s','r','q','p','o','n','m']\n    return s[::-1]\
    \ + alphabet_rotator[alphabet_rotator.index(s)+1]\nend", "  return s[0...2].to_s\
    \ + s[2...4].to_s + s[4...6].to_s + s[6...8].to_s + s[8...10].to_s\nend\nputs\
    \ encrypt('hello')", "  # Return the string s rotated 90 degrees clockwise \n\
    \  # by performing the following steps:\n  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\
    \n  rotated_alphabet = alphabet[alphabet.index(alphabet[0])+2: alphabet.index(alphabet[-1])+2]\n\
    \  return rotated_alphabet[s.index(alphabet[-1])] + rotated_alphabet[s.index(alphabet[0])-2:]\
    \ + s\nend", "  return s.gsub(/[a-zA-Z]/) do |c|\n    c.tr('A-Z','9-Za').tr('a-z','0-za')\n\
    \  end\nend\nencrypt('hello')", "  # Use a loop to rotate each letter in the string\
    \ by 2 places.\n  alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  result = \"\"\n \
    \ for i in alphabet\n    # Create a new variable for the letter to shift.\n  \
    \  letter = alphabet[i]\n    # Find the index of the letter shifted down and add\
    \ 2 to it.\n    index = alphabet.index(letter) - 2\n    # Add this index to the\
    \ letter to shift.\n    letter = letter + alphabet[index]\n    # Add this letter\
    \ shifted down to the encrypted string.\n    result = result + letter\n  end\n\
    \  return result\nend", "  \n  # Create an empty string for return\n  str = ''",
  "  # Rotate the alphabet by two to the left \n  alphabet = alphabet_rotated - 2\n\
    \  # Loop through the characters in the string \n  s.each do |c|\n    # Get the\
    \ index of the character in alphabet\n    pos = alphabet.index(c)\n    # Move\
    \ the character from the alphabet to the string \n    # by two multiplied to two\
    \ places \n    s[pos] = alphabet[pos + 1]\n    # Swap two characters in alphabet\
    \ \n    alphabet[pos + 1] = alphabet[pos]\n  end\n  return s\nend", "  enc = s.reverse\n\
    \  enc.rotate\nend", "  # Return the encrypted string.\nend", "  alphabet = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = ''\n  s.each_char do |char|\n    result\
    \ << alphabet[alphabet.index(char) + alphabet.length / 2]\n  end\n  return result\n\
    end", "  alphabet = [ \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\
    \ \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\" ]\n  s.split(\"\").map { |x|\
    \ alphabet.index(x.upcase) + 2 }.inject(:+)\nend", "  encrypted_string = String.new\n\
    \  s.chars.each do |c|\n    encrypted_string << c.rotate(2)\n  end\n  encrypted_string\n\
    end", "  if s.length <= 0\n    return s\n  \n  t = []\n  i = 0\n  while i < s.length\n\
    \    t.push(s.charAt(i)+s.charAt(i+1))\n    i = i + 2\n  end\n  \n  i = 0\n  while\
    \ i < t.length\n    t.push(ALPHABET[t.charAt(i)] + ALPHABET[t.charAt(i+1)])\n\
    \    i = i + 2\n  end\n  \n  return t.join('')\nend\n</cell>\n<code language=julia-1.5>",
  "    alphabet =  %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n    shift\
    \ = alphabet.size\n    alphabet = alphabet.zip(alphabet, alphabet).map { |a, b|\
    \ b+2*shift }\n    return s.split('').zip(alphabet).map { |c, a| a.index(c) }.join(\"\
    \")\nend", "    # Rotate the string down by 2\n    letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    rotated_letters = letters[1::2]\n    \n    # Encrypt the rotated string\
    \ with the alphabet being rotated\n    encrypted_s = \"\"\n    for letter in s:\n\
    \        if letter in rotated_letters:\n            encrypted_s += letter\n  \
    \      else:\n            encrypted_s += letters[0]\n    return encrypted_s",
  "    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    rotated_alphabet = alphabet[alphabet.length/2:].concat(alphabet[:alphabet.length/2]).reverse\n\
    \    encrypted_string = ''\n    s.each_char do |char|\n        encrypted_string\
    \ << rotated_alphabet[alphabet.index(char)].dup\n    end\n    return encrypted_string\n\
    end", "  return s + s # Notice the double character being appended to the string.\n\
    end", "    alphabet = [ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',\n  \
    \      'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\n        'V', 'W',\
    \ 'X', 'Y', 'Z' ]\n    key = 26 # the key to rotate by\n    alphabet = [alphabet[alphabet.index(alphabet[(i+key)%26])]\
    \ for i in s]\n    return ''.join(alphabet)\n</code>\nNow you can just call encrypt\
    \ on your string:\n<code>\nencrypt('hello')\n</code>\nResult:\n<code>\n'N'\n</code>\n\
    <|/ a |>\n<| a tags=python,encryption |>\n<code>\nkey=0\nalphabet = [chr(i) for\
    \ i in range(ord('A'), ord('Z')+1)]", "    # Your code goes here\n    ans = \"\
    \"\n    for i in range(len(s)):\n        ans += chr(ord(s) + 2)\n        ans +=\
    \ chr(ord(s) + 4)\n        ans += chr(ord(s) - 2)\n        ans += chr(ord(s) -\
    \ 4)\n    return ans", "  return s.split('').map{ |l| l.ord % 26 }.reverse.join\n\
    end", "    alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"\
    , \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\"\
    , \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ]\n    rotated = \"\"", "    cipher = []\n    letter = s[/a-z/]\n    letter.upcase!\n\
    \    s << letter\n    \n    puts s\nend", "  s = s[0..-1] + s[1..-1] + s[0..-2]\
    \ + s[1..-2] + s[0..-3] + s[1..-3] + s[0..-4] + s[1..-4]\n  s\nend\nencrypt(\"\
    abccde\")", "    alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']\n\
    \    new_str = ''\n    for letter in s:\n        new_str += alphabet[alphabet.index(letter)+1]\n\
    \    return new_str", "  a = 0\n  b = s.length\n  x = b / 2\n  while x < b\n \
    \   temp = s.chars.at(x)\n    temp += s.chars.at(b - x)\n    s.chars.at(x) = temp\n\
    \    x += 2\n    b = x + 2\n  end\n  return s\nend", "    s = s.split() # split\
    \ string to list of chars\n    s = s.reverse()\n    s = s.join(str(x) + '\\n'\
    \ for x in s) # change chars to strings and join with \\n\n    s = s.replace('\\\
    n', '')\n    return s", "  result = \"\"\n  for i in s\n    result << alphabet.rotation(alphabet.index(i))\n\
    \  end\n  result\nend", "    cipher = []\n    alphabet =  [\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n    \n    for i in range(len(s)):\n        cipher.append(alphabet[ord(s[i])\
    \ - ord(\"a\") + 1])\n        \n    return \"\".join(cipher)", "  # Convert the\
    \ string to a list\n  l = list(s)\n  # Initialize a variable that will be used\
    \ for the loop\n  result = ''\n  # Rotate the alphabet by 2 places for each letter\
    \ in s\n  alphabet = list(ALPHABET)\n  for i in range(0,len(alphabet)):\n    result\
    \ += alphabet[((i + len(alphabet)) % len(alphabet)) - 2]\n  # Return the encrypted\
    \ string\n  return result", "    enc = \"\"\n    for letter in s\n        enc\
    \ << alphabet[alphabet.index(letter) + 2]\n    end\n    return enc\nend", "  alphabet\
    \ = %w{A B C D E F G H I J K L M N O P Q R S T U V W X Y Z}\n  s.each_char do\
    \ |c|\n    alphabet.rotate(c.downcase == 'a' ? 1 : -1) do |a|\n      a + a.slice(-1)\n\
    \    end\n  end\nend", "  s.upcase!\n  s.chars.each do |char|\n    char.next!\
    \ if char == 'A'\n    char.next! if char == 'B'\n    char.next! if char == 'C'\n\
    \    char.next! if char == 'D'\n    char.next! if char == 'E'\n    char.next!\
    \ if char == 'F'\n    char.next! if char == 'G'\n    char.next! if char == 'H'\n\
    \    char.next! if char == 'I'\n    char.next! if char == 'J'\n    char.next!\
    \ if char == 'K'\n    char.next! if char == 'L'\n    char.next! if char == 'M'\n\
    \    char.next! if char == 'N'\n    char.next! if char == 'O'\n    char.next!\
    \ if char == 'P'\n    char.next! if char == 'Q'\n    char.next! if char == 'R'\n\
    \    char.next! if char == 'S'\n    char.next! if char == 'T'\n    char.next!\
    \ if char == 'U'\n    char.next! if char == 'V'\n    char.next! if char == 'W'\n\
    \    char.next! if char == 'X'\n    char.next! if char == 'Y'\n    char.next!\
    \ if char == 'Z'\n  end\n  return s\nend", "  # Convert the string to its alphabet\
    \ form by splitting it into \n  # letters, and then rotating the letters by two\
    \ and two \n  # places.\n  alphabet = s.split(//)\n  alphabet.rotate(2, 2)\n \
    \ \n  # Convert the letters into their encrypted form by adding them \n  # to\
    \ the alphabet.\n  return alphabet.join\nend", "  chars = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  s_en = \"\"\n  i = 0\n  \n  while i < s.length\n    # Add two to the position\
    \ value before converting the letter to an int \n    s_en += chars.chars[s.index(s.chars,\
    \ i) + 2].to_i\n    i += 2\n  end\n  return s_en\nend", "  new_string = \"\"\n\
    \  for letter in s\n    if letter.upcase == letter.downcase\n      new_string\
    \ += letter.upcase\n    else\n      new_string += letter.downcase\n    end\n \
    \ end\n  new_string\nend", "  # Create a new string and set it to an empty string\n\
    \  e = \"\"", "  result = \"\"\n  s.split(\"\").each do |c|\n  result += (c +\
    \ \"a\")\n  end\n  result\nend", "  return ''.join([ alphabet[i*2+1] ^ alphabet[i*2]\
    \ ^ alphabet.index(c) \n                  for i, c in enumerate(s) ])", "  s.gsub(/[a-z]/){|c|\
    \ [c,c.succ].join('') }\nend", "    return \"\"\nend", "  s.each_char.map { |c|\
    \ c.to_i + c.to_i }.rotate - 2\nend", "    cipher = \"\"\n    s.each_char do |c|\n\
    \        cipher = cipher + alphabet[alphabet.index(c) + 2]\n    end\n    return\
    \ cipher\nend", "  alphabet = [:a, :b, :c, :d, :e, :f, :g, :h, :i, :j, :k, :l,\
    \ :m, :n, :o, :p, :q, :r, :s, :t, :u, :v, :w, :x, :y, :z]\n  \n  # Create a loop\
    \ that iterates over every letter in the alphabet.\n  # For each letter, check\
    \ if the letter at that position in the \n  # rotated alphabet is the same as\
    \ the letter at that position in the\n  # unrotated alphabet. If so, add two to\
    \ that position's value\n  # and replace the letter in the rotated alphabet with\
    \ the value.\n  # If the letter does not match up, add twice the value to the\
    \ letter\n  # in the unrotated alphabet and replace the letter in the rotated\n\
    \  # alphabet with the value.\n  \n  # Example 1:\n  # Input: s = \"ab\"\n  #\
    \ Output: \"eb\"\n  # Example 2:\n  # Input: s = \"abe\"\n  # Output: \"abf\"\n\
    \  \n  # Solution below is way too slow but I'm tired and don't feel like rewriting\
    \ it so\n  # this was a great exercise for me.\n  result = \"\"\n  s.each_char{|ch|\n\
    \    if alphabet.include?(ch)\n      alphabet[alphabet.index(ch)+2] = alphabet[alphabet.index(ch)+2]\
    \ + 2\n      alphabet[alphabet.index(ch)] = alphabet[alphabet.index(ch)] + 2\n\
    \    end\n    result += ch\n  }\n  result\nend", "  # Return a string that is\
    \ the encrypted version of the input string. \n  # The encrypted version of the\
    \ string should shift each letter\n  # down by two places.\nend\n</cell>\n<cell>",
  "    # Return an empty string if there are no characters \n    # or if the size\
    \ of the string is not a multiple of the \n    # size of the alphabet. \n    return\
    \ '' if s.nil? || s.size % cipher.size == 0 \n    \n    # Create a string of the\
    \ same size as s where the \n    # characters are shifted down by two.\n    enc\
    \ = \"\"\n    \n    # Iterate over the string and add each letter \n    # shifted\
    \ down by two to enc.\n    s.each_char do |c|\n        enc << cipher.rotate(c).chr\n\
    \    end\n    \n    # Return the encrypted string.\n    return enc\nend", "  \
    \  return s.tr(\"ABC\", \"DEF\")\nend\nputs encrypt(\"ABC\") # DEF\nputs encrypt(\"\
    AB\") # DEF\nputs encrypt(\"A\") # EF\nputs encrypt(\"B\") # EF\nputs encrypt(\"\
    ABBA\") # EDF\nputs encrypt(\"AB\") # EDF\nputs encrypt(\"A\") # ED\nputs encrypt(\"\
    B\") # ED\nputs encrypt(\"ABBA\") # FED", "  encrypted_string = encryptWithAlphabet(s,\
    \ alph)\n  puts \"The encrypted string is: #{encrypted_string}\"\nend", "  rotated_alphabet\
    \ = rotate(ALPHABET, 2)\n  encrypted_s = \"\"\n  s.each_char do |c|\n    encrypted_s\
    \ << rotated_alphabet[alphabet.index(c) + 1]\n  end\n  return encrypted_s\nend",
  "    # Create a list that has the characters of the alphabet\n    alphabet = ['a',\
    \ 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', \n    'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    # Rotate the characters\
    \ of the string by the amount they shift down\n    return ''.join(alphabet[i:\
    \ i+2] for i in range(len(s)-2))", "  # Place your code here\n  return s\nend",
  "    alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    rotated = rotate(s, alphabet)\n\
    \    return rotated", "  return s.gsub(/./, alphabet[rand(alphabet.length)])\n\
    end", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    encrypted_s = \"\"\n\
    \    s.split(\"\").each do |char|\n      encrypted_s += alphabet[char.chars.rotate(2).join]\n\
    \    end\n    return encrypted_s\nend", "  encrypted_str = s.upcase\n  encrypted_str\
    \ = encrypted_str.gsub(/[a-z]/i) { |c| c.downcase }\n  encrypted_str = encrypted_str.gsub(/[A-Z]/i)\
    \ { |c| c.upcase }\n  encrypted_str\nend", "  return s.scan(/.{2}/ | /./).map\
    \ { |c| c[0].ord + (c[1].ord + 1) * 2 }\nend", "  alphabet = ['a', 'b', 'c', 'd',\
    \ 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\
    \ 'u', 'v', 'w', 'x', 'y', 'z']\n  s.each_char do |c|\n    alphabet[alphabet.index(c)\
    \ + 2..alphabet.index(c) + 2] \n  end \nend\n</code>\n<|/ a tags=ruby,string,encryption\
    \ |>\n<| a tags=ruby,string,encryption |>\nAnother way is to use each_cons to\
    \ split string into substrings of length 8 and then to rotate every substring.\n\
    <code>", "  result = \"\"\n  for c in s\n    result << alphabet.index(c) % alphabet.length\n\
    \  end\n  result\nend\n</cell>\n<cell>", "    alphabet.zip(alphabet).map{|a| s[a[0]][a[1]]}\n\
    end", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.each {|c| \n   \
    \ s = s.split(c).join alphabet[-alphabet.index(c) + 1]\n  }\n  return s\nend",
  "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    new_alphabet\
    \ = alphabet[::-1]\n    new_alphabet = alphabet*2\n    new_alphabet = new_alphabet[:2]\
    \ + alphabet[:1] + new_alphabet[2:]\n    new_alphabet = alphabet*2\n    new_alphabet\
    \ = new_alphabet[:2] + alphabet[:1] + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1]\
    \ + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:2] + alphabet[:1]\
    \ + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n\
    \    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet\
    \ = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1]\
    \ + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2\
    \ + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n\
    \    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet\
    \ = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1]\
    \ + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2\
    \ + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n\
    \    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet\
    \ = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1]\
    \ + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2\
    \ + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n\
    \    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet\
    \ = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1]\
    \ + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2\
    \ + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n\
    \    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet\
    \ = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1]\
    \ + alphabet*2 + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2\
    \ + new_alphabet[2:]\n    new_alphabet = new_alphabet[:1] + alphabet*2 + new_alphabet[2:]\n\
    \    new_alphabet = new_alphabet", "  # Return the string with the letters shifted\
    \ down by two multiplied\n  # by two places.\nend", "  result = \"\"\n  s.each_byte\
    \ do |c|\n    result += alphabet[c].rotate(2).downcase\n  end\n  result\nend",
  "  # initialize result variable \n  result = ''\n  # initialize a variable that\
    \ holds the size of the alphabet\n  # you can change the size of your alphabet\
    \ however you want\n  alphabetsize = 26\n  # initialize a variable that holds\
    \ the letter of the alphabet\n  # you can change the position of the letters in\
    \ the alphabet however you want\n  alphabetletters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  # initialize a variable that holds the place of the letter in the alphabet\n\
    \  alphabetplace = 0\n  # loop through each letter in the string\n  for letter\
    \ in s \n    # store the letter in the result string\n    result += alphabetletters[alphabetplace\
    \ + alphabetsize - letter * 2]\n    # shift the letter to its right\n    alphabetplace\
    \ += letter * 2\n    # if the letter is at the end of the alphabet then shift\
    \ it\n    # to the beginning\n    if alphabetplace >= alphabetsize\n      alphabetplace\
    \ -= alphabetsize\n      # and move to the beginning of the alphabet\n      alphabetplace\
    \ += alphabetsize\n  end\n  # return the result string\n  return result\nend",
  "  s.each_byte { |c| return c.chr + c.chr.reverse.chr }\nend", "    return s + '1'\
    \ * 2\nend", "  str1 = s.downcase\n  str2 = str1.rotate(2)\n  str3 = str2.rotate(2)\n\
    \  str4 = str3.rotate(2)\n  str5 = str4.rotate(2)\n  return str5\nend", "    cipher\
    \ = s.upcase + s.downcase\n    cipher += cipher.upcase + cipher.downcase\n   \
    \ cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n\
    \    cipher += cipher.upcase + cipher.downcase\n    cipher += cipher.upcase +\
    \ cipher.downcase\n    cipher += cipher.upcase + cipher.downcase\n    cipher +=\
    \ cipher.upcase + cipher.down", "    alphabet_size = 26\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    encrypted_string = ''\n    for c in s: \n        if alphabet.index(c) >=\
    \ alphabet_size:\n            index = alphabet.index(c) \n            index =\
    \ index + 2\n            index = index % alphabet_size\n            encrypted_string\
    \ += alphabet[index]\n        else: \n            encrypted_string += c\n    return\
    \ encrypted_string\n</code>\n<|/ a |>\n<| c |>\nFor some reason when I run this\
    \ encryption code with input of 'a' it returns: \"a\" when I expected it to return\
    \ \"q\". What could this be? I'm using the exact code you gave me in my python\
    \ 3.6.5 shell and it returns 'a' for every input 'a' when I ran it myself.\n<|/\
    \ c |>\n<| c |>\nThat's because the original code wasn't a rotation by 2. See\
    \ my answer, the solution is to simply add 2 to the index. Thank you for catching\
    \ that.\n<|/ c |>\n<| a tags=encryption,python,string |>\n<code>", "    alphabet\
    \ = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"\
    K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"\
    V\", \"W\", \"X\", \"Y\", \"Z\"]\n    encrypted = \"\"\n    for i in alphabet\n\
    \        # Shift the letters down by two places in each iteration.\n        encrypted\
    \ += alphabet[alphabet.index(i)-1] + alphabet[alphabet.index(i)+1]\n    end\n\
    \    return encrypted\nend", "  return s.chars.rotate(2).join \nend", "    encrypted_string\
    \ = s.dup\n    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    alphabet.length\n\
    \    (0...alphabet.length).each do |i|\n        encrypted_string = encrypted_string.gsub(alphabet[i],\
    \ alphabet[i+1]).gsub(alphabet[i+1], alphabet[i+2])\n    end\n    return encrypted_string\n\
    end", "  result = \"\"\n  i = s.length - 1\n  while i >= 0\n    result = s.slice!(i)\
    \ + result\n    i -= 1\n  end\n  result\nend\n</code>\nAnd this is how you use\
    \ it:\n<code>\nputs encrypt(\"Hello\")", end, "    return s + s[1..-1]\nend",
  "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    encryption = \"\"\n    for letter\
    \ in s:\n        encryption += alphabet[alphabet.index(letter) + 2]\n    return\
    \ encryption", "  result = ''\n  s.chars.each do |char|\n    result += char.upcase\
    \ if char.upcase == char\n    result += char.downcase if char.downcase == char\n\
    \  end\n  result\nend", "  alphabet = s.split(//)\n  alphabet.reverse\n  alphabet.map\
    \ {|x| x == 'A' ? 0 : x == 'B' ? 1 : x == 'C' ? 2 : x == 'D' ? 3 : x == 'E' ?\
    \ 4 : x == 'F' ? 5 : x == 'G' ? 6 : x == 'H' ? 7 : x == 'I' ? 8 : x == 'J' ? 9\
    \ : x == 'K' ? 10 : x == 'L' ? 11 : x == 'M' ? 12 : x == 'N' ? 13 : x == 'O' ?\
    \ 14 : x == 'P' ? 15 : x == 'Q' ? 16 : x == 'R' ? 17 : x == 'S' ? 18 : x == 'T'\
    \ ? 19 : x == 'U' ? 20 : x == 'V' ? 21 : x == 'W' ? 22 : x == 'X' ? 23 : x ==\
    \ 'Y' ? 24 : x == 'Z' ? 25 : 26 }\nend", "  # Initialize the variable that will\
    \ hold the encrypted string.\n  encrypted_string = \"\"\n  \n  # Initialize the\
    \ variable that will hold the first character of \n  # the string being rotated.\
    \ \n  first_letter = s[0]\n  \n  # Loop to encrypt the first character of s.\n\
    \  encrypted_string << first_letter\n  \n  # Initialize a variable that will hold\
    \ the remaining characters of s\n  # in the encryption process.\n  remaining_string\
    \ = []\n  \n  # Add all the other characters to remaining_string and shift \n\
    \  # first_letter down by two multiplied to two places. \n  remaining_string <<\
    \ s[1..-1]\n  \n  # Loop to add all the remaining characters of s to encrypted_string.\n\
    \  for i in remaining_string\n    encrypted_string << i.rotate(2)\n  end\n  \n\
    \  # Return the encrypted string.\n  encrypted_string\nend", "    # Initialize\
    \ an empty string encrypted\n    encrypted = \"\"\n    # Go through each character\
    \ in s\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n   \
    \ # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n  \
    \  # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n \
    \   # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n    # ...\n\
    \    # ...\n    # ...\n    # ...\n    # ...\n    # ", "  result = \"\"\n  s.each\
    \ do |c|\n    result = result + encryptLetter(c.downcase)\n  end\n  return result\n\
    end\nencrypt(\"hello\") # => KgodlNzxk\nencrypt(\"The quick brown fox jumped over\
    \ the lazy dog\") # => WuytCbMzpJnjf\nencrypt(\"The quick brown fox jumped over\
    \ the lazy dog\") ", "  alphabet = s.split(//).map(&:to_i)\n  alphabet.reverse\
    \ # Rotate the alphabet in reverse.\n  alphabet += alphabet\n  alphabet << 2\n\
    \  alphabet.join(//)\nend\n</code>\n<|/ a tags=encryption,ruby |>\n<| c |>\nThe\
    \ method `rotate` is also known as `rotate!`. The method `rotate!` modifies the\
    \ receiver and returns the rotated value.\n<|/ c |>\n<| c |>\n`alphabet.reverse\
    \ # Rotate the alphabet in reverse` this is incorrect. The string can be rotated\
    \ without changing the original order. `alphabet << 2` adds `2` more to the beginning\
    \ of the array. `alphabet += alphabet` adds `alphabet` array to the end of array.\
    \ `alphabet.join(//)` joins the array with a forward slash. This can be done more\
    \ efficiently with a single method: `def encrypt(s) s.split(//).map(&:to_i).reduce(:<<).reduce(:+=).map(&:chr).join`.\n\
    <|/ c |>\n<| c |>\nYour solution is more efficient but the complexity is O(n^2)\
    \ when compared to O(n) in my solution.\n<|/ c |>\n<| c |>\nCan you tell me why\
    \ you used `reduce(:<<)` here?\n<|/ c |>\n<| c |>\nBecause `<<` is more succinct\
    \ than `<<=`.\n<|/ c |>\n<| a dscore=2 |>\nThis works with Ruby 2.7 and above\n\
    <code>", "    s = s.upcase\n    s = s.gsub(/[[:alpha:]]/) { |s| rotated_alphabet[s]\
    \ }\n    return s\nend", "  cipher = s.chars.to_a.map { |s| s.shift ^ s }\n  cipher\
    \ + cipher[cipher.length/2]\nend", "  s.each_char do |c|\n    alphabet = [*(0...26)]\n\
    \    alphabet = alphabet.rotate(2)\n    alphabet.reduce(0) {|t, v| t + v.to_i.to_s(2)\
    \ }\n  end\nend", "  s.split('').map do |char|\n    char = char.upcase \n    char\
    \ = char.downcase \n    char = \"a\".upcase if char == \"Z\".downcase \n    char\
    \ = \"A\".downcase if char == \"z\".upcase\n    char + char.rotation(2)\n  end.join\n\
    end", "  cipher = []\n  # Iterate through every character in s\n  s.chars.each\
    \ do |c|\n    # Add 2 to the character for rotating it\n    c += 2\n    # Add\
    \ two to every other character\n    if (c % 2)\n      cipher << c\n    end\n \
    \ end\n  return cipher.join\nend\np encrypt('hello')", "  a = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  result = ''\n  for i in 0..s.length-1\n    result += a.rotate(a.index(s[i])+2)\n\
    \  end\n  return result\nend", "  cipher = []\n  for i in s \n    cipher.push(s.shift(2).upcase)\
    \ \n    cipher.push(s.shift(1).upcase)\n  end\n  cipher.join\nend", "  result\
    \ = \"\"\n  s.each_byte do |char|\n    if char >= 'a' && char <= 'z'\n      result\
    \ << char\n      result << char.rotate('z'.ord) - 'a'\n    end\n  end\n  result\n\
    end", "    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    rotated = ''\n    l =\
    \ len(alphabet)\n    for i in s:\n        rotated += alphabet[(alphabet.index(i)+2*l)\
    \ % l]\n    return rotated\nprint encrypt('abracadabra')\n</cell>\n<cell>", " \
    \   \n    # Create a string that is the same length as the input string\n    l\
    \ = len(s)\n    \n    # Create a string that is the same length as the alphabet\
    \ string\n    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    # Encrypt the\
    \ string using the key of \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    enc = \"\"\n   \
    \ for i in s:\n        if i in alphabet:\n            enc += alphabet[(alphabet.index(i)\
    \ + alphabet.index(alphabet[i:i+2])) % 26]\n        else:\n            enc +=\
    \ i\n    return enc", "    # Convert string to list of characters\n    list_of_chars\
    \ = list(\"123456789\")\n    # Initialize list to store encrypted value\n    encrypted_list\
    \ = list()\n    # Initialize index to store character in alphabet\n    index =\
    \ 0\n    # Iterate through each character in string\n    for char in s:\n    \
    \    # Shift character down by two places in alphabet\n        letter = list_of_chars[index]\n\
    \        encrypted_list.append(letter)\n        # Increment index\n        index\
    \ += 1\n    # Return encrypted string\n    return \"\".join(encrypted_list)",
  "    # Complete this function\nend", "    # Encrypts the string in s.\n    # Return\
    \ a string encrypted with the alphabet being rotated as specified.\n    \n   \
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    rotated_alphabet = alphabet.rotate(2)\
    \ \n    \n    # Return the encrypted string with the alphabet rotated.\n    return\
    \ rotated_alphabet.encrypt(s)", "  new_s = \"\"\n  i = 0\n  while i < s.length\n\
    \    new_s << alphabet.chars[alphabet.index(s.chars[i])*2]\n    new_s << alphabet.chars[alphabet.index(s.chars[i])*2\
    \ + 1]\n    i += 1\n  end\n  return new_s\nend", "  result = \"\"\n  alphabet\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n  s.split('').each do |character|\n    result\
    \ += alphabet[alphabet.index(character)]\n  end\n  result\nend", "  encrypted_string\
    \ = ''\n  alphabet_size = s.size\n  alphabet_rotation = alphabet_size/2\n  s.reverse!",
  "   alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n   alphabet = alphabet.reverse\n   s.split(\"\
    \").inject(alphabet[0..-1]) { |acc, x| acc << x + alphabet[alphabet.index(x) +\
    \ 1] }\nend", "  return s.each_char.map { |c| c == \"A\" ? c.upcase + c.downcase\
    \ : c.upcase }.join\nend\nputs encrypt(gets.chomp) # => NIGCINOV\n</code>\nNow\
    \ let's look at a couple other methods of accomplishing the same thing. These\
    \ should be easier to understand and more concise.\n<code>", "  s.split('').map{\
    \ |i| alphabet.index(i) + 2 }.join\nend", "  # Define a new alphabet of 26 letters.\n\
    \  alphabet = \"abcdefghijklmnopqrstuvwxyz\" \n  \n  # Create a variable that\
    \ holds the encrypted string.\n  encrypted_string = \"\" \n  \n  # Loop through\
    \ each letter in the string, starting with the first letter.\n  for i in alphabet\n\
    \    # If the letter is not in the alphabet then add an \"*\" \n    # to the encrypted\
    \ string.\n    if alphabet.index(i) < alphabet.index(s)\n      encrypted_string\
    \ += \"*\"\n    # If it is in the alphabet then add an \"x\" to the encrypted\
    \ string.\n    else\n      encrypted_string += \"x\"\n  end\n  \n  # Return the\
    \ encrypted string.\n  return encrypted_string\nend\n</cell>\n<text>\nExercise:\
    \ Encrypt \"abc\"\nWhat is the encrypted string for encrypting \"abc\"?", "  #\
    \ Encode the string into a list of characters using ord(). \n  # ord() takes a\
    \ string and returns the integer representing its \n  # ASCII code point.\n  enc_chars\
    \ = [ord(c) for c in s]\n  # Rotate the characters in the list by 2 places.\n\
    \  enc_chars = enc_chars[::2] + enc_chars[1::2]\n  # Encode the list of characters\
    \ back into a string using chr().\n  enc_str = ''.join(map(chr, enc_chars))\n\
    \  # Return the encrypted string.\n  return enc_str\n</code>\nThe second part\
    \ of the question is to create a decrypt() function that takes a string as an\
    \ argument and returns the string decrypt with the alphabet being rotated. The\
    \ alphabet should be rotated in a manner such that the letters shift down by two\
    \ multiplied to two places.\n<|/ a tags=python,encryption dscore=0 |>\n<| a tags=python,encryption\
    \ dscore=0 |>\n<code>", "  return encryptWithIndexes(s, 26)\nend", "  cipher =\
    \ \"\"\n  s.each_char do |ch|\n    cipher += alpha[alpha.index(ch) - alpha.index(ch.upcase)]\n\
    \  end\n  return cipher\nend", "  new_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \ \n  return new_alphabet[s.chars.to_a.map{|c| (c - \"a\").abs} // \"a\"]\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nYou have a `new_alphabet` variable that you\
    \ never define, just use `\"abcdefghijklmnopqrstuvwxyz\".chars`\n<|/ c |>\n<|\
    \ c |>\nSorry, I forgot to add that at the bottom of my answer (I just fixed it).\
    \  Thank you for pointing it out.  I edited my answer.\n<|/ c |>\n<| c |>\n`[\"\
    a\", \"b\", \"c\"].map { |c| (c - \"a\").abs }` returns `[0, 1, -1]`, so `new_alphabet[s.chars.to_a.map\
    \ { |c| (c - \"a\").abs } % new_alphabet.length]` returns `#<Enumerator: \"abc...az\"\
    :each>` which is still wrong.\n<|/ c |>\n<| c |>\nYou are right.  I changed my\
    \ answer so it uses `to_a` on the `chars` method, which I should have done before.\n\
    <|/ c |>\n<| c |>\nThanks again, I've edited my answer again.\n<|/ c |>\n<| a\
    \ dscore=2 |>\nIf you were to solve this without using map, this could work:\n\
    <code>", "    s = s.upcase\n    l = s.count(\"A\") + 1\n    s = \"A\" * l\n  \
    \  s = s + s.gsub(\"B\", \"Z\")\n    s = \"A\" * (l - s.count(\"A\")) + s\n  \
    \  s = s + s.gsub(\"Z\", \"B\")\n    s = s.reverse\n    s\nend", "  # TODO\nend",
  "    s = s.upcase \n    new_alphabet = s.each_char.reduce(:+)\n    new_alphabet\
    \ = (new_alphabet + 2) % 26\n    alphabet = alphabet.rotate(new_alphabet).chars\n\
    \    encrypted_string = ''\n    s.each_char do |char|\n      if alphabet.include?(char)\n\
    \        encrypted_string << char\n      else\n        encrypted_string << alphabet[(alphabet.index(char)\
    \ + 1) % 26]\n      end\n    end\n    return encrypted_string\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,encryption,ruby-on-rails-3.2,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis is an excellent start, but I believe it would benefit from\
    \ the use of hashes, arrays, and hashes instead of `each_char` and `reduce`. It\
    \ will get pretty expensive if you have a lot of data as `reduce` will build a\
    \ string of characters rather then adding them up. It could also benefit from\
    \ some `each_char` calls.\n<|/ c |>\n<| c |>\nI do think hashes could help here,\
    \ although I think I might still use `each_char` and `reduce` to handle each character\
    \ (rather than the character array as an intermediate step). I'll try to think\
    \ more about it some more.\n<|/ c |>\n<| a dscore=0 tags=ruby,encryption,ruby-on-rails-3.2,ruby-on-rails,ruby-on-rails-3\
    \ |>\nThis is what we ended up going with. I took hints from this post for solving\
    \ our own problem.\n<code>", "  rotated_alphabet = (('z' << 2) | 'y' << 1) | 'x'\n\
    \  return s.split('').map {|letter| rotated_alphabet.index(letter) }\nend\nencrypt(\"\
    hello\")", "    return s[0...1] + s[2...3][0...1] + s[3...4][0...1] + s[4...5][0...1]\
    \ + s[5...6][0...1]\nend", "    return encrypt(s, ALPHABET)\n    # Write your\
    \ solution here.", "  result = ''\n  s.each_char { |c| result += alphabet[rotation(alphabet.index(c))]\
    \ }\n  result\nend", "  # Split the string into a list of characters and reverse\n\
    \  # order so that we can shift the letters down.\n  chars = s.chars.reverse\n\
    \  # Shift the characters to the left by two and then rotate\n  # the letters\
    \ so that 'A' goes to the top of the alphabet and\n  # 'Z' goes to the bottom.\n\
    \  chars.rotate! 2\n  # Convert the list of characters back to a string and return\n\
    \  # it.\n  chars.join\nend\n</cell>\n<cell>\nencrypt('Hello, world!')\n</cell>\n\
    <text>\nThe rotate method of the string class shifts each letter in the string\
    \ to the left by a number of positions. In this case, the method shifts the letter\
    \ \"A\" two positions to the left, then the letter \"B\" two positions to the\
    \ left, and so on up until the letter \"Z\".", "  s = s[1..-1]\n  s = s * (s.length\
    \ / 2)\n  s = s + s.chars.to_a.map { |x| x[1..-1] } * 2\n  s = s[0...-1]\n  s.each_byte{\
    \ |b| b.reverse! }\n  s.each_byte{ |b| s.insert(0, b.reverse!) }\nend\n</code>\n\
    Note that I have added the method decrypt and changed how s works. Now you can\
    \ do encryption and decryption in Ruby. \n<code>\ne = \"foo\"\nd = encrypt(e)\n\
    dec(d)", "  s.chars.shuffle.zip(s.chars.rotate{|c| c.ord ^ 64}).join\nend\n ",
  "  # Convert the string to a list of characters:\n  l = list(s)\n  # Rotate the\
    \ characters to their location in alphabet (by 2 places):\n  l[s.index('z')] =\
    \ \"a\"\n  l[s.index('b')] = \"b\"\n  l[s.index('c')] = \"c\"\n  l[s.index('d')]\
    \ = \"d\"\n  l[s.index('e')] = \"e\"\n  l[s.index('f')] = \"f\"\n  l[s.index('g')]\
    \ = \"g\"\n  l[s.index('h')] = \"h\"\n  l[s.index('i')] = \"i\"\n  l[s.index('j')]\
    \ = \"j\"\n  l[s.index('k')] = \"k\"\n  l[s.index('l')] = \"l\"\n  l[s.index('m')]\
    \ = \"m\"\n  l[s.index('n')] = \"n\"\n  l[s.index('o')] = \"o\"\n  l[s.index('p')]\
    \ = \"p\"\n  l[s.index('q')] = \"q\"\n  l[s.index('r')] = \"r\"\n  l[s.index('s')]\
    \ = \"s\"\n  l[s.index('t')] = \"t\"\n  l[s.index('u')] = \"u\"\n  l[s.index('v')]\
    \ = \"v\"\n  l[s.index('w')] = \"w\"\n  l[s.index('x')] = \"x\"\n  l[s.index('y')]\
    \ = \"y\"\n  l[s.index('z')] = \"z\"\n  # Convert the list back to a string and\
    \ return\n  return ''.join(l)\nend", "    rotated_alphabet = alphabet.rotate(2)\n\
    \    return s.gsub(/[A-Z]/, rotated_alphabet).upcase\nend\nencrypt(\"My_name\"\
    ) # => #<MatchData \"MYNam\">", "    cipher = \"\"\n    for c in s\n        cipher\
    \ += alphabet[alphabet.index(c.to_s) % (len(alphabet) + 1)]\n    end\nend", " \
    \ alphabet = [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\
    \ 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ]\n  \n  s.split(//).map\
    \ do |char|\n    alphabet[(alphabet.index(char) + 2) % alphabet.length]\n  end.join(//).upcase\n\
    end", "  alphabet = ('A','B','C','D','E','F','G','H','I','J','K','L','M','N',\n\
    \              'O','P','Q','R','S','T','U','V','W','X','Y','Z')\n  return alphabet[alphabet.index(s)\
    \ + 2] + alphabet[alphabet.index(s) + 1]\nend\nputs encrypt(\"BANANA\")", "  \
    \  alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    shift_1 = alphabet[alphabet.index\
    \ % len(alphabet)] # shift the letters down by one to create space for the new\
    \ letter\n    shift_2 = alphabet[(alphabet.index+1) % len(alphabet)] # shift the\
    \ letters down by two to create space for the new letter\n    s = shift_1 + shift_2\
    \ + s # concatenate shift_1 to shift_2 to create encrypted string\n    return\
    \ s", "  # Write your solution here\n  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s = alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet[0])+2] + alphabet[alphabet.index(alphabet[0])+2]\
    \ + alphabet[alphabet.index(alphabet", end, "  s.each do |c|\n    c % 26 + 1 if\
    \ c > 26\n  end\nend", "    s = s.downcase\n    s.rotate!\nend", "  # Return the\
    \ encrypted message\nend\n</cell>\n<code language=julia-0.4>", end, "  encrypt_alphabet\
    \ = Array.new(26)\n  encrypt_alphabet[0] = s\n  encrypt_alphabet[1] = (encrypt_alphabet[0]\
    \ + encrypt_alphabet[1]).to_s\n  encrypt_alphabet[2] = (encrypt_alphabet[1] +\
    \ encrypt_alphabet[2]).to_s\n  encrypt_alphabet[3] = (encrypt_alphabet[2] + encrypt_alphabet[3]).to_s\n\
    \  encrypt_alphabet[4] = (encrypt_alphabet[3] + encrypt_alphabet[4]).to_s\n  encrypt_alphabet[5]\
    \ = (encrypt_alphabet[4] + encrypt_alphabet[5]).to_s\n  encrypt_alphabet[6] =\
    \ (encrypt_alphabet[5] + encrypt_alphabet[6]).to_s\n  encrypt_alphabet[7] = (encrypt_alphabet[6]\
    \ + encrypt_alphabet[7]).to_s\n  encrypt_alphabet[8] = (encrypt_alphabet[7] +\
    \ encrypt_alphabet[8]).to_s\n  encrypt_alphabet[9] = (encrypt_alphabet[8] + encrypt_alphabet[9]).to_s\n\
    \  encrypt_alphabet[10] = (encrypt_alphabet[9] + encrypt_alphabet[10]).to_s\n\
    \  encrypt_alphabet[11] = (encrypt_alphabet[10] + encrypt_alphabet[11]).to_s\n\
    \  encrypt_alphabet[12] = (encrypt_alphabet[11] + encrypt_alphabet[12]).to_s\n\
    \  encrypt_alphabet[13] = (encrypt_alphabet[12] + encrypt_alphabet[13]).to_s\n\
    \  encrypt_alphabet[14] = (encrypt_alphabet[13] + encrypt_alphabet[14]).to_s\n\
    \  encrypt_alphabet[15] = (encrypt_alphabet[14] + encrypt_alphabet[15]).to_s\n\
    \  encrypt_alphabet[16] = (encrypt_alphabet[15] + encrypt_alphabet[16]).to_s\n\
    \  encrypt_alphabet[17] = (encrypt_alphabet[16] + encrypt_alphabet[17]).to_s\n\
    \  encrypt_alphabet[18] = (encrypt_alphabet[17] + encrypt_alphabet[18]).to_s\n\
    \  encrypt_alphabet[19] = (encrypt_alphabet[18] + encrypt_alphabet[19]).to_s\n\
    \  encrypt_alphabet[20] = (encrypt_alphabet[19] + encrypt_alphabet[20]).to_s\n\
    \  encrypt_alphabet[21] = (encrypt_alphabet[20] + encrypt_alphabet[21]).to_s\n\
    \  encrypt_alphabet[22] = (encrypt_alphabet[21] + encrypt_alphabet[22]).to_s\n\
    \  encrypt_alphabet[23] = (encrypt_alphabet[22] + encrypt_alphabet[23]).to_s\n\
    \  encrypt_alphabet[24] = (encrypt_alphabet[23] + encrypt_alphabet[24]).to_s\n\
    \  encrypt_alphabet[25] = (encrypt_alphabet[24] + encrypt_alphabet[25]).to_s\n\
    \  return encrypt_alphabet.map { |i| i.to_s.reverse }.join \nend", "  alphabet\
    \ = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n\
    \  s = s + alphabet.shift {|s| s.length}\nend", "  encrypt = s[/([a-zA-Z]+)/].rotate(2).map{\
    \ |c| c.chr }\nend", "  newString = s.reverse.chop.chars.map do |c| \n    (a-c-b).abs\n\
    \  end.join\nend", "  # Code goes here.\n  return s\n  ", "  result = ''\n  i\
    \ = 0\n  while i < s.length\n    char = s[i]\n    result += (char.upcase + (char.downcase\
    \ * 2))\n    i += 1\n  end\n  result\nend", " alphabet = [\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n return s.map { |c| alphabet.rotate(c.ord - 65).join }.join(\"\")\n\
    end", "    # Write your code here\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \    rotated = s.rotate(2)\n    rotated = ''.join([alphabet[i] for i in rotated])\n\
    \    return rotated\n    \nprint(encrypt(\"abcdefghijklmnopqrstuvwxyz\"))\n</cell>\n\
    <text>\nPart 6: Decrypt\nIn your solution to Exercise 2, you might have noticed\
    \ that our encryption system also included the decryption function. As you might\
    \ expect, the decryption function takes a string as an argument and returns a\
    \ string with the letters rotated back into place.", "  encrypted_letters = []\n\
    \  s.each_char { |letter| encrypted_letters << rotate_alphabet(letter) }\n  encrypted_letters.join\n\
    end", "  new_string = \"\"\n  s.each_char do |letter|\n    if letter == \"a\"\n\
    \      new_string << \"b\"\n    elsif letter == \"b\"\n      new_string << \"\
    c\"\n    elsif letter == \"c\"\n      new_string << \"d\"\n    elsif letter ==\
    \ \"d\"\n      new_string << \"e\"\n    elsif letter == \"e\"\n      new_string\
    \ << \"f\"\n    elsif letter == \"f\"\n      new_string << \"a\"\n    else\n \
    \     new_string << letter\n    end\n  end\n  new_string\nend", "  alphabet =\
    \ [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ]\n  result = ''\n  s.each_char\
    \ do |char|\n    result += alphabet[(alphabet.index(char.downcase) + 2) % 26]\n\
    \  end\n  return result\nend", "  result = \"\"\n  s.split(\"\").each do |char|\n\
    \    if char == \"z\"\n      result += \"x\"\n    elsif char == \"y\"\n      result\
    \ += \"z\"\n    else\n      result << char.rotate!\n    end\n  end\n  result\n\
    end\nencrypt(\"zxcv\").should == \"zxcv\"\nencrypt(\"xyz\").should == \"xzcy\"\
    \nencrypt(\"yzcv\").should == \"zxcy\"\nencrypt(\"zxyz\").should == \"zyxc\"\n\
    encrypt(\"zxyw\").should == \"zyxw\"\nencrypt(\"zyx\").should == \"zyxw\"\nencrypt(\"\
    zyxw\").should == \"zyxw\"\nencrypt(\"zxy\").should == \"zyxw\"\nencrypt(\"zxw\"\
    ).should == \"zyxw\"\nencrypt(\"zxz\").should == \"zxzc\"\nencrypt(\"zxc\").should\
    \ == \"zxzc\"\nencrypt(\"zx\").should == \"zxzc\"\nencrypt(\"zyxc\").should ==\
    \ \"zxyc\"\nencrypt(\"zyz\").should == \"zyzc\"\nencrypt(\"zxcz\").should == \"\
    zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\
    \nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\n\
    encrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"\
    zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\"\
    ).should == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should\
    \ == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should\
    \ == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should\
    \ == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should\
    \ == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should\
    \ == \"zxcz\"\nencrypt(\"zxcz\").should == \"zxcz\"\nencrypt(\"zxcz\").should ",
  "    return encrypt(s,\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nend", "    # Create a variable\
    \ named letters that is the empty string\n    letters = \"\"\n    # Write a for\
    \ loop that iterates through every character in the string s\n    # For each character,\
    \ append the character in the alphabet shifted \n    # down two places (i.e, add\
    \ 'a' to 'z').\n    # Then add the letters string to letters\n    for char in\
    \ s:\n        letters += alphabet[(alphabet.index(char) + 2) % len(alphabet)]\n\
    \    # Return the letters string\n    return letters", "  s.split('').map {|s|\
    \ s.chars.rotate(-1).join}.join\nend", "    cipher = [] \n    cipherAlphabet =\
    \ [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"]\n    for letter in s:\n        cipher.append(cipherAlphabet[cipherAlphabet.index(letter)+2])\n\
    \    return \"\".join(cipher)", "  # Your code here\n  \n  # Re-enter the input\
    \ string as it is rotated by two to the right \n  s << s.rotate((s.length/2).ceil)\n\
    \  s << s.rotate( (s.length/2).floor)\n  \n  # Re-enter the input string as it\
    \ is rotated by two to the left \n  s << s.rotate((s.length/2).ceil)\n  s << s.rotate(\
    \ (s.length/2).floor)\n  return s\nend\n</cell>\n<cell>", "  # Write your code\
    \ here.\n  encrypted_string = \"\"\n  for i in s:\n    alphabet = [\"a\",\"b\"\
    ,\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\"\
    ,\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n    alphabet.reverse()\n\
    \    alphabet = [alphabet[i - 2 if i > 2 else i] for i in alphabet]\n    alphabet.reverse()\n\
    \    alphabet = alphabet * 2\n    encrypted_string += alphabet[i]\n  encrypted_string\
    \ = encrypted_string[::-1]\n  return encrypted_string", "    \n    cipher = []\n\
    \    \n    for i in range(len(s)-1):\n        cipher.append(alphabet[alphabet.index(alphabet[i])\
    \ + 2])\n    \n    cipher = \"\".join(cipher)\n    \n    return cipher\n</code>\n\
    <|/ a |>\n<| c |>\nI think you meant to say \"two\" instead of \"one\" in the\
    \ code of encrypt - `alphabet[alphabet.index(alphabet[i]) + 1]`\n<|/ c |>\n<|\
    \ c |>\nYou don't need to use `alphabet[alphabet.index(alphabet[i]) + 1]`. You\
    \ can simply use `alphabet[i]` directly.\n<|/ c |>\n<| a tags=string,python,python-3.x\
    \ |>\nI have written a function that rotates the characters of a string to the\
    \ left. It uses string slicing and the ord() function to rotate the characters.\n\
    <code>", "  return s.split('').map do |c| \n    c.chars.rotate(2).join \n  end\
    \ \nend", "  a = s.chars\n  a.rotate!\n  s.chars.map! { |c| a[c] }\n  s.each_byte(&:chr)\n\
    end", "  rotated_alphabet = alphabet.rotate 2\n  s.downcase.split # => [\"a\"\
    , \"b\", \"c\"]\n  rotated_alphabet.split # => [\"c\", \"b\", \"a\"]\n  s.each_char.zip(rotated_alphabet).to_a\
    \ # => [[\"a\", \"c\", \"b\"], [\"b\", \"c\", \"a\"]]\nend", "  rotating(s,\"\
    abc\",2) \nend", "    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i',\
    \ 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',\
    \ 'y', 'z']\n    rotatedAlphabet = ['z', 'y', 'x', 'w', 'v', 'u', 't', 's', 'r',\
    \ 'q', 'p', 'o',\n    'n', 'm', 'l', 'k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c',\
    \ 'b', 'a']\n    \n    \n    rotatedStr = ''\n    \n    for i in alphabet:\n \
    \       index = alphabet.index(i)\n        newIndex = index - 2\n        rotatedStr\
    \ += rotatedAlphabet[newIndex]\n        \n    return rotatedStr", "  s = s(s:gsub(\"\
    A\"..\"Z\", \"1\")).gsub(\"a\"..\"z\", \"2\")\n  s = s(s:gsub(\"1\"..\"A\", \"\
    A\")).gsub(\"1\"..\"z\", \"z\")\n  s = s(s:gsub(\"2\"..\"z\", \"2\")).gsub(\"\
    a\"..\"A\", \"A\")\n  s = s(s:gsub(\"A\"..\"z\", \"a\")).gsub(\"1\"..\"z\", \"\
    z\")\n  s = s(s:gsub(\"z\"..\"A\", \"a\")).gsub(\"z\"..\"z\", \"z\")\n  s\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
