name: HumanEval_108_count_nums
language: rb
prompt: "# Write a function count_nums which takes an array of integers and returns\n\
  # the number of elements which has a sum of digits > 0.\n# If a number is negative,\
  \ then its first signed digit will be negative:\n# e.g. -123 has signed digits -1,\
  \ 2, and 3.\ndef count_nums(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_nums\n\
  \    candidate = method(:count_nums)\n    assert_equal(0, candidate.call([]))\n\
  \    assert_equal(0, candidate.call([-1, -2, 0]))\n    assert_equal(6, candidate.call([1,\
  \ 1, 2, -2, 3, 4, 5]))\n    assert_equal(5, candidate.call([1, 6, 9, -6, 0, 1, 5]))\n\
  \    assert_equal(4, candidate.call([1, 100, 98, -7, 1, -1]))\n    assert_equal(5,\
  \ candidate.call([12, 23, 34, -45, -56, 0]))\n    assert_equal(1, candidate.call([0,\
  \ 1]))\n    assert_equal(1, candidate.call([1]))\n  end\nend\n"
completions: ["  arr.each_with_index do |n, i|\n    if n < 0\n      arr[i] = -n if\
    \ n > 0\n      arr[i] = 0\n      i += 1 \n    end\n  end\n  arr.count{ |n| n >\
    \ 0 }\nend", "    count = 0\n    \n    arr.each {|x| \n        x.to_s.split('').each\
    \ { |digit| \n            count += 1\n            if digit.to_i < 0 \n       \
    \         count -= 1\n            end\n        }\n    }\n    \n    return count\n\
    end\n</code>\nWe can also make use of the Enumerable#map method which iterates\
    \ through an array and applies the given block on each element:\n<code>", "  \
    \  arr.each do |n|\n        if n == 0\n            return 1\n        elsif n <\
    \ 0\n            return count_nums(n.to_s.chars.reverse.map {|x| x * -1}.reverse)\n\
    \        elsif n < 10\n            return 1 + count_nums(n.to_s.chars.reverse.map\
    \ {|x| x * -1})\n        else\n            return 1 + count_nums(n.to_s.chars.reverse.map\
    \ {|x| x * -1}.reverse) + count_nums(n.to_s.chars.reverse.map {|x| x * -1}.reverse)\n\
    \        end\n    end\nend", "  arr.each do |n|\n    return 0 if n.to_s.split('').map{|x|\
    \ x.to_i}.inject(:+) == 0 # if n is negative, first digit is negative\n    return\
    \ 1 if n.to_s.split('').map{|x| x.to_i}.inject(:+) > 9\n    return 2 if n.to_s.split('').map{|x|\
    \ x.to_i}.inject(:+) > 99\n    return 3 if n.to_s.split('').map{|x| x.to_i}.inject(:+)\
    \ > 999\n    return 4 if n.to_s.split('').map{|x| x.to_i}.inject(:+) > 9999\n\
    \    return 5 if n.to_s.split('').map{|x| x.to_i}.inject(:+) > 99999\n    return\
    \ 6 if n.to_s.split('').map{|x| x.to_i}.inject(:+) > 999999\n    return 7 if n.to_s.split('').map{|x|\
    \ x.to_i}.inject(:+) > 9999999\n    return 8 if n.to_s.split('').map{|x| x.to_i}.inject(:+)\
    \ > 999999999\n    return 9 if n.to_s.split('').map{|x| x.to_i}.inject(:+) > 99999999999\n\
    \    return 10 if n.to_s.split('').map{|x| x.to_i}.inject(:+) > 999999999999\n\
    \  end\nend\ncount_nums([1,2,-3,-4,555,45])", "  arr.reduce(0) do |acc, x|\n \
    \   (acc + ((x / 10).floor * 10)) if x > 0 && x % 10 == 0\n  end\nend", "  arr.each\
    \ do |n|\n    if n % 10 == 0\n      sum += n\n      sum += n % 10\n      sum +=\
    \ n % 10\n      sum += n % 10\n      sum += n % 10\n    end\n  end\n  return sum\n\
    end", "  arr.inject(0) { |n, e| n + (e < 0 ? -e**8 : e**8) }\nend", "  arr.select{|e|\
    \ e > 0}\nend", "    arr.each_with_index do |n, i|\n        if n > 0\n       \
    \     sum += i if sum > i\n            sum -= i if sum < i\n        end\n    end\n\
    \    sum\nend\n</cell>\n<cell>", "  count = 0\n  arr.each do |num|\n    if num\
    \ > 0\n      count += 1 if num.to_s.split(//).sum.to_i > 1\n    elsif num < 0\n\
    \      count += 1\n    end\n  end\n  return count\nend", "  count = 0\n  arr.each\
    \ do |n|\n    count += (n >= 0) ? n.divmod(10).size : 1\n  end\n  count\nend\n\
    </code>\nThe function count_nums is the only thing that really needs to be tested\
    \ and verified in the context of the problem.\nThe code in the test is very simple,\
    \ simply calling the function and verifying the expected result is obtained:\n\
    <code>\ndescribe \"#count_nums\" do\n  it \"counts the number of integers whose\
    \ sum is > 0\" do\n    expect(count_nums([-2, 6, -4])).to eq(1)\n    expect(count_nums([6,\
    \ -4])).to eq(1)\n    expect(count_nums([-6, -4])).to eq(0)\n    expect(count_nums([-2,\
    \ -4, -6, -8])).to eq(2)\n  end\nend\n</code>\nThe tests are very easy to understand.\
    \ Since Ruby is an interpreted language, there is no compilation step.\nThe tests\
    \ also reveal several important points:", "  arr.each { |x| x -= x.abs; return\
    \ x if x >= 0 }.length\nend\n</code>\nTest\n<code>\narr = [1, 2, -3, -4, 6, -7,\
    \ 8, 9]\n</code>\n<code>\ncount_nums(arr) # => 2\n</code>\n<code>\narr = [123,\
    \ -456]\n</code>\n<code>\ncount_nums(arr) # => 2\n</code>\n<code>\narr = [123,\
    \ -456, 99]\n</code>\n<code>\ncount_nums(arr) # => 2\n</code>\n<code>\narr = [1,\
    \ 2]\n</code>\n<code>\ncount_nums(arr) # => 1\n</code>\n<code>\narr = [1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n</code>\n<code>\ncount_nums(arr)\
    \ # => 2\n</code>\n<code>\narr = [-1, -2, -3]\n</code>\n<code>\ncount_nums(arr)\
    \ # => 1\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  arr.each do |i|\n \
    \   num = i.abs\n    # Break if a negative number\n    break num if num < 0\n\
    \    sum_num = 0\n    until num >= 10\n      sum += num % 10\n      num = (num\
    \ / 10).floor\n    end\n    next if sum_num == 0\n    sum += i\n    sum += sum_num\n\
    \    break sum if sum < 0\n  end\n  nil\nend", "    count=0\n    i=0\n    while\
    \ i<=arr.length\n        if arr[i] > 9\n            count += arr[i].to_i.nonzero?\
    \ -1\n        else\n            count += 1\n        end\n        i+=1\n    end\n\
    \    count\nend", "  arr.each do |n|\n    begin\n      digits = n.to_s.split(//).map\
    \ { |i| i.to_i }\n      digits = digits[0..-1] if n<0\n      digits.inject(0)\
    \ {|r, i| r + i }\n    rescue\n      puts \"The number #{n} is not an integer.\"\
    \n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    arr.each\
    \ do |i|\n        if i > 0 && i.is_a?(Integer) && i.to_i >= 0 \n            sum\
    \ += i.to_i\n        end\n    end\n    return sum\nend", "    arr.map! { |e| e.abs}\
    \ if arr.is_a? Array\n    arr = arr.sort.reverse\n    arr.map! { |e| e % 10 }\n\
    \    arr.reject! {|e| e < 0}\n    arr.each_index.with_object(Hash.new(0) { |i,h|\
    \ h[i] = 0 }) do |i, h|\n        h[i] += arr[i] if arr[i].nonzero?\n    end\n\
    \    arr\nend\n</code>\nTest cases:\n<code>\ncount_nums([-123, -123, 123, 123])",
  "  sum = 0\n  arr.each do |n|\n    sum += n\n  end\n  sum > 0 ? sum : (-sum)\nend",
  "  return arr.select { |x| x > 0 }.count\nend\n</code>\nNow all you need is to test\
    \ this out on your dataset.\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nHi Michael,\
    \ thank you so much for taking the time to write this out for me. I'm unclear\
    \ on how your code is different than mine. Could you explain how mine is different\
    \ and how mine is different from yours?\n<|/ c |>\n<| c |>\nAlso, what is the\
    \ significance of the \"*\" after the conditions? I'm wondering why this is necessary\
    \ for the code to work. Thanks again!\n<|/ c |>\n<| c |>\n- I updated my answer\
    \ to include an explanation of my code. The `*` signifies that it's a multi-line\
    \ `if` statement which takes advantage of the fact that Ruby supports multi-line\
    \ expressions. It's useful in the case when you have long `if` conditions that\
    \ you want to neatly spread across multiple lines.\n<|/ c |>\n<| c |>\nThank you\
    \ Michael! I appreciate it!\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  arr.inject(0)\
    \ {|count, n| return count + n if n < 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ would be my way of doing it. +1\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>",
  "  n = 0\n  for i in arr\n    if i.to_i > 9\n      n += 1\n      continue\n    digit\
    \ = i.to_i\n    # Skip numbers which has negative digit\n    if digit < 0\n  \
    \    digit = digit.to_i\n      n -= 1\n      # Only count negative numbers\n \
    \     if digit < 0\n        n += 1\n        continue\n    end\n    # Skip numbers\
    \ which has zero\n    if digit == 0\n      n += 1\n      continue\n  end\n  n\n\
    end", "  arr.each do |num|\n    digits = num.to_s.split('').map(&:to_i)\n    digits.each\
    \ do |d|\n      d > 0 ? d : d = -d * -1\n    end\n    return digits.count(d >\
    \ 0)\n  end\nend", "  count = 0\n  arr.each do |el|\n    el >= 0 ?\n      el +=\
    \ el / 10 :\n      el -= el / 10\n    el > 0 && count += el\n  end\n  count\n\
    end", "  arr.each do |i|\n    if i < 0\n      i -= i % 10\n    end\n    arr.each\
    \ do |j|\n      j -= i % 10\n      break if j == -1\n    end\n    break if i <\
    \ 0\n    arr -= i\n  end\n  return arr.size\nend", "  arr.inject(0) { |sum, digit|\
    \ sum + digit if digit >= 0 }\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>",
  "  arr.inject(0) do |n, i|\n    # n is now the sum value of the array of digits\n\
    \    n += (i / 10)**2 if i > 0\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays\
    \ |>\n<| c |>\nI really like your solution. It is a lot more efficient than mine.\n\
    <|/ c |>\n<| c |>\nI really don't know why, but I am getting different results\
    \ for the code you provided. It's almost the same, but one time I'm getting \"\
    -1\", the other I'm getting \"1\". It seems that when I have \"-1\" in the array,\
    \ I get -1. I just don't know why.\n<|/ c |>\n<| c |>\nI suspect `-1` is the result\
    \ of `-1**(-1)`. It's quite unlikely, but it's possible that `-1**(-1)` returns\
    \ `-1`. You could try changing `n += i` to `n += i if i >= 0`\n<|/ c |>\n<| a\
    \ dscore=0 |>\nYou might want to look into the enumerable methods map, inject,\
    \ and filter.\n<code>", "  arr.each do |x|\n    if (x > 0).zero?\n      puts \"\
    #{x}\"\n      puts \"#{x}'s digit sum #{sum_of_digits(x)}\"\n      puts \"#{x}'s\
    \ number of negative digits: #{number_of_negative_digits(x)}\"\n    end\n  end\n\
    end", "  arr.each do |n|\n    if n < 0\n      n = n[0].abs * (-1)\n    else\n\
    \      n = n[0].abs * 0\n    end\n  end\n  arr.size\nend", "    # Write your implementation\
    \ here.\n    return arr.count(&:positive?)\nend", "  arr.each do |num|\n    if\
    \ num > 0\n      digits = num.to_s.split(//)\n      sum = digits.inject(0){|sum,\
    \ digit| sum + digit.to_i}\n      if sum > 0\n        p sum\n      end\n    end\n\
    \  end\nend\ncount_nums([-123, -123, 123])\ncount_nums([12345, -1234, 1234])\n\
    count_nums([12345, -1234, 12345])\ncount_nums([12345, -1234, 12345, -12345, -1234,\
    \ 1234])", "  arr.each_with_index do |n, i|\n    if n.is_a?(Fixnum)\n      sum\
    \ = 0\n      while n > 0\n        sum += n % 10\n        n /= 10\n      end\n\
    \      sum += i > 0 ? 1 : 0\n      arr[i] = sum\n    elsif n.is_a?(Bignum)\n \
    \     arr[i] = count_nums(n.digits)\n    else\n      arr[i] = count_nums(n.to_s.chars.map(&:to_i))\n\
    \    end\n  end\n  arr\nend\n</code>\nNow let's run our test:\n<code>\narr = count_nums(-31415926312345435).map(&:to_i)\n\
    \  #=> [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, 2, 8, 1, 9, 4, 6, 6, 6,\
    \ 4, 3, 5, 2, 1] \narr.each_cons(2).to_a\n  #=> [[-1, -1], [1, 1], [1, 1], [4,\
    \ 2], [4, 2], [2, 8], [8, 1], [9, 4], [6, 6], [6, 6], [4, 3], [5, 2], [5, 2]]\
    \ \narr.sum\n  #=> -14 \narr.map{|n| n < 0 ? n : n.abs}.sum\n  #=> -14 \narr.inject(0){|sum,i|\
    \ sum + i}\n  #=> -14 \n</code>\nExplanation\nWe begin by defining arr as follows:\n\
    <code>\narr = [-31415926312345435]\n  #=> [-31415926312345435] \n</code>\nThe\
    \ next line begins the loop:\n<code>\narr.each_with_index do |n, i|\n</code>\n\
    This computes the next value to be returned from the block given to each:\n<code>\n\
    \  n = -31415926312345435\n  i = 1\n</code>\nNext we test whether the value is\
    \ numeric:\n<code>\nif n.is_a?(Fixnum)\n</code>\nThe value -31415926312345435\
    \ is numeric, so we compute sum and assign it to arr[1]. Now we move on to the\
    \ next value in the array:\n<code>\n  n = -31415926312345435\n  i = 2\n</code>\n\
    Next we test whether the value is numeric:\n<code>\n  if n.is_a?(Fixnum)\n</code>\n\
    The value -31415926312345435 is numeric, so we compute sum and assign it to arr[2].\
    \ Now we move on to the next value in the array:\n<code>\n  n = -31415926312345435\n\
    \  i = 3\n</code>\nNext we test whether the value is numeric:\n<code>\n  if n.is_a?(Fixnum)\n\
    </code>\nThe value ", "  arr.inject(0, :+)\n  .select { |n,| n > 0 }\n  .select\
    \ { |n,| n % 10 > 0 }\n  .inject(0) do |acc, n| acc += 1 if n > 0 && n % 10 ==\
    \ 0 end\nend", "  arr.select { |e| e > 0 }.size\nend", "  arr.each do |n|\n  \
    \  if n < 0\n      n *= -1\n    elsif n.is_a?(Integer)\n      n.to_i\n    else\n\
    \      raise \"Not an integer: #{n}\"\n    end\n  end.inject(0) do |n, x|\n  \
    \  x % 10 + n if x > 0\n  end\nend\n</code>\nWith that in place, I now see that\
    \ it is trivial to get the sum of the digits of any positive number:\n<code>\n\
    count_nums(-123)\n  #=> 3 # -> 1 + 2 + 3\ncount_nums(123)\n  #=> 5 # -> 1 + 2\
    \ + 3 + 4\n</code>\nThe only remaining question is what to do if the number is\
    \ negative. Let's take a look at an example. Consider -128.\n<code>\nn = -128\n\
    \  #=> -128 \nif n < 0\n  n *= -1\nelse\n  n.is_a?(Integer)\nend\n  #=> true",
  "  if arr.empty?\n    0 \n  elsif arr.is_a?(Range)\n    count_nums(arr.first)\n\
    \  elsif arr.is_a?(Array)\n    arr.count(&:positive?)\n  else\n    arr\n  end\n\
    end", "  arr.count{ |n| n >= 0 }\nend", "    count = 0\n    sign = 1\n    arr.each\
    \ do |i|\n        if i < 0\n            sign = -sign\n            i = -i\n   \
    \     end\n        if i == 0\n            count = count + 1\n        else\n  \
    \          temp = i\n            count = 0\n            while temp != 0\n    \
    \            temp = temp / 10\n                count = count + 1\n           \
    \ end\n        end\n    end\n    return count * sign\nend\nprint count_nums([-1,\
    \ -12, -34, -15, -7, -9])\n</code>\n<|/ a |>\n<| a tags=algorithm,ruby,arrays\
    \ |>\nI saw this in a problem set and I thought it might be a fun challenge. Here's\
    \ the solution I came up with:\n<code>", "  arr.select {|x| x > 0 }.size\nend",
  "  arr.select{|x| x >= 0 }.count(arr.first)\nend\n</code>\n<|/ a |>\n<| c |>\nWhat\
    \ if `arr = [-1, -2, -3]`?\n<|/ c |>\n<| c |>\nMy bad, I have updated my answer.\
    \ The `count_nums` function doesn't take negative numbers into account, and it\
    \ only counts the first positive number. The updated version should take care\
    \ of that.\n<|/ c |>\n<| c |>\nYou don't need `select`: `arr.count(arr.first)`.\n\
    <|/ c |>\n<| a tags=ruby |>\nThis is probably the simplest (and therefore fastest)\
    \ solution:\n<code>", "  arr.inject(0) do |m, i|\n    m += i.to_s.chars.map(&:to_i).reduce(:+)\
    \ + 1 if i > 0 ? i : -i.abs\n    m += 1 if i > 0 ? i : 0\n  end\nend", "  if arr\
    \ < 0\n    return -count_nums(arr.abs)\n  arr.map! { |n| n if n.to_s.chars.map(&:to_i).sum\
    \ > 0 }\n  arr.length\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI wouldn't\
    \ call `to_i` a \"cheat\" - it's perfectly fine. I just think it's a lot more\
    \ readable (at least for Ruby coders) if you use `chars.map(&:to_i)` instead of\
    \ `chars.map(&:to_s).to_i`.\n<|/ c |>\n<| c |>\nFair enough. Although I'm a little\
    \ surprised at how you end up with `\"1\"` being added to an array containing\
    \ `\"0\"`, which would make that array a digit of 2. And `\"9\"` being added to\
    \ an array containing `\"0\"`, which would make that array a digit of 3. How did\
    \ you handle that in your code?\n<|/ c |>\n<| c |>\nThe code is very concise,\
    \ compact, and easy to understand. I've been trying to figure out a way to add\
    \ up the digits, as to find the number of positive integers without using `to_i`.\n\
    <|/ c |>\n<| c |>\n: What I do to avoid `to_i` is `chars.map(&:to_i).reduce(:+)`.\
    \ The `:+` will implicitly convert strings to numbers, and then do the summing\
    \ operation. If you're unfamiliar with implicit conversions, I suggest reading\
    \ http://stackoverflow.com/questions/5043926/ruby-is-there-a-way-to-turn-a-string-into-an-integer-without-using-a-method\n\
    <|/ c |>\n<| a |>\n<code>", "  if arr.inject(0) do |sum, number|\n    sum += number\
    \ if number > 0; sum\n  end\nend", "  arr.each { |e| e < 0 ? e = -e: e }\n  arr.count{\
    \ |e| e > 0 }\nend\n</code>\n<code>\nputs count_nums([\"1\", \"2\", \"-1\", \"\
    5\", \"-3\"])", "  arr.sort.reverse\n  arr.each do |n|\n    return n if n.modulo(10)\
    \ == 0 && n.to_s.size > 0\n  end\n  0\nend", "  arr.map do |n|\n    if n < 0 then\n\
    \      n = n * -1\n      digit = n.abs\n      n -= digit\n    end\n    if n <\
    \ 10 then n else 0 end\n  end\n  .inject(0) {|sum, n| sum + n }\nend", "  arr.map\
    \ { |e| e.to_i }\n    .select { |e| e > 0 }\n    .count { |e| e.nonzero? }\nend",
  "  arr.inject(0) do |sum, digit|\n    sum + digit if digit > 0\n  end\nend", " \
    \ count = arr.count\n  arr.map {|n| n < 0 ? n.to_i.first : n}.each_with_index.inject(0)\
    \ do |sum, i|\n    sum += (i % 2 == 0) ? (i - 1) : i\n  end\nend\n</code>\nRunning\
    \ this function will yield this output:\n<code>\n[ -1, -2, 3, 5, 7, 9, 10, 12]\n\
    \ => 15\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThat won't solve the problem of\
    \ negative numbers. Negative numbers are positive numbers, just with a sign inverted.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,arrays,algorithm |>\n<code>", "  count = 0\n\
    \  arr.each do |n|\n    count = count + 1 if n % 10 > 0\n    count = count + 1\
    \ if n < 0\n  end\n  count\nend", "  count = 0\n  arr.each { |n| count += n.abs**2\
    \ }\n  count - arr.size unless arr.empty?\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThanks for the answer. It seems that there are cases for which\
    \ the code does not give the right answer. For example:", "  arr.inject(0) do\
    \ |sum, el|\n    sum += el if el.is_a?(Integer)\n    sum\n  end\nend", "  # your\
    \ code here\n  count = arr.select { |i| i.to_i.positive? }.size\n  if count >\
    \ 0\n    return count\n  elsif count < 0\n    return -arr.find { |i| i.to_i.negative?\
    \ }.to_s.size\n  end\n  return 0\nend", "  # TODO: Write the count_nums function\n\
    end", "  digits = arr.each_with_object(Hash.new(0)) { |n, h| h[n.to_s.chars.first]\
    \ += 1 }\n  digits.select { |k, v| v > 0 }.count\nend", "  sum = 0\n  arr.each\
    \ do |x|\n    if x.is_a?(Integer)\n      sum = sum + x\n    end\n  end\n  if sum\
    \ < 0\n    sum -= arr.first\n    arr.shift\n  end\n  return sum\nend\np count_nums([1,\
    \ 2, 3, -2])", "    arr.each_index do |i|\n        if arr[i] < 0\n           \
    \ if arr[i].negative?\n                arr[i] = arr[i].abs\n            end\n\
    \        end\n    end\n    arr.count { |e| e > 0 }\nend", "  count = 0\n  arr.each\
    \ do |i|\n    i.to_i.times do |j|\n      count += 1\n      break if count > 100\n\
    \    end\n    break if count > 100\n  end\n  count\nend", "  count = 0\n  arr.each\
    \ do |n|\n    if n % 10 == 0\n      count += 1\n    end\n  end\n  count\nend\n\
    puts count_nums(arr2)\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThe answer is correct\
    \ but there is one mistake in your code. You can not use arr2.each do |n| because\
    \ the array does not contain the numbers but rather a range of numbers starting\
    \ from arr2[0] to arr2[40]. so try changing it to arr2.each_with_index do |n,\
    \ i| and use i to get desired result.\n<|/ a tags=ruby,algorithm dscore=0 |>\n\
    <| c |>\nWhile this may be a correct answer, it would be great if you could add\
    \ some explanation.\n<|/ c |>\n<| c |>\nI tried to explain my code so that I can\
    \ explain my mistake. Hope you understand now. Thanks for your suggestion.\n<|/\
    \ c |>\n<| a |>\nI assume by \"first signed digit\", you mean the smallest negative\
    \ number, i.e. the largest negative number that does not have a first negative\
    \ digit.\n<code>", "  arr.each do |num|\n    num = num.to_i\n    if num > 0\n\
    \      p num if num % 10 > 0\n    end\n  end\nend", "  arr.inject(0) { |sum, num|\
    \ sum + num if num.to_i >= 0 }\nend", "    count = 0\n    arr.each do |n|\n  \
    \      if n % 10 == 0 then\n            count += 1\n        end\n    end\n   \
    \ return count\nend", "  arr.select {|x| x.positive?}.size\nend\n</code>\n<|/\
    \ a dscore=1 tags=arrays,ruby |>\n<| a dscore=1 |>\nI guess the code should be\
    \ like this:\n<code>", "  arr.select { |x| x > 0 }.size\nend\n</code>\n(I used\
    \ select to filter out any negative numbers, but you could also use a ternary\
    \ operator.)\nNow we test it against your code:\n<code>\narr = [-4, -2, -1, 1,\
    \ 2, 3, 4, 5]\nputs \"The number of positive integers with digits that add up\
    \ to digits > 0 is: #{count_nums(arr)}\\n\"\n</code>\nOutput:\n<code>\nThe number\
    \ of positive integers with digits that add up to digits > 0 is: 1\n</code>\n\
    Which is correct.", "  # Your code here\n  arr.group_by { |x| x/10 }.count\nend",
  "    count = 0\n    if arr[0] > 0\n        count = arr.select { |x| x > 0 }.size\n\
    \    end\n    if count > 0\n        count\n    else\n        -1\n    end\nend",
  "    count=0\n    nums=[]\n    nums=arr.map { |x| x.abs} # To get the absolute value\
    \ of a number\n    nums.each do |x|\n        if x.to_i.positive? # Check if x\
    \ is positive\n            count+=1 # Add one to the count of numbers with a sum\
    \ > 0\n        elsif x > 0 # Check if number is negative\n            count-=1\
    \ # Add one to the count of numbers with a sum == 0\n        end\n    end\n  \
    \  return count\nend\n</code>\nTest Cases:\n<code>\nputs count_nums([-12, -33,\
    \ -46, -9]) # => 2\nputs count_nums([-3, -6, -8, -10, -11, -20, -30, -33, -36,\
    \ -39, -44, -48, -61]) # => 1\nputs count_nums([-2, -1]) # => 0\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\n<code>", "  count = 0\n  arr.each do |x|\n    next if\
    \ x.zero? || x.is_negative?\n    digits = x.to_s.split('')\n    digits.each do\
    \ |d|\n      next if d.empty?\n      count += 1 if d.to_i >= 0\n    end\n  end\n\
    \  count\nend", "  return arr.count { |x| x.to_s.split('').count { |y| y > 0 }\
    \ }\nend", "    count = 0\n    arr.each do |x|\n        if x > 0 && x.to_s.split('').sum\
    \ > 0\n            count += 1\n        end\n    end\n    count\nend", "  arr.select\
    \ do |num|\n    num.to_s.chars.select {|c| c >= '0' && c <= '9'}.empty?\n  end.length\n\
    end", "  arr.each_with_index do |num, index|\n    num.positive? ? num.abs! : num.negative!\n\
    \    num.digits(2).each do |digit|\n      index.zero? ? break unless digit > 0\
    \ : return false\n      index -= 1\n    end\n  end\n  true\nend", "    count =\
    \ 0\n    arr.each { |e| e > 0 && count += 1 }\n    count\nend", "  arr.each do\
    \ |n|\n    return n if n < 0\n    i = n.to_s\n    digit = i.delete('-').to_i\n\
    \    return 0 if digit < 10\n    return 1 if digit == 10\n    digits = i.digits.count\
    \ { |i| i > 0 }\n    return digits if digits > 0\n  end\n  0\nend\n</code>\nLet's\
    \ run these two methods against each other and compare the results:\n<code>\n\
    count_nums([1, 2, -3, 5])", "    arr.map!(&:to_i).select {|i| i > 0 }.inject(0)\
    \ { |sum, num| sum + num }\nend", "  arr.each_with_index.inject(0) do |total,\
    \ el| \n    el > 0 ? total + 1 : total\n  end\nend", "  arr.select{|n| n >= 0}.reduce(0)\
    \ do |sum, number|\n    sum += number * (number > 0 ? 1 : -1) * 10\n  end\nend",
  "    arr.each_with_index.map { |n, idx| idx if n < 0 }.count\nend\n</code>\nLet's\
    \ see how this works. We create an enumerator by invoking each_with_index:\n<code>\n\
    [1,2,3].each_with_index", "  arr.each do |e|\n    if (e >= 0)\n      e %= 10 #\
    \ first digit\n    end\n    if (e == 0) # no more digits\n      break\n    end\n\
    \  end\n  return arr.reduce(:+) - 1 # count all except last digits\nend", "  return\
    \ arr.select { |n| n > 0 }.count\nend", "  count = 0\n  \n  arr.each do |n|\n\
    \    \n    if n < 0\n      \n      sign = n.to_s.first(1).to_i\n      \n     \
    \ if sign > 0\n        n.to_s.first(sign.to_i).to_i\n      elsif sign < 0\n  \
    \      sign * -1\n      else\n        sign\n      end\n    else\n      count +=\
    \ n / 10.0\n    end\n  end\n  \n  count\nend", "  arr.each do |num|\n    num =\
    \ num.to_i\n    if num.positive? && num.positive?\n      num = num.abs\n    end\n\
    \    if num > 0\n      nums.count{ |x| x > num }\n    elsif num < 0\n      nums.count{\
    \ |x| x < num }\n    end\n  end\nend", "  arr.select {|i| i > 0 }.count\nend",
  "  arr.each do |e|\n    if e < 0\n      e *= -1\n    end\n    count_num(e) == 0\n\
    \  end\nend", "  arr.each do |num|\n    if num < 0\n      negatives = num / 10\n\
    \      num -= negatives * 10\n    end\n    sum_of_digits = num.abs\n    if sum_of_digits\
    \ > 9\n      sum_of_digits -= 10\n    end\n    sum += sum_of_digits\n  end\nend",
  "  arr.map {|n| n % 10 }.count(0).to_f\nend\n</code>\nNow let's use your count_nums\
    \ function with a test case:\n<code>\nputs count_nums([1, -12345, 123456, -67890,\
    \ -999])", "  count = 0\n  arr.each do |n|\n    count += 1\n    # Check if first\
    \ digit is negative\n    sign = -(n[0].to_i < 0 ? n[0].to_i : 0)\n    n += sign\n\
    \  end\n  count\nend", "  arr.each do |num|\n    digits = []\n    while(num >\
    \ 0) do\n      digit = num % 10\n      digits.unshift(digit)\n      num = num\
    \ / 10\n    end\n    digits = digits.reverse\n    digits.each do |digit|\n   \
    \   if(digit > 0)\n        return true\n      end\n    end\n  end\n  false\nend",
  "  return arr.select {|n| n >= 0 && !n.zero?}.size\nend", "  count = 0\n  arr.each\
    \ { |n| n -= n.abs; n.zero? && count += 1 }\n  count\nend", "  arr.each_with_index\
    \ do |n, i|\n    # Move on to the next number if the sum has already been counted.\n\
    \    if @counted[i] == true\n      next\n    end", "  count = 0\n  arr.each do\
    \ |n|\n    if n.is_a?(Integer) then\n      if n < 0 then\n        n = -n.to_i\n\
    \      else\n        n = n.to_i\n      end\n    end\n    n += 1 if n % 10 > 0\n\
    \    count += 1\n  end\n  count\nend\n</code>\nA more efficient version would\
    \ use each_cons which returns a sub-array as you iterate through the array. Unfortunately\
    \ this isn't supported yet in ruby 1.8.7 and 1.9.2. We could use an up-to-date\
    \ version of ruby by installing ruby 2.0.0p195 (I used ruby 1.9.2 with RVM to\
    \ install it). Alternatively we could write our own version of each_cons which\
    \ does work with 1.8.7 and 1.9.2.\n<|/ a |>\n<| c |>\nYes, I missed that in the\
    \ question, but I thought the OP would already be aware of that. I've updated\
    \ my answer to reflect that.\n<|/ c |>\n<| c |>\nI was aware of the \"each_cons\"\
    \ functionality but I was looking for a solution that doesn't require the ruby\
    \ 2.0 support.  This is an excellent solution for the ruby 1.8.7 problem though.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>\n def countDigits(i)\n   (i/(10**8)).to_i\n\
    \ end", "  nums.each { |num| arr[@num].each { |x| @total += x } if @total > 0\
    \ }\n  case nums.first\n  when 0\n    @total\n  when -nums.first\n    (-nums.first\
    \ + @total)\n  else\n    -1\n  end\nend", "  arr.select do |e|\n    # e > 0 because\
    \ e is an integer and no integer has negative values\n    e > 0 && e.to_s.chars.map(&:to_i).sum\
    \ & e > 0\n  end.length\nend", "  arr.each do |num|\n    return num if num.positive?\n\
    \  end\n  nil\nend", "  if arr.nil? || arr.empty?\n    return 0\n  else\n    arr\
    \ = arr.map {|x| x.to_i}\n    arr.delete_if {|x| x.negative?}\n    arr.delete_if\
    \ {|x| x == 0}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n\
    \    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if\
    \ {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n\
    \    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if\
    \ {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n\
    \    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if\
    \ {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n\
    \    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if\
    \ {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n\
    \    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if\
    \ {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n\
    \    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if\
    \ {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n\
    \    arr.delete_if {|x| x.zero?}\n    arr.delete_if {|x| x.zero?}\n    arr.delete_if\
    \ {|x| x.zero?}\n    arr.delete_if {", "    count = 0\n    for num in arr\n  \
    \      count += count_nums(num.digits.to_a)\n        if num < 0\n            count\
    \ -= 1\n    end\nend", "  count = 0\n  arr.each do |x|\n    if x.is_a?(Integer)\n\
    \      count += 1\n    end\n  end\n  count\nend", "  return arr.count { |x| x\
    \ > 0 }\nend", "  num = 0\n  arr.each do |e|\n    if e > 0 then\n      num = num\
    \ + 1\n    end\n  end\n  num\nend", "  arr.select { |i| i > 0 }.count\nend", " \
    \ count = arr.count{|x| x > 0}\n  if arr.count(0) == count\n    return 0\n  else\n\
    \    arr.count {|x| x > 0 ? x.abs%10 <= 4 : x > 0 ? x.abs%10 <= 0 : x.abs%10 <=\
    \ 9}\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby,algorithm,arrays |>\n<| c\
    \ |>\nThe algorithm is very similar to that of the accepted solution, except that\
    \ the number of digits required is slightly different (to 4 instead of 2). Also\
    \ it is slightly more complicated than the accepted answer (which does not count\
    \ the number at all if there are no integers with a sum > 0). Also the accepted\
    \ solution does not count negative numbers.\n<|/ c |>\n<| c |>\nThe accepted solution\
    \ counts all negative numbers also it counts all numbers with zero sum (including\
    \ negative numbers)\n<|/ c |>\n<| a dscore=0 |>\nHere is a simple algorithm that\
    \ is based on a previous answer. This assumes the input array is non-empty.\n\
    <code>", "  count = 0\n  for num in arr\n    count += (num.to_s.split(//).select\
    \ { |d| d > 0 }.count - 1)\n  end\n  count\nend", "  arr.select { |num| num >\
    \ 0 }.count\nend", "  arr.select {|n| n % 10 > 0}.length\nend\n</code>\nNow we\
    \ can use that with your array:\n<code>\ncount_nums(numbers) #=> 2\n</code>\n\
    Using Array#select\nThis is another common Ruby idiom which is very often useful\
    \ when you're trying to perform an action on all elements of an array.\nFor example,\
    \ to extract all but the first element of an array, you could do this:\n<code>\n\
    numbers[1..-1] #=> [1, -1, 2, -2, 2, 3, -3]\n</code>\nThe reason we do numbers[1..-1]\
    \ is because we don't want to get the first element of the array, because that\
    \ is the first element of our desired result.\nIf we do numbers[0..-1] we still\
    \ get the first element, but we then skip the first element of the array, which\
    \ we don't want. By using numbers[1..-1] we get every element except the first\
    \ one (as opposed to [1..-1] which gives us all elements of the array except the\
    \ first one).\nThe same is true of Array#map:\n<code>\nnumbers[1..-1].map { |n|\
    \ n * 2 } #=> [-3, -6, -9, -12, ...]\n</code>\nFinally, let's see what we can\
    \ do using Array#select:\n<code>\nnumbers[1..-1].select { |n| n % 10 > 0 } #=>\
    \ [1, -1, 2, -2]\n</code>\nHere we return every element of the array which satisfies\
    \ the condition (n % 10 > 0).\nNow we know that there are two elements which satisfy\
    \ this condition, namely 2 and -3. Thus, we can use Array#length to get the number\
    \ of elements which satisfy the condition.\n<code>\nnumbers[1..-1].select { |n|\
    \ n % 10 > 0 }.length #=> 2\n</code>\nWe can see that our code works with integers\
    \ or other types of objects (such as strings or dates).\nAnother common idiom\n\
    We can also write code like this:\n<code>\nnumbers.select { |n| n % 10 > 0 }\n\
    </code>\nWe can think of this as saying \"give me all the elements of the array\
    \ which satisfy the condition (n % 10 > 0).\"\n<|/ a tags=ruby dscore=5 |>\n<|\
    \ a |>\nTo find how many numbers have the sum of digits greater than zero, here's\
    \ a concise way by using Enumerable#count:\n<code>", "  count = 0\n  arr.each\
    \ do |num|\n    if num > 0\n      sum += num\n      count += 1\n    end\n  end\n\
    \  return count\nend", "  arr.each do |num|\n    num = num.to_i\n    return num\
    \ if num > 0\n    num -= num % 10\n  end\n  0\nend", "    cnt = 0\n    arr.each\
    \ do |x|\n        cnt += 1 if x > 0 && !x.is_a?(Bignum)\n    end\n    cnt\nend",
  "  arr.each do |el|\n    el if el > 0\n    el -= el % 10\n    el\n  end\nend\ncount_nums([1,\
    \ -2, 3])", "  count = arr.count{|x| x >= 0}\n  nums = arr.select{|x| x >= 0}\n\
    \  nums.map{|x| x >= 0 ? x + 1 : -x}.select{|x| x >= 0}.length\nend\n</code>\n\
    The final piece of the puzzle is figuring out the smallest number which is divisible\
    \ by every number in the array.  In other words, which number is closest to the\
    \ number divisible by all the numbers in the array?  The trick is to use .min.\n\
    <code>", "  counter = 0\n  for num in arr\n    if num > 0\n      counter += 1\n\
    \    end\n  end\n  counter\nend\n</code>\nThe last part of the problem is straightforward\
    \ - we only have to add each digit to a sum:\n<code>", "  arr.inject(0) { |sum,\
    \ n| sum += if n < 0 \n    n.to_s.rindex(\"-\", 1) + 1\n  else\n    n.to_s.length\n\
    \  end}\nend\n</code>\n<|/ a |>\n<| c |>\n+1 This looks much better than my attempt.\
    \ I'm very new to ruby, so this will be very helpful. I'm still learning `inject`,\
    \ so this looks like a great way to learn. I will try to apply this in future\
    \ assignments, too.\n<|/ c |>\n<| c |>\nI wonder how many people would learn from\
    \ your solution if you used `each_with_object` instead?\n<|/ c |>\n<| c |>\n,\
    \ this is Ruby 101 stuff. `inject` will return the object the method was called\
    \ on. `each_with_object` is used to take an object and apply a method onto it\
    \ for each element (so `map` doesn't work here). It's not necessarily a bad idea\
    \ to learn it because it can save you a lot of headache down the road.\n<|/ c\
    \ |>\n<| c |>\nYeah, I just started learning Ruby recently, so I'm still learning\
    \ everything in depth. I wanted to learn the basics before diving into advanced\
    \ topics, like recursion (which I assume is what is happening with `inject`).\
    \ I'll read up on `each_with_object`, though. Thanks again!\n<|/ c |>\n<| a |>\n\
    Here's my stab at it:\n<code>", "  n = arr.length\n  (0...n).select { |i|\n  \
    \  arr[i].positive? && arr[i].sum > 0\n  }.length\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=1 |>\n<| a tags=ruby,arrays |>\nHere's one possible solution:\n<code>",
  "  # arr is the array of integers we want to get the count of\n  \n  # initialize\
    \ sum with first element of arr\n  sum = arr.first\n  \n  # Loop over remaining\
    \ elements of arr\n  arr.drop(1).each do |number|\n    # Check if current number\
    \ is positive\n    if number > 0\n      # If it is positive, add it to sum\n \
    \     sum += number\n    end\n  end\n  \n  # Return sum\n  return sum\nend\n</cell>\n\
    <cell>", "  arr.each_with_index do |n, i|\n    n.to_i.times { |j| sum += (arr[j].to_i\
    \ % 10).abs; }\n    if (n < 0) \n      sum -= (sum % 10).abs;\n    elsif (sum\
    \ == 0)\n      sum = 1;\n    end\n    sum += arr[i].to_i.abs;\n  end\nend", " \
    \ n = arr.size\n  count = 0\n  \n  while n != 0 do\n    count += n / 2\n    n\
    \ /= 2\n  end\n  return count\nend", "  arr.compact.map { |x| x if x > 0 }.inject(:+).to_i\n\
    end\nputs count_nums([10, -12, 12, 3])", "    count = 0\n    arr.each do |num|\n\
    \        if num > 0\n            count += num\n        end\n    end\n    count\n\
    end\n</code>\nLet's test our new function on the sample array we have:\n<code>\n\
    arr = [-12, 23, -453, -7, -43, -123]\nputs count_nums(arr)", "  # Initialize count\
    \ to 0.\n  count = 0\n  # Iterate over each element in arr.\n  arr.each do |e|\n\
    \    # If the element is negative then get the first digit.\n    if e < 0\n  \
    \    # If the first digit is < 0, then add it to count.\n      count += (e<0)\n\
    \    else\n      # Otherwise, multiply the current digit by 10.\n      count +=\
    \ e*10\n    end\n  end\n  # Return the count.\n  return count\nend\nputs count_nums([-123,\
    \ -4563, -891])\nputs count_nums([0, -0, -0])\nputs count_nums([-1, 0, -0])\n\
    puts count_nums([0, -1, 0])\nputs count_nums([-1, 1, 2])\nputs count_nums([1,\
    \ 1, 3])\nputs count_nums([1, 2, 3])\nputs count_nums([123, 4567, 12])\nputs count_nums([123,\
    \ 4567, 123, -4567, -2345, -4567])\nputs count_nums([1, 1, 1, 2, 2, 2, 1])\nputs\
    \ count_nums([-1, 0, 1, 2, 1, 3, -2])\nputs count_nums([-2, -1, -3])\nputs count_nums([1,\
    \ 2, 3, -2])\nputs count_nums([-2, -3, 1, 3, -2, 0])\nputs count_nums([1, 2, -3,\
    \ -1, -2])\nputs count_nums([-1, -2, 1, 2, 3])\nputs count_nums([1, 2, 3, 2, -1,\
    \ -4, -5, -2, -1, -2, 3])\nputs count_nums([-1, -3, 1, 2, 3, -2, -4, -5, -4, -2,\
    \ -1, -2, -3, -4, -5, -1, -3, 1, 2, 3, -2, -4, -5, -4, -2, -1, -2, -3, -4, -5,\
    \ -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3,\
    \ -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1,\
    \ -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4,\
    \ -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4,\
    \ -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2,\
    \ -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, -2,\
    \ -1, -2, -3, -4, -5, -4, -2, -1, -2, -3, -4, -5, -4, ", "  count = 0\n  arr.each\
    \ do |num|\n    num.digits.each do |digit|\n      next if digit < 0\n      count\
    \ += 1 \n    end\n  end\n  count\nend", "  count = 0\n  arr.each do |i|\n    digit\
    \ = i.abs\n    if digit > 0\n      count += digit % 10\n    else\n      i = (i\
    \ / 10) * -1 + digit\n    end\n  end\n  count\nend\n</code>\ncount_nums([-12,\
    \ 3, -5, 2, 3]) #=> 5\ncount_nums([-12, 3, -5, 2, 3]) #=> 2\ncount_nums([12, 3,\
    \ -5, 2, 3]) #=> 1\ncount_nums([12, 3, -5, 2]) #=> 2\ncount_nums([12, 3, 5]) #=>\
    \ 2\ncount_nums([12, 3]) #=> 3\ncount_nums([12]) #=> 1\ncount_nums([]) #=> 0\n\
    count_nums(nil) #=> 0\ncount_nums(1) #=> 1\ncount_nums(0) #=> 0\ncount_nums(0.1)\
    \ #=> 0\ncount_nums(-1.1) #=> -1\ncount_nums(-1.25) #=> -1\ncount_nums(-3) #=>\
    \ 0\ncount_nums(-34) #=> 1\ncount_nums(1234) #=> 2\ncount_nums(-123) #=> 3\ncount_nums(-123.1)\
    \ #=> 3\ncount_nums(0.1e1) #=> 1\ncount_nums(-0.1e1) #=> -1\ncount_nums(0.1e-3)\
    \ #=> 1\ncount_nums(-0.1e-3) #=> -1\ncount_nums(0.1e-7) #=> 0\ncount_nums(-0.1e-7)\
    \ #=> 0\ncount_nums(0.1e-9) #=> 0\ncount_nums(-0.1e-9) #=> 0\ncount_nums(0.1)\
    \ #=> 1\ncount_nums(-0.1) #=> -1\ncount_nums(1) #=> 1\ncount_nums(0.1) #=> 1\n\
    count_nums(-0.1) #=> -1\ncount_nums(1) #=> 1\ncount_nums(-1) #=> -1\ncount_nums(0)\
    \ #=> 0\ncount_nums(-0.1) #=> -1\ncount_nums(1) #=> 1\ncount_nums(0.1) #=> 1\n\
    count_nums(-0.1) #=> -1\ncount_nums(1) #=> 1\ncount_nums(-1) #=> -1\ncount_nums(0)\
    \ #=> 0\ncount_nums(-0.1) #=> -1\ncount_nums(1) #=> 1\ncount_nums(-1) #=> -1\n\
    count_nums(1) #=> 1\ncount_nums(-1) #=> -1\ncount_nums(0) #=> 0\ncount_nums(-0.1)\
    \ #=> -1\ncount_nums(1) #=> 1\ncount_nums(-1", "  return arr.select { |x| x.to_i\
    \ >= 0 }.count\nend", "  arr.map do |n|\n    n % 10\n  end.reduce(:+)\nend\n</cell>\n\
    <cell>\narr = [-5, 6, 12, 10, 2, -2]\ncount_nums(arr)\n</cell>\n<text>\nExercise:\
    \ Implement a function that takes an integer n and returns\nthe sum of the digits\
    \ of n.", "    arr.select{|x| x > 0}.length\nend", "  arr.each do |n|\n    return\
    \ 0 if n == 0\n    return 1 if (n % 100 < 10 and n % 100 > 0) or\n           \
    \     (n % 100 >= 10 and n % 100 < 20)\n    return 0 if n < 0 and n % 100 >= 20\n\
    \  end\n  return 0\nend", "    count = 0\n    arr.each do |x|\n        if x >=\
    \ 0\n            count += 1 if x == sum(x)\n        else\n            count +=\
    \ 1 if x == -sum(-x)\n        end\n    end\n    return count\nend", "  arr.reduce(:+)\n\
    end", "    count = 0\n    arr.each do |num|\n      count += 1 if num > 0 \n  \
    \  end\n    return count\nend", "  # Your code goes here\nend", "  count=0\n \
    \ for i in arr\n    if i < 0\n      i += 9\n    sum += i % 10\n    if sum >= 10\n\
    \      count += 1\n      sum -= 10\n    end\n  end\n  count\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a |>\n<code>", "  arr.each do |i|\n    return 0 if i > 9\n\
    \    return i if i == 0\n    return 0 if i > 0 && (i / 10) == (i / 10)\n    return\
    \ 1 if i > 9 && (i / 10) != (i / 10)\n  end\n  0\nend", "  result = 0\n  arr.each\
    \ do |x|\n    result += (x / 10).to_i\n  end\n  return result\nend", "  count\
    \ = 0\n  arr.each do |i|\n    next if i.negative?\n    count = 0 if i.zero?\n\
    \    count += 1 if i.digits.sum { |j| j > 0 }\n  end\n  count\nend", "    count\
    \ = 0\n    arr.each {|e| return e if e >= 0\n    count = count + 1 if e > 0\n\
    \    count = count + 1 if e < 0\n    return count\n    end\nend\n</code>\nNow\
    \ you have a function that calculates the number of positive and negative numbers\
    \ passed in:\n<code>\ncount_nums([1, 2, -1, -3, 2])\n=> 3\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nHi Amadan, I really appreciate the answer but I wanted to get an\
    \ explanation of your code. I would like to learn from it.\n<|/ c |>\n<| c |>\n\
    I added an explanation, hope it helps.\n<|/ c |>\n<| c |>\nGreat explanation of\
    \ what I was trying to explain. Thanks!\n<|/ c |>\n<| c |>\nAmadan, would this\
    \ be the correct way to use `each_with_index`? `arr.each_with_index.select { |e,i|\
    \ e >= 0 }`\n<|/ c |>\n<| c |>\nYes, that would work fine. Also note that you\
    \ can `return e` right before the `count+=...` line as well.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=1 |>\nI used the method below\n<code>", "  count = 0\n  arr.each { |n|\
    \ n >= 0 ? n : -n.to_i }.each { |n| count += 1 if n.digits.reduce(:+) > 0 }\n\
    \  count\nend", "  arr.each do |num|\n    if num < 0\n      num = -num\n    end\n\
    \    sum = 0\n    while num > 0\n      sum += num % 10\n      num /= 10\n    end\n\
    \    return sum if sum > 0\n  end\n  return 0\nend", "    count = 0\n    arr.each\
    \ {|e|\n       if e > 0 then count += 1\n    }\n    return count\nend", "  arr.each\
    \ do |x|\n    break if x == 0\n    break if x % 10 == 0\n    break if x % 10 <\
    \ 0\n    x += 10 if x % 10 > 0\n    counts[x] += 1\n  end\nend", "    arr.each_with_index\
    \ do |v, i|\n        if v.is_a? Integer\n            begin\n                sum\
    \ += v\n            end until sum >= 10\n        end\n    end\nend", "  arr.select\
    \ { |x| x > 0 }.length\nend", "  count = 0\n  arr.each do |x|\n    count = 0 if\
    \ x > 10\n    count += 1\n  end\n  count\nend", "  count = 0\n  arr.each do |x|\n\
    \    if x >= 0\n      count = count + 1\n    end\n  end\n  count\nend\ncount_nums([-1,\
    \ -2, -10, 1, 2, 5, 8, 13])", "    arr.inject(0) do |sum, num|\n        sum +=\
    \ num if num > 0\n        sum\n    end\nend", "  arr.sort.map {|i| i > 0 ? i :\
    \ -(i).abs} .count(&:nonzero?)\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nAgreed, I thought about using `.count` but I was thinking about\
    \ using `.select` to return only the positive numbers.\n<|/ c |>\n<| c |>\n`Array#select`\
    \ would return an array of true/false values, which is not what we want. The OP\
    \ wants to count the number of positive elements in the array, right?\n<|/ c |>\n\
    <| c |>\n: Yes, that's exactly what I was talking about.\n<|/ c |>\n<| c |>\n\
    Thanks for the solution! The code you provided in your edit works exactly as I\
    \ wanted it!\n<|/ c |>\n<| c |>\n: I added a solution that doesn't modify the\
    \ array in-place, which is more efficient, although I haven't benchmarked the\
    \ two solutions.\n<|/ c |>\n<| a dscore=0 |>\nIf you want the positive numbers\
    \ only, you can do this:\n<code>\nrequire 'set'", "  count = 0\n  arr.each do\
    \ |i|\n    if i.to_s.split('').select { |v| v > 0 }.size == i\n      count +=\
    \ 1\n    end\n  end\n  count\nend", "  sum = 0\n  arr.each do |n|\n    next if\
    \ n.to_i.negative?\n    sum += n\n  end\n  return 0 if sum == 0\n  return sum\
    \ if sum > 0\n  return -sum if sum.negative?\nend", "  arr.reduce(0){|sum, n|\
    \ sum+n % 10 if n > 0}\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays,sum |>\n\
    <| a |>\nHere's a solution using Ruby's inject to iterate over the array and sum\
    \ up each digit.\n<code>", "  arr.each do |num|\n    if num < 0\n      num = -num\n\
    \    end\n    digits = num.to_s.chars.map(&:to_i)\n    sum(digits) > 0 ? sum(digits)\
    \ : 0\n  end\nend", "  sum = 0\n  arr.each do |e|\n    if e.is_a? Integer\n  \
    \    sum += e % 10\n    elsif e.is_a? String\n      sum += (e.split('').map(&:to_i).reduce(:+)\
    \ % 10)\n    else\n      raise ArgumentError, 'argument must be an integer or\
    \ string'\n    end\n  end\n  sum\nend\n</code>\nOutput:\n<code>\ncount_nums [-1,\
    \ 2, 3, -4, 5] # => 3\ncount_nums [-1, -2, -4, 5] # => 0\ncount_nums [-1, 2, 3]\
    \ # => 2\n</code>\n<|/ a |>\n<| c |>\nI'm sorry, but I don't understand this answer.\
    \ How do you know that `count_nums([-1,2,-4,5])` returns `3`, when in fact it\
    \ should be `2`? The `count_nums` method doesn't seem to return anything meaningful...\n\
    <|/ c |>\n<| c |>\nHe is asking for a function which counts number of elements\
    \ whose sum is greater than zero. He has given his first example. For all those\
    \ examples, the first signed digit of each number is negative. For that reason\
    \ it is obvious that `count_nums [-1, 2, 3, -4, 5]` returns `3`. However, for\
    \ `count_nums [-1, -2, -4, 5]` the sum is negative, so the function should return\
    \ 0. Thus, for the first example, the function should return 3. For the second\
    \ example it returns 0. He did not ask us to write a function which returns number\
    \ of elements whose sum is negative, which is exactly what my function does. Does\
    \ that answer your question?\n<|/ c |>\n<| c |>\nThanks for your answer, but this\
    \ doesn't answer my question. I'm aware of what count_nums does, but I'm looking\
    \ for a solution to count the occurrences of an element which has a sum of digits\
    \ > 0. I'm not asking for the number of elements whose sum is negative. I don't\
    \ want to write an algorithm to count the number of elements whose sum is negative,\
    \ either. My question is about how I can find out if a number can be split into\
    \ a sum of positive digits (i.e. its digits sum upto zero) or not (i.e. at least\
    \ one digit in the sum is negative). Your code doesn't take care of that either.\n\
    <|/ c |>\n<| c |>\nI understand your question. You will see from the answer, that\
    \ I have provided two examples. In the first example the sum is less than 0. For\
    \ the second example the sum is greater than 0. When you see that `count_nums`\
    \ returns the number of elements with a sum greater than zero, then you should\
    \ be able to see that when you split the number into digits, the first digit cannot\
    \ be negative because its sign will change depending on the first digit. So, for\
    \ the ", "    count = 0\n    for num in arr\n        if num < 0\n            num\
    \ = -num\n        end\n        if num == 0\n            count += 1\n        end\n\
    \        if num % 10 == 0\n            count += 1\n        end\n    end\nend\n\
    </cell>\n<code language=julia-1.0>\ncount_nums(arr)\n</cell>\n<code language=julia-1.0>",
  "  arr.inject(0) do |total, n|\n    if n < 0\n      sum = 0\n      n.to_s.split('.').each\
    \ do |d|\n        sum += d.to_i\n      end\n      total -= sum\n    else\n   \
    \   total += n\n    end\n  end\nend\n</cell>\n<code language=conda-root-py>\n\
    count_nums([2, -2, 3])\n</cell>\n<code language=conda-root-py>\ncount_nums([-5,\
    \ 2, 3])\n</cell>\n<code language=conda-root-py>\ncount_nums([-13, -5, -2, 3])\n\
    </cell>\n<code language=conda-root-py>\ncount_nums([-1, -4, 5, 3])\n</cell>\n\
    <code language=conda-root-py>\ncount_nums([-1, -4, -5, 3])\n</cell>\n<code language=conda-root-py>\n\
    count_nums([-13, -4, -5, 3])\n</cell>\n<text>\nExercise 2 - Add Two Numbers",
  "  return arr.select {|n| n % 10 > 0}.length\nend", "  return arr.select { |n| n\
    \ > 0 }.size\nend", "  arr.inject(0) do |sum, (el)|\n    sum += el if el > 0\n\
    \    sum\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThank you so much for the explanation.\n\
    <|/ c |>\n<| a tags=ruby,algorithm,ruby-on-rails |>\nTry this:\n<code>", "  if\
    \ arr.length < 0\n    return -arr.first\n  end\n  arr.reduce(:+)\nend", "  # Your\
    \ code here\n  arr.each do |num|\n    if num < 0\n      num = (num / 10).abs\n\
    \    end\n  end\n  arr.count(num)\nend\n</code>\nIn Ruby, you can use the Enumerable#count\
    \ method to count the number of elements in a collection that match a condition.\
    \  In your case, you want to count the number of elements that have a sum greater\
    \ than 0.  You can use the Enumerable#sum method to sum the digits of a number,\
    \ which gives you a negative number if its first digit is negative:\n<code>\n\
    -123 => -1\n-456 => -56\n</code>\nYou can use this knowledge to write your count_nums\
    \ function, which returns the number of elements in a collection that have a sum\
    \ of digits > 0.\nThe count_nums function will use the Enumerable#sum method to\
    \ count the number of elements in the collection that have a sum of digits > 0,\
    \ and then it will use the Enumerable#count method to return the count:\n<code>",
  "    # Your code goes here\n    arr.each do |number|\n        if number < 0\n  \
    \          sign = -1\n            number = -number\n        else\n           \
    \ sign = 1\n        end\n        sum = 0\n        while number != 0\n        \
    \    sum += number%10\n            number /= 10\n        end\n        if sum >\
    \ 0\n            return sign * sum\n        end\n    end\n    return nil\nend",
  "  arr.select { |n| n < 0 }.select { |n| n.digits.sum }.count { |n| n > 0 }\nend",
  "  if arr.empty?\n    0\n  else\n    arr[0].to_i + count_nums(arr.drop(1)) # drop(1)\
    \ eliminates the last element\n  end\nend", "  # Write your code here\n  count\
    \ = 0\n  a = arr.clone\n  a.each_index { |i| return i if i < 0 && a[i][0] < 0\
    \ } \n  a.reverse\n  a.each_index do |i|\n    sum = 0\n    a[i].each { |j| sum\
    \ += j }\n    return count if sum > 0\n    count += 1\n  end\n  count\nend", " \
    \ count = 0\n  arr.each do |a|\n    count = count + 1 if a.positive?\n  end\n\
    \  count\nend", "  arr.select{|e| e > 0 }.count { |e| arr & e.to_s(10) }\nend\n\
    print count_nums([-2, -12, 3, 6, 72, 10, 50])\nprint count_nums([-2, -12, 3, 6,\
    \ 72, 10, 50])\nputs count_nums([-21, -12, 3, 6, 72, 10, 50])\nputs count_nums([-22,\
    \ -12, 3, 6, 72, 10, 50])\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`arr &\
    \ e.to_s(10)` could be replaced with `arr[e.to_s(10)]`\n<|/ c |>\n<| c |>\n: Thanks,\
    \ I updated the answer to use `arr[e.to_s(10)]`.\n<|/ c |>\n<| c |>\nI don't think\
    \ `&` works with the negative numbers.\n<|/ c |>\n<| a tags=ruby,arrays |>\nThis\
    \ is probably not the most efficient but it is readable for me\n<code>", "  arr.inject(0)\
    \ do |sum, num|\n    if num < 0\n      sum + num.abs\n    else\n      sum + num\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a dscore=2 tags=algorithm,ruby\
    \ |>\n<code>", "  # Write your code here.\n  arr.uniq.count do |e|\n    (e%10)==0\n\
    \  end\nend", "  count_nums = 0\n  arr.each do |num|\n    nums_digits = num.to_s.chars.map(&:to_i)\n\
    \    count_nums += 1 if nums_digits.inject(:+) > 0\n  end\n  count_nums\nend",
  "  sum = 0\n  arr.each {|i| sum += i if i > 0}\n  sum\nend", "    count = 0\n  \
    \  arr.each do |num|\n        count += num < 0 ? num.abs%(10**num.abs) / 10 :\
    \ 0\n    end\n    return count\nend\n</code>\nThen\n<code>\ncount_nums([1,2,-3,4,0,-6])\n\
    \  #=> 6\n</code>\nExplanation:\nThe method Array#each is documented here. It\
    \ iterates over the elements of an array. As we see in the following example:\n\
    <code>\nary = [1, 2, -3, 4, 0, -6]\nary.each { |e| puts e }\n</code>\nFirst the\
    \ block variable e is assigned the element of the array (1 or 2, then -3 or 4,\
    \ then 0, then -6).\nThe first expression num < 0 ? num.abs%(10**num.abs) / 10\
    \ : 0 is called the conditional expression.\nThe conditional expression returns\
    \ 1 if the element is an odd number, 0 otherwise. Since 1 is truthy, the conditional\
    \ expression returns the value of the expression and assigns it to num.\nIf num\
    \ is odd, then num.abs%(10**num.abs)/10 is the last digit, i.e., an odd integer's\
    \ last digit. Otherwise, this expression is nil and nil.to_i is 0.\nThe method\
    \ Integer#abs is documented here. Its description is", "  return arr.sum(&:nonzero?\
    \ && [true,false].include?(first)) > 0 ? arr.count(&:nonzero? && [true,false].include?(first))\
    \ : 0\nend", "    count = 0\n    arr.each do |num|\n        if num > 0\n     \
    \       count += num\n        end\n    end\n    return count\nend", "    arr.each\
    \ do |x|\n        sum += x if x > 0\n    end\n    sum\nend", "  arr.select { |i|\
    \ i > 0 }.inject(0) { |i, v| i + count_nums(v) }\nend\n</code>\nAs you can see,\
    \ I'm using the inject method which does what you'd think it does. When you pass\
    \ a block to inject, you get back a new array of those values, which are then\
    \ merged together. Here's how it works step by step:\n<code>", "  arr.each do\
    \ |n|\n    if n.zero?\n      next\n    elsif n.positive?\n      next\n    else\n\
    \      n -= n % 10\n      until n.zero?\n        n /= 10\n        puts n\n   \
    \   end\n    end\n  end\nend", "    count = 0\n    if arr.is_a?(Array)\n     \
    \   arr.each { |e| count += 1 if e > 0 }\n    else\n        count += 1\n    end\n\
    \    count\nend", "  arr.inject(0) do |n, i|\n    next n if n < 0\n    n += 1\
    \ if arr[i].nonzero?\n  end\nend", "  count = 0\n  while arr do\n    break if\
    \ arr.sum > 0\n    count += 1\n    arr = arr.next_to_positive\n  end\n  return\
    \ count\nend", "  # Solution code here\nend\n</cell>\n<code language=julia-1.5>",
  "  count = 0\n  i = 0\n  while i < arr.length\n    digit = arr[i]\n    if digit\
    \ >= 0\n      count += 1\n    else\n      count += digit\n    i += 1\n  end\n\
    \  count\nend", "  arr.sort.with_index do |x, i|\n    arr[i] >= 0 ? i : -i - 1\n\
    \  end\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c |>\nThis is not what the\
    \ OP wanted, I think. I think he just want to count the numbers which have more\
    \ than 0 sum, not sums within a range.\n<|/ c |>\n<| c |>\nOh I see. Let me fix\
    \ that\n<|/ c |>\n<| a |>\nWe can solve this problem without iterating over the\
    \ entire array. We can use regular expressions for matching patterns in the array.\
    \ For instance, we can use regular expressions for matching patterns in a string.\
    \ A pattern consists of a sequence of repeated characters. For example, for the\
    \ string \"abc\", the pattern is a{3}, which means \"a followed by three a\",\
    \ or \"ab\", or just \"b\".\nWe then can count the number of these patterns we\
    \ have using String#scan.\n<code>", "  count = 0\n  arr.each do |x|\n    if x.abs\
    \ < 0\n      x -= x.abs\n      count += 1\n    end\n  end\n  count\nend\nprint\
    \ count_nums([-2, -1, 0, 1, 2])\nprint count_nums([-1, 0, 1, 2])", "  arr.each\
    \ do |num|\n    unless num < 0 then\n      return num if num.to_s.each_char.map(&:to_i).sum\
    \ > 0\n    end\n  end\n  nil\nend\nprint count_nums([-123, -20, 0, 5, 6, -10])\n\
    </code>\n<|/ a dscore=2 tags=ruby,algorithm |>\n<| c |>\nI think you mean `each_char.map(&:to_i)`\n\
    <|/ c |>\n<| c |>\nThanks for the help!  This was very helpful.\n<|/ c |>\n<|\
    \ c |>\nYou're welcome. Also note that if you don't need the array to be sorted,\
    \ you might want to use `each_cons(2).reduce(:+)`\n<|/ c |>\n<| c |>\nWow! This\
    \ is awesome!\n<|/ c |>\n<| a |>\nThe solution is pretty simple. You can just\
    \ use Array#select:\n<code>\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\narr.select\
    \ { |x| x.to_s.each_char.map { |c| c.to_i }.max > 0 }", "    count = 0\n    arr.each\
    \ do |i|\n        count += i.digits.inject(0) do |sum, n|\n            sum + n\
    \ if sum + n > 0 && n < 10\n        end\n    end\n    count\nend\n</code>\nThe\
    \ count_nums method is now only three lines of code:\n<code>\narr = [1, 2, 3,\
    \ 4]\narr.select { |i| i.digits.inject(:+) > 0 }.count\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=2 |>\n<| a |>\nThe solution is quite complicated but it is very effective.\
    \ Here it is:\n<code>", "  arr.each_index do |i|\n    arr[i].to_s.split('').\n\
    \            select {|x| x.to_i > 0}.\n            reduce(0) {|t,s| t+1 if t <\
    \ s.length}\n  end\nend\n</code>\nThe resulting test case is\n<code>\ntest \"\
    count_nums\" do\n  assert_equal 2, count_nums([-123, -456, -10, 23, -6, 12, -3,\
    \ -121])\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby dscore=1 |>\nYou can\
    \ try this out as well. Just iterate over the array and increment the value for\
    \ each index till the current index. \n<code>", "  nums = arr.map(&:to_i)\n  nums.compact.each_with_object(0)\
    \ do |n, count|\n    if n > 0 && (nums.count { |i| i >= n } == 0)\n      count\
    \ += n\n    end\n  end\nend", "  arr.each do |n|\n    if n < 0\n      n = -n\n\
    \    end\n    count = 0\n    (1..9).each do |i|\n      count += n >= 0 ? n % i\
    \ == 0 : n % i != 0\n    end\n    puts \"#{n} has sum #{count}\"\n  end\nend",
  "  n = arr.length\n  counts = 0\n  for i in 0...n\n    digit = arr[i].to_i\n   \
    \ counts += digit > 0\n  end\n  counts\nend", "    arr.each do |num|\n       \
    \ if num > 0\n            arr[num-1] + arr[num-2] + arr[num-3]\n        else\n\
    \            arr[num-1]\n        end\n    end\nend", "    arr.each_index do |i|\n\
    \        if arr[i] > 0 \n            return arr[i]\n        elsif arr[i] < 0 and\
    \ arr[i-1] > 0\n            return arr[i-1]\n        end\n    end\nend\n</code>\n\
    Next, write the function sum_digits which takes an integer and returns the sum\
    \ of the digits of that integer.\n<code>", "  nums = []\n  # loop over all numbers\n\
    \  arr.each do |n|\n    # initialize a variable to store sums\n    # add n to\
    \ sum\n    sum = n\n    # loop over all digits in n\n    while sum > 0\n     \
    \ # take last digit in sum\n      digit = sum % 10\n      # get sum by taking\
    \ last digit of sum\n      sum = (sum / 10).floor\n      # if the last digit is\
    \ greater than 0\n      # add that digit to sum\n      sum += digit\n    end\n\
    \    # if the number is not negative\n    if n > 0 \n      # then add it to the\
    \ list\n      nums << n\n    end\n  end\n  nums.length\nend", "    count = 0\n\
    \    arr.each do |num|\n        if num >= 0\n            count += 1\n        \
    \    next if num.modulo(10) != 0\n        end\n        \n        pos = num.to_s.rindex('.')\n\
    \        if pos == nil \n            pos += 1\n        end\n        \n       \
    \ if num < 0\n            pos += 1 \n        end\n        \n        sum = num.to_s.to_i[pos]\n\
    \        if sum > 0\n            count += 1\n        end\n    end\n    return\
    \ count\nend", "  if arr[0].zero?\n    0\n  else\n    arr.select(&:nonzero?).sum\n\
    \  end\nend", "  nums = 0\n  arr.each do |n|\n    if n < 0\n      n = n * -1\n\
    \    end\n    n = n.to_i\n    if n % 10 > 0\n      nums += 1\n    end\n  end\n\
    \  nums\nend", "    arr.each do |x| \n        if x > 0 \n            nums = \"\
    \"\n            x.to_s.split('').each { |y| nums << y if y.to_i >= 0 }\n     \
    \       sum = 0\n            nums.each { |y| sum += y.to_i }\n            if sum\
    \ > 0 \n                return sum\n            end\n        end\n    end\nend",
  "    count = 0\n    arr.each do |n|\n        if n.is_a? Integer\n            count\
    \ += 1\n            n += (n.abs / 10).floor\n        end\n    end\n    count\n\
    end", "    arr.each do |x|\n      if x.is_a? Integer\n        if x >= 0\n    \
    \      puts \"#{x}\"\n        else\n          puts \"-#{x.abs}\"\n        end\n\
    \      end\n    end\nend", "  arr.each do |n|\n    next if n < 0\n    sign = (n\
    \ < 0) ? -1 : 1\n    digit_sum = n.digits.reduce(:+)\n    next unless digit_sum\
    \ > 0\n    n -= sign\n    break if n == 0\n    digit_sum -= sign\n    n += sign\n\
    \  end\n  arr.count(1)\nend\n</code>\n<|/ a |>\n<| c |>\nThis is quite interesting,\
    \ and it really helps to get my mind around what it's doing. My first attempt\
    \ was using recursion to solve the problem, but I found myself repeating code.\
    \ Not really an elegant solution, but I liked the way you thought of it.\n<|/\
    \ c |>\n<| c |>\nI like it too. Thanks for the reminder. :) It's been a while\
    \ since I wrote any Ruby, so I may have messed up the syntax or something.\n<|/\
    \ c |>\n<| a |>\nJust for fun, here's a recursive solution that I think might\
    \ do what you are asking for. I'm sure it could be made more elegant or maybe\
    \ even more efficient but it still looks pretty elegant to me:\n<code>", "  counts\
    \ = []\n  arr.each do |num|\n    sign = num < 0 ? -num : num\n    counts << sign.to_i\n\
    \  end\n  counts.length\nend", "  arr.inject(0) do |sum, elem|\n    sum += elem\
    \ if elem.is_a?(Integer)\n    sum\n  end\nend", "  arr.select{|x| x > 0 }.count\n\
    end", "  arr.each_with_index do |num, i|\n    if num < 0\n      num *= -1\n  \
    \    arr[i] = num\n    end\n  end\n  arr = arr.sort\n  return 0 if arr.size <=\
    \ 1\n  arr.size - 1\nend", "  arr.each do |i|\n    return 1 if i % 9 == 0\n  \
    \  return 0 if i % 9 > 0\n    return -1 if i % 9 < 0\n  end\nend", "  arr.select{|n|\
    \ n >= 0 }.inject(0) { |sum, n| sum + count_num(n) }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
