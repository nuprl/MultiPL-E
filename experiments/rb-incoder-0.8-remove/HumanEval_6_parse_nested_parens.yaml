name: HumanEval_6_parse_nested_parens
language: rb
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\ndef parse_nested_parens(paren_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n\
  \    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"\
  (()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"\
  () (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"\
  ))\n  end\nend\n"
completions: ["  paren_stack = []\n  paren_stack.push(n)\n  paren_stack.push(0)\n\
    \  paren_stack.push([])\n  paren_count = 0\n  n = 0\n  while n > 0\n    if paren_stack.length\
    \ == 0\n      break\n    paren_count = 0\n    paren_stack.each do |paren|\n  \
    \    count += 1\n      paren_count += 1\n      if paren_count == paren\n     \
    \   paren_stack.push(n)\n        break\n      end\n    end\n    n -= 1\n  end\n\
    \  paren_stack.pop\nend", "  paren_stack = []\n  paren_level = 0\n  paren_stack.push(0)\n\
    \  paren_stack.push(0)\n  paren_stack.length\n  nesting_level = 0\n  while paren_stack.length\
    \ > 0\n    nesting_level = paren_stack.pop\n    paren_stack.length = 0\n    paren_level\
    \ -= 1\n    if paren_level == 0\n      break\n    paren_stack.push(0)\n  end\n\
    \  nesting_level\nend", "  depth = 0\n  output = ''\n  paren_string.split(/\\\
    s+/).each do |str|\n    if str == '('\n      depth += 1\n      output += str.to_s.size.to_s\
    \ + ' ('\n    elsif str == ')'\n      depth -= 1\n      output += ')'\n      break\
    \ if depth == 0\n    end\n  end\n  output\nend", "    stack = []\n    level =\
    \ 0\n    paren_count = 0\n    paren_char = ''\n    depth = 0\n    \n    # Loop\
    \ through each character in the string.\n    paren_string.each_char do |char|\n\
    \        # Update the number of open parentheses.\n        if char == '('\n  \
    \          paren_count += 1\n        else\n            # If the open parentheses\
    \ count is 0 or 1, then close it.\n            if paren_count == 1\n         \
    \       paren_char = '('\n            else\n                # Increment the number\
    \ of open parentheses and decrease the level.\n                paren_count -=\
    \ 1\n                depth += 1\n                \n                # Close the\
    \ parentheses corresponding to the last open parentheses.\n                paren_char\
    \ += ')'\n            end\n        end\n        \n        # Push the closing parentheses\
    \ onto the stack.\n        stack << paren_char\n    end", "  level = 0\n  levels\
    \ = paren_string.split(' ')\n  levels.each do |element|\n    if element == \"\
    (\"\n      level += 1\n    elsif element == \")\"\n      level -= 1\n    elsif\
    \ level > 0\n      return level\n    end\n  end\n  return 0\nend", "  max_level\
    \ = 0\n  paren_groups = paren_string.gsub('( ', '( ').gsub(') ', ') ').split('\
    \ ')\n  paren_groups.each do |paren_group|\n    level = 0\n    if paren_group\
    \ != ''\n      while paren_group[paren_group.length-level-1] == paren_group[paren_group.length-level-2]\n\
    \        level += 1\n      end\n    end\n    max_level = level if level > max_level\n\
    \  end\n  max_level\nend", "  # Initialize a stack to store all parantheses levels.\n\
    \  parentheses_stack = []", "  paren_string.split(\" \").each_with_index do |group_string,\
    \ index|\n    group_string.strip!\n    paren_symbol = paren_string[index].strip\n\
    \    next if paren_symbol == \"()\" && group_string.empty?\n    \n    level =\
    \ levels[paren_symbol] || 0\n    \n    levels[paren_symbol] = level + 1\n    \n\
    \    p \"(#{group_string}): #{level}\" if level > 0\n    \n    parse_nested_parens(paren_string,\
    \ index + 1, level + 1)\n    levels[paren_symbol] = level\n  end\nend", "  max_nesting_level\
    \ = -1\n  max_nested_paren_level = 0\n  paren_count = 0\n  nested_parens = paren_string.split('\
    \ ')\n  nested_parens.each do |nested_paren|\n    if nested_paren == '()'\n  \
    \    nested_paren_level += 1\n    elsif nested_paren == '[]'\n      nested_paren_level\
    \ -= 1\n    elsif nested_paren == '{}'\n      nested_paren_level += 1\n    elsif\
    \ nested_paren == '{}'\n      nested_paren_level -= 1\n    elsif nested_paren\
    \ == '[]{}'\n      nested_paren_level += 1\n    elsif nested_paren == '[]{}'\n\
    \      nested_paren_level -= 1\n    else\n      parent_count = paren_count - nested_paren_level\n\
    \      max_nesting_level = max_nesting_level if max_nesting_level > parent_count\n\
    \      max_nested_paren_level = max_nested_paren_level if max_nested_paren_level\
    \ > nested_paren_level\n      nested_paren_level = paren_count\n      nested_paren_count\
    \ += 1\n    end\n  end\n  if max_nesting_level > 0\n    max_nesting_level -= 1\n\
    \  end\n  return max_nesting_level, max_nested_paren_level, nested_paren_count\n\
    end", "  paren_string.scan(/[^\\(\\)]+/).inject(0) do |highest_level, paren_char|\n\
    \    if paren_char == '('\n      highest_level + 1\n    elsif paren_char == ')'\n\
    \      highest_level - 1\n    end\n  end\nend\n</code>\nThe function above will\
    \ find the highest level of nesting from the given string.\n<|/ a tags=ruby,regex,string\
    \ dscore=0 |>\n<| a |>\n<code>\nparen_string = '(()()()()()()())'", "  paren_depth\
    \ = 1\n  paren_levels = Hash.new(0)\n  paren_levels[paren_depth] += 1", "  paren_stack\
    \ = []\n  paren_level = 0\n  paren_str = paren_string.strip.dup", "  # A stack\
    \ for parsing the parenthesis.\n  paren_string = paren_string.gsub(/\\s+/, \"\
    \ \").gsub(/\\(\\s*\\)/, \"(\").gsub(/\\)\\s*$/, \")\")\n  paren_string.scan(/\\\
    s*[^(]+(\\((.+?)(?:,|$))*[^)]*\\2\\s*$/)\nend", "  max_nesting_level = 0\n  nesting_level\
    \ = 0", "  depth = 1\n  paren_count = 0\n  groups = []\n  bracket_count = 0\n\
    \  \n  paren_levels = [paren_count, paren_count]\n  bracket_levels = [bracket_count,\
    \ bracket_count]\n  \n  while paren_count != 0\n    if paren_count > bracket_count\n\
    \      new_groups = []\n      new_depth = paren_levels[paren_count]\n      new_paren_count\
    \ = paren_count + 1\n      while new_depth != 0\n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n      \n        new_groups.push(paren_string)\n     \
    \   new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n        new_groups.push(paren_string)\n\
    \        new_depth -= 1\n        new_paren_count += 1\n      \n", "  max_level\
    \ = 0\n  nested_parens = []\n  paren_count = 0\n  paren_level = 0\n  paren_stack\
    \ = []\n  paren_levels = {}\n  paren_stack_keys = paren_stack_keys unless paren_stack_keys.nil?\n\
    \  paren_stack_keys ||= ['(', ')']", "  # To store the deepest level of nesting\
    \ \n  max_level = 0", "  # Split the string into an array of groups of parentheses\
    \ separated by spaces.\n  paren_groups = paren_string.split(\" \").map { |x| x.gsub(\"\
    [()]\", \"\\\\(\\\\)\") }", "  brackets = paren_string.scan(/\\(([^()]+)\\)/)\n\
    \  level = 0\n  result.push(brackets)\n  brackets.each do |bracket_group|\n  \
    \  bracket_group = bracket_group[1].split(')')\n    bracket_group.each do |bracket_group_inner|\n\
    \      if bracket_group_inner == '()'\n        level += 1\n      elsif bracket_group_inner\
    \ == '{}'\n        level -= 1\n      end\n    end\n  end\n  result.flatten.compact\n\
    end", "  levels = []\n  brackets = 0\n  parenthesis = paren_string.split(' ')\n\
    \  parenthesis.each do |x|\n    if x.start_with?('(')\n      brackets += 1\n \
    \     if brackets == 1\n        levels << 1\n      else\n        levels << brackets\n\
    \      end\n    elsif x.end_with?(')')\n      brackets -= 1\n      if brackets\
    \ == 0\n        levels << 0\n      else\n        levels << brackets\n      end\n\
    \    end\n  end\n  max_level = levels[levels.size-1]\n  if parenthesis.size >\
    \ max_level\n    parenthesis[max_level] = ''\n  end\n  parenthesis\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby,recursion |>\n<| a dscore=0 |>\n<code>\n def depth(parenthesis)\n\
    \    depth = []\n    parenthesis.chars.reduce(0) do |prev, curr|\n      case prev\n\
    \      when 0\n        depth << 1\n      when 1\n        depth << 1 + depth[prev]\n\
    \      else\n        depth.push(depth[prev])\n      end\n      prev += 1\n   \
    \ end\n    depth[-1]\n  end\n</code>\n<|/ a tags=ruby-on-rails,ruby,recursion\
    \ |>\n<| c |>\nIt would be helpful if you could add an explanation to your answer.\n\
    <|/ c |>\n<| a tags=ruby-on-rails,ruby,recursion |>\n<code>", "    nested_count\
    \ = 0\n    paren_stack = []\n    \n    # Count open brackets\n    open_brackets\
    \ = paren_string.count('(')\n    # Count closed brackets\n    closed_brackets\
    \ = paren_string.count(')')\n    \n    # If the string contains only parentheses\n\
    \    if open_brackets == closed_brackets\n        return nested_count\n    \n\
    \    while open_brackets <= closed_brackets\n        # Pop out opening parenthesis\n\
    \        paren_stack.pop\n        open_brackets = paren_string.count('(')\n  \
    \      \n        # Append the opening parenthesis to the paren_stack\n       \
    \ paren_stack.push(paren_string)\n        # Replace the closing parenthesis with\
    \ an empty string\n        paren_string = paren_string.gsub(')', \"\")\n     \
    \   \n        nested_count += 1 # Count this nested parentheses\n        paren_string\
    \ = paren_stack.last\n    end\n    \n    nested_count += 1 # Count this nested\
    \ parentheses\n    return nested_count\nend", "  paren_level = []\n  paren_count\
    \ = 0\n  paren_level = paren_level.dup", "  # Parsing logic from top to bottom\n\
    \  parsed_paren_groups = []\n  parsing_level = 0\n  paren_string = paren_string.split\n\
    \  parsed_paren_groups.push(paren_string.shift)\n  while !paren_string.empty?\n\
    \    # If the next char is left paren, increment the parsing level\n    if paren_string.first\
    \ == '('\n      parsing_level += 1\n    elsif paren_string.first == ')'\n    \
    \  parsing_level -= 1\n    end\n    # If parsing level is 0, add the current group\
    \ to the output list\n    if parsing_level == 0\n      parsed_paren_groups <<\
    \ parsed_paren_groups.pop\n    end\n  end\n  # If parsing level is 0, add the\
    \ current group to the output list\n  if parsing_level == 0\n    parsed_paren_groups\
    \ << parsed_paren_groups.pop\n  end\n  return parsed_paren_groups\nend", "  #\
    \ Use this counter to keep track of level of nesting\n  max_level = 0", "    nested_parens\
    \ = []\n    level = 0\n    levels_in_paren = 0", "  depth = 0\n  opening = paren_string.gsub(\"\
    ()\",\"*\").scan(/[^()]+/).flatten.first\n  depth = paren_string.gsub(opening,\"\
    \").scan(/[^()]+/).flatten.inject(0) do |depth, string|\n    string.to_i.downto(0)\
    \ do |i|\n      break if i.zero?\n      depth if depth < i\n    end\n  end.max\n\
    \  depth\nend", "  max_level = 0\n  parens_stack = []\n  paren_levels = paren_string.split('\
    \ ')\n  paren_levels.each do |paren|\n    if paren.strip.length == 0\n      break\n\
    \    end\n    parens_stack.push(0)\n  end", "  if paren_string == \"\"\n    []\n\
    \  else\n    parse_paren(paren_string.split(\" \").map {|x| x}).inject([]){|acc,\
    \ x| acc << x}.reverse\n  end\nend", "  paren_string.split(' ').map do |paren|\n\
    \    paren_pairs = paren.scan(/([()]*)\\1*/)\n    paren_pairs.map do |paren_pair|\n\
    \      paren_pair[0].length\n    end.max\n  end.max\nend", "  paren_stack = []\n\
    \  paren_string.scan(/[()()]/) { |char|\n    if paren_stack.empty? && char ==\
    \ '('\n      paren_stack.push char\n    elsif paren_stack.empty? && char == ')'\n\
    \      return \"#{paren_stack.pop}#{char}\"\n    elsif char == ')' && !paren_stack.empty?\n\
    \      paren_stack.pop\n    elsif paren_stack.empty?\n      paren_stack.push char\n\
    \    end\n  }\n  raise \"unbalanced parentheses!\" if paren_stack.size != 0\n\
    end", "  paren_array = []\n  paren_count = 0\n  paren_groups = paren_string.split(\"\
    \ \").map { |s| s.split(\"(\") }\n  while paren_count > 0\n    paren_count +=\
    \ 1\n    paren_array = paren_array.map { |a| a << paren_groups[paren_count] }\n\
    \  end\n  paren_array.map { |a| a.map { |s| s.gsub(/\\(|\\)/, \"\") } }\nend",
  "  paren_count = paren_string.scan(/\\(|\\)|[\\(\\)]/).size\n  results = []\n  for\
    \ i in 1..paren_count\n    if paren_string.scan(/\\(|\\)|[\\(\\)]/).size < i\n\
    \      break\n    elsif paren_string.scan(/\\(|\\)|[\\(\\)]/).size == i\n    \
    \  results.push(paren_string.scan(/\\(|\\)/).last)\n    end\n  end\n  results\n\
    end", "  level = 0\n  result = []\n  opening = paren_string[0]\n  closing = paren_string[-1]\n\
    \  paren_pairs = paren_string.gsub('()', '').scan(/[^\\s()]+/)\n  paren_pairs.each\
    \ do |pair|\n    if pair == opening || pair == closing\n      level += 1 if pair\
    \ == closing\n    else\n      result << level\n    end\n  end\n  result.max\n\
    end", "  paren_string.gsub!(/([^)(]+)(\\(([^)]+)\\))*([^)]*)/){\n    depth = $2.length\n\
    \    inner_string = $1 + ($3 ? \"(#{parse_nested_parens($3)})\" : \"\")\n    inner_string.gsub!(/\\\
    (|\\)/, \"\")\n    return (inner_string.length > depth) ? inner_string : nil\n\
    \  }\nend\n</code>\nI tested this on https://rubular.com/ and works fine.\n<|/\
    \ a tags=ruby,regex |>\n<| c |>\nIt works for most cases except nested parentheses\
    \ inside the double quotes.\n<|/ c |>\n<| c |>\n- Yes it does.  Your original\
    \ question didn't say anything about nested double quotes.  If you have some examples\
    \ where this doesn't work let me know and I'll update my answer.\n<|/ c |>\n<|\
    \ c |>\nIt does work for nested parenthesis inside the double quotes.\n<|/ c |>\n\
    <| c |>\n- It does.  The `gsub` function just removes the parentheses.\n<|/ c\
    \ |>\n<| c |>\n- Can you give me an example where this fails?  I'll update my\
    \ answer.\n<|/ c |>\n<| a dscore=1 tags=ruby,regex |>\nI assume that you're not\
    \ going to have parenthesis inside the string being parsed, and that the parenthesis\
    \ won't be inside double quotes.\nYou can write a custom parser:\n<code>\nstr\
    \ = \"()()()(()) asdfafsd  dsf(sa sadsadsd  asdasdas  asdasdas (asdasdas (asdasdas\
    \ (asdasdas)))(asdasdas (asdasdas))(asdasdas (asdasdas)) (asdasdas (asdasdas))\
    \ (asdasdas (asdasdas)) (asdasdas (asdasdas)) (asdasdas (asdasdas)) (asdasdas\
    \ (asdasdas)) (asdasdas (asdasdas)) (asdasdas (asdasdas)) (asdasdas (asdasdas))\
    \ (asdasdas (asdasdas)) (asdasdas (asdasdas)) (asdasdas (asdasd", "  paren_stack\
    \ = []\n  paren_stack.push paren_string\n  level_of_nesting = 0\n  while paren_stack.any?\n\
    \    if paren_stack.last.empty?\n      break\n    elsif paren_stack.last.last\
    \ == \")\"\n      level_of_nesting -= 1\n      paren_stack.pop\n    elsif paren_stack.last.last\
    \ == \"(\"\n      level_of_nesting += 1\n      paren_stack.pop\n    else\n   \
    \   puts \"Unexpected input at #{paren_stack.last}.\"\n      break\n    end\n\
    \  end\n  level_of_nesting\nend", "  max_level = 0\n  paren_stack = []\n  paren_stack_level\
    \ = 0\n  paren_string.split(\" \").each do |elem|\n    if elem == \"(\" || elem\
    \ == \"[\"\n      paren_stack.push elem\n      paren_stack_level += 1\n    elsif\
    \ elem == \")\"\n      paren_stack_level -= 1\n      if paren_stack_level == 0\
    \ then return max_level end\n      parent = paren_stack.pop\n      if parent ==\
    \ \"(\" || paren_stack.length > 0 then max_level = 1 + parse_nested_parens(paren_string)\
    \ end\n    elsif elem == \"]\"\n      if paren_stack_level == 0 then return max_level\
    \ end\n      parent = paren_stack.pop\n      if parent == \"(\" || paren_stack.length\
    \ > 0 then max_level = 1 + parse_nested_parens(paren_string) end\n    end\n  end\n\
    \  return max_level\nend", "  groups = paren_string.scan(/\\(([^\\(\\)]+)\\)/).flatten.map(&:first)\n\
    \  group_counts = groups.map{|g| g.count('(') + g.count(')')}\n  group_counts.max\n\
    end\n</code>\nAnd the test function:\n<code>", "  max_level = 0\n  parens_strings\
    \ = paren_string.split(\" \")\n  parens_strings.each do |paren_string|\n    if\
    \ !parens_strings.include?(paren_string)\n      max_level = max_level + 1\n  \
    \  end\n  end\n  max_level\nend", "  paren_string.split(\" \").each do |nested_parens_string|\n\
    \    # Output the deepest level of nesting of parentheses.\n    p \"Maximum level\
    \ of nesting in this expression: #{get_max_level_of_nesting(nested_parens_string)}\"\
    \n  end\nend", "  paren_count = paren_string.count(\"(\")\n  if paren_count >=\
    \ paren_string.count(\")\") || paren_count < 1\n    raise ArgumentError, \"Invalid\
    \ paren count. Paren count has to be greater than zero and less than or equal\
    \ to paren string. Paren string: '#{paren_string}'\"\n  end\n  paren_nesting =\
    \ []\n  paren_string.gsub!(\"(\", \"( \")\n  paren_string.gsub!(\")\", \" )\")",
  "  level = 0\n  paren_count = 0\n  paren_levels = []\n  paren_levels_stack = []\n\
    \  paren_counts_stack = []\n  paren_paren_levels = []\n  paren_paren_levels_stack\
    \ = []\n  paren_paren_counts = []\n  paren_paren_counts_stack = []\n  paren_levels_stack\
    \ = []\n  paren_paren_levels_stack = []", "  paren_string.split(\" \").inject(0)\
    \ do |max_level, _str|\n    (max_level - 1).to_i + (_str =~ /\\(/)\n  end\nend",
  "  paren_groups = paren_string.split\n  # If there's one set of parentheses, it's\
    \ already correct.\n  if paren_groups.size ==1\n    return paren_groups[0]\n \
    \ # Else, determine which parenthesis group is the deepest (if there's more than\
    \ one).\n  # For an input of (()(), ((()))), return '((()()))' since it has three\
    \ levels of nesting.\n  # For an input of ((((())))), return '((((())))' since\
    \ it has two levels of nesting.\n  deepest_level = -1\n  while paren_groups.any?\n\
    \    paren_group = paren_groups.shift\n    deepest_level = paren_groups.index(paren_group)\
    \ + deepest_level\n  end\n  return paren_groups[deepest_level]\nend", "  parens\
    \ = paren_string.split(\" \").map do |paren|\n    if paren == \"()\" ||\n    \
    \    paren == \"[]\" ||\n        paren == \"{}\" ||\n        paren == \"()[]\"\
    \ ||\n        paren == \"{}[]\" ||\n        paren == \"[]{}\" ||\n        paren\
    \ == \"(){}\" ||\n        paren == \"{}{}\" ||\n        paren == \"[][]\" ||\n\
    \        paren == \"{}[]\" ||\n        paren == \"[]{}\" ||\n        paren ==\
    \ \"()[]\" ||\n        paren == \"{}[]\"\n      paren\n    else\n      paren.split(\"\
    ,\").map { |nested_paren| parse_nested_parens(nested_paren) }\n    end\n  end",
  "  paren_count = 0\n  paren_level = 0\n  nested_parens = []\n  tokens = paren_string.split",
  "    paren_level = 0\n    nested_parens = 0\n    paren_groups = []", "  paren_stack\
    \ = []\n  paren_stack.push(paren_string)\n  max_level = 0\n  while paren_stack.size\
    \ > 0\n    par = paren_stack.shift\n    level = 1\n    size = par.size\n    while\
    \ size > 1\n      size /= 2\n      level += 1\n    end\n    if paren_stack.size\
    \ > max_level\n      max_level = paren_stack.size\n    end\n    puts \"(#{par})\"\
    .dup.sub('(', '').sub(')', '').to_i(10)\n  end\n  puts \"(#{paren_stack.shift})\"\
    .dup.sub('(', '').sub(')', '').to_i(10)\nend", "    stack = []\n    level = 0",
  "    paren_stack = []\n    parens = []\n    paren_count = 1\n    # count the number\
    \ of opening parens\n    open_parens = 0\n    # count the number of closing parens\n\
    \    close_parens = 0\n    # count the number of nested parens\n    nested_parens\
    \ = 0\n    # count the number of non nested parens\n    non_nested_parens = 0",
  "    nesting_depth = 0\n    nesting_level = 0\n    max_nesting_level = 0\n    found_nested_parens\
    \ = false\n    paren_string.scan(/[\\(\\)]/) do |char|\n        if char == '('\n\
    \            nesting_depth += 1\n            nesting_level += 1\n            found_nested_parens\
    \ = true\n        elsif char == ')'\n            nesting_depth -= 1\n        \
    \    nesting_level -= 1\n            found_nested_parens = true\n        end\n\
    \        max_nesting_level = nesting_depth if nesting_depth > max_nesting_level\n\
    \    end\n    if !found_nested_parens\n        # String is unparseable because\
    \ there is no nested parentheses.\n        raise ParseError, \"Unable to parse\
    \ string \\\"#{paren_string}\\\".\"\n    end\n    max_nesting_level\nend", " \
    \ stack = []\n  depth = 0\n  pos = 0\n  while pos < paren_string.length\n    paren_match\
    \ = paren_string[pos]\n    depth += 1 while paren_string[pos] == '(' && paren_string[pos\
    \ - 1] == '('\n    stack << paren_match\n    pos += 1\n    depth -= 1 while paren_string[pos]\
    \ == ')' && paren_string[pos - 1] == ')'\n  end\n  stack\nend", "  open_count\
    \ = paren_count = 0\n  open_levels = []", "    # No need to parse, as this will\
    \ be done in function `max_level`.\n    paren_string.split(' ')\nend", "  level\
    \ = 0\n  paren_level = 0\n  paren_count = 0\n  output_string = ''\n  paren_group\
    \ = paren_string.gsub(/\\([^()]*\\)/, '').gsub(/\\(([^()]*\\)/, '').split # Split\
    \ the input string by parentheses.\n  paren_group.each do |element|\n    if element\
    \ != ''\n      element =~ /^[(\\(])/ # Check if the element is the first opening\
    \ parentheses.\n      if paren_level > level # If current level is larger than\
    \ the previous level\n        level++\n        output_string = output_string +\
    \ paren_count # Output the deepest level of nesting if available.\n      end\n\
    \      output_string = output_string + element # Output the element without removing\
    \ the parentheses.\n    elsif paren_level > level # If current level is larger\
    \ than the previous level\n      level++\n      output_string = output_string\
    \ + paren_count # Output the deepest level of nesting if available.\n      paren_count\
    \ = paren_count + 1\n    end\n  end\n  return output_string\nend\n</code>\nThe\
    \ above function will take strings like this and output the deepest level of nesting:\n\
    <code>\nparen_string = \"((((()))))\"\n</code>\nOutput:\n<code>\n\"()\"\n</code>\n\
    <|/ a tags=ruby,regex dscore=3 |>\n<| a tags=ruby,regex |>\nThe OP asks for something\
    \ that works with variable depths of nested parentheses.\nI came up with a function\
    \ that counts the number of opening parentheses in a string.\n<code>", "  level\
    \ = 0\n  paren_string.chars.reverse_each do |c|\n    if c == '('\n      level\
    \ += 1\n    elsif c == ')'\n      level -= 1\n    end\n    level if level > 0\n\
    \  end\nend", "  paren_string = paren_string.gsub(/\\((\\(?)+|\\)?(\\(?)+|\\)?)+\\\
    )/, '').squeeze(' ')\n  paren_string = paren_string.gsub(/[\\(\\)']/, '')\n  paren_string\
    \ = paren_string.gsub(/\\s+/, ' ').squeeze(' ')\n  return paren_string.split('\
    \ ').map(&:count).max_by { |i| i }\nend", "  level = 0\n  result = []", "  nested_parentheses\
    \ = []\n  groups = paren_string.scan(/\\(|\\)/).map { |x| x }\n  groups.each {\
    \ |g| nested_parentheses << parse_nested_parens(g) }.flatten\nend", "    paren_depth\
    \ = paren_string.count('(') - paren_string.count(')')\n    nested_paren_depth\
    \ = 0\n    nesting_stack = []\n    for c in paren_string\n        if c == '('\n\
    \            nesting_stack.push paren_depth\n        elsif c == '('\n        \
    \    nesting_stack.pop\n            if nesting_stack.empty?\n                nested_paren_depth\
    \ = nesting_stack.last\n                nesting_stack = []\n            else\n\
    \                nested_paren_depth = nesting_stack.last\n            end\n  \
    \      elsif c == ')'\n            nesting_stack.pop\n        end\n    end\n \
    \   nested_paren_depth\nend", "  result = []\n  level_stack = []\n  paren_level_stack\
    \ = []\n  parens = 0\n  paren_level = 0\n  paren_levels = []\n  paren_levels_array\
    \ = []\n  paren_levels_array.append(paren_level)\n  paren_levels_array.append(paren_level)\n\
    \  paren_levels_array.append(paren_level)\n  paren_levels_array.append(paren_level)\n\
    \  paren_levels_array.append(paren_level)\n  paren_levels_array.append(paren_level)\n\
    \  paren_levels_array.append(paren_level)", "  # Re-initialize counts of parens\n\
    \  paren_counts = Hash.new(0)\n  # Re-initialize paren level\n  paren_level =\
    \ Hash.new(0)\n  # Initialize an empty array to store parsed parens\n  parsed_parens\
    \ = []\n  paren_string.split(\" \").each do |group|\n    group.split(\"\").each_with_index\
    \ do |char, i|\n      if char == \"(\"\n        paren_counts[char] += 1\n    \
    \    paren_level[char] += 1\n      elsif char == \")\"\n        paren_counts[char]\
    \ -= 1\n        paren_level[char] -= 1\n      elsif paren_counts[char] == 0\n\
    \        parsed_parens.push(char * paren_level[char])\n      end\n    end\n  end\n\
    \  parsed_parens\nend", "  level_stack = []\n  paren_stack = []\n  level_stack_str\
    \ = paren_stack_str = paren_string\n  i = 0", "  return paren_string.split(' ').map\
    \ do |nested_parens|\n    nested_parens.count { |c| c == '(' || c == ')' } - 1\n\
    \  end.max\nend", "  nested_parens = 0\n  paren_level = 0\n  paren_count = 0\n\
    \  paren_nesting = []\n  paren_levels = [[]]\n  while paren_count < paren_string.length\n\
    \    paren_count += 1 \n    if paren_count < paren_string.length\n      char =\
    \ paren_string[paren_count]\n      if char == ')'\n        if paren_count + 1\
    \ == paren_string.length\n          nested_parens += paren_level\n          paren_levels[paren_level]\
    \ << paren_count \n          break\n        else \n          nested_parens -=\
    \ 1\n          paren_count += 1\n      end\n      if char == '('\n        nested_parens\
    \ += 1\n        paren_count += 1\n        paren_nesting << paren_level\n     \
    \   paren_level += 1\n      end\n    end\n  end\n  paren_levels[nested_parens].sort!\n\
    \  return paren_levels\nend", "  paren_count = 0\n  result = []\n  paren_stack\
    \ = []\n  paren_groups = paren_string.split(\" \") # split on space\n  paren_groups.each\
    \ do |group|\n    level =  paren_stack.size + 1\n    if group == \"(\"\n     \
    \ paren_stack.push \"(\"\n    elsif group == \")\"\n      level += 1\n      paren_stack.pop\n\
    \    end\n    paren_stack.each do |item|\n      if item == \"(\"\n        level\
    \ += 1\n      elsif item == \")\"\n        level -= 1\n      end\n    end\n  \
    \  result << level\n  end\n  result.max\nend\n</code>\n<|/ a tags=ruby dscore=1\
    \ |>\n<| a dscore=0 tags=ruby |>\nI believe this question was recently asked,\
    \ but there seems to be some activity on this topic on Code Review:\nhttps://codereview.stackexchange.com/questions/69302/maximum-number-of-nested-parentheses-in-a-string\n\
    <|/ a |>\n<| a dscore=0 |>\nMy solution was as follows, using recursion and a\
    \ global variable:\n<code>\nmax_nested_parentheses = 0", "  nested_paren_levels\
    \ = paren_string.scan(/(?:\\(\\))?(.*?)(?:\\)\\(\\))/).flatten.map {|e| e[0].size}.reduce(:+)\n\
    \  return nested_paren_levels\nend", "  level = 0\n  par_list = paren_string.split('\
    \ ')\n  while par_list.size > 0\n    level += 1\n    par_list = par_list.drop_while{|x|\
    \ !x.empty?}.take_while{|x| x.size != 0}\n  end\n  return level\nend", "  groups\
    \ = paren_string.split ' '\n  return(groups.length - 1).ceil\nend", "  paren_string.scan(/^\\\
    s*\\(\\s*(\\()?([^{]*?)\\s*(\\)\\s*)?/) do |group1, group2, group3|\n    if group3\n\
    \      group2 = group3.gsub(/\\)\\s*$/, \"\")\n    end\n    if group2\n      group1\
    \ = group1.gsub(/\\(\\s*$/, \"\")\n    end\n    if group1\n      parse_nested_parens(group1)\n\
    \    else\n      group2\n    end\n  end\nend", "  paren_count = 0\n  paren_stack\
    \ = []\n  \n  paren_string.scan(/\\(/) do |match|\n    paren_stack.push paren_count\n\
    \    paren_count += 1\n  end\n  \n  paren_stack.each do |paren_count|\n    paren_string.scan(/[\\\
    (\\)]/) do |match|\n      if paren_stack.pop == paren_count\n        paren_count\
    \ += 1\n      end\n    end\n  end\n  \n  paren_count\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI like the approach, however it does not work for `((()))`. With\
    \ this input, `paren_stack.last` will return 3, and `paren_stack.last(-1).to_i`\
    \ will return 2.\n<|/ c |>\n<| c |>\nYeah it fails for `((((())))`. I suppose\
    \ the algorithm should just check if the last element of the stack is `()` and\
    \ if so count it as one level of nesting.\n<|/ c |>\n<| a dscore=1 |>\nI came\
    \ up with this\n<code>", "  paren_count = 0\n  level_stack = []\n  paren_string.split('\
    \ ').each { |parens| \n    if parens.nil? or parens.empty?\n      level_stack.push\
    \ paren_count\n      paren_count = 0\n    elsif parens == \"(\"\n      paren_count\
    \ += 1\n    elsif parens == \")\"\n      paren_count -= 1\n    end\n    if paren_count\
    \ == 0\n      if level_stack.empty?\n        return level_stack\n      else\n\
    \        return level_stack.shift\n      end\n    end\n  }\nend", "\ttokens =\
    \ paren_string.scan(/\\(|\\s|[\\s]|\\n/)\n\tlevel = 1\n\tgroups = []\n\tgroups.concat(tokens)\
    \ # Copy tokens into the groups to keep them in order\n\ttokens.delete_if { |t|\
    \ t == \")\" } # Remove all \")\" from the tokens\n\ttokens.delete_if { |t| t\
    \ == \")\\n\" } # Remove all \"\\n\" from the tokens", "  level = 0\n  nested_paren_group\
    \ = nil\n  paren_string.scan(/[()]/) do |char|\n    if char == '('\n      level\
    \ += 1\n    elsif char == ')'\n      level -= 1\n    end\n    if level > 0\n \
    \     nested_paren_group = char\n      break\n    end\n  end\n  nested_paren_group\n\
    end", "  if paren_string.empty?\n    return 0\n  level = 0\n  paren_count = 0\n\
    \  paren_stack = [paren_count]\n  paren_stack.each do |i|\n    if paren_string.slice(i..-1).include?('(')\n\
    \      paren_count += 1\n      paren_stack.push(paren_count)\n    else\n     \
    \ paren_stack.pop\n      level -= 1\n    end\n  end\n  return level\nend", " \
    \ level = 0\n  paren_count = 0\n  result = []\n  input_list = paren_string.split(\"\
    \ \")", "  paren_string.scan(/(?:\\(|\\))|[^\\(\\)]+(?:\\([^\\(\\)]+\\))*/).map\
    \ {|x| x.count(\"(\") - x.count(\")\")}.max\nend", "  return paren_string.split('\
    \ ').reverse.reduce(:+)\nend", "  # Initialize a stack to keep track of parens\n\
    \  paren_stack = []\n  # Initialize a counter to keep track of level of nesting\n\
    \  max_level = 0\n  paren_count = 0\n  \n  paren_string.split(\" \").each do |paren_string|\n\
    \    # If the string contains at least one open paren, push it to the stack\n\
    \    if paren_string.include?(\"(\")\n      paren_stack.push(paren_string)\n \
    \     paren_count += 1\n    \n    # If the string contains at least one close\
    \ paren, pop out as many open parens as there are\n    elsif paren_string.include?(\"\
    )\")\n      while paren_stack.last.include?(\"(\")\n        paren_stack.pop\n\
    \      end\n      \n      # If the number of opened parens equals the maximum\
    \ number of levels of nesting, pop out any opening parens\n      # that remain\
    \ in the stack\n      if paren_count == max_level\n        paren_stack.last.split(\"\
    (\").each do |paren_string|\n          paren_stack.pop\n        end\n      end\n\
    \      \n      paren_count -= 1\n    end\n    \n    # If the stack is empty, exit\
    \ the loop\n    if paren_stack.size == 0\n      return max_level\n    end\n  \
    \  \n    # If the stack is unbalanced, output the maximum level of nesting\n \
    \   if paren_stack.size != paren_stack.last.size\n      return max_level\n   \
    \ end\n    \n    max_level = paren_stack.last.size\n  end\n  \n  0\nend", "  paren_level\
    \ = 0\n  max_level = 0\n  output = []\n  input = paren_string.split(' ')", " \
    \ paren_string_arr = paren_string.split(\" \")\n  max_level = 0\n  max_level_arr\
    \ = []", "    # Initialize a counter to keep track of the deepest level of nesting\
    \ in the parentheses.\n    max_depth = 0", "  parsed_strings = paren_string.scan(/\\\
    (.*?\\)/g).map do |match|\n    match = match.split('(')\n    match.last += ')'\
    \ if match.last && match.last.include?(')')\n    match\n  end\n  parsed_strings.reduce(0)\
    \ { |sum, string| sum + calc_max_level(string) }\nend", "    level = 0\n    nested_parens\
    \ = []\n    paren_string.each_char.with_index do |character, index|\n        if\
    \ character == \"(\"\n            level += 1\n            nested_parens << [index]\n\
    \            nested_parens.last.push([]) if nested_parens.last == nested_parens[-2]\n\
    \        elsif character == \")\"\n            level -= 1\n            nested_parens[-2].last.push(index)\
    \ if nested_parens[-2].last == nested_parens[-1]\n        end\n    end\n    nested_parens.map\
    \ { |level, nested| nested.map { |n| paren_string[n] } }\nend", "  groups = paren_string.split(\"\
    \ \").group_by{|x| x}\n  max_nesting = groups.max_by {|k, v| v}.values.count\n\
    \  max_nesting == 1 ? 1 : max_nesting - 1\nend", "  depth = 0\n  result = \"\"\
    \n  last_index = paren_string.rindex(\"(\")\n  paren_string.slice!(last_index+1)\n\
    \  paren_string.slice!(-1) if paren_string[-1] == ?(\n  while paren_string.length\
    \ > 0\n    if paren_string[0] == ?(\n      depth += 1\n    elsif paren_string[0]\
    \ == ?(\n      depth -= 1\n    end\n    result += paren_string.slice!(0)\n   \
    \ paren_string.slice!(0)\n  end\n  return result\nend\n</code>\n<|/ a tags=ruby,string\
    \ dscore=1 |>\n<| a dscore=0 |>\nThis works for a given string and gives the answer\
    \ as a string as well.\n<code>", "  paren_string = paren_string.chomp\n  paren_groups\
    \ = paren_string.gsub('[(()]', '').split \n  paren_groups.length.times do |i|\n\
    \    next if paren_groups[i].empty?\n    paren_groups[i] = paren_groups[i].gsub('(',\
    \ '')\n    paren_groups[i] = paren_groups[i].gsub(')', '')\n    level = parse_paren_group(paren_groups[i])\n\
    \    puts \"#{paren_groups[i]} has maximum level of nesting #{level}. \" if level\
    \ > 0\n  end\nend\n</code>\nSample output with paren_string = \"(()())\":\n<code>\n\
    (()()) has maximum level of nesting 3. \n((())) has maximum level of nesting 2.\
    \ \n</code>\n<|/ a tags=regex,ruby,ruby-on-rails |>\n<| c |>\nThe accepted answer\
    \ is not only very informative but also provides the correct solution to OP's\
    \ problem. Thanks for posting your solution.\n<|/ c |>\n<| a |>\nThis is a pure\
    \ regex solution to solve your problem:\n<code>\nregex = /(\\(+\\))+/g\n</code>\n\
    A sample run:\n<code>\nputs regex.match \"(()())\" # => #<MatchData \"(()())\"\
    >\n</code>\n<|/ a tags=regex,ruby,ruby-on-rails dscore=2 |>\n<| c |>\nPlease consider\
    \ adding a description of your regex pattern or else this answer can be deleted.\n\
    <|/ c |>\n<| a tags=regex,ruby,ruby-on-rails dscore=2 |>\n<code>\nparens = \"\
    (()()\"", '  paren_stack = []', "  level = 0\n  groups = []\n  string_without_parens\
    \ = paren_string.gsub(/\\(|\\)| /, '')\n  string_without_parens.scan(/[^()]+/)\
    \ {|e| groups << e}\n  groups.each do |group|\n    level = 0\n    if group.gsub!(/\\\
    (|\\)|\\)/, '')\n      levels.times do |i|\n        level += 1\n      end\n  \
    \  end\n  end\nend", "  paren_depth = 0\n  levels = []\n  while paren_string\n\
    \    depth = 0\n    paren_level = 0\n    paren_string = paren_string.strip", " \
    \ paren_stack = []\n  paren_stack_depth = 0\n  paren_depth = 0\n  paren_opening_positions\
    \ = []\n  paren_closing_brackets = []\n  paren_closing_brackets_positions = []\n\
    \  paren_string.split(\" \").each do |paren_string|\n    if paren_string == \"\
    (\"\n      if paren_stack.length > 0\n        paren_stack.push paren_opening_positions[paren_stack_depth]\n\
    \      end\n      paren_depth += 1\n      paren_opening_positions << paren_depth\n\
    \    elsif paren_string == \")\"\n      if paren_depth == 0\n        paren_stack.push\
    \ paren_closing_brackets[paren_stack_depth]\n        paren_closing_brackets.pop\n\
    \      end\n      paren_depth -= 1\n      paren_closing_brackets_positions <<\
    \ paren_depth\n    elsif paren_depth == 0\n      paren_stack.push paren_string\n\
    \    end\n  end\n  paren_stack.each do |paren_string|\n    paren_string.length.downto(paren_stack_depth)\
    \ do |paren_depth|\n      current_level_string = paren_stack[paren_depth]\n  \
    \    current_level_string.length.downto(paren_depth - 1) do |paren_depth|\n  \
    \      current_level_string = current_level_string + paren_stack[paren_depth]\n\
    \      end\n      output_string = output_string + current_level_string\n    end\n\
    \  end\n  return output_string\nend", "  paren_string.scan(/[\\(\\)]+(?:[\\(\\\
    )]+[\\(\\)]+)*\\z/) do |group|\n    group.scan(/[\\(\\)]+(?:[\\(\\)]+[\\(\\)]+)*\\\
    z/) do |level|\n      level\n    end.compact.length\n  end\nend", "  paren_stack\
    \ = []\n  depth = 0\n  output = ''\n  paren_string.split(\" \").each do |element|\n\
    \    if paren_stack.length == 0\n      output += element\n    elsif paren_stack[-1].length\
    \ == element.length\n      paren_stack.pop\n      output += element\n    else\n\
    \      output += paren_stack.push(element)\n    end\n  end\n  paren_stack.each\
    \ do |el|\n    output += el\n  end\n  output\nend", "  levels = []\n  paren_stack\
    \ = []\n  paren_count = 0\n  open_count = 0\n  closed_count = 0\n  in_parens =\
    \ 0\n  paren_char = ''\n  paren_nesting = 0", "  paren_count = 0\n  paren_stack\
    \ = []\n  groups = []", "  paren_arr = paren_string.split(\" \")\n  max_level\
    \ = 0\n  max_level_i = 0\n  max_level_paren_count = 0\n  for i in 0..paren_arr.length\n\
    \    if paren_arr[i].empty?\n      max_level = i\n      max_level_i = i\n    \
    \  max_level_paren_count = 1\n    else\n      current_level = 0\n      current_level_paren_count\
    \ = 1\n      while paren_arr[i].include?('(')\n        current_level += 1\n  \
    \      current_level_paren_count += 1\n        if current_level_paren_count >\
    \ max_level_paren_count\n          max_level = i\n          max_level_i = i\n\
    \          max_level_paren_count = current_level_paren_count\n        end\n  \
    \      i += 1\n      end\n      while paren_arr[i].include?(')')\n        current_level\
    \ -= 1\n        current_level_paren_count -= 1\n        if current_level_paren_count\
    \ < max_level_paren_count\n          max_level = i\n          max_level_i = i\n\
    \          max_level_paren_count = current_level_paren_count\n        end\n  \
    \      i += 1\n      end\n    end\n  end\n  max_level\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,regex |>\nHere is another solution:\n<code>", "  paren_count =\
    \ 0\n  current_level = 0\n  nested_paren_stack = []\n  nested_paren_stack.push([paren_count,\
    \ current_level, paren_string])", "  paren_string.gsub!('(', '').gsub!(')', '')",
  "  paren_depth = 0\n  paren_stack = []\n  paren_stack << paren_string\n  while paren_depth\
    \ < paren_stack.size\n    if paren_stack[paren_depth] == '('\n      paren_depth\
    \ += 1\n    elsif paren_stack[paren_depth] == ')'\n      paren_depth -= 1\n  \
    \  else\n      puts \"Invalid parentheses level: #{paren_stack[paren_depth]}\"\
    \n      break\n    end\n    paren_stack << paren_stack[paren_depth + 1]\n  end\n\
    end", "  parens = paren_string.split(/\\s*\\((.+?)\\)\\s*/)\n  parens.map do |paren|\n\
    \    level = 0\n    (paren.gsub(/\\(/, '').length).times do |i|\n      level +=\
    \ 1\n      if paren[(i+1)...paren.length] == ')'\n        break\n      end\n \
    \   end\n    level\n  end\nend", "  # Initialize a stack to hold each level of\
    \ nesting.\n  level_stack = []", "  paren_string = paren_string.strip\n  return\
    \ paren_string.split(' ').inject({}) {|memo, s| memo[s] = {} unless memo.has_key?(s);\
    \ memo[s][:level] = memo[s][:level] + 1; memo[s][:parens] = [] unless memo[s][:parens];\
    \ memo[s][:parens].push(s); memo[s][:parens].flatten.max }\nend", "  paren_count\
    \ = 0\n  nested_count = 0\n  paren_depth = 0\n  result = \"\"\n  nested_parens\
    \ = nil\n  paren_string.split(\" \").each do |word|\n    if word == \"(\"\n  \
    \    paren_depth += 1\n      nested_count += 1\n    elsif word == \")\"\n    \
    \  nested_count -= 1\n      paren_depth += 1\n    elsif word == \"(\"\n      nested_count\
    \ += 1\n      nested_parens = paren_depth\n    elsif word == \")\"\n      nested_count\
    \ -= 1\n      nested_parens = paren_depth if nested_count < 0\n    elsif nested_count\
    \ > 0\n      result << word\n    end\n  end", "  paren_level = 0\n  open_count\
    \ = 0\n  close_count = 0\n  paren_string.each_char do |c|\n    if c == ')'\n \
    \     close_count += 1\n      if open_count > close_count\n        paren_level\
    \ = open_count - close_count\n        break\n      end\n    else\n      open_count\
    \ += 1\n    end\n  end\n  return paren_level\nend", "  paren_counts = paren_string.scan(/\\\
    ((\\))|(\\(\\))|(\\((\\)))|(\\((\\()|(\\)()\\)))/)\n  paren_counts.count('(')\n\
    end\n</cell>\n<cell>", "  paren_string.chomp!\n  paren_string.gsub!(/[\\(\\)]/,\
    \ '')\n  paren_string.gsub!(/(^|\\s)\\(([^\\)]+)\\)($|\\s)/) do |match|\n    open_paren_count\
    \ = close_paren_count = 0\n    match.gsub!(/\\s+/, '').split(', ').each do |paren|\n\
    \      if paren == paren[0..1]\n        open_paren_count += 1\n      else\n  \
    \      close_paren_count += 1\n      end\n    end\n    open_paren_count == close_paren_count\
    \ ? match.gsub(/^\\(/, '').gsub(/\\)/, '') : match\n  end\n  paren_string.gsub(/(^|\\\
    s)\\(([^\\)]+)\\)($|\\s)/) do |match|\n    open_paren_count = close_paren_count\
    \ = 0\n    match.gsub!(/\\s+/, '').split(', ').each do |paren|\n      if paren\
    \ == paren[0..1]\n        open_paren_count += 1\n      else\n        close_paren_count\
    \ += 1\n      end\n    end\n    open_paren_count == close_paren_count ? match.gsub(/^\\\
    (/, '').gsub(/\\)/, '') : match\n  end\n  paren_string.chomp\nend", "  # Initialize\
    \ the stack with parentheses level as 1\n  stack = []\n  # Split the string by\
    \ spaces and store each element in a hash\n  paren_hash = {}\n  paren_string.split('\
    \ ').each do |paren|\n    # If the current level is greater than the max level\
    \ yet encountered, then reset it back to the 1\n    level = (paren_hash[paren]\
    \ ||= 1)\n    # If the current level is less than the max level yet encountered,\
    \ then increment the level\n    level += 1 if paren_hash[paren] > level\n    #\
    \ Add the current level to the stack\n    stack.push(level)\n  end", "  paren_string.scan(/[\\\
    (\\)]/) do |group|\n    parsed_paren_group = []\n    group.scan(/[\\(\\)]/) do\
    \ |group|\n      if group.nil? || group[0] == ?(\n        parsed_paren_group <<\
    \ group\n      else\n        parsed_paren_group.push \"(\" + group + \")\"\n \
    \     end\n    end\n    return parsed_paren_group\n  end\nend", "  return get_maximum_nesting_level(paren_string)\n\
    end", "  max_level = 0\n  open_parens = 1\n  paren_stack = [paren_string]\n  open_paren_levels\
    \ = Hash.new(0)\n  paren_levels = Hash.new(0)\n  paren_openings = Hash.new(0)\n\
    \  \n  while paren_stack.any?\n    paren_string = paren_stack.pop\n    open_parens\
    \ = open_paren_levels[paren_string]\n    if open_paren_levels[paren_string] ==\
    \ nil\n      # This is the first open paren encountered.\n      # Initialize open\
    \ paren level to 1.\n      open_paren_levels[paren_string] = 1\n    else\n   \
    \   # Increment the open paren level.\n      open_paren_levels[paren_string] +=\
    \ 1\n    end", "  paren_array = paren_string.split(' ')\n  paren_stack = []",
  "  paren_count = 0\n  level = 0\n  parens = []\n  parsed_parens = []\n  stack =\
    \ [paren_string]", "  max_nesting = 0\n  groups = paren_string.split(\" \").groups()\n\
    \  groups.each { |x| max_nesting = x.count(\"(\") > x.count(\")\") ? x.count(\"\
    (\") : x.count(\")\") > x.count(\"(\") ? x.count(\")\") : max_nesting }\n  return\
    \ max_nesting\nend", "    paren_count = 0\n    paren_level = 0\n    paren_start_index\
    \ = 0\n    paren_end_index = 0\n    level_stack = []\n    group_stack = []\n \
    \   i = 0\n    while(i < paren_string.length)\n        if paren_string[i] == '('\n\
    \            paren_count += 1\n            group_stack = []\n            level_stack\
    \ = []\n            paren_end_index = paren_count\n            paren_start_index\
    \ = i\n            paren_level += 1\n            i += 1 #skip '('\n        elsif\
    \ paren_string[i] == ')'\n            if paren_count == 0\n                level_stack\
    \ = []\n                group_stack = []\n            paren_count -= 1\n     \
    \       group_stack.pop\n            level_stack.pop\n            i += 1 #skip\
    \ ')'\n        elsif paren_string[i] == ' '\n            i += 1\n        end\n\
    \        group_stack.push paren_string[i]\n    end\n    return group_stack\nend",
  "  level = 0\n  depth = 0\n  paren_stack = []\n  nesting = 0\n  while level < max_nesting\
    \ && depth < max_depth\n    # Pop stack as long as it contains only '(' and ')'.\n\
    \    while paren_stack.count > 0 && paren_stack.last != '(' && paren_stack.last\
    \ != ')'\n      paren_stack.pop\n    end\n    # Pop stack as long as it contains\
    \ '(' or ')'.\n    while paren_stack.count > 0 && paren_stack.last != '(' && paren_stack.last\
    \ != ')'\n      paren_stack.pop\n    end\n    if paren_stack.count == 0 || paren_stack.last\
    \ == ')'\n      depth += 1\n    else\n      depth -= 1\n    end\n    level +=\
    \ 1\n    if paren_stack.count == 0\n      nesting -= 1\n    end\n    paren_stack.push\
    \ \"(#{paren_string[level]})\"\n  end\n  paren_stack.reverse!\n  return paren_stack\n\
    end", "  paren_stack = []\n  i = 0\n  while i < paren_string.length\n    if paren_string[i]\
    \ =~ /^[()]/\n      if paren_stack.length == 0\n        paren_stack.push paren_string[i]\n\
    \      else\n        if paren_stack.last.length >= paren_string[i].length\n  \
    \        paren_stack.push paren_string[i]\n        else\n          paren_stack.pop\n\
    \        end\n      end\n    else\n      paren_stack.push paren_string[i]\n  \
    \  end\n    i += 1\n  end", "  # Initialize empty array to store parsed groups\n\
    \  parsed_groups = []\n  # Initialize a counter to store current level of nesting\n\
    \  counter = 0\n  # Loop through paren_string, add each char to parsed_groups\
    \ array, check if char is '(', increment counter\n  parsed_groups.concat(paren_string.split('\
    \ ').collect do |char|\n    # Ignore empty strings\n    next if char.empty?\n\
    \    # Add char to parsed_groups\n    parsed_groups << char\n    # Check if char\
    \ is '(', increment counter\n    counter += 1 if char == '('\n    # Check if char\
    \ is ')', decrement counter\n    counter -= 1 if char == ')'\n    # Return counter\
    \ if it is greater than zero\n    counter if counter > 0\n  end)\n  # Return parsed_groups\n\
    \  parsed_groups\nend", "  tokens = paren_string.split(\" \")\n  max_level = -1\n\
    \  current_level = 0\n  groups = []\n  index = 0\n  while index < tokens.length\n\
    \    if tokens[index].match?(/\\(/)\n      current_level += 1\n      groups.push([])\n\
    \    elsif tokens[index].match?(/\\)/)\n      groups.pop\n      current_level\
    \ -= 1\n    elsif current_level > max_level\n      max_level = current_level\n\
    \    end\n    index += 1\n  end\n  return max_level, groups\nend", "  paren_count\
    \ = 0\n  paren_stack = []\n  while paren_count > 0\n    paren_count += 1\n   \
    \ paren_stack.push paren_string[paren_count-1]\n    if paren_stack.count > paren_count\
    \ + 1\n      break\n    end\n  end\n  paren_count = 0\n  paren_stack = []\n  while\
    \ paren_count < paren_string.length\n    paren_stack.push paren_string[paren_count]\n\
    \    paren_count += 1\n    if paren_stack.count < paren_count\n      break\n \
    \   end\n  end\n  paren_stack.count.times{ paren_stack.delete }\nend", "  nesting\
    \ = paren_string.count(\"(\") - 1\n  \n  paren_level = 0\n  paren_stack = []\n\
    \  paren_stack.push(0)\n  \n  while paren_stack.count > nesting\n    paren_level\
    \ = paren_stack.pop\n    \n    if paren_level == 0\n      paren_stack.push(1)\n\
    \    else\n      paren_stack.push(paren_level + 1)\n  end\n  \n  paren_level\n\
    end", "  result = paren_string.count(\"(\")\n  paren_count = 1\n  while result\
    \ > paren_count\n    paren_string.count(\"(\")\n    paren_count += 1\n    result\
    \ = paren_string.count(\"(\")\n  end\n  return paren_count\nend", "  paren_level\
    \ = 0\n  paren_depth = 0\n  groups = []\n  group_index = 1\n  bracket_level =\
    \ 0\n  bracket_depth = 0\n  bracket_opened = false\n  bracket_closed = false\n\
    \  \n  paren_string.split(\" \").each do |character|\n    if character == '('\n\
    \      paren_level += 1\n      bracket_opened = true\n    elsif character == ')'\n\
    \      paren_level -= 1\n      bracket_closed = true\n      \n      # Add all\
    \ previous groups to output if there are any\n      if !bracket_opened && paren_level\
    \ > 0 && !bracket_closed\n        groups.each do |group|\n          output.push(\"\
    #{group}\")\n        end\n      end\n    elsif character == '['\n      bracket_depth\
    \ += 1\n    elsif character == ']'\n      bracket_depth -= 1\n    end\n    \n\
    \    if bracket_level >= 0 && !bracket_opened\n      group_index += 1\n      groups\
    \ = []\n    elsif bracket_level == 0 && bracket_depth <= 0\n      groups << \"\
    [#{group_index}]\"\n    end\n  end\n  \n  # Add all previous groups to output\
    \ if there are any\n  if !bracket_opened && paren_level > 0 && !bracket_closed\n\
    \    groups.each do |group|\n      output.push(\"#{group}\")\n    end\n  end\n\
    end", "    level = 0\n    paren_count = 0\n    \n    # Traverse the string to\
    \ count the level of nesting.\n    # This step is done using two stacks instead\
    \ of recursion\n    # to avoid memory overflow problems caused by the stack\n\
    \    # growing unboundedly when deeply nested parentheses appear.\n    open_stack\
    \ = []\n    close_stack = []\n    open_stack << paren_string\n    while open_stack.size\
    \ > 0 do\n        paren_string = open_stack.pop\n        if paren_string == '('\
    \ then\n            paren_count += 1\n            if open_stack.size < close_stack.size\
    \ then\n                open_stack << paren_string\n            else\n       \
    \         close_stack << paren_string\n            end\n        else\n       \
    \     if paren_count == 0 then\n                open_stack << paren_string\n \
    \           else\n                close_stack << paren_string\n            end\n\
    \        end\n    end\n    \n    return close_stack\nend", "  paren_level = 0\n\
    \  parens = []\n  paren_string = paren_string.strip", "  level = 0\n  nested_paren_string\
    \ = paren_string\n  paren_index = 1", "  tokens = paren_string.scan(/\\(.*?\\\
    )/)\n  tokens.map do |token|\n    if token.length >= 1\n      parse_nested_parens(token)\n\
    \    else\n      token\n    end\n  end.max_by { |s| s.length }\nend", "  group_strings\
    \ = paren_string.split(' ')\n  groups = []\n  depth = 0\n  while group_strings.length\
    \ > 0\n    group_string = group_strings[0]\n    group_strings = group_strings.slice(1,group_strings.length)\n\
    \    depth += 1\n    groups.push(group_string)\n  end\n  return [groups,depth]\n\
    end", "  # Recursive function.\n  def parse()\n    level = 0\n    stack = []\n\
    \    # Parse the string one character at a time into the stack\n    paren_string.each_char\
    \ do |char|\n      if char == '('\n        level += 1\n        stack << char\n\
    \      elsif char == ')'\n        level -= 1\n        if level == 0\n        \
    \  return stack\n        else\n          stack.pop\n        end\n      end\n \
    \   end\n    # Didn't find any closing parentheses\n    return nil\n  end\n  #\
    \ Recursive call.\n  parse()\nend", "  paren_count = paren_string.count('(')\n\
    \  nesting_level = paren_count\n  paren_string.gsub!(/\\(.*?\\)/, '') # Remove\
    \ all parentheses.\n  while paren_string.count('(') != paren_count\n    paren_string.gsub!(/\\\
    ((.*?)\\)/, '') # Remove one set of parentheses.\n    paren_count = paren_string.count('(')\n\
    \    nesting_level -= 1\n  end\n  nesting_level += 1\n  return nesting_level\n\
    end", "  paren_count = 0\n  paren_stack = []\n  paren_level = 0\n  paren_start\
    \ = 0", "  level = 0\n  groups = paren_string.scan(/[^()]+/)\n  groups.each_with_index\
    \ do |group, index|\n    level_length = group.count('(') - group.count(')')\n\
    \    if level_length > level\n      level = level_length\n    end\n  end\n  return\
    \ level\nend", "\tdepth = 0\n\tmax_depth = 0\n\tparens = paren_string.split(\"\
    \ \")\n\tparens.map! do |str|\n\t\tstr = str.tr(\" \", \"+\")\n\t\tstr = str.tr(\"\
    (\", \"(\")\n\t\tstr = str.tr(\")\", \")\")\n\t\tstr.downcase!\n\tend", "  paren_string.scan(/[(]+/).each\
    \ do |paren_string|\n    group_nesting = paren_string.count(\"()\")\n    if group_nesting\
    \ > max_nesting or paren_string == \"(\" # Handle first level nesting\n      max_nesting\
    \ = group_nesting\n    else\n      if paren_string == \"(\" # Handle second level\
    \ nesting\n        max_nesting += 1\n      else # Handle third level nesting\n\
    \        max_nesting += 2\n      end\n    end\n  end\n  max_nesting\nend", " \
    \ level = 0\n  parentheses = paren_string.count(\"(\", paren_string.count(\")\"\
    ) + 1)\n  result = 1\n  while (result < parentheses) do\n    level += 1\n    result\
    \ = (level * level) + (parentheses - level)\n  end\n  level - 1\nend", "  levels_of_nesting\
    \ = []\n  paren_groups = paren_string.split(\" \").map(&:to_i)\n  paren_groups.each_with_index\
    \ { |g, i| levels_of_nesting.push(0) if g > paren_groups[i] }\n  levels_of_nesting.pop.times\
    \ { levels_of_nesting.shift }\n  levels_of_nesting\nend", "  depth = 0\n  paren_string.scan(/[\\\
    (\\)]+/.) do |paren_string|\n    depth += 1 if paren_string[0] == '('\n    depth\
    \ += 1 if paren_string[0] == ')'\n  end\n  depth\nend", "  paren_string = paren_string.tr('()',\
    \ ' ')\n  paren_string = paren_string.tr(')', ' ')\n  paren_string = paren_string.tr('(',\
    \ ' ')\n  paren_string = paren_string.tr(')', ' ')", "\tparen_string_arr = paren_string.split(/\\\
    )\\s+\\(\\)\\s+/)\n\t\n\t\n\tmax_level = paren_string_arr.map { |str| str.count('(')\
    \ - str.count(')')}.max\n\t\n\treturn max_level\nend", "  paren_string.split(/\\\
    s+/).reduce(:+)\nend", "\tresult = \"\"\n\tstack = ParenStack.new\n\tbegin = 0\n\
    \tend = 0\n\t\n\tparen_string.scan(/[\\(\\)]/) {\n\t\tbegin = $&\n\t\tstack.push(begin)\n\
    \t}", "  paren_string = paren_string.split(\" \").map { |group| group.gsub(\"\
    [()]\", \"\") }\n  nested_parens_level = paren_string.map { |group| group.count(\"\
    (\") }.max\n  paren_string.map { |group| parse_nested_parens(group).max }.max\n\
    end", "  paren_count = 0\n  parsed_string = \"\"\n  level = 0\n  last_string =\
    \ paren_string\n  for i in 0...paren_string.length\n    if paren_count > 0 &&\
    \ paren_count > level\n      parsed_string += last_string\n      last_string =\
    \ paren_string.slice!(i..paren_string.length)\n    else\n      last_string +=\
    \ paren_string[i]\n      parsed_string += last_string[1..-1]\n    end\n    paren_count\
    \ += 1\n  end\n  parsed_string += last_string\n  return parsed_string\nend", " \
    \ parsed_parens = Array.new\n  parentheses_count = 0\n  paren_count = 0\n  paren_group_count\
    \ = 0\n  \n  paren_string.split(\" \").each do |nested_paren|\n    if nested_paren.empty?\n\
    \      break\n    end\n    \n    if nested_paren.include?(\"(\")\n      parentheses_count\
    \ += 1\n      \n      if paren_count > paren_group_count\n        parsed_parens[paren_group_count]\
    \ = Array.new\n        parsed_parens[paren_group_count] << nested_paren\n    \
    \  else\n        parsed_parens[paren_count] << nested_paren\n      end\n     \
    \ \n      paren_group_count += 1\n    end\n    \n    if nested_paren.include?(\"\
    )\")\n      parentheses_count -= 1\n      \n      if parentheses_count == 0\n\
    \        parsed_parens << parsed_parens[paren_group_count]\n        paren_group_count\
    \ -= 1\n      end\n    end\n    \n    paren_count += 1\n  end\n  \n  parsed_parens\n\
    end", "    nest = 0\n    paren_level = nil\n    in_parentheses = false\n    stack\
    \ = []\n    paren_string.split(\"\\n\").each do |line|\n        line.chomp! if\
    \ line.chomp.empty?\n        line.scan(/[()]/).each do |symbol|\n            in_parentheses\
    \ = true if symbol == '('\n            paren_level = nest if in_parentheses\n\
    \            stack.push(symbol) if symbol != ')'\n        end\n        stack.push(nil)\
    \ if in_parentheses\n        stack.each do |symbol|\n            nest = symbol.length\
    \ if nest.nil? or symbol != nest\n        end\n        nest = stack.last.length\
    \ if nest.nil?\n    end\n    nest\nend", "  paren_string.scan(/(?<open>[(]?)\\\
    ((?<-open>[)]?)\\)(?<-open>\\1\\)?/x) do |match|\n    unless match.to_s.empty?\n\
    \      depth = match.to_s.count(\"(\") - match.to_s.count(\")\")\n      yield\
    \ \"(\" until depth == 0\n      yield match\n      yield(match.to_s.count(\"(\"\
    ) - match.to_s.count(\")\")) until depth == 0\n      yield \")\"\n    end\n  end\n\
    end", "  paren_array = paren_string.split(\"\\(\\)\")\n  result_paren_array =\
    \ []\n  current_level = 0\n  for i in 0..paren_array.count-1\n    if (paren_array[i].count(\"\
    (\") > paren_array[i].count(\")\"))\n      current_level = current_level + 1\n\
    \    else # if (paren_array[i].count(\"(\") == paren_array[i].count(\")\"))\n\
    \      current_level = current_level - 1\n    result_paren_array << paren_array[i]\
    \ if (current_level > 0)\n  end\n  return result_paren_array\nend\n</code>\n<|/\
    \ a tags=parentheses,string,ruby,parsing |>\n<| a dscore=0 |>\nHere's a recursive\
    \ solution:\n<code>", "  paren_string.split(\" \").map.with_index.with_object([]).map\
    \ { |level, i| parse_nested_parens_helper(paren_string, level, i)}.max { |a, b|\
    \ b }\nend\n</code>\nThis can be used in your example:\n<code>\nparen_string =\
    \ \"()() ()() ()() ()\"\nparse_nested_parens(paren_string).inspect", "  # Count\
    \ number of open parenthesis \n  open_count = 1\n  \n  # Iterate through the string\
    \ and count the number of open parenthesis\n  paren_string.each_byte do |char|\n\
    \    if char == '('\n      open_count += 1\n    elsif char == ')'\n      open_count\
    \ -= 1\n    end\n    \n    if open_count == 0\n      # If all parentheses are\
    \ closed then return open_count\n      return open_count\n    end\n  end\n  \n\
    \  # If there are no open parentheses, return nil\n  return nil\nend", "  paren_string\
    \ = paren_string.dup\n  max_level = nil\n  level = 0\n  paren_level = 0", "  paren_string.scan(/\\\
    (.*?\\)/).each do |group|\n    return group if paren_string.start_with?(group)\n\
    \  end\n  ''\nend", "  paren_counts = Hash.new(0)\n  paren_string.split(\" \"\
    ).each do |paren|\n    levels = paren_counts[paren] || 0\n    paren_counts[paren]\
    \ = levels + 1\n  end\n  max_level_of_nesting = paren_counts.values.max_by(&:last)\n\
    \  max_level_of_nesting || 0\nend", "  paren_string = paren_string.gsub(/\\s+/,\
    \ \" \").gsub(/(.)(?=(.))/, '\\1\\2').downcase\n  return paren_string.scan(/(\\\
    ((?:[^()]*|(?R))*\\))/).flatten\nend", "  groups = paren_string.split(' ')\n \
    \ max_group_size = 0\n  max_group_index = 0", "  # Store the parentheses level\
    \ count here for returning.\n  levels_count = 0\n  # Initialize the return string.\n\
    \  ret = ''\n  # For every group of parentheses.\n  paren_groups.each{|g|\n  \
    \  # Get the contents of each group of parentheses and store in an array for recursion.\n\
    \    nested_parens = paren_string.gsub(/\\((.*?)\\)/, '').gsub(/\\(([^\\(\\)]+)\\\
    )/, '').split(\" \").map(&:strip)\n    # If a group of parentheses are found,\
    \ then check the number of nested parentheses to determine what level of nesting\
    \ to return.\n    if nested_parens.length >= 2\n      # Increment the level of\
    \ nesting by 1.\n      levels_count += 1\n      # Recursively check the level\
    \ of nesting.\n      ret = parse_nested_parens(nested_parens[0...nested_parens.length\
    \ - 1])\n      # If level of nesting is equal to or greater than the levels count\
    \ then stop the loop.\n      if levels_count >= levels_count \n        # Stop\
    \ the recursion at or before levels count.\n        return ret\n      end\n  \
    \  end\n  }\n  return ret\nend\n</code>\nTesting\nTest case 1: ((()))\n<code>\n\
    > paren_string = '((()))'\n> parse_nested_parens(paren_string)\n=> ')'\n</code>\n\
    Test case 2: (((()))))\n<code>\n> paren_string = '(((()))))'\n> parse_nested_parens(paren_string)\n\
    => ')'\n</code>\nTest case 3: (((())))\n<code>\n> paren_string = '(((())))'\n\
    > parse_nested_parens(paren_string)\n=> ''\n</code>\nTest case 4: ((()()()))\n\
    <code>\n> paren_string = '((()()()))'\n> parse_nested_parens(paren_string)\n=>\
    \ ''\n</code>\nTest case 5: (((()))))\n<code>\n> paren_string = '(((()))))'\n\
    > parse_nested_parens(paren_string)\n=> ''\n</code>\nTest case 6: (((()))))((()))\n\
    <code>\n> paren_string = '(((()))))((()))'\n> parse_nested_parens(paren_string)\n\
    => ''\n</code>\nTest case 7: (((())))((()()))\n<code>\n> paren_string = '(((())))((()()))'\n\
    > parse_nested_parens(paren_string)\n=> ''\n</code>\nTest case 8: (((())())))\n\
    <code>\n> paren_string = '(((())())))'\n> parse_nested_parens(paren_string)\n\
    => ''\n</code>\nTest case 9: (((()()()())))\n<code>\n> paren", "  stack = []\n\
    \  max_nesting = -1", "  brackets = paren_string.chars.count { |char|\n    char\
    \ == CHAR_LEFT_PARENTHESIS or char == CHAR_RIGHT_PARENTHESIS\n  }", "  level =\
    \ 0\n  max_level = 0\n  paren_array = []\n  paren_array[0] = [paren_string]\n\
    \  while (paren_array.length > 0)\n    level += 1\n    paren_array[0].pop(0) #\
    \ Remove the current paren_string from its paren array.\n    if paren_array.length\
    \ > 0\n      max_level = level\n    end\n    paren_array.each_with_index do |group,\
    \ index|\n      group = \"(#{group})\" if index == (paren_array.length - 1)\n\
    \      paren_array[index + 1] = group.split(\" \").map {|s| [s, index + 1]}.inject([])\
    \ do |(paren_str, paren_index), (group_str, group_index)|\n        ((paren_str[group_index]\
    \ == paren_str[group_index + 1]) ? paren_str : [paren_str[group_index], paren_str[group_index\
    \ + 1]]).join(\" \")\n      end\n    end\n  end\n  max_level\nend", "  if paren_string.empty?\n\
    \    raise ArgumentError, \"Empty parentheses\"\n  end", "  paren_string.split(\"\
    \ \").map {|s| parse(s)}.max { |a, b| b.level <=> a.level }\nend", "  paren_stack\
    \ = [paren_string]\n  paren_depth = 0", "  paren_stack = Array.new\n  paren_stack.push\
    \ \"[\"\n  paren_stack.push \"(\"\n  paren_stack.push \")\"\n  paren_stack.push\
    \ \"{\"\n  paren_stack.push \"}\"", "  i = 0\n  level = 0", "  max_level = 0\n\
    \  max_nesting = 0\n  levels_nesting = [[]]", "  paren_string.split(\" \").map{|paren_string|\
    \ parse_nested_parens(paren_string)}.reduce(:+)\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "  parentheses_groups = []\n  levels_stack = []\n  last_paren_index\
    \ = 0\n  groups = 0\n  paren_count = 0", "  paren_stack = paren_string.split(\"\
    \ \")\n  max_nesting = 0\n  nesting = 1\n  open_parens = []\n  nesting_level =\
    \ 0\n  while nesting <= max_nesting\n    current_index = open_parens.index(nesting_level-1)\n\
    \    if current_index > -1\n      current_paren = open_parens.pop(current_index)\n\
    \      open_parens.insert(current_index+1, current_paren)\n    else\n      current_paren\
    \ = open_parens.pop(nesting_level)\n      open_parens.insert(nesting_level+1,\
    \ current_paren)\n    nesting_level += 1\n    if nesting == max_nesting\n    \
    \  nesting_level -= 1\n      max_nesting -= 1\n    end\n  end\n  open_parens.reverse.each\
    \ do |paren_index|\n    if nesting_level > max_nesting\n      current_paren =\
    \ open_parens.pop(nesting_level)\n      open_parens.insert(nesting_level+1, current_paren)\n\
    \      nesting_level += 1\n    end\n  end\n  open_parens\nend", "    parsed_paren_array\
    \ = []\n    # parse all nested parens recursively\n    def parse(paren_string)\n\
    \        if (paren_string.empty?)\n            return parsed_paren_array\n   \
    \     if (paren_string.include?(\"(\"))\n            curr_array_element = paren_string[0..paren_string.index(\"\
    (\")]\n            curr_array_element = parse(curr_array_element)\n          \
    \  parsed_paren_array << curr_array_element\n        else\n            # parse\
    \ one level here\n            parsed_paren_array << paren_string\n        end\n\
    \    end\n    parse(paren_string)\nend", "  stack = []\n  stack_string = \"\"\n\
    \  open_count = 0\n  paren_count = 0\n  parentheses_count = 0\n  last_bracket\
    \ = 0", "  level = 1\n  stack = []\n  max_level = 0\n  paren_count = 0\n  in_group\
    \ = 1\n  result = \"\"\n  pos = 0\n  paren_stack = []\n  paren_stack[0] = pos\n\
    \  paren_stack.each_index do |i|\n    pos = paren_stack[i+1]\n    char = paren_string[pos]\n\
    \    if char == \"(\"\n      in_group = 1\n      level += 1\n    elsif char ==\
    \ \")\"\n      in_group = 0\n      level -= 1\n    elsif char == \" \"\n     \
    \ if in_group\n        result += char\n      end\n    elsif char == \"(\"\n  \
    \    paren_stack.push(i)\n      paren_count += 1\n    elsif char == \")\"\n  \
    \    paren_stack.pop\n      paren_count -= 1\n    end\n    if level > max_level\n\
    \      max_level = level\n    end\n  end\n  if paren_stack.size != paren_count\n\
    \    return \"\"\n  end\n  paren_count = 0\n  paren_stack.each_index do |i|\n\
    \    pos = paren_stack[i+1]\n    char = paren_string[pos]\n    if char == \"(\"\
    \n      in_group = 1\n      level += 1\n    elsif char == \")\"\n      in_group\
    \ = 0\n      level -= 1\n    elsif char == \" \"\n      if in_group\n        result\
    \ += char\n      end\n    elsif char == \"(\"\n      paren_stack.push(i)\n   \
    \   paren_count += 1\n    elsif char == \")\"\n      paren_stack.pop\n      paren_count\
    \ -= 1\n    end\n  end\n  if paren_stack.size != paren_count\n    return \"\"\n\
    \  end\n  result\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is good. I added\
    \ some comments explaining what the code is doing.\n<|/ c |>\n<| c |>\nThis is\
    \ a great answer! I ran into a problem when trying to use this on inputs with\
    \ multiple parentheses, for example `((()))`. To solve this problem I changed\
    \ `paren_stack = paren_stack[0,i]` to `paren_stack = paren_stack[i+1..-1]` on\
    \ line 12. Now it works on inputs with multiple parentheses.\n<|/ c |>\n<| c |>\n\
    This fails on inputs with multiple nested parentheses, but not nested parentheses.\n\
    <|/ c |>\n<| a tags=ruby,regex,parentheses |>\nHere's another solution:\n<code>",
  "  # Initialize a counter to keep track of the number of levels of nesting of parentheses.\n\
    \  max_level_of_nesting = 0\n  # Initialize an empty array to hold the number\
    \ of levels of nesting.\n  level_of_nesting = []\n  # Iterate over each character\
    \ of the string and store the number of levels of nesting for each character in\
    \ the string.\n  paren_string.chars.each do |character|\n    # Increment the levels\
    \ of nesting by the number of parentheses in the current character.\n    level_of_nesting\
    \ += 1 if character == '('\n    # Increment the levels of nesting by the number\
    \ of parentheses in the current character.\n    level_of_nesting += 1 if character\
    \ == ')'\n    # If the levels of nesting is greater than the current max, then\
    \ update the max and store the levels of nesting.\n    if level_of_nesting.length\
    \ > max_level_of_nesting\n      max_level_of_nesting = level_of_nesting.length\n\
    \    end\n  end\n  # Return the levels of nesting.\n  return level_of_nesting\n\
    end", "\tparen_string = paren_string.strip\n\tlevel = 0\n\tnested_paren_string\
    \ = \"\"\n\tfor i in 0...paren_string.length\n\t\tc = paren_string[i]\n\t\tnext\
    \ unless c\n\t\tnext if i == paren_string.length-1 || paren_string[i+1] == ')'\n\
    \t\tif c == '('\n\t\t\tlevel += 1\n\t\telsif c == '['\n\t\t\tlevel += 1\n\t\t\
    elsif c == ']'\n\t\t\tlevel -= 1\n\t\telsif c == ')'\n\t\t\tlevel -= 1\n\t\telsif\
    \ c == '['\n\t\t\tlevel += 1\n\t\telsif c == ']'\n\t\t\tlevel -= 1\n\t\telsif\
    \ c == '{' || c == '}'\n\t\t\tlevel = 0\n\t\telse\n\t\t\tlevel += 1\n\t\tend\n\
    \t\tnested_paren_string += c\n\tend\n\treturn level\nend", "  paren_level = 1\n\
    \  paren_stack = []\n  paren_str = paren_string.strip", "  level = 0\n  paren_string.chars.each\
    \ do |character|\n    if character == '('\n      level += 1\n    elsif character\
    \ == ')'\n      level -= 1\n    elsif level < 0\n      raise \"String '#{paren_string}'\
    \ contains a closing parenthesis without a matching opening.\"\n    end\n  end\n\
    \  level\nend", "  return parsed_string\nend", "  paren_string.split(\" \").each\
    \ do |group|\n    parse_depth(group) \n  end\nend", "  paren_level = 0\n  paren_counts\
    \ = Array.new\n  paren_groups = paren_string.split(' ')\n  paren_groups.each do\
    \ |group|\n    group.strip!\n    paren_counts[group] ||= 0\n    paren_counts[group]\
    \ += 1\n  end", "  paren_string.split(\"( )\").reduce(:+).to_i\nend", "  # A stack\
    \ for storing nesting level.\n  nested_levels = []", "  paren_string.scan(/\\\
    (([^()]*|(\\([^()]*\\)))*\\)/) do |level_string|\n    level_string.gsub!(/\\(/,\
    \ \"(\")\n    level_string.gsub!(/\\)/, \")\")\n    level_string.gsub!(/, /, \"\
    \ and \")\n    level_string.split.map { |element| element.gsub!(/\\)/, \")\")\
    \ }\n      .flatten.compact\n      .each_index {|index| paren_string[index] =\
    \ level_string[index]}\n  end\n  paren_string\nend\n</code>\nThe first three lines\
    \ of code convert a string with multiple groups for nested parentheses to an array\
    \ where each element of the array is a group of nested parentheses.\nThe next\
    \ three lines of code remove all whitespace and parentheses from each of the groups.\n\
    The next three lines of code convert the remaining groups into an array of strings\
    \ where each element of the array is a group of nested parentheses.\nThe next\
    \ three lines of code convert the remaining groups into an array of strings where\
    \ each element of the array is a group of nested parentheses.\nThe last three\
    \ lines of code convert the remaining groups into an array of strings where each\
    \ element of the array is a group of nested parentheses.\nThe last three lines\
    \ of code convert the remaining groups into an array of strings where each element\
    \ of the array is a group of nested parentheses.\nThe final three lines of code\
    \ convert the remaining groups into an array of strings where each element of\
    \ the array is a group of nested parentheses.\n<|/ a tags=parsing,ruby,nested,parentheses\
    \ |>\n<| c |>\nVery nice explanation.  I ran this through my code and came up\
    \ with this solution:", "  groups = paren_string.split(/\\s+/)\n  max_levels =\
    \ groups.inject(0) { |max_level, g| g.count('(') > g.count(')') ? max_level :\
    \ max_level + 1 }\n  return groups.map(&:length).max <= max_levels\nend", "  paren_count\
    \ = 0\n  paren_group = []\n  parens = []\n  paren_level = 1\n  paren_nesting =\
    \ 0\n  paren_chars = []", "  return get_max_nested_depth(paren_string.split('\
    \ '))\nend", "  level = 0\n  depth = 1\n  paren_count = 0\n  paranthese_stack\
    \ = []\n  result = \"\"\n  \n  paren_string.each do |c|\n    if c == \"(\"\n \
    \     paren_count += 1\n      paranthese_stack.push(level-1)\n      level += 1\n\
    \    elsif c == \")\"\n      depth = paren_count\n      level -= 1\n      paren_count\
    \ -= 1\n    elsif c == \" \"\n      result << \" \" * ((level - 1) * depth + paren_count\
    \ * 2)\n    elsif c == \",\"\n      result << \" \" * ((level - 1) * depth + paren_count\
    \ * 2 + 1)\n    elsif c == \"{\"\n      paranthese_stack.push(level - 1)\n   \
    \   level += 1\n    elsif c == \"}\"\n      depth = paranthese_stack.pop\n   \
    \   level -= 1\n    end\n  end\n  \n  result\nend", "  \n  parens = paren_string.split(\"\
    \ \")\n  maxlevel = parens[0].length\n  for i in 1..(parens.length)\n    maxlevel\
    \ = max(maxlevel, parens[i].length)\n  end\n  \n  paren_array = []\n  for i in\
    \ 0..maxlevel\n    paren_array << parens[i]\n  end\n  \n  paren_array.join(\"\"\
    )\nend", "\tnesting_level = 0\n\tparen_nesting = 0\n\tparen_group = paren_string.split('\
    \ ')\n\tparen_length = len(paren_group)\n\tparen_index = 0\n\tparen_stack = []",
  "  result = \"\"\n  \n  if paren_string.empty?\n    result\n  else\n    (group1,paren_groups)\
    \ = paren_string.split(\" \",2)\n    \n    if paren_groups.empty?\n      result\
    \ = paren_groups\n    else\n      parse_nested_parens(paren_groups).gsub!(/\\\
    (|\\)/,\"\")\n      result = parse_nested_parens(paren_groups).gsub(/\\)|\\)/,\"\
    \")\n    end\n    \n  end\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| c |>\nThank\
    \ you for posting such a detailed response. My question is actually about the\
    \ number of levels of nesting - any ideas?\n<|/ c |>\n<| c |>\nI think my code\
    \ is correct for that case. `((()))` has three levels of nesting, `((((())))`\
    \ has five. I tested it on some online regex checker and it seems working properly.\n\
    <|/ c |>\n<| c |>\nThank you for your time. The above is exactly what I was looking\
    \ for. I think I'm going insane trying to figure out how to do that in regex.\
    \ Thanks so much for your help!\n<|/ c |>\n<| c |>\n, if you like it, please upvote\
    \ it too. Thanks.\n<|/ c |>\n<| c |>\nSure, thank you. Sorry, I'm new here and\
    \ I'm not quite yet familiar with how things work.\n<|/ c |>\n<| a dscore=1 |>\n\
    You can do it with one line of code, using Array#group_by. I'm sure it can be\
    \ done with fewer lines. But it's more readable.\n<code>\nstr = \"((((()))))\"",
  "  nested_level = 0\n  paren_index = 1\n  while paren_index < paren_string.length\n\
    \    # Check if parenthesis has a higher level than previous level else add it\
    \ to current level and decrement the level\n    if paren_string[paren_index] ==\
    \ '('\n      nested_level = 1 if nested_level > 0 else nested_level - 1\n    \
    \  paren_index = paren_index + 1\n    elsif paren_string[paren_index] == '{'\n\
    \      nested_level = 1 if nested_level > 0 else nested_level - 1\n      paren_index\
    \ = paren_index + 1\n    elsif paren_string[paren_index] == '}'\n      nested_level\
    \ = 1 if nested_level > 0 else nested_level - 1\n      paren_index = paren_index\
    \ + 1\n    else\n      # Increment the level of nesting if current character is\
    \ not a parenthesis and is enclosed with parenthesis\n      nested_level = 1 if\
    \ nested_level > 0 else nested_level + 1\n      paren_index = paren_index + 1\n\
    \    end\n  end\n  return nested_level\nend\n</cell>\n<cell>", "  paren_groups\
    \ = paren_string.split(\" \")\n  max_level = 0\n  current_level = max_level",
  "  max_level = 0\n  level = 0\n  paren_string.scan(/^([(])?(.*)/) do |type, content|\n\
    \    if type == '('\n      level += 1\n    elsif type == ')'\n      level -= 1\n\
    \      max_level = max(max_level, level)\n    end\n  end\n  max_level\nend", " \
    \ stack = 0\n  stacked_paren_groups = []\n  group_count = 0\n  paren_groups =\
    \ paren_string.split(' ')\n  paren_groups.each{|group|\n    if group == '('\n\
    \      stack = stack + 1\n    elsif group == ')'\n      stack = stack - 1\n  \
    \  elsif stack == 0\n      stacked_paren_groups << group_count\n      group_count\
    \ = group_count + 1\n    end\n  }\n  stacked_paren_groups.pop\nend", "  paren_depth\
    \ = ParenDepth.new\n  paren_depth.paren_level = paren_depth.paren_level + 1\n\
    \  paren_depth.paren_count = paren_depth.paren_count + 1", "  paren_count = paren_string.count('(')\n\
    \  result = []\n  opening_count = 0\n  i = paren_count\n  while i < paren_string.length\n\
    \    paren_char = paren_string[i]\n    i += 1\n    if paren_char == '('\n    \
    \  if opening_count == 0\n        opening_count += 1\n      else\n        opening_count\
    \ -= 1\n    elsif paren_char == ')'\n      if opening_count > 0\n        opening_count\
    \ += 1\n      else\n        result.push(opening_count)\n      end\n    end\n \
    \ end\n  if opening_count > 0\n    result.push(opening_count)\n  end\n  return\
    \ result\nend", "    paren_count = 0\n    depth = 1\n    stack = []\n    \n  \
    \  paren_groups = paren_string.split\n    \n    paren_groups.each do |paren|\n\
    \        if paren_count < depth\n            stack << paren\n        end\n   \
    \     \n        depth += 1 if paren_count == 0\n        \n        paren_count\
    \ += 1\n    end\n    \n    stack.join(' ')\nend", "  parentheses_count = 0\n \
    \ depth = 0\n  paren_groups = paren_string.split(' ')\n  paren_groups.each do\
    \ |group|\n    if group == '('\n      parentheses_count += 1\n    elsif group\
    \ == ')'\n      parentheses_count -= 1\n    elsif parentheses_count == 0\n   \
    \   depth += 1\n    end\n  end\n  depth\nend", "  paren_count = 1\n  max_level\
    \ = 0\n  \n  paren_stack = paren_string.split ' '\n  \n  while paren_stack.size\
    \ > 0\n    \n    # Handle open parenthesis first.\n    case paren_stack.shift\n\
    \    when '('\n      paren_count += 1\n    when ')'\n      paren_count -= 1\n\
    \    end\n    \n    if paren_count > max_level\n      max_level = paren_count\n\
    \    end\n  end\n  \n  max_level\nend\n</code>\nThe only other change I had to\
    \ make is to change the output to be:\n<code>\n( ( ( ( ( ( ( ( ( ) ) ) ) ) ) )\
    \ ) ) \n</code>\nto meet the requirement of returning the deepest level of nesting\
    \ instead of the maximum level of nesting.\n<|/ a |>\n<| a |>\n<code>", "  nested_paren_count\
    \ = 0\n  paren_string.gsub!(/\\(\\)/) do |parens| nested_paren_count += 1\n  nested_paren_count\n\
    end\nreturn nested_paren_count\nend\n</code>\nThe above code returns the level\
    \ of nesting for each group of parenthesis.\n<|/ a |>\n<| a tags=ruby,regex,parentheses\
    \ dscore=0 |>\n<code>", "  paren_stack = []\n  nested_level = 0\n  \n  paren_string.each_char.each\
    \ do |c|\n    next if c == '('\n    \n    unless paren_stack.empty?\n      nested_level\
    \ = paren_stack.last\n    end\n    \n    paren_stack.push c\n    \n    if c ==\
    \ '('\n      nested_level += 1\n    end\n    \n    if c == ')'\n      nested_level\
    \ -= 1\n    end\n    \n    if nested_level == 0\n      paren_stack.push c\n  \
    \  end\n  end\n  \n  nested_level\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    The code is so much nicer than mine. I've been trying to solve this problem for\
    \ ages. Thanks so much.\n<|/ c |>\n<| a dscore=0 |>\nHere is my implementation.\
    \ It only takes care of parentheses and it counts the number of opening parentheses.\
    \ It should be simple enough to modify it to count the total amount of nesting.\n\
    <code>", "  group_regex = /\\(([^)]+)\\)/\n  paren_stack = []", "  paren_string\
    \ = paren_string.split(' ')\n  max_level = 0", "  max_level = 0\n  paren_string.scan(/(?<open>\\\
    ()|(?<-open>\\))|(?<open>\\()|(?<-open>\\))/) do |match|\n    case match\n   \
    \ when '('\n      max_level += 1\n    when ')'\n      max_level -= 1\n    end\n\
    \  end\n  max_level\nend", "  groups = paren_string.scan(/[(]{(\\d+)}[)]/)\n \
    \ groups.map do |grp|\n    grp.flatten.map {|s| s.to_i}.inject(0) {|sum, i| sum\
    \ + i }\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
