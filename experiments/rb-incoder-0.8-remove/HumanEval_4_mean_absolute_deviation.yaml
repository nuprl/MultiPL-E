name: HumanEval_4_mean_absolute_deviation
language: rb
prompt: "# For a given list of input numbers, calculate Mean Absolute Deviation\n\
  # around the mean of this dataset.\n# Mean Absolute Deviation is the average absolute\
  \ difference between each\n# element and a centerpoint (mean in this case):\n# MAD\
  \ = average | x - x_mean |\ndef mean_absolute_deviation(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_mean_absolute_deviation\n\
  \    candidate = method(:mean_absolute_deviation)\n    assert_equal(0.5, candidate.call([1.0,\
  \ 2.0]))\n    assert_equal(1.0, candidate.call([1.0, 2.0, 3.0, 4.0]))\n    assert_equal(1.2,\
  \ candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n  end\nend\n"
completions: ["    numbers.each do |number|\n        sum = 0\n        numbers.each\
    \ do |n|\n            sum += (n - number)**2\n        end\n        mad = sum /\
    \ numbers.length\n        puts \"MAD for #{number} is #{mad}\"\n    end\nend\n\
    </code>\nIn short, you're calculating a MAD which is nothing more than the average\
    \ of absolute difference between each of the numbers and a mean of numbers. In\
    \ Ruby we can take advantage of Enumerable#each_with_index method which provides\
    \ the index of the current element as well as the current element in an array.\n\
    <code>\nnumbers.each_with_index do |number, index|\n    # index is the index in\
    \ the array, and number is the current element of array\nend\n</code>\n<|/ a dscore=2\
    \ tags=arrays,ruby |>\n<| c |>\nThat looks much cleaner! Thanks!\n<|/ c |>\n<|\
    \ c |>\nI think you meant `numbers.each_with_index { |number, index|` in the second\
    \ snippet.\n<|/ c |>\n<| a tags=arrays,ruby dscore=0 |>\n<code>", "  mean = (numbers.sum\
    \ / numbers.length)\n  deviation = (numbers - mean).abs\n  abs = deviation.sum\n\
    \  mdev = 0\n  count = 0\n  while count < deviation.length\n    if abs(deviation[count])\
    \ > mdev\n      mdev = abs(deviation[count])\n    end\n    count = count + 1\n\
    \  end\n  mdev = mdev / count\n  mdev\nend\n</cell>\n<code language=julia-0.5>",
  "  mean = 0\n  n = numbers.size.to_f\n  numbers.each_with_index do |number, index|\n\
    \    mean += number.to_f ** 2\n  end\n  mean /= n\n  numbers.each_with_index do\
    \ |number, index|\n    numbers[index] -= mean\n  end\n  numbers.inject(:+)\nend",
  "  deviations = numbers.map { |x| x - numbers.mean }\n  deviations.inject(0) do\
    \ |sum, value|\n    sum + value.abs\n  end\nend", "  numbers.inject(0) {|sum,\
    \ el| sum + abs el - numbers.mean}\nend", "  numbers.sort!\n  mean = (numbers.inject(0)\
    \ {|sum, value| sum + value}) / numbers.size\n  diff = numbers.inject(0) {|sum,\
    \ value| sum + value * value }\n  diff / numbers.size\nend", "    # Calculate\
    \ Mean\n    numbers_mean = numbers.mean\n    # Calculate Deviation\n    deviations\
    \ = numbers - numbers_mean\n    # Calculate Mean\n    mean_abs_dev = deviations.abs.mean\n\
    \    return mean_abs_dev\n    ", "  numbers.inject{|sum,x| sum + x if x.is_a?(Numeric)}\n\
    \  numbers.inject(0){|sum,x| sum + x*x if x.is_a?(Numeric)}\n  numbers.inject(0){|sum,x|\
    \ sum + (x - numbers.mean)*(x-numbers.mean) }\nend\n</code>\n<|/ a tags=ruby,average,ruby-on-rails,deviation,arrays\
    \ |>\n<| a dscore=1 tags=ruby,average,ruby-on-rails,deviation,arrays |>\n<code>",
  "  mean  = numbers.mean\n  deviation  = numbers.map { |x| x - mean }\n  MAD = deviation.abs",
  "  deviations = []\n  mean = 0\n  n = numbers.count", "  avg = numbers.inject(:+)\
    \ / numbers.size\n  numbers.inject([]) do |sum, el|\n    sum.last += el - avg\n\
    \    sum\n  end\nend", "  numbers.inject(0) {|sum, number| sum += Math.abs (number)}\n\
    \  numbers.inject(0.0) {|sum, number| sum += Math.sqrt (number)}\n  Math.sqrt\
    \ ((numbers.sum / numbers.size.to_f) - mean * mean)\nend", "    numbers.inject(0)\
    \ do |sum, number|\n        sum += number\n    end\n    numbers.inject(0) do |sum,\
    \ number|\n        sum = sum + pow(number - numbers.shift, 2)\n    end\n    Math.sqrt(sum\
    \ / numbers.length)\nend", "  numbers.inject(0) do |sum, el|\n    sum = sum +\
    \ el\n    sum\n  end\n  numbers.inject(0) { |sum, el| sum + Math.sqrt((el - sum)\
    \ * (el - sum)) }\nend", "  # initialize an accumulator for absolute deviation\
    \ sum\n  mad_sum = 0.0\n  # iterate over all the numbers and accumulate their\
    \ averages\n  numbers.each do |number|\n    # get the absolute deviation of this\
    \ number from the mean\n    mad_sum += (number - numbers.mean) ** 2\n  end\n \
    \ # return the average\n  mad_sum / numbers.size\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for the help\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  avg = numbers.inject(0) {|sum, value| sum + value }\n  numbers.inject(0)\
    \ {|sum, value| sum + abs ((value - avg) / avg) }\nend", "  numbers.inject { |sum,\
    \ number| sum + number.abs } / (numbers.length.to_f)\nend\n</code>\nAs you see,\
    \ it's very easy to calculate the mean of a list of numbers. Using inject with\
    \ a block, the mean of the list can be calculated using the sum and the number.abs\
    \ methods, which are built-in Ruby methods.\n<|/ a |>\n<| c |>\nPlease see my\
    \ edited question above. I am working with floats, so I need the mean of deviations.\
    \ I cannot use the median as the numbers need to be ordered.\n<|/ c |>\n<| a dscore=0\
    \ |>\nAssuming your numbers are sorted, you could always use a sliding window\
    \ of length N and calculate the mean of all those numbers in that window.\n<|/\
    \ a tags=deviation,average,ruby,algorithm,statistics |>\n<| c |>\nHmm - how would\
    \ you implement this in Ruby?\n<|/ c |>\n<| c |>\nI mean - how would you implement\
    \ this in Ruby?\n<|/ c |>\n<| c |>\n- I have no idea what your implementation\
    \ is like.  Do you have a code sample?  Or are you asking how to *write* a sliding\
    \ window of size N?\n<|/ c |>\n<| c |>\nThe sliding window of size N - do you\
    \ mean the sliding window of size N from each number in the array? If so I don't\
    \ understand how the sliding window would help with the problem - what am I missing?\n\
    <|/ c |>\n<| c |>\nThe sliding window of size N is used to calculate an estimate\
    \ of how \"spread out\" the numbers in the array are over a range of N numbers.\
    \  Say, the numbers are 1, 2, 3, and 4 and you apply the sliding window of size\
    \ 3 to them.  You get 1, 2, and 3, and 1, 2 and 4, and 1, 2, and 3.  As you can\
    \ see, in each of these \"windows\" the average is calculated as the sum of the\
    \ numbers in the window/sliding.\n<|/ c |>\n<| a |>\nYou need a sliding window\
    \ to compute an average; this is exactly what a sliding window is, a sliding window\
    \ that is moving along a sequence of N values at a time. Here is some pseudocode:\n\
    <code>", "    numbers.each { |x| puts x }\n    total = 0\n    numbers.each { |x|\
    \ total += x - x.last }\n    return total / numbers.size\nend", "  numbers.inject(0)\
    \ {|sum,n| sum += Math.abs n }\n  numbers.inject {|sum,n| sum + Math.abs n } /\n\
    \    numbers.inject(0) {|sum,n| sum += 1 }\nend", "  # initialize return value\n\
    \  total = 0.0;\n  # calculate the average\n  average = numbers.sum/numbers.length\n\
    \  # loop through all numbers\n  numbers.each do |n|\n    # calculate difference\
    \ (absolute value - average)\n    difference = Abs(n - average)\n    # add to\
    \ total and print\n    total = total + difference\n  end\n  # return average\n\
    \  total/numbers.length\nend", "  mean_absolute_deviation_numbers = numbers.map\
    \ { |number|\n    abs_number = number.abs\n    mean_number = number.to_f\n   \
    \ abs_number - mean_number\n  }.inject{ |sum, number| sum + number }\n  mean =\
    \ numbers.inject(&:+) / numbers.size\n  Math.sqrt(mean_absolute_deviation_numbers\
    \ / (numbers.size-1))\nend", "  sum = 0\n  n = numbers.count\n  numbers.each do\
    \ |n|\n    sum = sum + (n - n ** 2) / n\n  end\n  mean = sum / n\n  sum = 0\n\
    \  numbers.each do |n|\n    sum = sum + (n - mean) ** 2\n  end\n  mad = sum /\
    \ n\n  return mad\nend", "  numbers.inject(0.0) { |sum, value| sum += (value -\
    \ mean) ** 2 } / (numbers.length.to_f)\nend", "    mad = []\n    \n    # Calculate\
    \ mean\n    mean = numbers.inject(0) do |sum, item|\n      sum + item\n    end\n\
    \    \n    # Calculate difference\n    numbers.each do |item|\n      item = item\
    \ - mean\n      mad << item\n    end\n    \n    # Calculate MAD\n    result =\
    \ mad.inject(0.0) do |sum, item|\n      sum + item\n    end\n    \n    return\
    \ result\nend", "  mad = numbers.inject(0) { |sum, number| sum + abs(number -\
    \ sum.sum / numbers.count) }\n  mad / numbers.count\nend", "  mean = numbers.inject(:+).to_f\
    \ / numbers.size\n  sum((numbers - mean)*(numbers - mean)).to_f / (numbers.size-1)\n\
    end", "  # Calculate the mean and standard deviation of numbers:\n  mean = numbers.mean\n\
    \  stdev = numbers.std\n  # Calculate MAD:\n  MAD = numbers.map{|x| (x - mean)\
    \ * stdev}.sum / numbers.size \n  return MAD\nend", "  mean_value = numbers.inject(0,\
    \ :+).to_f / numbers.size\n  diffs = numbers.map { |x| x - mean_value }\n  diffs.inject(:+)\
    \ / numbers.size \nend\n</code>\nUsing these definitions, here's the results for\
    \ an array with random numbers between -1 and 1:\n<code>\n[-1,1,-1,1,-1].inject(:+)\
    \ / 5.to_f", "  deviations = numbers.map { |n| Math.sqrt( ((n - numbers.mean)\
    \ ** 2))}\n  mean_deviation = deviations.mean\n  deviations.map! { |n| n - mean_deviation}\n\
    \  deviations.sum / deviations.size # => The average of the deviations\nend\n\
    </code>\nThe result is\n<code>\nnumbers = [1.2, 3.4, 5.6, 7.8, 9.0, 10.3, 20.5,\
    \ 30.7, 40.9, 51.1]\nnumbers.map { |n| Math.sqrt( ((n - numbers.mean) ** 2)) }\n\
    => [5.97435275062179, 10.506716808881, 18.4553984491928, 29.87776439628545, 43.24122984265736,\
    \ 60.57390912858984, 76.37147788839466, 99.34866240954242, 132.1299696407041,\
    \ 169.8115417698397, 199.3957606704865]\nnumbers.map { |n| Math.sqrt( ((n - numbers.mean)\
    \ ** 2)) }.mean\n=> 5.97435275062179", "  mean   = numbers.mean\n  devs   = numbers.map\
    \ {|x| (x - mean).abs}\n  madevs = devs.sum / devs.length\n  return madevs\nend",
  "  numbers.each_with_index do |n, index|\n    diff = numbers.count - index\n   \
    \ diff += diff > 0 ? 1 : 0\n    diff *= diff\n  end\n  numbers.inject((numbers.count\
    \ - 1) * -1) do |sum, el|\n    sum + el\n  end\nend", "    numbers.inject([:+,:+])\
    \ { |sum, el| sum + el }\n    avg = numbers.inject(0) { |sum, el| sum + el } /\
    \ numbers.size\n    numbers.reject{ |el| el < avg  }.inject([:+,:+]) { |sum, el|\
    \ sum + el }\nend", "  mean = 0\n  deviation = 0\n  numbers.each do |number|\n\
    \    mean += number\n  end\n  mean /= numbers.length\n  numbers.each do |number|\n\
    \    deviation += abs(number - mean)\n  end\n  deviation /= numbers.length\n \
    \ deviation\nend", "  # Write your code here.\n  numbers.inject(0){|sum, number|\
    \ sum += (number - numbers.mean)**2}\nend\n</cell>\n<text>\nWe can then define\
    \ a function to calculate the mean deviations:", "  numbers.inject(0) { |sum,\
    \ element| sum + ABS(element - mean_element(numbers)) }\nend", "  numbers.inject(0)\
    \ do |sum, number|\n    sum += abs(number-numbers.mean)\n    sum\n  end\nend\n\
    </cell>\n<cell>", "    numbers.each_with_index do |num, i|\n      sum = 0.0\n\
    \      numbers.each do |num2|\n        sum += (num ^ num2) / 2.0\n      end\n\
    \      mean = sum / i\n      STDDEV = sum / i\n      MAD = num - mean\n    end\n\
    \    MAD\nend\n</code>\n<|/ q tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nCan\
    \ you add an example of your expected output?\n<|/ c |>\n<| c |>\nExpected output\
    \ in the question is just one example. I'm looking for something that is more\
    \ general and flexible to handle any sort of array.\n<|/ c |>\n<| c |>\nCan you\
    \ give an example of what you are looking for? It's not quite clear what you want\
    \ to do.\n<|/ c |>\n<| c |>\nI added more description. I hope it's more clear.\
    \ Let me know if you need anything else and thanks for any help!\n<|/ c |>\n<|\
    \ c |>\nIt's not clear what the question is. How is the output for `[1,2,3,4,5]`\
    \ determined? How does that depend on the input array? How is this determined\
    \ without looking at the input?\n<|/ c |>\n<| a |>\nHere's one way. I'm sure there\
    \ are better ways to do it.\n<code>", "  avg = numbers.inject(0) {|sum, element|\
    \ sum + element } / numbers.length\n  numbers.inject(0) {|sum, element| sum +\
    \ Math.abs (element - avg) }\nend", "  numbers.each_index do |i|\n    diff = numbers[i]\
    \ - mean_number\n    abs_diff = diff.to_f\n    mad = abs_diff.abs\n    sum_mad\
    \ += mad\n    sum_diff += diff\n  end\n  sum_mad / numbers.size\nend", "  numbers.collect{|x|\
    \ x.abs} .collect{|x| x.to_f}.inject (0, :+).sqrt\nend", "  mean_value = numbers.inject(0)\
    \ {|sum, value| sum + value }\n  squared_deviation = (numbers.map {|x| x - mean_value}).inject(0)\
    \ {|sum, value| sum + value * value }\n  (squared_deviation / numbers.size)\n\
    end", "  mean = 0\n  sum_of_squares = 0\n  deviation = 0\n  n = numbers.size\n\
    \  \n  numbers.each do |number|\n    sum = sum + number\n    sum_of_squares +=\
    \ (number ** 2)\n  end\n  \n  mean = sum / n\n  deviation = sum_of_squares / n\
    \ - mean ** 2\n  \n  return deviation\nend", "  numbers.each { |x| x -= x.mean}\n\
    \  numbers.reduce(0,:).abs\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI don't\
    \ think there's any need for that `numbers.each { |x| x -= x.mean}` part. That\
    \ doesn't change the numbers in the array. The `reduce` method works on the whole\
    \ array and returns one value.\n<|/ c |>\n<| c |>\nYes, you're right! I thought\
    \ the method reduce works like each and reduces arrays to one value. Thank you\
    \ for pointing out. I've fixed my answer now.\n<|/ c |>\n<| c |>\nI tested this\
    \ and it works, although it does add a `x.abs` to the block so it looks like this:\
    \ `numbers.reduce(0) { |total,x| total + x.abs - x.mean}`. I'm not sure why you\
    \ would want to do this though. `each` already returns the array `numbers`.\n\
    <|/ c |>\n<| c |>\nAh, I see. Just a little misunderstanding about reduce method.\
    \ Thank you for explanation\n<|/ c |>\n<| a tags=ruby |>\nFor my simple case that\
    \ I am going to be doing, I actually just want to find the standard deviation\
    \ of a list of numbers. The solutions here are great, but I believe that if I\
    \ want to find out a more general \"mean of deviations\" then I should use something\
    \ like this:\n<code>", "    \n    # Get the mean of the list:\n    mean = numbers.inject(:+).to_f\
    \ / numbers.size\n    \n    # Get the differences and square:\n    differences\
    \ = numbers - mean\n    differences.square\n    \n    # Sum and divide by count:\n\
    \    sums = differences.reduce(:+)\n    sums /= numbers.size\n    \n    # Return\
    \ mean squared deviation:\n    sums.sqrt\nend", "  numbers.reduce(:+)\nend", " \
    \ numbers.inject { |sum, number| sum + Math.abs number }\n  numbers.inject { |sum,\
    \ number| sum + Math.sqrt number }\n  numbers.inject { |sum, number| sum / 2.0\
    \ }\nend", "  # return the list of numbers without the mean and calculate the\n\
    \  # average absolute deviation\n  return numbers.delete_at(numbers.index(numbers.mean)).inject(0,\
    \ :+).to_f / (numbers.size - 1)\nend\n</code>\nThen you get your answer for any\
    \ numbers in the range you specify (I chose the range from 100 to 1000 and averaged\
    \ out a few numbers).\n<code>\nmean_absolute_deviation(1000.times.map{ rand(100)\
    \ }) # => 9.143378805766223\n</code>\nI used the inject method from Ruby's Enumerable\
    \ class here (http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject)\
    \ which is a convenient way of doing this, but you could also use inject!, which\
    \ does the same thing but returns the object it was called on (so you wouldn't\
    \ have to store it in a variable beforehand).\n<|/ a tags=ruby,math |>\n<| c |>\n\
    Your `mean_absolute_deviation` does not actually calculate the mean in any way.\
    \ It just subtracts the mean from a set of numbers, then averages the results.\
    \ This is more like MAD in statistics terms.\n<|/ c |>\n<| c |>\nYes, I know.\
    \  He used the phrase \"around the mean\", so I thought it would be okay to average\
    \ the numbers around a central number.  I also realize that it's probably not\
    \ what he wants.  What I meant was that he should take all the numbers up to the\
    \ mean and calculate the MAD between each point and the mean of the set.\n<|/\
    \ c |>\n<| c |>\nNo. Your method would calculate the MAD between each element\
    \ and its mean, not between the elements and the mean. I understand why you want\
    \ to do this, but your code would calculate the MAD between the elements and the\
    \ mean in each step. It's not what he wants.\n<|/ c |>\n<| a |>\nHere's one way\
    \ to do it.\n<code>", "  numbers.inject(0){|sum, e| sum += e ^ 2; sum}\n  Math.log(numbers.inject(0)\
    \ {|sum, e| sum += e ^ 2; sum}) / numbers.size\nend", "  numbers.inject(0.0) {\
    \ |sum, number|\n    sum += abs(number - sum / numbers.size);\n    sum\n  }\n\
    end\n</cell>\n<code language=ruby-1.8.7-p358>", "  abs = numbers.map(&:abs).sum\n\
    \  mean = numbers.map(&:mean).sum / numbers.count\n  deviation = numbers.map {|x|\
    \ x - mean}.map(&:abs).sum / abs \n  deviation\nend", "  numbers.each_with_object(0.0)\
    \ do |num, acc|\n    acc += num\n    acc += num\n  end\n  acc / 2\nend", "  avg\
    \ = numbers.inject(:+).to_f / numbers.size\n  (numbers - avg).abs\nend\n</code>\n\
    Now let's take this a step further and use map to calculate the MAD only for the\
    \ middle two numbers and store them in an array. Then we can use the average to\
    \ calculate the average MAD:\n<code>", "    numbers.each do |number|\n       \
    \ sum = numbers.inject(0) do |sum, number|\n            sum + Math.abs ((number\
    \ - number[0]))\n        end\n        mean = numbers.inject(0){ |sum,number| sum\
    \ + number[0] }\n        puts sum / numbers.length\n        puts sum / mean.length\n\
    \    end\nend", "  mean = numbers.inject(:+).reduce(:+) / numbers.size\n  deviations\
    \ = numbers.map { |n| Math.sqrt((n**2 - mean**2) / (numbers.size - 1)) }\n  deviations.inject(:+)\
    \ / numbers.size\nend", "  # Sum of absolute values of all numbers\n  sum_of_absolute_values\
    \ = numbers.inject(0) { |sum, number| sum + number.abs }\n  \n  # Mean absolute\
    \ deviation\n  mean_absolute_deviation = sum_of_absolute_values / numbers.size\
    \ unless numbers.empty?\n  \n  # Return mean absolute deviation\n  mean_absolute_deviation\n\
    end", "  avg = numbers.inject(:+) / numbers.size\n  numbers.inject(:-) do |sum,\
    \ item|\n    sum + Math.abs ((item - avg) * (item - avg))\n  end\nend\n</cell>\n\
    <cell>", "  mean = numbers.inject(:+) / numbers.length.to_f\n  squared_diffs =\
    \ numbers.map { |x| x - mean }\n  squared_diffs.map { |diff| diff * diff }.length.sqrt\n\
    end\n</code>\nSo this one returns the same values as what you had, which gives\
    \ the correct result for this data set with your code:\n<code>\n[\n  {\"name\"\
    \ => \"Apple\", \"value\" => 10},\n  {\"name\" => \"Banana\", \"value\" => 20},\n\
    \  {\"name\" => \"Cherry\", \"value\" => 30},\n  {\"name\" => \"Grape\", \"value\"\
    \ => 40},\n  {\"name\" => \"Lemon\", \"value\" => 50},\n  {\"name\" => \"Melon\"\
    , \"value\" => 70},\n  {\"name\" => \"Orange\", \"value\" => 80},\n  {\"name\"\
    \ => \"Peach\", \"value\" => 90},\n  {\"name\" => \"Watermelon\", \"value\" =>\
    \ 100},\n  {\"name\" => \"Pear\", \"value\" => 110},\n  {\"name\" => \"Blackberry\"\
    , \"value\" => 120}\n]\n</code>\nAnd this one also gives correct results:\n<code>\n\
    [\n  {\"name\" => \"Apple\", \"value\" => 10},\n  {\"name\" => \"Banana\", \"\
    value\" => 20},\n  {\"name\" => \"Cherry\", \"value\" => 30},\n  {\"name\" =>\
    \ \"Grape\", \"value\" => 40},\n  {\"name\" => \"Lemon\", \"value\" => 50},\n\
    \  {\"name\" => \"Melon\", \"value\" => 70},\n  {\"name\" => \"Orange\", \"value\"\
    \ => 80},\n  {\"name\" => \"Peach\", \"value\" => 90},\n  {\"name\" => \"Watermelon\"\
    , \"value\" => 100},\n  {\"name\" => \"Pear\", \"value\" => 110},\n  {\"name\"\
    \ => \"Blackberry\", \"value\" => 120},\n  {\"name\" => \"Blueberry\", \"value\"\
    \ => 130}\n]\n</code>\nAnd here are the results for your data:\n<code>\n[\n  {\"\
    name\" => \"Apple\", \"value\" => 10},\n  {\"name\" => \"Banana\", \"value\" =>\
    \ 20},\n  {\"name\" => \"Cherry\", \"value\" => 30},\n  {\"name\" => \"Grape\"\
    , \"value\" => 40},\n  {\"name\" => \"Lemon\", \"value\" => 50},\n  {\"name\"\
    \ => \"Melon\", \"value\" ", "  mean = 0\n  sum = 0\n  numbers.each do |n|\n \
    \   sum += n * n\n    mean += n\n  end\n  Math.sqrt(sum / numbers.length.to_f)\
    \ - Math.sqrt(mean / numbers.length.to_f)\nend", "  devs = numbers.map(&:to_f).map(&:abs).map\
    \ { |x| x - x.mean }\n  mean = devs.mean\n  MAD = devs.map(&:abs).max # MAD =\
    \ maximum | x - x_mean |\n  return mean, MAD\nend", "  # initialize mad with zeros\n\
    \  mad = 0\n  # loop through numbers, add to mad if not null\n  numbers.each do\
    \ |number|\n    mad += number if number.to_s.to_i > 0\n  end\n  # divide mad by\
    \ number of values\n  mad / numbers.size\nend\n</code>\nA few notes:", "    numbers.inject(0)\
    \ { |sum, x| sum + Math.abs (x) }\n    Math.sqrt (numbers.inject(0) { |sum, x|\
    \ sum + Math.pow (x - mean, 2) })\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    The code is great in ruby, but the OP asked about rails\n<|/ c |>\n<| c |>\nI\
    \ have added the solution for rails, i did not have access to ruby so i was not\
    \ able to test it.\n<|/ c |>\n<| c |>\nNice. Now that this is an acceptable answer,\
    \ you should mark it as accepted or delete it.\n<|/ c |>\n<| c |>\nHi thank you\
    \ for the answer it works great.  I have one additional question but I'll post\
    \ a new question so you can help me.  How can I take the input from the user and\
    \ put it into a database (I already have the database set up with all the correct\
    \ fields) with rails.  I know how to create a new row but I cannot get an input\
    \ from the user to put into my database without using a form tag.\n<|/ c |>\n\
    <| c |>\nI would suggest that you start a thread on the [ruby forum](https://groups.google.com/forum/?fromgroups#!forum/rubyonrails)\
    \ because it's difficult to answer that in a comment. Make sure to put in more\
    \ details about what you are trying to do and what you have already done.\n<|/\
    \ c |>\n<| a tags=ruby-on-rails,ruby-on-rails-3,ruby |>\nI'm gonna assume you\
    \ know about model validations\n<code>", "    mad = []\n    numbers.each do |number|\n\
    \        mad << Math.sqrt(number.to_f ** 2 - number.to_f ** 2)\n    end\n    mad\
    \ << 0\n    mad / numbers.count\nend", "  sorted_numbers = numbers.sort\n  center\
    \ = sorted_numbers.first\n  delta = 0.0\n  deviation = 0.0\n  i = 0\n  while i\
    \ < numbers.length\n    delta = sorted_numbers[i] - center\n    deviation += delta\
    \ * (sorted_numbers[i] - center)\n    i += 1\n  end\n  deviation = deviation /\
    \ i\n  return deviation\nend\n</code>\n<|/ a dscore=2 tags=arrays,ruby |>\n<|\
    \ a tags=arrays,ruby dscore=2 |>\nIf you wish to find the average and the standard\
    \ deviation, I recommend using ruby's statistics library.\n<code>\nrequire 'statistics'",
  "  diff = 0\n  count = 0\n  made_number = numbers[0]\n  numbers.each do |number|\n\
    \    count += 1\n    diff += ((number - made_number) / count)\n    made_number\
    \ = number\n  end\n  return diff\nend", "  numbers.inject(0, :+).reduce(:*)\n\
    end", "  avg = numbers.inject(:+)/numbers.size\n  numbers.map(&:abs).map { |n|\
    \ n.abs-avg  }.inject { |sum, num| sum + num  }.sqrt\nend", "  numbers.inject(0)\
    \ {|sum, number| sum + Math.abs number }\n  numbers.inject(0) {|sum, number| sum\
    \ + Math.abs number } / numbers.size\nend", "  numbers.inject(0) {|sum, element|\
    \ sum + abs(element - numbers.mean)}\nend\n</code>\nThis calculates Mean Absolute\
    \ Deviation from a list of numbers.\n<code>\np numbers # => [10, 13, 9, 4, 12,\
    \ 12, 8, 7, 15, 13, 11, 13]\np mean_absolute_deviation(numbers) # => 0.4714285714285714\n\
    </code>\n<|/ a tags=ruby,statistics dscore=2 |>\n<| c |>\nThis is very similar\
    \ to what I was using but I was looking for an efficient way to compute it, that\
    \ wouldn't require so many loops. Thanks though! +1\n<|/ c |>\n<| c |>\nActually\
    \ you were right the first time, my mistake :) I edited the question with my own\
    \ solution, I was looking for a more efficient way to calculate it. Thanks again!\n\
    <|/ c |>\n<| c |>\nI edited my answer to make it even simpler by avoiding the\
    \ need for a separate loop.\n<|/ c |>\n<| a dscore=2 |>\nHere is a solution using\
    \ Ruby's Enumerable#chunk_while method.\nThe method will split the given array\
    \ into chunks until it finds two consecutive elements that are different from\
    \ each other. \nThe second value returned from the method is an array that contains\
    \ all the elements that are different from the previous value returned by the\
    \ method. \nThe difference between the two values is the mean of the difference\
    \ between the elements.\n<code>\nnumbers = [10,13,9,4,12,12,8,7,15,13,11,13]",
  "  numbers.inject(0) {|sum, x| sum + Math.abs (x-numbers.last)}\n  numbers.inject(0)\
    \ {|sum, x| sum + Math.pow (x-numbers.last, 2)}\n  numbers.inject(0) {|sum, x|\
    \ sum + Math.pow (x - numbers.last, 2)}\n  Math.sqrt(numbers.inject(0) {|sum,\
    \ x| sum + Math.pow (x - numbers.last, 2)})\nend\n</code>\n<|/ a dscore=5 tags=statistics,ruby,ruby-on-rails,ruby-on-rails-3,math\
    \ |>\n<| a tags=statistics,ruby,ruby-on-rails,ruby-on-rails-3,math |>\nI like\
    \ the answer from SaschaM for its simplicity.\nI took it a step further and wrote\
    \ a more general function that is more robust to outliers.\nIt returns an array\
    \ with the deviation from the mean (m) as the element, and the difference between\
    \ this and the mean (m) as the second element.\n<code>", "  mean = numbers.inject(:+)\
    \ / numbers.length\n  squared_deviation = (numbers.map(&:to_f) - mean).map(&:*)\n\
    \  squared_deviation.inject(:+) / (numbers.length - 1).sqrt\nend", "  numbers.inject(0)\
    \ { |sum, value| sum + math.abs value }\n  math.sqrt(numbers.inject(0) { |sum,\
    \ value| sum + value }) / numbers.to_f\nend", "  number_sets = numbers.to_set\n\
    \  number_sets[0].sort!\n  first_number = number_sets[0]\n  sum_of_squared_differences\
    \ = 0.0\n  sum_of_squares = 0.0\n  sum_of_squares = 0.0\n  number_sets.each do\
    \ |number|\n    sum_of_squares += number*number\n    sum_of_squared_differences\
    \ += (number-first_number)*number\n  end\n  \n  if number_sets.length == 1\n \
    \   sum_of_squared_differences / (number_sets.length - 1.0)\n  else\n    sum_of_squared_differences\
    \ / Math.sqrt(sum_of_squares / number_sets.length)\n  end\nend", "  numbers.inject(0)\
    \ {|sum, e| sum + e } / numbers.size\nend", "  numbers.inject { |sum, el| sum\
    \ + el**2 } / (numbers.length.to_f - 1)\nend", "  # TODO: Your code here!\nend",
  "  n = numbers.count\n  mean = (numbers.sum / n)\n  deviations = (numbers - mean).abs\n\
    \  \n  numbers_sorted = numbers.sort\n  deviations_sorted = deviations.sort",
  "  numbers.each_with_index.map {|n, index| [n, index] }.\n    sort_by { |n| n[0]\
    \ }.\n    map {|n| n[0] - n[1].to_f }.\n    reduce(:+)\nend\n</code>\nThe above\
    \ code will return a list of arrays with the mean and MAD values. We can then\
    \ easily calculate the MAD value using the following code:\n<code>", "  numbers.inject(0)\
    \ {|sum, val| sum + math.abs(val) }\n  numbers.inject(0) {|sum, val| sum + val**2\
    \ }\n  math.sqrt(numbers.inject(0) {|sum, val| sum + val }) # average\nend", " \
    \ numbers.inject(0) {|sum, el| sum + abs(el - el.mean) }\nend\n</code>\nThen calling\
    \ the function in your view like this:\n<code>\n<%= distance_of_mean([@number])\
    \ %>\n</code>\nNote that I've changed your function a little bit - it had some\
    \ syntax errors. \nThe main point was that the method must return an integer,\
    \ so you cannot return from your block. Your return statement should be outside\
    \ the block. Also note that you have a typo in your.each block - you have not\
    \ closed the block with curly bracket.\n<|/ a dscore=2 tags=ruby-on-rails,ruby,ruby-on-rails-3,ruby-on-rails-3.1\
    \ |>\n<| c |>\nThanks for the response! I appreciate the help, however... I'm\
    \ still confused on how to use this method with the view code I posted. I'm sorry\
    \ if I'm missing something simple, but I'm very new to rails and still trying\
    \ to learn the ropes. I added the 'distance_of_mean' method to my helper file,\
    \ but it says the method isn't defined. What am I missing? Thanks!\n<|/ c |>\n\
    <| c |>\nYou've added the method to your helper file, but you've also added it\
    \ to the wrong file. To call it from the view you'll need to add the helper method\
    \ to the controller file. The controller file should be `app/controllers/your_controller.rb`\
    \ and the method should be called as `helper_method :distance_of_mean`. You should\
    \ then be able to call `<%= distance_of_mean %>` within the view - assuming you've\
    \ included the helper in your controller file.\n<|/ c |>\n<| c |>\nI apologize\
    \ if I'm being dumb, I'm just trying to wrap my head around this stuff for a project\
    \ that I'm working on and I'm kinda confused as to what I need to do :( I added\
    \ the method to my controller file, but I don't think that was the right way to\
    \ go about it. I have the helper_method in the controller file, and I tried calling\
    \ it from the view by placing the code you wrote in the view file, but it still\
    \ didn't work. I'm sorry if I'm missing something simple, I'm very new to rails.\
    \ I appreciate your help so much!\n<|/ c |>\n<| a dscore=2 |>\nThe other answers\
    \ are good, but I wanted to point out a couple of things about your code. \nFirstly,\
    \ I believe this line: numbers.inject(0) {|sum, el| sum + abs(el - el.mean) }\n\
    should read: numbers.inject(0) {|sum, el| sum + abs(el - el.to_i) }\nSecondly,\
    \ you're calling your method inside your view. I think ", "    avg = mean(numbers)\n\
    \    sum = 0\n    for i in numbers\n        sum = sum + abs(i - avg)\n    avg\
    \ = sum / numbers.size\n    return avg\nend", "  mean = 0\n  num_elements = 0\n\
    \  numbers.each { |x| mean += x }\n  mean /= numbers.count\n  numbers.each { |x|\
    \ num_elements += 1}\n  num_elements.times { |i| mean -= numbers[i] }\n  mean_absolute_deviation\
    \ = Math.sqrt( (mean * mean) / num_elements)\nend\n</code>\n<|/ a dscore=4 tags=ruby,algorithm,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| c |>\nI like the simple approach and will try it out in the morning,\
    \ thanks so much for the detailed explanation.\n<|/ c |>\n<| c |>\nI tried it\
    \ out, but got this error: undefined method `each' for [3, 7, 11, 15, 18]:Array\n\
    <|/ c |>\n<| c |>\nI forgot that my array was in fact a 2D array from my CSV parsing,\
    \ so I changed `numbers.each { |x| mean += x }` to: `numbers.each { |x| mean +=\
    \ x[0] }` and it works! Thanks again!\n<|/ c |>\n<| c |>\n: I missed that, I updated\
    \ the answer and will appreciate if you could accept it.\n<|/ c |>\n<| a tags=ruby,algorithm,ruby-on-rails-3,ruby-on-rails\
    \ |>\nIn case someone is looking for an implementation of the above algorithms\
    \ I wrote a little gem that does just that. It supports calculating the standard\
    \ deviation around the mean (not using the median or quartiles approach) and also\
    \ calculating a confidence interval from it. It also takes care of edge cases.\
    \ Its written in pure ruby.\nhttps://github.com/r0man/rmad \n<code>", "  m = 0\n\
    \  d = []\n  for x in numbers\n    m = m + x\n    d << m\n    m += x\n  end\n\
    \  m\nend", "  numbers.inject(0) do |sum, number|\n    sum = sum + number\n  end\n\
    \  numbers.inject(0.0) do |sum, number|\n    sum = sum + Math.sqrt(number - Math::sqrt(sum))\n\
    \  end\nend", "    numbers.each do |number|\n        numbers.each do |number|\n\
    \            mad = abs(number - numbers.mean)\n        end\n    end\nend", " \
    \ numbers.inject(0) { |sum, element| sum + Math.abs element }\n  numbers.inject(0)\
    \ { |sum, element| sum + element }\n  numbers.length.times do |i|\n    numbers[i]\
    \ -= numbers[i] / numbers.length.to_f\n  end\n  numbers.length / 2\nend", "  numbers.inject{|sum,\
    \ (el, num)| sum + abs(num - el)} \n  numbers.inject{|sum, el| sum + el} \n  numbers.sum\
    \ / numbers.length.to_f\nend", "  return numbers.inject(:+).abs.mean\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| a dscore=3 tags=statistics,ruby,arrays,loops |>\nHere's\
    \ a one-liner in Ruby:\n<code>\nnumbers.reduce(:+).abs.sqrt\n</code>\n<|/ a |>\n\
    <| a dscore=2 |>\nThe solution using inject, inject + map and map on itself is\
    \ more complicated than necessary and more inefficient than the other solutions\
    \ using reduce or inject.\nThis version only calls map once in the middle of the\
    \ loop and doesn't call inject twice:\n<code>", "  # The numbers array is assumed\
    \ to be sorted.\n  numbers.sort!\n  center = numbers.pop\n  sum = 0\n  for x in\
    \ numbers\n    sum += abs(x - center)\n  end\n  sum / numbers.length\nend", " \
    \ m = mean(numbers)\n  deviations = numbers.map { |x| x - m }\n  Math.sqrt(deviations.inject(:+).to_f/deviations.size)\n\
    end", "    mad =  []\n    avg =  numbers.inject(0) { |sum,x| sum + x }\n    numbers.each_with_index\
    \ do |n, i|\n        mad[i] = Math.sqrt((n - avg)*(n - avg).to_f)\n    end\n \
    \   mad.average\nend", "    made_of_numbers = Array.new\n    numbers.each do |n|\n\
    \        made_of_numbers += (n - n.mean)**2\n    end\n    made_of_numbers.mean\n\
    end", "  numbers.each { |x| x -= x.mean }\n  numbers.reduce(0) { |sum, x| sum\
    \ + |x| }\nend", "  numbers.inject(0) { |sum, number| sum + Float(number)**2 }\n\
    \  numbers.inject(0) { |sum, number| sum + Float(number) }\n  numbers.inject(0)\
    \ { |sum, number| sum + Float(number) / numbers.size }\nend", "  numbers.each_with_index\
    \ do |number,i|\n    # Mean Absolute Deviation is a measure of absolute deviation.\n\
    \    calculated_mad_sum += ((number - mean) * i).abs\n  end\n  calculated_mad_sum\
    \ / numbers.size\nend", "  numbers.each do |number|\n    abs_deviation = abs_deviation\
    \ = (number - numbers.mean)\n  end", "  # Find the mean.\n  number_mean = numbers.mean",
  "  numbers.each do |number|\n    diff = number.to_f - numbers.shift\n    diff =\
    \ diff if diff.nonzero?\n    diff /= 2 if diff.nonzero?\n    diff\n  end\nend",
  "  numbers.inject(0) {|sum, number| sum += number.abs}\n  numbers.inject(0.0) {|sum,\
    \ number| sum += number**2}\n  numbers.inject(0.0) {|sum, number| sum += number**3}\n\
    \  numbers.inject(0.0) {|sum, number| sum += number**4}\n  sum / numbers.size\n\
    end\n</code>\nThis would calculate the mean and the standard deviation around\
    \ the mean (mean) of given numbers. You would need to change the code to use your\
    \ array instead of numbers then.\n<|/ a |>\n<| a dscore=2 |>\nThis is a generic\
    \ function. You can add multiple values to calculate their standard deviation.\n\
    <code>", "  # Write your code here\n  mad = []\n  numbers.each do |n|\n    mad\
    \ = mad + (n - numbers.mean)/numbers.std\n  end\n  mad /= numbers.size\n  mad\
    \ #=> MAD\nend", "  # Get the mean of our numbers\n  average = numbers.inject(:+).to_f\
    \ / numbers.size\n  # Return our result\n  numbers.map { |n| Math.log(n - average).abs\
    \ }.average\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\nHere is an example for standard deviation\n<code>", "    numbers.each do\
    \ |number|\n        numbers_delta = number - mean\n        mad += abs(numbers_delta)\n\
    \    end\n    mad / numbers.size\nend", "    numbers.each do |number|\n      \
    \  diff = number-numbers.mean\n        numbers.mean += diff * diff\n    end\n\
    \    return numbers.mean/numbers.length\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nI understand your answer, but I want to do it without iterating over the\
    \ whole dataset multiple times (like you did in your code). I want to do it without\
    \ looping through every number, but only through every other number. \nFor example,\
    \ I want to calculate the standard deviation of every other number in the dataset,\
    \ not every other number. So, I want to skip every other number, then calculate\
    \ the standard deviation of every other number in the dataset, then skip every\
    \ other number, and calculate the standard deviation of every other number in\
    \ the dataset, and so on.\n<|/ c |>\n<| c |>\nOkay, I edited my answer to take\
    \ this into account. Basically, you loop over the list once (to calculate the\
    \ mean and standard deviation) then you loop over it again to calculate the differences\
    \ in each number and save those to a second list.\n<|/ c |>\n<| a dscore=0 |>\n\
    This answer assumes you're talking about doing something like the standard deviation\
    \ calculation but on a sub-sample of the data.  The method you're describing is\
    \ computationally more expensive than just running a loop over every data point.\
    \  It also assumes that you want to compute the mean and standard deviation on\
    \ the full data set.\nOne way to approach this problem is to first pick a random\
    \ subset of your data points to use as the sub-sample and compute the standard\
    \ deviation on that.  Then you can compare the standard deviation from the sub-sample\
    \ with the standard deviation from the full data set to compute the MAD.  Below\
    \ is a quick example of a recursive function that will compute the standard deviation\
    \ on a sub-sample of your data set.\n<code>", "  mean = 0.0\n  sum = 0.0\n  sum_of_squares\
    \ = 0.0\n  numbers.each do |num|\n    sum = sum + num\n    sum_of_squares = sum_of_squares\
    \ + num * num\n  end\n  mean = sum / numbers.size\n  sum_of_squares = (sum_of_squares\
    \ / numbers.size)-mean*mean\n  result = Math.sqrt(sum_of_squares)\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThe OP says that \"the average of numbers cannot\
    \ be more than 10\", and your code doesn't show such requirements.\n<|/ c |>\n\
    <| c |>\nI assumed that \"the average of numbers cannot be more than 10\" meant\
    \ that they have to have at least 10 or no more than 10 items. I added the 'or'\
    \ logic to my answer since I saw that OP mentioned that they cannot have more\
    \ than 10 items. This meant I didn't have to deal with that logic within the function.\n\
    <|/ c |>\n<| c |>\nThis is an example from the book that I read a while ago, it\
    \ uses arrays: https://books.google.com.ua/books?id=4q6lZ4MhH5oC&pg=PA438&lpg=PA438&dq=average+absolute+deviation+in+ruby+for+each+element&source=bl&ots=MwW1u2Jp6P&sig=Y4lY4Gqxjyzt6VsWQ3X7QMxFkM1qo&hl=en&sa=X&ved=0ahUKEwjPjZg6nRYAhX9tYKHVZkKHX4CdUQ6AEIhCAk&biw=1536&bih=721#v=onepage&q=average%20absolute%20deviation%20in%20ruby%20for%20each%20element&f=false\n\
    <|/ c |>\n<| c |>\nthe OP didn't say that \"the average of numbers cannot be more\
    \ than 10\" but that they can only have 10 numbers. Your answer is correct for\
    \ \"they can only have 10 numbers\", but not for the general case. It would be\
    \ better if `#each_cons` returned an enumerator instead of an array, but that\
    \ would require Ruby 1.9. If that's the case, then the answer should be modified\
    \ to call `to_enum` on the enumerator, and return the enumerator itself.\n<|/\
    \ c |>\n<| c |>\n", "  n = numbers.count\n  avg = numbers.inject(:+) / n\n  result\
    \ = numbers.map { |n| Math.sqrt((n - avg) * (n - avg).abs) }\n  result.sum / result\n\
    end\n</cell>\n<code language=conda-root-py>", "  # Initialize variables\n  sum\
    \ = 0.0\n  \n  # Calculate the mean of our numbers\n  mean = numbers.inject(0)\
    \ {|sum, number| sum + number; sum / numbers.size }\n  # Calculate the deviation\
    \ from the mean\n  deviations = numbers.map {|number| number - mean}\n  # Calculate\
    \ sum of deviations, squared deviations, and take average\n  sum = deviations.inject(0)\
    \ {|sum, number| sum + number * number}\n  sum = sum ** 2\n  avg = sum / deviations.inject(0)\
    \ {|sum, number| sum + number}\n  # Return average and deviation\n  [avg, deviations.inject(0)\
    \ {|sum, number| sum + number}]\nend\n</cell>\n<text>\nNow let's calculate MAD\
    \ using the function defined above and store it in a variable:", "  avg = numbers.inject(:+)\
    \ / numbers.size\n  deviations = numbers.map { |x| x - avg }\n  mean = numbers.inject(:+)\
    \ / numbers.size.to_f\n  Math.sqrt(deviations.map { |dev| dev * (dev - mean) })\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer! Can I do that calculation\
    \ without using loops?\n<|/ c |>\n<| c |>\nYes, but it will make your program\
    \ longer, and harder to understand. I will update my answer with an example.\n\
    <|/ c |>\n<| c |>\nThanks for your help, this is very helpful!\n<|/ c |>\n<| a\
    \ dscore=0 tags=ruby |>\nThe below code calculates MAD for you using your methods.\
    \ The only difference is the use of inject method, where you can specify what\
    \ method should actually perform the calculation. Here, I am using the + to calculate\
    \ the average, as you mentioned in the question.\n<code>", "  # initialize MAD\
    \ and x_mean\n  MAD = 0.0\n  x_mean = 0.0", "  # initialize with the mean of the\
    \ first number\n  delta = numbers.mean", "  numbers.inject { |sum, number| sum\
    \ + number.abs }\n  numbers.inject { |sum, number| sum + number.to_f }\n  numbers.inject\
    \ { |sum, number| sum + number.to_i }\n  numbers.inject { |sum, number| sum +\
    \ number.to_l }\n  numbers.inject { |sum, number| sum + number.to_d }\n  numbers.inject\
    \ { |sum, number| sum + number.to_r }\n  numbers.inject { |sum, number| sum +\
    \ number.to_i }\n  numbers.inject { |sum, number| sum + number.to_l }\n  numbers.inject\
    \ { |sum, number| sum + number.to_d }\n  numbers.inject { |sum, number| sum +\
    \ number.to_r }\n  numbers.inject { |sum, number| sum + number.to_i }\n  numbers.inject\
    \ { |sum, number| sum + number.to_l }\n  numbers.inject { |sum, number| sum +\
    \ number.to_d }\n  numbers.inject { |sum, number| sum + number.to_r }\n  numbers.inject\
    \ { |sum, number| sum + number.to_i }\n  numbers.inject { |sum, number| sum +\
    \ number.to_l }\n  numbers.inject { |sum, number| sum + number.to_d }\n  numbers.inject\
    \ { |sum, number| sum + number.to_r }\n  numbers.inject { |sum, number| sum +\
    \ number.to_i }\n  numbers.inject { |sum, number| sum + number.to_l }\n  numbers.inject\
    \ { |sum, number| sum + number.to_d }\n  numbers.inject { |sum, number| sum +\
    \ number.to_r }\n  numbers.inject { |sum, number| sum + number.to_i }\n  numbers.inject\
    \ { |sum, number| sum + number.to_l }\n  numbers.inject { |sum, number| sum +\
    \ number.to_d }\n  numbers.inject { |sum, number| sum + number.to_r }\n  numbers.inject\
    \ { |sum, number| sum + number.to_i }\n  numbers.inject { |sum, number| sum +\
    \ number.to_l }\n  numbers.inject { |sum, number| sum + number.to_d }\n  numbers.inject\
    \ { |sum, number| sum + number.to_r }\n  numbers.", "    ma = 0\n    av = sum(numbers)\
    \ / len(numbers)\n    numbers.each do |x|\n      ma += abs(x - av)\n    end\n\
    \    ma / len(numbers)\nend", "  return numbers.inject(0) { |sum, number| sum\
    \ + number.abs }\nend", "    numbers.each do |number|\n        mean = get_mean(numbers)\n\
    \        deviation = number - mean\n        puts deviation.abs\n    end\nend",
  "  mean_of_numbers = numbers.inject(:+).to_f / numbers.size\n  numbers.map { |n|\
    \ mean_of_numbers - n }.abs\nend\n</code>\nIn both cases, you will have to replace\
    \ numbers.map { |n| mean_of_numbers - n }.abs with the actual formula you want\
    \ to use. You are welcome to put in a bug report for my solution if you find it\
    \ too complex.\n<|/ a |>\n<| c |>\nThanks very much for taking the time to post\
    \ your solution here. One thing I didn't know was how to get the standard deviation\
    \ from my data set. I think I am starting to understand it a bit more. My apologies\
    \ for not responding sooner.\n<|/ c |>\n<| c |>\nI updated my original question,\
    \ could you please take a look. Thanks again. Very much appreciated.\n<|/ c |>\n\
    <| c |>\nI've updated my answer to show you how to get the standard deviation\
    \ from your data.\n<|/ c |>\n<| a dscore=0 |>\nI believe there is a more efficient\
    \ way using map and inject or inject. Since you mentioned standard deviation,\
    \ I will use inject in this case. \n<code>", "  return numbers.inject(0) {|sum,\
    \ value| sum + abs(value - numbers.mean) }\nend", "  numbers.inject(0) do |sum,\
    \ value|\n    sum += value.abs\n    sum\n  end\nend", "  numbers.inject(0) {|sum,\
    \ number| sum + Math.abs number }\n  numbers.inject(0) {|sum, number| sum + Math.sqrt\
    \ Math.abs number }\n  math.sqrt(numbers.inject(0) {|sum, number| sum + Math.abs\
    \ number })\nend", "  mean_of_numbers = numbers.inject(0) {|sum, number| sum +\
    \ number}\n  squared_of_differences = numbers.map {|number| number - mean_of_numbers}.inject(0)\
    \ {|sum, number| sum + number ** 2}\n  Math.sqrt(squared_of_differences) / (numbers.size-1)\n\
    end", "  mean = numbers.inject(:+).to_f / numbers.size.to_f\n  deviations = numbers.map\
    \ {|n| n - mean}\n  average_absolute_deviation = deviations.inject(:+).to_f /\
    \ deviations.size.to_f\n  return average_absolute_deviation\nend", "  m = 0\n\
    \  ma = 0\n  for n in numbers\n    m += n\n    ma += (n - m)\n  return ma / numbers.length\n\
    end", "    numbers.each {|x|\n        sum = sum + x\n    }\n    avg = sum / numbers.length\n\
    \    numbers.each {|x|\n        difference = x - avg\n        mad = difference\
    \ / x\n    }\n    return mad\nend", "  m = numbers.inject(0) { |sum, number| sum\
    \ + number.abs }\n  numbers.inject(0.0) { |sum, number| sum + Math.pow((number\
    \ - m), 2) }\nend", "  numbers.each_with_index.map{ |value, index| \n    (value\
    \ - numbers[index])\n  }.sum / numbers.size\nend", "  numbers.collect{|x| x}.inject(0.0)\
    \ do |sum, number|\n    sum += ((number - numbers.mean) / numbers.std)\n    sum\n\
    \  end\nend", "  numbers.inject(0) {|sum, x| sum + abs(x)}\n  numbers.inject(0)\
    \ {|sum, x| sum + x*x}\n  numbers.length.times do\n    sum = numbers.pop + numbers.shift\n\
    \    numbers.unshift(sum / numbers.length)\n  end\n  numbers.inject(:+) / numbers.length.to_f\n\
    end", "  return numbers.inject(:+).abs.\n    map{ |value| value - (numbers.reduce(:+)\
    \ / numbers.size)}\nend", "  abs_deviations = numbers.map { |n| Math.sqrt((n **\
    \ 2).to_f) }\n  abs_deviations.inject(0) do |sum, value|\n    sum += value\n \
    \ end\n  abs_deviations.map { |value| value / numbers.size\nend", "  mad = []\n\
    \  numbers.each do |number|\n    m = number\n    numbers.each do |n|\n      m\
    \ = m + (n - m)\n    end\n    mad << m / numbers.length.to_f\n  end\n  mad.min\n\
    end", "  numbers.inject(0) {|sum, num| sum + Math.abs (num - mean)} / numbers.inject(0)\
    \ {|sum, num| sum + num}\nend", "  ma = 0.0\n  for n in numbers\n    ma += (n\
    \ - numbers.mean) **2\n  end\n  ma / numbers.size\nend", "  n = numbers.size\n\
    \  result = 0.0\n  result_sq = 0.0", "  numbers.inject(0) { |sum, item| sum +\
    \ Math.pow(item - mean, 2) }\nend ", "  mean_number = numbers.mean\n  squared_diffs\
    \ = numbers.map { |n| n**2 - mean_number**2 }\n  average_diff = squared_diffs.mean\n\
    \  return average_diff\nend\n</cell>\n<code language=julia-0.5>", "  numbers.inject(0)\
    \ do |sum, number|\n    sum = sum + number\n  end\n  numbers.inject(0.0) do |sum,\
    \ number|\n    sum = sum + Math.abs ((number - numbers.mean) / numbers.standard_deviation)\n\
    \  end\nend", "  numbers.inject(0) do |sum, number|\n    sum += number.abs unless\
    \ number.zero?\n    sum\n  end\n  numbers.inject(0) do |sum, number|\n    sum\
    \ + Math.sqrt(number.to_f ** 2)\n  end\nend", "  numbers.each { |number| puts\
    \ \"MAD for #{number} is: #{(number - numbers.mean).abs}\"}\nend\n</code>\nOutput\
    \ (with your input):\n<code>\nMAD for 0 is: 0.0\nMAD for 1 is: 0.0\nMAD for 2\
    \ is: 0.0\nMAD for 3 is: 0.0\nMAD for 4 is: 0.0\nMAD for 5 is: 0.0\nMAD for 6\
    \ is: 0.0\nMAD for 7 is: 0.0\nMAD for 8 is: 0.0\nMAD for 9 is: 0.0\nMAD for 10\
    \ is: 0.0\nMAD for 11 is: 0.0\nMAD for 12 is: 0.0\nMAD for 13 is: 0.0\nMAD for\
    \ 14 is: 0.0\nMAD for 15 is: 0.0\nMAD for 16 is: 0.0\nMAD for 17 is: 0.0\nMAD\
    \ for 18 is: 0.0\nMAD for 19 is: 0.0\nMAD for 20 is: 0.0\nMAD for 21 is: 0.0\n\
    MAD for 22 is: 0.0\nMAD for 23 is: 0.0\nMAD for 24 is: 0.0\nMAD for 25 is: 0.0\n\
    MAD for 26 is: 0.0\nMAD for 27 is: 0.0\nMAD for 28 is: 0.0\nMAD for 29 is: 0.0\n\
    MAD for 30 is: 0.0\nMAD for 31 is: 0.0\nMAD for 32 is: 0.0\nMAD for 33 is: 0.0\n\
    MAD for 34 is: 0.0\nMAD for 35 is: 0.0\nMAD for 36 is: 0.0\nMAD for 37 is: 0.0\n\
    MAD for 38 is: 0.0\nMAD for 39 is: 0.0\nMAD for 40 is: 0.0\nMAD for 41 is: 0.0\n\
    MAD for 42 is: 0.0\nMAD for 43 is: 0.0\nMAD for 44 is: 0.0\nMAD for 45 is: 0.0\n\
    MAD for 46 is: 0.0\nMAD for 47 is: 0.0\nMAD for 48 is: 0.0\nMAD for 49 is: 0.0\n\
    MAD for 50 is: 0.0\nMAD for 51 is: 0.0\nMAD for 52 is: 0.0\nMAD for 53 is: 0.0\n\
    MAD for 54 is: 0.0\nMAD for 55 is: 0.0\nMAD for 56 is: 0.0\nMAD for 57 is: 0.0\n\
    MAD for 58 is: 0.0\nMAD for 59 is: 0.0\nMAD for 60 is: 0.0\nMAD for 61 is: 0.0\n\
    MAD for 62 is: 0.0\nMAD for 63 is: 0.0\nMAD for 64 ", "  # Your code here\n  n\
    \ = numbers.count\n  mean = 0\n  sum = 0\n  for i in numbers\n    mean += i\n\
    \  end\n  mean /= n\n  for i in numbers\n    sum += (i-mean)**2\n  end\n  sum\
    \ /= n\n  mad = sum / n\n  return mad \nend", "  return numbers.inject(:+).to_f\
    \ / numbers.count\nend", "    # Your code here\n    return np.mean(numbers - np.mean(numbers))\n\
    end\n</cell>\n<code language=julia-1.0>\n@time mean_absolute_deviation([1,2,3])\n\
    </cell>\n<code language=julia-1.0>\n@time mean_absolute_deviation([1,2,3])\n</cell>\n\
    <code language=julia-1.0>\n@time mean_absolute_deviation([1,2,3])\n</cell>\n<code\
    \ language=julia-1.0>\n@time mean_absolute_deviation([1,2,3])\n</cell>\n<text>\n\
    4.1 Write a function get_median(numbers) that takes as input a list of numbers\
    \ and returns the median of the list numbers.", "  mean_number = numbers.inject(0){|sum,\
    \ element| sum + element }\n  distances = numbers.map { |x| abs (x-mean_number)\
    \ }\n  mean = distances.inject(0, :+).to_f / distances.size\n  variance = distances.inject(0,\
    \ :+).to_f / (distances.size-1)\n  mdev = mean * distances.inject(0) { |sum, distance|\
    \ sum + distance }\n  [mdev, (mdev-mean)/variance]\nend", "  numbers.inject(0)\
    \ do |sum, number|\n    sum = sum + number\n  end\n  return sum / numbers.size\n\
    end", "  numbers.inject(0) do |sum, number|\n    sum + Float(number)\n  end\n\
    end", '  numbers.sort!', "  numbers.inject(0) { |sum, number| sum + Math.abs number\
    \ }\n  numbers.inject(0.0) { |sum, number| sum + Math.abs (number - mean) }\n\
    \  Math.sqrt(numbers.inject(0) { |sum, number| sum + Math.pow(number - mean, 2)\
    \ })\nend", "  numbers.inject{|sum, el| sum + abs el} /\n    (numbers.inject(:+).to_f\
    \ / numbers.size)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3 |>\n<| c |>\n\
    This is exactly what I was looking for. Thank you so much.\n<|/ c |>\n<| c |>\n\
    It's worth noting that this will be much slower than just computing the mean of\
    \ the array and subtracting it, because it has to go through the whole collection\
    \ twice, but it's probably not really a big deal in most applications.\n<|/ c\
    \ |>\n<| a |>\nIf you're looking to get a numerical approximation to mean absolute\
    \ deviation in a Ruby on Rails application, try the following:\n<code>", "  numbers.inject(0.0)\
    \ { |sum, el| sum += (el - numbers.mean) }\n  Math.sqrt(sum / numbers.size)\n\
    end", "  numbers.inject(0) {|sum, el| sum + el.abs }\n  numbers.inject(0) {|sum,\
    \ el| sum + el }\n  numbers.length\nend", "  deviations = numbers.map { |x| x\
    \ - numbers.reduce(:+) }\n  mean = numbers.reduce(:+) / numbers.size\n  mad =\
    \ deviations.inject(0.0) { |sum, dev| sum + Math.sqrt(dev * dev + mean / numbers.size)\
    \ }\nend", "  # Initialize an empty list that will hold our MAD values for each\
    \ number.\n  mad = []\n  # Loop through each number and calculate the MAD\n  numbers.each\
    \ do |number|\n    mad << Math.sqrt(Math.pow(number - numbers.mean,2))\n  end\n\
    \  # Return the average\n  mad.average\nend\n</code>\nFor completeness, here's\
    \ a general function to calculate the Standard Deviation of a set of numbers\n\
    <code>", "  numbers.inject(0, :+) #add all elements to get sum of squares\n  numbers.reduce(:*)\
    \ #square the sum to get mean\n  numbers.reduce(:/) #take the quotient\nend",
  "    # Your code here\n    \nend\n</cell>\n<code language=julia-1.5>\nmean_absolute_deviation([1,3,4,5,7,2,4,1])\n\
    </cell>\n<text>\nQuiz Question: Using your function, calculate MAD of the following\
    \ dataset:", "  numbers.inject(0) {|sum, element| sum + Math.abs (element - sum)\
    \ }\n  numbers.inject(0) {|sum, element| sum + Math.sqrt (element - sum) }\n \
    \ numbers.inject(0) {|sum, element| sum + (element - numbers.mean) }\nend\n</code>\n\
    <|/ a tags=ruby,math,ruby-on-rails,deviation,math |>\n<| c |>\nThanks, this helped\
    \ a lot! However, I believe you mistyped something in the second part of the code,\
    \ should be `numbers.inject(0) {|sum, element| sum + (element - numbers.mean)\
    \ }`\n<|/ c |>\n<| c |>\nYes, thanks! I fixed it now. Also, just in case you were\
    \ wondering, I took out my sample data because I was lazy at the time, and didn't\
    \ want to write out your entire dataset.\n<|/ c |>\n<| a tags=ruby,math,ruby-on-rails,deviation,math\
    \ |>\n<code>", "    numbers.each{|x| p << x if x > p}\n    numbers.each{|x| p\
    \ << x if x < p}\n    p -= numbers.inject{|sum, x| sum + x}\n    p /= numbers.size\n\
    \    return p\nend", "  return numbers.inject(0.0) { |sum, number| sum + number.abs\
    \ } /\n      numbers.size.to_f\nend", "    avg = numbers.inject(:+).to_f / numbers.size\n\
    \    diff = numbers.map {|n| [n] - avg}\n    abs = diff.map{|n| n.abs}\n    ma\
    \ = abs.inject(:+) / numbers.size\nend\n</code>\n<|/ a dscore=5 tags=ruby,ruby-on-rails,algorithm,ruby-on-rails-3\
    \ |>\n<| c |>\nThis is a very nicely written answer. I am going to test it out\
    \ and see what my results are. Just one question: How do you get the mean and\
    \ standard deviation?\n<|/ c |>\n<| c |>\nI added some sample code. My code doesn't\
    \ compute the mean, so if you want that, you'll have to adapt it. But the standard\
    \ deviation is exactly the square root of the variance.\n<|/ c |>\n<| c |>\nI\
    \ tried to do that on my own, but it wasn't working out as I expected. Do you\
    \ think you could take a look at my implementation and tell me where I've gone\
    \ wrong? http://pastie.org/4103638\n<|/ c |>\n<| c |>\n: No, I can't take a look\
    \ at it, but I can tell you why it's wrong. Your code computes the standard deviation\
    \ for the whole set. Try that on [the sample data I provided](http://pastie.org/4103638#pastie-417510)\
    \ and see if it works.\n<|/ c |>\n<| c |>\nOkay, I see my mistake. I was looking\
    \ at the wrong set in my head :-P Thanks for your help!\n<|/ c |>\n<| a |>\nI\
    \ would just do this with standard ruby, no special libraries:\n<code>", "  mean\
    \ = numbers.inject(:+).to_f / numbers.size\n  squared_errors = numbers.map { |n|\
    \ (n - mean)**2 }\n  sum_squared_errors = numbers.inject(:+).to_f * numbers.inject(:+).to_f\n\
    \  Math.sqrt(sum_squared_errors / numbers.size)\nend", "  mean = (numbers.inject(:+)\
    \ / numbers.size)\n  deviations = numbers - mean\n  \n  mean = numbers.inject(:+)\
    \ / numbers.size\n  deviations = numbers - mean\n  \n  Math.sqrt(deviations.inject(:*,\
    \ :+) / (numbers.size - 1))\nend\n</code>\nNow lets create some simple test data:\n\
    <code>\ndata = [1, 2, 3, 5, 4, 6, 7]\n</code>\nNow we calculate the MAD of each\
    \ number\n<code>\n data.map { |num| mean_absolute_deviation(num) }\n #=> [2.447213595499958,\
    \ 1.5811388300841855, 1.5662524403273728, 1.574844065645844, \n     #=> 1.5687620508289925,\
    \ 1.5729478489206576, 1.573020751967644]\n</code>\nNow lets calculate the MAD\
    \ of each group of 3 numbers \n<code>\ndata = [1, 2, 3, 5, 4, 6, 7]", "  numbers.each\
    \ do |n|\n    sum = numbers.inject(0) do |sum, number|\n      sum + Float(number)/n.to_f\n\
    \    end\n  end\n  sum = numbers.inject(0) do |sum, number|\n    sum + Float(number)/numbers.count\n\
    \  end\n  sum.round(3)\nend", "  # Get Mean of numbers list\n  total = numbers.inject(:+)\
    \ # sum\n  mean = total / numbers.size  # average", "  numbers.collect{|x| x -\
    \ mean_of_nums(numbers)}.inject(:+).sqrt\nend", "  sum = 0\n  numbers.each do\
    \ |x|\n    sum = sum + x\n  end\n  mean = sum / numbers.size\n  numbers.each do\
    \ |x|\n    sum = sum - x\n  end\n  sum = sum / numbers.size\n  return sum / mean\n\
    end", "  numbers.each do |number|\n    deviation = [number[0] - number.mean]\n\
    \    deviation.push((number[1] - number.mean) * -1)\n    deviation = deviation.abs\n\
    \    mean += deviation.to_f\n  end\n  mean /= numbers.length\n  return mean\n\
    end", "  return numbers.inject(:+).to_f / numbers.inject(:+).count\nend", "  avg\
    \ = numbers.inject(0.0, :+) / numbers.size\n  sum = 0\n  for i in 0..numbers.size\
    \ - 1\n    sum = sum + abs(numbers[i] - avg)\n  end\n  mad =  sum / numbers.size\n\
    \  mad_with_mean = mad - avg\n  return mad \nend", "  numbers.map { |n| abs(n\
    \ - mean) }\nend\n</code>\nThe result is stored in an array:\n<code>\nnumbers",
  "    numbers.each_with_index do |number, index|\n        mean += number\n      \
    \  absolute += number ** 2\n        deviation += absolute - mean ** 2\n    end\n\
    \    deviation = deviation / (numbers.length - 1)\n    deviation\nend", "  numbers.inject(0)\
    \ do |sum, number|\n    sum += (number-numbers.mean)**2\n  end\n  numbers.inject(:sqrt)\
    \ do |sum, number|\n    sum + Math.sqrt(number)\n  end\nend", "  return Math.mean(numbers.map\
    \ {|x| Math.abs (x-Math.mean(numbers))})\nend", "  numbers.inject(0.0) do |sum,\
    \ number|\n    sum += (number - numbers.mean) ** 2\n  end\n  numbers.inject(0.0)\
    \ do |sum, number|\n    sum + Math.sqrt(sum / number)\n  end\nend", "  sum = numbers.inject(0)\
    \ {|sum, el| sum + el }\n  sum = numbers.inject(0) {|sum, el| sum + el }\n  avg\
    \ = sum / numbers.size\n  sum.inject(0) {|sum, el| sum + Math.abs ((el - avg)\
    \ * el) }\nend", "  sum_of_squares = numbers.inject(0) { |sum, el| sum += el.to_f**2\
    \ }\n  mean = numbers.inject(0) { |sum, el| sum += el }\n  variance = (sum_of_squares.to_f\
    \ / numbers.size - mean.to_f**2)\n  Math.sqrt(variance)\nend", "    # find the\
    \ mean\n    numbers.inject(0){ |sum, el| sum += el }\n    \n    numbers.inject(0){\
    \ |sum, el| sum += el / numbers.size  }\nend", "    numbers.each do |number|\n\
    \        mean = numbers.inject(0.0) { |sum, x| sum + x }\n        mean = mean\
    \ / numbers.length.to_f\n        numbers.each do |number|\n            diff =\
    \  number - mean\n            MAD += diff * diff\n        end\n    end\n    MAD\
    \ = MAD / numbers.length.to_f\n    return MAD\nend\n</cell>\n<cell>\nmean_absolute_deviation([2,\
    \ 4, 4, 7, 9, 9])\n</cell>\n<cell>", "  numbers = numbers.flatten.map { |n| n.to_i\
    \ }\n  mean = numbers.inject(:+) / numbers.size\n  result = numbers.map do |number|\n\
    \    (number - mean).abs\n  end\n  result.inject(:+) / result.size\nend", "  mean\
    \     = numbers.inject(:+) / numbers.size.to_f\n  deviations = numbers.map { |n|\
    \ n - mean }\n  mad.call(deviations, mean)\nend\n</code>\nTo find all values within\
    \ an interval of [100, 200] or [100, 2000] you can use\n<code>", "  numbers.inject(0.0)\
    \ { |sum, value| sum + Math.sqrt(value * value / numbers.count) }\nend\n</cell>\n\
    <code language=ruby-1.9.3-p448>", "    sum = 0.0\n    count = 0\n    numbers.each\
    \ do |num|\n        sum = sum + Math.abs num\n        count = count + 1\n    end",
  "  mean = numbers.inject(0.0) { |sum, el| sum + el }\n  numbers.map { |x| x - mean\
    \ }.reduce(:+) / numbers.size\nend", "  numbers.map! { |x| x - x.mean }\n  numbers.reduce(:+)\
    \ / numbers.size\nend", "  numbers.inject(0) do |sum, value|\n    sum + abs(value)\n\
    \  end\nend\n</code>\n<|/ a dscore=5 |>\n<| a dscore=5 |>\nYou can find the standard\
    \ deviation of a set of numbers using the following\n<code>", "  ma = 0.0\n  numbers.each\
    \ do |n|\n    ma += (n - numbers.mean) / numbers.stdev\n  end\n  ma\nend", " \
    \ numbers.inject(0){|sum, element| sum + element if element > 0}.abs\nend\n</code>\n\
    Then, your final calculation would be:\n<code>", "  mean = 0.0\n  numbers.each\
    \ { |n| mean += n }\n  mean /= numbers.size\n  sum = 0.0\n  numbers.each { |n|\
    \ sum += (n - mean) * (n - mean) }\n  return Math.sqrt(sum / numbers.size) # return\
    \ square root of the sum\nend", "    numbers.each do |number|\n        sum +=\
    \ abs(number)\n    end\n    sum = sum / numbers.length.to_f\n    sum\nend", " \
    \ numbers.inject(0) { |sum, number| sum + Math.abs number }\n  Math.sqrt(numbers.inject(0)\
    \ { |sum, number| sum + Math.pow(number, 2) })\nend", "  numbers.each_with_index\
    \ do |x, i|\n    yield(x, numbers[i])\n  end\nend", "  numbers.inject(0) {|sum,\
    \ num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n\
    \  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0)\
    \ {|sum, num| sum + num}\n  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f\
    \ ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n  numbers.inject(0) {|sum,\
    \ num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n\
    \  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0)\
    \ {|sum, num| sum + num}\n  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f\
    \ ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n  numbers.inject(0) {|sum,\
    \ num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n\
    \  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0)\
    \ {|sum, num| sum + num}\n  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f\
    \ ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n  numbers.inject(0) {|sum,\
    \ num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n\
    \  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0)\
    \ {|sum, num| sum + num}\n  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f\
    \ ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n  numbers.inject(0) {|sum,\
    \ num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0) {|sum, num| sum + num}\n\
    \  numbers.inject(0) {|sum, num| sum + Math.sqrt(num.to_f ^ 2)}\n  numbers.inject(0)\
    \ {|sum, num| sum + num}\n  numbers.inject(0) {|sum, ", "  numbers.collect{|num|\
    \ abs (num - mean)}\nend", "  numbers.inject(0) {|sum, number| sum + Math.pow(number\
    \ - numbers.mean(), 2)}\nend\n</cell>\n<text>\nFor our experiment, we will be\
    \ looking at all the measurements in our dataset - that is, the average of all\
    \ the measurements in the dataset.", "  mean = 0.0\n  for x in numbers\n    mean\
    \ += x \n  mean /= numbers.size\n  return mean \nend", "    numbers.each do |x|\n\
    \        sum += Math.abs - x\n    end \n    sum / (numbers.length)\nend\n</code>\n\
    The mean is calculated by taking the sum of the absolute values of the numbers,\
    \ and dividing by the number of elements.\nThe standard deviation is the square\
    \ root of the mean divided by the number of elements.  \nSo you have a standard\
    \ deviation that is the same as the standard deviation that you would have if\
    \ you just averaged the numbers themselves.  \n<code>", "  numbers.reduce(0) {|sum,\
    \ number| sum + Math.abs number }\nend", "  numbers.inject(0.0) do |sum, number|\n\
    \    sum = sum + number\n  end\n  numbers.inject(0.0) do |sum, number|\n    sum\
    \ = sum + number\n    sum\n  end\nend\n</code>\nYou would need to call the function\
    \ in each iteration of your loop:\n<code>\nfor x in numberlist\n  md = mean_absolute_deviation(x)\n\
    \  ...\nend\n</code>\n<|/ a |>\n<| c |>\nI tried implementing your code. I am\
    \ getting an undefined method \"inject\" error. I also tried redefining my functions\
    \ in the loop but that didn't work either.\n<|/ c |>\n<| c |>\nWhat version of\
    \ Ruby are you using? Ruby 1.8.7? `inject` is a method in the Ruby 1.9.2 standard.\n\
    <|/ c |>\n<| c |>\nI'm using 1.9.2p320. I think it's because I'm also using a\
    \ lot of ruby 1.9.1 stuff in the project. I'll try upgrading and see if it helps.\n\
    <|/ c |>\n<| c |>\nOk it seems like the problem is with the Ruby 1.9.1 gems. I'm\
    \ going to try updating them all and see if it works. Thanks for your help.\n\
    <|/ c |>\n<| a |>\nTo find the mean of the deviation around a number simply subtract\
    \ the number from its average and then divide by the number of deviations. \n\
    <code>", "    center = numbers.mean\n    abs_deviation = 0\n    numbers.each do\
    \ |num|\n        abs_deviation += abs(num - center)\n    end\n    abs_deviation\
    \ /= numbers.size\n    return abs_deviation\nend\n</code>\nThe reason I'm writing\
    \ it that way is so that I can use the same code for both data types. Since you're\
    \ doing it on numbers, you can use this method to calculate the mean and standard\
    \ deviation on them. However, you can do that for arrays as well like this:\n\
    <code>\narray = [1, 2, 3, 4, 5]\narray.mean", "    numbers.each do |num|\n   \
    \   diff = num - numbers.mean()\n      diff.abs\n    end\nend", "  numbers.inject(0)\
    \ { |sum, el| sum + Math.abs el - el }\n  numbers.inject(0) { |sum, el| sum +\
    \ Math.sqrt Math.pow((sum + el) / numbers.size, 2) }\n  numbers.inject(0.0) {\
    \ |sum, el| sum + el } / numbers.size\nend\n</code>\nThe first method will give\
    \ you the mean of the whole dataset, and the second method will give you the mean\
    \ of the dataset with mean subtracted.\n<|/ a tags=ruby,ruby-on-rails-3 dscore=3\
    \ |>\n<| a tags=ruby,ruby-on-rails-3 |>\n<code>", "  avg = numbers.inject(:+).to_f\
    \ / numbers.size\n  numbers.inject(0) do |sum, num|\n    sum += abs(num - avg)\n\
    \  end\nend\n</code>\nThen you just need to call it in your program:\n<code>\n\
    deviation_values = numbers.map { |n| mean_absolute_deviation([n]) }\n</code>\n\
    <|/ a tags=ruby-on-rails-3.2,ruby-on-rails,ruby |>\n<| c |>\nthanks for your response.\
    \ I am having problems getting this code to run. I think my problem is in how\
    \ I am calling it. Where do you specify where to call for the code you provided?\
    \ Do I put it in the controller or the model? Thanks\n<|/ c |>\n<| c |>\nYou will\
    \ need to call it in the controller. The code I provided is meant to be put into\
    \ your model and it will give the deviations. I wrote this from memory and haven't\
    \ tested it, so there may be typos. What happens now is that deviation_values\
    \ will contain the deviations from your original numbers. To use deviation_values\
    \ you will just have to call them like any other array.\n<|/ c |>\n<| c |>\nI\
    \ added the code to the model and I called it like you said but I still get an\
    \ error when trying to view my page. Here is my code:\n<|/ c |>\n<| c |>\nI just\
    \ added it to my model. Is there something else I should be doing since I still\
    \ get an error? thanks\n<|/ c |>\n<| c |>\nWhat is the error you are receiving?\
    \ Can you post the full error message please?\n<|/ c |>\n<| a tags=ruby-on-rails-3.2,ruby-on-rails,ruby\
    \ dscore=1 |>\n<code>", "  mean_number = numbers.inject(:+).to_f / numbers.size\n\
    \  squared_distances = numbers.map { |n| n**2 } - 2*numbers.map(&:to_f).inject(:+)\
    \ \n  mean = squared_distances.map { |n| n/numbers.size }.inject(:+) / numbers.size\n\
    \  Math.sqrt(mean)\nend", "  numbers.each_with_index.map{|n, i| [i, (n - numbers.at(i)).abs]\
    \ }.\n    collect{|x,y| y[1][0] }.\n    map{|x| x.inject(:+)/x.size }.\n    min\
    \ # smallest deviation\nend\n</code>\n<|/ a tags=ruby,mean,arrays,sorting,ruby-on-rails\
    \ |>\n<| c |>\nI like this answer because it can handle multi-dimensional arrays.\
    \  For a one dimensional array, it works, but for a two dimensional array, you'll\
    \ need to do some additional manipulation.  It works for the OP's example but\
    \ isn't going to work for every array.  I thought about making this a gem, but\
    \ it doesn't seem necessary as there is already a library that does this for you.\
    \  https://rubygems.org/gems/array_stats , check out their example.  I still don't\
    \ think there is a simple way to do what they want without writing this function.\n\
    <|/ c |>\n<| c |>\nThe OP didn't ask for a gem, they asked for a solution in their\
    \ rails project.  This is simple and straightforward, why would you need a gem?\n\
    <|/ c |>\n<| c |>\nOP said they have a rails project and they are using rails.\
    \ A gem is an external library. This is a very simple solution that doesn't require\
    \ a gem, so you think it adds no value.\n<|/ c |>\n<| c |>\nYou're right.  I thought\
    \ it would be nice to have this as a method on a library (like array_stats) so\
    \ others could use it without having to write any code at all.  I still think\
    \ writing a ruby method would add a little bit of value, but you're right, it's\
    \ not necessary in this case.\n<|/ c |>\n<| c |>\nI agree.  Writing a method for\
    \ something like this doesn't seem worth the overhead of doing it properly.  I\
    \ believe there are two reasons for this: 1) It can be easily modified into a\
    \ method that can handle multiple data types, like [this](https://stackoverflow.com/a/64878731/447356)\
    \ example for multiple datatypes.  2) It makes it easy to share the method with\
    \ others.  I would suggest using a gem for this, or at least a library like [active_support\
    \ array_stats](https://www.rubydoc.info/gems/activesupport/4.1.8/ActiveSupport/CoreExtensions/Array/Stats).\n\
    <|/ c |>\n<| a |>\nI believe this is a more elegant solution. It checks for nil\
    \ values before calculating a mean.\n<code>", "  means = numbers.inject(:+) /\
    \ numbers.size.to_f\n  differences = numbers.map { |n| n - means }\n  sum_differences\
    \ = differences.inject(:+) / numbers.size.to_f\n  Math.sqrt(sum_differences)\n\
    end", "  numbers.inject([:+]) do |sum, number|\n    sum + Math.sqrt(number **\
    \ 2)\n  end\nend\n</code>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
