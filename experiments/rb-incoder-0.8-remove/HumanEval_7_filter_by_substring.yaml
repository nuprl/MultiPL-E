name: HumanEval_7_filter_by_substring
language: rb
prompt: "# Filter an input list of strings only for ones that contain given substring\n\
  def filter_by_substring(strings, substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_filter_by_substring\n\
  \    candidate = method(:filter_by_substring)\n    assert_equal([], candidate.call([],\
  \ \"john\"))\n    assert_equal([\"xxx\", \"xxxAAA\", \"xxx\"], candidate.call([\"\
  xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"))\n    assert_equal([\"\
  xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], candidate.call([\"xxx\", \"asd\", \"aaaxxy\"\
  , \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"))\n    assert_equal([\"grunt\", \"\
  prune\"], candidate.call([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"\
  ))\n  end\nend\n"
completions: ["  strings.select { |s| s.include?(substring) }\nend", "  strings.select\
    \ { |str| str.include?(substring) }\nend\n</code>\nNote that this solution returns\
    \ an array of strings containing substrings, but you could modify it to return\
    \ an array of hashes of strings with keys that match the substring, which might\
    \ make more sense in certain circumstances.\n<|/ a tags=ruby,hash dscore=1 |>\n\
    <| a |>\nThis looks like a case for Enumerable#flat_map, which lets you map each\
    \ value to a new array and merge them all at once:\n<code>\nhash = {\n  'name'\
    \ => 'Mr Jones',\n  'address' => '1 Main St.',\n  'email' => ''\n}", "  strings_filter\
    \ = string.split(substring)\n  strings_filter.map! { |s| s.strip }\n  strings_filter.compact.uniq\n\
    end\n</code>\n<|/ a tags=ruby,substring,string dscore=1 |>\n<| a tags=ruby,substring,string\
    \ |>\n<code>", "  strings.select do |string|\n    string =~ substring ? true :\
    \ false\n  end\nend", "    strings.select { |s| s.include?(substring) }\nend",
  "  strings.select do |string| \n    string.include?(substring)\n  end\nend", " \
    \   filtered_strings = []\n    filtered_strings.concat(substring.split('|').map\
    \ { |s| s.gsub(\" \", \"\") })\n    strings.map { |s| s.gsub(substring, \"\")\
    \ }.each do |s|\n      filtered_strings.concat(s.split('|').map { |s2| s2.gsub(substring,\
    \ \"\") })\n    end\n    filtered_strings\nend", "  filtered_strings = []\n  strings.each\
    \ do |string|\n    if string.include?(substring)\n      filtered_strings << string\n\
    \    end\n  end\n  filtered_strings\nend\n</cell>\n<cell>", "  strings.select{|string|\
    \ string.include?(substring)}\nend", "  strings.select do |s|\n    s =~ /#{substring}/\n\
    \  end\nend", "  strings.select do |string|\n    string =~ /#{substring}/\n  end\n\
    end", "    filtered_strings = []\n    for string in strings\n        if string.include?(substring)\n\
    \            filtered_strings << string\n        end\n    end\n    return filtered_strings\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,regex |>\n<| c |>\nThanks for your answer,\
    \ it seems very helpful :) But how do I use this code in my own code? Do I need\
    \ to place it in a separate file or can I just put it in my main file? And what\
    \ do I have to add to get it working? I have tried to run it but I get an error\
    \ about undefined method 'scan' for Regexp.\n<|/ c |>\n<| c |>\nSure, that's why\
    \ I added the comment \"Filter an input list of strings only for ones that contain\
    \ given substring\". Just add your string into `filter_sub_strings` method. `filter_sub_strings(strings,\
    \ \"foobar\")` will give you a list of strings that contain \"foobar\".\n<|/ c\
    \ |>\n<| c |>\nI managed to get it working :) I guess I was making mistakes with\
    \ putting it together but I managed to do it now :)\n<|/ c |>\n<| a tags=ruby,regex\
    \ |>\nIf you have a lot of such strings, you may want to use Regexp#scan instead\
    \ of Regexp#match.\nHere is one example:\n<code>\nstrings = %w[foo-bar-baz foo-baz\
    \ foobar foobar-baz foobarbaz]\nstr_regex = /^foo(bar)?(-baz)?/\nstrings.select\
    \ do |str|\n  str_regex.scan(str)\nend\n</code>\nThe above code will give you\
    \ ['foo-bar-baz', 'foo-baz', 'foobar', 'foobar-baz', 'foobarbaz'].\nThe reason\
    \ why this approach is faster is because Regexp#match will loop through all matches\
    \ of pattern but Regexp#scan will stop searching once it finds the first match.\n\
    <|/ a dscore=1 |>\n<| c |>\nHi :) I ran your code but it didn't return any strings\
    \ for me :( I have also tried it with just one string but this also didn't work\
    \ :( Do I need to add something to your code or is it okay as is? Thanks!\n<|/\
    \ c |>\n<| c |>\nHi, I ran it on a Rails console, and it worked perfectly. Here\
    \ are some sample runs: http://pastebin.com/MjMmJnM4. Please let me know if you\
    \ have any more questions. Thanks.\n<|/ c |>\n<| c |>\nI have tried running it\
    \ again with your code and it gives me an undefined method 'scan' error :( I am\
    \ using Rub", "  strings.select { |x| x.include?(substring) }\nend", "  strings.select\
    \ { |string| string.include? substring }\nend\n</pre>\n            </div>\n  \
    \        \n          \n          \n          \n          \n            \n    \
    \        <div class=\"sourcecode\">\n              \n              <p class=\"\
    source-link\">\n                Source: \n                <a href=\"javascript:toggleSource('method-i-filter_by_substring_source')\"\
    \ id=\"l_method-i-filter_by_substring_source\">show</a>\n                \n  \
    \            </p>\n              <div id=\"method-i-filter_by_substring_source\"\
    \ class=\"dyn-source\">\n                <pre><span class=\"ruby-comment\"># File\
    \ /usr/local/rvm/gems/ruby-2.0.0-p0/gems/activesupport-4.0.0/lib/active_support/core_ext/string/filters.rb,\
    \ line 11</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">filter_by_substring</span>(<span class=\"ruby-identifier\">strings</span>,\
    \ <span class=\"ruby-identifier\">substring</span>)\n  <span class=\"ruby-identifier\"\
    >strings</span>.<span class=\"ruby-identifier\">select</span> { <span class=\"\
    ruby-operator\">|</span><span class=\"ruby-identifier\">string</span><span class=\"\
    ruby-operator\">|</span> <span class=\"ruby-identifier\">string</span>.<span class=\"\
    ruby-identifier\">include?</span> <span class=\"ruby-identifier\">substring</span>\
    \ }\n<span class=\"ruby-keyword\">end</span></pre>\n              </div>\n   \
    \         </div>\n            \n          </div>\n        \n        <div class=\"\
    method\">\n          <div class=\"title method-title\" id=\"method-i-grep\">\n\
    \            \n              <b>grep</b>(regexp, *args, &amp;block)\n        \
    \    \n            <a href=\"../../../classes/String.html#method-i-grep\" name=\"\
    method-i-grep\" class=\"permalink\">Link</a>\n          </div>\n          \n \
    \         \n            <div class=\"description\">\n              <p>Passes each\
    \ string in the <a href=\"../../../classes/String.html\">String</a> to a block,\
    \ replacing\neach substring that matches <code>regexp</code> with <code>replace</code>.\n\
    <code>block</code> receives the matching substring as its argument. If <code>replace</code>\n\
    is supplied, each replacement will be prefixed with the string supplied\nfor its\
    \ <code>^</code> character.</p>", "  strings.select do |string|\n    string =~\
    \ /#{substring}/\n  end\nend", "  strings.select { |s| s.include?(substring) }\n\
    end", "    substring = substring.downcase\n    substring = substring.gsub(/[^a-zA-Z0-9\\\
    -]/, '') # Remove any non-alphanumeric characters\n    strings = strings.select{|s|\
    \ s.include? substring }\nend", "  strings.select do |str|\n    str.include?(substring)\n\
    \  end\nend\n</code>\n<|/ a dscore=2 tags=arrays,ruby,string |>\n<| a tags=arrays,ruby,string\
    \ dscore=1 |>\n<code>", "    filtered_strings = []\n    for string in strings\n\
    \        if string.include? substring\n            filtered_strings << string\n\
    \        end\n    end\n    filtered_strings\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This is just what I was looking for. Thank you.\n<|/ c |>\n<| a dscore=1 tags=string,arrays,ruby\
    \ |>\nI believe that in Ruby, String already has all kinds of useful string methods,\
    \ including String#include?, which can be used to test if one string includes\
    \ the other:\n<code>\n> \"abcd\".include? \"abc\"\n=> true\n> \"abcd\".include?\
    \ \"bcd\"\n=> false\n</code>\nTo get just the strings, you may use String#split,\
    \ splitting the string into an array of strings:\n<code>\n> \"abc def\".split\n\
    => [\"abc\", \"def\"]\n</code>\nThen you can filter those strings by using String#include?:\n\
    <code>\n> \"abc def\".split # split into array of strings\n=> [\"abc\", \"def\"\
    ]", "  # Return all elements for which given substring is contained somewhere\n\
    \  # in them\n  return strings.select { |s| s.include? substring }\nend", "\t\
    strings = strings.reject {|s| s.include?(substring) }\nend", "  strings.select!\
    \ { |string| string.include?(substring) }\nend", "  strings.select { |string|\
    \ string.include? substring }\nend", "  strings.select { |x| x =~ /.*#{substring}.*/i\
    \ }\nend", "  filtered = []\n  strings.each do |s|\n    if s.include?(substring)\n\
    \      filtered << s\n    end\n  end\n  filtered\nend\n</cell>\n<text>\nNow let's\
    \ try it:", "  strings.select { |string| string.include?(substring) }\nend", " \
    \ strings.select { |str| str.include?(substring) }\nend", "  strings.select {\
    \ |s| s.include?(substring) }\nend", "  filtered_strings = []\n  strings.each\
    \ do |string|\n    string.include?(substring) ? filtered_strings << string : nil\n\
    \  end\n  filtered_strings\nend", "  strings.select{|s| s.include?(substring)\
    \ }\nend", "  strings.select { |i| i.include?(substring) }\nend", "  # If no substring,\
    \ return an empty list\n  return strings.to_a.select { |s| s.include? substring\
    \ }\nend", "  strings = strings.collect{|s| s.downcase}\n  strings.reject!{|s|\
    \ s.include?(substring)}.to_a.join(\", \")\nend", "    strings.each do |str|\n\
    \        if str.include?(substring)\n            yield str\n        end\n    end\n\
    end", "    strings.select do |string|\n        string =~ /#{substring}/ # Match\
    \ substring anywhere in string\n    end\nend", "  new_strings = []\n  strings.each\
    \ do |string|\n    break if string.downcase.include?(substring.downcase)\n   \
    \ new_strings << string\n  end\n  return new_strings\nend", "  strings.select\
    \ { |i| i.include? substring }\nend", "  return strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings = strings.map do |s|\n    s =~ /#{substring}/ ? s : nil\n\
    \  end\n  strings\nend", "  strings.select{|s| s.include? substring}\nend", " \
    \ strings.select { |string| string.include?(substring) }\nend", "  strings.select\
    \ { |s| s.include?(substring) }\nend", "  string_list.all?(&:include?(substring))\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you for your answer! I appreciate it. I\
    \ see what you are doing here and I agree that the use of global variables is\
    \ generally considered an anti-pattern, but I'm not sure why you consider it here.\
    \ Also, why do you say that the use of global variables is generally considered\
    \ an anti-pattern? If this was my code, I would be more interested in how I would\
    \ be able to refactor it to avoid this problem.\n<|/ c |>\n<| c |>\nAs a matter\
    \ of fact, using global variables is not a good pattern in general. Global variables\
    \ are considered bad because they make your code less modular and reusable. A\
    \ more modern approach is to use class attributes to share data between methods.\
    \ Also, global variables can be \"bad\" when used incorrectly. [Here](https://refactoring.guru/single-responsibility)\
    \ is a great article explaining why global variables are considered an anti-pattern.\n\
    <|/ c |>\n<| c |>\nYeah I read that article and I appreciate the advice. I guess\
    \ I was just wondering why you considered it bad practice in my case. Is using\
    \ a class variable the same as using a global variable?\n<|/ c |>\n<| c |>\nYes\
    \ exactly, they are just variable names. A class variable is just a global variable\
    \ that you can access through a getter and setter method.\n<|/ c |>\n<| c |>\n\
    I updated my question with your refactoring suggestions. Thanks again for your\
    \ help!\n<|/ c |>\n<| a |>\nThe main thing you need to remember is that Ruby methods\
    \ return nil if they don't succeed. So instead of returning nothing or returning\
    \ nil, you should raise an exception instead.\n<code>", "  return strings.select\
    \ { |str| str.index(substring) != nil } if strings.length > 0\n  []\nend", " \
    \ strings.select{ |s| s.include?(substring) }\nend", "    strings = [s for s in\
    \ strings if substring in s]\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n<| c |>\nThe question\
    \ was about Ruby 1.8.7, which doesn't have `String#include?`. And Ruby 1.9.2+\
    \ has `String#include?` as of version 1.9.3, which was released in April 2013.\n\
    <|/ c |>\n<| a dscore=1 |>\nRuby 1.9.3 now has a String#include?() method.\n<code>\n\
    > require 'rubygems'\n> require 'test/unit'\n> include Test::Unit", "  strings.select\
    \ { |str| str.include?(substring) }\nend", "  return strings.select { |string|\
    \ string.include? substring }\nend\n</code>\nAnd finally the filter_by_substring\
    \ method will be used as:\n<code>\nstrings = %w[apple banana orange banana kiwi]\n\
    substring = \"banana\"", "  strings.select { |string| string.include? substring\
    \ }\nend", "  strings.select{|s| s.include?(substring)}.first\nend", "  filtered_strings\
    \ = []\n  strings.each do |string|\n    if string.include?(substring)\n      filtered_strings\
    \ << string\n    end\n  end\n  filtered_strings\nend\n</code>\n<|/ a tags=ruby-on-rails\
    \ |>\n<| a dscore=0 |>\nYou can find all the substring matches in an array with\
    \ a regular expression:\n<code>\nstrings = [\"this\", \"is\", \"a\", \"test\"\
    , \"with\", \"some\", \"numbers\", \"and\", \"some\", \"other\", \"text\"]", " \
    \ strings = strings.map { |s| s.substring substring, 0 }\nend\n</code>\n<|/ a\
    \ dscore=5 tags=ruby,regex |>\n<| c |>\n`/\\A#{Regexp.escape(substring)}/m` would\
    \ be a slightly more robust solution. `/\\A(?:#{Regexp.escape(substring)})/m`\
    \ would also handle `\"#{substring}\"` and `substring`, but only as a literal.\
    \ If you are looking for any *single* occurrence of substring regardless of whether\
    \ it appears within a larger string, then `\\A#{Regexp.escape(substring)}` is\
    \ sufficient.\n<|/ c |>\n<| c |>\nIf you're going to use the `m` flag, be aware\
    \ that the `^` anchor (beginning of string) won't be matched unless the entire\
    \ pattern matches the beginning of the string, which isn't going to be the case\
    \ when your pattern has special characters.\n<|/ c |>\n<| c |>\nAs a general rule,\
    \ I try to avoid `/m` unless I'm specifically trying to match across multiple\
    \ lines (that is, unless I'm actually trying to extract a pattern with newlines).\
    \ For example, if you need to match `(?s)foo`, then you probably don't want to\
    \ use `/m`, but instead use `/(?s)foo/.match('abc\\n')` will match but `'abc\\\
    n'.match /(?s)foo/` won't. In most cases, you're probably better off using `/(?s)foo/m`\
    \ (note the added `m` flag).\n<|/ c |>\n<| c |>\nIf you're using `/(?s)foo/`,\
    \ be aware that this will also match `foo` if the string contains `foo` *with*\
    \ newlines.\n<|/ c |>\n<| c |>\n\"It would be better to use\" `/^...$/` instead?\
    \ I'm wondering, what happens when the string is `\"...\"`? Doesn't that mean\
    \ that the regex is matching against the empty string? Or am I missing something\
    \ here?\n<|/ c |>\n<| a |>\nIt is not always possible, for example, if the pattern\
    \ may contain non-word characters (non-letter/digit/underscore/etc.).\n<code>\n\
    text = \"abcde123 dfg4356 ghi7890 jkl0123\"\npattern = \"(123|456|789)\"", " \
    \   strings.map! do |string|\n        if string.include?(substring)\n        \
    \    string\n        end\n    end\n    strings\nend\n</cell>\n<code language=julia-1.5>\n\
    strings = [\"This is a test\", \"and here is a test\", \"Another test\", \"This\
    \ is a test\"]\nsubstring = \"test\"\n</cell>\n<code language=julia-1.5>\nfilter_by_substring(strings,\
    \ substring)\n</cell>\n<text>\nFiltering by number", "  strings.select { |string|\
    \ string.include?(substring) }\nend", "    strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select { |str| str.include?(substring) }\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI'm sorry for asking but I can't get your method to\
    \ work - could you please show an example of how you might call it?\n<|/ c |>\n\
    <| c |>\nI wrote an answer with working code. Hope this helps.\n<|/ c |>\n<| a\
    \ tags=arrays,ruby,contains,substring dscore=4 |>\nAn approach with Array#include?.\
    \ \n<code>\n[true, false, nil, :true, \"test\"].reject { |e| e == nil || e.include?\
    \ false }", "  return strings.select { |s| s.include? substring }\nend\n</code>\n\
    You could then use it like:\n<code>\ninput_list = [\"apple\", \"pear\", \"grape\"\
    ]\nsubstring = \"e\"\nresult = filter_by_substring(input_list, substring)\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-5 dscore=3 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-5\
    \ |>\nYou can use Enumerable#grep\n<code>\nlist = [\"apple\", \"pear\", \"grape\"\
    ]\nlist = list.grep(/e/)\nlist.class # => Array\n</code>\n<|/ a dscore=2 |>\n\
    <| a |>\nTo build on other answers, if you're interested in matching substrings,\
    \ instead of exact matches, you can also use the following which also allows for\
    \ partial matches or a regex pattern to be used:\n<code>\nlist = [\"apple\", \"\
    pear\", \"grape\"]\nlist = list.grep(/pe/)\nlist.class # => Array\n</code>\n<|/\
    \ a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-5 |>\n<| a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-5\
    \ |>\nThe answer given by is good for beginners.\nBut there are many ways to do\
    \ this.\nHere is the code snippet that helps me to understand clearly.\n<code>\n\
    a = [\"apple\", \"pear\", \"grape\"]\nb = a.grep(/pe/)\nb.class", "  return strings.select\
    \ { |s| s.include?(substring) }\nend", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails |>\n<| a |>\nHere\
    \ is a more generic method that does a case-insensitive regex search of a string:\n\
    <code>", "  strings.select{|s| s.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select!\
    \ do |string|\n    !string.include?(substring)\n  end\nend", "  return strings.select\
    \ do |s|\n    s =~ /#{substring}/\n  end\nend", "    filtered_strings = []\n \
    \   for string in strings\n        if substring in string\n            filtered_strings\
    \ << string\n        end\n    end\n    return filtered_strings\nend", "  # Iterate\
    \ over each string in the list\n  strings.each do |string|\n    # Iterate over\
    \ each character in the string\n    string.chars.each do |char|\n      # If the\
    \ substring contains a character from the current string\n      if substring.include?(char)\n\
    \        strings << string\n        break\n      end\n    end\n  end\nend", " \
    \ strings.select { |string| string.include?(substring) }\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  return strings.select\
    \ { |s| s.include?(substring) }\nend", "  return strings.select {|s| s.include?\
    \ substring }\nend", "  strings.select { |string| string.include?(substring) }\n\
    end", "  filtered_strings = []\n  filtered_strings.concat(substring) if strings.include?\
    \ substring\n  filtered_strings.concat(strings).except(filtered_strings)\nend",
  "  strings.grep(/#{substring}/)\nend", "  strings.select{ |string| string.include?(substring)\
    \ }\nend", "  strings.select { |string| string.include?(substring) }\nend", " \
    \ # Return a list of strings that have substring\n  matching_strings = []\n  strings.each\
    \ do |string|\n    if string.include?(substring)\n      matching_strings.push(string)\n\
    \    end\n  end\n  return matching_strings\nend", "    filtered_strings = []\n\
    \    strings.each do |string|\n        if string =~ /#{substring}/i\n        \
    \    filtered_strings << string\n        end\n    end\n    filtered_strings\n\
    end", "  strings.select { |string| string.include?(substring) }\nend\n</code>\n\
    If you use some functional programming you should be able to make it shorter but\
    \ I would have to learn how to do that.\n<|/ a |>\n<| c |>\n`filter_by_substring`\
    \ is wrong, try `filter_by_substring([1,2,3],\"1\")`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nIf you have a relation like Post has_many :comments then you can do\n<code>\n\
    Post.joins(:comments).where(\"comments.body LIKE '%some_string%'\")\n</code>\n\
    <|/ a dscore=1 |>\n<| a |>\nThe code as below will search all Posts and then for\
    \ each Post search all the Comments to find if the string 'something' exists in\
    \ Comments:\n<code>\nPost.all.each do |p|\n  p.comments.each do |comment|\n  \
    \  if comment.body == 'something'\n      p << comment\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| a tags=ruby,ruby-on-rails dscore=0\
    \ |>\nYou can use joins to do something like this.\n<code>\nComment.joins(post:\
    \ :user).where(post_id: 1, body: params[:body])\n</code>\n<|/ a |>\n<| c |>\n\
    This won't work because `Comment` does not have a `post_id` column (or have a\
    \ `user_id` column).  But this query will also not work because `body` would need\
    \ to be in the `WHERE` clause.  I believe he needs to query for a specific `Post`\
    \ first, then query its associated `Comments`.\n<|/ c |>\n<| c |>\nYes, you're\
    \ right. I missed that. I'll update the answer.\n<|/ c |>\n<| c |>\nNo problem,\
    \ I've updated my answer.\n<|/ c |>\n<| c |>\nThanks, this does work. I'm curious\
    \ if there is an alternative solution using pure ruby, and maybe some fancy `#select`\
    \ method.\n<|/ c |>\n<| c |>\nI don't think so. `select` wouldn't help because\
    \ you're not just selecting records from `Comments`; you're selecting records\
    \ from `Comments` based on a criteria on a different table.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nYou could do something like this using where and join\n<code>\nPost.joins(:comments).where('comments.body\
    \ LIKE ?', \"%#{param", "  substring_positions = []\n  strings.each do |s|\n \
    \   substring_positions << s.index(substring)\n  end\n  substrings_positions =\
    \ []\n  substring_positions.each do |pos|\n    substrings_positions << pos+1\n\
    \  end\n  substrings_positions.flatten\nend", "  strings.select do |string|\n\
    \    string.include?(substring)\n  end\nend", "    string_list.each do |string|\n\
    \        next if string =~ /#{substring}/\n        puts \"\\t\" + string\n   \
    \ end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt was indeed the grep command\
    \ that solved my issue. Thanks a lot for your help and suggestions!\n<|/ c |>\n\
    <| a tags=ruby,file-io,ruby-on-rails,ruby-on-rails-3,rake |>\nAs I understand\
    \ your question, you want to extract all lines which contain a given substring.\
    \ In this case you might want to use grep command of GNU coreutils:\n<code>\n\
    grep \"pattern\" myfile.txt\n</code>\nAnd here is a Ruby implementation of this\
    \ command:\n<code>", "  strings.select { |str| str.index(substring) != -1 }\n\
    end", "  strings.select { |str| str.include?(substring) }\nend", "  strings.select\
    \ do |s|\n    s =~ /#{substring}/\n  end\nend", "  strings.select { |s| s =~ /#{substring}/i\
    \ }\nend", "  strings[strings.include?(substring)] = \"\"\nend", "  strings.each\
    \ do |string|\n    return true if string =~ /^.*#{substring}.*$/\n  end\n  false\n\
    end", "  strings.select { |s| s.include?(substring) }\nend\n</cell>\n<cell>\n\
    filter_by_substring('a b c', 'b')\n</cell>\n<cell>\nfilter_by_substring('a b c\
    \ d', 'd')\n</cell>\n<text>\nWe can write it in a more compact way:", "  strings.select\
    \ { |string| string.index(substring) != nil }\nend", "  strings.select { |string|\
    \ string =~ Regexp.new(substring) }\nend", "  strings.select do |string|\n   \
    \ string.index(substring) != nil\n  end\nend", "  strings.reject{ |s| s.include?(substring)\
    \ }\nend", "  strings.select{|str| str.include?(substring)}.to_a\nend", "  # Return\
    \ only the input list that has at least one occurrence of substring\n  strings.select\
    \ do |string|\n    string.index(substring) != nil\n  end\nend", "  strings.select\
    \ do |string|\n    string.include?(substring)\n  end\nend", "  strings.select\
    \ { |str| str.include?(substring) }\nend", "  strings.select do |string|\n   \
    \ string.include?(substring)\n  end\nend", "\tresult = []\n\t\n\tstrings.each\
    \ do |string|\n\t\tresult << string if string =~ Regexp.new(substring)\n\tend",
  "  strings.reject! do |string|\n    string.include?(substring)\n  end\nend\n</code>\n\
    Now you can just write:\n<code>\nfilter_by_substring(strings, \"some string\"\
    )\n</code>\nThe reason I like to use the reject method like this is that it returns\
    \ an enumerator. That way, you don't have to do an if check or anything else to\
    \ see if the filter works or not. You just have to iterate the enumerator and\
    \ it will only return those strings that contain \"some string\".\n<code>\nstrings\
    \ = [\"some string\", \"some longer string\"]", "  strings.select{|string| string.include?\
    \ substring}\nend", "    strings.select { |string| string.include?(substring)\
    \ }\nend", "  strings.select { |s| s.include?(substring) }\nend\n</code>\nIn your\
    \ controller method, call it like this:\n<code>", "    strings.select do |string|\n\
    \      string.include? substring\n    end\nend\n</code>\nAnd then we know that\
    \ we can easily find the substrings we want.\n<code>\nstrings = [\"a\",\"bc\"\
    ,\"def\",\"ghi\",\"jkl\",\"mno\",\"pqr\",\"stu\",\"vwx\",\"yz\"]\nsubstrings =\
    \ [\"def\", \"yz\"]\n</code>\nWe can then filter the list of strings by checking\
    \ to see if the string includes the substrings.\n<code>\nsubstrings.map do |substring|\n\
    \  filter_by_substring(strings, substring)\nend\n</code>\nAnd that's it for finding\
    \ your substrings! Let's go through this a little more slowly to understand how\
    \ this works. What we're doing is first finding a list of strings that we want\
    \ to filter, and then we're finding all the substrings that we want to check against.\n\
    <code>\nstrings = [\"a\",\"bc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqr\",\"stu\"\
    ,\"vwx\",\"yz\"]\nsubstrings = [\"def\", \"yz\"]", "  filtered_strings = []\n\
    \  strings_with_regex = []\n  strings.each do |string|\n    string =~ Regexp.new(substring,\
    \ Regexp::IGNORECASE)\n    filtered_strings << string unless filtered_strings.include?(string)\n\
    \    strings_with_regex << string if filtered_strings.include?(string)\n  end\n\
    \  filtered_strings = strings_with_regex\n  filtered_strings\nend", "  filtered_strings\
    \ = []\n  filtered_strings.concat strings.select{|string| string =~ /#{substring}/i}\n\
    \  filtered_strings\nend\n</code>\nAs for your second problem, it appears to be\
    \ that your file name is too long. Windows can not handle file names longer than\
    \ 260 characters. Please see if there is a better way to solve that problem.\n\
    <|/ a dscore=2 |>\n<| a dscore=1 tags=ruby,ruby-on-rails,windows,ruby-on-rails-3\
    \ |>\nI have seen your issue before. Looks like you cannot have spaces in your\
    \ file name.\n<|/ a |>\n<| c |>\nhow can i solve it please ?\n<|/ c |>\n<| c |>\n\
    If you have a filename like \"Test - Copy.txt\" then ruby thinks the space is\
    \ part of the filename. That is why your code fails.\n<|/ c |>\n<| c |>\nhow can\
    \ i solve it please ?\n<|/ c |>\n<| c |>\ntry renaming your file with one that\
    \ does not contain spaces. Like \"TestCopy.txt\". Or try using a backslash in\
    \ the filename: \"Test - Copy.txt\".\n<|/ c |>\n<| c |>\nhow can i solve it please\
    \ ?\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,windows,ruby-on-rails-3 |>\nI noticed\
    \ this too. One of the gems that I use on windows is rubyzip which can be downloaded\
    \ from here. The source is also available on github and can be installed with\n\
    <code>\ngem install rubyzip --platform=ruby\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nthanks ! but i don't know how should i do that can you please tell me ?\n\
    <|/ c |>\n<| c |>\nWhat do you mean? That you do not know how to use it on Windows?\n\
    <|/ c |>\n<| c |>\nyes i don't know how should i use it on windows ?\n<|/ c |>\n\
    <| c |>\nHow should i use this gem in my project ?\n<|/ c |>\n<| c |>\nAs I said,\
    \ it can be installed with\n`gem install rubyzip --platform=ruby`\n<|/ c |>\n\
    <| a |>\nI was able to fix this by doing this:\n<code>", "  return strings.select\
    \ do |string|\n    string.index(substring) != nil\n  end\nend\n</code>\nNow you\
    \ can implement your filter_by_substring method in this way:\n<code>", "  new_strings\
    \ = []\n  for string in strings\n    if string.include? substring\n      new_strings\
    \ << string\n    end\n  end\n  new_strings\nend", "  strings.select { |s| s.include?\
    \ substring }\nend\n</code>\nAnd then you can chain these to find those that match\
    \ the substring you're looking for:\n<code>", "  strings = strings.collect { |str|\
    \ str.index(substring) }\n  strings = strings[0..-2] unless strings.size == 1\n\
    \  strings\nend", "\tresult = {}\n\tstrings.each do |string|\n\t\tif string.include?\
    \ substring\n\t\t\tresult[ string ] = true\n\t\tend\n\tend\n\treturn result\n\
    end", "  strings.select { |string| string.include?(substring) }\nend", "  strings.select\
    \ { |string| string =~ /#{substring}/ }\nend", "    filtered_strings = []\n  \
    \  for string in strings\n        if string.include?(substring)\n            filtered_strings\
    \ << string\n        end\n    end\n    return filtered_strings\nend", "  strings.select\
    \ { |string| string.include?(substring) }\nend", "  return strings.select {|s|\
    \ s.include?(substring)}\nend", "    strings.select do |e|\n        e.include?(substring)\n\
    \    end\nend", "    strings.select { |x| x =~ substring }\nend", "  # Return\
    \ a new array of strings where every string in the original list contains a given\
    \ substring \n  new_strings = []\n  strings.each do |s|\n    next if s.include?(substring)\n\
    \    new_strings << s\n  end\n  new_strings\nend\nputs filter_by_substring([1,\
    \ 2, 3, 4], 2)", "  strings.grep(Regexp.new(substring))\nend", "  strings.select\
    \ { |string| string.include?(substring) }\nend", "  filtered = Array.new(strings.length)\n\
    \  i = 0\n  while i < strings.length\n    next if strings[i].sub!(/\\A.*#{Regexp.escape(substring)}/i,\
    \ '')\n    filtered[i] = strings[i]\n    i += 1\n  end\n  filtered\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for this. This is helpful. Although it didn't solve\
    \ the issue with my original code, it did fix my problem in this specific instance.\
    \ It looks like the code I originally posted worked fine.\n<|/ c |>\n<| c |>\n\
    Nice to hear that you\u2019ve found a solution that works for you. I\u2019d also\
    \ suggest you take a look at [this question](http://stackoverflow.com/q/317499/128421).\
    \ If you have any questions about regexes or what they can do, feel free to ask\
    \ them on here or on that question!\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\nI was able to fix this problem using the following code:\n<code>", "   \
    \ strings.select { |s| s.include? substring }\nend\n</code>\nTo use this filter,\
    \ I will need to define variables:\n<code>\nstrings = ['foo', 'bar foo', 'bar\
    \ bar']\nsubstring = 'bar'\n</code>\nThen I can just call the function:\n<code>\n\
    filter_by_substring(strings, substring)\n</code>\nAnd get:\n<code>", "\tfiltered_strings\
    \ = \"\"\n\tmatching_strings = \"\"\n\tstrings.each do |string|\n\t\tif string.include?\
    \ substring\n\t\t\tfiltered_strings << string\n\t\telse\n\t\t\tmatching_strings\
    \ << string\n\t\tend\n\tend\n\treturn filtered_strings, matching_strings\nend",
  "  strings.select { |string| string.include? substring }\nend", "  strings.select\
    \ { |string|\n    string.include?(substring)\n  }\nend", "    strings.each do\
    \ |s|\n        s !~ Regexp.new(substring)\n    end\nend", "  strings.select {\
    \ |s| s.include?(substring) }\nend\n</code>\nNow, we filter using our own function.\
    \ Here, we filter all strings starting with a \"c\" in the array that contains\
    \ \"c\".\n<code>\n> strings = [\"abc\", \"ac\", \"abcde\", \"a\", \"c\", \"ac\"\
    , \"d\", \"c\"]\n> filter_by_substring(strings, \"c\")\n => [\"abc\", \"ac\",\
    \ \"ac\", \"abcde\", \"c\", \"c\", \"d\"]\n</code>\n<|/ a dscore=0 tags=ruby,arrays\
    \ |>\n<| a dscore=0 tags=ruby,arrays |>\nYou can do it like this:\n<code>\nstrings\
    \ = [\"abc\", \"ac\", \"abcde\", \"a\", \"c\", \"ac\", \"d\", \"c\"]\nstring.select\
    \ { |s| s.include?(\"c\") }\n</code>\nOutput:\n<code>\n[\"abc\", \"ac\", \"ac\"\
    , \"abcde\", \"c\", \"c\", \"d\"]\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\n\
    Try this: \n<code>", "  strings.select do |string|\n    string.include? substring\n\
    \  end\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-3 |>\n<| c |>\n\
    Thanks a lot for that. I will try it out, but what if I want only those users\
    \ that have a user account that is linked to a specific account? If not, then\
    \ how do I achieve this?\n<|/ c |>\n<| c |>\nAgain - thanks a lot. Very helpful\
    \ indeed. I will have to try it out but in the meantime I have an idea for my\
    \ app, so hopefully it'll work for me. Thanks!\n<|/ c |>\n<| c |>\nI've made a\
    \ mistake in my last comment. I have tried this, but now I realize that it doesn't\
    \ seem to work. I'm getting an error `undefined method 'first' for #<User:0x10b596840>`",
  "  strings[strings.index{$string ~ /#{substring}/}-1]\nend", "  strings.select {\
    \ |string| string.include?(substring) }\nend", "  strings.select { |string| string.include?(substring)\
    \ }\nend", "  strings.select { |s| s.include?(substring) }\nend", "    filtered_strings\
    \ = []\n    for string in strings\n        if string.include?(substring)\n   \
    \         filtered_strings << string\n        end\n    end\n    filtered_strings\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nI used the regex pattern\
    \ to filter the string but using scan method of String class is more efficient\
    \ :\n<code>\nstr = \"the quick brown fox jumps over the lazy dog\"\npattern =\
    \ /(quick|brown|fox|jumps)/i\nstr.scan(pattern)\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nYes, this is definitely the best solution to filter strings in ruby.\n\
    <|/ c |>\n<| c |>\n`str.scan(pattern)` will match `quick` and `quickie` both which\
    \ is not desired as I believe.\n<|/ c |>\n<| c |>\n: I believe you're right. `str.scan(pattern)`\
    \ would only match `quick` or `brown`.\n<|/ c |>\n<| a |>\n<code>\n\"the quick\
    \ brown fox jumps over the lazy dog\".split %w| quick brown fox jumps |\n</code>\n\
    <|/ a dscore=5 tags=ruby |>\n<| c |>\nThis is the answer that doesn't require\
    \ any loops\n<|/ c |>\n<| c |>\nThis does not answer the question, which asks\
    \ for an array.\n<|/ c |>\n<| c |>\nHow do you make this work for arrays?\n<|/\
    \ c |>\n<| a |>\n<code>\n> str = 'the quick brown fox jumps over the lazy dog'\n\
    > arr = str.split(\" \").select {|x| x == \"quick\" || x == \"brown\" || x ==\
    \ \"fox\" || x == \"jumps\"}\n> arr\n=> [\"quick\", \"brown\", \"fox\", \"jumps\"\
    ]\n</code>\n<|/ a tags=ruby dscore=4 |>\n<| c |>\nI like this solution, since\
    \ it is easy to read and easy to extend.  Also, with Ruby 1.9, `x.in?` would work\
    \ nicely.\n<|/ c |>\n<| a dscore=4 tags=ruby |>\nIf you want to use arrays, you\
    \ can use the select method\n<code>\narray = ['the quick brown fox jumps over\
    \ the lazy dog', 'hello world']", "  return strings.select { |s| s =~ Regexp.new(substring)\
    \ }\nend", "  strings.select{|string| string.include?(substring)}\nend\n</code>\n\
    The first part is where you can add your custom functionality (e.g., using an\
    \ ActiveRecord or ActiveSupport extension). \nThe second part is the actual method\
    \ call.\nThe third part is the actual method invocation.\n<|/ a tags=ruby |>\n\
    <| c |>\nI did not downvote, but I would guess that is because you don't explicitly\
    \ explain how to make the method work.\n<|/ c |>\n<| a dscore=2 |>\nThe #include?\
    \ method can be called on the String class which acts as an alias for the String's\
    \ include? method.  \n<code>", "    filtered_strings = []\n    string.gsub!(substring,\
    \ \"\") \n    strings.each do |string|\n        string.gsub!(substring, \"\")\
    \ \n        filtered_strings << string unless string == \"\"\n    end\n    filtered_strings\n\
    end", "    strings.select { |s| s.include?(substring) }\nend", "    filtered_strings\
    \ = []\n    \n    strings.each do |string|\n      if string.include?(substring)\n\
    \        filtered_strings << string\n      end\n    end", "  strings.select do\
    \ |string|\n    string.include? substring\n  end\nend", "  filtered_strings =\
    \ []\n  strings.each do |string|\n    filtered_strings << string if string.include?(substring)\n\
    \  end\n  filtered_strings\nend", "  strings.select{|str| str.include?(substring)}.to_a\n\
    end", "  strings.select do |string|\n    string.include?(substring)\n  end\nend",
  "  strings.select do |string|\n    string.include?(substring)\n  end\nend", "  \
    \  matches = []\n    strings.each do |string|\n        if substring == string\n\
    \            matches << string\n        end\n    end\n    matches\nend", "  strings.select\
    \ { |s| s.include? substring }\nend\n</code>\nYou can use the result like that:\n\
    <code>\nfilter_by_substring(array, 'bar') #=> ['bar', 'foobar', 'barfoo']\n</code>\n\
    <|/ a |>\n<| c |>\nVery nice solution, thank you for sharing!\n<|/ c |>\n<| a\
    \ dscore=1 |>\nYou don't need a loop. Just use select and include?\n<code>\narr\
    \ = [ 1, 2, 3, 4, 5 ]", "  strings_filtered = []\n  strings.each do |string|\n\
    \    if string.include?(substring)\n      strings_filtered << string\n    end\n\
    \  end\n  strings_filtered\nend", "  strings.select{ |string| string.include?\
    \ substring }\nend", "  strings.select do |string|\n    string.include? substring\n\
    \  end\nend\n</code>\n<|/ a dscore=3 tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\nIf you are looking for just a string match, try:\n<code>\nstring = \"foobar\"\
    \narr = [ \"foo\", \"bar\", \"foofoo\" ]\narr.select { |s| s == \"foo\" } # =>\
    \ [\"foo\", \"foofoo\"]\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\n<code>\n\
    arr.select{|s| s == \"foo\"}\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\nYou can achieve this in a variety of ways.\n<code>\narr.select { |s| s ==\
    \ \"foo\" }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nUse an Array Method\nIf you're\
    \ trying to find all strings in a specific array that contain \"foo\" you could\
    \ use one of the Array methods. \nFor example, arr.select { |s| s == \"foo\" }\
    \ will give you an array of all strings that contain \"foo\".\nYou can also specify\
    \ what kind of comparison (==, === etc) you want to make with your string. For\
    \ example: arr.select { |s| s == \"foo\" && \"foo\" == 'foo' } will return an\
    \ array of strings containing both \"foo\" and \"foo\".\nHere is a list of the\
    \ Array Methods available when working with Arrays:", "  strings.select { |s|\
    \ s.include?(substring) }\nend", "\tnew_strings = []\n\tstrings.each do |string|\n\
    \t\tstring = string.downcase\n\t\tif (string.include?(substring))\n\t\t\tnew_strings\
    \ << string\n\t\tend\n\tend\n\treturn new_strings\nend", "  strings.select { |s|\
    \ s.include?(substring) }\nend\n</cell>\n<cell>", "  strings.select do |string|\
    \ \n    string.index(substring)\n  end\nend\n</code>\nLet's try this one out:\n\
    <code>\nstrings = [\"foo\", \"bar\", \"baz\"]\nsubstring = \"ar\"\nfilter_by_substring(strings,\
    \ substring)", "    strings.select do |string|\n        string =~ Regexp.new(substring)\n\
    \    end\nend", "  new_strings = []\n  strings.each do |string|\n    if string.include?(substring)\n\
    \      new_strings << string\n    end\n  end\n  new_strings\nend\n</code>\n<|/\
    \ a tags=string,ruby dscore=4 |>\n<| a |>\nI didn't want to add another dependency\
    \ to my project, so I wrote a gem that does this:\nhttps://github.com/dmitry-zaitsev/string_in\n\
    The method looks like:\n<code>\nstring_in(\"string\", \"sub\") #=> true\n</code>\n\
    <|/ a dscore=4 tags=string,ruby |>\n<| c |>\nI cannot get your example to work.\
    \ Where is `string_in` defined?\n<|/ c |>\n<| c |>\nI added the module in my answer.\
    \ You probably just have to require it.\n<|/ c |>\n<| c |>\nI see, it seems like\
    \ the gem is doing something similar to your solution. Thank you\n<|/ c |>\n<|\
    \ c |>\nNo worries. Yes it's similar to your solution, I just found it a bit more\
    \ direct because you were using `.any?` instead of `.include?`.\n<|/ c |>\n<|\
    \ a tags=string,ruby dscore=4 |>\n<code>", "  string_regex = Regexp.new(Regexp.escape(substring))\n\
    \  strings.select { |string| string_regex.match(string) }\nend\n</code>\nThe function\
    \ can be used as follows:\n<code>\nstrings = [\"abcd\", \"efg\", \"cdefg\", \"\
    xyz\"]\nsubstring = \"ef\"\nfiltered_strings = filter_by_substring(strings, substring)",
  "  strings.select { |s| s.include? substring }\nend\n</code>\nNow we can use both\
    \ methods in a single line:\n<code>", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select { |s| s.include?(substring) }\nend", "\tfiltered_strings\
    \ = []", "  strings.select do |string|\n    string.include?(substring)\n  end\n\
    end", "    filter_by_substrings = lambda strings: filter(lambda a: a == substring,\
    \ strings)\n    filtered_strings = map(filter_by_substrings, strings)\n    return\
    \ list(filtered_strings)\nend", "    strings.select do |string|\n      string\
    \ =~ /\\A#{substring}\\Z/\n    end\nend", "  strings.select{|s| s.include? substring\
    \ }\nend", "    strings.select do |str|\n        str.include?(substring)\n   \
    \ end\nend", "    strings.select { |s| s.include?(substring) }\nend", "  return\
    \ strings.select{|s| s.include? substring }\nend", "  return strings.select {\
    \ |s| s.include?(substring) }\nend\n</code>\nNow you can do:\n<code>\nstrings\
    \ = ['hello', 'hello', 'goodbye', 'goodbye']\nsubstring = 'e'\nstrings = filter_by_substring(strings,\
    \ substring)\nstrings # => ['hello', 'hello', 'goodbye']\n</code>\nOr you can\
    \ make filter_by_substring more generic by passing in a regex instead of a substring\
    \ and you can pass any block that will be used to filter the strings.\n<|/ a dscore=5\
    \ |>\n<| a dscore=4 |>\n<code>", "  strings.select { |s| s.include? substring\
    \ }\nend", "\tstrings_with_substring = []", "  strings[strings.any? { |i| i.include?(substring)\
    \ }]\nend", "  substrings = strings_to_substrings(strings)\n  filtered_strings\
    \ = []\n  filtered_substrings = strings_to_substrings(substring)\n  filtered_substrings.each\
    \ do |substring|\n    strings.each do |string|\n      if substring == string\n\
    \        filtered_strings << string\n      end\n    end\n  end\n  filtered_strings\n\
    end", "  filtered_strings = []\n  \n  strings.each do |string|\n    if string.include?(substring)\n\
    \      filtered_strings << string\n    end\n  end\n  \n  return filtered_strings\n\
    end", "  strings.select do |s|\n    s.include?(substring)\n  end\nend", "  strings.select\
    \ do |s|\n    s =~ /#{substring}/\n  end\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select{ |str| str.include?(substring) }\nend", "\tmatches\
    \ = []\n\tstring.split(substring).each do |item|\n\t\tmatches << item if strings.include?(item)\n\
    \tend\n\tmatches\nend", "  filtered_strings = []\n  strings.each do |string|\n\
    \    string =~ substring ? filtered_strings << string : filtered_strings\n  end\n\
    \  filtered_strings\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby |>\n<| c |>\n\
    Wow, I had to put that in there myself... but didn't think of using Enumerable#grep\
    \ instead! That's a very nice solution!\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\nI like to do it this way, which doesn't require any external dependencies:\n\
    <code>", "  strings = strings.map {|s| s.gsub! substring, '' }\n  return strings\n\
    end", "  strings.select { |string| string.include?(substring) }\nend", "  filtered_strings\
    \ = []\n  strings.each do |string|\n    if string.include? substring\n      filtered_strings\
    \ << string\n    end\n  end\n  filtered_strings\nend", "  strings.select{ |str|\
    \ str.include?(substring) }\nend", "  strings.select { |s| s.include? substring\
    \ }\nend", "  strings.select{ |string| string.include?(substring) }\nend", " \
    \   strings.grep(/#{substring}/)\nend", "  strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select { |s| s.include?(substring) }\nend", "  filtered_strings\
    \ = []\n  strings.each do |string|\n    if string.include?(substring)\n      filtered_strings\
    \ << string\n    end\n  end\n  filtered_strings\nend\n</code>\nThe second function\
    \ is similar to the first, except it also filters by substring, using filter_by_substring2:\n\
    <code>", "\tfiltered_strings = []\n\t\n\tstrings.each do |string|\n\t\tif (string\
    \ =~ substring)\n\t\t\tfiltered_strings << string\n\t\tend\n\tend\n\t\n\treturn\
    \ filtered_strings\nend", "  strings.select { |s| s.include?(substring) }\nend",
  "  strings.grep(/#{substring}/)\nend", "    strings.select { |s| s.include?(substring)\
    \ }\nend", "  strings.select{|s| s.include?(substring)} \nend", "  filtered =\
    \ []\n  strings.each do |s|\n    if substring =~ s\n      filtered << s\n    end\n\
    \  end\n  filtered\nend", "  strings.select do |string| \n    string.include?(substring)\n\
    \  end\nend", "  return strings.select { |string| string.include? substring }\n\
    end", "  strings.select{|string| string.include?(substring) }\nend\n</code>\n\
    (note that the code above assumes that your strings are \"not nil\" and not an\
    \ empty string)\n<|/ a tags=ruby-on-rails,ruby-on-rails-3,ruby dscore=5 |>\n<|\
    \ c |>\nthanks for your answer. i tried both of them but still get the same error.\
    \ i have added the stack trace in the above question.\n<|/ c |>\n<| c |>\nI've\
    \ updated the answer: the `params` hash only contains non-nil values, not empty\
    \ strings.\n<|/ c |>\n<| c |>\nthanks again. i have tried this but still same\
    \ error. here is the updated stack trace http://pastebin.com/2yH3YkKi. i also\
    \ tried `puts params` and it is returning `#<ActionController::Parameters {\"\
    q\"=>\"apple\", \"controller\"=>\"fruits\", \"action\"=>\"index\"} permitted:\
    \ false>`\n<|/ c |>\n<| c |>\nSorry, I didn't check the stack trace closely. I\
    \ think you should rewrite your view code like this: instead of `puts params[:q]`,\
    \ use `puts q`, where `q` is the local variable you defined earlier. `params[:q]`\
    \ is actually a completely different hash containing only the parameter values\
    \ submitted in the request to this controller.\n<|/ c |>\n<| c |>\ni tried that\
    \ too but still no luck. i think i have missed something while updating my view\
    \ code which caused this issue. thanks for your help and sorry for wasting your\
    \ time.\n<|/ c |>\n<| a dscore=4 tags=ruby-on-rails,ruby-on-rails-3,ruby |>\n\
    Try this,\n<code>\n before_filter :set_q\n def index\n #your code\n end\n private\n\
    \ def set_q = params[:q]\n end\n</code>\n<|/ a |>\n<| c |>\nthanks for the answer\
    \ but i am still getting same error. i also tried `puts params[:q]` and it is\
    \ returning `#<ActionController::Parameters {\"q\"=>\"apple\", \"controller\"\
    =>\"fruits\", \"action\"=>\"index\"} permitted: false>`\n<|/ c |>\n<| c |>\ntry\
    \ this `before_filter :set_q, only: [:index]` instead of `before_filter :set_q`\n\
    <|/ c |>\n<| a tags=ruby-on-rails,ruby-on-rails-3,ruby dscore", "  strings.select\
    \ { |s| s =~ Regexp.new(Regexp.escape(substring), Regexp::IGNORECASE) }\nend\n\
    </code>\n<code>", "  strings.select do |string|\n    string.include?(substring)\n\
    \  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
