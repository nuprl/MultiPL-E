name: HumanEval_26_remove_duplicates
language: rb
prompt: "# From a list of integers, remove all elements that occur more than once.\n\
  # Keep order of elements left the same as in the input.\ndef remove_duplicates(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n\
  \    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1,\
  \ 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"
completions: ["  numbers.uniq\nend", "  # TODO: implement here\nend", "  numbers_with_counts\
    \ = numbers.group_by { |x| x }.map do |_, nums|\n    nums.sort.reverse\n  end",
  "  sorted = numbers.sort\n  result = sorted.dup\n  sorted.each do |n|\n    result.delete_if\
    \ { |e| e == n }\n  end\n  result\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks for your comment. I had not realized that there were several Ruby versions,\
    \ especially the one I am using.\n<|/ c |>\n<| c |>\nThis was exactly what I was\
    \ looking for. I just added a little more to it, but this was exactly what I needed.\
    \ Thanks!\n<|/ c |>\n<| a dscore=0 |>\nI recently ran into this problem (though\
    \ it seems less common), and came up with the following solution in Ruby. If anyone\
    \ has any comments, suggestions, improvements, etc. it would be very helpful:\n\
    <code>", "  numbers_with_duplicates = []\n  numbers.each do |number|\n    numbers_with_duplicates.push(number)\
    \ if numbers.count(number) > 1\n  end\n  numbers_with_duplicates\nend\n</code>\n\
    The result\n<code>\n[2, 4, 6, 1, 3]\n</code>\n<|/ a |>\n<| a tags=ruby |>\nHere\
    \ is a solution that uses Set, which is a data structure to hold a collection\
    \ of unique values. \n<code>", "  numbers.compact.uniq.sort!\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=0 tags=ruby,algorithm |>\nThe general idea is to generate\
    \ an array of all the possible combinations of the input numbers, and then remove\
    \ any that occur more than once:\n<code>", "  numbers.uniq\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThe `uniq` method does not preserve order. It returns an array\
    \ with duplicates in order in which they occurred.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nThe first answer was almost perfect for my needs, however it did not preserve\
    \ the order of numbers in my input array. Here is a modified version to preserve\
    \ the original order of numbers:\n<code>", "  numbers.reduce([]) { |list, number|\n\
    \    list << number if list.count(number) == 1 }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nAs others pointed out, the easiest way is to use Enumerable#uniq!:\n\
    <code>\nnumbers = Array.new(5){rand(100_000_000_000) + 1}\nnumbers.uniq!", " \
    \ new_numbers = []\n  numbers_count = numbers.inject(0) do |sum, number|\n   \
    \ if sum >= number\n      sum + number\n    else\n      sum\n    end\n  end\n\
    \  numbers.each_with_index do |number, i|\n    if numbers_count - number >= 1\n\
    \      new_numbers << number\n      numbers_count -= number\n    end\n  end\n\
    \  new_numbers\nend\n</code>\nThen we can use your two functions to get the result:\n\
    <code>\nremove_duplicates(numbers).map do |number|\n  number == numbers.first?\
    \ ? 0 : number\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis works great for\
    \ an array without duplicates, but what about an array with duplicates? For example,\
    \ `[1,1,2,3,4]`. After the operation, `[1,2,3,4]` should be returned.\n<|/ c |>\n\
    <| c |>\nIt would return an array with duplicates (if there were any): `[2, 3,\
    \ 4]`.\n<|/ c |>\n<| c |>\nYes, I did test it and it returned `[2, 3, 4]`. Thanks\
    \ for your help.\n<|/ c |>\n<| c |>\nI actually just realized that my solution\
    \ would return `[2,3,4]` if you supplied `[1,1,2,3,4]` instead of `[1,2,3,4]`.\
    \ I updated the answer to address that.\n<|/ c |>\n<| a |>\nThis is a one liner\
    \ :\n<code>\na.uniq.compact\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\n`a`\
    \ should be an array.\n<|/ c |>\n<| c |>\nThis will return an array.\n<|/ c |>\n\
    <| c |>\nI do not want an array with elements that have duplicates in them, I\
    \ want to get rid of the duplicates. I do not want to remove duplicates within\
    \ other elements.\n<|/ c |>\n<| c |>\nThis won't work for `a = [1, 1, 2, 3, 4]`\n\
    <|/ c |>\n<| a tags=ruby |>\nHere is a one-line solution:\n<code>\n[1, 2, 1, 2].uniq.map\
    \ {|i| i == 1 ? 0 : i }", "  numbers = numbers.uniq\n  numbers.each { |n| numbers.delete(n)\
    \ if numbers.count(n) > 1 }\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| c |>\n\
    If you need to support older Ruby versions, you may want to use `to_enum` instead\
    \ of `each`.\n<|/ c |>\n<| c |>\nAwesome solution. I was trying to get rid of\
    \ the duplicate hashes and this has saved me a lot of time. Thank you.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>", "  numbers = numbers.to_a\n  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| a |>\n<code>\narr = [1,2,3,4,1,2,1,3]",
  "  numbers.group_by { |x| x }.map { |k,v| v.size }.uniq.sort.each { |x| numbers.delete(x)\
    \ }\n  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI'm afraid it\
    \ doesn't work in case when there are repeating elements in the list. `a = [1,1,2,3,4,4,4,6,6,8,8,8,8,9]`\n\
    <|/ c |>\n<| c |>\nOh yeah, you're right. Fixed it.\n<|/ c |>\n<| c |>\nThe OP\
    \ doesn't even need to return anything, just remove duplicates.\n<|/ c |>\n<|\
    \ c |>\nOP wants to remove duplicates from an array.\n<|/ c |>\n<| c |>\nThat's\
    \ right. But the OP doesn't even need to return anything, just remove duplicates.\n\
    <|/ c |>\n<| a |>\n<code>\narr = ['a','b','a','c']", "  numbers_with_duplicates\
    \ = Set.new # a set will remove duplicates\n  numbers.each do |number|\n    if\
    \ numbers_with_duplicates.include? number\n      numbers.delete(number)\n    else\
    \ \n      numbers_with_duplicates.add(number)\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=3 |>\n<| c |>\nThis is the correct answer,\
    \ but doesn't exactly answer the OP's question of how to make an array of unique\
    \ elements. While this solution will remove duplicate elements, the OP said he\
    \ wanted a specific order.\n<|/ c |>\n<| a |>\n<code>", "    unique = []\n   \
    \ numbers.each { |i| unique.push(i.next) }\n    unique\nend\n</code>\nAnd here's\
    \ a way to get you started with using each to iterate through a list of integers\
    \ and do something to each integer:\n<code>", "    seen = {}\n    numbers.each\
    \ do |number|\n        if seen[number]\n            numbers.delete(number)\n \
    \       else\n            seen[number] = true\n        end\n    end\nend", " \
    \ numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer.\
    \ Yes, it's much better solution and this helped me. I'm still trying to understand\
    \ what you wrote. Do you mean \"numbers[numbers-1] += 1\" ? If yes, could you\
    \ please explain me what do you mean by \"numbers[numbers-1] += 1\" ? If not,\
    \ could you please give me some links to read more about \"numbers[numbers-1]\
    \ += 1\" ? Thank you!\n<|/ c |>\n<| c |>\nSure. `numbers[numbers-1] += 1` means\
    \ \"increment the element at `numbers-1` by one\". That is, it changes `numbers[numbers-1]`\
    \ into `numbers[numbers-1] + 1`. If `numbers-1` is the first element in the array,\
    \ it will be zero. If `numbers-1` is the second element in the array, it will\
    \ be one, and so on. If `numbers-1` is the last element in the array, it will\
    \ be `numbers.length - 1`.\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nI came across\
    \ this question when I was trying to figure out what the best way to sort an array\
    \ is. My understanding is that there are different ways to do it, but each one\
    \ has different advantages and disadvantages.\nMy code below is to sort an array\
    \ of strings in alphabetical order, while keeping duplicates (without removing\
    \ the duplicates).\n<code>", "    numbers.inject([]) do |result,number|\n    \
    \  result << number if numbers.count(number) == 1 \n      result\n    end\nend\n\
    </code>\nExample\n<code>\nnumbers = [3, 2, 5, 2, 3, 7, 9]\np remove_duplicates(numbers)",
  "  duplicates = []\n  numbers.each_with_index do |n, i|\n    if duplicates.include?(n)\
    \ == false\n      duplicates.push(n)\n    end\n  end\n  duplicates\nend", "  numbers.flatten!\n\
    \  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThe above\
    \ answers are great and efficient. Here is another way to do this using Array#flatten,\
    \ which was added with Rails 5.1, but it's very handy even if you have to support\
    \ older versions.\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=3 |>\n<| a dscore=2 tags=ruby,arrays |>\nNot sure I understand your question,\
    \ but if you're asking how to count the frequency of elements in a collection:\n\
    <code>\nmy_array = [1,2,2,2,3,2,2,2]\nmy_array.uniq.count\n=> 5\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,arrays |>\nUse a Hash:\n<code>\nh = {}\nmy_array.each {\
    \ |x| h[x] = h[x] + 1 }\n</code>\n<|/ a dscore=2 |>\n<| a |>\nYou might want to\
    \ use a hash for this, as you also want to keep the original order:\n<code>\n\
    h = {}\n[1,2,2,2,3,2,2,2].each do |x|\n  h[x] = h[x] || 0\n  h[x] += 1\nend\n\
    h.inspect", "  numbers.uniq.map { |number| numbers.count(number) }\nend\n</code>\n\
    <|/ a |>\n<| a |>\nIf you have a list of integers you can also use the built-in\
    \ select method to find all elements that occur more than once.\n<code>\narr =\
    \ [1,1,1,2,2,3,5]", "  seen = {}\n  numbers.select { |n| seen[n] ? false : seen[n]\
    \ = true }\nend\n</code>\nYou can see this in action in the following:\n<code>\n\
    [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\
    \ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, ", "  numbers.uniq.compact!\n\
    end\n</code>\n<|/ a tags=ruby,hashmap dscore=0 |>\n<| c |>\nI wouldn't call this\
    \ a \"hashmap\", but that's just me\n<|/ c |>\n<| c |>\nI guess it depends on\
    \ what you mean by \"hashmap\".  It certainly isn't what most people think of\
    \ when they see `HashMap`.  I did find it useful in case I want to keep track\
    \ of a key with multiple values, which has already been added to a HashMap, which\
    \ is why I thought it was called a HashMap.\n<|/ c |>\n<| a dscore=0 tags=ruby,hashmap\
    \ |>\n<code>\na = [1,2,3,3,4,5,6,6,6,6,7]\n</code>\nFirst get unique elements\
    \ in array then create a hash with unique elements as keys\n<code>\na.uniq.each_with_object(Hash.new(0))\
    \ { |element, h| h[element] += 1 }", "  numbers.group_by {|e| e}.map { |k, v|\
    \ [k, v.size] }.\n    reject {|_, v| v.size <= 1 }.to_h\nend\n</code>\nThis returns\
    \ the following hash:\n<code>\n{2 => 1, 3 => 2, 1 => 3}\n</code>\n<|/ a |>\n<|\
    \ c |>\nYour solution returns only unique values. What if I have duplicates like\
    \ `[1, 1, 2, 3, 3]`?\n<|/ c |>\n<| c |>\nIn that case, `{1 => 1, 2 => 2, 3 =>\
    \ 3}` would be the result.\n<|/ c |>\n<| c |>\nYes, but that is the only result\
    \ that is going to be returned. The OP wants to remove duplicates. That is why\
    \ he stated 'only unique values'.\n<|/ c |>\n<| c |>\nYou might want to rename\
    \ `remove_duplicates` to `remove_duplicate` ;)\n<|/ c |>\n<| c |>\n: Yes, I agree.\
    \ Updated answer based on your feedback.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\n\
    I believe this should work:\n<code>\na = [1, 1, 2, 3, 3]", "    numbers.sort!\n\
    \    new_numbers = []\n    new_numbers.concat numbers.uniq\n    new_numbers\n\
    end", "  new_numbers = []\n  numbers.each do |num|\n    new_numbers << num if\
    \ new_numbers.count(num) < 2\n  end\n  new_numbers\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=1 |>\n<| c |>\nYou don't need `uniq`, this can be done more efficiently\
    \ with a single `reduce`.\n<|/ c |>\n<| c |>\nOh, I didn't realise that `uniq`\
    \ was the most efficient way to do it. I have edited my answer accordingly.\n\
    <|/ c |>\n<| c |>\n`uniq` is indeed the most efficient way, but this doesn't answer\
    \ the OP's question, which is to remove duplicates from an array of random numbers,\
    \ not an array of integers.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays |>\nYou\
    \ don't need to create an array of unique numbers, you can just use a hash to\
    \ keep track of duplicates.\n<code>", "  result = []\n  seen = Set.new\n  numbers.each\
    \ do |number|\n    if seen.include?(number)\n      next\n    end\n    result <<\
    \ number\n    seen << number\n  end\n  result\nend", "  seen = {}\n  numbers.each\
    \ do |number|\n    if seen.has_key?(number)\n      seen[number]\n    else\n  \
    \    seen[number] = true\n    end\n  end\n  numbers.select { |number| seen.has_key?(number)\
    \ }\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "    numbers.uniq!\n    numbers.compact!\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 tags=ruby-on-rails-3,ruby-on-rails,ruby |>\n<code>", "  hash\
    \ = {}\n  numbers.each { |n| hash[n] = true }\n  new_numbers = []\n  numbers.each\
    \ { |n| new_numbers << n unless hash[n] }\n  new_numbers\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| c |>\nThe hash lookup could be replaced with `numbers.uniq.map\
    \ {|n| [n, numbers.include?(n) ? false : true] }`\n<|/ c |>\n<| c |>\nI like the\
    \ use of include? for its simplicity. Thanks for the solution.\n<|/ c |>\n<| c\
    \ |>\n: I agree that `include?` is the best solution in this case, but I thought\
    \ I'd illustrate a more general solution using hashes. I might write up an answer\
    \ using hashes to avoid the confusion about what happens when two different elements\
    \ are removed from the `numbers` array. Also, I think it's better to give OP some\
    \ more concrete examples about the performance characteristics of various solutions,\
    \ than to demonstrate them with a benchmark on the fly!\n<|/ c |>\n<| c |>\n:\
    \ You're right; I've updated the answer with your suggestion.\n<|/ c |>\n<| a\
    \ dscore=1 |>\n<code>\na = [1,2,3,4,5,5,4,3,2,1]\na.delete_if { |e| a.count(e)\
    \ > 1 }\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>\na = [1, 2, 3,\
    \ 1]\na.uniq!\na", "  new_numbers = []\n  seen = {}\n  numbers_with_duplicates\
    \ = numbers.map{|n| seen[n] ||= []; seen[n] << n}.compact\n  numbers_with_duplicates.each\
    \ do |number|\n    new_numbers << number\n  end\n  new_numbers\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThank you for this, but I am really struggling\
    \ to understand exactly what you are doing. This is a bit advanced for me, but\
    \ I appreciate the help. This is really helpful.\n<|/ c |>\n<| a dscore=1 |>\n\
    This was my first question and I really had a hard time reading other answers.\
    \ Thank you everyone! I finally got my solution and am posting it here for future\
    \ reference:\n<code>", "  seen = Set.new\n  result = []\n  numbers.each do |num|\n\
    \    if seen.include? num\n      result.push num\n      next\n    end\n    seen\
    \ << num\n  end\n  result\nend", "  numbers.uniq!\n  numbers\nend", "  counts\
    \ = Hash.new(0)\n  \n  numbers.each do |n|\n    counts[n] += 1\n  end\n  \n  new_numbers\
    \ = []\n  \n  counts.each do |number, count|\n    if count > 1\n      new_numbers\
    \ << number\n    end\n  end\n  \n  new_numbers.uniq\nend", "  # Your code here\n\
    \  numbers.uniq { |a| a }\nend\n</code>\nTest:\n<code>\narr = [1,3,2,4,1,5,7,5]\n\
    remove_duplicates(arr)\n  #=> [1, 2, 3, 4, 5]\n</code>\nIf you wish to preserve\
    \ the order of elements left in the input, you can use the form Array#uniq! that\
    \ will modify the original array:\n<code>\narr = [1,3,2,4,1,5,7,5]\narr.uniq!\n\
    \  #=> [3, 4, 5, 1, 2]\narr\n  #=> [3, 4, 5, 1, 2]\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a dscore=0 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10]", "  numbers_sorted\
    \ = numbers.sort\n  last_number = nil\n  numbers.each do |number|\n    if last_number\
    \ == number # skip duplicates\n      next\n    end\n    last_number = number\n\
    \  end\n  numbers.shift\n  numbers_sorted.shift\n  numbers_sorted << last_number\n\
    \  numbers_sorted\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a dscore=1 |>\n\
    My answer is based on this answer\n<code>", "  seen = Set.new\n  numbers.each\
    \ { |i| seen.add i if seen.include?(i) }\n  seen\nend", "  numbers.uniq!\n  numbers\n\
    end", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\n<code>\nnumbers = [1, 1, 2, 3, 5]", "  numbers.sort\n  result = []\n  number.each\
    \ do |number|\n    if (number - result).zero?\n      result << number\n    else\n\
    \      result.delete number\n    end\n  end\n  return result\nend\n</code>\n<|/\
    \ a tags=ruby,duplicates,algorithm |>\n<| a |>\nMy version\n<code>", "  result\
    \ = []\n  seen = Set.new\n  numbers.each do |num|\n    seen << num\n    result\
    \ << num if seen.size == 1\n  end\n  result\nend", "  return numbers.reject {\
    \ |number| numbers.count(number) > 1 }\nend\n</code>\n<|/ a tags=arrays,ruby,duplicates\
    \ |>\n<| a dscore=1 |>\n<code>", "  return numbers.uniq\nend", "    numbers.group_by\
    \ { |number| number }.select { |k, v| v.size > 1 }.map { |k, v| k }\nend", " \
    \   seen = Set.new\n    numbers.each { |i| seen.delete(i) }\n    seen\nend", " \
    \ numbers.group_by(&:itself).transform_values { |arr| arr.uniq.sort }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThe OP wants to get rid of the duplicates. The method you provide\
    \ does not do that unless I'm missing something?\n<|/ c |>\n<| c |>\n: You are\
    \ correct. I was confused at first; I've edited the answer to include a method\
    \ for doing exactly that.\n<|/ c |>\n<| a dscore=5 tags=ruby |>\nHere is an easy\
    \ way if you have multiple lists and want to remove duplicates from them in a\
    \ single pass\n<code>\n[list1, list2, list3].flatten.uniq\n</code>\n<|/ a |>\n\
    <| c |>\nHad the same problem and found this answer helpful.\n<|/ c |>\n<| c |>\n\
    This does not preserve the original order\n<|/ c |>\n<| a dscore=4 tags=ruby |>\n\
    The Ruby API has Array#uniq (which can be called on arrays containing arbitrary\
    \ objects), as well as a whole host of other methods Array#uniq, Array#uniq_by,\
    \ Array#uniq!, Array#uniq!, Array#unique, Array#uniq, Array#uniq! and Array#uniq!.\n\
    <|/ a |>\n<| a |>\nYou could also use a Hash to store your data like this:\n<code>\n\
    [1,2,2,3,4,4,5,6].inject({}){|m,x| m.merge(x => m.keys[x]) }\n</code>\nThis would\
    \ produce:\n<code>\n{1 => 1, 2 => 3, 3 => 5, 4 => 6}\n</code>\n<|/ a tags=ruby\
    \ dscore=4 |>\n<| c |>\nNot sure why that code wasn't accepted. It does exactly\
    \ what it says on the tin.\n<|/ c |>\n<| c |>\nI like that this approach is O(N)\
    \ where as the others are O(N^2) because they require O(N) time for each element\
    \ in the collection.\n<|/ c |>\n<| a dscore=4 |>\nYou can use this function below;\n\
    <code>", "  return numbers.uniq.reduce(:<<)\nend\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| c |>\nThe order of elements is unspecified in the question so this is\
    \ not a solution. Just a comment.\n<|/ c |>\n<| c |>\n: That's why I added '...keep\
    \ order of elements left the same as in the input'. If you don't like it just\
    \ downvote me.\n<|/ c |>\n<| c |>\n: This answer is fine, but I think it is a\
    \ bit too complex for the asker as a beginner. Also, there is no need to assign\
    \ the result of `uniq` to `numbers` because `uniq` returns a new array. Lastly,\
    \ it is more efficient to write `numbers.uniq.size`.\n<|/ c |>\n<| c |>\nFair\
    \ enough, but I do agree with you that `uniq` is a more readable option. Also,\
    \ I didn't know `uniq` returns a *new* array, so thank you!\n<|/ c |>\n<| c |>\n\
    , I don't understand why you think it is too complex. `reduce` is an [extremely\
    \ simple operation](http://ruby-doc.org/core-2.3.0/Enumerable.html#method-i-reduce).\
    \ As for efficiency, I see no reason why the OP would expect `uniq` to be more\
    \ efficient than `Array#size`.\n<|/ c |>\n<| a dscore=0 |>\nThis solution was\
    \ inspired by the previous one, but was able to return an array with duplicate\
    \ elements removed, preserving the order of the elements.  It uses Enumerable#partition\
    \ and Array#combination instead of Enumerable#uniq and Array#reduce.  It also\
    \ passes most of the test cases in the question as well.\n<code>", "    numbers.flatten!\n\
    \    seen = Set.new\n    numbers.delete_if { |n| seen.include? n }\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| a tags=ruby |>\nHere's a simple and efficient\
    \ solution:\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\nThe above is\
    \ Ruby\u2019s version of #uniq! method.", "  numbers.group_by{|x| x}.each{|k,\
    \ v| v.reject {|x| v.count(x) > 1}}\nend", "  sorted = numbers.sort\n  unique\
    \ = []\n  index = 0\n  while index < sorted.size\n    if sorted.include?(index)\
    \ && !unique.include?(index)\n      unique.push(sorted[index])\n      index +=\
    \ 1\n    end\n  end\n  unique\nend\n</code>\nI then used the function remove_duplicates\
    \ to remove duplicate values from a list of integers provided and returned the\
    \ list of unique values in sorted order as output.\n<code>", "  nums = numbers.dup.sort\n\
    \  result = []\n  while nums.length > 0\n    nums.reverse_each do |n|\n      if\
    \ nums.count > 1\n        result << n\n      else\n        nums.shift unless nums.include?(n)\n\
    \      end\n    end\n  end\n  return result\nend", "  sorted = numbers.sort\n\
    \  numbers.clear\n  numbers.concat sorted\nend\n</code>\n<|/ a dscore=4 |>\n<|\
    \ c |>\nThanks for this code snippet. However I'm wondering, how does it work\
    \ internally? I'm just curious how it works because I want to implement a similar\
    \ function for my own purposes.\n<|/ c |>\n<| c |>\nI believe the only thing that\
    \ does is sort an array of integers.  I suspect it uses quicksort.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\n def remove_duplicates(a)\n        a.sort\n        i\
    \ = 0\n        j = 1\n        while i < a.size\n            while i < a.size and\
    \ a[i] > a[i+1]\n                i += 1\n            end\n            j = j +\
    \ 1\n            while j < a.size and a[j] < a[j-1]\n                j += 1\n\
    \            end\n            a.delete_at(j)\n        end\n        a\n    end\n\
    </code>\n<|/ a tags=arrays,ruby |>\n<| a |>\n<code>", "  numbers.uniq!\n  numbers\n\
    end", "  return numbers.uniq\nend\n</code>\nIn short, here are the steps:\n<code>\n\
    ruby -e \"puts remove_duplicates([1,2,3,4,5])\"\n</code>\n<code>", "    seen =\
    \ []\n    numbers.delete_if do |number|\n        if seen.include? number\n   \
    \         false\n        else\n            seen << number\n            true\n\
    \        end\n    end\n    seen\nend", "  numbers = numbers.sort.uniq\n  numbers.each\
    \ do |number|\n    number.to_s.split(\".\").each do |digit|\n      if number.to_s.index(digit)\
    \ != numbers.index(digit)\n        numbers.delete(digit)\n      end\n    end\n\
    \  end\n  return numbers\nend\n</code>\n<|/ a |>\n<| a tags=ruby |>\nMy solution:\n\
    <code>", "  result = numbers.uniq\n  result.delete(\"\")\n  result\nend", "  return\
    \ numbers.reject {|n| numbers.count(n) == 1}\nend", "  numbers.uniq!\nend", " \
    \ numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    The \"remove all elements that occur more than once\" part was the part I was\
    \ looking for. Nice one!\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\na = [1,1,1,2,3,4,5,6,6,6,7]\n\
    b = a.uniq.sort\n</code>\n<|/ a dscore=3 |>\n<| c |>\nBut what happens if you\
    \ have a `b` array with duplicate elements, but they are not necessarily in order?\
    \ e.g. `b = [1,5,6,7,2,4,5]`? The desired result would be `b = [1,2,3,4,5]`.\n\
    <|/ c |>\n<| a |>\nTo remove all duplicates:\n<code>\narr = [1,1,1,2,3,4,5,6,6,6,7]\n\
    arr.uniq.sort\n</code>\nTo remove all duplicates but leave the first occurrence\
    \ if there are two:\n<code>\narr = [1,1,1,2,3,4,5,6,6,6,7]\narr.uniq.sort_by{|x|\
    \ [x,0].max}\n</code>\nTo keep only the first occurrence if there are two:\n<code>\n\
    arr = [1,1,1,2,3,4,5,6,6,6,7]\narr.uniq.sort_by{|x| [x,0].min}\n</code>\n<|/ a\
    \ dscore=2 tags=ruby,arrays |>\n<| c |>\nThe `sort_by` seems nice, but I would\
    \ use `sort_by!` instead. `sort_by!` returns the array unchanged, and modifies\
    \ the array in place.\n<|/ c |>\n<| c |>\nThe second one worked great for me.\
    \ The first two resulted in an error \"no implicit conversion of Symbol into Integer\"\
    .\n<|/ c |>\n<| a tags=ruby,arrays dscore=2 |>\n<code>\na = [1,1,1,2,3,4,5,6,6,6,7]\n\
    a.uniq.sort\n</code>\n<|/ a |>\n<| a dscore=1 tags=ruby,arrays |>\n<code>\na =\
    \ [1,1,1,2,3,4,5,6,6,6,7]\na.uniq.sort #=> [1, 1, 1, 2, 3, 4, 5, 6, 6, 6, 7]\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\na = [1,1,1,2,3,4,5,6,6,6,7]\na.sort_by { |x|\
    \ [x,0].max }\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nThis is a\
    \ great solution, because it also keeps the order of the elements in the original\
    \ array.\n<|/ c |>\n<| a tags=ruby,arrays ", "  dups = []\n  numbers.each_index\
    \ do |i|\n    next if dups.include?(i)\n    dups.push i\n    numbers.delete_at(i)\
    \ if numbers.count(i) == 1 \n  end\n  numbers\nend", "  counts = Hash.new(0)\n\
    \  numbers.each { |number| counts[number] += 1 }\n  numbers.reject! { |number|\
    \ counts[number] > 1 }\n  numbers\nend", "  numbers.uniq!\nend", "    numbers.uniq!\n\
    \    numbers\nend", "  sorted = numbers.sort.to_a\n  uniques = []\n  duplicated_elements\
    \ = 0\n  for i in 0...numbers.length\n    uniques << sorted[i]\n  until sorted\
    \ == uniques\n  uniques -= duplicated_elements\n  uniques\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=2 |>\nI wanted to avoid an explicit loop, but since Ruby 2.4\
    \ has deconstructed array comprehensions, I thought it might be good to provide\
    \ an answer using deconstruction instead of an explicit loop.  Here is a solution\
    \ similar to one of the answers, but more concise and more readable:\n<code>",
  "    numbers.uniq.tap do |uniques|\n        numbers.delete(uniques.min)\n    end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nIt would have been better to suggest a solution\
    \ using Set than a solution with uniq (which might not be the best solution if\
    \ it is supposed to keep order). The solution with uniq is definitely more efficient.\n\
    <|/ c |>\n<| c |>\nI actually did suggest a Set solution but changed it because\
    \ it wasn't a good one. I'll edit my answer now. Thanks for the suggestion.\n\
    <|/ c |>\n<| c |>\nI agree - Set is better than uniq.\n<|/ c |>\n<| a |>\nI believe\
    \ that \"numbers\" is the list of your numbers in ascending order. \nSo, just\
    \ do this:\n<code>\nnumbers.delete_if {|number| numbers.count(number) == 1}\n\
    </code>\nYou would get a new list that has all the numbers that don't occur more\
    \ than once.\n<|/ a tags=ruby,ruby-on-rails dscore=2 |>\n<| c |>\n`count` is O(n)\
    \ complexity, your solution would have to call `count` a number of times equal\
    \ to the number of items in the list to be deleted, which would result in quadratic\
    \ runtime.\n<|/ c |>\n<| c |>\n, It doesn't necessarily have to be `O(n)`. Though,\
    \ you're correct, count would have to call `count` `n` times and this would be\
    \ `O(n^2)`.\n<|/ c |>\n<| a |>\nIt is not very elegant, but you can use a while\
    \ loop and an index to keep a record of which numbers you have seen before:\n\
    <code>", "  seen = {}\n  unique = []\n  numbers.each do |n|\n    if seen[n] ==\
    \ nil\n      unique << n\n      seen[n] = true\n    end\n  end\n  unique\nend\n\
    </code>\n<|/ a dscore=3 tags=arrays,ruby |>\n<| c |>\nI haven't used ruby a lot\
    \ but I think this should be the accepted answer.\n<|/ c |>\n<| c |>\nI like this\
    \ solution as it uses the fact that ruby is associative (which is great for speed\
    \ and memory efficiency) rather than iterating through every element of the array\
    \ and checking to see if it already exists in an additional array\n<|/ c |>\n\
    <| a dscore=3 |>\nIf you're using Rails (which I am) you can use the uniq method.\
    \ e.g.\n<code>\n>> [1,2,2,3,4].uniq\n=> [1, 2, 3, 4]\n</code>\n<|/ a tags=arrays,ruby\
    \ |>\n<| c |>\nThis is the best answer (if you're using Rails) because it doesn't\
    \ require a loop.\n<|/ c |>\n<| a |>\nHow about:\n<code>\na = array\na.select\
    \ {|x| a.count(x) == 1}\n</code>\n<|/ a tags=arrays,ruby dscore=2 |>\n<| c |>\n\
    I think this should be the accepted answer.\n<|/ c |>\n<| c |>\nThis solution\
    \ isn't going to work if the array has duplicate values. For example, [1, 2, 3,\
    \ 3, 3, 4] will return all four values.\n<|/ c |>\n<| c |>\nHmmm, true.  I'd have\
    \ to do two passes or use a hash to ensure there are no duplicates first.\n<|/\
    \ c |>\n<| a |>\nHere's a solution that doesn't require sorting. It just uses\
    \ a hash to hold seen values and checks for the existence of the key in the hash\
    \ before adding it to the new array.\n<code>", "  # Create a new array and add\
    \ our numbers.\n  new_numbers = []\n  \n  # Loop through each of the numbers in\
    \ the old array.\n  numbers.each do |number|\n    # If the number was not in the\
    \ new array, add it.\n    new_numbers << number unless new_numbers.include?(number)\n\
    \  end\n  \n  # Return the new array.\n  new_numbers\nend\n</pre>\n</div>\n</div>",
  "  numbers.uniq.sort!\n  return numbers\nend\n</code>\nAnd if you're not into using\
    \ functional programming, you can use this simple Ruby solution:\n<code>\nnumbers\
    \ = [1,2,3,4,3,2,1]\nnumbers.group_by { |n| n }.map{ |k,v| v.reject { |i| i ==\
    \ k.last }.uniq }.compact\n</code>\nThis will return an Array, which will contain\
    \ only unique elements, that have the same value as the last element in the original\
    \ Array.\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=1 |>\nAnother option is\
    \ the following:\n<code>", "  numbers.uniq\nend", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    \  return numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nYou don't\
    \ need `uniq`, just `numbers = numbers.uniq`. Then `numbers` will contain the\
    \ unique values.\n<|/ c |>\n<| c |>\n`uniq` returns a new array. No, `uniq!` modifies\
    \ the array in place. Read more on `Array` methods at http://www.ruby-doc.org/core-1.9.3/Array.html\n\
    <|/ c |>\n<| c |>\nI meant `uniq!`. Yes, `uniq` returns a new array, but that\
    \ array contains the unique values in it, and `uniq!` modifies the original array.\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=2 |>\nI find this one quite readable in\
    \ ruby:\n<code>\na = [1,3,4,4,4,5,7,9,9,9,10,11,11,12]\nputs a.uniq.sort\n</code>\n\
    <|/ a |>\n<| a |>\n<code>", "  new_numbers = []\n  duplicates = false\n  numbers\
    \ = [1, 2] + numbers\n  numbers.each do |num|\n    duplicates = true if num !=\
    \ new_numbers.last\n    new_numbers << num if duplicates\n  end\n  new_numbers\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,arrays,duplicates |>\n<| a |>\n<code>",
  "  numbers.uniq!\nend\n</code>\nYou can test it like:\n<code>\n[2,1,2,3,4,5,6,7,8,2,1,3,4,5,6,7].each\
    \ { |num| puts \"#{num}: #{remove_duplicates([num])}\" }\n</code>\nOutput:\n<code>\n\
    2: [2]\n1: [1]\n3: [3]\n4: [4]\n5: [5]\n6: [6]\n7: [7, 8]\n8: [8]\n</code>\n<|/\
    \ a tags=arrays,ruby |>\n<| a |>\nYou can use Enumerable#group_by to group your\
    \ arrays by their values and then Array#map to map each group to a flattened array\
    \ of values:\n<code>\narray.group_by { |v| v }.map { |k, v| v.flatten }\n</code>\n\
    Example:\n<code>\narray = [2,1,2,3,4,5,6,7,8,2,1,3,4,5,6,7]\narray.group_by {\
    \ |v| v }.map { |k, v| v.flatten }", "  numbers.delete_if { |x| numbers.count(x)\
    \ > 1 }\nend", "  numbers.select { |i| (numbers & [numbers[i]]).size == 1 }\n\
    end\n</code>\n<|/ a tags=ruby,arrays,unique |>\n<| c |>\n+1 I love this solution.\
    \  I came up with an almost identical one, although I would use `each_with_object`\
    \ instead of `inject` so that it wouldn't mutate the original array or create\
    \ a new array.  And I'd use `numbers[i]` instead of `[i]` to avoid having to use\
    \ the `select` method.\n<|/ c |>\n<| c |>\nI like this one. I came up with a similar\
    \ solution myself and just thought this would be a nice one. I just wanted to\
    \ point out that this solution isn't the fastest, though it does look nice.\n\
    <|/ c |>\n<| c |>\nThanks man, I really like this one!  I added the benchmark\
    \ results to my benchmark tests and its super fast!  Thanks for posting so many\
    \ benchmarks!\n<|/ c |>\n<| c |>\nThe benchmark results were great!  Thanks! \
    \ I'm still learning ruby so this is super helpful!\n<|/ c |>\n<| c |>\nThis solution\
    \ is pretty fast.  In fact, it is the fastest for me on large lists, on average.\
    \  I have benchmarks I used to test the other solutions.  This solution is much\
    \ faster for short lists and doesn't use any additional libraries.\n<|/ c |>\n\
    <| a dscore=5 tags=ruby,arrays,unique |>\nI like the solution from Chris Heald,\
    \ but I want to post my own version of it. I think the algorithm is cleaner, and\
    \ more understandable, but I believe it may have some performance implications.\n\
    <code>", "  numbers_hash = numbers.inject({}){|h, v| h[v] = h.size; h}\n  numbers.reject!\
    \ {|n| numbers_hash[n] == 1}\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI didn't\
    \ downvote you, but I suspect the reasoning behind your downvote is that this\
    \ solution is O(N^2) complexity (where N is the input size) which isn't great.\n\
    <|/ c |>\n<| c |>\nThat's a good point.  It makes this solution unsuitable for\
    \ a large number of numbers (say a million or so for that matter).  My apologies\
    \ for the downvote.\n<|/ c |>\n<| c |>\nI agree with you, and my apologies for\
    \ the downvote.  However, your solution may be more efficient than the one I gave,\
    \ depending on how `Array#each_index` works and how large a `numbers` list is.\
    \  My point was that efficiency shouldn't be an issue for this problem.\n<|/ c\
    \ |>\n<| c |>\nI agree, your answer is more efficient.\n<|/ c |>\n<| c |>\nI actually\
    \ like the idea of using the `count` method on the array and then just rejecting\
    \ duplicates in one step. However, the downside is that it doesn't handle duplicates\
    \ that are part of an interspersed array.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  numbers = numbers.uniq\n  numbers.each { |num| numbers.delete(num) }\n  numbers\n\
    end\n</code>\nThis also gives you a nice way to remove the zero and non-zero elements\
    \ separately:\n<code>", "    numbers.group_by{|n| n}.each{|n,v| numbers.delete_if{|n|\
    \ n == n}; numbers.delete_if{|n| n == v.last}; numbers.delete_if{|n| n == v.first}}\n\
    end\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nI like that, but I\
    \ think the second and third lines can be combined into a single one, as the OP\
    \ wanted to preserve the original order of the elements.\n<|/ c |>\n<| c |>\n\
    Actually, your solution preserves the original order of the elements, but also\
    \ the order in which they are encountered in the input list.  It does not preserve\
    \ the order in the original input.  Also, it produces a hash of the elements and\
    \ then removes all the elements whose values are equal to the key's last value.\
    \ Is that what you intended?\n<|/ c |>\n<| c |>\nYes, I wanted the order in the\
    \ original input preserved. I wasn't sure how to keep the original order of elements.\
    \ The key value pairs were the elements that I needed eliminated from the original\
    \ array and I wasn't sure how to remove the elements from the original array while\
    \ preserving the original order.\n<|/ c |>\n<| c |>\nI edited my answer with a\
    \ possible solution, although it's not quite as efficient as it could be.\n<|/\
    \ c |>\n<| c |>\nI haven't seen your edit. My solution does preserve the order\
    \ of the elements.\n<|/ c |>\n<| a tags=ruby,arrays |>\nI wrote a method that\
    \ preserves the order of elements and removes repeated values. It could be used\
    \ on any array, not just sorted ones:\n<code>", "  numbers.select do |number|\n\
    \    numbers.count(number) == 1 && numbers.include?(number)\n  end\nend\n</code>\n\
    And here's a more Ruby-esque way of doing it that uses Hash#merge to remove any\
    \ elements that occur more than once:\n<code>", "    numbers.each_with_object({})\
    \ do |number, hash|\n      hash[number] ||= []\n      hash[number] << number\n\
    \    end.map { |number, values| values.first }\nend", "    numbers = numbers.sort\n\
    \    seen = []\n    i = 0\n    while i < numbers.length\n        if seen[numbers[i]]\
    \ == nil\n            seen[numbers[i]] = true\n            i += 1\n        else\n\
    \            numbers.delete_at(i)\n        end\n    end\n    return numbers\n\
    end", "  numbers.uniq!\nend", "  numbers_count = numbers.inject(Hash.new(0)) {\
    \ |h,x| h[x] += 1 }\n  numbers.select { |x| numbers_count[x] == 1 }\nend", " \
    \ seen = []\n  numbers.uniq.each do |i|\n    next if seen.include?(i)\n    seen\
    \ << i\n  end\n  return seen\nend", "  numbers.uniq.sort.uniq\nend\n</code>\n\
    You will want to add the following to your application controller if you want\
    \ to use Rails 3:\n<code>", "    numbers.uniq.map { |n| numbers.count(n) > 1 ?\
    \ n : nil }.compact\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer. Can\
    \ you explain what is going on in the map? I understand that it will turn an array\
    \ of numbers into an array of numbers of duplicates. But I am not able to follow\
    \ the logic behind it.\n<|/ c |>\n<| c |>\nI added a couple more explanations!\n\
    <|/ c |>\n<| c |>\nThanks for the explanation. I understand that we are comparing\
    \ each element with the rest of the array and removing any elements that have\
    \ a duplicate. But how do we know what the duplicate is? How does it know what\
    \ to compare? Also, how does it know not to return the nil when there is no duplicate?\n\
    <|/ c |>\n<| c |>\n`count` returns the number of times that something occurs in\
    \ an array. `uniq` removes all the duplicates, leaving the non-duplicates.\n<|/\
    \ c |>\n<| c |>\n`uniq` removes all the duplicates, leaving only one of each of\
    \ the duplicates.\n<|/ c |>\n<| a |>\nI figured out a really simple way to solve\
    \ this. It involves using the .uniq method on the array. This will remove any\
    \ duplicates and leave the unique items. \nThe method looks like this:\n<code>",
  "  numbers_sorted = numbers.sort\n  numbers.delete_if { |x| numbers.count(x) > 1\
    \ }\n  numbers_sorted\nend\n</code>\nNow we can do this:\n<code>\nremove_duplicates([1,3,4,5,5,8,9,11,12,11])",
  "  numbers.uniq\nend", "  numbers.delete_if { |x| numbers.count(x) > 1 }\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "    numbers.uniq.sort!\n    i\
    \ = 0\n    while i < numbers.size\n        if numbers[i] == numbers[i+1]\n   \
    \         numbers.delete_at(numbers.index(i))\n        else\n            i +=\
    \ 1\n        end\n    end\n    numbers\nend", "    numbers.uniq.map { |number|\
    \ numbers.count(number) == 1 ? number : nil }\nend\n</code>\nThe remove_duplicates([1,\
    \ 1, 1, 2, 2, 3]) will return [1, 1, 2, 3].\n<|/ a |>\n<| c |>\nI agree, but I\
    \ think this is overkill. I think the OP wanted to know how to use the .uniq method\
    \ and map and count :)\n<|/ c |>\n<| c |>\nI don't think it's overkill. Sometimes\
    \ one doesn't have to reinvent the wheel but simply use what's already been invented.\n\
    <|/ c |>\n<| a dscore=0 tags=ruby,count,arrays,unique |>\nIf you don't need to\
    \ use an array but to have a string, this would work just fine:\n<code>\nputs\
    \ \"Enter the numbers you want to delete, one by one:\"\na = gets.chomp.split(//)\n\
    a.delete_if {|x| a.count(x) == 1}\n</code>\n<|/ a |>\n<| a tags=ruby,count,arrays,unique\
    \ |>\nAnother way of doing it is to use inject\n<code>\nary = [1, 2, 2, 3, 3,\
    \ 3, 4, 4, 5, 6]\nary.inject({}){|h,x| h[x] = ary.count(x)>1 ? ary.count(x) :\
    \ 1 }.keys\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  numbers.uniq.compact.flatten!\n\
    end", "  numbers_to_remove = Set.new\n  numbers.each do |number|\n    if !numbers_to_remove.include?(number)\n\
    \      numbers_to_remove << number\n    end\n  end\n  numbers_to_remove.clear\n\
    end", "  return numbers.uniq.sort_by { |num| -numbers.count(num) }\nend\n</code>\n\
    <|/ a tags=ruby,arrays,unique,algorithm dscore=2 |>\n<| c |>\nThis is O(N^2),\
    \ which isn't necessarily better than O(N)\n<|/ c |>\n<| a |>\nIf you're using\
    \ Rails you can use activesupport to make a uniq_by method on Arrays:\n<code>\n\
    array = [1,1,2,3,4,5,7,8,9,10]\narray.uniq_by{|x| x}", "  numbers.uniq!\n  numbers\n\
    end", "  result = []\n  numbers.each do |x|\n    result << x unless result.include?(x)\n\
    \  end\n  result\nend", "  result = []\n  numbers.each do |number|\n    if (result.include?\
    \ number) == false \n      result << number\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\n<code>\na = [1, 2, 3, 2, 3, 4, 4,\
    \ 5, 5, 6, 7, 7, 8, 8, 9]", "  numbers.delete_if do |n|\n    numbers.count(n)\
    \ > 1\n  end\nend", "    seen = []\n    to_remove = []\n    res = []\n    numbers.each\
    \ do |n|\n        if seen.include? n\n            to_remove << n\n        else\n\
    \            seen << n\n            res << n\n        end\n    end\n    to_remove.each\
    \ do |n|\n        numbers.delete_at(res.index(n))\n    end\n    return res\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis has quadratic performance in large lists.\
    \ I imagine this would fail on even larger lists and is extremely slow. On an\
    \ initial pass through the list, and each time you find a duplicate, you have\
    \ to search the rest of the list for each item in the list before you get to next\
    \ item in the list. This means that for every duplicate you find, you have to\
    \ search the rest of the list to see if it is a duplicate and if so, remove it.\
    \ As you add more items to the list, this will increase the time it takes to find\
    \ a duplicate. Also, this isn't a good solution to remove duplicates in a list.\
    \ Instead of removing duplicates, you should create a second list with duplicates\
    \ and return that.\n<|/ c |>\n<| c |>\nThe OP has mentioned in the comments that\
    \ they do not want to use Array#uniq since they do not want to modify the original\
    \ list. Also, in the comments below the question, they say that their code worked\
    \ as intended and that they want to remove duplicates from a list of integers\
    \ while retaining order.\n<|/ c |>\n<| c |>\nI agree with you, however, as you\
    \ add items to the original list you are adding more work to the algorithm and\
    \ this should slow things down. I would agree with you if there were a better\
    \ solution.\n<|/ c |>\n<| c |>\nI agree with this statement. However, the OP has\
    \ clarified that they want to return a new list with the duplicates removed, which\
    \ is exactly what the solution I proposed does. The downside is that you are creating\
    \ a new list with duplicates, which might take more memory than you need to store\
    \ the entire list in the first place. You are also using linear search to find\
    \ the indices of the duplicates, which should take linear time. The point is that\
    \ linear search is quadratic in time complexity and can cause performance issues\
    \ very quickly. Also, you need to store all duplicates in memory, which can cause\
    \ memory issues very quickly.\n<|/ c |>\n<| c |>\nI see what you are saying. But\
    \ in my solution, the entire array is copied into memory in order to remove duplicates\
    \ which is exactly what Array#uniq does.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n\
    I did this in Python", "  numbers.uniq\nend", "  numbers.uniq\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby |>\n<| c |>\nI like your solution, but the question\
    \ is \"how can this be done without using `Enumerable`?\"\n<|/ c |>\n<| c |>\n\
    : I actually like it better than mine. I'm going to edit mine out though.\n<|/\
    \ c |>\n<| c |>\nYeah. I'd say that yours is better if you don't have access to\
    \ the Enumerable#uniq method.\n<|/ c |>\n<| a dscore=2 |>\nThe most performant\
    \ solution I know of for this kind of thing is to convert the list to a hash and\
    \ then convert the hash back to an array at the end. Ruby 2.3 has Hash#values_at\
    \ which does exactly that.\n<code>", "  numbers_with_counts = numbers.map { |x|\
    \ [x, numbers.count(x)] }\n  numbers_with_counts.flatten.reject { |_, count| count\
    \ > 1 }\nend\n</code>\nExample:\n<code>\nnumbers = [1,2,3,3,4,5,6,6,6,6,7,8,9,9,9,9,9,9,10,11,12,12,12,12,12,12,12,12,12,12,12]\n\
    remove_duplicates(numbers)\n  #=> [1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 12, 12, 12] \n</code>\n<|/ a tags=ruby,arrays,duplicate-removal,ruby-on-rails\
    \ dscore=0 |>\n<| a dscore=0 |>\nUse a hash that counts the number of occurrences\
    \ of each element and only keep those that have a count of 1 or less.\n<code>\n\
    numbers = [1,2,3,3,4,5,6,6,6,6,7,8,9,9,9,9,9,9,9,10,11,12,12,12,12,12,12,12,12,12,12]\n\
    hash = {}\nnumbers.each do |number|\n  hash[number] = hash[number].nil? ? 1 :\
    \ hash[number] + 1\nend\nresult = hash.select {|number, count| count == 1}\np\
    \ result # => [1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 12]\n\
    </code>\n<|/ a tags=ruby,arrays,duplicate-removal,ruby-on-rails |>\n<| c |>\n\
    This will remove all but the last duplicate `6` - it needs to remove *all* duplicates.\n\
    <|/ c |>\n<| c |>\nThis works great, except it also removes the first duplicate.\
    \  If you run it against [1,2,3,4,3,4,5,6,6,6,6,6,7,8,9,9,9,9,9,9,9,10,11,12,12,12,12,12,12,12,12,12,12]\
    \ you'll see what I mean.\n<|/ c |>\n<| a tags=ruby,arrays,duplicate-removal,ruby-on-rails\
    \ |>\nA simple way to avoid the creation of additional objects is to keep track\
    \ of the last seen number - if it is different from the current one, skip the\
    \ current number in the new list. \n<code>\nnumbers = [1,2,3,3,4,5,6,6,6,6,7,8,9,9,9,9,9,9,9,10,11,12,12,12,12,12,12,12,12,12,12,12]",
  "    numbers.inject([]) do |output,el|\n        if output.include? el\n        \
    \    output << el\n        else\n            output << el\n        end\n    end\n\
    end", "    seen = {}\n    numbers.each { |n| seen[n] = true }\n    numbers.select\
    \ { |n| seen[n] }.uniq.compact\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nYou\
    \ could also use `Hash.new(0)` to get a default value of 0 instead of `nil`\n\
    <|/ c |>\n<| c |>\nThis answer is great because it shows how it works. But I think\
    \ you should not call it \"Ruby way\". Ruby idioms use more idiomatic Ruby constructs\
    \ such as Enumerable#group_by, and they work fine on Ruby 1.9 or higher without\
    \ needing methods like group_by. Just use `Hash.new(0)` as a default value.\n\
    <|/ c |>\n<| c |>\nI agree, but I decided that the point of this answer is to\
    \ show how it works, not because it's the right or wrong Ruby way. I was just\
    \ pointing out that Hash.new(nil) is better than Hash.new(0).\n<|/ c |>\n<| c\
    \ |>\nI like the use of select and compact to remove dupes. I love the use of\
    \ Enumerable#group_by. I learned something today!\n<|/ c |>\n<| c |>\nI like your\
    \ use of map and uniq.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails-3 dscore=3 |>\n\
    This one worked for me:\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,arrays |>\n<code>\nx = [1,2,2,3,3,4]", "  \n  numbers.uniq.sort\n\
    \  \n  return numbers\nend", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\n\
    end", "  # +++your code here+++\n  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis isn't a great solution, because it modifies the array rather\
    \ than returning a new array.\n<|/ c |>\n<| c |>\nOh, and this solution modifies\
    \ the input, which isn't mentioned in the requirements.\n<|/ c |>\n<| c |>\nThis\
    \ solution modifies the input too, and this isn't mentioned in the requirements.\n\
    <|/ c |>\n<| c |>\nIt does return a new array. The example in the question doesn't\
    \ suggest modifying the input, so why suggest it?\n<|/ c |>\n<| c |>\nIt's a modification\
    \ of the input, but I agree. Just mentioning that this solution is modifiying\
    \ input is not an acceptable requirement in the question.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nThis is a solution using #inject:\n<code>", "  seen = {}\n  result = []\n\
    \  numbers.each do |number|\n    if seen[number]\n      seen[number] += 1\n  \
    \  else\n      seen[number] = 1\n      result << number\n    end\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2\
    \ |>\n<| c |>\nIt's unnecessary to include `Array#uniq` if the `Array` `numbers`\
    \ has already been passed to `Hash#values`.\n<|/ c |>\n<| c |>\nThe OP was asking\
    \ for a `Hash` solution. That's why I chose to provide a `Hash` solution. I agree\
    \ that `Array#uniq` can still be useful, just not for this example. Thank you\
    \ for pointing that out.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2\
    \ |>\nIf you've got a Hash, you can use values as an enumerator:\n<code>", " \
    \ new_list = []\n  numbers.each do |i|\n    if new_list.count <= i\n      new_list\
    \ << i\n    end\n  end\n  return new_list\nend\n</code>\nThis method is more concise\
    \ and efficient. \nThe method itself is relatively straightforward and uses no\
    \ external libraries.\n<|/ a tags=ruby dscore=0 |>\n<| a dscore=0 tags=ruby |>\n\
    <code>", "    seen = {}\n    numbers_without_duplicates = []\n    numbers.each\
    \ do |num|\n        unless seen[num] \n            numbers_without_duplicates.push(num)\n\
    \            seen[num] = true\n        end\n    end\n    numbers_without_duplicates\n\
    end\n</code>\nThe first function remove_duplicates takes a list of integers and\
    \ removes all the elements without duplication. This is achieved by using a hash.\
    \ The elements of the hash are set to true if the element has ever been seen,\
    \ otherwise it is set to false. When we iterate through the list of numbers we\
    \ check if the element has been seen and if so we know it hasn't been seen before.\
    \ \nThe second function takes the input numbers and filters out the unique elements.\
    \ The uniqueness is achieved by using the seen hash which holds the elements with\
    \ their seen values, and by using the each method to iterate through the numbers\
    \ and check if a number has been seen. \nThe final function takes the input numbers\
    \ and returns the list numbers without duplication. \n<code>\nnumbers = [1,2,3,4,4,4,5,6,7,8,9,10]\n\
    numbers_without_duplicates = remove_duplicates(numbers)\np numbers_without_duplicates",
  "  numbers.uniq.compact!\nend", "  numbers.compact.uniq.sort\nend", "    numbers.uniq!\n\
    end\n</code>\nNow the final method looks like this:\n<code>", "    seen = {}\n\
    \    duplicates = []", "  numbers.uniq!\nend", "  seen = Set.new\n  numbers.map\
    \ {|n| seen << n unless seen.include?(n)}\nend", "  numbers.uniq.sort!\n  numbers.delete_if\
    \ { |n| numbers.count(n) > 1 }\nend\n</code>\nThis will return an array:\n<code>\n\
    [\"2\", \"3\", \"5\", \"8\", \"10\", \"20\", \"30\"]\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis is a very elegant solution to the problem, and so I thought\
    \ I'd add another option for accomplishing the same thing. It may be more efficient\
    \ to run through numbers once and save a hash of each number as the count is incremented\
    \ on each pass (and then remove the key if the count is greater than one). This\
    \ would take more space than the solution above, however.\n<|/ c |>\n<| c |>\n\
    Very cool! I hadn't thought of doing this. I wonder if the difference in performance\
    \ would be substantial.\n<|/ c |>\n<| c |>\nI've tested it, and your solution\
    \ is almost twice as fast as mine. On a 100 item array, the solution that worked\
    \ (with 3 loops) took 0.408761 seconds, and my solution took 0.313879 seconds.\
    \ So thank you very much for the response!\n<|/ c |>\n<| c |>\nI ran the test\
    \ again with more elements (1000 instead of 100) and my solution took 0.011507\
    \ seconds, while the solution by Tom (with 2 loops) took 0.043097 seconds. So\
    \ it seems that my solution is still the fastest.\n<|/ c |>\n<| c |>\nThat's interesting.\
    \ I'm glad you found something that worked well for you!\n<|/ c |>\n<| a tags=ruby\
    \ dscore=0 |>\nHere's a solution that removes duplicates while preserving the\
    \ order of the elements:\n<code>", "    sorted = numbers.sort\n    seen = {}\n\
    \    answer = []\n    i = 0\n    while i < sorted.length\n        if seen[sorted[i]]\n\
    \            # Skip this element\n            i += 1\n        else\n         \
    \   answer.push(sorted[i])\n            seen[sorted[i]] = true\n            i\
    \ += 1\n    end\n    return answer\nend", "  numbers.group_by { |n| n }.values.flatten.compact\n\
    end", "  new_numbers = []\n  new_numbers_hash = {}", "  result = Set.new\n  numbers.each\
    \ do |number|\n    result << number if !result.include?(number)\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby-on-rails-3,ruby,arrays,ruby-on-rails,ruby-on-rails-3.1\
    \ |>\n<| a dscore=4 tags=ruby-on-rails-3,ruby,arrays,ruby-on-rails,ruby-on-rails-3.1\
    \ |>\nHere's a one-liner that gets you close:\n<code>\na = [1,2,3,4,5,3,4]\na.uniq(&:itself)",
  "  numbers.uniq!\nend", "  seen = {}\n  new_numbers = []\n  numbers.each do |number|\n\
    \    if seen[number] == nil\n      new_numbers << number\n      seen[number] =\
    \ 1\n    end\n  end\n  new_numbers\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Why not just use `count`? That would avoid having to convert the list into an\
    \ integer array (which is not necessary but a good idea anyway).\n<|/ c |>\n<|\
    \ c |>\nI assumed he wanted to avoid using `count`.  That said, I should clarify\
    \ that `count` would not solve the problem with duplicate numbers.  It would remove\
    \ the duplicates in each array, and then the second array would have duplicate\
    \ elements.  So the order would not be preserved.\n<|/ c |>\n<| c |>\nThanks for\
    \ the solution and explanation. I am going to implement it in my code now.\n<|/\
    \ c |>\n<| c |>\nI did a little bit of reading into hashes and I think this was\
    \ one of the reasons I was getting confused as to why my program was only working\
    \ for the first array. After doing some more research, I was able to adapt the\
    \ solution to my program. Thanks again for the solution.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby |>\n<code>\nnumbers = [\n  [1, 1],\n  [2, 2],\n  [3, 3],\n  [4, 4],\n\
    \  [5, 5],\n  [6, 6],\n  [7, 7],\n  [8, 8],\n  [9, 9],\n  [10, 10],\n  [11, 11],\n\
    \  [12, 12]\n]\n</code>\nFirst, let's see what your code does in each step:\n\
    <code>", "  return numbers.uniq\nend", "    i = 0\n    while i < numbers.length\n\
    \        while i < numbers.length && numbers[i] == numbers[i + 1]\n          \
    \  i += 1\n        end\n        numbers.delete_at(i + 1)\n    end\n    numbers\n\
    end", "  # Write your code here.\n  result = []\n  numbers.each { |n| result <<\
    \ n }\n  result = result.uniq!\n  result.uniq!\n  result.uniq!\n  result\nend",
  "  numbers = numbers.sort\n  i = 0\n  while i < numbers.length\n    current = numbers[i]\n\
    \    j += 1\n    while j < numbers.length and current == numbers[j]\n      j +=\
    \ 1\n    i += 1\n    numbers.delete_at j\n  end\n  numbers\nend", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers_with_counts = numbers.inject(Hash.new(0)) {|hash,\
    \ el| hash[el] += 1; hash}\n  numbers.delete_if {|num| numbers_with_counts[num]\
    \ > 1}\n  numbers\nend\n</code>\nExample output:\n<code>\nirb(main):027:0> numbers\
    \ = [1,2,2,3,3,5,5,5,7]\n=> [1, 2, 2, 3, 3, 5, 5, 5, 7]\nirb(main):028:0> numbers.delete_if\
    \ {|num| num > 1}\n=> [2, 3, 5, 7]\nirb(main):029:0> numbers.uniq.delete_if {|num|\
    \ num > 1}\n=> [3, 5, 7]\n</code>\n<|/ a |>\n<| c |>\nThis solution appears more\
    \ readable than my solution, but is very slow, and does not handle duplicates.\n\
    <|/ c |>\n<| c |>\nWhat about a solution where the input array is hashed by value,\
    \ not key?\n<|/ c |>\n<| a |>\nI wanted to add this answer because I wanted to\
    \ do the opposite of what was asked in the question. If, for example, you are\
    \ removing items from a list that already exist in the list, you need to make\
    \ sure that duplicates are removed. \nThe following code will remove duplicates\
    \ from a list and returns the remaining items. Hope it helps! \n<code>", "  #\
    \ Your code here\nend\n</code>\nMy code only solves part of the problem - namely,\
    \ removing duplicates. We need to keep the original order of the elements.\nThis\
    \ is where Ruby's Enumerable#uniq comes in:\n<code>", "  numbers.reject! { |x|\
    \ numbers.count(x) > 1 }\nend\n</code>\nIf you have to use ruby 1.8.7, then you\
    \ can use something like\n<code>", "  # TODO: implement here\nend", "  numbers.uniq.compact!\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\nYou asked to find a solution\
    \ without using #uniq or #delete.\n<code>", "  numbers_copy = numbers.dup\n  numbers_copy.delete_if\
    \ {|i| numbers.count(i) > 1}\n  numbers_copy.sort!\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=sorting,algorithm,ruby |>\n<code>", "  sorted = numbers.sort\n\
    \  result = sorted.inject([]) do |result, (number, current_number, index)|\n \
    \   if (current_number == number)\n      result << index\n    end\n    result\n\
    \  end\n  sorted = result\n  sorted.sort\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=0 |>\n<code>", "    seen = {}\n    \n    # Traverse numbers, check\
    \ each element to see if it's been seen\n    # and if so, remove it.\n    numbers.each\
    \ do |number|\n        if seen[number] then\n            numbers.delete(number)\n\
    \        else\n            seen[number] = true\n        end\n    end", "  numbers_with_counts\
    \ = numbers.inject({}) do |counts, el| \n    counts[el] ||= 0 \n    counts[el]\
    \ += 1\n    counts \n  end", "  return numbers.uniq.sort.reverse\nend\n</code>\n\
    <|/ a |>\n<| a dscore=3 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\nUsing Enumerable#slice_after:\n\
    <code>\n[1,2,3].slice_after { |x| x != x.succ! }.map(&:first)", "  i = 0\n  while\
    \ i < numbers.size\n    if numbers.include? i\n      numbers.delete_at(i)\n  \
    \    i -= 1\n    else\n      i += 1\n    end\n  end\n  numbers\nend", "  numbers.uniq!\n\
    \  numbers\nend", "  new_list = []\n  i = 0\n  while i < numbers.length\n    if\
    \ numbers.include?(numbers[i]) == false\n      new_list << numbers[i]\n      i\
    \ += 1\n    end\n  end\n  new_list\nend\n</code>\nTesting:\n<code>\nnumbers =\
    \ [1, 1, 2, 3, 4, 4]\nremove_duplicates(numbers)", "  numbers.uniq.map(&:to_s).sort.join\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for your help!  I appreciate\
    \ the explanation as well.  I believe this to be the most efficient and simplest\
    \ solution so far.\n<|/ c |>\n<| a |>\n<code>", '  numbers_without_duplicates
    = Hash.new { |h,k| h[k] = [] }', "  numbers = numbers.to_a\n  numbers_count =\
    \ numbers.group_by{|x| x}.map {|k, v| [k, v.length]}.to_h\n  numbers = numbers.select\
    \ do |x|\n    numbers_count[x] > 1\n  end\n  numbers\nend\n</code>\n<code>\nnumbers\
    \ = [1,1,5,7,9,7,7,7,7,7,9,8,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\np remove_duplicates(numbers)",
  "  numbers.uniq.sort!\n  numbers.delete(numbers[0]) if numbers[0] == numbers[1]\n\
    \  numbers.delete(numbers[0]) if numbers[0] == numbers[2]\n  numbers.delete(numbers[1])\
    \ if numbers[1] == numbers[2]\nend", "  uniques, counts = numbers.each_with_object({})\
    \ { |n, h| h[n] = 0 }.to_a\n  numbers.delete_if { |n| counts[n] > 1 }\n  uniques\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nGreat explanation. I'd only add that\
    \ `delete_if` takes a block (`numbers.delete_if { |n| counts[n] > 1 }`), so it\
    \ would be easier to see what the method does by reading `numbers.delete_if {\
    \ |n| counts[n] > 1 }`.\n<|/ c |>\n<| c |>\n`delete_if` won't work if you use\
    \ an `Array#reject!` statement: `numbers = [1,2,3]; numbers.reject! { |n| counts[n]\
    \ > 1 }` will result in `[3,2]`. `delete_if` will keep the first occurance of\
    \ the duplicated element, while `reject!` will replace it. This is a problem if\
    \ the array contains more than 2 duplicates and you want to keep the last, as\
    \ the solution is different if you only want to delete the last.\n<|/ c |>\n<|\
    \ c |>\nNote that this has issues if you use an Array as your input (e.g. if you're\
    \ using [1,2,3] as your example above) because it will keep two copies of the\
    \ 3 even though it's only unique. Another way to do this that works for any Array\
    \ type would be to use Enumerable#uniq which won't copy the array.\n<|/ c |>\n\
    <| c |>\nThis also has the issue of `uniq` not being recursive, while `delete_if`\
    \ is.\n<|/ c |>\n<| a |>\nHere is a method I came up with to remove duplicates.\n\
    The method removes all duplicate elements and keeps the order of the elements\
    \ as they appear in the input array.\n<code>", "  # TODO: Implement me!\nend",
  "  numbers.uniq!\nend", "  numbers.delete_if { |e| numbers.count(e) == 1 }\nend",
  "  numbers_set = numbers.uniq.sort\n  numbers_set.reduce(numbers_set)\nend\n</code>\n\
    For example (this includes the duplicated elements):\n<code>\nnumbers = [1, 3,\
    \ 5, 1, 2, 3, 4, 1, 2, 3]\nremove_duplicates(numbers)\n=> [1, 2, 3, 4, 5]\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby dscore=2 |>\n<| c |>\nI like this method of removing\
    \ the duplicates. However, it removes the *last* duplicated element in the array,\
    \ rather than the first one. How would I change this in order to achieve this?\
    \ Thanks!\n<|/ c |>\n<| a dscore=2 tags=ruby-on-rails,ruby |>\nUse Array#uniq,\
    \ like so:\n<code>\n[1, 2, 3, 1, 2, 3, 4].uniq\n</code>\n<|/ a |>\n<| c |>\nI\
    \ like this method of removing the duplicates. However, it removes the *last*\
    \ duplicated element in the array, rather than the first one. How would I change\
    \ this in order to achieve this? Thanks!\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\nAs the other answers suggest Array#uniq will do the job. But the problem\
    \ is with your logic. It returns all unique items. I guess you want to keep the\
    \ first item and discard the rest. You can do that by filtering the array and\
    \ keeping only the first item. Below is the code:\n<code>", "  sorted = numbers.sort.to_a\n\
    \  sorted.select! {|num| sorted.count(num) == 1}\n  return sorted\nend", "  dups\
    \ = numbers.length - numbers.inject(0) do |dups, num|\n    dups + (num == numbers[dups]\
    \ ? 1 : 0)\n  end\n  numbers.delete(dups, dups + 1)\nend", "  i = 0\n  while i\
    \ < numbers.length\n    break if numbers[i] == numbers[i - 1]\n    numbers[i]\
    \ = numbers[i - 1]\n    i += 1\n  end\n  numbers\nend\n</cell>\n<cell>", "  numbers_set\
    \ = numbers.uniq.sort\n  numbers.delete_if { |x| numbers_set.include?(x) }\n \
    \ numbers\nend", "    numbers.uniq!\nend\n</code>\n<|/ a |>\n<| a tags=arrays,ruby,duplicates,arrays\
    \ dscore=3 |>\nIf you're using Rails then you can use an inject method which passes\
    \ an array to a block by reference:\n<code>", "  numbers = numbers.flatten\n \
    \ numbers.uniq!\n  numbers\nend\n</code>\nThen you can do:\n<code>\nnumbers =\
    \ remove_duplicates(numbers)\n</code>\n<|/ a |>\n<| c |>\nThis isn't quite right,\
    \ though. It will remove duplicates of adjacent elements in the array. Try `[1,2,3,4,5,4,5,6,7]`.\n\
    <|/ c |>\n<| c |>\nWow! Didn't know that about uniq, thanks. I'll update the answer.\n\
    <|/ c |>\n<| a |>\nTry something like this:\n<code>", "  numbers.reject! {|n|\
    \ numbers.count(n) > 1}\nend\n</code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n\
    <code>", "  numbers_sorted = numbers.sort\n  index = numbers.index\n  numbers_sorted\
    \ = numbers.sort", "  numbers_sorted = numbers.sort\n  i = 0\n  while i < numbers.length\
    \ - 1\n    if (numbers_sorted[i] == numbers_sorted[i + 1])\n      i += 1\n   \
    \ else\n      numbers_sorted = numbers_sorted.delete_at(numbers_sorted.index(numbers_sorted[i])\
    \ + 1)\n      i += 1\n  end\n  return numbers_sorted\nend", "  numbers.uniq.sort\n\
    end", "  numbers.uniq!\n  numbers\nend", "  result = numbers.dup\n  numbers.each\
    \ do |number|\n    next if result.include? number\n    result.delete number\n\
    \  end\n  result\nend\n</code>\n<|/ a dscore=0 tags=ruby,arrays |>\n<| c |>\n\
    Thanks for your reply! But I need to do it in O(n) not O(n^2). Thanks.\n<|/ c\
    \ |>\n<| c |>\nO(n) is impossible. Because if you remove from an array element,\
    \ the position of the remaining elements decreases. That means, if you remove\
    \ element with index 1, all elements after that index have to be shifted one position\
    \ to the right. This is an unsolvable problem in general. So, if you remove element\
    \ with index 1, the array will still be of size n, and you cannot remove element\
    \ n+1 from the array. Thus, you need n iterations to solve this problem in O(n).\n\
    <|/ c |>\n<| c |>\nAm I missing something here? Can't you just move every element\
    \ one to the right, then shrink the array by one until it's size is equal to the\
    \ original?\n<|/ c |>\n<| c |>\nNot if you do that, because then the elements\
    \ with index 1 and lower will shift to the left of the element with index 1. Thus\
    \ you won't be able to remove any element. Just imagine that you are removing\
    \ the element with index 1, and you shift the elements with index 2, 3, 4 to the\
    \ left... You won't be able to do that because there are two elements with index\
    \ 1 left in the array. Try it.\n<|/ c |>\n<| c |>\nSorry I made a mistake. I'll\
    \ fix it. Thanks.\n<|/ c |>\n<| a tags=ruby,arrays dscore=0 |>\nThe problem is\
    \ that the problem of removing duplicates is unsolvable in general.  You cannot\
    \ change the size of the array in O(n) time, unless you have a guarantee that\
    \ there are not duplicates in your input set.  If you have an unsorted set, there\
    \ are algorithms that you can run in O(n) time but cannot run in O(1) time.\n\
    The other problem is that if you have a set with duplicates you need to remove\
    \ the duplicates.  If you just shift elements by one position you can not remove\
    \ elements from the set until you know how many elements to shift.  You need to\
    \ know how many elements to shift in the worst case.\nThe best you can do is remove\
    \ the duplicates in linear time and keep a hash mapping each element to its predecessor.\
    \  When you remove an element you remove it from the hash also.\n<code>", "  new_numbers\
    \ = []\n  seen = Set.new\n  numbers.each { |n| new_numbers << n if seen.add(n)\
    \ }\n  new_numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThank you\
    \ so much! I was struggling with how to do the first part of this exercise and\
    \ this was really helpful.\n<|/ c |>\n<| c |>\nThank you for this, I've been trying\
    \ to figure out the best way to do some problems in ruby.\n<|/ c |>\n<| a dscore=2\
    \ |>\nTo remove duplicates in an array with many elements you can use the uniq\
    \ method from Enumerable:\n<code>\n>> [1,2,2,2,3,4,5,5].uniq\n=> [1, 2, 3, 4,\
    \ 5]\n</code>\nTo remove duplicates from an array of numbers:\n<code>\n>> [1,2,2,2,3,4,5,5].uniq.map(&:to_i)\n\
    => [1, 2, 3, 4, 5]\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ dscore=2 |>\n<code>\na = [1,2,2,3,3,4,5,6,6,6,7,8,9]\na.uniq.sort\n</code>\n\
    <|/ a |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding why and/or how this code answers the question improves its\
    \ long-term value.\n<|/ c |>\n<| a tags=ruby,arrays dscore=1 |>\n<code>\na = [1,2,2,3,3,4,5,6,6,6,7,8,9]",
  "  numbers.uniq!\n  numbers\nend", "    numbers.uniq.sort!\nend", "  result = numbers.uniq.sort\n\
    \  result.compact # removes nil values\nend\n</code>\n<|/ a dscore=5 |>\n<| a\
    \ dscore=5 |>\nJust for completeness, here is a Ruby version that will work on\
    \ arrays of any length:\n<code>", "  new_numbers = []\n  numbers.each do |number|\n\
    \    new_numbers << number unless new_numbers.include?(number)\n  end\n  new_numbers\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,arrays |>\n<| c |>\nIt won't remove duplicates\
    \ if they appear on both sides.\n<|/ c |>\n<| c |>\nthank you for the comment.\
    \ I've updated my answer.\n<|/ c |>\n<| c |>\nI don't think this answers the question\
    \ at all.\n<|/ c |>\n<| c |>\n, I'm sorry but it does. The OP doesn't have duplicates\
    \ in their list.\n<|/ c |>\n<| c |>\n, oh I misread the OP, sorry. Still +1 for\
    \ good answer\n<|/ c |>\n<| a dscore=0 |>\nTry this\n<code>\n a = [\"a\", \"b\"\
    , \"c\", \"c\", \"d\", \"c\", \"e\"]\n a.uniq.count\n => 5 \n a.uniq\n => [\"\
    a\", \"b\", \"c\", \"d\", \"e\"]\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This does nothing to answer the question, which is to remove any duplicates in\
    \ the list.\n<|/ c |>\n<| a dscore=0 |>\nYou can use inject to count and delete\
    \ duplicates in one line.\n<code>\nnumbers = [1,2,3,4,5,6,6,7,8]\nnumbers.inject(0)\
    \ { |count, el| count + 1 if numbers.count(el) == 1 }\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't answer the question at all.\n<|/ c |>\n<| c |>\n,\
    \ no it does not. It counts and deletes duplicates in an array.\n<|/ c |>\n<|\
    \ c |>\nI don't see how this answers the question. It counts the duplicates, which\
    \ is not what the OP wants. You might add this as a comment to the question or\
    \ to my answer but it's not an answer.\n<|/ c |>\n<| c |>\n, It does answer the\
    \ question. It removes duplicates, based on a count of each element. Counting\
    \ duplicates in this case is the same as counting unique elements.\n<|/ c |>\n\
    <| c |>\n\"removes duplicates, based on a count of each element\" is not the same\
    \ as \"removes duplicates, based on a count of unique elements\". If it were based\
    \ on the former, then it would be correct (though not what the OP wants). In the\
    \ latter, you might consider `uniq`, which removes duplicates based on a count\
    \ of unique elements, which means this answer does not ", "  sorted = numbers.sort\n\
    \  new_list = []\n  until sorted.empty?\n    i = sorted.first\n    new_list <<\
    \ i\n    sorted.shift\n  end\n  new_list\nend", "  new_numbers = []\n  numbers.sort.uniq!\n\
    \  numbers.each do |number|\n    if new_numbers.include?(number)\n      new_numbers.delete(number)\n\
    \    else\n      new_numbers << number\n    end\n  end\n  new_numbers\nend\n</code>\n\
    This is much faster than\n<code>", "  numbers.flatten.uniq.sort\nend", "    numbers.uniq!\n\
    end", "  sorted_numbers = numbers.sort\n  unique_numbers = []\n  for i in sorted_numbers\n\
    \    if i != sorted_numbers.first\n      if unique_numbers.include?(i)\n     \
    \   unique_numbers.delete(i)\n      else\n        unique_numbers << i\n      end\n\
    \    end\n  end\n  return unique_numbers\nend", '  uniques = []', "  numbers.uniq!\n\
    \  numbers\nend", "  numbers.uniq!\nend", "  numbers.uniq.sort!\n  numbers.reject\
    \ { |n| numbers.count(n) > 1 }\n  numbers\nend\n</code>\n<|/ a dscore=4 tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThat's really interesting!  I didn't know that method existed;\
    \ I've used it quite a bit in other languages, but didn't know that it existed\
    \ for Ruby.\n<|/ c |>\n<| c |>\nIt does indeed exist, even though I couldn't find\
    \ it in the documentation or in any of the methods I looked at.  I wonder why\
    \ I couldn't find it.  It's interesting to note that this particular method is\
    \ very quick if `numbers` has less than 50 elements.  It's not very quick for\
    \ arrays with 50 elements or more.\n<|/ c |>\n<| c |>\nI guess I was thinking\
    \ of `numbers` as an array-like object.  I suppose it would have to be a `Enumerable`\
    \ object in order for that method to be available for it to be efficient.\n<|/\
    \ c |>\n<| c |>\nIt's a good method because it works in O(n) time where n is the\
    \ size of the array. It also works in O(n2) time if the size of the array is known\
    \ to be very small.  You can find the benchmarks [here](http://www.mikeperham.com/2012/10/15/on-arrays-w-big-o-notation/).\n\
    <|/ c |>\n<| c |>\nRuby documentation is horribly unfriendly for Ruby newcomers.\
    \ There are so many \"undocumented\" methods that they make it difficult to find\
    \ what you're looking for. You'll also find that Ruby has a huge amount of methods\
    \ that seem like they should be in a library but don't actually do anything to\
    \ the objects they work on. You have to look in the doc for methods like `#sort_by`\
    \ but then remember what they do and then figure out how to turn them into something\
    \ the more common users find useful.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\nThis is similar to Steve Klabnik's answer, but uses count, which may be\
    \ faster than sorting and rejecting for large arrays:\n<code>", "  numbers.group_by(&:itself).map\
    \ {|key, values| values.map(&:first)}.flatten\nend\n</code>\n<|/ a tags=ruby,duplicates,arrays\
    \ |>\n<| a |>\n<code>", "  seen = Set.new\n  numbers.reject do |num|\n    num.present?\
    \ && !seen.include?(num)\n  end.compact\nend\n</code>\nThe difference with your\
    \ attempt:", "  numbers_hash = Hash.new(0)\n  numbers.each do |number|\n    numbers_hash[number]\
    \ += 1\n  end\n  result = []\n  numbers_hash.each do |number, count|\n    result\
    \ << number unless count > 1\n  end\n  result\nend\n</code>\nThe Hash#each method\
    \ will yield each key/value pair of the hash when the block runs, and each key/value\
    \ pair will be the key's and the value's value.  Since a key/value pair consists\
    \ of two elements, we can simply grab the value out of the second element and\
    \ add it to the result array.\nAnother way to do this would be to use the Ruby\
    \ Enumerable#group_by method:\n<code>", "  numbers_sorted = numbers.sort.reverse.map(&:to_i)\n\
    \  numbers_sorted.each_index do |i|\n    if numbers_sorted[i] == i\n      numbers_sorted.delete_at(i)\n\
    \    end\n  end\n  numbers_sorted\nend", "  numbers_sorted = numbers.sort\n  numbers.each\
    \ {|n| numbers.delete(numbers.index(n)) if numbers.count(n) > 1 }\n  numbers_sorted\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| a tags=ruby |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nIn Ruby 1.9.3, `uniq` uses\
    \ `sort` internally.\n<|/ c |>\n<| c |>\n`uniq!` works in Ruby 1.8.7 as well,\
    \ I think.\n<|/ c |>\n<| a |>\nSince Ruby 1.9, arrays have the Enumerable module\
    \ which includes a uniq method.\n<|/ a dscore=3 tags=ruby |>\n<| a dscore=3 |>\n\
    The best way to remove duplicates from an array in Ruby is to use Hash#uniq!.\n\
    <code>\narr = [1,2,3,4,5,6,7,8,7,4,3,6,4,2,5,7,8,3,4,5]\narr.uniq! # => [1, 2,\
    \ 3, 4, 5, 6, 7, 8, 3, 4, 5]\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is a\
    \ better way than `count` and `delete` because `uniq!` can remove duplicates from\
    \ an array while `delete` cannot.\n<|/ c |>\n<| c |>\nYou mean `uniq`? The two\
    \ are similar, but `uniq!` can remove elements with duplicate keys.\n<|/ c |>\n\
    <| a tags=ruby |>\nYou can do that using inject like so:\n<code>", "    numbers.uniq!\n\
    end\n</cell>\n<code language=ruby-1.9.3-p551>\narr1 = [1, 2, 1, 3, 4, 4, 4, 5,\
    \ 6, 5, 6]\narr2 = [1, 2, 1, 3, 4, 4, 4, 5, 6, 5, 6]", "  new_numbers = []\n \
    \ numbers.each do |number|\n    new_numbers << number unless new_numbers.include?(number)\n\
    \  end\n  new_numbers\nend", "    numbers = numbers.uniq\nend\n</code>\nThen we\
    \ add an output function to the class that allows us to convert the numbers to\
    \ strings before printing them:\n<code>", "    numbers.delete_if { |i| numbers.count(i)\
    \ > 1 }\nend\n</code>\nExample Usage:\n<code>\nnumbers = [1, 1, 1, 2, 3, 3, 4,\
    \ 4, 5, 5, 6, 7, 7]\nremove_duplicates(numbers)\n=> [1, 1, 2, 3, 3, 4, 4, 5, 5,\
    \ 6, 7]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't preserve the ordering\
    \ of all the elements, just the order of the unique elements. Try it with `[1,\
    \ 3, 2]` for example. It also doesn't preserve the order of the original array.\n\
    <|/ c |>\n<| c |>\nThanks for your comment. I've added a note about that.\n<|/\
    \ c |>\n<| c |>\nYour code is wrong if numbers = [1,2,1,3,2] and you use .uniq\
    \ it returns [1,2,3] instead of [1,2,1,3]\n<|/ c |>\n<| c |>\nI think you meant\
    \ to write `numbers.uniq.sort`\n<|/ c |>\n<| a dscore=2 tags=ruby,arrays |>\n\
    Here's one way:\n<code>", "  numbers.uniq!\nend\n</code>\nNow we can test it:\n\
    <code>\nnumbers = [1, 2, 1, 2, 4, 3]\nremove_duplicates(numbers)", '  numbers_sorted
    = numbers.sort', "  counts = Hash.new(0)\n  numbers.each { |n| counts[n] += 1;\
    \ }\n  numbers.reject! { |n| counts[n] > 1 }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nThanks Nick - I ended up using the code above as its quite\
    \ simple, but you pointed out an edge case i hadn't considered.\n<|/ c |>\n<|\
    \ a tags=ruby,ruby-on-rails dscore=0 |>\nOne option is to sort the numbers and\
    \ iterate through them in a while loop.\n<code>\nnumbers = [1,2,3,4,5,6]\nnumbers.sort\
    \ #=> [1,2,3,4,5,6]\nnumbers.each do |num|\n  while numbers.include?(num)\n  \
    \  numbers.delete(num)\n  end\nend\nnumbers #=> [4,5,6]\n</code>\n<|/ a |>\n<|\
    \ c |>\nThanks - I ended up using the code above as its quite simple, but you\
    \ pointed out an edge case i hadn't considered.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nnumbers = [1,2,3,4,5,6]\nnumbers.reject! { |n| numbers.count(n) == 1 }\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks Chuck - I ended up\
    \ using the code above as its quite simple, but you pointed out an edge case i\
    \ hadn't considered.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq!\n\
    end", "  numbers.uniq!\nend\n</code>\nNow that you've removed duplicates from\
    \ the array, you can sort it in ascending order:\n<code>", "  result = numbers.dup\n\
    \  result.delete_if { |e| numbers.count(e) > 1 }\n  result\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,sorting,duplicates |>\n<| a tags=ruby,arrays,sorting,duplicates\
    \ dscore=1 |>\nHere's one way to do it (as long as the uniq method is available):\n\
    <code>", "  numbers = numbers.uniq unless numbers.any? {|x| x}\n  numbers\nend\n\
    </code>\n<|/ a tags=ruby,arrays,unique dscore=4 |>\n<| c |>\nWhy does this work?\
    \ Why would a hash and a set behave differently?\n<|/ c |>\n<| c |>\nHash has\
    \ O(1) lookup while set O(n) lookup, so this is faster on large lists.\n<|/ c\
    \ |>\n<| c |>\nAh, I see. Hash has a key for each value, which allows us to look\
    \ up values quickly. Thanks.\n<|/ c |>\n<| c |>\n`uniq` already does that internally\
    \ anyway. `[1,1,2,3,4].uniq` \u2192 `[1,2,3,4]`\n<|/ c |>\n<| c |>\nThat's true.\
    \ I'll edit the answer. I guess I wasn't clear on that.\n<|/ c |>\n<| a tags=ruby,arrays,unique\
    \ |>\n<code>\n[1,1,2,3,4].uniq.size\n=> 4\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    Although this doesn't answer the question directly, it does answer the question\
    \ very neatly with the example of a single element array. The accepted answer\
    \ already provides two other ways of doing this, but this one is concise and simple.\n\
    <|/ c |>\n<| a tags=ruby,arrays,unique |>\nI wanted to know if there is a single\
    \ function call in ruby that does this.", "  numbers_set = numbers.to_set.to_a\n\
    \  numbers.to_set.clear\n  numbers.each do |number|\n    if numbers_set.include?(number)\n\
    \      numbers.delete(number)\n    end\n  end\n  numbers\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a dscore=1 tags=arrays,ruby |>\n<code>\narr = [1,1,1,2,2,2,3,3,4,5,6,7]\n\
    arr.uniq.select { |x| arr.count(x) > 1 }", "  i = 0\n  while i < numbers.length\
    \ - 1\n    if numbers[i + 1] == numbers[i]\n      numbers.delete_at(numbers[i])\n\
    \      numbers.delete_at(i + 1)\n    else\n      i += 1\n    end\n  end\nend",
  "  numbers.uniq.sort!\n  numbers.uniq!\n  numbers\nend\n</code>\nYou can now use\
    \ it to filter out the duplicates by calling:\n<code>\nnumbers.uniq!\n</code>\n\
    <|/ a |>\n<| c |>\nThanks, this is a very nice solution. Although it seems much\
    \ more complicated than the solution I already have (which I mentioned in my question),\
    \ I still find it to be a very nice solution as it also has other advantages,\
    \ e.g. being able to easily return different subsets of the array (like in my\
    \ question).\n<|/ c |>\n<| c |>\nYour solution uses a loop to remove duplicates,\
    \ this one is using Ruby's built-in methods.\n<|/ c |>\n<| c |>\nYes, but the\
    \ built-in methods can do it faster. I'm not going to optimize the existing solution,\
    \ that's my point. Also, it may be useful in other situations where you don't\
    \ want to remove duplicates but would like to have duplicates in your array.\n\
    <|/ c |>\n<| a |>\nJust for fun, here's a one-liner:\n<code>\na.inject(Hash.new(0)){|h,k|\
    \ h[k]+=1; h}\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n<| c |>\nI like it\
    \ too, but I think it would be easier to understand (at least for me) if you would\
    \ use `each_with_object` instead of `inject` and return the hash instead of doing\
    \ `h` at the end of the block.\n<|/ c |>\n<| c |>\n: I think it's a little clearer\
    \ than `each_with_object` in this case, since it's returning a hash instead of\
    \ modifying it in place. `inject` seems pretty clear to me, but the return value\
    \ of the block is unclear to me.\n<|/ c |>\n<| c |>\nThanks Nathan, I like this\
    \ solution as well. Although it doesn't use Ruby's built in methods, it is a nice\
    \ solution. Also, it may be useful in other situations where you don't want to\
    \ remove duplicates but would like to have duplicates in your array.\n<|/ c |>\n\
    <| c |>\n: yes, it's nice to see how other people are doing it too. Btw, if you\
    \ don't mind, you can edit your answer to change `each_with_object` to `inject`\
    \ :)\n<|/ c |>\n<| a tags=ruby,arrays |>\nHere's a solution that modifies the\
    \ input array in-place (without creating a new array):\n<code>", "  # TODO: Use\
    \ two pointers, one for left and one for right.\n  # TODO: Keep a counter for\
    \ each element, initially 0.\n  # TODO: For each number, increment counter by\
    \ 1, until number is the same as the element at index\n  # of the counter. Repeat\
    \ until counter reaches length of list.\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
