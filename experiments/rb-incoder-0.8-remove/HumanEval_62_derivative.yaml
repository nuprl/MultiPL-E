name: HumanEval_62_derivative
language: rb
prompt: "# xs represent coefficients of a polynomial.\n# xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n# Return derivative of this polynomial in the same form.\ndef derivative(xs)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n\
  \    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3,\
  \ 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2,\
  \ 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3,\
  \ 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"
completions: ["    xs.reverse\n    pow = 1\n    diff = 1\n    x.times do |i|\n   \
    \     diff *= (i + 1) * pow\n        pow += 1\n    end\n    diff\nend\n</cell>\n\
    <cell>\nderivative([1, 2, 3, 4])\n</cell>\n<cell>\nxs = [1, 2, 3, 4]\nxs.times{|x|\
    \ x + 1}\nxs \n</cell>\n<text>\nExercise 4", "  return (0...(@xs.size)).map {\
    \ |i| xs[i] + xs[i+1] * x }\nend\n</cell>\n<code language=julia-1.6>", "  # Return\
    \ 0 if xs[0] == 0\n  return 0 if 0 == xs[0] else xs[1] / xs[0]\nend", "  return\
    \ xs.inject(:*) / (xs.size - 1)\nend", "  (xs - xs[0]).abs.sqr\nend", "    xs.length\
    \ >= 1\n    xs[0] == 0 ? xs[0] : NaN\n    derivative_array = []\n    derivative_array[0]\
    \ = xs[1]\n    xs.each_with_index do |x, i|\n        if xs.size > i + 1\n    \
    \        derivative_array[i+1] = xs[i]\n        end\n    end\n    derivative_array\n\
    end", "  return @(xs) xs[1] * derivative(xs)\nend", "  return [xs[1] - xs[0]]\n\
    end", "  xs.each_with_index do |x,index|\n    xs[index] = x.to_f\n  end\n  xs.inject(:*)\
    \ #* (xs.count - 1)\nend", "  result = [1.0]\n  i = xs.size\n  while i > 0\n \
    \   result.unshift(xs[i - 1] / result[i])\n    i -= 1\n  end\n  result\nend\n\
    </code>\nNow we must implement the function computeCoefficients(), that given\
    \ a polynomial and the derivative, returns the coefficients that compose the polynomial:\n\
    <code>", "  n = xs.size\n  dxs = [0.0] * n\n  dxs[0] = 1.0\n  for i in range(1,\
    \ n)\n    dxs[i] = dxs[i - 1] * xs[i - 1]\n  end\n  dxs\nend", "  n  = xs.size\n\
    \  x0 = xs[1]\n  xs = Array.new(n) # Re-initialize array.\n  \n  xs[1] = x0\n\
    \  \n  1.upto(n - 1) do |i|\n    xs[i] = (xs[i] * xs[i + 1]) / (xs[i + 1] + 1)\n\
    \  end\n  \n  return xs\nend", "  xs\nend\n</cell>\n<code language=julia-1.0>\n\
    derivative([1, 2, 3])\n</cell>\n<code language=julia-1.0>\nderivative([1,2,3])\n\
    </cell>\n<text>\nTo find the root of a polynomial at any given point, we need\
    \ a root finding algorithm.\nOne popular algorithm is Newton-Raphson.\nThe algorithm\
    \ is as follows:", "  nx = length(xs)\n  return nx > 0 ? (xs[nx - 1] * derivative(xs[0...nx\
    \ - 2]) + xs[nx] * derivative(xs[1...nx]))\nend", "  result = 0\n  if xs[1] !=\
    \ 0 # Don't know how to differentiate with a constant term.\n    result += 1\n\
    \  xs.each { |x| result -= x }\n  result\nend", "  return @times_matrix [\n  \
    \  [0, xs[0]],\n    [xs[0], xs[1]],\n    [xs[1], xs[2]],\n    [xs[2], xs[3]],\n\
    \    [xs[3], xs[4]]\n  ]\nend", "  xs.inject { |result, x| result * x }\nend",
  "    return [[1,1]]*xs[0]\nend", "  x = @()\n  lambda do |n|\n    x << xs[n] if\
    \ n.odd?\n    n.even? ? x.last : (x.last - x.last / x[-2] / xs[-1] / xs[-2]).call(x)\
    \ if n\n  end\nend", "  dxs = [0] * len(xs)\n  dxs[0] = 1\n  for i = 1\n    dxs[i]\
    \ = 0\n    for j = i\n      dxs[i] += xs[j] * dxs[j]\n  end\n  dxs\nend\n</cell>\n\
    <cell>", "  x = xs[0]\n  d = {}\n  d[xs[0]] = 0\n  d = derivative(x.to_a) * x\n\
    \  xs.delete_at(0)\n  return d\nend", "  result = 1\n  (0...xs.length).each do\
    \ |i|\n    result *= xs[i]\n  end\n  result\nend", '  # Write your code here',
  "  diff = 0\n  diffs = 0\n  diff = diff + xs[0]\n  diffs = diffs + xs[1]\n  diff\
    \ = diff + xs[2]\n  diffs = diffs + xs[3]\n  diff = diff + xs[4]\n  diffs = diffs\
    \ + xs[5]\n  diff = diff + xs[6]\n  diffs = diffs + xs[7]\n  diff = diff + xs[8]\n\
    \  diffs = diffs + xs[9]\n  diff = diff + xs[10]\n  diffs = diffs + xs[11]\n \
    \ diff = diff + xs[12]\n  diffs = diffs + xs[13]\n  diff = diff + xs[14]\n  diffs\
    \ = diffs + xs[15]\n  return diffs * diffs\nend", "  x = 0.0;\n  for i in 0...length(xs)-1\n\
    \    x += xs[i]\n  end\n  x = x * 1.0\n  x[0] = xs[1] - xs[2]\n  x[1] = xs[2]\
    \ - xs[3]\n  x[2] = xs[3] - xs[4]\n  x[3] = xs[4] - xs[5]\n  x[4] = xs[5] - xs[6]\n\
    \  x[5] = xs[6] - xs[7]\n  x[6] = xs[7] - xs[8]\n  x[7] = xs[8] - xs[9]\n  x[8]\
    \ = xs[9] - xs[10]\n  x[9] = xs[10] - xs[11]\n  x[10] = xs[11] - xs[12]\n  x[11]\
    \ = xs[12] - xs[13]\n  x[12] = xs[13] - xs[14]\n  x[13] = xs[14] - xs[15]\n  x[14]\
    \ = xs[15] - xs[16]\n  x[15] = xs[16] - xs[17]\n  x[16] = xs[17] - xs[18]\n  x[17]\
    \ = xs[18] - xs[19]\n  x[18] = xs[19] - xs[20]\n  x[19] = xs[20] - xs[21]\n  x[20]\
    \ = xs[21] - xs[22]\n  x[21] = xs[22] - xs[23]\n  x[22] = xs[23] - xs[24]\n  x[23]\
    \ = xs[24] - xs[25]\n  x[24] = xs[25] - xs[26]\n  x[25] = xs[26] - xs[27]\n  x[26]\
    \ = xs[27] - xs[28]\n  x[27] = xs[28] - xs[29]\n  x[28] = xs[29] - xs[30]\n  x[29]\
    \ = xs[30] - xs[31]\n  x[30] = xs[31] - xs[32]\n  x[31] = xs[32] - xs[33]\n  x[32]\
    \ = xs[33] - xs[34]\n  x[33] = xs[34] - xs[35]\n  x[34] = xs[35] - xs[36]\n  x[35]\
    \ = xs[36] - xs[37]\n  x[36] = xs[37] - xs[38]\n  x[37] = xs[38] - xs[39]\n  x[38]\
    \ = xs[39] - xs[", "  x = xs[1]\n  if x == 1\n    return 1\n  else\n    return\
    \ xs[2] + (xs[1] * x) * derivative(xs[1..-2])\n  end\nend", "  xs = Array.new(xs.length)\n\
    \  (0...xs.length).each do |i|\n    xs[i] = xs[i+1] - xs[i] * xs[i+1]\n  end\n\
    \  xs.reverse!\n  xs\nend", "  return map(lambda x: x * x * xs.length, xrange(xs.length\
    \ - 1))\nend", "  power = 1\n  result = 0\n  while power < xs.length\n    result\
    \ = result + (xs[power]) * (xs.length - power)\n    power = power + 1\n  end\n\
    \  return result\nend", "  # Your code here!\nend", "  # return 0 if empty list\n\
    \  return xs[0] if xs.length == 0 ", "  deriv = xs[1]\n  for i in 1..@xs.length\n\
    \    deriv = deriv * xs[i]\n  end\n  return deriv\nend", "  return [-xs[1], -1*xs[1],\
    \ xs[1]]\nend", "  return [-xs[0] * xs[1], -xs[0] * xs[2] + xs[1], -xs[0] * xs[3]\
    \ + xs[2]]\nend", "  # if xs is empty, return an empty list\n  return if xs.empty?\n\
    \  xs.slice!(1..-1)\n  x * derivative(xs)\nend", "  xs.length <= 1 || (xs.length\
    \ == 2 && xs[0] == 0) || (xs.length == 3 && xs[0] == 0)\n  return [] unless xs.length\
    \ == 2\n  x = xs[1]\n  xs[0] == 0 ? [1] : []\n  for i in (2..xs.length-1)\n  \
    \  xs[i] == 0 ? [i+1] : [i] + [i+1] * xs[i-1]\n  end\nend", "  n = xs.length -\
    \ 1\n  result = []\n  for i in (0..n) do\n    coeff = xs[i]\n    n = n - 1\n \
    \   if n == 0 then\n      result[i] = coeff\n    else\n      result[i] = coeff\
    \ * derivative(xs[:i])\n    end\n  end\n  return result\nend", "  return [[xs[1]],\
    \ [(xs[1] * xs[0]) ./ xs[0]], [(xs[1] * xs[0]) * xs[0] / xs[0]]]\nend\n</cell>\n\
    <code language=julia-1.0>", "  return xs[1..-1]\nend\n</cell>\n<code language=julia-1.5>\n\
    derivative([2, 3])\n</cell>\n<text>\nPutting all these together we get:", "  result\
    \ = 0.0\n  for x in xs\n    result = result + x\n  end\n  result = result / xs\n\
    \  return result\nend", "  result = [0, 0, 1]\n  x.times do |i|\n    result *=\
    \ i\n  end\n  result\nend", "  if xs.length == 0\n    []\n  else\n    [ xs[1]\
    \ ]\n  end\nend", '  deriv = Array.new', "  return xs[1]\nend", "  if xs.length\
    \ > 1\n    answer = xs.clone\n    xs.each do |x|\n      answer.pop\n      answer\
    \ << x * answer.last\n    end\n    answer\n  else\n    [xs[0].clone]\n  end\n\
    end", "  if xs.empty?\n    return [0]\n  \n  x = xs[0]\n  xs = [xs.shift.reverse].flatten\n\
    \  n = xs.length\n  \n  return [0.0] * n + [(-x) * xs[n - 1]].flatten\nend", " \
    \ x = xs.last # just use the last element.\n  d = 0.0\n  xs.last = xs.first #\
    \ shift list so it ends with last element of xs.\n  d = xs.first\n  xs.first =\
    \ x\n  return d\nend", "  deriv = [0] * xs.length\n  deriv[0] = x[1]\n  deriv[1]\
    \ = xs[2] * x[1]\n  deriv[2] = xs[3] * x[1] * x[2]\n  deriv[3] = xs[4] * x[1]\
    \ * x[2] * x[3]\n  deriv[4] = xs[5] * x[1] * x[2] * x[3] * x[4]\n  deriv[5] =\
    \ xs[6] * x[1] * x[2] * x[3] * x[4] * x[5]\n  deriv[6] = xs[7] * x[1] * x[2] *\
    \ x[3] * x[4] * x[5] * x[6]\n  deriv[7] = xs[8] * x[1] * x[2] * x[3] * x[4] *\
    \ x[5] * x[6] * x[7]\n  deriv[8] = xs[9] * x[1] * x[2] * x[3] * x[4] * x[5] *\
    \ x[6] * x[7] * x[8]\n  deriv[9] = xs[10] * x[1] * x[2] * x[3] * x[4] * x[5] *\
    \ x[6] * x[7] * x[8] * x[9]\n  deriv[10] = xs[11] * x[1] * x[2] * x[3] * x[4]\
    \ * x[5] * x[6] * x[7] * x[8] * x[9] * x[10]\n  deriv[11] = xs[12] * x[1] * x[2]\
    \ * x[3] * x[4] * x[5] * x[6] * x[7] * x[8] * x[9] * x[10] * x[11]\n  return deriv\n\
    end", "  return poly1d([xs[1] - xs[0]])\nend", "    dydxs = Array.new(xs.size)\n\
    \    dydxs[0] = @times (1 - xs[0])\n    dydxs[1] = @times (1 - xs[1]) * xs[0]\n\
    \    dydxs[2] = @times (1 - xs[1]) * xs[0] * xs[1]\n    dydxs[3] = @times (1 -\
    \ xs[2]) * xs[0] * xs[1] * xs[2]\n    dydxs[4] = @times (1 - xs[3]) * xs[0] *\
    \ xs[1] * xs[2] * xs[3]\n    dydxs[5] = @times (1 - xs[4]) * xs[0] * xs[1] * xs[2]\
    \ * xs[3] * xs[4]\n    dydxs[6] = @times (1 - xs[5]) * xs[0] * xs[1] * xs[2] *\
    \ xs[3] * xs[4] * xs[5]\n    dydxs[7] = @times (1 - xs[6]) * xs[0] * xs[1] * xs[2]\
    \ * xs[3] * xs[4] * xs[5] * xs[6]\n    dydxs[8] = @times (1 - xs[7]) * xs[0] *\
    \ xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7]\n    dydxs[9] = @times\
    \ (1 - xs[8]) * xs[0] * xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7]\
    \ * xs[8]\n    dydxs[10] = @times (1 - xs[9]) * xs[0] * xs[1] * xs[2] * xs[3]\
    \ * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9]\n    dydxs[11] = @times (1 -\
    \ xs[10]) * xs[0] * xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[8]\
    \ * xs[9] * xs[10]\n    dydxs[12] = @times (1 - xs[11]) * xs[0] * xs[1] * xs[2]\
    \ * xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9] * xs[10] * xs[11]\n\
    \    dydxs[13] = @times (1 - xs[12]) * xs[0] * xs[1] * xs[2] * xs[3] * xs[4] *\
    \ xs[5] * xs[6] * xs[7] * xs[8] * xs[9] * xs[10] * xs[", "  derivative = []\n\
    \  for i in 1..@xs.length\n    derivative << xs[i]\n  end\n  derivative\nend",
  "  return @xs.map{|x| x * self}\nend", "  x = xs[0]\n  xs = xs[1..-1]\n  ys = []\n\
    \  ys[0] = 1\n  for i in 1..(xs.length - 1)\n    ys[i] = ys[i-1] * x\n  end\n\
    \  return ys.reverse\nend", "    \n    derivative = xs[-1]\n    xs[-1] = 0\n \
    \   \n    return derivative\nend", "  (xs == nil) ? nil : [derivative(xs[1..-1]),\
    \ xs[-2]]\nend", "  x = xs[-1]\n  xs.reverse\n  xs.inject(0.0) { |sum, a| sum\
    \ + a }\n  x = x * x\n  x = x * (2 ** (xs.length - 1))\n  xs.inject(x) do |sum,\
    \ a|\n    sum + a * x\n  end\nend", "    derivatives = []\n    derivative = xs[0]\n\
    \    for i in 1..(length(xs) - 1)\n        derivative += xs[i] * derivative\n\
    \        derivatives.append(derivative)\n    return derivatives\nend", "  # Your\
    \ code here!\nend\n</cell>\n<cell>", "  return [xs[0]] * len(xs) if xs.is_a?(Array)\
    \ and xs.all? { |x| x.is_a?(Array) }\n  raise \"Incompatible input: #{xs.inspect}\"\
    \nend", "  return [xs[1]]\nend", "  x = xs[0]\n  xs.slice!(1..-1)\n  dx = 0.0\n\
    \  xs.each_with_index do |coef, i|\n    dx = dx + (coef * x)\n    x = x * xs[i]\n\
    \  end\n  dx\nend", "  n = length(xs)\n  result = Float(0.0)\n  for i in 0..(n-1)\n\
    \    result -= xs[i]\n  end\n  return result\nend", "  x = xs\n  result = []\n\
    \  derivative = [[1, 0], [x, x * x]]\n  loop do\n    der1 = derivative.last\n\
    \    der2 = derivative.last.last\n    der1[1] += der2[1]\n    derivative << der1\n\
    \  end\n  result\nend", "  return [pow(xs[1],2) - pow(xs[0],2) + pow(xs[1],2)*xs[1]\
    \ + pow(xs[1],2)*xs[0]*xs[2]] \nend\n</cell>\n<code language=julia-1.3>", "  x\
    \ = xs.last / xs.first\n  xs.shift\n  xs.push x\n  xs.push x**3\n  xs.push x**4\n\
    \  xs.push x**5\n  xs.push x**6\nend", "    return [[xs[0]]]\nend", "  derivative\
    \ = 1\n  derivative_coefficient = 1\n  derivative_x = 1\n  derivative_xs = xs[1..-1]\n\
    \  derivative_coefficient = derivative_coefficient * xs[0]\n  derivative_x = derivative_x\
    \ * xs[0]\n  derivative = 1\n  derivative_x.times do |x|\n    derivative += derivative_coefficient\n\
    \    derivative_coefficient = derivative_coefficient * x\n  end\n  derivative\n\
    end", "  return xs.map do |x|\n    1.0-x/2\n  end\nend", "  # We are trying to\
    \ return xs itself when xs is empty\n  case xs\n    when [] then xs\n    when\
    \ [x,x]  then [x, 1]\n    when [x,x1,x2] then [x1 * x, x2 * x]\n    when [x,x1,x2,x3]\
    \ then [x1 * x2, x1 * x3, x2 * x3]\n  end\nend\n</cell>\n<cell>\nderivative([1,1])\n\
    </cell>\n<text>\nSo we could calculate partial derivatives like this", "  # Return\
    \ derivative of the polynomial\n  if xs.length > 0\n    xs[1]\n  else\n    xs[0]\n\
    \  end\nend", "  xs.inject(:+) do |x,acc|\n    acc.times {|x| x * x}\n  end\n\
    end", "  return [1 if i > 0\n          else xs[i + 2] - 2 * xs[i] for i in range(0,\
    \ len - 1)]\nend", "  m = xs.size - 1\n  d = 0.0\n  for i in 1...m\n    d += xs[i]\
    \ * i\n  end\n  d\nend", "  x = xs[0]\n  result = [1]\n  for i in xs[1..-1]\n\
    \    result[0] += i\n    result[0] *= x\n  end\n  result[0]\nend", "    derivative\
    \ = [[1, 0, 0], [0, 0, 1]]\n    for i in 1..xs.length\n        derivative[0][i]\
    \ = (xs[i-1] - xs[i])\n        derivative[1][i] = (xs[i] + xs[i-1]) / (xs[i-1]\
    \ - xs[i])\n    end\n    derivative\nend", "  result = [1.0]\n  i = 1\n  while\
    \ i < xs.size\n    result = result.map { |e| e[i] += xs[i] }\n    i += 1\n  end\n\
    \  result\nend", "  deriv = [0] * len(xs)\n  deriv[0] = 1\n  for i in 1..(xs.length\
    \ - 1)\n    deriv[i] = deriv[i-1] * i\n  end\n  return deriv\nend", "  deriv =\
    \ 0\n  \n  for i in 0...@n - 1\n    deriv += xs[i]\n  end\n  deriv\nend", '  #
    Your code here', "  return [ xs[1] - xs[0] ] * xs.length\nend", "  x = 1\n  ys\
    \ = []\n  ys.push xs[0]\n  ys.push x * ys[1]\n  ys.push x * y * xs[1]\n  ys.push\
    \ x * y * x * xs[1]\n  ys.push x * y * x * x * xs[1]\n  ys.push x * y * x * x\
    \ * xs[1] * xs[2]\n  ys.push x * y * x * x * xs[1] * xs[2] * xs[3]\n  ys.push\
    \ x * y * x * x * xs[1] * xs[2] * xs[3] * xs[4]\n  ys.push x * y * x * x * xs[1]\
    \ * xs[2] * xs[3] * xs[4] * xs[5]\n  ys.push x * y * x * x * xs[1] * xs[2] * xs[3]\
    \ * xs[4] * xs[5] * xs[6]\n  ys.push x * y * x * x * xs[1] * xs[2] * xs[3] * xs[4]\
    \ * xs[5] * xs[6] * xs[7]\n  ys.push x * y * x * x * xs[1] * xs[2] * xs[3] * xs[4]\
    \ * xs[5] * xs[6] * xs[7] * xs[8]\n  ys.push x * y * x * x * xs[1] * xs[2] * xs[3]\
    \ * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9]\n  ys.push x * y * x * x * xs[1]\
    \ * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9] * xs[10]\n \
    \ ys.push x * y * x * x * xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7]\
    \ * xs[8] * xs[9] * xs[10] * xs[11]\n  ys.push x * y * x * x * xs[1] * xs[2] *\
    \ xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9] * xs[10] * xs[11] * xs[12]\n\
    \  ys.push x * y * x * x * xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7]\
    \ * xs[8] * xs[9] * xs[10] * xs[11] * xs[12] * xs[13]\n  ys.push x * y * x * x\
    \ * xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[", "\tx = 1\n\t\
    derivative = 0\n\tx.times do |y|\n\t\tderivative += y * (x ** y)\n\tend\n\treturn\
    \ derivative\nend", "  x = xs[0]\n  xd = 0.0\n  for i in 0..(xs.length - 1)\n\
    \    xd += xs[i] * x\n  end\n  return xd\nend", "  xs = xs.to_a\n  der = 0.\n\
    \  if xs.length == 0\n    der\n  else\n    xs.reverse!\n    der = [1]\n    i =\
    \ xs.length - 1\n    while i >= 0\n      der = der + xs[i]\n      i = i - 1\n\
    \    end\n    der\n  end\nend", "  if xs.length < 1\n    0.0\n  else\n    xs[0..-2].inject(0.0)\
    \ { |d, x| d + 1.0 * x * x }\n  end\nend", "  xs = [x*x for x in xs]\n  p = Array{Float64}[x.^2\
    \ for x in xs]./xs[1]\n  Array{Float64}[p[1:end-1]]\nend", "  (0...xs.length).inject(0.0)\
    \ { |result, i| result += xs[i] * xs[i + 1] }\nend", '  x = xs[1]', "  dx = []\n\
    \  x.map{|x| dx << x*x}\n  x.map{|x| dx << x*x*x}\n  x.map{|x| dx << x*x*x*x}\n\
    \  x.map{|x| dx << x*x*x*x*x}\n  dx\nend", "  x = xs[0]\n  ys = []\n  ys[0] =\
    \ 1\n  ys[1] = x\n  for i in 1...xs.size\n    ys[i] = ys[i-1] * x\n  end\n  ys[xs.size]\
    \ = 1 #derivative, at x = length\n  return ys\nend", "  # Return derivative of\
    \ polynomial xs.\n  x = y = 0\n  d = 0\n  for i in xs\n    d += i * x\n    y +=\
    \ 1\n  end\n  return d\nend", "  # Compute coefficient of x^0\n  dec0 = 0\n  #\
    \ Compute coefficient of x^1\n  dec1 = 0\n  # Compute coefficient of x^2\n  dec2\
    \ = 0\n  # Compute coefficient of x^3\n  dec3 = 0\n  # ...\n  # Compute coefficient\
    \ of x^n\n  decn = xs[0]\n  # Compute partial derivatives of x^0\n  decd0 = xs[0]\n\
    \  # Compute partial derivatives of x^1\n  decd1 = xs[1]\n  # Compute partial\
    \ derivatives of x^2\n  decd2 = xs[2]\n  # Compute partial derivatives of x^3\n\
    \  decd3 = xs[3]\n  # ...\n  # Compute partial derivatives of x^n\n  decdn = xs[n-1]\n\
    \  # Compute total derivatives of polynomial and return\n  return [\n    dec0,\
    \ decd0, decd1, decd2, decd3, decd, decdn, dec(n-1)\n  ]\nend\n</code>\nLet's\
    \ try it out on a few examples:\n<code>", "  x = 1\n  derivative_array = []\n\
    \  derivative_array.push(xs[0])\n  for i in 1...xs.length\n    derivative_array.push(xs[i]\
    \ * x)\n    x = x * i\n  end\n  derivative_array\nend", "    one = ones(1, 1)\n\
    \    two = ones(1, 1)\n    zero = ones(1, 1)", "  return [ xs[2] - xs[1], xs[1]\
    \ - xs[0], xs[0] ]\nend", "  # TODO: Write implementation\n  raise NotImplementedError\n\
    end", "  der = 0.0\n  for i in 0..(length(xs) - 1)\n    der += xs[i] * Math.pow(i,\
    \ 2)\n  end\n  return der\nend", "  dxs = Array.new(xs.length)\n  dxs[0] = 1\n\
    \  for i in 1..xs.length\n    dxs[i] = dxs[i-1] * xs[i-1]\n  end\n  dxs\nend",
  "  derivative_coefficients = []\n  xs = Array.new(xs) # Re-use xs array.\n  xs.map!\
    \ do |x|\n    derivative_coefficients << (x.to_f / (1 + x.to_f))\n  end\n  Derivative.new(derivative_coefficients)\n\
    end", "  deriv = xs.clone\n  deriv.each_index { |i| deriv[i] -= xs[i] * deriv[i]\
    \ }\n  deriv\nend", "    deriv = [@(x) -> x]\n    deriv.push deriv[0]\n    deriv.push\
    \ deriv[1]\n    for i in 2...@xs.length\n        deriv.push (@(xs[i]) * *(@deriv)[i])\n\
    \    end\n    return deriv\nend", "  # Code here to calculate derivative.\n  derivative\n\
    end\n</cell>\n<text>\nCalculate gradient\nTo calculate gradient, we need Jacobian\
    \ matrix of the cost function and vector of parameters $x$. We can calculate them\
    \ using calculate_gradient(xs, ys)", "  # TODO: use rand to generate coefficients\
    \ for a polynomial\n  # of degree m\n  raise NotImplementedError\nend", "  return\
    \ xs.reverse.inject(:+) * Poly(xs.reverse, :+) \nend", "  # TODO: Finish this\
    \ function!\n  raise NotImplementedError()\nend\n</cell>\n<code language=julia-0.4>\n\
    derivative([1., 2., 3.])\n</cell>\n<code language=julia-0.4>\nderivative([1.,\
    \ 2., 3., 4., 5.])\n</cell>\n<text>\nExercise\nWrite a function to find the derivatives\
    \ of a polynomial. Your function should take a list of numbers as its argument\
    \ and return a list of the same length. Your function should use a loop to evaluate\
    \ the polynomial at each point and save the result in a list. Your function should\
    \ then return the new list. Try evaluating the polynomial at 0 and 1 for the derivative\
    \ of polynomial. Try evaluating the polynomial at 0, 1 and 2. The function should\
    \ use the following formula: $x^n + x^{n-1} + x^{n-2} + ... + x + 1$. Make sure\
    \ the order of the polynomial is 1 less than the length of the input list.", " \
    \ derivative = [0] * xs.size\n  derivative[0] = 1 \n  for i in 1..xs.size\n  \
    \  derivative[i] = derivative[i-1]*xs[i-1]\n  end\n  derivative\nend", "  x =\
    \ 0.0\n  for i in 1..size(xs)\n    x += (i - 1) * xs[i]\n  end\n  x\nend", " \
    \ return [xs[1]] * xs.length\nend", "  return [derivative(xs[i-1]) if xs[i-1]\
    \ != 0 else\n          (xs[i-1] / x) if i == 0 else 0 for\n           i in [1..(xs.size-1)]]\
    \ #xs[0] is the value of a polynomial\nend", "  result = 1.0\n  x.times do |i|\n\
    \    result = result * xs[i] / x\n  end\n  result\nend\n</cell>\n<cell>", "  derivative\
    \ = []\n  \n  # calculate partial derivatives in reverse order\n  derivative.push(xs[2])\n\
    \  derivative.push(xs[1])\n  derivative.push(xs[0]) \n  \n  return derivative\n\
    end", "  x = xs[0]\n  derivatives = []\n  derivatives.push x if xs.count > 1\n\
    \  for x in xs\n    derivatives.push x * x\n  end\n  derivatives.push -1\n  derivatives\n\
    end", "    # Add all terms except last one and multiply by xs.\n    ans = 0\n\
    \    for i in 0..(xs.size-1)\n        ans = ans + xs[i] * (i+1)\n    end\n   \
    \ return ans\nend", "    xs.map { |x| Derivative.new(x) }\nend", '  result = @(@(@(@(xs[0]),
    x), x)) * (@(@(@(xs[1]), x))) * (@(@(@(xs[2]), x))) * (@(@(@(xs[3]), x))) * (@(@(@(xs[4]),
    x))) * (@(@(@(xs[5]), x))) * (@(@(@(xs[6]), x))) * (@(@(@(xs[7]), x))) * (@(@(@(xs[8]),
    x))) * (@(@(@(xs[9]), x))) * (@(@(@(xs[10]), x))) * (@(@(@(xs[11]), x))) * (@(@(@(xs[12]),
    x))) * (@(@(@(xs[13]), x))) * (@(@(@(xs[14]), x))) * (@(@(@(xs[15]), x))) * (@(@(@(xs[16]),
    x))) * (@(@(@(xs[17]), x))) * (@(@(@(xs[18]), x))) * (@(@(@(xs[19]), x))) * (@(@(@(xs[20]),
    x))) * (@(@(@(xs[21]), x))) * (@(@(@(xs[22]), x))) * (@(@(@(xs[23]), x))) * (@(@(@(xs[24]),
    x))) * (@(@(@(xs[25]), x))) * (@(@(@(xs[26]), x))) * (@(@(@(xs[27]), x))) * (@(@(@(xs[28]),
    x))) * (@(@(@(xs[29]), x))) * (@(@(@(xs[30]), x))) * (@(@(@(xs[31]), x))) * (@(@(@(xs[32]),
    x))) * (@(@(@(xs[33]), x))) * (@(@(@(xs[34]), x))) * (@(@(@(xs[35]), x))) * (@(@(@(xs[36]),
    x))) * (@(@(@(xs[37]), x))) * (@(@(@(xs[38]), x))) * (@(@(@(xs[39]), x))) * (@(@(@(xs[40]),
    x))) * (@(@(@(xs[41]), x))) * (@(@(@(xs[42]), x))) * (@(@(@(xs[43]), x))) * (@(@(@(xs[44]),
    x))) * (@(@(@(xs[45]), x))) * (', "  x_1 = xs\n  x_2 = xs\n  x_3 = xs\n  x_4 =\
    \ xs\n  x_5 = xs\n  x_6 = xs\n  x_7 = xs\n  x_8 = xs", "  xs = Array.new(xs.length\
    \ - 1)\n  # TODO: Use this once it's in place\n  # (xs[1]-(xs[1]*xs[0]))/xs[0]\
    \ xs[0]\n  xs[1] = -(xs[1]*xs[0])\n  xs[2] = -(xs[1]*xs[0]*xs[0])\n  xs[3] = -(xs[1]*xs[0]*xs[0]*xs[0])\n\
    \  xs[4] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0])\n  xs[5] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[6] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n  xs[7] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[8] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n  xs[9] =\
    \ -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n  xs[10] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[11] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[12] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[13] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[14] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[15] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[16] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[17] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[18] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0])\n\
    \  xs[19] = -(xs[1]*xs[0]*xs[0]*xs[0]*xs[0]*xs[0]", "  return [xs[1]*x, xs[3],\
    \ xs[6]]\nend\n</cell>\n<code language=julia-1.5>\nderivative([1,2,3])\n</cell>\n\
    <text>\nProblem 3: Solve Equations\nWrite a function solve that takes a matrix\
    \ equation as an argument and returns the solution as a 1x3 matrix.\nThe input\
    \ matrix equation should be a 2 by 3 matrix where each element in the matrix\n\
    is a linear algebra equation. The output matrix will consist of a 3 by 1 matrix\
    \ which\nis the solution of that equation.", "  return xs.inject(:+) * xs.map\
    \ {|x| x * x}\nend", "  x = @(xs) xs[1]\n  xs = [xs[0]]\n  for i in 1..length(xs)\n\
    \    x =  xs[i] * x\n    xs << x\n  end\n  return xs\nend", "  if xs.length ==\
    \ 1\n    puts xs[0]\n  else\n    puts \"(\" + xs[0] + xs[1] * x + xs[2] * x^2\
    \ + xs[3] * x^3 + ... + xs[50] * x^50 + xs[51] * x^51 + xs[52] * x^52)\n  end\n\
    end", "  derivative = ( xs[0] - xs[1] * (xs[2] + xs[3] * xs[4])) / xs[4]\n  return\
    \ derivative\nend", "  derivatives = []\n  xs.each_with_index do |x, i|\n    derivative\
    \ = xs.size - i - 1\n    derivatives << derivative\n  end\n  derivatives\nend",
  "  # Initialize a derivative array to same size as xs.\n  derivative = Array.new(xs.size)\
    \ do\n    # Initialize a temporary array to store the current value of the polynomial\n\
    \    # multiplied by each element of xs.\n    temp = Array.new(xs.size) do\n \
    \     0.upto(xs.size-1) do |i|\n        # Initialize a temporary variable in range\
    \ -1 to 1.\n        temp = temp + (xs[i] * -1)\n      end\n      # Return this\
    \ temporary array.\n      temp\n    end\n    # Return this temporary array.\n\
    \    temp\n  end\n  # Return the derivative array.\n  derivative\nend\n</code>\n\
    <|/ a |>\n<| c |>\n+1 nice answer. One thing I noticed though is that it's unnecessary\
    \ to initialize `temp` as an array, just to loop over it to calculate the sum.\
    \ In my experience Ruby will work just fine with just `0.upto(xs.size-1) do |i|\
    \ temp = temp + (xs[i] * -1) end`. I know I've seen it done that way, but I haven't\
    \ seen it done in the other answer where we start with `Array.new(xs.size)`.\n\
    <|/ c |>\n<| c |>\nAs a side note, `Array.new(n)` creates a new array with length\
    \ `n`, i.e. `[1, 2, 3]` for `n = 3`, which is not ideal. `Array.new(xs.size)`\
    \ creates a new array with length `(xs.size) - 1`, i.e. `[1, 2, 3, 4]` for `xs\
    \ = [1, 2, 3]`. For arrays of length `5`, it is almost always better to use the\
    \ built-in `Array.new` because it's faster: `Array(5)`.\n<|/ c |>\n<| a tags=math,ruby\
    \ |>\n<code>", "  if xs.length == 1\n    [ 0 ]\n  else\n    dp = (xs[2] - xs[1])\
    \ / (xs[0] - xs[1])\n    [ dp * x, dp * x^2, dp * x^3, dp * x^4, dp * x^5, dp\
    \ * x^6, dp * x^7, dp * x^8, dp * x^9 ]\n  end\nend\n</cell>\n<cell>\nderivative([0.3,\
    \ 1.0, 2.0])\n</cell>\n<text>\nExercise", "  return [0 for i in xs] + (xs[0] +\
    \ xs[1] * derivative(xs[2..-1]))\nend", "  deriv = [0] * xs.length\n  deriv[0]\
    \ = xs[1]\n  deriv[1] = xs[2]\n  deriv[2] = xs[3]\n  deriv[3] = xs[4]\n  deriv[4]\
    \ = xs[5]\n  deriv[5] = xs[6]\n  return deriv\nend", "  xs, xs_count = xs\n  xs_count\
    \ = Integer(xs_count)\n  if xs_count == 0\n    return [0]\n  x = 1\n  for i in\
    \ xs[1..-1]\n    x <<= 1\n    x |= i\n  end\n  return [xs, x]\nend", "  xs.each\
    \ do |x|\n    xs.shift\n  end\n  \n  power = xs.length - 1\n  \n  if xs.length\
    \ == 1\n    xs[0]\n  elsif xs.length == 2\n    xs[1] * xs[0]\n  else\n    (xs[power]\
    \ * xs[power - 1]) * (xs[power] * xs[power - 2])\n  end\nend", "  x = xs[0]\n\
    \  xd = xs[1]\n  return [(xd * x) ** 2]\nend\n</cell>\n<code language=julia-1.1>\n\
    derivative([1.0, 2.0, 3.0])\n</cell>\n<text>\n3.1.2 Back Substitution\nBack substitution\
    \ can be performed in polynomial expressions such as the one in Equation 3.1 above.",
  "\tdx = zeros(3, 1);\n\tdx[2] = 1;\n\tfor i in 2:length(xs)\n\t\tdx[i] = (xs[i]\
    \ - xs[i - 1]) / dx[i - 1];\n\tend\n\treturn dx;\nend", "  num_terms = xs.length\
    \ - 1\n  if num_terms == 0\n    0.0\n  else\n    num_terms.times do |i|\n    \
    \  d = 0.0\n      num_terms.times do |j|\n        d += xs[j + 1] * xs[j]\n   \
    \   end\n      xs[i + 1] = xs[i + 1] - d\n    end\n    1.0\n  end\nend", "  return\
    \ [xs[1] - xs[0]]\nend\n</cell>\n<code language=julia-1.6>\nderivative([1.5, -2,\
    \ 3])\n</cell>\n<code language=julia-1.6>\nderivative([1.2, -2.1, 3])\n</cell>\n\
    <code language=julia-1.6>", "  val = 0\n  x.times do\n    val = val + xs[i]\n\
    \  end\n  val\nend", "  dx = 0.0\n  dx_squared = 0.0\n  n = xs.length\n  for i\
    \ in 0...n\n    dx_squared = i * xs[i]\n    dx += dx_squared \n  end\n  return\
    \ dx\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nAside from the unnecessary\
    \ `sqrt` call, you might also want to revisit your code. `dx ^= xs[i]` is equivalent\
    \ to `dx = dx * xs[i]` which is not the same as `dx = dx_squared + i * dx`. Also,\
    \ if you do `return dx` inside `for ... end`, you will not get what you expect\
    \ if `dx` is `0.0`.\n<|/ c |>\n<| c |>\n, thank you for pointing that out. I've\
    \ corrected the code. About the `sqrt`: I don't remember why I did it that way.\
    \ I guess it came in handy when I was just learning Ruby.\n<|/ c |>\n<| c |>\n\
    Thank you for the help. I ended up using a different method but will try to remember\
    \ to upvote your answer when I can.\n<|/ c |>\n<| a |>\nThe other answers are\
    \ more succinct and cleaner but here is an example of how you could do it using\
    \ recursion:\n<code>", "  dx = 0.0\n  dx = dx * xs[0]\n  dx = dx + derivative(xs[1..-1])\
    \ if xs.length >  1\n  return dx\nend", "  deriv = [xs[1]]\n  for i in xs[2..-1]\n\
    \    deriv.push(xs[i] * deriv[deriv.length - 1])\n  end\n  return deriv\nend",
  "  return polyval(xs, derivative_coeffs(xs))\nend", "  if xs == []\n    []\n  else\n\
    \    # Calculate first derivative\n    # Return derivative if first derivative\
    \ is zero.\n    deriv_first_term = xs[1]\n    deriv_second_term = derivative(xs[2])\n\
    \    deriv_third_term = derivative(xs[3])\n    if deriv_first_term == 0\n    \
    \  deriv_first_term = deriv_second_term\n      deriv_second_term = deriv_third_term\n\
    \      deriv_third_term = 0\n    deriv_first_term *= -1\n    deriv_second_term\
    \ *= -1\n    deriv_third_term *= -1\n    return [deriv_first_term,deriv_second_term,deriv_third_term]\n\
    \  end\nend", "  result = [1]\n  for x in xs\n    result = result * x\n  end\n\
    \  return result\nend", "  derivative = 0\n  x = 1\n  while x > -1000\n    derivative\
    \ = derivative + xs[(x - 1) % len(xs)]\n    x = x * xs[(x - 1) % len(xs)]\n  end\n\
    \  return derivative\nend\n</cell>\n<code language=julia-1.5>\nderivative([2,-1,4])\n\
    </cell>\n<code language=julia-1.5>", "  deriv = 0\n  xs.each_with_index { |x,\
    \ i| deriv += x * (i+1) }\n  deriv\nend", "  result = 1\n  i = 2\n  while i <\
    \ xs.length\n    result = result * xs[i]\n    i += 1\n  end\n  result\nend", " \
    \ xs = Array.new(xs.length)\n  xs[0] = 1\n  xs[1] = xs[0]\n  xs[2] = xs[1] * x\n\
    \  xs.length\nend", "    derivative = 0\n    derivative = xs[1]\n    derivative\
    \ *= x\n    derivative += xs[2]\n    derivative *= x**2\n    derivative += xs[3]\n\
    \    derivative *= x**3\n    derivative += xs[4]\n    derivative *= x**4\n   \
    \ derivative += xs[5]\n    derivative *= x**5\n    derivative += xs[6]\n    derivative\
    \ *= x**6\n    derivative += xs[7]\n    derivative *= x**7\n    derivative +=\
    \ xs[8]\n    derivative *= x**8\n    derivative += xs[9]\n    derivative *= x**9\n\
    \    derivative += xs[10]\n    derivative *= x**10\n    derivative += xs[11]\n\
    \    derivative *= x**11\n    derivative += xs[12]\n    derivative *= x**12\n\
    \    derivative += xs[13]\n    derivative *= x**13\n    derivative += xs[14]\n\
    \    derivative *= x**14\n    derivative += xs[15]\n    derivative *= x**15\n\
    \    derivative += xs[16]\n    derivative *= x**16\n    derivative += xs[17]\n\
    \    derivative *= x**17\n    derivative += xs[18]\n    derivative *= x**18\n\
    \    derivative += xs[19]\n    derivative *= x**19\n    derivative += xs[20]\n\
    \    derivative *= x**20\n    derivative += xs[21]\n    derivative *= x**21\n\
    \    derivative += xs[22]\n    derivative *= x**22\n    derivative += xs[23]\n\
    \    derivative *= x**23\n    derivative += xs[24]\n    derivative *= x**24\n\
    \    derivative += xs[25]\n    derivative *= x**25\n    derivative += xs[26]\n\
    \    derivative *= x**26\n    derivative += xs[27]\n    derivative *= x**27\n\
    \    derivative += xs[28]\n    derivative *= x**28\n    derivative += xs[29]\n\
    \    derivative *= x**29\n    derivative += xs[30]\n    derivative *= x**30\n\
    \    derivative += xs[31]\n    derivative *= x**31\n    derivative += xs[32]\n\
    \    derivative *= x**32\n    derivative += xs[33]\n    derivative *= x**33\n\
    \    derivative += xs[34]\n    derivative *= x**34\n    derivative += xs[35]\n\
    \    derivative *= x**35\n    derivative += xs[36]\n    derivative *= x**36\n\
    \    derivative += xs[37]\n    derivative *= x**37\n    derivative += xs[38]",
  "  deriv = xs[1]\n  deriv = deriv * x * x\n  deriv = deriv + xs[0]\n  return deriv\n\
    end", "  if xs.length == 1\n    xs[0]\n  else\n    xs[0] * derivative(xs[1..-1])\n\
    \  end\nend\n</cell>\n<text>\nThis function is called by the code we just saw\
    \ to evaluate the polynomial at any point $x$.", "  derivative_of_1stx = 0\n \
    \ derivative_of_2ndx = 0\n  \n  derivative_of_1stx = x[1]\n  derivative_of_2ndx\
    \ = x[2]\n  \n  return [derivative_of_1stx, derivative_of_2ndx]\nend", "    term\
    \ = xs[1]\n    x = xs[0]\n    derivative = [term]\n    for i = 3..(xs.length)\n\
    \        term = term / xs[i]\n        derivative << term\n    end\n    derivative\n\
    end\n</code>\n<|/ a tags=ruby,polynomials |>\n<| a tags=ruby,polynomials dscore=2\
    \ |>\nHere is a recursive implementation in Ruby:\n<code>", "  x = 1\n  for i\
    \ in 0..xs.size\n    x += xs[i]\n  end\n  x\nend", "    return eval(coeffs(xs))\n\
    end", "  deriv = []\n  i = 0\n  while i < xs.length\n    deriv << xs[i]\n    i\
    \ += 1\n  end\n  deriv\nend", "  d = 0\n  1.upto(length(xs)-1) do |i|\n    d +=\
    \ xs[i] * xs[i]\n  end\n  return d\nend", "  return [(xs[1] - xs[0]) * (xs[2]\
    \ - xs[0] * xs[1])] + ([xs[0]**2 - xs[0] * xs[2]] if (xs[0]**2 - xs[0] * xs[2]\
    \ != 0) else [])\nend", "  product = x * x\n  product.each{ |x| return product\
    \ if x!=0 }\n  return 1\nend\n</code>\nThe function derivative(xs) does exactly\
    \ what you want for the case where x is a constant (in your case it returns 1)\n\
    A more general solution can be achieved by doing:\n<code>", "    x1 = xs[0]\n\
    \    x2 = xs[1]\n    d = x2 * x1 * xs[0]\n    for x in xs[0..-2] # xs must have\
    \ at least 2 coefficients\n      d += x2 * x * xs[1]\n    end\n    d\nend", " \
    \ xs, length = xs.size, 0\n  xs.each_with_index { |x, i|\n    length += 1 if x\n\
    \    xs[i] = xs[i - 1] * (i - 1)\n    xs[i] -= xs[i - 1]\n  }\n  xs[length] +=\
    \ 1 if xs[length]\n  xs\nend\n</code>\n<|/ a dscore=2 tags=ruby,polynomial-math,math\
    \ |>\n<| c |>\nCan you elaborate on your use of `each_index` vs. `each_with_index`?\
    \ I understand they accomplish the same thing (in this case), but I wonder which\
    \ one performs better.\n<|/ c |>\n<| c |>\n: In Ruby 1.8, `each_with_index` would\
    \ be equivalent to `each_index{|x| ; }`.\n<|/ c |>\n<| c |>\nThat being said,\
    \ I prefer `each_index{|x| ; }` because I don't like having to `return` a value\
    \ in an `each` block, so it's more idiomatic to express this using a `do` block.\n\
    <|/ c |>\n<| c |>\nThanks for the elaboration. I just wanted to make sure I wasn't\
    \ missing something.\n<|/ c |>\n<| c |>\n: I was thinking you were referring to\
    \ the use of `each_index{|x| ; }`, but was surprised when looking at my answer.\
    \ I'd missed that `each_with_index` was an alias of `each_index`.\n<|/ c |>\n\
    <| a tags=ruby,polynomial-math,math |>\nHere is a simple implementation that does\
    \ not use recursion (it uses iteration instead), and only uses mathematical operations:\n\
    <code>", "  result = 0\n  for i in 0...xs.length\n    result *= i\n    result\
    \ += xs[i]\n  end\n  result\nend", "  result = []\n  \n  for x in range(1, xs.length\
    \ - 1)\n    result = result.concat(Array(xs.length - x).fill(0))\n    result =\
    \ result.concat([x])\n  end", "  x = xs[0]\n  ys = []\n  \n  for i in 0..@n -\
    \ 1\n    term = xs[i]\n    ys.push term * x \n    x = term\n  end\n  \n  return\
    \ ys\nend", "  val = 0\n  val += xs[1]\n  val += xs[2] * x\n  val += xs[3] * x^2\
    \ \n  val += xs[4] * x^3\n  val += xs[5] * x^4\n  val += xs[6] * x^5\n  val +=\
    \ xs[7] * x^6\n  val += xs[8] * x^7\n  val += xs[9] * x^8\n  val += xs[10] * x^9\n\
    \  val += xs[11] * x^10\n  val += xs[12] * x^11\n  val += xs[13] * x^12\n  val\
    \ += xs[14] * x^13\n  val += xs[15] * x^14\n  val += xs[16] * x^15\n  val += xs[17]\
    \ * x^16\n  val += xs[18] * x^17\n  val += xs[19] * x^18\n  val += xs[20] * x^19\n\
    \  val += xs[21] * x^20\n  val += xs[22] * x^21\n  val += xs[23] * x^22\n  val\
    \ += xs[24] * x^23\n  val += xs[25] * x^24\n  val += xs[26] * x^25\n  val += xs[27]\
    \ * x^26\n  val += xs[28] * x^27\n  val += xs[29] * x^28\n  val += xs[30] * x^29\n\
    \  val += xs[31] * x^30\n  val += xs[32] * x^31\n  val += xs[33] * x^32\n  val\
    \ += xs[34] * x^33\n  val += xs[35] * x^34\n  val += xs[36] * x^35\n  val += xs[37]\
    \ * x^36\n  val += xs[38] * x^37\n  val += xs[39] * x^38\n  val += xs[40] * x^39\n\
    \  val += xs[41] * x^40\n  val += xs[42] * x^41\n  val += xs[43] * x^42\n  val\
    \ += xs[44] * x^43\n  val += xs[45] * x^44\n  val += xs[46] * x^45\n  val += xs[47]\
    \ * ", "  xs, degree = xs.clone, x.length\n  xs, remainder = xs.divmod(1)\n  remainder,\
    \ quotient = remainder.divmod(1)\n  return if remainder\n    [ xs[degree] * quotient,\
    \ xs[degree] - 1, 1 ]\n  else\n    [ remainder, xs[degree] * quotient, 1 ]\nend",
  "  deriv = [0.0]\n  deriv[0] = xs[1]\n  deriv[1] = xs[1]*xs[0]\n  deriv[2] = xs[1]*xs[0]*xs[0]\n\
    \  deriv[3] = 0\n  return deriv\nend", "  deriv = [0.0]\n  i = 0\n  while i <\
    \ xs.length - 1\n    deriv.append(xs[i + 1] - xs[i])\n    i += 1\n  end\n  deriv\n\
    end", "  # use Lagrange polynomials, https://en.wikipedia.org/wiki/Lagrange_polynomial\n\
    \  return [\n    xs[1] + xs[0] * xs[-1],\n    xs[-1] + xs[-2] * xs[-1],\n  ]\n\
    end\n</cell>\n<code language=julia-1.5>\nderivative(coef(g))\n</cell>\n<text>\n\
    3. Solving a polynomial\nWe want to solve a polynomial equation, $x^2 + 2x + 1\
    \ = 0$, we will solve by using the quadratic formula, $ax^2 + bx + c = 0$, $x\
    \ = 0$, and $a = -1$, $b = 1$, and $c = -1$.", "  if xs.empty?\n    []\n  else\n\
    \    terms = []\n    xs.each do |x|\n      terms << x * derivative(terms)\n  \
    \  end\n    terms\n  end\nend", "  if xs.length == 1\n    1.0\n  else\n    xs.length\
    \ - 1.to_f / xs[0].to_f\n  end\nend", "  raise NotImplementedError\nend", "  xs\
    \ = Array.new(xs, 0)\n  deriv = 0\n  xs.each { |x| deriv += x * (x.to_i) ** 2}\n\
    \  return deriv\nend", "  xs.length <= 3\n  x = xs[0]\n  ys = xs[1..-1]\n  ys.map!{\
    \ |y| y * x }\n  y = ys[0]\n  ys.length <= 1 ? y : x * y\nend", "  if xs.empty?\n\
    \    0\n  else\n    2.0*xs[0] + xs[1] + xs[2] - 2*xs.sum\n  end\nend", "  xs =\
    \ Array.new(xs.length)\n  # Return first derivative of our polynomial if xs.length\
    \ > 0.\n  return xs.length ? (xs[-1] - xs[-2]) / xs[-3] * xs : nil\nend", "  dx\
    \ = []\n  for i in [0...xs.length]\n    dx << xs[i]\n    dx += xs[i] * derivative([i-1,\
    \ i-2])\n  end\n  return dx\nend", "  derivative = [xs[0]]\n  xs.slice!(1..-1).each\
    \ do |x|\n    derivative << xs[0] * x + xs[1]\n  end\n  derivative\nend", "  x\
    \ = @zeros(1,xs.size)\n  x[0] = xs[1]\n  y = x\n  for i in 1..(xs.size)\n    x[i]\
    \ = xs[i-1]*x + xs[i]\n    y = y^2 * x\n  end\n  return y\nend\n</cell>\n<code\
    \ language=julia-0.6>\nderivative([2,3,4])\n</cell>\n<text>\nThis allows us to\
    \ evaluate the derivative at any point and get the gradient vector of the polynomial.",
  "  if xs.length == 0\n    []\n  else\n    [xs[1] - xs[0] * xs[2] - xs[0] * xs[2]\
    \ * xs[3], xs[0]]\nend", "  # xs[0] + xs[1] * x + xs[2] * x^2 + ....\n  # Return\
    \ derivative of this polynomial in the same form.\n  return [ (xs[0] - xs[1])\
    \ * x, (xs[0] - xs[1]) * x ** 2, (xs[0] - xs[1]) * x ** 3, (xs[0] - xs[1]) * x\
    \ ** 4, (xs[0] - xs[1]) * x ** 5, (xs[0] - xs[1]) * x ** 6, (xs[0] - xs[1]) *\
    \ x ** 7, (xs[0] - xs[1]) * x ** 8, (xs[0] - xs[1]) * x ** 9, (xs[0] - xs[1])\
    \ * x ** 10]\nend\n</cell>\n<code language=julia-1.5>", "  return [xs[0]] * len(xs)\n\
    end", "  # Implement here.\n  derivative = Array.new(length(xs)) do\n    0.0\n\
    \  end\nend", "  x = xs[0]\n  y = xs[1]\n  return x * y + x * x * y + x\nend",
  "  return [1 if x==0 else 0 for x in range(1,length(xs))]\nend", "    deriv = [0.0]*xs.size\
    \ - 1\n    xs.each_index do |i|\n      deriv[i] = (xs[i] - deriv[i-1]) / (xs[i]\
    \ - xs[i-1])\n    end\n    return deriv\n  end", "\tderivative = []\n\tderivative_coef\
    \ = nil\n\t\n\tif xs.length == 0\n\t\traise ArgumentError, \"Wrong number of arguments\
    \ for derivative\"\n\tend\n\t\n\txs.each_with_index do |x,i|\n\t\tderivative_coef\
    \ = x * x * x\n\t\tderivative << derivative_coef\n\tend\n\t\n\treturn derivative\n\
    end", "  # Return empty array if no coefficients given.\n  return [0,0,0] if xs.length\
    \ < 3 then return [] else xs[2] / xs[1] - xs[0] / xs[1]", "  # Return the derivative\
    \ of our polynomial in terms of our coefficients\n  product = 1.0;\n  x = 0.0;\n\
    \  for i in 0...xs.length\n    product *= i;\n    x += xs[i]\n  end\n  return\
    \ product\nend", "    grad = [xs[1] / xs[0]]\n    grad[1] = grad[1] - (xs[0] *\
    \ grad[0]) / xs[1]\n    grad\nend\n</cell>\n<code language=julia-1.3>", "  \n\
    \  # Return 0 when xs is an empty list.\n  return 0 if xs == [] ", "  return (0..x).map\
    \ {|i| xs[i] * (xs[i+1] - xs[i])}\nend", "  # Initialize with 0\n  d = 0\n  \n\
    \  # Calculate derivative\n  d = 1 \n  \n  # Check number of variables\n  if xs.count\
    \ != 0\n    \n    # Multiply x by last coefficient\n    d *= xs[-1]\n    \n  \
    \  # Loop through remaining variables and multiply by the last\n    # coefficient\
    \ times x\n    for i = xs.length - 1\n      d *= xs[i-1]\n    end\n  end\n  \n\
    \  return d\nend\n</cell>\n<cell>\nderivative([1,2,3])\n</cell>\n<text>\nExercise\
    \ 4: Calculate the derivative of a polynomial using the previous function. How\
    \ would you implement the gradient function in the cell below?", "  return [xs[1]\
    \ + xs[0] * x]\nend", "  # Return derivative of xs (list containing polynomial\
    \ coefficients)\n  if xs.size == 1\n    xs[1]\n  else\n    # Start with a zero\
    \ polynomial\n    d = [0]*(xs.size-1)\n    d[1] = xs[1]\n    # Calculate xs[0]\
    \ + xs[1] * x + xs[2] * x^2 + ...\n    for i in 2..(xs.size-1)\n      d[i] = (d[i-1]*xs[i-1])\
    \ + xs[i]\n    end\n    # Return the polygon formed by adding the last element\
    \ to d\n    d\n  end\nend\n</code>\n<|/ a tags=ruby,linear-algebra,ruby-on-rails-3,math,algorithm\
    \ dscore=2 |>\n<| c |>\nI tested the code with various sizes and it worked quite\
    \ nicely.  It took me a while to figure out what was going on, but it was really\
    \ clever, and I learned a lot about how things work under the hood.  Thanks a\
    \ bunch!\n<|/ c |>\n<| c |>\nThis is exactly the way I imagined it. I was so focused\
    \ on doing it with recursion that I forgot about the iterative approach.\n<|/\
    \ c |>\n<| c |>\nHm, I just realized that the Ruby implementation is not quite\
    \ the same as the Python one.  Ruby doesn't include square roots and does not\
    \ include a square root.  I'm still not sure how to fix this problem in Ruby,\
    \ but I'll probably have to figure it out later.\n<|/ c |>\n<| c |>\nI noticed\
    \ that the Ruby code doesn't actually return a quadratic polynomial.  It returns\
    \ a cubic polynomial.  Could this be fixed by just replacing the line `d[i] =\
    \ (d[i-1]*xs[i-1]) + xs[i]` with `d[i] = (d[i-1]*xs[i-1]) + xs[i] + d[i+1]`?\n\
    <|/ c |>\n<| c |>\n: Yes, but this approach doesn't require you to calculate any\
    \ of those coefficients. It's simply an iterative solution using recursion. Cubic\
    \ polynomials are a special case of quadratic polynomials. Cubic polynomials are\
    \ the same thing as quadratic polynomials except for the first and last elements\
    \ (the coefficient is always 1), but if you want the mathematical definition you\
    \ can look it up. http://en.wikipedia.org/wiki/Quadratic_polynomial\n<|/ c |>\n\
    <| a tags=ruby,linear-algebra,ruby-on-rails-3,math,algorithm dscore=2 |>\nThis\
    \ Ruby code should do what you need. It does have a few limitations and I haven't\
    \ figured out how to fix them, but it does work for your examples.\n<code>", " \
    \ return [0 for i in range(1,len(xs)) ] + [xs[0]] * (len(xs) - 1) # Dx\nend",
  "    return [0] * (len(xs) - 1) + [1, 1] * (len(xs) - 1)\nend", "  # Return derivative\
    \ in same form as xs.\n  return [1 if xs[i] == 0 else xs[i+1] - xs[i] for i in\
    \ range(len(xs)-1)]\nend", "  d  = 1\n  xs.each_with_index { |x,i|\n    # d is\
    \ incremented by 1\n    d *= x - xs[i]\n  }\n  return d\nend", "  raise NotImplementedError\n\
    end", "  dxs = [0]\n  xs.each_with_index { |x,i| dxs << x*dxs[i+1] }\n  dxs.each_with_index\
    \ { |x,i| dxs[i] = x }\n  dxs\nend", "  return 0 if xs == [] else xs[1..-1].inject(:*)\n\
    end\n</code>\n<|/ a |>\n<| a |>\nAs the other answers note, there is an iterative\
    \ algorithm to solve this problem. The reason for this is that there are a finite\
    \ number of solutions. One of the answers shows how to find this for polynomials\
    \ of the form x^n+a*x^(n-1)+...+a. A quick implementation follows:\n<code>", " \
    \   derivate = []\n    for i in xs\n        derivate.push(i)\n        derivate.push(1)\
    \ / i\n    end\n    return derivate\nend\n</code>\n<|/ a tags=ruby,python,java,equation,math\
    \ |>\n<| c |>\nThis is an interesting solution.  Do you have a link that explains\
    \ why this is optimal?  I suspect it would be somewhat more complex to implement.\n\
    <|/ c |>\n<| c |>\nI didn't understand what you meant by \"optimal\". This works\
    \ because we only need to calculate the derivatives of the polynomials up to the\
    \ first degree of the polynomial. For the general case of polynomials with a general\
    \ number of terms, you should be able to take this approach and implement it for\
    \ any number of terms.\n<|/ c |>\n<| c |>\nI'm sorry, I didn't make it clear enough.\
    \  I meant \"simple\" and as efficient as possible.\n<|/ c |>\n<| c |>\nThis is\
    \ called `Leibniz form` which is used in `Mathematica` to calculate derivatives.\
    \ And it is more or less easy to calculate derivatives up till `n` terms. If you\
    \ need more details, you can check out the [Leibniz Form](https://en.wikipedia.org/wiki/Leibniz_form)\
    \ and [Introduction to Derivatives](https://en.wikipedia.org/wiki/Derivative).\
    \ They are mathematics research articles I came across.\n<|/ c |>\n<| c |>\nThank\
    \ you for the links!  I was a bit curious how the algorithm worked.  I didn't\
    \ know about the \"Leibniz form\" before.\n<|/ c |>\n<| a tags=ruby,python,java,equation,math\
    \ |>\nI know this thread is rather old but i recently stumbled upon it whilst\
    \ trying to solve a related problem. As far as i can tell, this is the most efficient\
    \ solution proposed by and that has proven to be the most efficient solution proposed\
    \ in my benchmarks.\nI wrote this in python but i think it should be easy to convert\
    \ to java. \n<code>", "  # write your code here\nend\n</cell>\n<cell>\nderivative([1,2,3])\n\
    </cell>\n<text>\n1.5 Plotting the derivative\nInstructions:\nWrite a function\
    \ derivative that takes in a list of numbers and returns the derivative of polynomial\
    \ of degree 4 in that list. Plot your derivative below."]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
