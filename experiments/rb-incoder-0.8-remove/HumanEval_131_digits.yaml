name: HumanEval_131_digits
language: rb
prompt: "# Given a positive integer n, return the product of the odd digits.\n# Return\
  \ 0 if all digits are even.\n# For example:\n# >>> digits(1) \n# 1\n# >>> digits(4)\
  \ \n# 0\ndef digits(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n\
  \    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5,\
  \ candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5,\
  \ candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625,\
  \ candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"
completions: ["  return n.to_s.reverse.split('').inject(:*)\nend", "  result = 0\n\
    \  while n > 0\n    result = result + (n % 10) * (n/= 10)\n  end\n  return result\n\
    end", "  return n.to_s.chars.take_while { |c| c % 2 == 1 }.inject(:*)\nend", " \
    \ result = 1\n  n.to_s.split(\"\").each_with_index do |s, i|\n    next if s.even?\n\
    \    result *= 2\n    result += 1\n  end\n  result\nend", "  n.to_s.length.times\
    \ {|i| return 0 if i.to_i % 2 == 1}\n  n.to_s.reverse.each_char.inject(1){|a,c|\
    \ a*10 + c.to_i}\nend", "  return n if n.odd? ? n.to_s.reverse.split.reduce(:*)\
    \ : 0;\nend", "  total = 1\n  for i in 1..n\n    total = total * i % 10\n    puts\
    \ total % 10\n  end\n  puts 0 if total == 0 \n  total\nend", "  if n.odd? then\
    \ n % 2 else 0 \nend", "  n = n.to_i\n  n.zero? && return 0\n  n.odd? && (return\
    \ 0)\n  n.even? && (return 1)\n  n.odd? && n.even? && (return n.to_i*2)\n  n.odd?\
    \ && (n.times { n /= 2 } <= 1) && (return n.to_i*2)\n  n\nend", "  \n  # Use recursion\
    \ to solve this problem\n  digits = n / 10\n  multiplier = n % 10\n  digits =\
    \ digits(digits) + multiplier\n  return digits\nend", "  while n > 0\n    n.slice!(/[13579]/.match('0')\
    \ ? 1 : 0)\n    n -= 1\n  end\n  n\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    You know you can accept your own answer after a delay. Glad you did it :)\n<|/\
    \ c |>\n<| c |>\nYeah I know, I just haven't had time to try it yet\n<|/ c |>\n\
    <| a tags=ruby |>\nA simple one liner for Ruby 1.9 and above is as below:\n<code>",
  "    digits = []\n    i = n.to_s\n    until i.empty? do\n        digits.push i.last.to_i\n\
    \        i =~ /^\\d/\n    end\n    return 0 if digits.empty?\n    digits.inject\
    \ {|sum,d| sum + d}\nend", "    digits = n.to_s.split(//).map(&:to_i)\n    digits\
    \ = digits.reject { |d| d > 9 }\n    digits.product \nend\n</code>\n<|/ a |>\n\
    <| a |>\nThis is a variation on the theme of the other answers that takes into\
    \ account negative numbers.\n<code>", "    digits = 0\n    while n > 0\n     \
    \   digits = digits * 2 if n % 2 == 1 else digits\n        n /= 2\n    end\n \
    \   digits\nend", "  n%2=0 ? n%10*10+n/10 : 0\nend", "  return n.digits.reduce(:*)\n\
    end", "  if n.zero?\n    return 0\n  end\n  product = 1\n  n.each do |x|\n   \
    \ product *= (x % 10).to_i\n  end\n  product\nend", "  # write your code here\n\
    \  x = n.to_s.length\n  if n % 2 == 0\n    p =  n.to_s.chars.sort.inject(:*) *\
    \ 10\n  else\n    p = 0\n  end\n  p += n.to_s.chars.sort.join.to_i\n  return p\n\
    end", "  n.to_s.split(\"\").map { |d| d.odd? ? d.to_i + 0 : 0 }.inject(:*)\nend",
  "  sum=0\n  while n > 0\n    sum = sum + n%10\n    n = n/10\n  end\n  return 0 if\
    \ sum > 0\n  sum\nend", "  n.to_s.each_char.inject(1) { |sum, (digit)| sum * 2\
    \ + digit % 2 == 0 ? digit : 0 }\nend", "\tif n.zero?\n\t\t0\n\telse\n\t\tn.to_s.reverse.split(//).reduce(:*)\n\
    \tend\nend", "  num = n.to_s\n  d = 1\n  i = 2\n  while i <= num.length\n    if\
    \ num[i] % 2 == 1 \n      d *= num[i.to_s]\n      i += 1\n    else\n      i +=\
    \ 1\n    end\n  end\n  d\nend\n</cell>\n<code language=julia-0.6>\ndigits(45)\n\
    </cell>\n<code language=julia-0.6>\ndigits(12345)\n</cell>\n<code language=julia-0.6>\n\
    digits(42)\n</cell>\n<code language=julia-0.6>\ndigits(54321)\n</cell>\n<code\
    \ language=julia-0.6>\ndigits(123)\n</cell>\n<code language=julia-0.6>\ndigits(10)\n\
    </cell>\n<code language=julia-0.6>\ndigits(-10)\n</cell>\n<code language=julia-0.6>\n\
    digits(0)\n</cell>\n<code language=julia-0.6>\ndigits(1)\n</cell>\n<code language=julia-0.6>\n\
    digits(-1)\n</cell>\n<code language=julia-0.6>\ndigits(1.1)\n</cell>\n<code language=julia-0.6>\n\
    digits(2.9)\n</cell>\n<code language=julia-0.6>\ndigits(99)\n</cell>\n<text>\n\
    Write a function, odddigits, that computes the number of odd digits in a positive\
    \ integer n. For example, odddigits(1234) should return 3. Define odddigits using\
    \ digits, if necessary. Test your function with examples above.", "  product =\
    \ 1\n  while n > 0\n    if n % 2 == 1\n      product = product * 2\n      n /=\
    \ 2\n    else \n      n /= 2\n  end\n  return product\nend", "  return (0 * (n\
    \ + 1)) if n.odd? else n\nend", "  a=[]\n  a.push(n%10)\n  n=n/10\n  until n.zero?\n\
    \  a.push(n%10)\n  n=n/10\n  until n.zero?\n  puts a\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a tags=ruby |>\nUsing recursion:\n<code>", "  # Split n into digits \n\
    \  n.split('').each_slice(2).map(&:join).reduce(:*)\nend", "  (0..Math.sqrt(n)).to_a.map\
    \ {|i| n % i == 0 ? i : 0}.inject(:*)\nend", "  n.to_s.length\n  n.to_s.length\
    \ < 2\n  n / 10\nend", "  digits = n.to_s.chars.select { |c| c.odd? }.join ''\n\
    \  digits.empty? ? '0' : digits\nend", "  n.times do |i|\n    n %= 10\n    n +=\
    \ 1 if i%2 == 1\n  end\n  n\nend", "  if n == 0\n    return 0\n  else\n    return\
    \ n * (n - 1) * (n - 2)\nend", "\treturn 0 if n == 0 else ((n % 2) * digits(n\
    \ / 2))\nend", "  return 0 if n.zero? then 0 else n.digits(2)\nend\n</cell>\n\
    <code language=julia-1.4>\ndigits(1) \ndigits(4) \n</cell>\n<text>\nExercise:\
    \ Write a function that calculates the sum of the digits of an integer n taken\
    \ from the right.  For example, digits(42) should return 10 because 1+2+3+4+4=10.",
  "  n.to_s.split(\"\").inject(1) { |acc, digit| acc * 10 + (digit % 2 ? 1 : 0) }\n\
    end", "  if n == 0 then 0\n  else n % 10 * digits(n / 10)\nend", "\tn\n\t\n\t\
    # Base Case\n\tif n < 10\n\t\treturn n\n\t\n\t# Find the first digit (position)\
    \ where n % 2 == 0\n\ti = find(n, 2, 0)\n\t\n\t# If no such digit, return 0\n\t\
    if not i\n\t\treturn 0\n\t\n\t# The odd digits begin at i\n\toddDigits = n - i\
    \ * 2 \n\t\n\treturn digits(oddDigits)\n\t\nend", "  digits = []\n  while n\n\
    \    digits = digits[0..0] + [n % 10]\n    n /= 10\n  end\n  digits.reverse!\n\
    \  digits.inject(1, :*)\nend", "  # Initialize sum as 0\n  sum = 0\n  # For each\
    \ digit, add if odd or multiply if even\n  n.to_s.split(\"\").each_with_index\
    \ do |digit, index|\n    if (index % 2 == 0)\n      sum += digit.to_i\n    else\n\
    \      sum *= digit.to_i\n    end\n  end\n  return sum\nend", '    return n.to_s.scan(/\d/).map
    { |s| s.to_i }.product', "  d = 1\n  while n > 0\n    d *= n % 10\n    n /= 10\n\
    \  end\n  d\nend", "  product = 1\n  while n > 0\n    product *= n % 10\n    n\
    \ /= 10\n  end\n  product\nend", "  n.to_s.reverse.chars.product([0,1].include?(n))\n\
    end", "    digit = 0\n    odd_count = 0", "    num = n.to_s\n    digits = []\n\
    \    current = 1", "  digits = n.to_s.split(//).select {|d| d % 2 != 0}\n  digits.size\
    \ == 0 ? 0 : digits.reduce(:*)\nend", "    sum = n\n    div = 1\n    while n >\
    \ 0 do\n        div = div * 2\n        if n % 2 == 1 do\n            sum -= (n\
    \ % 10)\n        end\n        n = n / 10\n    end\n    return sum\nend", "  if\
    \ n.zero?\n    1.zero? ? 0.zero : 1.zero\n  else\n    n.to_s.split(//).map{|s|\
    \ s.odd? ? 0.zero : s.to_i}.inject(:*)\n  end\nend", "  \n  # Write your code\
    \ here.\n  \n  digits = []\n  while n > 0\n    if n % 2 == 0\n      digits <<\
    \ n\n      n /= 2\n    else\n      n -= 1\n  end\n  return digits.inject(:*)\n\
    end", "  return 0 if n == 0 \n  x = 1\n  while n > 0 do\n    while n % 2 == 0\
    \ do\n      x += 1\n      n /= 2\n    end\n    n -= 1\n  end\n  x\nend", "  digits\
    \ = n.to_s.split(//).map(&:to_i).reduce(:*)\n  digits == 0 ? 0 : digits(digits/2)\n\
    end", "  sum = 1\n  n.to_s.split(\"\").each do |x| \n    sum = sum * x.to_i\n\
    \  end\n  return sum % 10 == 0\nend", "  n.to_s.split(//).each_with_index do |x,\
    \ i|\n    return 0 if x % 2 == 1\n    digits(x / 2)\n  end\nend", "  product =\
    \ 1\n  while n > 0 \n    product = product * n % 10\n    n = n / 10\n  end\n \
    \ product\nend", "  digit = n.to_s.chars.map { |c| c.to_i }.join.to_i\n  (n /\
    \ digit).floor * digit\nend", "  return 0 unless n.odd?\n  \n  # Simplify this\
    \ by making n positive\n  n = n * 2 - 1", "  return n % 2 ? n * digits(n/2) :\
    \ n\nend", "\tdigit = n % 10 \n\tremainder = n / 10\n\tprint remainder, digit\n\
    \tif remainder % 2 == 1 and digit % 2 != 0: \n\t\treturn 0\n\telse:\n\t\treturn\
    \ digits(remainder)\n\t", "  sum = 0\n  while n > 0\n    sum += n % 10\n    n\
    \ /= 10\n  end\n  sum\nend", "  n.to_s.split(\"\").each_with_index.reduce(:*)\n\
    end", "  n0 = n % 100\n  n1 = n % 10 \n  n2 = n % 10 \n  n3 = n % 10\n  if n0\
    \ == 0 then\n    return n\n  elsif n1 == 0 then\n    return (n * n2)\n  elsif\
    \ n2 == 0 then\n    return (n * n3)\n  else\n    return (n * n3)\n  end\nend",
  "  return 0 if n % 2 == 1 else n * digits(n / 2)\nend", "  return n * (n+1) / 2\n\
    end", "  digits.reduce(:*)\nend", "  # Convert n to a String, and split it into\
    \ digits\n  s = n.to_s\n  d = s.chars", "    sum = n\n    while n > 0 do\n   \
    \     sum *= n % 10\n        n /= 10\n    end\n    return sum\nend", "  if n.zero?\n\
    \    0\n  else\n    (n.to_s(10).chars.map(&:odd?).reduce(:*))\n  end\nend", " \
    \ total = 0\n  while n > 0\n    total = total + (n % 10) * [2,1][n % 2 != 0]\n\
    \    n /= 10\n  total\nend", '    return 0 if n == 0 else n % 2 == 1 and n * digits(n
    / 2)', "    total = 1\n    i = 2\n    while i < n\n        if n % i == 0\n   \
    \         total = total * i\n            i += 1\n        else\n            i +=\
    \ 1\n    end\n    total\nend", "  n.to_s.split('').map{|e| e == \"0\" ? 1 : 0}\
    \ * \n    n.to_s.split('').select{|e| e == \"1\"}.inject(:*)\nend\n</cell>\n<cell>\n\
    digits(100) # => 3628800\n</cell>\n<text>\n4.9. Divide\nWrite a method called\
    \ divide that divides two numbers. The method should raise a ZeroDivisionError\
    \ when attempting to divide by zero.\nFor example:", "  n.to_s.split('').each_with_index.map\
    \ { |x,i| x.to_i*(n % 2 ? -1 : 1) }.inject(1)\nend", "  digits = n.to_s.chars.collect\
    \ {|c| c}\n  digits.delete_if {|d| d % 2 == 0}\n  if digits.length == 0 then 0\
    \ else\n    digits.inject(1) {|sum, digit| sum * 10 + digit}\n  end\nend", " \
    \ n = (n.to_s[0...].split(//)).inject(:*).to_i\n  0? ? 0 : (n % 10 * digits(n\
    \ / 10))\nend\n</cell>\n<code language=julia-1.2>", "  digits = []\n  while n\
    \ > 0\n    digits.push(n % 10)\n    n /= 10\n  end\n  return digits.reverse.inject(:*)\n\
    end", "  nstr = n.to_s\n  return nstr.split('').inject(0) do |result, digit|\n\
    \    if digit % 2 > 0\n      result * 10\n    else\n      result * -1\n    end\n\
    \  end\nend\n</code>\n(The above is not the most efficient solution.  It's just\
    \ an example of how you could do it.)\n<|/ a tags=math,ruby,python |>\n<| c |>\n\
    Awesome, I knew it had to be something like that! I'm still having trouble fully\
    \ grasping what's going on in your code though. For example, you're using inject,\
    \ but don't you need a return statement to complete the process? Also, what's\
    \ that first line doing? It's a weird language construct you haven't seen before.\n\
    <|/ c |>\n<| c |>\nYes, I believe you need an explicit return statement.  It's\
    \ not a weird construct but a method that's been around since the early days of\
    \ Ruby.  I guess it's called that because it's used like a function.  It's a good\
    \ solution, but it doesn't answer the original question.  I don't think I've seen\
    \ the original question before either, but I'll try to find it in a few hours\
    \ and get back to you.\n<|/ c |>\n<| c |>\nYeah, that definitely helps. My first\
    \ question was actually asking why you used the .split method rather than just\
    \ treating n as a string directly (and what does it do to the string when it's\
    \ converted from a number?). But I think I understand now (thank you!), but I'm\
    \ getting a strange \"NoMethodError: undefined method `*' for nil:NilClass\" error,\
    \ which means some code outside of my function is throwing an error for some reason\
    \ and I haven't been able to figure out why. Any thoughts?\n<|/ c |>\n<| c |>\n\
    Actually scratch that - it was my mistake. I had been doing a `n.to_s` somewhere\
    \ in my code, and that's why it was giving me that error. Not sure why I had that\
    \ in there though. Thank you so much for helping me out with this!\n<|/ c |>\n\
    <| c |>\nYes, I agree that `n.to_s` was the problem.  I edited my answer to address\
    \ this.  If you don't need it for your program, you should be able to get rid\
    \ of it by replacing `nstr` with `n.to_s`.\n<|/ c |>\n<| a tags=math,ruby,python\
    \ |>\nIn ruby:\n<code>", "  num = 0\n  while n > 0\n    num = num * 10 + (n %\
    \ 10)\n    n = n / 10\n  end\n  return num\nend", "  digits = Array.new\n  n.to_s.split(\"\
    \").each_with_index do |d, i|\n    if i % 2 == 1 \n      digits << d\n    end\n\
    \  end\n  digits.reduce(:*)\nend", "  digits = n.to_s.chars.each_slice(2).map\
    \ {|a,b| a * b }\n  digits.reduce(:*)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=2 |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  r = 1\n  for i in\
    \ [1..n]\n    r =  r*i\n    (r%2==0 && r%4==0) ? 0 : r\nend", "  return n.digits.inject(:*)\n\
    end", "  n.to_s.split(\"\").map { |n| n.to_i % 2 ? 1 : 0 }.reduce(:*)\nend", " \
    \ x = n.to_s.split(\"\").map {|d| d.to_i}\n  x.each_with_index.inject(0) {|result,a|\
    \ result * a}\nend", "  digits=0\n  while n>0 do\n    digits=digits*10\n    digits=digits+n\
    \ % 10 \n    n=n/10\n  end\n  return digits\nend", "  return n == 0 ? 0 : n ==\
    \ 1 ? 1 : n * digits(n - 1)\nend", "  return n.odd? ? 0 : n * digits(n.to_i-1)\n\
    end\n  ", "    digits = []\n    while n > 0\n        digit = n % 10\n        digits.append(digit)\n\
    \        n = n / 10\n    return digits.reverse\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nThe original idea is to get the first digit from the left and multiply\
    \ it with the rest of the number.\n<code>\n def digits(n)\n   return ((n-1).to_s+\"\
    0\")[-1,1].to_i\n end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a tags=ruby dscore=0\
    \ |>\nFor this specific case, you can convert the number to a string, get the\
    \ first character and convert to integer, then multiply by the rest of the number:\n\
    <code>", "    digits = n.to_s.split('')\n    digits.reverse\n    digits.inject(:*)\n\
    \  end", "  digits = n.to_s.split('').map(&:to_i)\n  evens = digits.select { |d|\
    \ d % 2 == 0 }\n  odd_ones = digits.select { |d| d % 2 != 0 }\n  evens.inject(0)\
    \ { |sum, d| sum * d } * odd_ones.inject(0) { |sum, d| sum * d }\nend\n</cell>\n\
    <cell>\ndigits(12345)\n</cell>\n<cell>\ndigits(13)\n</cell>\n<cell>\ndigits(1234)\n\
    </cell>\n<cell>\ndigits(12)\n</cell>\n<cell>\ndigits(99)\n</cell>\n<cell>\ndigits(42)\n\
    </cell>\n<cell>\ndigits(9)\n</cell>\n<cell>\ndigits(1)\n</cell>\n<text>\nSlicing\
    \ Arrays\nIn Ruby, arrays are objects, so you can slice them just like any other\
    \ object. The only difference is that you use square brackets instead of parentheses.",
  "  return n.to_s.split(//).select { |d| d % 2 != 0 }.reduce(0, &:*)\nend", "  num\
    \ = n\n  i = 0\n  while i < n\n    num = num / 10\n    i = i + 1\n  end\n  return\
    \ num\nend", "  if n < 0\n    return 0\n  d, r = 0, 1\n  while n > 0\n    d, r\
    \ = d*10 + n % 10, n % 10\n    n /= 10\n  return d\nend", "  n.to_s.split(\"\"\
    ).map { |s| s.to_i if s.odd? }.inject(0, &:*)\nend", "\tif n.odd?\n\t\t0\n\telse\n\
    \t\tn.digits.reduce(:*)\n\tend\nend", "  digits = n.to_s.split(//).map(&:to_i)\n\
    \  odd = digits.find { |x| x % 2 != 0 }\n  result = 1 if odd != nil\n  n.to_s.split(//).each\
    \ do |digit|\n    if digit.to_i % 2 != 0\n      result = result * digit.to_i\n\
    \    end\n  end\n  result\nend\n</code>\n<|/ a dscore=3 tags=ruby,algorithm |>\n\
    <| c |>\nIf `n` is `0` `0` should be returned.\n<|/ c |>\n<| c |>\nGood catch.\
    \ Edited accordingly.\n<|/ c |>\n<| a tags=ruby,algorithm |>\nHere's a mathematical\
    \ solution to this problem:\n<code>", "  n.to_s.reverse.split(//).map { |digit|\
    \ digit.to_i * (digit.to_i % 2 ? -1 : 1) }.reduce(1, :*)\nend\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nWhat are you trying to say? This does not do what you\
    \ want. And how is this better than \"[a more readable] solution\"?\n<|/ c |>\n\
    <| c |>\nI added some explanation about what the code is doing and why.\n<|/ c\
    \ |>\n<| c |>\nThanks so much for the explanation. It's much appreciated.\n<|/\
    \ c |>\n<| c |>\nThis is not a good solution since it will raise exceptions. When\
    \ it gets a string with single digits, it raises an exception\n<|/ c |>\n<| a\
    \ tags=ruby,ruby-on-rails |>\n<code>", "    i = 0\n    sum = 0\n    while i <\
    \ n do\n        sum = (sum * 10) + (n % 10)\n        i += 1\n        n = n / 10\n\
    \    end\n    return sum\nend\n</cell>\n<code language=julia-1.0>\ndigits(123)\n\
    </cell>\n<code language=julia-1.0>\ndigits(1234)\n</cell>\n<text>\nQuestion 5\
    \ (6.9%)\nDefine a function that returns the sum of the numbers from 1 to n that\
    \ are divisible by k.", "  product = 1\n  while n > 0 do\n    if n % 2 == 1 then\n\
    \      product = product * 3\n    end\n    n = n / 2\n  end\n  product\nend",
  "    \n    if n < 0\n        return 0 \n    \n    result = 1\n    \n    while n\
    \ > 0 \n        \n        result = result * n % 10\n        \n        n = n /\
    \ 10 \n    \n    return result", "    p =1\n    while (p > 0 ) do\n        p =p*(n%2)\n\
    \        n = n / 2\n    end\n    return p\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's a Ruby implementation of John Cook's solution that produces the correct\
    \ result with O(n) time, O(1) space:\n<code>", "  digits.reverse!\n  n.times {\
    \ |x| digits.reduce(:*) * (x % 2 + 1) }\nend", "  n = n.to_s\n  n.split(\"\").each\
    \ do |digit|\n    if digit % 2 == 1\n      return 0\n    end\n  end\n  n.split(\"\
    \").map { |digit| digit.to_i }.inject(:*)\nend\n</cell>\n<cell>\ndigits(1)\n</cell>\n\
    <cell>\ndigits(4)\n</cell>\n<cell>\ndigits(999999999999999999999999999999999)\n\
    </cell>\n<cell>", "  return 0 if n==0 else (n%2).bit_or(digits(n//2))\nend\n</cell>\n\
    <code language=julia-1.5>\ndigits(120)\n</cell>\n<text>\nExercise 2.4: Digits\n\
    Write a function that takes an integer and returns the sum of the odd digits in\
    \ the integer.\nFor example, for 123, the sum is 1+2+3 = 6.", "  return if n.to_i\
    \ < 10\n  1\nend", "  x = n\n  y = 0\n  \n  while x > 0 do\n    x = (x / 2)\n\
    \    y = y + 1\n  end\n  \n  return 0 if y > 0\n  \n  x = x / 2\n  y = 0\n  \n\
    \  while x > 0 do\n    x = (x / 2)\n    y = y + 1\n  end\n  \n  return y\nend",
  "    sum=0\n    if n<10\n        sum=n\n    else\n        sum=(n%10)*digits(n/10)\n\
    \    end\n    \n    return sum\nend", "    num = n.to_s\n    digit = num.to_s[1..-1]\n\
    \    return 0 if digit.start_with?('0') \n    return num.to_i * digit.to_i\nend",
  "  if n == 0\n    0\n  elsif n % 2 == 0\n    digits(n / 2)\n  else\n    n * digits(n\
    \ / 2)\n  end\nend", "  digits = []\n  i = n.to_i\n  while i >= 1\n    digits\
    \ << i.to_i\n    i /= 10\n  end\n  digits.reverse!\n  digits.reduce(1,:*) # reduce\
    \ returns a list of all the elements in an array\n  return digits[0] if digits.any?\n\
    \  0\nend\n  ", "  return n and n*100+10*n%100 and digits(n//10) or 0\nend\n</cell>\n\
    <code language=julia-0.6>\ndigits(4)\n</cell>\n<text>\nNow we can find the sum\
    \ of the digits of an integer.", "    number = 0\n    while (n != 0)\n       \
    \ number *= 10\n        number += n % 10\n        n = n / 10\n    return number\n\
    </cell>\n<code language=julia-1.0>", "    digits_array = n.to_s.split(//)\n  \
    \  product = 1\n    \n    if n == 0\n        product\n    else\n        product\
    \ = 0\n        \n        digits_array.each do |digit|\n            product *=\
    \ (digit.to_i % 2 != 0) ? 0 : 1 # Odd digits must be zero.\n        end\n    end\n\
    end\n</code>\n<code>\ndigits(4) ", "  n.to_s.split(\"\").map{|d| d.to_i}.inject{|m,\
    \ n| m * n if n % 2 == 1}\nend", "  sum = 0\n  n.times do |i|\n    sum += i &\
    \ 1\n  end\n  sum if sum > 0\nend", "    digits = \"\"\n    while n > 0\n    \
    \    digits = digits+n%10\n        n /= 10\n    return digits if digits.to_s.length\
    \ <= 1 else digits.to_s\nend", "  digit = 1\n  while n > 0 do\n     digit = digit\
    \ * n % 10\n     n = n / 10\n  end\n  return digit\nend\n</cell>\n<text>\nExtra\
    \ credit\nExtra credit question: what if you wanted to make digits() a recursive\
    \ function?", "\treturn n % 2 ? n * digits(n / 2) : n", "  r = 1\n  while n >\
    \ 0\n    r = r * n % 10\n    n /= 10\n  end\n  return r\nend", "\tif n == 0 then\
    \ return 0\n\tsum = 0\n\ti = 0\n\twhile i < n do\n\t\tdigit = n % 10\n\t\tif digit\
    \ % 2 > 0 then\n\t\t\tdigit = digit + 1\n\t\tsum = sum + digit\n\t\tn = n / 10\n\
    \t\ti = i + 1\n\treturn sum\nend", "  return n % 2 != 0 ? n * digits(n / 2)\n\
    \                 : 0\nend", "  product = 1\n  n.times { product *= 2 if n % 2\
    \ == 1 }\n  product\nend", "  result = 0\n  while n > 0\n    result += (n % 10).odd?\n\
    \    n /= 10\n  end\n  result\nend", "    sum = 0\n    while n>0\n        if n\
    \ % 2\n            sum += n\n        n /= 10\n    return sum\nend", "  if n %\
    \ 2 == 0\n  else\n  digits(n//2) + n%2*3\nend", "  n.to_s.split('').select { |d|\
    \ d.odd? }.inject(:*)\nend", "  digits = (0...n).map {|i| i % 2 != 0 ? i : 0}\n\
    \  digits.inject(1) do |result, x|\n    result * 10 + x\n  end\nend", "  total\
    \ = 0\n  n.times { total += n % 10 if n % 2 == 1 }\n  total\nend", "  product\
    \ = 1\n  while n > 0\n    product = (product * 2 + n % 10).to_i\n    n /= 10\n\
    \  product\nend", "  digit_arr = n.to_s.split('').reverse.to_a\n  digit_arr.each_with_index\
    \ do |x, i|\n    next if x.to_i.odd?\n    digit_arr[i] = x.to_i\n  end\n  digit_arr.inject(:*)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI'm sure that it's O(n), but I would love to\
    \ see an explanation of how it works.\n<|/ c |>\n<| c |>\n, sorry but I don't\
    \ think the answer should be O(n). But I see a O(n) way of solving this. I will\
    \ try to work out the solution myself and update the answer. Thanks\n<|/ c |>\n\
    <| c |>\nI don't think it's O(n), but it is O(n/2) so it's pretty cool.\n<|/ c\
    \ |>\n<| a |>\nHere's my take on the problem:\n<code>", "  result = 1\n  while\
    \ n > 0 do\n    result = result * n % 10\n    n /= 10\n  end\n  result\nend",
  "  return n.to_s.split(//).select{|a| a.odd?}.inject(:*)\nend", "  return (n%10).to_s\
    \ if n.to_s.length<=1 && n.to_s.length>0 && (n%100).to_s.length<=1 && n.to_s.length>0\
    \ && (n%1000).to_s.length<=1 && n.to_s.length>0 && (n%10000).to_s.length<=1 &&\
    \ n.to_s.length>0 && (n%100000).to_s.length<=1 && n.to_s.length>0 && (n%1000000).to_s.length<=1\
    \ && n.to_s.length>0 && (n%10000000).to_s.length<=1 && n.to_s.length>0 && (n%100000000).to_s.length<=1\
    \ && n.to_s.length>0 && (n%1000000000).to_s.length<=1 && n.to_s.length>0\n  return\
    \ 0 if n.to_s.length<=1 && n.to_s.length>0 && (n%100).to_s.length<=1 && n.to_s.length>0\
    \ && (n%1000).to_s.length<=1 && n.to_s.length>0 && (n%10000).to_s.length<=1 &&\
    \ n.to_s.length>0 && (n%100000).to_s.length<=1 && n.to_s.length>0 && (n%1000000).to_s.length<=1\
    \ && n.to_s.length>0 && (n%10000000).to_s.length<=1 && n.to_s.length>0 && (n%100000000).to_s.length<=1\
    \ && n.to_s.length>0 && (n%1000000000).to_s.length<=1 && n.to_s.length>0\n  n.to_s.reverse.each.with_index\
    \ { |n| return 0 if n.to_s.length<=1 && n.to_s.length>0 && (n%100).to_s.length<=1\
    \ && n.to_s.length>0 && (n%1000).to_s.length<=1 && n.to_s.length>0 && (n%10000).to_s.length<=1\
    \ && n.to_s.length>0 && (n%100000).to_s.length<=1 && n.to_s.length>0 && (n%1000000).to_s.length<=1\
    \ && n.to_s.length>0 && (n%10000000).to_s.length<=1 && n.to_s.length>0 && (n%100000000).to_s.length<=1\
    \ && n.to_s.length>0 && (n%1000000000).to_s.length<=1 && n.to_s.length>0 }\n \
    \ \n  # Given a positive integer n, return the sum of the even digits.\n  # Return\
    \ 0 if all digits are odd.\n  # For example:\n  # >>> sum(5) \n  # 6\n  # >>>\
    \ sum(3) \n  # 6\n  def sum(n)\n    n.to_s.reverse.each.with_index { |n| return\
    \ 0 if n.to_s.length<=1 && n.to_s.length>0 && (n%100).to_s.length<=1 && n.to_s.length>0\
    \ && (n%1000).to_s.length<=1 && n.to_s.length>0 && (n%10000).to_s.length<=1 &&\
    \ n.to_", "  total = 0\n  n.to_s.chars.each do |c|\n    digit = c.to_i\n    next\
    \ if digit % 2 == 1\n    total = total + digit\n  end\n  total\nend", "  if n<10\n\
    \    digit=1\n  elsif n>9\n    digit=digit(n/10)*10\n    digit+=digit(n%10)\n\
    \  else\n    digit=0\n  end\n  digit\nend", "  digits = []\n  while n > 0\n  \
    \  digits.push(n % 10)\n    n = n / 10 \n  end\n  digits.reverse!\n  digits.product!(2)\
    \ \nend", "  res = 0\n  while n > 0\n    n, r = divmod (n, 10)\n    res = res\
    \ * r + n\n  end\n  res\nend", "  digits = Array.new(n)\n  \n  n.times do |i|\n\
    \    digits[i] = n % 10\n    n /= 10\n  end\n  \n  digits.reduce(:*)\nend", " \
    \ n<10? n=0\n  n>=0? n=1*n*n+digits(n/10).last : -1\nend", "  n.to_s.split(//).inject(1)\
    \ { |s,e| s * 10 + (e.to_i % 2 == 0 ? 0 : 1) }\nend\n</cell>\n<cell>\ndigits(7)\n\
    </cell>\n<cell>\ndigits(123)\n</cell>\n<cell>\ndigits(999)\n</cell>\n<text>\n\
    Exercise\nWrite a function that returns the sum of the digits of n. Note: n should\
    \ not contain any leading zero digits.", "\tn%2 == 0 ? n*9 : n*9 + 1\nend\n</cell>\n\
    <cell>\ndigits(1)\n</cell>\n<cell>\ndigits(4)\n</cell>\n<cell>", "  n%2 == 0 ?\
    \ n*(n+1)/2 : 0\nend", "    n.to_i.digits.reverse.map(&:odd?).inject(:*)\nend",
  "    product = 1\n    i = 0\n    while i < n\n        product = product * n % 10\n\
    \        i += 1\n        n = n / 10\n    return product\n</code>\nAt the end of\
    \ the program, the result is displayed.\n<code>", "  if n % 2 == 1\n    product\
    \ = 1\n  else\n    product = 0\n  end", "  if n == 0\n    1\n  else\n    n % 10\
    \ * digits(n / 10)\n  end\nend", "  sum = 0\n  while n > 0 \n    sum += n % 10\n\
    \    n /= 10\n  end\n  sum\nend", "  n.to_s.split(//).map {|c| c.to_i%2 ? c.to_i\
    \ : 0}.reduce(:*)\nend", '  return n % 2 ? n*digits(n-1) : n', "  d = 1\n  n0\
    \ = n % 10\n  n1 = (n0 / 10).round\n  n2 = (n1 / 10).round\n  n3 = (n2 / 10).round\n\
    \  n4 = (n3 / 10).round\n  n5 = (n4 / 10).round\n  n6 = (n5 / 10).round\n  n7\
    \ = (n6 / 10).round\n  n8 = (n7 / 10).round\n  n9 = (n8 / 10).round\n  n10 = (n9\
    \ / 10).round\n  n11 = (n10 / 10).round\n  n12 = (n11 / 10).round\n  n13 = (n12\
    \ / 10).round\n  n14 = (n13 / 10).round\n  n15 = (n14 / 10).round\n  n16 = (n15\
    \ / 10).round\n  n17 = (n16 / 10).round\n  n18 = (n17 / 10).round\n  n19 = (n18\
    \ / 10).round\n  n20 = (n19 / 10).round\n  n11 = (n20 / 10).round\n  n12 = (n11\
    \ / 10).round\n  n13 = (n12 / 10).round\n  n14 = (n13 / 10).round\n  n15 = (n14\
    \ / 10).round\n  n16 = (n15 / 10).round\n  n17 = (n16 / 10).round\n  n18 = (n17\
    \ / 10).round\n  n19 = (n18 / 10).round\n  n20 = (n19 / 10).round\n  n11 = (n20\
    \ / 10).round\n  n12 = (n11 / 10).round\n  n13 = (n12 / 10).round\n  n14 = (n13\
    \ / 10).round\n  n15 = (n14 / 10).round\n  n16 = (n15 / 10).round\n  n17 = (n16\
    \ / 10).round\n  n18 = (n17 / 10).round\n  n19 = (n18 / 10).round\n  n20 = (n19\
    \ / 10).round\n  n11 = (n20 / 10).round\n  n12 = (n11 / 10).round\n  n13 = (n12\
    \ / 10).round\n  n14 = (n13 / 10).round\n  n15 = (n14 / 10).round\n  n16 = (n15\
    \ / 10).round\n  ", "  digits.each(n) do |d|\n    if d % 2 != 0\n      d *= 3\n\
    \    end\n  end\n  n\nend", "  i = n.to_s.length - 1\n  while i > 0\n    digit\
    \ = n.to_s[i] % 10\n    i -= 1\n    n /= 10\n    return digit\n  end\n  n\nend",
  "  result = 0\n  while n > 0\n    digit = n % 10\n    result = result * digit\n\
    \    n /= 10\n  end\n  result\nend", "\tn.to_s.split('').each_with_index.map {|d,\
    \ i| digits_oned[i % 2]*d}.reduce(0, :*)\nend", "  return 0 if n == 0 then\n \
    \         0\n  elsif n == 1 then\n          1\n  elsif n < 10 then\n         \
    \ return n * digits(n % 10)\n  else\n          return 0\n  end\nend", "  if n.odd?\
    \ or n.even?\n    n\n  else\n    n.to_s.reverse.scan(/../).inject(0) do |acc,\
    \ n|\n      if n.odd?\n        acc * 2\n      else\n        acc * 3\n      end\n\
    \    end\n  end\nend\n</cell>\n<cell>\ndigits(1)\n</cell>\n<cell>\ndigits(4)\n\
    </cell>\n<cell>\ndigits(8)\n</cell>\n<text>\nExercise: Find the greatest product\
    \ of four consecutive digits.", "  d = 0\n  while n > 0\n    d, n = n / 10, n\
    \ % 10\n  end\n  d\nend", "  return 0 if (n.zero?) \n  a = 1\n  i = 1\n  while\
    \ i <= n\n    a += 2*(i % 2 == 1)\n    i += 1\n  end\n  a\nend", "  total = 0\n\
    \  while n > 0 do\n    total = (n % 10) * 10 + total\n    n = n / 10\n  end\n\
    \  return total\nend\n</cell>\n<cell>\ndigits(1)\n</cell>\n<cell>\ndigits(4)\n\
    </cell>\n<cell>\ndigits(4)\n</cell>\n<cell>\ndigits(123456789)\n</cell>\n<cell>\n\
    digits(123)\n</cell>\n<cell>\ndigits(10)\n</cell>\n<cell>\ndigits(20)\n</cell>\n\
    <cell>\ndigits(1234567890)\n</cell>\n<cell>\ndigits(1234567891)\n</cell>\n<cell>\n\
    digits(1234567890123)\n</cell>\n<cell>\ndigits(-1)\n</cell>\n<cell>\ndigits(-2)\n\
    </cell>\n<cell>\ndigits(-123)\n</cell>\n<cell>\ndigits(-987)\n</cell>\n<cell>\n\
    digits(-9876)\n</cell>\n<cell>\ndigits(-987654321)\n</cell>\n<cell>\ndigits(-987654321)\n\
    </cell>\n<cell>\ndigits(-987654321)\n</cell>\n<cell>\ndigits(0)\n</cell>\n<cell>\n\
    digits(2)\n</cell>\n<cell>\ndigits(3)\n</cell>\n<cell>\ndigits(4)\n</cell>\n<cell>\n\
    digits(5)\n</cell>\n<cell>\ndigits(9)\n</cell>\n<cell>\ndigits(10)\n</cell>\n\
    <cell>\ndigits(11)\n</cell>\n<cell>\ndigits(100)\n</cell>\n<cell>\ndigits(1000)\n\
    </cell>\n<cell>\ndigits(1000)\n</cell>\n<cell>\ndigits(10000)\n</cell>\n<cell>\n\
    digits(1234567890123)\n</cell>\n<cell>\ndigits(123456789012345)\n</cell>\n<cell>\n\
    digits(12345678901234567)\n</cell>\n<cell>\ndigits(1234567890123456)\n</cell>\n\
    <cell>\ndigits(1234567890123456)\n</cell>\n<cell>\ndigits(1234567890123456)\n\
    </cell>", "  n.to_s.scan(/\\d+/).reduce(:*)\nend\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| a tags=ruby,regex |>\n<code>\nn = \"1234567\"\n\"#{n[-1,1]}\"\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post.\n<|/ c |>\n<| c |>\nIt does answer the question and it was the only correct\
    \ answer at the time of my post.  It does give the desired output and works with\
    \ any number of digits given to it.\n<|/ c |>\n<| c |>\nThis is nice and short\
    \ but if the input is a negative number then you get the wrong answer and it doesn't\
    \ work. e.g. `\"-1234567\"[-1,1]` gives you `\"-\"` which is wrong.\n<|/ c |>\n\
    <| a dscore=0 |>\nThe shortest I could come up with is \n<code>", "  digits =\
    \ n.to_s.split(\"\")\n  odd = digits[0...digits.length-1]\n  even = digits[1...digits.length]\n\
    \  sum = even.inject(:*)\n  sum *= odd.inject(:*)\n  sum\nend", "  sum = 0\n \
    \ n.times { sum += n % 2 }\n  sum\nend", "  if n < 0\n    puts \"0\", 0\n  else\
    \ if n == 0\n    puts \"1\"\n  else\n    while n % 2 == 0\n      puts \"0\", 0\n\
    \      n /= 2\n    end\n    puts n\n  end\nend", "  n==0 ? 1 : n % 2 == 0 ? n\
    \ / 2 * digits(n / 2) : 0\nend", "    count = 0\n    while n > 0\n        count\
    \ += n % 10\n        n /= 10\n    end\n    count\nend", "  res = 0\n  while n\
    \ > 0\n    n, d = divmod(n, 10)\n    res = res * d + d\n  end\n  return res\n\
    end", "  return n == 0 ? 0 : ((n % 10 ** (2 * n)) % 2)\nend", "\t\n\t# your code\
    \ here\n\tif n < 10\n\t\treturn n\n\tif n == 0\n\t\treturn 0\n\tif n % 2 == 0\n\
    \t\treturn n*digits(int(n/2))\n\telse\n\t\treturn n*digits(int(n/2))\n\tend\n\
    end", "  (n * 9 % 10).floor\nend", "  n.to_s.split(\"\").reduce(:*)\nend", " \
    \ n.to_s.reverse.split('').select {|c| c.odd?}.inject(:*)\nend", "  return n.to_s.split('').reverse.reduce(:*)\
    \ if (n > 0)\n  0\nend\n</cell>\n<code language=julia-0.5>\ndigits(10)\n</cell>\n\
    <text>\nSolution\nNow let's define the function that computes how many ways we\
    \ can arrange the digits in n into arrangements where the only number in each\
    \ arrangement is the same as the n. The function should accept an integer, n,\
    \ and return a integer.", "    return 0 if n % 2 == 0 else n * digits(n / 2)\n\
    end", "  digits = []\n  for i in 1...n\n    digits.push(i%10) if i%10\n  end\n\
    \  digits.inject(:*)\nend", "  product = 1\n  while n > 0\n    if n % 2 == 1\n\
    \      product = product * 10\n      n = n / 2\n    end\n    n = n / 2\n  end\n\
    \  product = product * 10\n  product = product * digits(n)\n  return product\n\
    end", "  return 0 if n < 10 else n % 10 * digits(n / 10)\nend", "  sum = 0\n \
    \ n.times { sum += n % 10 }\n  sum\nend", "\tcount = 0\n\twhile n != 0\n\t\tcount\
    \ += 1\n\t\tn /= 10\n\tend\n\treturn count\nend", "  digits = n.to_s.chars.each_char.map\
    \ { |x| x if x.odd? }\n  digits.inject(0) { |x,y| x * y }\nend", "\tlocal result\
    \ = 1\n\tlocal num = 1\n\twhile n >= 0 do\n\t\tlocal i = 1\n\t\twhile num + i\
    \ >= 10 do\n\t\t\tresult = result * i\n\t\t\ti = i + 1\n\t\tend\n\t\tresult =\
    \ result + num + i\n\t\tnum = num + i + 1\n\tend\n\treturn result\nend", "  if\
    \ n % 2\n  then\n    digits(n / 2)\n  else\n    n\n  end\nend", "  return 0 if\
    \ n == 0\n  m = n % 2 == 1\n  while n > 0 do\n    n /= 2\n    m = m || n % 2 ==\
    \ 1\n  end\n  return m == 0 ? n : 0\nend", "  if n < 10 then return n\n  if n\
    \ % 2 == 0 then return 0\n  if n % 3 == 0 then return n * digits(n / 3)\n  else\
    \ return n * digits(n / 3) + 1\nend", "  if n.even? \n    0\n  else\n    n.to_s.chars.map\
    \ { |n| n % 2 == 1 }.reduce(:*)\n  end\nend", "  digits = n.to_s.chars.map(&:to_i)\n\
    \  if digits[0] == 0\n    digits.shift\n  end\n  digits.inject(:*)\nend", "  n.digits.each_with_index\
    \ {|d,i| return d if i%2 != 0 }\n  0\nend", "  return 0 if n == 0\n  return n\
    \ * digits(n / 2)", "  result = 0\n  n.to_s.split(//).each do |x|\n    result\
    \ += (x.to_i % 2).to_s * (x.to_i / 2).to_s\n  end\n  result *= 0\nend", "  n,\
    \ *rest = n.divmod(10)\n  return rest.length % 2 ? n * prod(rest)\nend ", "  return\
    \ n - (n % 2) * 10 + (n % 2 > 0)\nend", "  digits = n.to_s.chars.map { |c| digit(c)\
    \ }\n  digits.reduce(:*)\nend\n</code>\nThis solution assumes that you want to\
    \ return the product of the digits, not just their values. If you want to return\
    \ the sum of the values, simply replace sum with product in your function.\n<|/\
    \ a |>\n<| c |>\nNice use of `chars` and `map` instead of `each_char`!\n<|/ c\
    \ |>\n<| c |>\nI like this solution, but it assumes that `n` is an integer.  It\
    \ also assumes that `digits(10)` returns `10`, but that isn't necessarily the\
    \ case in a real implementation.  See my answer for one that works with arbitrary\
    \ precision.\n<|/ c |>\n<| c |>\n: I realise that the question doesn't specify\
    \ the precision of the input, but I thought it might be worth noting that the\
    \ question assumes the input is an integer. I'll make that clearer in the answer.\n\
    <|/ c |>\n<| a |>\nThe easiest way to do this is:\n<code>", "  # TODO: implement\
    \ the function here\n  return 0\nend", "    product = 1\n    digits = n.to_s.split(\"\
    \")\n    digits.reverse!\n    digits.each do |digit|\n        if digit.to_i%2\
    \ != 0\n            product *= digit.to_i\n        end\n    end\n    return product\n\
    end", "  sum = 0\n  while n > 0 do\n      sum += n % 10\n      n /= 10\n  end\n\
    \  return sum if n == 0\n  sum = 0\n  while n > 0 do\n      sum += n % 10\n  \
    \    n /= 10\n  end\n  return sum\nend", "\tdigits_array = []\n\tnstr = '0' *\
    \ (n-1) + n.to_s\n\tdigits_array = nstr.each_char.map(&:to_i).sort\n\t\n\tdigits.reduce(1,&:*).tap(&:*).tap(&:to_i).tap(&:round)\n\
    end", "  # TODO: Implement this\nend\n</pre>", "  if n < 1\n    0\n  else\n  \
    \  return n * digits(n-1)\nend", "  return n.to_s.reverse.gsub(/(\\d)(?=(?:\\\
    d{2})*$)/, '\\1'*n)\nend\n</code>\n<|/ a |>\n<| c |>\nHow is this answer different\
    \ from the one posted earlier?\n<|/ c |>\n<| c |>\n: Nope, same solution, different\
    \ approach.\n<|/ c |>\n<| a |>\nThis is my attempt at a solution for Ruby 1.8.7:\n\
    <code>", "  return n.to_s.reverse.gsub(/\\d{2}/,'0').to_i\nend", "  d = n.to_s.reverse.scan(/../).map\
    \ { |x| x % 2 ? x : x % 10 }.inject(0, &:*)\n  if d == 0\n    0\n  else\n    d\n\
    \  end\nend", "  n.to_s.reverse.to_i\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
