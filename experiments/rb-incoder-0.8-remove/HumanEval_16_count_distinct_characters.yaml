name: HumanEval_16_count_distinct_characters
language: rb
prompt: "# Given a string, find out how many distinct characters (regardless of case)\
  \ does it consist of\ndef count_distinct_characters(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_distinct_characters\n\
  \    candidate = method(:count_distinct_characters)\n    assert_equal(0, candidate.call(\"\
  \"))\n    assert_equal(5, candidate.call(\"abcde\"))\n    assert_equal(5, candidate.call(\"\
  abcdecadeCADE\"))\n    assert_equal(1, candidate.call(\"aaaaAAAAaaaa\"))\n    assert_equal(5,\
  \ candidate.call(\"Jerry jERRY JeRRRY\"))\n  end\nend\n"
completions: ["    return string.split('').uniq.count\nend", "  string.downcase.count(\"\
    a\")\nend", "    string.downcase!\n    string.count\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,ruby-on-rails,string |>\n<| c |>\nGood catch. I missed that in my\
    \ answer. I was originally thinking that the OP was looking for `String#count`\
    \ but then he edited the question and he changed it to `String#size`.\n<|/ c |>\n\
    <| c |>\nMy initial question was meant for cases where I do not need the total\
    \ string size. For example, if I were to count the number of words present in\
    \ a string, the answer would be the answer provided by string#count. But I was\
    \ looking for a way to find the number of distinct characters as well as the total\
    \ string length. \nMy second question was specifically regarding cases where I\
    \ need to find the total number of distinct characters present in a string but\
    \ I need to find the total number of characters as well as the total string length\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,string |>\nI believe you are looking for\
    \ the String#count method. This method returns the number of times a character\
    \ appears in a string. \nAs far as your second question, I don't see a way in\
    \ Ruby to know how many characters are in a string, but you could probably implement\
    \ it yourself using a method like:\n<code>", "  string.split('').inject(0) do\
    \ |count,char|\n    count += 1 if char.casecmp(string.downcase) == 0\n  end\n\
    end", "  string.scan(/./u).length\nend", "  string.split(//).reduce(0) { |c, x|\
    \ c + (case x.downcase when \"a\" then 1 when \"b\" then 2 when \"c\" then 3 when\
    \ \"d\" then 4 when \"e\" then 5 when \"f\" then 6 when \"g\" then 7 when \"h\"\
    \ then 8 when \"i\" then 9 when \"j\" then 10 when \"k\" then 11 when \"l\" then\
    \ 12 when \"m\" then 13 when \"n\" then 14 when \"o\" then 15 when \"p\" then\
    \ 16 when \"q\" then 17 when \"r\" then 18 when \"s\" then 19 when \"t\" then\
    \ 20 when \"u\" then 21 when \"v\" then 22 when \"w\" then 23 when \"x\" then\
    \ 24 when \"y\" then 25 when \"z\" then 26 end) end) }\nend\n</code>\nThe last\
    \ part is counting how many of each character there is, which you can then turn\
    \ into a hash using the count as the key.\n<|/ a dscore=0 |>\n<| c |>\nIf you're\
    \ using Rails 3, you can get away with using the `count` method to get the number\
    \ of each character in a string.\n<|/ c |>\n<| c |>\nyeah, I wasn't sure if he\
    \ was using a version of rails past 2.3.x or not, but it's an easy change for\
    \ him\n<|/ c |>\n<| c |>\nI appreciate your thoughts on this, but I want to keep\
    \ the solution within the realm of the language and the standard library.  Your\
    \ solution is good but I don't want to have to write my own code for each and\
    \ every possible case I might encounter.  I want a solution where I can simply\
    \ loop through each character of the string and use Ruby's standard library to\
    \ do it for me.\n<|/ c |>\n<| a tags=ruby |>\nThis should do it:\n<code>", " \
    \ array.map(&:downcase).uniq.count\nend", "  characters = string.split(//)\n \
    \ characters.inject(0) do |distinct_count, (char)|\n    distinct_count + (character\
    \ == char) ? 0 : -1\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nWhat would be the\
    \ time complexity of this solution compared to the other solutions above?\n<|/\
    \ c |>\n<| c |>\nThe solutions above have `O(n)` time complexity. The answer above\
    \ has `O(k)` time complexity. Time complexity of string counting is always `O(n)`\n\
    <|/ c |>\n<| a dscore=4 |>\nYou can try this-\n<code>", "    count = 0\n    string.upcase.each\
    \ do |c|\n        count += 1 if string.downcase.count(c) > 1\n    end\n    count\n\
    end", "  string.scan(/[a-z]+/).size\nend", "  string.split(//).uniq.count\nend",
  "  # Your code here\n  str.chars.uniq.count\nend", "  # Initialize a counter\n \
    \ counter = {}\n  \n  # Iterate through every character in the string\n  string.each\
    \ do |char|\n    # If a character is not yet in the counter\n    if !counter.has_key?\
    \ char\n      # The character is not yet in the counter, add it\n      counter[char]\
    \ = 1\n      # Move on to the next character\n      next\n    # Otherwise, increment\
    \ the counter for the current character\n    else\n      counter[char] += 1\n\
    \    end\n  end\n  \n  # Return the number of distinct characters\n  counter.length\n\
    end", "  chars = set()\n  char_count = 0\n  string.split(\"\").each do |c|\n \
    \   chars.add c unless chars.include? c\n    char_count += 1\n  end\n  char_count\n\
    end", "  count = 0\n  string.split(\"\").each do |char|\n    count += 1\n  end\n\
    \  count\nend", "  string.count(\"a\")\nend", "  (0..string.length-1).to_a.inject(Hash.new(0))\
    \ {|h,i|h[string.upcase[i]] += 1 }\nend", "  string.to_s.chars.uniq.size\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "\tstring.split.uniq.size\nend",
  "  string.scan(/./.count).to_a\nend", "  (0...string.size).to_a.uniq.size\nend",
  "  string.each_char.uniq.size\nend\n</code>\nNote that your count_distinct_characters\
    \ function does not take into account uppercase letters, i.e. it counts lowercase\
    \ and uppercase letters as distinct. While it might be good enough for your use\
    \ case, the solution provided by is the one that would perform better for this\
    \ task.\n<|/ a |>\n<| a |>\nWe can use String#scan to count the distinct characters.\
    \ For example\n<code>", "  # No need to worry about empty strings\n  return string.count\
    \ if string", "  string = string.downcase\n  string.each_char.uniq.count\nend",
  "  string.downcase.split('').uniq.size\nend", "  string.split(\"\").inject(Hash.new(0)){|hash,\
    \ char| hash[char] += 1; hash}\nend", "  string.split('').uniq.size\nend", " \
    \ unique_chars = string.chars.uniq.count\n  return unique_chars\nend", "    string.each_char.with_object(Hash.new(0))\
    \ { |c,h| h[c] += 1 }.size\nend", "  string.split(//).inject(Hash.new(0)){|h,\
    \ s| h[s.downcase] += 1}\nend", "  count = 0\n  string.downcase.each_char do |letter|\n\
    \    unless string.upcase.include? letter\n      count += 1\n    end\n  end\n\
    \  count\nend", "  chars = string.split('')\n  chars.uniq.length\nend", "    string.downcase!\n\
    \    count = 0\n    string.each { |c| count += 1 if c.downcase != c.upcase }\n\
    \    count\nend\n</code>\n<|/ a dscore=0 tags=ruby-on-rails,ruby |>\n<| c |>\n\
    Wow, this is a lot cleaner! I'm going to try this out as soon as I can.\n<|/ c\
    \ |>\n<| c |>\nI updated my answer with a simple benchmark. Yes, I agree that\
    \ `downcase!` is more ruby-like.\n<|/ c |>\n<| c |>\nNice! This actually works\
    \ better than the one I had, and it also runs faster, and it's cleaner. Thanks!\n\
    <|/ c |>\n<| c |>\nOk, I did some more testing. It seems that my method is slower\
    \ than yours by a factor of 50 in some cases, but the other is faster in others.\
    \ Any idea why?\n<|/ c |>\n<| c |>\nWhat is the length of the string that you\
    \ test?\n<|/ c |>\n<| a |>\n<code>\n'aAaAaAa'.scan(/./).count", "    return string.split('').uniq.count\n\
    end", "    unique = string.downcase.split(//).uniq.count\n    unique += string.upcase.split(//).uniq.count\n\
    \    return unique\nend", "  string.split(\"\").uniq.size\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis solution looks more elegant and understandable to me. Thanks.\n\
    <|/ c |>\n<| a dscore=0 |>\nIf you really need a faster algorithm (but I don't\
    \ think it will matter), you could try to run a preprocessing on the string and\
    \ to remove all non-alphanumeric characters before counting how many distinct\
    \ characters there are. Then, run your algorithm on the string.\nYou could do\
    \ that by using the following regex:\n<code>\n[^A-Za-z0-9]\n</code>\n<|/ a tags=string,ruby,algorithm,ruby-on-rails\
    \ |>\n<| c |>\nI guess regex could do the job but I'm looking for a solution that\
    \ doesn't involve regex.\n<|/ c |>\n<| a dscore=0 |>\nI needed something similar.\
    \ My solution was to use each_char and just check if a character was a digit.\n\
    <code>", "  string.split(\"\").uniq.size\nend", "  (0..string.length-1).to_a.inject(0)\
    \ do |memo, index|\n    memo += 1 if string[index].downcase != string[index].upcase\n\
    \    memo\n  end\nend\n</code>\nThis works well when you're looking for case-insensitive\
    \ distinct characters. \n<code>\ncount_distinct_characters \"Hello, World!\"",
  "  string.chars.uniq.count\nend", "  string.downcase.chars.uniq.length\nend", " \
    \ string.split(//).uniq.size\nend\n</cell>\n<cell>", "  # Create an array to store\
    \ the distinct characters\n  distinct_characters = []\n  # Loop over the characters\
    \ in the string\n  string.each_char do |character|\n    # If the character is\
    \ not in the array already, add it to the array\n    if !distinct_characters.include?(character)\n\
    \      distinct_characters << character\n    end\n  end\n  # Return the number\
    \ of distinct characters found (this will be a positive number if the string contains\
    \ at least one distinct character regardless of case)\n  distinct_characters.count\n\
    end\n</code>\n<|/ a tags=string,ruby |>\n<| c |>\nThanks. I thought about doing\
    \ that, but I wasn't sure if there was some Ruby way of doing it besides looping\
    \ through each character. I suppose I'll probably end up doing that, I just wanted\
    \ to know if there's a more elegant way. Thanks again for the suggestion!\n<|/\
    \ c |>\n<| c |>\nI suppose you could do it in one line with `string.chars.group_by(&:itself).count`.\n\
    <|/ c |>\n<| c |>\n: That\u2019s not so \u201Cruby\u201D, is it? :) And it\u2019\
    s actually less efficient, since it makes a separate array and groups it all together.\
    \ Since OP\u2019s code would also make `distinct_characters` an array, that\u2019\
    s likely to be more efficient in any case.\n<|/ c |>\n<| c |>\n: yes, I\u2019\
    m aware that it\u2019s less efficient but that\u2019s what I\u2019ve been asked\
    \ for here so that\u2019s what I am going with. Thanks for the suggestion.\n<|/\
    \ c |>\n<| c |>\nI do know that `count` is faster than `length`. The issue is\
    \ that `length` is very different for different types of objects in Ruby. Strings\
    \ return `3` for `\"123\".length` while `count` returns `3` for `\"123\".count`.\n\
    <|/ c |>\n<| a dscore=3 tags=string,ruby |>\n<code>\n'Hello'.scan(/./).uniq.length\n\
    </code>\n<|/ a |>\n<| c |>\nNice! I actually don't know ruby, so I didn't know\
    \ about `.scan(/./).uniq.length`, but it is a nice trick.\n<|/ c |>\n<| c |>\n\
    Just out of curiosity, why use `scan` over `each`? Just curious.\n<|/ c |>\n<|\
    \ c |>\nBecause `scan` returns an array of matches.\n<|/ c |>\n<| a dscore=3 tags=string,ruby\
    \ |>", "  string.split(\"\").map {|c| c.downcase }.uniq.count\nend\n</code>\n\
    <|/ a tags=ruby dscore=2 |>\n<| a |>\n<code>", "  string.split('').inject(0) {|sum,\
    \ item| sum + item.length }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for your effort. I would vote up but I don't have enough reputation. I appreciate\
    \ your help though. I will test this out and let you know\n<|/ c |>\n<| c |>\n\
    The downside of this solution is that the solution you posted only works for English\
    \ characters. However, you can use this idea to extend it to other languages too.\
    \ The only thing you need to do is replace `\"a\"` with `\"a\".downcase` and do\
    \ the same with `\"z\"`. Do you understand?\n<|/ c |>\n<| c |>\nThank you. This\
    \ worked perfectly. I am very new to programming and am very grateful for your\
    \ help. Thank you again.\n<|/ c |>\n<| c |>\n, can you please explain what exactly\
    \ does this do? `string.split('').inject(0) {|sum, item| sum + item.length }`\n\
    <|/ c |>\n<| c |>\nThe method `inject` is used to iterate over a collection in\
    \ order to perform an operation on each element. Here we simply need to sum the\
    \ number of characters in each string.\n<|/ c |>\n<| a dscore=0 |>\nI recently\
    \ wrote a solution for counting distinct characters for a string that considers\
    \ both upper and lower case:\n<code>", "  # Write your code here.\nend", "  string.split('').uniq.size\n\
    end\n</code>\nAnd the last one is the solution:\n<code>", "  string.each_char\
    \ do |character|\n    puts character if string.split(character).length <= 1\n\
    \  end\nend\n</code>\n<|/ a tags=string,ruby dscore=1 |>\n<| c |>\nI edited the\
    \ question to include a better example\n<|/ c |>\n<| a dscore=1 |>\nI hope this\
    \ helps!\n<code>", "  string.downcase.scan(/\\w/).size\nend", "  string.downcase!\n\
    \  string.count('a'..'z') + 1\nend", '  string = "#{string}"', "  string.downcase.chars.count\n\
    end", "  string.each_char.count\nend\n</code>\n<|/ a dscore=2 tags=ruby,string\
    \ |>\n<| c |>\nI like this solution (no regex), but the other two are more straightforward.\n\
    <|/ c |>\n<| c |>\nI'd use the `each_char` method rather than `chars` when possible\
    \ (which is, I think, what they're doing, as they use the same method to get the\
    \ set of characters).\n<|/ c |>\n<| c |>\n`each_char` would probably be better\
    \ in terms of memory usage since it is lazy, and so less likely to cause unexpected\
    \ memory consumption.\n<|/ c |>\n<| c |>\n`chars` doesn't create an array to contain\
    \ the characters; it uses the current `string.encoding` to create an array.\n\
    <|/ c |>\n<| a |>\nRuby has the Enumerable#chunk method.\n<code>\n\"abcde\".chars.chunk{|c|\
    \ c}.map(&:join)", "  string = string.downcase\n  string.count('a'..'z')\nend\n\
    </code>\nAnd here's the code to generate the strings:\n<code>", "  string.split(\"\
    \").uniq.size\nend", "    seen = Set.new\n    string.split(\"\").reduce(0) { |count,\
    \ char| \n        if seen.include?(char)\n            count\n        else\n  \
    \          count + 1\n            seen << char\n        end\n    }\nend", "  string.reduce(0)\
    \ { |count, char| char.ord }.inject(:+)\nend", "  string.downcase.chars.uniq.length\n\
    end", "  string.split(//).uniq.size\nend", "  string.to_s.each_char.uniq.count\n\
    end", "  # First find the number of different characters\n  count_distinct_characters_helper('',\
    \ string)\nend", "  string.each_char do |char|\n    puts char.to_s if string.count(char)\
    \ == string.count(char.downcase)\n  end\nend", "  string.chars.uniq.length\nend",
  "    count = Hash.new(0)\n    string.each_char { |c| count[c] += 1 }\n    count.values\n\
    end", "  string.downcase.split('').uniq.count\nend", "  string_size = string.size\n\
    \  count = 0\n  \n  string.each_char do |char|\n    if char.downcase != char\n\
    \      count += 1 \n    end\n  end\n  \n  return count\nend\n</cell>\n<code language=julia-1.5>",
  "  string = string.downcase\n  string.chars.distinct.size\nend", "    count = 0\n\
    \    string.downcase!\n    string.each do |c|\n        if string.include? c\n\
    \            count += 1\n        end\n    end\n    return count\nend", "  new_string\
    \ = string.downcase\n  count = 0\n  new_string.each_char do |char|\n    if new_string.count(char)\
    \ != 0\n      count += 1\n    end\n  end\n  count\nend", "  # @TODO Implement\
    \ me!\nend", "  string.downcase!\n  string.gsub(/[a-z]/i, \"\").length\nend",
  "  string.scan(/./.count).size\nend", "\tstring.split(//).uniq.size\nend", "   \
    \ count_distinct_characters_count = 0\n    string.each_char do |char|\n      \
    \  if string.upcase == char\n            count_distinct_characters_count += 1\n\
    \        end\n        if string.downcase == char\n            count_distinct_characters_count\
    \ += 1\n        end\n    end\n    return count_distinct_characters_count\nend",
  "  # Convert to array of individual characters\n  chars = string.split(\"\")\n \
    \ # Return number of distinct characters in the array\n  return chars.count{ |char|\
    \ char.upcase != char }\nend", "  string.each_char.uniq.count\nend", "  string.each_char\
    \ do |char|\n    if string.count(char) == string.length\n      puts \"#{char}\"\
    \n    end\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nYou do not need to\
    \ call `count` twice. `string.each_char do |char| if string.count(char) == string.length\
    \ puts \"#{char}\" end end` will do just fine.\n<|/ c |>\n<| c |>\nThis should\
    \ be `each_char` instead `each_line`.\n<|/ c |>\n<| c |>\nThank you for the comments.\
    \  I've updated my answer accordingly.\n<|/ c |>\n<| a tags=ruby |>\nI agree with\
    \ what Jorge Villalm\xEDn said above. But the other thing you should be aware\
    \ of is that the count method will loop through the string for each character.\
    \ Not very efficient. That's why I added the each_char method. I also added the\
    \ chomp method to remove the new line character. \n<code>", "  string.downcase!\n\
    \  string.count('a') + 1\nend", "  string.downcase!\n  string.each_char.uniq.size\n\
    end", "  string.split('').sort.uniq.count\nend", "    string.downcase!\n    count\
    \ = {}\n    string.each_char do |c|\n        count[c] = count[c].nil? ? 0 : count[c]\
    \ + 1\n    end\n    count\nend", "  string.split(\"\").uniq.size\nend\n</cell>\n\
    <cell>\ncount_distinct_characters(\"Hello World\")\n</cell>\n<cell>", "  chars\
    \ = []\n  chars.concat(string.downcase)\n  chars.concat(string.upcase)\n  chars.concat(string.capitalize)\n\
    \  chars.concat(string.swapcase)\n  chars.concat(string.gsub(/[^a-zA-Z0-9]/, ''))\n\
    \  chars.length\nend\n</code>\nPutting it all together:\n<code>", "  string.chars.uniq.length\n\
    end", "    count = 1\n    string.each_char do |char|\n      count += 1\n    end\
    \ \n    return count\nend", "  string.split(//).size\nend", "  string.each_char.uniq.count\n\
    end", "    string.downcase!\n    string.gsub!(/\\s/, '') # remove any extra white\
    \ space\n    string.tr!('\"?!,;:{}()[]#&*%$^+\\-_=~`~\xB4^\xA8\xA6\xAB\xAA\xB4\
    \xB8\xBE\xBC\xBD\xBE\xBB\xAB\xAB\xB5\xAB\xBB\xBC\xBF\xB6\xB1\xB2\xB3\xB5\xB1\xB2\
    \xB5\xBC\xBB\xAB\xB3\xBF\xB1\xB2\xB6\xB6\xB1\xB2\xB3\xB6\xB3\xB2\xB3\xB6\xBC\xB5\
    \xBC\xBB\xB6\xAB\xB5\xAB\xB5\xBB\xBC\xBF\xB3\xB6\xB6\xBC\xBB\xAB\xB6\xBC\xB5\xBC\
    \xBB\xB6\xBB\xAB\xB3\xB2\xB6\xBC\xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\xB6\xBC\
    \xB5\xBC\xBB\xB6\xBB\xAB\xB3\xB2\xB6\xBC\xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\
    \xB6\xBC\xB5\xBC\xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\xB6\xBC\xB5\xBC\xBB\xB6\
    \xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\xB6\xBC\xB5\xBC\xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\
    \xBB\xAB\xB6\xBC\xB5\xBC\xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\xB6\xBC\xB5\xBC\
    \xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\xB6\xBC\xB5\xBC\xBB\xB6\xBB\xAB\xBB\xBC\
    \xBD\xBC\xBB\xAB\xB6\xBC\xB5\xBC\xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\xB6\xBC\
    \xB5\xBC\xBB\xB6\xBB\xAB\xBB\xBC\xBD\xBC\xBB\xAB\xB6\xBC\xB5\xBC\xBB\xB6\xBB\xAB\
    \xBB\xBC\xBD\xBC\xBB\xAB", "  count = 0\n  string.each do |char|\n    if !char.include?(char)\n\
    \      count += 1\n    end\n  end\n  return count\nend\np count_distinct_characters('abc')\n\
    p count_distinct_characters('ABCD')", "  string.split('').uniq.size\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,arrays |>\n<code>", "  string.split('').uniq.count\n\
    end", "\tstring = string.upcase\n\tstring.chars.uniq.length\nend", "  string.count(\"\
    a\") + string.count(\"b\") + string.count(\"c\") +\n  string.count(\"d\") + string.count(\"\
    e\") + string.count(\"f\") +\n  string.count(\"g\") + string.count(\"h\") + string.count(\"\
    i\") +\n  string.count(\"j\") + string.count(\"k\") + string.count(\"l\") +\n\
    \  string.count(\"m\") + string.count(\"n\") + string.count(\"o\") +\n  string.count(\"\
    p\") + string.count(\"q\") + string.count(\"r\") + string.count(\"s\") +\n  string.count(\"\
    t\") + string.count(\"u\") + string.count(\"v\") +\n  string.count(\"w\") + string.count(\"\
    x\") + string.count(\"y\") +\n  string.count(\"z\")\nend", "  string.downcase\n\
    \  string.split('').uniq.length\nend", "    string.downcase!\n    string.split(//).reduce(0)\
    \ { |count, rest| count + rest.count(rest.upcase) }\nend", "  count_array = string.split(\"\
    \").uniq.count\n  p count_array\nend", "  count = 0\n  string.each_char do |character|\n\
    \    if character.is_upper?\n      count += 1\n    elsif character.is_lower?\n\
    \      count += 1\n    end\n  end\n  count\nend\n</code>\n<|/ a tags=ruby dscore=1\
    \ |>\n<| a |>\n<code>\nstr = \"hello world\"\nstr.split(\"\").inject(0) { |a,\
    \ e| a + e.to_i }\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if the string contains Unicode chars. `str.gsub(/[^A-Z]/, \"\").split(\"\
    \").inject(0) { |a, e| a + e.to_i }` does.\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nAnother solution is using the each_char method of String class, which returns\
    \ a String with each character as an element:\n<code>\nstr.each_char.map(&:to_i).reduce(:+)\n\
    </code>\n<|/ a |>\n<| a dscore=0 tags=ruby |>\n<code>", "    characters = string.chars\n\
    \    characters_count = {}", "  string.split(//).inject(Hash.new(0), :merge).values.sort.reduce(:+)\n\
    end", "  string.downcase.split(//).uniq.size\nend", "  string.downcase.split('').uniq.size\n\
    end", "  string.chars.uniq.length\nend", "    return string.scan(/../).size\n\
    end", "  characters = string.split(//)\n  characters.inject(0) { |sum, character|\
    \ sum + character.upcase.count(\"A\"..\"Z\") + character.downcase.count(\"A\"\
    ..\"Z\") }\nend\n</code>\nNow, to count the number of words, a better approach\
    \ is to split the string on white spaces, trim each word and count how many words\
    \ there are:\n<code>", "  string.downcase.split(\"\").count { |char| !char.ascii_only?\
    \ }\nend", "  string.split(//).distinct.length\nend\n</code>\n<|/ a tags=ruby,string,regex\
    \ |>\n<| a |>\nI wanted to test the regex solution so I did a little benchmark:\n\
    <code>\nrequire 'benchmark'", "    string.downcase\n    string.scan(/[[:alpha:]]/)\n\
    \    string.count\nend", "  string.count(\"a\") + string.count(\"b\") + string.count(\"\
    c\") + string.count(\"d\") + string.count(\"e\") + string.count(\"f\") + string.count(\"\
    g\") + string.count(\"h\") +\n  string.count(\"i\") + string.count(\"j\") + string.count(\"\
    k\") + string.count(\"l\") + string.count(\"m\") + string.count(\"n\") + string.count(\"\
    o\") + string.count(\"p\") + string.count(\"q\") + string.count(\"r\") +\n  string.count(\"\
    s\") + string.count(\"t\") + string.count(\"u\") + string.count(\"v\") + string.count(\"\
    w\") + string.count(\"x\") + string.count(\"y\") + string.count(\"z\")\nend",
  "  string.split('').uniq.size\nend\n</code>\n<|/ a |>\n<| c |>\nThank you! I am\
    \ still a beginner so it is good to see different approaches!\n<|/ c |>\n<| c\
    \ |>\nI wouldn't use `split` here to begin with \u2014 it's probably going to\
    \ be slower for large strings than `each` with conditionals on `yield`.  It also\
    \ doesn't count characters like `\"a\".gsub(/./) { |c| c.upcase }.uniq.size` does,\
    \ which I think OP wanted (unless I misunderstood their question).\n<|/ c |>\n\
    <| c |>\nYou're absolutely right, I wasn't paying attention to what they wanted,\
    \ but this could be modified by either counting them or using the `string` method\
    \ `chars` to get the string's character count. Anyway, I used the `.split` method\
    \ just for the sake of the answer; it seems that `chars` is more efficient in\
    \ Ruby 2.0.\n<|/ c |>\n<| c |>\nYes, `chars` is more efficient.\n<|/ c |>\n<|\
    \ c |>\nHa, I wonder if that's only true in Ruby 2.0 - because `chars` is also\
    \ the most straightforward solution.  I assume that `chars` was optimized in 1.9.x,\
    \ but who knows? :)\n<|/ c |>\n<| a tags=string,ruby |>\n<code>", "  hash={}\n\
    \  string.split('').each do |letter|\n    if hash[letter.downcase]\n      hash[letter.downcase]\
    \ += 1\n    else\n      hash[letter.downcase] = 1\n    end\n  end\n  hash.keys.sort.each\
    \ do |letter|\n    puts \"#{letter} has #{hash[letter]} characters\"\n  end\n\
    end", "    string.downcase!\n    string.split(//).size\nend\n</code>\nThen you\
    \ can do:\n<code>\nputs count_distinct_characters(string)\n</code>\nThat will\
    \ give you the number of distinct characters in the string.\n<|/ a dscore=0 |>\n\
    <| c |>\nWhy use `split` and `downcase` when you can get the count directly with\
    \ `size`? The code is also cleaner by not creating a temporary array.\n<|/ c |>\n\
    <| c |>\n, it's just because I wanted to use the OP's original code for the example.\
    \ Also, the count can be calculated without converting to lower case, so `downcase`\
    \ is still a good idea. And yes, `size` is an easier way to get the count (I guess).\n\
    <|/ c |>\n<| c |>\nThe question was asking how many distinct characters there\
    \ are in a string, not how many distinct characters there are in a string.\n<|/\
    \ c |>\n<| c |>\n, oops, you're right. I didn't read it carefully enough. I'll\
    \ fix the answer.\n<|/ c |>\n<| a |>\nI came here looking for the same answer\
    \ and I thought I would share what I found. I don't know if this is what you were\
    \ looking for, but it may be helpful to others looking for an answer. \n<code>",
  "    string.downcase!\n    string.upcase!\n    return string.split('').uniq.length\n\
    end\n</code>\n<|/ a |>\n<| a |>\nIn ruby\n<code>\nstring.split(//).uniq.size\n\
    </code>\nThe split method splits a string into an array of substrings by splitting\
    \ with a regular expression. \nThe expression // in ruby is a regular expression\
    \ that matches empty string. \nThe uniq method returns a new array containing\
    \ all unique elements from the original array.\nThe size method returns the length\
    \ of an array. The size of the array returned by split is equal to the number\
    \ of substrings returned by split plus one.\n<|/ a dscore=5 tags=string,ruby |>\n\
    <| c |>\nthis answer is the only one that actually explains what `//` does. `//`\
    \ is a Regexp object and the `//` operator is used to match zero or more of any\
    \ character. Eg, `'foo'//` and `/foo/g` both return `'f'`.\n<|/ c |>\n<| a dscore=5\
    \ |>\nIn ruby you can use scan and count methods\n<code>\n'abc'.scan(/./).count\n\
    </code>\n<|/ a tags=string,ruby |>\n<| c |>\nI think this is a more ruby-like\
    \ way to answer this.\n<|/ c |>\n<| c |>\nIt might be an inefficient method (but\
    \ I think it's more idiomatic) than some of the other answers but it's certainly\
    \ not the most readable or concise.\n<|/ c |>\n<| c |>\nI agree, `split` method\
    \ looks better in this case, it's more expressive.\n<|/ c |>\n<| c |>\nI like\
    \ how `scan` and `count` don't require an additional argument to pass in an empty\
    \ string.\n<|/ c |>\n<| c |>\nIt's probably less efficient than the `split` method\
    \ because it creates an array instead of just returning an integer. It also doesn't\
    \ include the delimiter in the output.\n<|/ c |>\n<| a |>\n<code>\nString.length\n\
    </code>\n<|/ a dscore=5 tags=string,ruby |>\n<| c |>\nThe question is asking for\
    \ a method that determines the number of distinct characters, not just the length.\n\
    <|/ c |>\n<| c |>\nI believe that the number of distinct characters is the same\
    \ as the number of distinct substrings. E.g. `'foobar'.length == String.length('foobar')\
    \ == String.count('obar') == 5`\n<|/ c |>\n<| c |>\nI'm pretty sure that's not\
    \ what OP wants.\n<|/ c |>\n<| c |>\nOh dear. I missed the distin", "  string.downcase!\n\
    \  string.count(\"#{'a'..'z'}\")\nend", "  array.uniq.inject(0) { |count, _| count\
    \ + 1 if string =~ /#{Regexp.escape($_)}/ }\nend", "  string.scan(/./).uniq.size\n\
    end\n</code>\nThis also uses scan instead of scan to remove duplicates, since\
    \ scan is more efficient.\n<|/ a tags=ruby,algorithm,ruby-on-rails dscore=1 |>\n\
    <| c |>\nThis will not work, since `string.scan(/./).uniq.size` returns `6` for\
    \ the string `\"abc\"`, where `uniq` returns `[\"a\", \"b\", \"c\"]`.  That means\
    \ your solution would return `3` for the string `\"abc\"`, when it should return\
    \ `4`\n<|/ c |>\n<| a dscore=1 |>\n<code>", "    letters = {}\n    string.each_char\
    \ do |char|\n        if letters[char] == nil\n            letters[char] = 1\n\
    \        else\n            letters[char] += 1\n        end\n    end\n    return\
    \ letters.count - 1 # return all letters except the first one\nend\n</code>\n\
    Testing the first function:\n<code>\n>> count_distinct_characters \"aaaaaaa\"\n\
    => 3\n</code>\nTesting the second function:\n<code>\n>> count_distinct_characters\
    \ \"aaaaaaaa\"\n=> 7\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the response\
    \ - I'm looking at some of my other functions and trying to understand how they\
    \ work. I think the last part is what I'm struggling with\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,hash |>\n<code>", "  string.downcase.chars.uniq.size\nend", "    string.downcase!\n\
    \    string.gsub(/[^A-Z]/, '')\n    string.count('a')\nend\n</code>\n<|/ a |>\n\
    <| a dscore=1 tags=ruby,ruby-on-rails |>\n<code>", "  string.split('').inject(0)\
    \ { |count, letter| count + (letter =~ /[[:upper:]]|[[:lower:]]/) ? 1 : 0 }\n\
    end", "  count = Hash.new(0)\n  string.each_char do |c|\n    count[c] += 1\n \
    \ end\n  count\nend", "  string.downcase.split(\"\").uniq.size\nend", "  string.downcase\n\
    \  string.count('a')..string.count('z')\nend", "  string.split(//).uniq.length\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThe first example doesn't work. String#split\
    \ returns an array and you cannot call #uniq on an array.\n<|/ c |>\n<| a |>\n\
    For those who are interested, below is how I figured it out after reading the\
    \ answers above and other answers.\n<code>", "  string.downcase!\n  string.split(//).uniq.size\n\
    end", "  string.split(//).uniq.size\nend", "    hash = {}\n    string.split(\"\
    \").each do |char|\n        if hash[char].nil?\n            hash[char] = 1\n \
    \       else\n            hash[char] += 1\n        end\n    end\n    return hash.keys.uniq.size\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhy do you use `string.split(\"\").each`?\n\
    <|/ c |>\n<| c |>\nto handle empty strings\n<|/ c |>\n<| c |>\nI don't think this\
    \ answers the question, please see my comment on the accepted answer\n<|/ c |>\n\
    <| a dscore=3 |>\nI wrote an algorithm that generates the answer to the question\
    \ \"What is the smallest set of characters that will generate a unique hash?\"\
    \ from all of the answers here. The solution relies on the \"uniqueness of hashes\"\
    \ property of dictionaries. If a hash contains all unique elements, then its uniqueness\
    \ property is trivially satisfied for equal dictionaries with just one exception:\
    \ one element of the dictionary must be different. In particular, the element\
    \ must occur twice in the set of hashes.\nTo generate this set of hashes, I started\
    \ with a string consisting of all distinct characters and repeated it until there\
    \ was one character left that didn't appear in the original string. Then, I used\
    \ this character as the key and the number of repetitions as its value. So, the\
    \ key would be all distinct characters and the value would be the number of repetitions.\
    \ At this point, I could count how many characters were left in the string. Next,\
    \ I used the characters that were in the string as keys and the integer count\
    \ of repetitions as their values. Then, I would iterate over the keys and increment\
    \ the values with each iteration. Finally, I would take only those pairs that\
    \ have values that are greater than or equal to 2. \n<code>", "    string.downcase!\n\
    \    chars = string.split(//)\n    chars.uniq.size\nend", "  count = {}\n  string.split('').each\
    \ { |char| count[char] = count[char].to_i + 1 }\n  count.values.uniq\nend", " \
    \ string.count(\"a\".ord) + string.count(\"b\".ord) + string.count(\"c\".ord)\
    \ + string.count(\"d\".ord) + string.count(\"e\".ord) + string.count(\"f\".ord)\
    \ + string.count(\"g\".ord) + string.count(\"h\".ord) + string.count(\"i\".ord)\
    \ + string.count(\"j\".ord) + string.count(\"k\".ord) + string.count(\"l\".ord)\
    \ + string.count(\"m\".ord) + string.count(\"n\".ord) + string.count(\"o\".ord)\
    \ + string.count(\"p\".ord) + string.count(\"q\".ord) + string.count(\"r\".ord)\
    \ + string.count(\"s\".ord) + string.count(\"t\".ord) + string.count(\"u\".ord)\
    \ + string.count(\"v\".ord) + string.count(\"w\".ord) + string.count(\"x\".ord)\
    \ + string.count(\"y\".ord) + string.count(\"z\".ord)\nend", "  count = 0\n  string.each_char\
    \ do |char|\n    unless char.upcase == char\n      count += 1\n    end\n  end\n\
    \  count\nend", "  string.split('').uniq.size\nend", "  string.chars.uniq.size\n\
    end", "  count = {}\n  string.each_char.map { |c| count[c] = count.has_key?(c)\
    \ ? count[c] + 1 : 1 }\n  count.values.uniq\nend", "  string.split('').uniq.count\n\
    end", "  string.split('').uniq.length\nend", "  new_string = ''\n  for i in string.split(//)\n\
    \    new_string << i.downcase\n  end\n  new_string.size\nend", "  string.scan(/./).count\n\
    end", "  return string.split(//).uniq.size\nend", "  string.scan(/./).length\n\
    end", "  unique = string.split(\"\").uniq\n  unique.size.to_i\nend", "    char_count\
    \ = Hash.new(0)\n    string.each_char do |char|\n        char_count[char] += 1\n\
    \    end\n    char_count.reject{ |k, v| v > 1 }.size\nend", "  # Initialize a\
    \ character hash map with 0 values\n  character_hash = Hash.new(0)\n  # Iterate\
    \ over the string\n  string.chars.each do |character|\n    # Update character\
    \ hash with character as key and 1 as value\n    character_hash[character] +=\
    \ 1\n  end\n  # Return the hash value\n  character_hash.values.max\nend", "  \
    \  string.split(//).uniq.size\nend", "  chars = string.split('')\n  chars.each_with_index\
    \ { |c, i| putc c if chars.count(c) > 1 }\nend", "  distinct_characters = 0\n\
    \  string = (string).downcase\n  string.each_byte do |character|\n    if string\
    \ =~ /#{character.upcase}/\n      distinct_characters += 1\n    end\n  end\n \
    \ distinct_characters\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex |>\n\
    <| a dscore=0 |>\nThis solution finds out the number of distinct letters in string.\
    \ Notice, the count is different than the number of distinct letters in string.\
    \ \n<code>", "  string.split(//).uniq.size\nend\n</cell>\n<code language=julia-0.6>",
  "    count = 0\n    chars = []\n    string.split(//).each do |char|\n        if\
    \ char.downcase == char.upcase #ignore case\n            count += 1\n        \
    \    chars << char\n        end\n    end\n    chars.uniq.length\nend", "    return\
    \ string.split('').uniq.count\nend", "  string.split(//).reduce(:+)\nend", " \
    \ string.downcase.split('').sort.uniq.size\nend", "    count = 0\n    string.split(//).each\
    \ { |x| count += 1  if x !~ /[A-Z]/i  }\n    count\nend", "\tstring.scan(/\\w/).length\n\
    end", "  string.downcase!\n  string.scan(/./).count\nend", "  count = 0\n  string.each_byte\
    \ do |character|\n    if case character\n    when 'a'..'z' then count += 1\n \
    \   when 'A'..'Z' then count += 1\n    when '0'..'9' then count += 1\n    else\
    \ raise \"Unexpected case\"\n    end\n  end\n  count\nend\n</code>\nBut that would\
    \ be a lot of work. \nLet's try out an easy way:\n<code>", "  count = 1\n  string.each_char\
    \ do |character|\n    count = count + 1 if string.include?(character)\n  end\n\
    \  count\nend\n</cell>\n<cell>", "    chars = string.split(//)\n    chars.count\
    \ { |c| c != '-' }\nend\n</code>\nThen, just call that method whenever you need\
    \ the result\n<code>\ncount_distinct_characters(\"this-is-a-test-string\")", " \
    \ string.split('').inject(0) { |t,x| t + (x.downcase.count('a') + x.downcase.count('e')\
    \ + x.downcase.count('i') + x.downcase.count('o') + x.downcase.count('u') + x.downcase.count('\xF1\
    ') + x.downcase.count('\xE1') + x.downcase.count('\xED') + x.downcase.count('\xF3\
    ') + x.downcase.count('\xFA')) }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nIt\
    \ returns 0 on `abc 123` instead of 4.\n<|/ c |>\n<| c |>\nThis is wrong. Try\
    \ running it on `abc 123`.\n<|/ c |>\n<| c |>\nI checked the answer, but I do\
    \ not see any problem with the code. Can you point it out? Thanks!\n<|/ c |>\n\
    <| c |>\nThis is not right. It returns `4` for `abc 123`\n<|/ c |>\n<| c |>\n\
    Thanks for reporting it! It was fixed a few hours ago, I forgot to update my answer,\
    \ I updated the answer with the code I was testing with.\n<|/ c |>\n<| a dscore=4\
    \ |>\nUse this ruby code:\n<code>", "    string.downcase!\n    string.scan(/\\\
    w/).length\nend", "  string.split('').inject(0) {|counts, char| counts << char.ord\
    \ }\nend", "  # initialize empty array of counts\n  count_array = Array.new(26,\
    \ 0)", "  string.downcase!\n  string.split(//).uniq.size\nend", "  count = 0\n\
    \  string.downcase!\n  string.each_char do |char|\n    if char.upcase != char\n\
    \      count += 1\n    end\n  end\n  count\nend", "  string.downcase.gsub(/[[:upper:]]/).length\n\
    end", "\tstring.split(\"\").uniq.size\nend", "  string.downcase!\n  string.gsub(/[[:alpha:]]/).count\n\
    end\n</code>\n<|/ a dscore=2 tags=ruby,algorithm,string |>\n<| a |>\nRuby's Enumerable#uniq\
    \ method can do this:\n<code>\n'abcd'.split('').uniq", "  string.split(//).map(&:downcase).uniq.size\n\
    end", "  return string.split('').uniq.count\nend", "  string.length.times.map\
    \ { string.chars.uniq.size }\nend", "  return string.scan(/./).flatten.uniq.size\n\
    end", "  chars = string.split(//)\n  count = chars.inject(0) do |sum, char|\n\
    \    sum += char.upcase.size + char.downcase.size\n  end\n  count\nend", "   \
    \ distinct_chars = string.chars.to_a\n    distinct_chars.uniq.size\nend", "  string\n\
    \    .each_char.uniq.count\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nHere's a\
    \ solution using regex and ruby 2.\n<code>\nstring = \"hello\"\nstring.split(\"\
    \").map{|e| e.downcase}.uniq.length\n</code>\n<|/ a tags=ruby,string,algorithm\
    \ |>\n<| a |>\nI like using regex for this sort of thing as I find it easier to\
    \ read.\n<code>\n'abc'.match(/[^a-z]/).count\n</code>\n<|/ a tags=ruby,string,algorithm\
    \ dscore=2 |>\n<| a dscore=2 tags=ruby,string,algorithm |>\nIn Javascript, you\
    \ can use the following:\n<code>\nfunction countDistinct(str) {\n    return str.split('').filter(function(e){\n\
    \        return e == e.toUpperCase() || e == e.toLowerCase();\n    }).length;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>", "  count = 0\n  string.gsub(/[[:upper:]]/)\
    \ {count += 1; ''}\n  string.gsub(/[[:lower:]]/) {count += 1; ''}\n  string.gsub(/[^[:upper:]-[[:upper:]]]/)\
    \ {count += 1; ''}\n  string.gsub(/[^[:lower:]-[[:lower:]]]/) {count += 1; ''}\n\
    \  string.gsub(/[[:punct:]]/) {count += 1; ''}\n  string.gsub(/[[:space:]]/) {count\
    \ += 1; ''}\n  string.gsub(/[-_]/) {count += 1; ''}\n  string.gsub(/[^A-Za-z0-9]/)\
    \ {count += 1; ''}\n  count\nend", "  string = string.downcase\n  count = 0\n\
    \  string.each_char do |char|\n    count = (count + 1) if char.upcase != char\n\
    \  end\n  count\nend\n</cell>\n<cell>", "  string.split(//).uniq.count\nend",
  "  string.split('').uniq.size\nend", "  count_array = []\n  string.each_char do\
    \ |char|\n    if count_array.include? char\n      count_array[char] += 1\n   \
    \ else\n      count_array << char\n    end\n  end\n  count_array.uniq.length\n\
    end", "  return string.split('').uniq.size\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=ruby |>\n<code>\n def count_distinct_characters(string)\n  string.split('').uniq.size\n\
    \ end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYour answer would be better if you\
    \ explained how it works, and why it is more efficient than other solutions.\n\
    <|/ c |>\n<| c |>\nI agree with. I don't think there is anything better than `string.split('').uniq.size`.\
    \ `uniq` will do that by itself.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  string.downcase.split('').uniq.count\n\
    end", "  string.split(//).map(&:downcase).count\nend", "  string.downcase!\n \
    \ string.gsub(/[^a-z]+/i, \"\").length\nend", "  string.count(\"a\") + string.count(\"\
    b\") + string.count(\"c\") + string.count(\"d\")\nend", "  string.chars.uniq.count\n\
    end", "  string.split(\"\").uniq.size\nend", "  count = 0\n  string.each_byte\
    \ do |c|\n    if c == string\n      count += 1\n    elsif c.upcase == c\n    \
    \  count += 1\n    end\n  end\n  count\nend\n</code>\nThis can be further optimized\
    \ by only comparing characters in the same case, but that would require some additional\
    \ work.\n<|/ a tags=ruby,string |>\n<| c |>\nThe idea of counting distinct characters\
    \ came to my mind first as a very smart way to solve the problem. But, of course,\
    \ the string can have duplicate characters. That is the key concern here. Thanks\
    \ for the idea!\n<|/ c |>\n<| a tags=ruby,string |>\nYou can use each_char for\
    \ this:\n<code>\nstring.each_char.uniq.length\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nIt should be noted that this has `O(N)` performance since it iterates\
    \ through each character in the string. On the other hand, this solution might\
    \ be the most readable one and easy to understand.\n<|/ c |>\n<| c |>\nAgreed,\
    \ this is a great option for very short strings. But it becomes unusable for longer\
    \ strings.\n<|/ c |>\n<| c |>\n`each_char.uniq.size` would be a good alternative\
    \ for longer strings. `uniq` makes a copy of the array, so if the string has repeated\
    \ characters, it creates a new array.\n<|/ c |>\n<| c |>\n`each_char.uniq.size`\
    \ is better than `count` because it does not iterate over the entire string and\
    \ count its characters. Thanks!\n<|/ c |>\n<| c |>\nThis is an awesome solution\
    \ if you just need a simple count without having to keep track of the distinct\
    \ values.\n<|/ c |>\n<| a |>\nYou can get distinct characters by using regular\
    \ expression:\n<code>\nstring.scan(/[[:alpha:]]/).size\n</code>\n<|/ a tags=ruby,string\
    \ dscore=5 |>\n<| c |>\nWhile `scan` is fine for this simple example, its performance\
    \ may suffer significantly if there are a lot of distinct characters.\n<|/ c |>\n\
    <| c |>\nthis won't work correctly in some cases: for example `\"\xD6\".scan(/[[:alpha:]]/).size`\
    \ returns `4` instead of `2`\n<|/ c |>\n<| c |>\nThis may or may not work depending\
    \ on your encoding. [See this answer](http://stackoverflow.com/a/6351466/15498)\n\
    <|/ c |>\n<| ", "  string.split('').uniq.count\nend", "  count = {}\n  string.split(//).each\
    \ do |c|\n    count[c] = count[c].nil? ? 1 : count[c] + 1\n  end\n  count.values\n\
    end", "    count = []\n    string = string.upcase\n    string.each_char do |char|\n\
    \        if count.include?(char) = true\n        else = false\n            count.push(char)\n\
    \        end\n    end\n    count\nend\n</code>\n<|/ a |>\n<| c |>\nI do not think\
    \ you are using Ruby 1.9.  I did a quick test with 1.8.7 and it does not seem\
    \ to have `.upcase` on strings. Try using `.capitalize` instead (http://ruby-doc.org/core/classes/String.html#M002289)\n\
    <|/ c |>\n<| c |>\nUpcase was added in Ruby 1.9, I ran it on 1.8.7 and it worked\
    \ fine.\n<|/ c |>\n<| a tags=string,ruby dscore=1 |>\n<code>", "  string.count(\"\
    a\") + string.count(\"e\") + string.count(\"i\") + string.count(\"o\") + string.count(\"\
    u\")\nend", "  string.downcase.split('').uniq.size\nend\n</code>\nThe first code\
    \ block will return the correct result for the following input strings:\n<code>\n\
    count_distinct_characters('heLLO WORLD')\n=> 6", "  string.downcase!\n  string.scan(/./).inject(0)\
    \ { |count, _| count + 1 }\nend", "    unique_characters = []\n    string.each_char\
    \ do |char|\n        unless unique_characters.include? char\n            unique_characters\
    \ << char\n        end\n    end\n    unique_characters.uniq.size\nend", "  string.split('').uniq.size\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if the string has duplicate\
    \ characters, like \"aasssss\".\n<|/ c |>\n<| c |>\nIn that case, you should use\
    \ something like `string.length.to_a` and count the unique elements of the array.\
    \ I can post that as another answer if you'd like.\n<|/ c |>\n<| a dscore=2 |>\n\
    Here's another solution, more efficient, but using two helper methods instead\
    \ of one:\n<code>", "  char_count = {}\n  string.each_char do |char|\n    char_count[char.to_s]\
    \ = char_count.has_key?(char.to_s) ? char_count[char.to_s].to_i + 1 : 1\n  end\n\
    \  char_count.select{|k,v| v > 1}\nend", "  unique_characters = string.downcase.split(//).uniq.size\n\
    \  unique_characters.nil? ? 0 : unique_characters\nend\n</cell>\n<cell>\ncount_distinct_characters(string)\n\
    </cell>\n<text>\nLet's write a method count_distinct_characters? that returns\
    \ true if there is an uppercase letter and a lowercase letter, otherwise false.\
    \ We will use this method later in the function.", "  return string.count(string.downcase)\n\
    end", "  count_distinct_characters = Hash.new(0)\n  string.each_char.map { |character|\
    \ count_distinct_characters[character.downcase] += 1 }\n  count_distinct_characters[nil]\n\
    end", "  string.chars.to_a.map(&:uniq.size).inject(:+)\nend", "  string.downcase.split(//).map\
    \ { |e| e.ord }.count\nend\n</code>\n<|/ a |>\n<| c |>\nFor Ruby 1.8.7, you could\
    \ replace `string.downcase.split(//)` with `string.scan(//)`. That would give\
    \ the same results.\n<|/ c |>\n<| c |>\nI like the scanning option. Much more\
    \ elegant.\n<|/ c |>\n<| c |>\nHow does this work? What are the //'s doing?\n\
    <|/ c |>\n<| c |>\n`//` is [Regexp#split](http://www.ruby-doc.org/core-2.1.1/Regexp.html#method-i-split)\
    \ which splits a string using regular expressions. `//` matches any character\
    \ `\"\"`. Thus it splits the string into an array of characters. Then `count`\
    \ is called on the array to get its length so `string.downcase.split(//).map {\
    \ |e| e.ord }.count` would give the same result as `string.scan(//).count`.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>\nrequire 'set'", "  string.split('').uniq.size\n\
    end", "  string.split('').uniq.size\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
