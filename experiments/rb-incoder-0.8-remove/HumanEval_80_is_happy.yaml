name: HumanEval_80_is_happy
language: rb
prompt: "# You are given a string s.\n# Your task is to check if the string is happy\
  \ or not.\n# A string is happy if its length is at least 3 and every 3 consecutive\
  \ letters are distinct\n# For example:\ndef is_happy(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_happy\n\
  \    candidate = method(:is_happy)\n    assert_equal(false, candidate.call(\"a\"\
  ))\n    assert_equal(false, candidate.call(\"aa\"))\n    assert_equal(true, candidate.call(\"\
  abcd\"))\n    assert_equal(false, candidate.call(\"aabb\"))\n    assert_equal(true,\
  \ candidate.call(\"adb\"))\n    assert_equal(false, candidate.call(\"xyy\"))\n \
  \   assert_equal(true, candidate.call(\"iopaxpoi\"))\n    assert_equal(false, candidate.call(\"\
  iopaxioi\"))\n  end\nend\n"
completions: ["    # Write your code here\n    return s.length >= 3 and s.chars.combination(3).all?\
    \ { |c| c.to_a.uniq.size <= 3 }\nend\n</cell>\n<code language=other-env>\nassert_equals(is_happy(\"\
    yes\"), true)\nassert_equals(is_happy(\"no\"), false)\nassert_equals(is_happy(\"\
    yes2\"), false)\nassert_equals(is_happy(\"yes2\"), true)\nassert_equals(is_happy(\"\
    yes12\"), false)\n</cell>\n<text>\n2.3 String substitution", "  return true if\
    \ s.length >= 3 and every 3 consecutive letters are distinct\n  return false\n\
    end", "  str.length >= 3 and str.length % 3 ==0 and \n\ts.uniq.each_char.each_cons(3).all?{|i|\
    \ i.length == 3 }\nend\nassert is_happy('abcabcbb')\nassert !is_happy('bbbbb')\n\
    assert !is_happy('abba')\nassert is_happy('loveleetcode')\nassert is_happy('PEPE')\n\
    assert !is_happy('')\nassert is_happy('abba')\n</cell>\n<cell>", "  happy = true\n\
    \  s.each do |letter|\n    if letter == s[0..2]\n      next if letter == s[2..4]\n\
    \      next if letter == s[4..6]\n      next if letter == s[6..8]\n      next\
    \ if letter == s[8..10]\n      next if letter == s[10..12]\n      next if letter\
    \ == s[12..14]\n      next if letter == s[14..16]\n      next if letter == s[16..18]\n\
    \      next if letter == s[18..20]\n      next if letter == s[20..22]\n      next\
    \ if letter == s[22..24]\n      next if letter == s[24..26]\n      next if letter\
    \ == s[26..28]\n      next if letter == s[28..30]\n      next if letter == s[30..32]\n\
    \      next if letter == s[32..34]\n      next if letter == s[34..36]\n      next\
    \ if letter == s[36..38]\n      next if letter == s[38..40]\n      next if letter\
    \ == s[40..42]\n      next if letter == s[42...44]\n      next if letter == s[44..46]\n\
    \      next if letter == s[46..48]\n      next if letter == s[48..50]\n      next\
    \ if letter == s[50..52]\n      next if letter == s[52..54]\n      next if letter\
    \ == s[54..56]\n      next if letter == s[56..58]\n      next if letter == s[58..60]\n\
    \      next if letter == s[60..62]\n      next if letter == s[62..64]\n      next\
    \ if letter == s[64..66]\n      next if letter == s[66..68]\n      next if letter\
    \ == s[68..70]\n      next if letter == s[70..72]\n      next if letter == s[72..74]\n\
    \      next if letter == s[74..76]\n      next if letter == s[76..78]\n      next\
    \ if letter == s[78..80]\n      next if letter == s[80..82]\n      next if letter\
    \ == s[82..84]\n      next if letter == s[84..86]\n      next if letter == s[86..88]\n\
    \      next if letter == s[88..90]\n      next if letter == s[9", "    # your\
    \ code here\n    count = 0\n    arr = s.split('')\n    for i in range(0, len(arr)\
    \ - 3):\n        if arr[i] == arr[i + 1] == arr[i + 2]:\n            count +=\
    \ 1\n    if count >= 3:\n        return True\n    else:\n        return False",
  "  s.downcase!\n  s.length >= 3\n  s.split('').each_cons(3).all? do |letters|\n\
    \    letters.uniq.size == 3\n  end\nend\n</code>\n<|/ a tags=string,ruby |>\n\
    <| a dscore=1 |>\n<code>", "    \n    # Write your condition here\n    \n    #\
    \ If the condition was met return 'True'\n    return 'True'\n    \n</cell>\n<text>\n\
    Solution\nHere we use a list comprehension to check if the condition is met.",
  "  return true if s.length >= 3 && s.chars.uniq.length >= 3\n  return false\nend",
  "  return s.length >= 3 and s.chars.each_cons(3).all? { |x| x.uniq.size == 1 }\n\
    end\nputs is_happy(\"haha\")", "  \nend", "    # Write your code here\n    \n\
    \    \n    \n    #return happy\n    ", "  s.size >= 3 && s.chars.sort.uniq.size\
    \ == 3 # or s.chars.sort.uniq.length == 3\nend", "  strings = split(s, 3)\n  string\
    \ = strings[0]\n  unique = [string]", "  return s.length >= 3 and s.each_char.uniq.length\
    \ == 3\nend", "  s = s.split('')\n  s.each do |char|\n    puts \"#{char} is happy\"\
    \ if s.count == 3 && s[0..3].uniq.length == 3\n  end\nend", "  return s.length\
    \ >= 3 and s.chars.uniq.count == 3\nend\n</pre>", "    s.size==3 or s.chars.sort.uniq.count{|c|\
    \ c==s.chars[0]} or s.chars.sort.uniq.count{|c| c==s.chars[1]} or s.chars.sort.uniq.count{|c|\
    \ c==s.chars[2]}\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nAren't you doing a\
    \ lot of `.size` when `s` is a `String` and not an array? You just need `s.length`\
    \ and that's it. `s` doesn't have `.size`\n<|/ c |>\n<| c |>\nNope, `s.length`\
    \ is more efficient. Ruby doesn't need to keep checking the size of the string\
    \ for each and every character in the loop.\n<|/ c |>\n<| a |>\nI came up with\
    \ this solution that is similar to the one from Ben Smet, but uses inject and\
    \ each_char to iterate through the string's characters. \n<code>", "  \n  # TODO:\
    \ Write your code here\n  s.size >= 3 and s.chars.uniq.size % 3 == 0\nend", " \
    \ if s.length < 3 then return false\n  for i in 1..s.length do\n    if s[i-1]\
    \ == s[i-2] && s[i-2] == s[i-3] then return false\n  end\n  return true\nend",
  "    count = 0\n    length = len(s)\n    if length > 3 and length >= 3 and s.chars.all?\n\
    \            s.chars.each { |i| if i == i }\n            count += 1\n        \
    \    s.chars.each { |i| if i == i }\n            count += 1\n            s.chars.each\
    \ { |i| if i == i }\n            count += 1\n            s.chars.each { |i| if\
    \ i == i }\n            count += 1\n            s.chars.each { |i| if i == i }\n\
    \            count += 1\n            s.chars.each { |i| if i == i }\n        \
    \    count += 1\n            s.chars.each { |i| if i == i }\n            count\
    \ += 1\n            s.chars.each { |i| if i == i }\n            count += 1\n \
    \           s.chars.each { |i| if i == i }\n            count += 1\n         \
    \   s.chars.each { |i| if i == i }\n            count += 1\n            s.chars.each\
    \ { |i| if i == i }\n            count += 1\n            s.chars.each { |i| if\
    \ i == i }\n            count += 1\n            s.chars.each { |i| if i == i }\n\
    \            count += 1\n            s.chars.each { |i| if i == i }\n        \
    \    count += 1\n            s.chars.each { |i| if i == i }\n            count\
    \ += 1\n            s.chars.each { |i| if i == i }\n            count += 1\n \
    \           s.chars.each { |i| if i == i }\n            count += 1\n         \
    \   s.chars.each { |i| if i == i }\n            count += 1\n            s.chars.each\
    \ { |i| if i == i }\n            count += 1\n            s.chars.each { |i| if\
    \ i == i }\n            count += 1\n            s.chars.each { |i| if i == i }\n\
    \            count += 1\n            s.chars.each { |i| if i == i }\n        \
    \    count += 1\n            s.chars.each { |i| if i == i }\n            count\
    \ += 1\n            s.chars.each { |i| if i == i }\n            count += 1\n \
    \           s.chars.each { |i| if i == i }\n            count += 1\n         \
    \   s.chars.each { |i| if i == i }\n            count += 1\n            s.chars.each\
    \ { |i| if i == i }\n            count += 1\n            s.chars.each { |i| if\
    \ i == i }\n            count += 1\n            s.chars.each { |i| if i == i }\n\
    \            count += 1\n", "  return true if s.count >= 3 and s.split('').uniq.count\
    \ == s.length\nend\n</pre>\n<p>\n  Note the <code>.count</code> in the first line\
    \ of the function.\n  The <code>.count</code> will give you the number of elements\
    \ in the string.\n</p>\n<pre class=\"ruby\"><span class=\"ruby-identifier\">is_happy?</span>\
    \  <span class=\"ruby-identifier\">s</span>=<span class=\"ruby-value\">'azcbobobegghakl'</span>\
    \  <span class=\"ruby-comment\">#=&gt; false</span>\n<span class=\"ruby-identifier\"\
    >is_happy?</span>  <span class=\"ruby-identifier\">s</span>=<span class=\"ruby-value\"\
    >'azcbobegghakl'</span>  <span class=\"ruby-comment\">#=&gt; true</span>\n</pre>\n\
    <p>\n  In the second line, Ruby first splits the string into individual characters\
    \ and then\n  counts the number of characters (using <code>.count</code>).\n \
    \ So <code>s.split('').uniq.count == s.length</code> is true because there are\n\
    \  only five unique characters.\n</p>\n<pre class=\"ruby\"><span class=\"ruby-identifier\"\
    >is_happy?</span>  <span class=\"ruby-identifier\">s</span>=<span class=\"ruby-value\"\
    >'bob'</span>  <span class=\"ruby-comment\">#=&gt; true</span>\n<span class=\"\
    ruby-identifier\">is_happy?</span>  <span class=\"ruby-identifier\">s</span>=<span\
    \ class=\"ruby-value\">'bobob'</span>  <span class=\"ruby-comment\">#=&gt; false</span>\n\
    </pre>\n<p>\n  Ruby also has a built-in <code>.split</code> method, which splits\
    \ a string into\n  individual elements.  In this example, Ruby first splits the\
    \ string into individual\n  characters and then puts them into an array.  Finally,\
    \ <code>.uniq</code> filters out\n  duplicate elements and <code>.length</code>\
    \ counts the number of elements in the array:\n</p>\n<pre class=\"ruby\"><span\
    \ class=\"ruby-identifier\">is_happy?</span>  <span class=\"ruby-identifier\"\
    >s</span>=<span class=\"ruby-value\">'azcbobobegghakl'</span>  <span class=\"\
    ruby-comment\">#=&gt; true</span>\n<span class=\"ruby-identifier\">is_happy?</span>\
    \  <span class=\"ruby-identifier\">s</span>=<span class=\"ruby-value\">'azcbobegghakl'</span>\
    \  <span class=\"ruby-comment\">#=&gt; true</span>\n<span class=\"ruby-identifier\"\
    >is_happy?</span>  <span class=\"ruby-identifier\">s</span>=<span class=\"ruby-value\"\
    >'bob'</span>  <span class=\"ruby-comment\">#=&gt; true</span>\n<span class=\"\
    ruby-identifier\">is_happy?</span>  <span class=\"ruby-identifier\">s</span>=<span\
    \ class=\"", "  if s.length >= 3\n    s.each_char.map { |c| c}.uniq.size == s.length\n\
    \  else\n    false\n  end\nend", "    s = s.downcase\n    return s.length >= 3\
    \ and (s.length % 3) == 0 && (s.chars.uniq.count > 0)\nend\n</pre>", "    # write\
    \ your code in Ruby\nend", "  puts s.split('').inject(true) { |bool, s| bool &&\
    \ (s.size == 3 && s.all? { |c| c.match(/\\p{Alnum}/) }) }\nend\nis_happy(\"happy\"\
    )\nis_happy(\"HAPPY\")\nis_happy(\"happy\")\nis_happy(\"HAPPY\")", "    # write\
    \ your code here\n    return s[0..-2] == s[0..-2][0..-2]\nend\nprint(is_happy(\"\
    happy\"))\nprint(is_happy(\"happyp\"))\nprint(is_happy(\"happyppy\"))\nprint(is_happy(\"\
    happypppy\"))\n</cell>\n<text>\n13. Given a string, return true if the string\
    \ contains any permutation of the characters in \"AEIOUY\", otherwise return false.\n\
    Example:\nInput: \"ABCD\"\nOutput: true", "  s = s.to_s\n  s.to_s.length >= 3\
    \ && s.chars.uniq.length == 3 && s.chars.uniq.size == 3\nend", "    l = s.split(//)\n\
    \    l.reduce(&:+).to_i <= 3\nend", "  s.chars.each_cons(3).all? {|s| s.any? {|c|\
    \ c.is_a?(String) && c.length >= 3 && c.count(c) > 1 }}\nend", "  # Handle edge\
    \ cases when s is nil or ''\n  return false if !s || s.empty?", "  return s.length\
    \ >= 3 and s.chars.uniq.count == 3\nend\n</cell>\n<code language=julia-1.4>\n\
    is_happy(\"Happy\")\n</cell>\n<code language=julia-1.4>\nis_happy(\"Happy Hour\"\
    )\n</cell>\n<code language=julia-1.4>\nis_happy(\"Happy Hour Happy\")\n</cell>\n\
    <code language=julia-1.4>\nis_happy(\"Happy Hour Happy Hour\")\n</cell>\n<text>\n\
    4.3 String Concatenation\nTask\nGiven two strings s1 and s2 of equal length, return\
    \ a string that concatenates s1 and s2 delimited by a space (\" \").", "  return\
    \ s.size>=3 and s.chars.all? {|x| s.count(x)==3}\nend", "  result = []\n  i =\
    \ 0\n  while i < s.length\n    # Skip the letter 's' in the string\n    i += 1\n\
    \    # Get the letter at position i to test\n    char = s[i]\n    if s.length\
    \ >= 3\n      # If it is distinct.\n      if s.count(char) > 1\n        # Add\
    \ the letter to the result\n        result.push(char)\n      end\n    end\n  end",
  "    s.length >= 3 && s.chars.all?(&:uniq == true)\nend\n</code>\n<|/ a |>\n<| a\
    \ tags=string,ruby,arrays,methods |>\n<code>", "    # your code goes here\n  \
    \  return ((s.length >= 3) and (s.group_by{|x| x}.length == s.length))\nend\n\
    </cell>\n<code language=julia-0.5>\nis_happy(\"awesome\")\n</cell>\n<text>\nExercise\
    \ 11 - Happy Numbers", "  if s.length < 3 || s.length > 3\n    return false\n\
    \  end", "  l = s.length\n  happiness = 0\n  \n  while l > 3\n    if s[l-3] ==\
    \ s[l-2] == s[l-1]\n      happiness += 1\n    end\n    l -= 1 \n  end\n  \n  \n\
    \  if l == 3 and happiness == 3\n    return true\n  else\n    return false\n \
    \ end\nend", "  str_length = s.length\n  if str_length < 3\n    return false\n\
    \  else\n    arr = s.split(\"\")\n    is_happy = true\n    arr_length = arr.length\n\
    \    for num in 0...arr_length-1\n      if arr[num] == arr[num+1] or arr[num]\
    \ == arr[num+2]\n        is_happy = false\n      end\n    end\n    return is_happy\n\
    \  end\nend", "  # return true if s is happy\n  return s.length >= 3 and s.chars.uniq.size\
    \ == 3\nend", "  if s.empty? or s.length < 3\n    return false\n  end\n  \n  hap_letters\
    \ = Hash.new { |h, k| h[k] = [] }\n  s.chars.each do |c|\n    hap_letters[c] <<\
    \ c\n  end\n  hap_letters.each do |c, letters|\n    return true if letters.length\
    \ > 1 and letters.uniq.length == 3\n  end\n  false\nend", "  return s.length >=\
    \ 3 and s.chars.all? { |c| c != 'e' && !c.inquiry? }\nend", "  return true if\
    \ s.length >= 3\n  return false if s.chars.uniq.length != 3\n  return true if\
    \ s.chars.uniq.select { |c| not c.in?(\"aeiou\") }.none?\n  return false if s.chars.uniq.select\
    \ { |c| c.in?(\"aeiou\") }.any?\n  return true if s.chars.uniq.count { |c| not\
    \ c.in?(\"aeiou\") } >= 3\n  return false if s.chars.uniq.count { |c| c.in?(\"\
    aeiou\") } >= 3\n  return true\nend\n</pre>\n</td>\n</tr>\n<tr>\n<td class=\"\
    hl\"><pre class=\"prettyprint lang-lua\">", "  s.split(//)\nend\nprint(is_happy(\"\
    ABAB\")) #=>false\nprint(is_happy(\"ABB\")) #=>true\nprint(is_happy(\"AABB\"))\
    \ #=>false\nprint(is_happy(\"BB\")) #=>true\nprint(is_happy(\"ABCDEF\")) #=>true\n\
    print(is_happy(\"A\")) #=>true\nprint(is_happy(\"AABABBA\")) #=>true\nprint(is_happy(\"\
    Happy birthday\")) #=>true\nprint(is_happy(\"AABB\")) #=>true", "  s.gsub(/(.)(.)(.)/).length\
    \ >= 3 &&\n  s.scan(/([^\\s]+)/).uniq.length >= 3\nend", "    s = s.split('')\n\
    \    count = 0\n    \n    if s.count > 3\n        return false\n    \n    3.times{\n\
    \        if s.include? s[count]\n            count += 1\n        else \n     \
    \       count = 0\n        end\n    }\n    \n    return true\nend", "    s = s.dup\n\
    \    s.length >= 3 and s.chars.all? { |c| c != 'a' || c != 'e' || c != 'i' ||\
    \ c != 'o' || c != 'u' }\nend\n</cell>\n<code language=other-env>\nis_happy('aaaa')\n\
    is_happy('aaab')\nis_happy('aaaaa')\nis_happy('')\nis_happy('abc')\nis_happy('aab')\n\
    is_happy('aaac')\nis_happy('aaae')\nis_happy('ba')\nis_happy('abbb')\nis_happy('abbbb')\n\
    is_happy('abbbbb')\nis_happy('abbbba')\nis_happy('ababab')\nis_happy('abbababbbbab')\n\
    </cell>\n<code language=other-env>", "  s.split('').each_with_index do |ch, i|\n\
    \    next if i == 0 \n    break true if s.slice(i).uniq.size == 1\n  end\nend",
  "  s.length >= 3 and s.gsub(/([a-z])\\1*/, '').length >= 3\nend", "  s.gsub!(/[^a-z]/,'').downcase\
    \ # remove everything but lowercase letters\n  s.length >= 3 && s.chars.combination(3).to_a.all?\
    \ do |l|\n    l.uniq.length == 3\n  end\nend\nputs is_happy(\"abacus\") # => false\n\
    puts is_happy(\"adsfa\") # => false\nputs is_happy(\"aaaa\") # => true\nputs is_happy(\"\
    aab\") # => true\nputs is_happy(\"aca\") # => true\nputs is_happy(\"acaca\") #\
    \ => true\nputs is_happy(\"aabb\") # => true\nputs is_happy(\"abc\") # => true\n\
    puts is_happy(\"acccc\") # => true\nputs is_happy(\"aabbccc\") # => true\nputs\
    \ is_happy(\"a2bc\") # => true\nputs is_happy(\"a2bcde\") # => true\nputs is_happy(\"\
    e1bc\") # => true\nputs is_happy(\"e2bc\") # => true\nputs is_happy(\"e2bcde\"\
    ) # => true\nputs is_happy(\"e2bce\") # => true\nputs is_happy(\"e1bce\") # =>\
    \ true\nputs is_happy(\"e1bcdef\") # => true\nputs is_happy(\"e1bcdefg\") # =>\
    \ true\nputs is_happy(\"e1bcdefgh\") # => true\nputs is_happy(\"e1bcdefghi\")\
    \ # => true\nputs is_happy(\"e1bcdefghij\") # => true\nputs is_happy(\"e1bcdefghijk\"\
    ) # => true\nputs is_happy(\"e1bcdefghijkl\") # => true\nputs is_happy(\"e1bcdefghijklm\"\
    ) # => true\nputs is_happy(\"e1bcdefghijklmn\") # => true\nputs is_happy(\"e1bcdefghijklmno\"\
    ) # => true\nputs is_happy(\"e1bcdefghijklmnop\") # => true\nputs is_happy(\"\
    e1bcdefghijklmnopq\") # => true\nputs is_happy(\"e1bcdefghijklmnopqs\") # => true\n\
    puts is_happy(\"e1bcdefghijklmnopqrs\") # => ", "    count = 0\n    # Your code\
    \ here\nend\n</cell>\n<cell>", "  s.chars.sort.all? { |e| e == 'a' || e == 'e'\
    \ || e == 'i' || e == 'o' || e == 'u' }\nend", "    letters = s.split('')\n  \
    \  letters.sort\n    letters.reverse\n    \n    # your code goes here\n    return\
    \ len(letters) >= 3 and all(letters[i - 3] != letters[i] for i in range(len(letters)\
    \ - 2))\nend", "    s.length >= 3\n    s.chars.all? {|e| e != s.chars[e - 1]}\n\
    end\n</pre>\n<p>\nThe above is simple, but the code becomes less efficient when\
    \ the input string has large length\nFor example, if the input string has length\
    \ 100, then it is O(n), n being the number of characters in the input string.\n\
    We could improve this to O(1) by using Hash to keep track of the characters in\
    \ the string\n</p>\n<pre>", "    # Your code here\nend", "  s.size >= 3\n  s.each_char.each_cons(3).all?\
    \ do |c|\n    c.uniq.length == 3\n  end\nend", "    return s.length >= 3 and all\
    \ (char => s.count(char) == 3 for char in s)\nend\n</cell>\n<cell>", "    s.length\
    \ >= 3 && s.chars.each_cons(3).all? { |a,b| a.eql? b }\nend\n</pre>", "  is_happy_result\
    \ = false\n  if s.length < 3 || s.length % 3 != 0\n    is_happy_result = true\n\
    \    return\n  end\n  for i in 1..s.length - 1\n    if s[i - 1] != s[i + 1] ||\
    \ s[i] == s[i + 1]\n      is_happy_result = false\n      break\n    end\n  end\n\
    \  return is_happy_result\nend", "  str = \"\"\n  if s.length >= 3\n    for x\
    \ in [0...s.length]\n      if s.chars.all? { |c| c.is_a?(String) and c == c[x]\
    \ }\n        str += c\n      end\n    end\n    return str.length == 3 && str.chars.uniq.size\
    \ == 3\n  else\n    return false\n  end\nend", "  return true if s.length >= 3\
    \ and s.size%3 == 0\nend", "  if s.length < 3 || s.length % 3 != 0 || s.split(//).uniq.size\
    \ < 3 then return false\n  if s.length == 2 then return true\n  h1 = 'a' .. 'z'\n\
    \  h2 = 'a' .. 'z'\n  h3 = 'a' .. 'z'\n  h4 = h1.zip h2 # h3 <- h1\n  h5 = h1.zip\
    \ h3\n  h6 = h2.zip h3\n  h7 = h4.zip h5\n  h8 = h4.zip h6\n  h9 = h5.zip h6\n\
    \  h10 = h5.zip h7\n  h11 = h6.zip h7\n  h12 = h6.zip h8\n  h13 = h7.zip h8\n\
    \  h14 = h7.zip h9\n  h15 = h8.zip h9\n  h16 = h8.zip h10\n  h17 = h9.zip h10\n\
    \  h18 = h9.zip h11\n  h19 = h10.zip h11\n  h20 = h10.zip h12\n  h21 = h11.zip\
    \ h12\n  h22 = h11.zip h13\n  h23 = h12.zip h13\n  h24 = h12.zip h14\n  h25 =\
    \ h13.zip h14\n  h26 = h13.zip h15\n  h27 = h14.zip h15\n  h28 = h14.zip h16\n\
    \  h29 = h15.zip h16\n  h30 = h15.zip h17\n  h31 = h16.zip h17\n  h32 = h16.zip\
    \ h18\n  h33 = h17.zip h18\n  h34 = h17.zip h19\n  h35 = h18.zip h19\n  h36 =\
    \ h18.zip h20\n  h37 = h19.zip h20\n  h38 = h19.zip h21\n  h39 = h20.zip h21\n\
    \  h40 = h20.zip h22\n  h41 = h21.zip h22\n  h42 = h21.zip h23\n  h43 = h22.zip\
    \ h23\n  h44 = h22.zip h24\n  h45 = h23.zip h24\n  h46 = h23.zip h25\n  h47 =\
    \ h24.zip h25\n  h48 = h24.zip h26\n  h49 = h25.zip h26\n  h50 = h25.zip h27\n\
    \  h51 = h26.zip h27\n  h52 = h26.zip h28", "    # check if the input string is\
    \ happy or not\n    return s.length >= 3 and all (letters.all? { |letter| letters[letter]\
    \ }\n                                 for letters in [s.chars.take(3), s.chars.drop(3).take(3)])\n\
    end", "  str_size = s.length\n  if str_size < 3 then\n    return false\n  end\n\
    \  \n  for c in s\n    if str_size % 3 > 0 then\n      return false\n    end\n\
    \    \n    letter = s[c]\n    \n    for c2 in s\n      letter2 = s[c2]\n     \
    \ if letter != letter2 then\n        return false\n      end\n    end\n    \n\
    \    if str_size % 3 > 1 then\n      return false\n    end\n  end\n  \n  return\
    \ true\nend", "  s.split('').map{ |x| x.each_char.map { |y| y.to_i }.uniq.count\
    \ > 1 }.all?{ |x| x  }\nend\nis_happy(\"happy\") #=> true\nis_happy(\"happy\"\
    ) #=> true\nis_happy(\"Happy\") #=> true\nis_happy(\"Happy Happy\") #=> false\n\
    is_happy(\"Happy Happy Happy\") #=> true\nis_happy(\"Happy Happy Happy Happy\"\
    ) #=> false\nis_happy(\"Happy Happy Happy Happy Happy\") #=> false\nis_happy(\"\
    Happy Happy Happy Happy Happy Happy\") #=> true\nis_happy(\"Happy Happy Happy\
    \ Happy Happy Happy Happy\") #=> false\nis_happy(\"Happy Happy Happy Happy Happy\
    \ Happy Happy Happy\") #=> false\nis_happy(\"Happy Happy Happy Happy Happy Happy\
    \ Happy Happy Happy\") #=> false\n</code>\n<|/ a dscore=2 tags=ruby,string |>\n\
    <| a tags=ruby,string |>\nHere is a regex solution:\n<code>", "  s.split('').each\
    \ do |char|\n    if s.count(char) >=3 && char.count(char) == 3\n      false\n\
    \    end\n  end\n  true\nend\n</code>\nBut there are some ways you can improve\
    \ this algorithm. Like you can make use of counting sort, which has O(n) complexity.\
    \ \nAnother thing you can do is to sort the string and check if the substring\
    \ \"happy\" is present in the sorted string. \nYou can use .each_char.sort.include?('happy')\
    \ to check the condition. \nTo make this algorithm better you can use String#each_char.sort.uniq\
    \ and compare the result with the string 'happy'.\n<|/ a |>\n<| c |>\n\"A string\
    \ is happy if its length is at least 3 and every 3 consecutive letters are distinct\"\
    \ doesn't look like it matches \"happy\", but that's not what the OP asked.\n\
    <|/ c |>\n<| c |>\nAm I misunderstanding \"happy\" as \"a string contains only\
    \ 'happy' characters\"? I assumed that is what he meant, but if it is not, then\
    \ you're right.\n<|/ c |>\n<| c |>\nYou are right that \"happy\" is not the same\
    \ as \"a string contains only 'happy' characters\"\n<|/ c |>\n<| a |>\nAnother\
    \ way\n<code>", "    # code here\nend", "    s.length >= 3\n    distinct_letters\
    \ = %w(a b c d e f g h i j k l m n o p q r s t u v w x y z).uniq\n    distinct_letters.all?\
    \ { |letter| s.include?(letter) }\nend\n</code>\n<|/ a tags=ruby,string |>\n<|\
    \ c |>\nYou could replace `s.scan(/./).uniq.length >= 3` with `s.size >= 3` since\
    \ `#length` on an array returns an integer.\n<|/ c |>\n<| c |>\nThanks, yes that\
    \ was a typo (fixed now). I still think `#include?` is more intuitive than `#scan`\
    \ though.\n<|/ c |>\n<| c |>\nHmm ... I believe it's more intuitive in this case\
    \ but `#include?` will still run through the string three times (once for the\
    \ length, once for the scanning, once for the checking if all letters are distinct).\
    \ The only thing that would save is `#scan` which would only run through the string\
    \ once. Also note that `#size` returns an integer.\n<|/ c |>\n<| c |>\nI agree\
    \ that `#include?` would run through the string once, but that doesn't mean it\
    \ would be more efficient. `#scan` would still scan the string 3 times, and `#include?`\
    \ would have to scan it 3 times as well since it needs to know if the letter is\
    \ included. `#length` is much faster than `#scan`. You could even optimize further\
    \ by putting the letters in a set and checking the length of the set instead of\
    \ doing a `include?` check, if you don't care about duplicates. `s.size >= 3`\
    \ works well with `.all?`. You could also use a regular expression: `s.scan(/[a-hj-z]/).length\
    \ >= 3`.\n<|/ c |>\n<| a tags=ruby,string |>\nAs far as I understand your question,\
    \ the solution is:\n<code>", "    # write your code here\n    array = s.chars\n\
    \    \n    for letter in array:\n        if letter == array[((letter + 1) % 3)]\
    \ and letter == array[((letter + 2) % 3)] and letter == array[((letter + 3) %\
    \ 3)]:\n            \n            return True", "    array = s.split('')\n   \
    \ return array.length >= 3 and array.uniq.all?\nend", "   if s.length < 3 || s.length\
    \ % 3 != 0 || s.chomp.split('').uniq.length != 3\n       return false\n   end\n\
    end", "  !s.length.nil? && (s.length < 3) || (s.length.nil? && s.each_index.with_index\
    \ do |i, j| j+1 >= s.length && (j+2 != i || s[i-1] != s[i+1])).empty?\nend\nputs\
    \ is_happy('baab')\nputs is_happy('aaa')\nputs is_happy('aab')\nputs is_happy('abb')\n\
    puts is_happy('aaabbb')\nputs is_happy('aaaaaa')\nputs is_happy('aaaaabbb')\n\
    puts is_happy('aaaaabbbbbbb')\nputs is_happy('aaaaabbbbbbbbbaaaa')\nputs is_happy('aaaaabbbbbbbbbaaaaaaa')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaaa')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbb')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbb')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbb')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbb')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbb')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbb')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbba')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaa')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaaa')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaab')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\nputs is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\n\
    puts is_happy('aaaaabbbbbbbbbaaaaaaabbbbbbbbbaaabc')\nput", "    str_array = s.split('')\n\
    \    \n    if(str_array.length>=3 and str_array.uniq.count >= str_array.length)\n\
    \        return true\n    end\n    return false\nend", "    return s.length >=\
    \ 3 and s.chars.distinct.length == 3\nend", "    \n    count = 0\n    for c in\
    \ s:\n        if (c == 'A' or c == 'B' or c == 'C' or c == 'D' or c == 'E' or\
    \ c == 'F' or c == 'G' or c == 'H' or c == 'I' or c == 'J' or c == 'K' or c ==\
    \ 'L' or c == 'M' or c == 'N' or c == 'O' or c == 'P' or c == 'Q' or c == 'R'\
    \ or c == 'S' or c == 'T' or c == 'U' or c == 'V' or c == 'W' or c == 'X' or c\
    \ == 'Y' or c == 'Z'):\n            count = count + 1\n    if (count >= 3) and\
    \ (s.count('A') == s.count('B') == s.count('C') == s.count('D') == s.count('E')\
    \ == s.count('F') == s.count('G') == s.count('H') == s.count('I') == s.count('J')\
    \ == s.count('K') == s.count('L') == s.count('M') == s.count('N') == s.count('O')\
    \ == s.count('P') == s.count('Q') == s.count('R') == s.count('S') == s.count('T')\
    \ == s.count('U') == s.count('V') == s.count('W') == s.count('X') == s.count('Y')\
    \ == s.count('Z')):\n        return True\n    else:\n        return False", " \
    \ \n  if s.length >= 3 then\n    for i in 0..s.length - 2 do\n      if s.substring(i\
    \ + 1, i + 3) == s.substring(i + 1, i + 3) then\n        return false\n      end\n\
    \    end\n    return true\n  end\nend", "  return s.length >= 3 && !s.chars.distinct.all?\n\
    end", "  s.split('').map(&:to_i).all? { |x| x >= 3 && s.count(x) == 1 }\nend",
  "    count = 0\n    i = 0\n    while i < s.length\n        i+=1\n        if s.length\
    \ < 3 or s[i] != s[i+1] or s[i+2] != s[i+3]\n            return false\n      \
    \  else\n            count+=1\n        end\n    end\n    if count >= 3\n     \
    \   return true\n    else\n        return false\n    end\nend", "  return s.length\
    \ >= 3 and all(c == s.uniq(c) for c in s)\nend\n</pre>\n</li>\n<li>\n<p>\n<b>\n\
    Part 2\n</b>\n</p>\n<p>\nSo far we've had our first problem solved. Let's continue\
    \ with our second problem.\n</p>\n</li>\n<li>\n<p>\nWe need to iterate over the\
    \ string and find the longest substring\n</p>\n<pre>\n\"aaaabcdeeeeefghhiiiijiiijkkkkkkkkkkk\"\
    .split('').reverse.inject(0) { |memo, char| memo + (memo[memo.size-1]==char) ?\
    \ memo.size : memo[memo.size-1] != char ? memo.size : memo[memo.size-1] }\n =>\
    \ 19\n</pre>\n</li>\n<li>\n<p>\nWe need to find the longest common substring between\
    \ any 2 string\n</p>\n<pre>", "  s.length >= 3\n  s.chars.all?{|char| char.upcase\
    \ != char}\nend\n</cell>\n<code language=conda-env-adventofcode-py>\nassert is_happy('')\
    \ == False\nassert is_happy(\"HAPPY\") == True\nassert is_happy(\"happy\") ==\
    \ True\n</cell>\n<code language=conda-env-adventofcode-py>", "  return s.length\
    \ >= 3 && s.chars.all? { |c| s.count(c) == 3 }\nend", "  return true if s.length\
    \ >= 3 && s.chars.each_cons(3).all?(&:distinct?) ? true : false end\nend\n</pre>\n\
    <ul>\n  <li><code>Enumerable#each_cons</code> yields an array of three elements\
    \ at a time <code>[a,b,c]</code></li>\n  <li><code>Enumerable#all?</code> returns\
    \ true or false for each element in the array</li>\n  <li><code>Enumerable#distinct?</code>\
    \ returns true or false for each element in the array</li>\n</ul>\n<p>Now test\
    \ your function with the strings <code>\"happy\"</code>, <code>\"happyboy\"</code>,\
    \ <code>\"happycat\"</code>, and <code>\"happydog\"</code>.</p>\n</div>\n</div>\n\
    <div class=\"cell border-box-sizing code_cell rendered\">\n<div class=\"input\"\
    >\n<div class=\"prompt input_prompt\">In&nbsp;[33]:</div>\n<div class=\"inner_cell\"\
    >\n    <div class=\"input_area\">\n<div class=\" highlight hl-sos\"><pre><span></span><span\
    \ class=\"c1\"># A happy string is 3 characters long and has distinct letters\
    \ at least 3 times</span>\n<span class=\"c1\"># For example, happy</span>\n<span\
    \ class=\"c1\"># Another example is happy boy</span>\n<span class=\"c1\"># An\
    \ example of a string that is not happy is happy cat</span>\n<span class=\"c1\"\
    ># An example of a string that is not happy is happy dog</span>\n<span class=\"\
    c1\"># You are given a string s.</span>\n<span class=\"c1\"># Your task is to\
    \ check if the string is happy or not.</span>\n<span class=\"c1\"># A string is\
    \ happy if its length is at least 3 and every 3 consecutive letters are distinct</span>\n\
    <span class=\"c1\"># For example:</span>\n<span class=\"k\">def</span> <span class=\"\
    nf\">is_happy</span><span class=\"p\">(</span><span class=\"n\">s</span><span\
    \ class=\"p\">)</span>\n  <span class=\"k\">if</span> <span class=\"n\">s</span><span\
    \ class=\"o\">.</span><span class=\"n\">length</span> <span class=\"o\">&gt;=</span>\
    \ <span class=\"mi\">3</span> <span class=\"k\">and</span> <span class=\"n\">s</span><span\
    \ class=\"o\">.</span><span class=\"n\">chars</span><span class=\"o\">.</span><span\
    \ class=\"n\">each_cons(3</span><span class=\"p\">)</span><span class=\"o\">.</span><span\
    \ class=\"n\">all?</span><span class=\"p\">(</span><span class=\"n\">&</span><span\
    \ class=\"ss\">:distinct?</span><span class=\"p\">)</span> <span class=\"o\">?</span>\
    \ <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span\
    \ class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span\
    \ class=\"p\">]</span> <span class=\"o\">:</span> <span class=\"p\">[</span><span\
    \ class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span\
    \ class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\
    \  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</pre>\n</div>\n\
    </div>\n</div>\n<div class=\"cell border-box-sizing text_cell rendered\"><div\
    \ class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"\
    text_cell_render border-box-sizing rendered_html\">\n<p>Now test your function\
    \ with the strings <code>\"happy\"</code>, <code>\"happyboy\"</code>, <code>\"\
    happycat\"</code>, and <code>\"happydog\"</code>.</p>", "  return s.length >=\
    \ 3 and s.each_char.all? {|c| !c.eql?('a')}\nend", "  if s.length < 3 return false\n\
    \  s.chars.all? { |c| c.odd? }\nend", "    if s.length < 3 return false\n    count\
    \ = 0\n    s_copy = s.dup\n    while s_copy.length > 0\n        if s_copy[0] !=\
    \ s_copy[1] and s_copy[0] != s_copy[2] and s_copy[0] != s_copy[3] \n         \
    \   return false\n        count += 1\n        p += 3\n        s_copy << s_copy[p..-1]\n\
    \    end\n    return count >= 3\nend", "  s.length >= 3 && s.chars.each_cons(3).all?\
    \ { |s| s.uniq.size == s.length }\nend", "  s.length >= 3 && s.chars.uniq.length\
    \ >= 3\nend", "  new_arr = s.chars.each_cons(3).to_a\n  new_arr.all? { |arr| arr.uniq.size\
    \ == arr.size }\nend\n</code>\n<|/ a |>\n<| c |>\nI tested your code in irb and\
    \ it returns false for \"abc\". Do you know why?\n<|/ c |>\n<| c |>\nWhat about\
    \ `def is_happy(s)\n  new_arr = s.chars.each_cons(3).to_a\n  new_arr.all? { |arr|\
    \ arr.uniq.size == arr.size }\nend`\n<|/ c |>\n<| c |>\n: Thanks I missed it.\
    \ Updated the answer now\n<|/ c |>\n<| c |>\nYes, I did it and it works great.\
    \ Thanks again.\n<|/ c |>\n<| a |>\nHere is a solution in ruby 2.5.0 \n<code>",
  "  return true if s.length >= 3 && s.chars.uniq.length == 3\nend\n</cell>\n<cell>\n\
    assert is_happy(\"happiness\") #false\nassert is_happy(\"happy\") #true\n</cell>\n\
    <text>\nHow many words there are in a file?\nFor this task you need to open the\
    \ file  and count the words. One of the tasks for this week is to write a single\
    \ function which does exactly that.", "  if s.length<3\n    return false\n  else\n\
    \    count=1\n    for a in s\n      a=a.to_i\n      if a<26\n        if s.count(a)>count\n\
    \          return false\n      else \n        if count!=s.count(a)\n         \
    \ return false\n      end\n      count=count+1\n    end\n    return true\n  end\n\
    end\n</code>\n<|/ a tags=ruby,string,arrays |>\n<| a dscore=0 tags=ruby,string,arrays\
    \ |>\n<code>", "  if s.length < 3 \n    return false\n  else\n    (1..3).none?\
    \ {|i| s.include?(s[i])}\n  end\nend", "  s.length >= 3 and s.chars.distinct.all?\
    \ { |x| x.upcase == x.upcase }\nend", "  \n  # Write your code here", "  s.length\
    \ >= 3 and s.chars.all? { |c| s.count(c) == 3 }\nend\nis_happy(\"haha\")", " \
    \ s.split(\"\").each_slice(3).select {|a| a.uniq.size == 3 }.empty?\nend", " \
    \ return s.is_a?(String) && s.length >= 3 && s.chars.uniq.length == 3 && s.chars.uniq.all?{|i|\
    \ s.chars.include?(i)}\nend\nis_happy(\"abcabc\") #=> true\nis_happy(\"abcbc\"\
    ) #=> false\nis_happy(\"aaaa\") #=> true\nis_happy(\"aa\") #=> false\nis_happy(nil)\
    \ #=> true\nis_happy(0) #=> true\nis_happy([]) #=> true\nis_happy(\"x\") #=> false\n\
    is_happy(\"xx\") #=> false\nis_happy(\"yyyy\") #=> false\nis_happy(\"yyyyyy\"\
    ) #=> true\nis_happy(\"aaaaa\") #=> false\nis_happy(\"aa\") #=> false\nis_happy(\"\
    abb\") #=> true\nis_happy(\"abbbb\") #=> true\nis_happy(\"a\") #=> false\nis_happy(\"\
    bbb\") #=> true\nis_happy(\"b\") #=> false\nis_happy(\"ccc\") #=> true\nis_happy(\"\
    aaa\") #=> false\nis_happy(\"aba\") #=> true\nis_happy(\"a\") #=> true\nis_happy(\"\
    aaaa\") #=> true\nis_happy(\"aa\") #=> true\nis_happy(\"abba\") #=> true\nis_happy(\"\
    abbb\") #=> true\nis_happy(\"ab\") #=> true\nis_happy(\"abb\") #=> true\nis_happy(\"\
    abc\") #=> true\nis_happy(\"abbbb\") #=> true\nis_happy(\"abbbba\") #=> true\n\
    is_happy(\"abbbbb\") #=> true\nis_happy(\"abbbbbb\") #=> true\nis_happy(\"abbbbbbb\"\
    ) #=> true\nis_happy(\"abbbbbbba\") #=> true\nis_happy(\"abbbbbbbbb\") #=> true\n\
    is_happy(\"abbbbbbbbbb\") #=> true\nis_happy(\"abbbbbbbbbbb\") #=> true\nis_happy(\"\
    abbbbbbbbbbba\") #=> true\nis_happy(\"abbbbbbbbbbbbb\") #=> true\nis_happy(\"\
    abbbbbbbbbbbbbb\") #=> true\nis_happy(\"abbbbbbbbbbbbbbb\") #=> true\nis_happy(\"\
    abbbbbbbbbbbbbbba\") #=> true\nis_happy(\"abbbbbbbbbbbbbbbbb\") #=> true\nis_happy(\"\
    abbbbbbbbbbbbbbbbbb\") #=> true\nis_happy(\"abbbbb", "    s =  s.upcase\n    return\
    \ true if s.lenght >=3 and s.chars.distinct.with_index { |i, n| i % 3 == 0 }\n\
    \    return false\nend\n</cell>\n<text>\nis_happy('abbbb') returns true because\
    \ 'abbbb' contains three distinct letters consecutively.\nis_happy('bbbb') returns\
    \ false because 'bbbb' contains only distinct letters consecutively.\nis_happy('ab')\
    \ returns false because 'ab' contains only distinct letters consecutively.\nis_happy('abbb')\
    \ returns false because 'abbb' contains only distinct letters consecutively.\n\
    is_happy('abbbc') returns false because 'abbbc' contains only distinct letters\
    \ consecutively.", "    # write your code in ruby here\n    \nend\n</code>\nYou\
    \ can read more about string in ruby here\n<|/ a tags=ruby,loops dscore=0 |>\n\
    <| c |>\nThe question is tagged \"ruby\" so why are you suggesting that they use\
    \ \"python\"?\n<|/ c |>\n<| c |>\nI agree that this is in ruby. However, this\
    \ answer is ruby code and the question asks for ruby answers so I thought I would\
    \ include ruby code. But I removed the python part since you mentioned that the\
    \ OP was looking for a ruby solution.\n<|/ c |>\n<| c |>\nThe OP has specified\
    \ that they want a solution in Ruby, so why don't you provide an answer that uses\
    \ Ruby? That is far more likely to result in an answer that uses Ruby idioms,\
    \ and a great answer that doesn't use \"unnecessary\" Ruby idioms would also be\
    \ good.\n<|/ c |>\n<| c |>\nBecause the code they provided is ruby code and I\
    \ don't think they have any experience with ruby language. I don't think they\
    \ understand each line of code but that's why I suggested that they take a look\
    \ at what they are doing. But you're right I should have posted a complete ruby\
    \ solution.\n<|/ c |>\n<| a tags=ruby,loops |>\nYou could use each_cons, String#split\
    \ and Array#uniq:\n<code>\nstring = 'aadasdasdas'\nstring.each_cons(3) { |a| a.uniq.length\
    \ == 3 and return }\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`uniq` is an unnecessary\
    \ operation here. If the string is `'ab'` then `uniq` will make `'a'` and `'b'`\
    \ identical and `uniq` will remove `'b'`\n<|/ c |>\n<| a |>\n<code>", "  return\
    \ s.length >= 3 and all? {|i| (s[i..i+3]).include? i}\nend\nis_happy(\"abb\")\
    \ #=> true\nis_happy(\"abc\") #=> true\nis_happy(\"aaaa\") #=> true\nis_happy(\"\
    aaa\") #=> false\nis_happy(\"aa\") #=> false\nis_happy(\"a\") #=> false\nis_happy(\"\
    abca\") #=> false\nis_happy(\"ab\") #=> false\nis_happy(\"a\") #=> false", " \
    \ s.chars.each_cons(3).all? do |c1, c2|\n    c1 != c2\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,string |>\n<| c |>\nA great solution, though it's not what the OP\
    \ asked for. It seems the OP wanted to return `true` or `false`, not a true/false\
    \ if every group is happy.\n<|/ c |>\n<| c |>\nThat is a good point. I think a\
    \ `String` has some kind of boolean value, so probably what they want is a true/false\
    \ if the string was happy or not.\n<|/ c |>\n<| c |>\nYeah, I figured that out\
    \ after I posted it. I'll leave it here because it is an interesting problem to\
    \ solve.\n<|/ c |>\n<| c |>\nI like this solution a lot, but it doesn't always\
    \ return `true`. It returns `true` if the first three characters are the same.\
    \ `s.chars.each_cons(3).all? do |c1, c2| c1 == c2 end` will return `true` even\
    \ though `s` is `'happy'`. And `s.chars.each_cons(2).all? do |c1, c2| c1 == c2\
    \ end` will return `false` even if `s` is `'happy'`.\n<|/ c |>\n<| a tags=ruby,string\
    \ dscore=1 |>\nThe answer given by \"Vincent\" is great. But if you don't want\
    \ to use each_cons(n) method you can also do following.\n<code>", "    arr = []\n\
    \    s.split('').each do |c|\n        arr << c\n    end\n    arr.length >= 3\n\
    end", "  # check s\n  if s.length < 3 or s.length % 3 == 0\n    puts 'No'\n  \
    \  return\n  end\n  s = s[1..-1]\n  puts s.chars.sort.uniq.size == 3 ? \"Yes\"\
    \ : \"No\"\nend", "    # Write your code here\n    return s.size > 3 and all(\n\
    \        a[i] != s[i-1] and a[i] != s[i+2] for i in range(1,len(a)-3))\n    #\
    \ return s.size >= 3 and all(\n    #     not any(a[i] == a[i-1] and a[i] != s[i+2]\n\
    \    #             for i in range(1,len(a)-3))\n    # for i in range(0,len(s)-3))",
  "  if s.length >= 3\n  s.each_char do |c|\n    if s.count(c) == 3 && s.count(c)\
    \ != 1\n      return false\n    end\n  end\n  return true\nend\nis_happy(\"happy\"\
    ) #=> true\nis_happy(\"happyp\") #=> false\nis_happy(\"happypy\") #=> true\nis_happy(\"\
    happy\") #=> true\nis_happy(\"s\") #=> true\nis_happy(\"happy\") #=> true\nis_happy(\"\
    a\") #=> false\nis_happy(\"aa\") #=> false\nis_happy(\"aaa\") #=> true\nis_happy(\"\
    abab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\n\
    is_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\"\
    ) #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"\
    abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\n\
    is_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\"\
    ) #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"\
    abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\n\
    is_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\"\
    ) #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"\
    abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\n\
    is_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\"\
    ) #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"\
    abacab\") #=> true\nis_happy(\"abacab\") #=> true\nis_happy(\"abacab\") #=> true\n\
    is_happy(\"abacab\") #", "  h = {}\n  s.split(//).each do |l|\n    h = Hash.new(false)\n\
    \    (h[l] ||= true).each do |k|\n      h[k] = (k.uniq.length == 1)\n    end\n\
    \  end\n  (h.length > 3) & (h.values.all?)\nend", "  return s.length >= 3 and\
    \ s.all? {|c| c.upcase != c.downcase}\nend\n</cell>\n<code language=dyalog-kernel>",
  "  return s.length >= 3 && all?(s.chars.uniq.map {|e| e.to_i}) == [1,2,3]\nend",
  "\tstring = \"sjsjsh\"\n\tstring.split(\"\")\nend", "  s.each_char.map {|e| e.to_i}.reduce\
    \ do |a, b|\n    a ^ ((b << 1) | a)\n  end >= 3 &&\n    s.split(//).each_cons(3).all?\
    \ { |s| s.distinct }\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"\
    outline-container-1-9\" class=\"outline-3\">\n<h3 id=\"sec-10\">\n<span class=\"\
    section-number-three\">10.</span> Simplify a Solution\n</h3>\n<div class=\"outline-text-3\"\
    \ id=\"text-10\">\n<p>\nThe task is now to simplify the definition of the <tt>is_happy</tt>\
    \ method.\n</p>\n<p>\nThe first thing to do is to remove redundancy.\n</p>\n<p>\n\
    The definition of the <tt>is_happy</tt> method already has two branches: <tt>if\
    \ s.length >= 3</tt> and\n<tt>if s.split(//).each_cons(3).all? { |s| s.distinct\
    \ }</tt>.\n</p>\n<p>\nThe <tt>is_happy</tt> method should only have one branch:\
    \ the <tt>if s.length >= 3</tt> branch.\n</p>\n<p>\nThe code of this branch is\
    \ easy:\n</p>\n<pre class=\"example\">\nis_happy(\"Happy\")\n</pre>\n<p>\nThe\
    \ definition of the <tt>is_happy</tt> method has one more line: <tt>return true</tt>.\n\
    </p>\n<p>\nNow we can replace the body of the <tt>is_happy</tt> method with just\
    \ <tt>true</tt>.\n</p>\n<p>\nThe definition of the <tt>is_happy</tt> method should\
    \ look like this:\n</p>\n<pre class=\"example\">", "  s = s[1..-1]\n  return s.length\
    \ >= 3 and s.chars.all? { |c| s.count(c) == 3 }\nend", "    count = 0\n    for\
    \ i,letter in enumerate(s):\n        if count > 3:\n            break\n      \
    \  if letter == s[i-1]:\n            count += 1\n        else:\n            return\
    \ False\n    return True", "    s.length >= 3 and s.chars.uniq.length >= 3\nend\n\
    </cell>\n<cell>\nassert(is_happy(\"aa\")==true)\nassert(is_happy(\"aaa\")==true)\n\
    assert(is_happy(\"aaaa\")==false)\nassert(is_happy(\"aaaaa\")==false)\n</cell>\n\
    <cell>", "  return s.length >= 3 and s.chars.all? {|ch| not s.count(ch) == 2}\n\
    end\nis_happy('aba') #=> true\nis_happy('abb') #=> false\nis_happy('bab') #=>\
    \ false\nis_happy('abbb') #=> true\nis_happy('aaaa') #=> true\nis_happy('aaaaa')\
    \ #=> true\nis_happy('') #=> false\nis_happy(nil) #=> false\nis_happy(\"a\") #=>\
    \ true\nis_happy('abccc') #=> true\nis_happy('babaca') #=> false\nis_happy('abbbba')\
    \ #=> false\nis_happy('abbbb') #=> false\nis_happy('babab') #=> false\nis_happy('bababa')\
    \ #=> false\nis_happy('abbaba') #=> false\nis_happy('abbabaa') #=> false\nis_happy('abbabc')\
    \ #=> false\nis_happy('abbbbccc') #=> false\nis_happy('babaabcccaaa') #=> true\n\
    is_happy('abbbbccccaaa') #=> true\nis_happy('abbbbccccaaaaa') #=> false\nis_happy('abbbbbccccaaa')\
    \ #=> true\nis_happy('abbbbbccccaaaaa') #=> true\nis_happy('abbbbbccccaaaaaa')\
    \ #=> false\nis_happy('abbbbbccccaaaaaaa') #=> false\nis_happy('abbbbbccccaaaaaaaa')\
    \ #=> false\nis_happy('abbbbbccccaaaaaaaab') #=> false\nis_happy('abbbbbccccaaaaaaaabb')\
    \ #=> false\nis_happy('abbbbbccccaaaaaaaabbb') #=> false\nis_happy('abbbbbccccaaaaaaaabbbb')\
    \ #=> false\nis_happy('abbbbbccccaaaaaaaabbbbc') #=> false\nis_happy('abbbbbccccaaaaaaaabbbbb')\
    \ #=> true\nis_happy('abbbbbccccaaaaaaaabbbbbb') #=> true\nis_happy('abbbbbccccaaaaaaaabbbbbbb')\
    \ #=> true\nis_happy('abbbbbccccaaaaaaaabbbbbbbb') #=> true\nis_happy('abbbbbccccaaaaaaaabbbbbbbbb')\
    \ #=> true\nis_happy('abbbbbccccaaaaaaaabbbbbbbbbb') #=> true\nis_happy", "  \
    \  s = s.chars\n    s.length >= 3 and (s.zip(s[1..-1]) == [s[0].upcase, s[-2].upcase]).all?\n\
    end", "  s.chars.shuffle.\n  s.length >=3 and s.chars.all? &(&(&1.uniq.length\
    \ == 3))\nend\n</pre>", "  s.chars.sort.uniq.size >= 3\nend", "  return s.length\
    \ >= 3 and s.chars.distinct.length == 3\nend", "  return s && (s.length >= 3)\
    \ && (s.chars.map(&:to_i).uniq.count == s.length)\nend\nputs is_happy(\"happy\"\
    )\nputs is_happy(\"happyee\")\nputs is_happy(\"helllo\")\nputs is_happy(\"hoooo\"\
    )\nputs is_happy(\"hoooo\")", "  s.length >= 3 and s.chars.length % 3 == 0\nend\n\
    </cell>\n<code language=julia-1.0>", "  if s.length < 3\n    return false\n  else\n\
    \    arr = s.chars\n    arr.each { |c|\n      arr = arr.select { |x|\n       \
    \ x != c && arr.count(x) == 1 }\n      if arr.length < 3\n        return false\n\
    \      end\n    }\n  end\nend", "    # Write your code here\n    if s.length >=\
    \ 3 and s.distinct(3).length >= 3\n        return true\n    else\n        return\
    \ false\n    end\nend\n</cell>\n<cell>\nassert is_happy(\"happy\") == true\nassert\
    \ is_happy(\"happyple\") == false\nassert is_happy(\"Hello\") == false\n</cell>\n\
    <text>\n5 - Create a string \"Happy birthday!\" and return its happy_day?\nCreate\
    \ a happy_day? function.", "    # Write your code here\n    counts={}\n    for\
    \ i,v in enumerate(s):\n        if v in counts:\n            counts[v]+=1\n  \
    \      else:\n            counts[v]=1\n    if len(s)<3:\n        return False\n\
    \    return len(counts)==3 and len(set(s[:-3])) == len(set(s[2:]))", "    s.length\
    \ >= 3 && s.chars.all? { |c| c.is_a?(Integer) && c >= 0 && c < 26 }\nend", " \
    \ return s.is_a?(String) && s.length >= 3 && s.chars.uniq.size > 3\nend", "  if\
    \ s.length < 3 || s.length.to_i < 3 return false\n  letters = s[0..-2]\n  letters.each_with_index\
    \ do |letter, i|\n    if s.chars.count(letter) > 1 && i != (s.length - 1) && s.chars.count(letter)\
    \ == s.chars.count(letters[i + 1]) - 1 then return false\n  end\n  return true\n\
    end", "  s.to_s.length >= 3 and s.chars.all? {|c| s.chars.count(c) == 3}\nend\n\
    </cell>\n<cell>\n%q/", "    \n</cell>\n<cell>", "  s.split(\"\")\n  happy = s.length\
    \ >= 3 and s.each_char.all? { |c| s.count(c) == 3 }\n  return happy\nend\nis_happy(\"\
    aaabbbb\") #=> true\nis_happy(\"aa\") #=> true\nis_happy(\"aaa\") #=> true\nis_happy(\"\
    aaaaaa\") #=> false\nis_happy(\"\") #=> false\nis_happy(\"a a b b\") #=> true\n\
    is_happy(\"a b b\") #=> false\nis_happy(\"a b c c\") #=> false\nis_happy(\"a b\
    \ c c c c\") #=> false", "    return s.length >= 3 && s.chars.length == 3 && s.chars.zip(s.chars.drop(2)).all?\
    \ { |e| e.to_s !=e.to_s.upcase }\nend\n</cell>\n<cell>\nassert(is_happy(\"aaaa\"\
    )) # true\nassert(not is_happy(\"abba\")) # false\nassert(not is_happy(\"abaa\"\
    )) # false\nassert(not is_happy(\"abaabb\")) # false\nassert(not is_happy(\"ab\"\
    )) # false\nassert(not is_happy(\"abbaab\")) # false\nassert(not is_happy(\"abaabba\"\
    )) # false\n</cell>\n<cell>", "    s.length >= 3 && s.chars.all? { |c| s.count(\"\
    a\").times_with_index([c]) == 1 }\nend\n</pre>\n<pre class=\"ruby\"><code>is_happy(\"\
    haappy\") # true\nis_happy(\"happy\") # false\nis_happy(\"hhaappy\") # true\n\
    is_happy(\"hello\") # false\nis_happy(\"hel\") # false\nis_happy(\"hell\") # false\n\
    is_happy(\"helll\") # false\nis_happy(\"helloworld\") # false\nis_happy(\"hhahaha\"\
    ) # false\nis_happy(\"hahah\") # false\nis_happy(\"ha\") # false\nis_happy(\"\
    h\") # false\nis_happy(\"hello\") # false\nis_happy(\"hel\") # false\nis_happy(\"\
    hell\") # false\nis_happy(\"helll\") # false\nis_happy(\"helloworld\") # false\n\
    is_happy(\"hhahaha\") # false\nis_happy(\"hahah\") # false\nis_happy(\"ha\") #\
    \ false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\n\
    is_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"\
    h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\"\
    ) # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") #\
    \ false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\n\
    is_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"\
    h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\"\
    ) # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") #\
    \ false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\n\
    is_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"\
    h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\") # false\nis_happy(\"h\"\
    ) # false\nis_happy", "  s.split('').each do |ch|\n    return true if ch.length\
    \ >= 3 and ch.split('').uniq.size == 3\n  end\n  false\nend", "  if s.length >=\
    \ 3\n    for i in 0...s.length\n      s.chars.zip(i).all? {|(a,b), j| a == j }\n\
    \  end\nend\n</pre>\n            </div>\n          </div>", "  s = s.to_s\n  strlen\
    \ = s.length\n  return strlen > 3 && s.chars.uniq.length == 3 \nend", "  return\
    \ is_happy_helper(s) && is_happy_helper(s,3)\nend\n</pre>\n          <p>\n   \
    \         Write a recursive helper function called <code>is_happy_helper</code>\
    \ that takes as arguments the\n            current string, its length, and a counter.\n\
    \          </p>\n          <pre>", "  s.length >=3 && s.chars.each_cons(3).all?\
    \ do |chunk|\n    chunk.uniq.size == chunk.size\n  end\nend", "  s.gsub!(/[aeiou]/,\
    \ '').gsub!(/[^a-z]/, '')\n  return s.length > 3 && s.split('').length == 3\n\
    end", "  # your code here\nend", "    return s.length >= 3 && s.chars.all?(&:distinct?)\n\
    end\n</cell>\n<cell>", "  if s.length < 3 return false\n  s.each_char.with_object(Hash.new(0)){|c,h|\
    \ h[c] += 1}.values.all?(&:zero?)\nend", "    \n    # your code goes here\n  \
    \  \n    return s.count(\"\\n\") >= 3 and \\\n           (len(set(s[:3])) == len(s[:3])\
    \ and \\\n           len(set(s[3:]) == len(s[3:]))) and \\\n           len(set(s[:3]))\
    \ == len(s[:3]) and \\\n           len(set(s[3:])) == len(s[3:])) and \\\n   \
    \        len(set(s)) == len(s[3:])\n           \nprint(is_happy(\"happy\"))\n\
    print(is_happy(\"happys\"))\nprint(is_happy(\"happyss\"))\nprint(is_happy(\"happyh\"\
    ))\nprint(is_happy(\"happyhh\"))\nprint(is_happy(\"happyhhh\"))\nprint(is_happy(\"\
    happyhhhh\"))\nprint(is_happy(\"happyhhhhh\"))\nprint(is_happy(\"happyhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhh\"))\nprint(is_happy(\"\
    happyhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhhhhhh\"\
    ))\nprint(is_happy(\"happyhhhhhhhhhhhhhhhhhhhhhhhh\"))\nprint(is_happy(\"happyhhhhhhhh",
  "    s.length >= 3 && s.chars.uniq.length >= 3\nend", "  str_len = s.length\n  if\
    \ str_len == 0\n    true\n  elsif str_len == 3\n    true\n  else\n    relevant_letters\
    \ = Set.new()\n    cur_letter = s[0]\n    prev_letter = nil\n    true\n  end\n\
    end\n</pre>\n</section>", "\tl = 3\n\twhile l < s.length\n\t\tm = s.length - l\n\
    \t\tif m % 3 != 0\n\t\t\tm = m + 1\n\t\twhile m < s.length\n\t\t\tif s[l] == s[m]\n\
    \t\t\t\tm = m + 1\n\t\t\tm = m + 1\n\t\t\tif m == s.length\n\t\t\t\treturn true\n\
    \t\t\tl = l + 1\n\treturn false\nend", "  return s.length >= 3 and s.chars.all?\
    \ { |c| (c-1..c+2).all? { |c| s.index(c) == 0 } }\nend\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie pizza)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie dog pizza)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie dog pizza apple pizz)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie dog pizza apple pizza dogs)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie dog pizza apple pizza dog pizz pizza dog pizza apple pizza dog\
    \ pizza dog pizza)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\ns =\
    \ %w(apple pie dog pizza apple pizza dog pizz pizza dog pizza apple pizza dog\
    \ pizza dog pizza apple pizza dog pizza)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie dog pizza apple pizza dog pizz pizza dog pizza apple pizza dog\
    \ pizza dog pizza apple pizza dog pizza)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie dog pizza apple pizza dog pizz pizza dog pizza apple pizza dog\
    \ pizza dog pizza apple pizza dog pizza)\nis_happy(s)\n</cell>\n<code language=ruby-1.9.3-p194>\n\
    s = %w(apple pie dog pizza apple pizza dog pizz pizza dog pizza apple pizza ",
  "  if s.nil? or s.length <= 3\n    return true\n  else\n    i = 0\n    while i <\
    \ s.length\n      if s[i] != s[i+1] and  s[i] != s[i+2] and  s[i] != s[i+3]\n\
    \        return false\n      end\n      i += 1\n    end\n    return true\n  end\n\
    end", "  if s.length >= 3 and s.distinct.length == s.length / 3\n    return true\n\
    \  return false\nend", "   return s.length > 3 && s.chars.distinct.length >= 3\n\
    end\n</cell>\n<text>\nExercise 3\nThe next function checks if a word is palindrome\
    \ or not:", "  return s.length >= 3 and s.chars.all? { |c| (s.chars.count(c) -\
    \ 1).zero? }\nend", "  return s.length >= 3 && s.split('').all?(|x| x.count(x)\
    \ > 1)\nend\nis_happy('aba') #=> true\nis_happy('abc') #=> false\nis_happy('')\
    \ #=> true\nis_happy('abaa') #=> false\nis_happy('abaaa') #=> true\nis_happy('abaab')\
    \ #=> false\nis_happy('abbba') #=> false", "  s.split(\"\").all?{|c| c == c.upcase\
    \ || c == c.downcase}.nil?\nend", "  return s.length >= 3 and s.chars.inject(:+)\
    \ == s.length\nend", "  s.length >= 3 and (s.chars.distinct.count{|x| x == 3}\
    \ == 3)\nend", "  return s.length >= 3 and s.count(s[0]) == s.length and s.count(s[1])\
    \ == s.length and s.count(s[2]) == s.length and s.count(s[3]) == s.length\nend",
  "    # write your code here\n    str_chars = s.chars\n    str_length = str_chars.length\n\
    \    i = 0\n    while i < str_length\n        j = i + 1\n        while j < str_length\n\
    \            if str_chars[i] == str_chars[j] and str_chars[i] != str_chars[j]\n\
    \                return false\n            j += 1\n        i += 1\n    return\
    \ true\nend\n</cell>\n<code language=julia-1.3>", "  if s.length < 3 return false\n\
    \  s.each_char.with_index do |char, index|\n    unless index == 0\n      if s[index]\
    \ == s[index - 1]\n        return false\n      end\n    end\n  end\n  true\nend",
  "  s = s[0]\n  return s.split(//).length >= 3 and s.split(//).each do |x|\n    x.split(//).uniq.length\
    \ == s.length / 3\n  end\nend\nputs is_happy('abracadabra')\nputs is_happy('abba')\n\
    puts is_happy('abaca')\nputs is_happy('abacaba')\nputs is_happy('abacabaacaba')\n\
    puts is_happy('abacabaacabaacaba')\nputs is_happy('abbacaba')\nputs is_happy('abacad')\n\
    puts is_happy('acabababa')\nputs is_happy('babaacbabaacbaba')\nputs is_happy('abcacabcacabcacabcac')\n\
    puts is_happy('abbbabbb')\nputs is_happy('abbabaa')\nputs is_happy('abbabaaabbababbb')\n\
    puts is_happy('abbabbababbababba')\nputs is_happy('abcabcbb')\nputs is_happy('abcabcbc')\n\
    puts is_happy('abbbabbbabbbabbbabbb')\nputs is_happy('abbbbbbb')\nputs is_happy('abbbbbbbabbbbabbbb')\n\
    puts is_happy('abbbbbbbabbbbbbb')\nputs is_happy('abbbbbbbbbbb')\nputs is_happy('abbbbbbbbbbbabbbbabbb')\n\
    puts is_happy('abbbbbbbbbbbabbbbbbbbabbb')\nputs is_happy('abbbbbbbbbbbabbbbbbbbabbbbabbb')\n\
    puts is_happy('abbbbabbbbabbbbabbb')\nputs is_happy('abbbbabbbbabbbbbbb')\nputs\
    \ is_happy('abbbbabbbbabbbbbbbabbbbabbb')\nputs is_happy('abbbbabbbbabbbbbbbabbbbabbbbabbb')\n\
    puts is_happy('abbbbabbbbabbbbbbbabbbbabbbbabbbbabbb')\nputs is_happy('abbbbabbbbabbbbabbbabbbbabbbbabbb')\n\
    puts is_happy('abbbbabbbbabbbbabbbabbbbabbbbabbbbabbb')\nputs is_happy('abbbbabbbbabbbbbbbabbbbabbbbabbbbabbb')\n\
    puts is_happy('abbbbab", "  return s.length >= 3 and s.chars.each_cons(3).all?\
    \ { |ss| (ss & ss).length == 3 }\nend\nis_happy(\"happy\") #=> true\nis_happy(\"\
    happyp\") #=> false\nis_happy(\"psapy\") #=> true\nis_happy(\"peapy\") #=> false\n\
    is_happy(\"as\") #=> false\nis_happy(\" \") #=> false\nis_happy(\"asdasda\") #=>\
    \ false", "  # write your code\nend", "  str.length >= 3 && s.chars.each_cons(3).all?\
    \ { |str| str.length == 3 && str.chars.uniq.all? { |c| c.to_s == c } }\nend\n\
    </cell>\n<cell>\nis_happy(\"abba\") #=> true\nis_happy(\"abcd\") #=> false\nis_happy(\"\
    abce\") #=> true\nis_happy(\"abcde\") #=> false\nis_happy(\"abca\") #=> false\n\
    is_happy(\"aaaa\") #=> false\n</cell>\n<cell>", "  s.count(\"a\")+s.count(\"b\"\
    )+s.count(\"c\") >= 3\nend", "  return s.length >= 3 && s.split('').all? {|x|\
    \ s.count(x) == 3}\nend", "  s.length >= 3 and s.chars.uniq.size == 3\nend", " \
    \   count = 0\n    for i in  s[0,1]..s[-1,1]\n        if s[0,1] == s[i]\n    \
    \        count += 1\n        end if\n        if s[-1,1] == s[i]\n            count\
    \ += 1\n        end if\n        if s[1,-1] == s[i]\n            count += 1\n \
    \       end if\n        end for\n    end if\n    return count >= 3\nend function\n\
    </cell>\n<code language=julia-1.0>", "  s.chars.each_cons(3).all?{ |arr| arr.uniq.size\
    \ == 3 }\nend", "  s.gsub(/\\W/,'')\n  s.split('')\n  puts s.split('').uniq.length\
    \ >= 3 &&\n    !s.split('').uniq.grep(/^\\W/).any?\nend\n</code>\nIt produces\
    \ no output when run for is_happy(\"hello\")\n<code>\n$ ruby happy.rb\n</code>\n\
    It also produces no output when run for is_happy(\"Hello\")\n<code>\n$ ruby happy.rb\n\
    </code>\nIt also produces no output when run for is_happy(\"aa\")\n<code>\n$ ruby\
    \ happy.rb\n</code>\nIt also produces no output when run for is_happy(\"ab\")\n\
    <code>\n$ ruby happy.rb\n</code>\nIt also produces no output when run for is_happy(\"\
    abc\")\n<code>\n$ ruby happy.rb\n</code>\nIt also produces no output when run\
    \ for is_happy(\"abcd\")\n<code>\n$ ruby happy.rb\n</code>\nIt also produces no\
    \ output when run for is_happy(\"a3b\")\n<code>\n$ ruby happy.rb\n</code>\nIt\
    \ also produces no output when run for is_happy(\"a3b4\")\n<code>\n$ ruby happy.rb\n\
    </code>\nIt also produces no output when run for is_happy(\"123\")\n<code>\n$\
    \ ruby happy.rb\n</code>\nIt also produces no output when run for is_happy(\"\
    1234\")\n<code>\n$ ruby happy.rb\n</code>\nIt also produces no output when run\
    \ for is_happy(\"12345\")\n<code>\n$ ruby happy.rb\n</code>\nIt also produces\
    \ no output when run for is_happy(\"123456\")\n<code>\n$ ruby happy.rb\n</code>\n\
    It also produces no output when run for is_happy(\"abcdefg\")\n<code>\n$ ruby\
    \ happy.rb\n</code>\nIt also produces no output when run for is_happy(\"abcdefgh\"\
    )\n<code>\n$ ruby happy.rb\n</code>\nIt also produces no output when run for is_happy(\"\
    abcdefghi\")\n<code>\n$ ruby happy.rb\n</code>\nIt also produces no output when\
    \ run for is_happy(\"abcdefghij\")\n<code>\n$ ruby happy.rb\n</code>\nIt also\
    \ produces no output when run for is_happy(\"abcdefghijk\")\n<code>\n$ ruby happy.rb\n\
    </code>\nIt also produces no output when run for is_happy(\"abcdefgh", "  # check\
    \ if s is empty\n  if s.empty?\n    false\n  # check if s length is at least 3\n\
    \  elsif s.length < 3\n    false\n  # check if every 3 consecutive letters are\
    \ distinct\n  elsif s.chars.uniq.length % 3 != 0\n    false\n  # otherwise, return\
    \ true\n  else\n    true\n  end\nend", "  s.length >= 3 &&\n  s.chars.each_cons(3).all?\
    \ do |chars| # each_cons will iterate over all three-letter combinations\n   \
    \ chars.all? { |char| char.unique?}\n  end\nend", "    # Write your code here\n\
    \    return True if len(s)>=3 and all(s[i]!=s[i] for i in range(len(s)-3)) else\
    \ False\n\"\"\"\n</cell>\n<cell>", "    length = 3\n    count = 0\n    \n    while\
    \ length > 0\n        if s.chars.join.chars.compact.length % length != 0\n   \
    \         length += 1\n        else\n            count = 0\n        end \n   \
    \ end \n    \n    return length >= 3\nend \n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"hello\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"lo\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"lol\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"olo\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"oll\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"olol\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"olooo\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"helloo\")\n\
    </cell>\n<code language=julia-1.0>\nis_happy(\"hiho\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"hihi\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"hhii\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"hhi\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"hihiii\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"hihiiii\"\
    )\n</cell>\n<code language=julia-1.0>\nis_happy(\"hihiiiii\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"hihiiiiii\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"hihiiiiiii\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"hihiiiiiiii\"\
    )\n</cell>\n<code language=julia-1.0>\nis_happy(\"hihiiiiiiiii\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"hihiiiiiiiiii\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"hihiiiiiiiiiii\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"\
    hihiiiiiiiiiiii\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"hihiiiiiiiiiiiii\"\
    )\n</cell>\n<code language=julia-1.0>\nis_happy(\"hihiiiiiiiiiiiiiii\")\n</cell",
  "  len = s.length\n  return len >= 3 && s.chars.distinct.length >= 3\nend", "  s.gsub!(/[[:blank:]]/,\
    \ \"\") # Remove whitespace\n  if s.length < 3 or s.slice!(0) != s\n    return\
    \ false\n  end\n  s.each_index { |i| return false if s[i] == s[i+1] }\n  true\n\
    end", "  s = s.downcase\n  s.length >= 3 && s.split('').uniq.count >= 3\nend\n\
    </pre>\n</div>\n<div id=\"ruby-example\" class=\"section level2\">\n<h2>Ruby example</h2>\n\
    <pre class=\"code ruby\">\n<span class=\"id\">@happy_strings</span> = <span class=\"\
    const\">%w(apple orange banana pear)</span>\n<span class=\"id\">@happy_strings</span>.<span\
    \ class=\"id\">map</span> {|str| <span class=\"id\">is_happy</span>(str) }\n</pre>\n\
    <p>\nOutput: [true, false, true]\n</p>\n<pre class=\"code ruby\">\n<span class=\"\
    id\">@happy_strings</span> = <span class=\"const\">%w(apple orange banana pear\
    \ pineapple)</span>\n<span class=\"id\">@happy_strings</span>.<span class=\"id\"\
    >map</span> {|str| <span class=\"id\">is_happy</span>(str) }\n</pre>\n<p>\nOutput:\
    \ [true, false, true]\n</p>\n<pre class=\"code ruby\">\n<span class=\"id\">@happy_strings</span>\
    \ = <span class=\"const\">%w(apple orange banana pear pineapple grape)</span>\n\
    <span class=\"id\">@happy_strings</span>.<span class=\"id\">map</span> {|str|\
    \ <span class=\"id\">is_happy</span>(str) }\n</pre>\n<p>\nOutput: [true, false,\
    \ true]\n</p>\n<p>\nThe last one was an exercise!\n</p>\n</div>\n<div id=\"python-example\"\
    \ class=\"section level2\">\n<h2>Python example</h2>\n<pre class=\"code python\"\
    >\n<span class=\"id\">happy_strings</span> = [\n    <span class=\"str\">'apple',</span>\n\
    \    <span class=\"str\">'orange',</span>\n    <span class=\"str\">'banana',</span>\n\
    \    <span class=\"str\">'pear'</span>,\n    <span class=\"str\">'pineapple',</span>\n\
    \    <span class=\"str\">'grape'</span>,\n]", "  s = String.new(s) # or s = s\n\
    \  return s.chars.length >= 3 && !s.chars.group_by{|s| s}.values.any?(&:nil?)\n\
    end", "  return s.length >= 3 && s.chars.all?(::Char::isDistinctFrom)\nend", "\t\
    str.len() >= 3 && s.each_char.distinct.count { |letter| letter != s[0,3] }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nYour solution is O(n) complexity, which is fine for\
    \ small cases. But you forgot to add `&&`. You would need a second `and` for the\
    \ `&&` check in the `if` statement.\n<|/ c |>\n<| c |>\nYes indeed you forgot.\
    \ Fixed. Thanks.\n<|/ c |>\n<| c |>\nNice. I've just added an explanation below\
    \ the code sample.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s = s.downcase\n\
    \  s.chars.each_with_index do |c, i|\n    next if i == s.size - 1\n    next if\
    \ s.chars.slice(i + 1).include?(c)\n    puts \"#{c} repeated #{i+1} times\"\n\
    \  end\n  true\nend\nis_happy('heyyo')", "    return s.length >= 3 && all?(s.chars,\
    \ &:unique?)\nend\n</cell>\n<cell>", "  s.is_a?(String)\n  s.is_happy?\nend\n\
    assert is_happy(\"happy\") == true\nassert is_happy(\"Happy\") == false\nassert\
    \ is_happy(\"Happy!\") == false", "  is_happy = s.length >= 3 and s.chars.group_by.all?{|c|\
    \ c == \"a\"} # or whatever your ruby function is\nend\nis_happy(\"baacbb\") #=>\
    \ false\nis_happy(\"a\") #=> true\nis_happy(\"ab\") #=> true\nis_happy(\"abacab\"\
    ) #=> true\nis_happy(\"abaca\") #=> false\nis_happy(\"abacabacabacab\") #=> false\n\
    is_happy(\"abacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacab",
  "  if s.length < 3 || s.length % 3 != 0\n    return false\n  \n  seen = {}\n  \n\
    \  count = 0\n  for char in s\n    if char in seen\n      return false\n    seen[char]\
    \ = true\n    count += 1\n  end\n  \n  return true\nend", "    \n    return s.length\
    \ >= 3 and s.chars.uniq.count.between?(1,3)\nend\n</cell>\n<cell>", "    s.length\
    \ >= 3 and s.chars.uniq.length >= 3\nend\n</pre>\n            </div>\n       \
    \   \n          \n          \n          \n          \n            \n         \
    \   <div class=\"sourcecode\">\n              \n              <p class=\"source-link\"\
    >\n                Source: \n                <a href=\"javascript:toggleSource('method-i-is_happy-source')\"\
    \ id=\"l_method-i-is_happy-source\">show</a>\n                \n             \
    \ </p>\n              <div id=\"method-i-is_happy-source\" class=\"dyn-source\"\
    >\n                <pre><span class=\"ruby-comment\"># File /usr/local/rvm/gems/ruby-2.0.0-p0/gems/claide-0.5.1/lib/claide/command.rb,\
    \ line 31</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">is_happy</span>(<span class=\"ruby-identifier\">s</span>)\n  <span\
    \ class=\"ruby-identifier\">s</span>.<span class=\"ruby-identifier\">length</span>\
    \ <span class=\"ruby-operator\">&gt;=</span> <span class=\"ruby-number\">3</span>\
    \ <span class=\"ruby-operator\">&amp;&amp;</span> <span class=\"ruby-identifier\"\
    >s</span>.<span class=\"ruby-identifier\">chars</span>.<span class=\"ruby-identifier\"\
    >uniq</span>.<span class=\"ruby-identifier\">length</span> <span class=\"ruby-operator\"\
    >&gt;=</span> <span class=\"ruby-number\">3</span>\n<span class=\"ruby-keyword\"\
    >end</span></pre>\n              </div>\n            </div>\n            \n  \
    \        </div>\n        \n        <div class=\"method\">\n          <div class=\"\
    title method-title\" id=\"method-i-is_not\">\n            \n              <b>is_not</b>()\n\
    \            \n            <a href=\"../../../classes/Clade/Clade.html#method-i-is_not\"\
    \ name=\"method-i-is_not\" class=\"permalink\">Link</a>\n          </div>\n  \
    \        \n          \n            <div class=\"description\">\n             \
    \ \n            </div>\n          \n          \n          \n          \n     \
    \     \n            \n            <div class=\"sourcecode\">\n              \n\
    \              <p class=\"source-link\">\n                Source: \n         \
    \       <a href=\"javascript:toggleSource('method-i-is_not-source')\" id=\"l_method-i-is_not-source\"\
    >show</a>\n                \n              </p>\n              <div id=\"method-i-is_not-source\"\
    \ class=\"dyn-source\">\n                <pre><span class=\"ruby-comment\"># File\
    \ /usr/local/rvm/gems/ruby-2.0.0-p0/gems/claide-0.5.1/lib/claide/command.rb, line\
    \ 37</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">is_not</span>\n  <span class=\"ruby-identifier\">is_happy</span>(<span\
    \ class=\"ruby-ivar\">@command_result</span>)\n<span class=\"ruby-keyword\">end</span></pre>\n\
    \              </div>\n            </div>\n            \n          </div>\n  \
    \      \n        <div class=\"method\">\n          <div class=\"title method-title\"\
    \ id=\"method-i-is_not?\">\n            \n              <b>is_not?</b>()\n", " \
    \ arr = s.downcase.split(//)\n  arr.uniq.length >= 3 and arr.all? { |x| x.size\
    \ == 3 && x.uniq.size == 1 }\nend", "  puts \"Happy\" if s.length >= 3 && s.chars.uniq.count\
    \ == 3 \nend\nprint is_happy(\"Happy\") # => Happy\nprint is_happy(\"Happy Happy\"\
    ) # => Happy\nprint is_happy(\"Happy Happy Happy\") # => Happy", "    # Write\
    \ your code here\n    if len(s) < 3 or s[0] != s[1] != s[2] or s[1] != s[2] or\
    \ s[2] != s[3] or s[0] != s[2] or s[1] != s[3] or s[2] != s[3] or s[3] != s[4]\
    \ or s[0] != s[1] != s[3] or s[1] != s[2] != s[3] or s[2] != s[3] != s[4] or s[2]\
    \ != s[3] != s[4] or s[3] != s[4] != s[5] or s[0] != s[1] != s[2] != s[3] != s[4]\
    \ != s[5] or s[1] != s[2] != s[3] != s[4] != s[5] or s[2] != s[3] != s[4] != s[5]\
    \ or s[3] != s[4] != s[5] != s[6] or s[0] != s[1] != s[2] != s[3] != s[4] != s[5]\
    \ != s[6] or s[1] != s[2] != s[3] != s[4] != s[5] != s[6] or s[2] != s[3] != s[4]\
    \ != s[5] != s[6] or s[3] != s[4] != s[5] != s[6] != s[7]\n        return false\n\
    \    return true\nend\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\"\
    )\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\n\
    is_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\"\
    )\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\n\
    is_happy(\"a\")\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\")\n</cell>\n\
    <code language=julia-1.4>\nis_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\n\
    is_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\"\
    )\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\n\
    is_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\"\
    )\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\n\
    is_happy(\"abacad\")\n</cell>\n<code language=julia-1.4>\nis_happy(\"abacad\"\
    )\n</cell>\n<code language=julia-1.4>", "    # your code here\n    return false\n\
    end", "  s.each_char.with_index.with_index do |x,i,j|\n    if (i + (j - i) % 3)\
    \ == 3 \n      puts x\n      return false\n    end\n  end\nend", "    str_len\
    \ = s.length\n    str_happy = true\n    \n    # check if string is at least 3\
    \ and it's length is greater than 3 \n    if str_len < 3\n        str_happy =\
    \ false\n    \n    # check if all 3 chars are distinct\n    count = 0\n    for\
    \ i in 1..str_len\n        count += s[i] == s[i]\n        if count == 3\n    \
    \        str_happy = false\n            break\n    end", "  return s.length >=\
    \ 3 and s.chars.uniq.length >= 3\nend", "    puts s\n    puts s.length\n    #\
    \ put your code here\nend\n</cell>\n<code language=julia-1.0>\nis_happy(\"hello\"\
    )\n</cell>\n<code language=julia-1.0>\nis_happy(\"test\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"aa\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaa\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"aaaa\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"aaaaa\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaa\")\n\
    </cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaa\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"aaaaaaaaa\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaaaa\"\
    )\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaaaaa\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"aaaaaaaaaaaa\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"aaaaaaaaaaaaa\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaa\"\
    )\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaa\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaa\")\n</cell>\n<code language=julia-1.0>\n\
    is_happy(\"aaaaaaaaaaaaaaaaaaa\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"\
    aaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaa\"\
    )\n</cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaa\")\n\
    </cell>\n<code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n<code\
    \ language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n</cell>\n\
    <code language=julia-1.0>\nis_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n", " \
    \ if s.length < 3 return false\n  s.each_char.each_cons(3).all? { |c1,c2,c3| c1==c2==c3\
    \ }\nend", "  # your code here\n  return True\nend\n</cell>\n<code language=julia-1.5>\n\
    is_happy(\"AABBC\")\n</cell>\n<code language=julia-1.5>\nis_happy(\"AABBC\")\n\
    </cell>\n<code language=julia-1.5>\nis_happy(\"AABBC\")\n</cell>\n<code language=julia-1.5>\n\
    is_happy(\"AABBC\")\n</cell>\n<text>\n(Optional) Exercises", "  s = s.to_s\n \
    \ is_happy = false\n  if s.length >= 3\n    (s.length % 3).times do |i|\n    \
    \  if s[i+i] != s[i+i+1]\n        is_happy = false\n        break\n      end\n\
    \    end\n  end\n  return is_happy\nend\n</pre>\n<p>\nNext let's write a test\
    \ case.\n</p>\n<pre class=\"ruby\"><code>assert_equal(true,\n            isHappy('happy'))\n\
    assert_equal(false,\n            isHappy('Happy'))\nassert_equal(false,\n    \
    \        isHappy('happyHappy'))\nassert_equal(true,\n            isHappy('happyHappyHappy'))\n\
    </pre>\n<p>\nThe <code>assert</code> and <code>assert_equal</code> are Ruby's\
    \ built-in assertions.\nThe <code>assert_equal</code> method compares two objects\
    \ (in this case, strings) and\noutputs a message if the comparison fails.\n</p>\n\
    <pre class=\"ruby\"><code>assert_equal\n   assert_equal equality_value,\n   message\
    \ [, expected_expr]\n   assert_equal equality_value,\n   message [, expected_expr1,\n\
    \            expected_expr2, ...]\n</pre>\n<p>\nIn our test case, we have already\
    \ created a boolean variable.\nWe need to compare this boolean variable with <code>true</code>\
    \ or\n<code>false</code>. There are several ways to do that.\n</p>\n<pre class=\"\
    ruby\"><code>assert_equal(true, is_happy('happy'))\nassert_equal(false, is_happy('Happy'))\n\
    assert_equal(false, is_happy('happyHappy'))\nassert_equal(true, is_happy('happyHappyHappy'))\n\
    </pre>\n<p>\nWe are using Ruby's built-in <code>==</code> operator to compare\
    \ our boolean variable\nwith the <code>true</code> or <code>false</code> constants.\
    \ We can also use <code>!=</code>\nif we want the test to fail if the variable\
    \ is <code>true</code>.\n</p>\n<pre class=\"ruby\"><code>assert_equal(!false,\
    \ is_happy('Happy'))\n</pre>\n<p>\nFinally, let's write our test file.\n</p>\n\
    <pre class=\"ruby\"><code>cd <span class=\"ruby-identifier\">bin</span>\ncp <span\
    \ class=\"ruby-ivar\">@react_on_rails_scripts_bin</span> <span class=\"ruby-ivar\"\
    >@react_on_rails_scripts_bin</span>.<span class=\"ruby-identifier\">old</span>\n\
    <span class=\"ruby-identifier\">mkdir</span> <span class=\"ruby-ivar\">@react_on_rails_scripts_bin</span>.<span\
    \ class=\"ruby-identifier\">old</span>\n<span class=\"ruby-identifier\">chmod</span>\
    \ <span class=\"ruby-value\">0755</span> <span class=\"ruby-ivar\">@react_on_",
  "  if s.length >= 3\n    chars = s.split('')\n    chars.delete_if { |char| char.even?\
    \ }\n    chars.uniq.length == chars.length && chars.uniq.size == 3\n  else\n \
    \   false\n  end\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"\
    cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"\
    >\n</div><div class=\"inner_cell\">\n<div class=\"text_cell_render border-box-sizing\
    \ rendered_html\">\n<h2 id=\"Excercise\">Excercise<a class=\"anchor-link\" href=\"\
    #Excercise\">&#182;</a></h2>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing\
    \ code_cell rendered\">\n<div class=\"input\">\n<div class=\"prompt input_prompt\"\
    >In&nbsp;[&nbsp;]:</div>\n<div class=\"inner_cell\">\n    <div class=\"input_area\"\
    >\n<div class=\" highlight hl-julia\"><pre><span></span><span class=\"k\">for</span>\
    \ <span class=\"n\">i</span> <span class=\"kp\">in</span> <span class=\"mi\">1</span><span\
    \ class=\"o\">:</span><span class=\"mi\">12</span>\n    <span class=\"n\">println</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;\\$ </span><span class=\"si\">$i</span><span\
    \ class=\"s\"> :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >))</span>\n    <span class=\"n\">println</span><span class=\"p\">(</span><span\
    \ class=\"s\">&quot;\\$  </span><span class=\"si\">$i</span><span class=\"s\"\
    > :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >,</span> <span class=\"n\">true</span><span class=\"p\">))</span>\n    <span\
    \ class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">&quot;\\\
    $  </span><span class=\"si\">$i</span><span class=\"s\"> :&quot;</span><span class=\"\
    p\">,</span> <span class=\"n\">string_to_boolean</span><span class=\"p\">(</span><span\
    \ class=\"s\">&quot;$i&quot;</span><span class=\"p\">,</span> <span class=\"n\"\
    >false</span><span class=\"p\">))</span>\n    <span class=\"n\">println</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;\\$  </span><span class=\"si\">$i</span><span\
    \ class=\"s\"> :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >,</span> <span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"\
    n\">false</span><span class=\"p\">))</span>\n    <span class=\"n\">println</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;\\$  </span><span class=\"si\">$i</span><span\
    \ class=\"s\"> :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >,</span> <span class=\"n\">false</span><span class=\"p\">,</span> <span class=\"\
    n\">false</span><span class=\"p\">))</span>\n    <span class=\"n\">println</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;\\$  </span><span class=\"si\">$i</span><span\
    \ class=\"s\"> :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >,</span> <span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"\
    n\">false</span><span class=\"p\">,</span> <span class=\"n\">false</span><span\
    \ class=\"p\">))</span>\n    <span class=\"n\">println</span><span class=\"p\"\
    >(</span><span class=\"s\">&quot;\\$  </span><span class=\"si\">$i</span><span\
    \ class=\"s\"> :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >,</span> <span class=\"n\">false</span><span class=\"p\">,</span> <span class=\"\
    n\">false</span><span class=\"p\">,</span> <span class=\"n\">false</span><span\
    \ class=\"p\">))</span>\n    <span class=\"k\">println</span><span class=\"p\"\
    >(</span><span class=\"s\">&quot;\\$  </span><span class=\"si\">$i</span><span\
    \ class=\"s\"> :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >,</span> <span class=\"n\">true</span><span class=\"p\">,</span> <span class=\"\
    n\">true</span><span class=\"p\">))</span>\n    <span class=\"k\">println</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;\\$  </span><span class=\"si\">$i</span><span\
    \ class=\"s\"> :&quot;</span><span class=\"p\">,</span> <span class=\"n\">string_to_boolean</span><span\
    \ class=\"p\">(</span><span class=\"s\">&quot;$i&quot;</span><span class=\"p\"\
    >,</span> <span class=\"n\">false", "  if s.nil?\n    false\n  elsif s.length\
    \ < 3\n    false\n  else\n    count = 1\n    i = 0\n    while i < s.length\n \
    \     j = i + 1\n      if count > s.length\n        j = i + 1\n      end\n   \
    \   if s[i] != s[i+1]\n        if s[i] != s[j-1]\n          count = 0\n      \
    \  else\n          count += 1\n        end\n      end\n      i += 1\n    end\n\
    \    return true\n  end\nend", "  if s.length < 3\n    return false\n  else\n\
    \    h = s.each_char.group_by{|x| x.to_i}.each_value.none?{ |x| x.uniq.length\
    \ != 3 }\n    return h\n  end\nend", "  str_array = s.split('')\n  str_array.each\
    \ do |letter|\n    if letter == 'a'\n      true\n    elsif letter == 'a'\n   \
    \   true\n    else\n      false\n    end\n  end\nend", "  return s.length >= 3\
    \ and s.chars.uniq.count > 3\nend\nis_happy(\"happy\") # => true\nis_happy(\"\
    happypp\") # => false\nis_happy(\"happyp\") # => false\nis_happy(\"happpp\") #\
    \ => false\nis_happy(\"pp\") # => false\nis_happy(\"zzzz\") # => false\nis_happy(\"\
    \ \") # => false\nis_happy(\"\") # => false\nis_happy(\"a\") # => false\n</pre>\n\
    </div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"footer\">\n<div id=\"footer-text\"\
    >\nLast updated 2016-03-07 23:32:45 by\n<a href=\"https://github.com/upstage/upstage/commits/master.atom\"\
    >commit information</a>\n</div>\n</div>\n</body>\n</html>\n<|/ file |>\n<| c |>\n\
    Hi, this is great solution. One question - why did you use 'join' instead of 'split'?\n\
    <|/ c |>\n<| c |>\n, I don't think `join` makes a difference. It makes the code\
    \ more readable.\n<|/ c |>\n<| c |>\nThanks for sharing your knowledge!\n<|/ c\
    \ |>\n<| c |>\nThe first line of your second solution can be shortened to: `return\
    \ s.chars.uniq.count >= 3`.\n<|/ c |>\n<| c |>\n: It also makes the code more\
    \ efficient (avoids a `split` call). See my answer.\n<|/ c |>\n<| a dscore=5 |>\n\
    The easiest way is this:\n<code>\ns.split.length >= 3\n</code>\nIf you need to\
    \ check more conditions, you can do this:\n<code>\ns.split.all?{|e| e.length >=\
    \ 3}\n</code>\nIf you need to support strings with non-ASCII characters, you can\
    \ use this:\n<code>\ns.split.all?{|e| e.length >= 3} && s.split.all?{|e| e.valid_encoding?}\n\
    </code>\nIf you need to support strings with UTF-8 characters, you can do this:\n\
    <code>\ns.split.all?{|e| e.length >= 3} && s.split.all?{|e| e.valid_encoding?}\
    \ && s.split.all?{|e| e.valid_encoding?}\n</code>\nIf you need to support strings\
    \ with Unicode code points up to U+10FFFF, you can do this:\n<code>\ns.split.all?{|e|\
    \ e.length >= 3} && s.split.all?{|e| e.valid_encoding?} && s.split.all?{|e| e.valid_encoding?}\
    \ && s.split.all?{|e| ", "  # write your code in Ruby\n  # Example :\n  \n  #\
    \ \"hello\" => true\n  # \"hell\" => true\n  # \"herr\" => false\n  # \"he\" =>\
    \ false\n  # \"hey\" => true\n  # \"hel\" => false\n  # \"hee\" => false", " \
    \ return s.length >= 3 && s.chars.sort.uniq.count >= 3\nend\n</pre>\n        \
    \  <h4 id=\"finding-the-last-word-from-a-string-to-the-end\">Finding the last\
    \ word from a string to end</h4>\n          <p>\n            This can be done\
    \ in O(length(s)) time. You will need to find the index of the last letter in\
    \ the string,\n            then find the first letter in the string from the last\
    \ index.\n          </p>\n          <pre data-filter-output=\"(out)\" data-role=\"\
    codeBlock\" data-info=\"js\"\n            class=\"language-javascript data-line\
    \ line-numbers data-user data-host data-prompt data-output\"\n            data-prismjs-copy=\"\
    Copy !\" data-download-link=\"\"\n            data-original-code=\"userInput.lastIndex;\n\
    var lastWord = userInput.substring(lastIndex, userInput.length)\nvar firstWord\
    \ = userInput.substring(lastIndex - 3, lastIndex)\"\n            data-sandbox=\"\
    userInput.lastIndex;\nvar lastWord = userInput.substring(lastIndex, userInput.length)\n\
    var firstWord = userInput.substring(lastIndex - 3, lastIndex)\">\n          <code\
    \ id=\"finding-the-last-word-from-a-string-to-the-end\" type=\"javascript\" data-for=\"\
    finding-the-last-word-from-a-string-to-the-end\">\nfunction lastWord(s) {\n  return\
    \ s.substring(s.length - 1, s.length);\n}"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
