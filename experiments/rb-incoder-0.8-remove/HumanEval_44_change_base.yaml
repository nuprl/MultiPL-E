name: HumanEval_44_change_base
language: rb
prompt: "# Change numerical base of input number x to base.\n# return string representation\
  \ after the conversion.\n# base numbers are less than 10.\ndef change_base(x, base)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n\
  \    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8,\
  \ 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\"\
  , candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n\
  \    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7,\
  \ 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3,\
  \ 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5,\
  \ 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7,\
  \ 8))\n  end\nend\n"
completions: ["    return x.to_s(base)\nend", "  s = x.to_s\n  return s.chars.map\
    \ { |i| i.to_i(base) }\nend", "  case \n    when base < 2 \n      raise ArgumentError\
    \ \"base must be >= 2.\"\n    when base > 36 \n      raise ArgumentError \"base\
    \ must be <= 36.\"\n    when base == 2 \n      return x.to_s\n    else\n     \
    \ return x.to_s(base)\n  end\nend", "  base = base.to_i\n  return \"#{x.to_s(base)}\"\
    .to_i\nend", "  if x <> 0 then\n    if base > 0 then\n      if base < 10 then\n\
    \        local a = math.floor(x/base)\n        return a\n      else\n        return\
    \ nil\n      end\n    else\n      return nil\n    end\n  else\n    return nil\n\
    \  end\nend", "  if base < 2\n    raise(\"Base must be greater than 1\")\n  end\n\
    \  if base > 36\n    raise(\"Base must be less than 36\")\n  end\n  if x.is_a?(Integer)\n\
    \    if base == 10\n      return x.to_s\n    end\n    return x.to_s(base)\n  else\n\
    \    if base == 10\n      return x.to_s\n    end\n    raise(\"Not an Integer\"\
    )\n  end\nend", "  digits = []\n  while x != 0\n    digit = x % base\n    digits.push(digit)\n\
    \    x = x / base\n  end\n  digits.reverse!\n  return digits.to_s\nend", "  #\
    \ if base is not in range [2, 36] then return empty string.\n  base_digits = [\
    \ '', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine',\
    \ 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen',\
    \ 'eighteen', 'nineteen' ]\n  base_digits_len = base_digits.length\n  base_digits_map\
    \ = { 1 => '', 2 => 'tw', 3 => 'thr', 4 => 'for', 5 => 'fiv', 6 => 'sixf', 7 =>\
    \ 'sev', 8 => 'eigh', 9 => 'nine' }\n  base_digits_map.each do |k, v|\n    if\
    \ base == k\n      base_digits_map[k] = v\n      break\n    end\n  end\n  # if\
    \ base is not in range [2, 36] then return empty string.\n  if base_digits_map[base].length\
    \ == 0\n    return ''\n  end\n  # if base is greater than base 36 then return\
    \ empty string.\n  if base > base_digits_len\n    return ''\n  end\n  # if x is\
    \ greater than base 36 then return empty string.\n  if x > (base_digits_len -\
    \ base)\n    return ''\n  end\n  # return base_digits_map[base].rjust(x, '0')\
    \ + (base_digits_len-x).to_s\n  base_digits_map[base].rjust(x, '0')\nend", " \
    \   x.to_s(base).rjust(10)\nend", "  x = x.to_i # Convert to integer first.\n\
    \  base = base.to_i\n  return x.to_s(base).reverse\nend", "  return x.to_s(base)\n\
    end", "    digits = x.to_s.reverse.to_i(base)\n    if digits < 10\n        return\
    \ x.to_s.reverse.to_s(base)\n    end\n    \n    return x.to_s.reverse.to_s(base)\
    \ + change_base(digits, base).to_s.reverse.to_i(base)\nend", "  # Convert the\
    \ base number to an integer.\n  base_in_int = base.to_i\n  # Convert x to an integer.\n\
    \  x_in_int = x.to_i\n  # Calculate the new value of the number.\n  result = x_in_int\
    \ / base_in_int\n  # Convert back to a string.\n  result = base.to_s(result)\n\
    \  # Return the result\n  result\nend", "  if x == 0 then\n    return 0\n  elseif\
    \ base > 0 then\n    if base == 2 then\n      return \"#o\" + change_base(x, base)\n\
    \    end\n    base = change_base(x % base, base)\n  else\n    return \"<BASE #{base}>\"\
    \n  end\nend", "  return x.to_s.chars.reverse.each_cons(base).map(&:reverse).join.to_i\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\n+1 I like the clever approach to this.\
    \  I did a search on \"base\" but couldn't find anything close to this.\n<|/ c\
    \ |>\n<| c |>\nThanks, I liked the `each_cons` method too\n<|/ c |>\n<| c |>\n\
    This is very nice and elegant. One minor caveat: it seems to work fine for `base`\
    \ up to 32 for some reason (it returns an integer value up to 32 for bases above\
    \ 32).\n<|/ c |>\n<| c |>\nIf you're looking to convert base 16 strings to base10,\
    \ you may need to run it through [`unpack`](https://ruby-doc.org/core-2.5.3/String.html#method-i-unpack)\
    \ with `:h`. This will change `\"001\"` to `3`, but `\"011\"` stays as `\"011\"\
    `.\n<|/ c |>\n<| c |>\nGreat answer - but this can only convert a number to a\
    \ given base up to a certain point. For example: convert_base(\"10\",16) => 10\n\
    convert_base(\"10\",17) => \"c\"\nconvert_base(\"10\",18) => \"d\"\nconvert_base(\"\
    10\",19) => \"f\"\nconvert_base(\"10\",20) => 10\nconvert_base(\"10\",21) => \"\
    f\"\nconvert_base(\"10\",22) => \"f\"\nconvert_base(\"10\",23) => \"f\"\nconvert_base(\"\
    10\",24) => \"f\"\nconvert_base(\"10\",25) => \"f\"\nconvert_base(\"10\",26) =>\
    \ 10\nconvert_base(\"10\",27) => \"f\"\nconvert_base(\"10\",28) => \"f\"\nconvert_base(\"\
    10\",29) => \"f\"\nconvert_base(\"10\",30) => 10\nconvert_base(\"10\",31) => \"\
    f\"\nconvert_base(\"10\",32) => 10\nconvert_base(\"10\",33) => \"f\"\nconvert_base(\"\
    10\",34) => \"f\"\nconvert_base(\"10\",35) => \"f\"\nconvert_base(\"10\",36) =>\
    \ \"f\"\nconvert_base(\"10\",37) => \"f\"\nconvert_base(\"10\",38) => \"f\"\n\
    convert_base(\"10\",39) => \"f\"\nconvert_base(\"10\",40) => \"f\"\nconvert_base(\"\
    10\",41) => \"f\"\nconvert_base(\"10\",42) => \"f\"\nconvert_base(\"10\",43",
  "  x = x.to_s.to_i\n  base = base.to_s.to_i", "  # convert x to string\n  x = x.to_s\n\
    \  # check base\n  if base < 0\n    raise ArgumentError \"base #{base} must be\
    \ non-negative\"\n  elsif base > 36\n    raise ArgumentError \"base #{base} must\
    \ be less than or equal to 36\"\n  else\n    # initialize output value\n    y\
    \ = ''\n    # convert number from base to base\n    while x != ''\n      y = base_conversion(x,\
    \ base)\n      x = x.slice!(0...-1)\n    end\n    # return y as a string\n   \
    \ y.to_s\n  end\nend", "  if base < 2\n    puts \"Base conversion not allowed\
    \ for numbers less than 10.\"\n  elsif base > 36\n    puts \"Base conversion not\
    \ allowed for numbers more than 36.\"\n  elsif base = 36\n    puts \"Base conversion\
    \ not allowed since base is 36.\"\n  else\n    return (x * base).tos(base)\n \
    \ end\nend", "  x = x.to_s.reverse\n  base = base.to_s\n  \n  n = x.length", " \
    \   # Base conversion is done by converting a number to an\n    # equivalent decimal\
    \ representation and back.\n    if base==2:\n        return int(x)\n    else:\n\
    \        return str(x)", "  new_num = x.to_s.reverse\n  i = 0\n  new_num.each_char.with_index\
    \ do |char, index|\n    if char == char.chr # change number if char is a digit\n\
    \      new_num[index] = base.to_s.reverse \n    end\n    i += 1\n  end\n  new_num.reverse\n\
    end", "  if x < 0\n    return \"Number must be positive and non-negative.\"\n\
    \  elsif base < 2 || base > 64\n    return \"Base must be between 2 and 64.\"\n\
    \  elsif base == 2\n    str = x.to_s\n    str = str.reverse.to_s\n    str = str.ljust((str.length\
    \ + 1) * 1, \"0\")\n    return str\n  else\n    str = x.to_s\n    base = 64 -\
    \ base\n    str = str.reverse.to_s\n    str = str.ljust(base, \"0\")\n    return\
    \ str\n  end\nend", "\tif x <= base\n\t\treturn x\n\tdiv = x.to_i / base.to_i\n\
    \trem = x.to_i % base.to_i\n\tres = x.to_i\n\twhile rem > 0\n\t\tres = res * base.to_i\n\
    \t\trem = rem / base.to_i\n\tend\n\twhile div > 0\n\t\tres = res / base.to_i\n\
    \t\tdiv = div % base.to_i\n\tend\n\treturn res\nend\nend", "\treturn x.to_s(base)\n\
    end\nend", "  case base\n  when 10 then return x.to_s\n  when 16 then return x.to_s(2)\n\
    \  when 2 then return x.to_s(8)\n  when 8 then return x.to_s(16)\n  else raise\
    \ ArgumentError, \"invalid base: #{base.to_i}\"\n  end\nend", "\tdigits = x.to_s\n\
    \tif digits == \"0\"\n\t\treturn nil\n\tend\n\tdigits = digits[1..(digits.length\
    \ - 1)]\n\tdigits.reverse\n\tdigits.each_index do |index|\n\t\tif digits == base.to_s\n\
    \t\t\treturn index\n\t\tend\n\tend\n\tnil\nend", "  x = \"#{x}\" #convert to string\n\
    \  x = [x] #convert to array\n  x = x.map { |i| i.to_i(base) } #convert bases\
    \ to int\n  return x.to_s #return string from int\nend\n</code>\nThe above code\
    \ will convert a base-10 number into any base\n<code>\nputs change_base(7, 10)\
    \ #output: 71\nputs change_base(9, 10) #output: 9\nputs change_base(1010, 21)\
    \ #output: 1010\n</code>\n<|/ a tags=ruby,math |>\n<| c |>\nI love this solution,\
    \ very simple and works like a charm. Thank you.\n<|/ c |>\n<| a tags=ruby,math\
    \ dscore=4 |>\nIn Ruby 2.0 you can do this using the Kernel.Integer#to_ibase method.\n\
    <|/ a |>\n<| c |>\nCool.  I'll have to look into that.  Thanks.\n<|/ c |>\n<|\
    \ a tags=ruby,math dscore=4 |>\nOne way is to convert it to a string and reverse\
    \ it:\n<code>\nbase = 10\n[12345,67890,1235].map{|x| x.to_s(base).reverse}\n=>\
    \ [\"456789\", \"1234\", \"0123\"]\n</code>\n<|/ a |>\n<| a |>\nThe way I usually\
    \ do it is to have a lookup hash for mapping numbers from one base to another:\n\
    <code>\nbases = Hash['10' => \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n              '11'\
    \ => \"abcdefghijklmnopqrstuvwxyz\",\n              '12' => \"0123456789\",\n\
    \              '13' => \"9\",\n              '14' => \"8\",\n              '15'\
    \ => \"7\",\n              '16' => \"6\",\n              '17' => \"5\",\n    \
    \          '18' => \"4\",\n              '19' => \"3\",\n              '20' =>\
    \ \"2\",\n              '21' => \"1\",\n              '22' => \"0\",\n       \
    \       '23' => \".\",\n              '24' => \"/\"]\n</code>\nAnd then you can\
    \ do things like\n<code>\nbases[10]\n=> \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nbases[11]\n\
    => \"abcdefghijklmnopqrstuvwxyz\"\nbases[12]\n=> \"0123456789\"\nbases[13]\n=>\
    \ \"9\"\n</code>\n<|/ a dscore=3 tags=ruby,math |>\n<| c |>\nYou could use [String#to_i](http://ruby-doc.org/core-1.9.3/",
  "  s = \"\"\n  digits = []\n  while x\n    if x % base == 0\n      s << x\n    \
    \  digits << x\n    end\n    x /= base\n  end\n  digits.reverse!\n  digits.reverse!\n\
    \  s.reverse!\n  s.reverse!\n  \n  for i in digits\n    s << i\n  end\n  s\nend",
  "  if base == 10\n    return x\n  end", "    digits = x.to_s.reverse.split(//).map(&:to_i).reverse\n\
    \    digits.map { |d| d * base + digits[base] }.reverse.join\nend", "  return\
    \ x.to_s(base)\nend", "  if x.to_s.length < base\n    x = x.to_i + base\n  end\n\
    \  return x.to_s\nend", "  new = []\n  n.times do |j|\n    j = j * base\n    new.push(j\
    \ % 10)\n  end\n  new\nend", "\tbase = base.to_i\n\tdigits = x.to_s.reverse.to_i(base)\n\
    \tdigits = (0...digits).map(&:to_s).join.to_i\n\tdigits.reverse.to_s * (base -\
    \ 1).to_i\nend", "  x_str = x.to_s\n  x_str.gsub!(/\\A(\\-?\\d+)(\\d+)\\z/, \n\
    \    lambda m| m[1..-1] + base_conversions[base][$1] * $2.to_i\n  )\n  x_str.to_i\n\
    end\n</code>\n<|/ a |>\n<| c |>\nYou don't need to use [Regexp#scan](http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-i-scan)\
    \ with a block.\n<|/ c |>\n<| c |>\nGood point, thanks. I wasn't aware of the\
    \ `scan` method. I'll edit the answer.\n<|/ c |>\n<| c |>\n`base` is probably\
    \ not the best variable name for that.\n<|/ c |>\n<| c |>\nTrue. Not sure what\
    \ `base` was supposed to represent.\n<|/ c |>\n<| c |>\nThanks for your response!\
    \ Is there a way I can do this without loops?\n<|/ c |>\n<| a |>\nBased on's answer.\
    \ \n<code>", "  return x.to_s(base)\nend", "    digits = Array.new\n    digits[-1]\
    \ = x\n    while x > 0 do\n        digit = x / base\n        digits.unshift(digit)\n\
    \        x = x - digit*base\n    end\n    digits.reverse!\n    digits.join(\"\"\
    )\nend", "  if x <base then\n    x \n  else\n    x.to_s(base)\n  end\nend", " \
    \ string = \"\"\n  while x > 0\n    digit = x % base\n    string = \"#{digit}#{string}\"\
    \n    x = x / base\n  end\n  string.reverse\nend", "  str = x.to_s(base)\n  return\
    \ str\nend", "  # Base 10 raised to higher power\n  if base.to_i > 10\n    raise(\"\
    base number too high\")\n  # Base 10 raised to lower power\n  elsif base.to_i\
    \ < 10\n    raise(\"base number too low\")\n  # Convert to integer and raise to\
    \ power given by base.\n  else\n    raise(\"base must be between 10 and 36\")\n\
    \  end", "  x.to_s.split(\"\").reverse.each_with_index {|n,i| x = x.to_s.split(\"\
    \").reverse.map {|v| v == n ? base - i : v}.join}.reverse\n  x\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nthanks your solution works for me but the input has\
    \ to be only positive integer. can you help me\n<|/ c |>\n<| c |>\nIt should just\
    \ be `base < 10`, not `base < 0`. It works for positive integers because of the\
    \ `10` in `base < 10`\n<|/ c |>\n<| c |>\nthanks again. now it works fine. but\
    \ i have problem when my input is negative integer. it shows the negative integer\
    \ but it's wrong. how can i fix it ?\n<|/ c |>\n<| a dscore=0 |>\nA solution without\
    \ regular expressions or large integers\n<code>", "  s = \"\"\n  while x > base\n\
    \    s = (\"0\" + (x % base)).to_s + s\n    x = x / base\n  end\n  s = x + s\n\
    \  s\nend", "  x = x.to_i\n  return x.to_s(base)\nend", "  base_to_num = Array.new(base)\n\
    \  base_to_num[0] = \"\"\n  x = x.to_s\n  x.chars.each_with_index { |char, i|\
    \ base_to_num[char.to_i] += \"#{i}\" }\n  return base_to_num[x] unless base_to_num[x].empty?\n\
    \  return \"\"\nend", "    puts \"Base #{base} of #{x} is #{base ** x}\"\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI like using gsub and regular expressions.\
    \  This way you can choose the base you want.  Just be sure you escape your string\
    \ correctly.  It works fine in irb.\n<code>\nbase = 10\ns = \"This is just a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a string.\
    \  It is a string.  It is a string.  It is a string.  It is a string.  It is a\
    \ string.  It is a string.  It is a string.  It is a string.  It is a ", "  x.to_s(base).sub(/(?<=^0{,2})|(?<=^0{,4}$)/,'')\n\
    end", "    digits = Array.new\n    while x >= base\n        digits.push(x%base)\n\
    \        x = x / base\n    end\n    digits.reverse\n    return digits.join('')\n\
    end", "  return x.to_s(base)\nend", "  case base\n  when 2 then return x.to_s.reverse\n\
    \  when 10 then return x.to_s\n  else raise \"unsupported base\"\n  end\nend",
  "  if x < 10\n  x\n  elsif base == 10\n  '%d' % x\n  else\n  '%0*d' % (base, x)\n\
    \  end\nend\nputs change_base(10, 4)\nputs change_base(25, 8)", "  result = ''\n\
    \  power = 1\n  while x > 0\n    digit = x % base\n    x = x / base\n    digit\
    \ = digit.to_i\n    result += (digit.to_s * (power - 1)) + digit.to_s\n    power\
    \ += 1\n  end\n  result\nend", "  # your code goes here\n  return x.to_s(base)\n\
    end\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>", "  if base>10\n    return \"\
    Sorry. This program supports only positive numbers.\"\n  elsif base==10\n    return\
    \ x.to_s\n  elsif base<=0\n    return \"Sorry. This program supports only positive\
    \ numbers.\"\n  end\n  while x>0\n    remainder = x/base\n    digit = x/base%base\n\
    \    x = remainder\n    return digit.to_s + remainder.to_s\n  end\n  return \"\
    Sorry. This program supports only positive numbers.\"\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis works beautifully, except that `x.to_s` doesn't seem to work\
    \ on negative numbers.\n<|/ c |>\n<| c |>\n, `x.to_s` converts `x` to a string\
    \ (as `x.to_s` converts x to a string). What do you mean?\n<|/ c |>\n<| c |>\n\
    I mean that `x.to_s` doesn't work on negative numbers. `x = -100` and `x.to_s`\
    \ is `-` and not `-100`.\n<|/ c |>\n<| c |>\n, `-100` is `-`. The sign is lost.\
    \ `-100`.to_s(16) #=> \"100\"`\n<|/ c |>\n<| c |>\nOh I see. Thank you. I was\
    \ so focused on getting the signs to show up that I was forgetting that the input\
    \ comes through as a string.\n<|/ c |>\n<| a dscore=3 |>\nI wrote this a while\
    \ back\n<code>", "\tif x >= base\n\t\treturn nil\n\tend", "  new_num = x\n  i\
    \ = 0\n  while i < base\n    quotient = new_num.to_i / base\n    digit = new_num.to_i\
    \ % base\n    new_num = quotient * base + digit\n    i += 1\n  end\n  return new_num.to_s\n\
    end", "  digits = []\n  while x != 0\n    x = x / base\n    digits.push(x)\n \
    \ end\n  digits[digits.length-1].to_s(base)\nend", "  if base.to_i >= x.to_i\n\
    \    digits = x.to_i\n    digits = (digits / base).floor * base\n    digits =\
    \ x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i\
    \ + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits\
    \ = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i\
    \ + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits\
    \ = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i\
    \ + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits\
    \ = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i\
    \ + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits\
    \ = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i\
    \ + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits\
    \ = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i\
    \ + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits\
    \ = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i\
    \ + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n    digits\
    \ = x.to_i + digits\n    digits = x.to_i + digits\n    digits = x.to_i + digits\n\
    \    digits = x.to_i + digits\n    digits = x.to_i + ", "  s = ''\n  digits =\
    \ x.to_s.split(//)\n  digits.reverse!\n  digits.each_index do |i|\n    digit =\
    \ digits[i].to_i\n    s += digit.to_s(base)\n  end\n  s # => 10\nend", "  digits\
    \ = x.to_s.split('')\n  digits.map!{|d| d.to_i(base)}\n  digits.join('')\nend",
  "\treturn x.to_s(base)\nend", "    digit_list = x.to_s\n    digits = digit_list.split(\"\
    \")\n    if base == 10\n        return digits.join\n    else\n        digit_list.reverse!\n\
    \        digits = digit_list.split(\"\")\n        if base < 10\n            digits\
    \ = digits[base..-1] + digits.take(base)\n        else\n            digits = digits[base..-1]\
    \ + digits.take(base).reverse\n        end\n    end\nend", "  s = \"\"\n  while\
    \ x > 0 do\n    s, x = s, x % base\n  end\n  return s\nend", "  a = x.to_i\n \
    \ b = a.to_s(base)\nend", "  res = []\n  if x == 0\n    res.push(\"\")\n  elsif\
    \ x > base\n    push(res, x, base)\n  else\n    digits = x.to_s.chars.reverse\n\
    \    while(digits.length > 0)\n      if digits.last < base\n        # push last\
    \ digit\n        push(res, digits.last, base)\n        digits.pop\n      else\n\
    \        # push digits in reverse\n        push(res, digits.reverse.last, base)\n\
    \        digits.pop.reverse\n      end\n    end\n  end\n  res.reverse.join\nend",
  "  # change base from 2 to 10\n  base = 10\n  # change from 2 to 10\n  x = [x] if\
    \ base.to_i != 10 then base.to_i\n  x.collect! { |i| i % base }\n  x.join\nend\n\
    </code>\n<|/ a tags=ruby,base,digits,ruby-on-rails dscore=1 |>\n<| a tags=ruby,base,digits,ruby-on-rails\
    \ |>\nThis is how I solved it. I believe it's more elegant than using eval:\n\
    <code>", "  return \"#{x}\".to_i(base) # string conversion is implicit\nend",
  "  if x % base == 0\n    return x\n  else\n    return change_base(x / base, base)\n\
    \  end\nend", "    digits = []\n    while x > 1\n        digit = x % base\n  \
    \      digits.append(digit)\n        x = x / base\n    end\n    return digits.reverse.join\n\
    end", "\tif base < 0 or base > 10\n\t\treturn nil\n\tend\n\t\n\tres = \"\"\n\t\
    \n\twhile x > 0\n\t\tres = (base % 10) + res\n\t\tx = (x - base) / 10\n\tend\n\
    \t\n\treturn res\nend", "    \n    if x <= 10\n        return x.to_s(base)\n \
    \   else\n        digits = []\n        x.to_s.reverse.each_char.with_index do\
    \ |ch, n|\n            digits[n] = base.to_i(ch.to_s)\n        end\n        \n\
    \        return digits.reverse.join.to_s(base)\n    end\nend", "    # Base conversion\n\
    \    digits = []\n    while x != 0\n        if x % base == 0\n            digits.push(x\
    \ % base)\n            x /= base\n        else\n            digits.push(x % base)\n\
    \            digits.pop()\n            x /= base\n    end\n    return digits.reverse()\n\
    end", "    str = x.to_s\n    str.sub(/./, digits(base).method(:[]))\nend", " \
    \ if x\n    case base\n    when 2\n      puts x\n    when 10\n      puts \"#{x.to_s.reverse}\"\
    \n    else\n      puts \"Invalid base\"\n    end\n  else\n    puts \"Invalid input\"\
    \n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,digits,base,towers-of-hanoi\
    \ |>\n<code>", "    return x.to_s(base) if x.class.base_of == Fixnum\n    base\
    \ = base.to_s(base) if base.class.base_of == Fixnum\n    base = Integer(base)\
    \ if base.class != Integer\n    return x.to_s(base) if x.class.base_of == Integer\n\
    \    return \"Error\"\nend", "  return x.to_s(base)\nend", "  if x == 0\n    return\
    \ 0\n  elsif x < 0 or base < 0\n    return nil\n  elsif x == 0\n    convert_base(\"\
    0\", base)\n  elsif base == 0\n    convert_base(x, base)\n  elsif x < base\n \
    \   convert_base(x, base)\n  else\n    convert_base(x, base)\n  end\nend", " \
    \ if x.is_a?(Integer)\n    x /= base\n  elsif x.is_a?(Float)\n    x /= base\n\
    \  else\n    raise TypeError, \"#{x.class} is not convertible to #{base.class}\"\
    \n  end\n  x\nend", "  ret = String()\n  x = x.to_s(base).reverse\n  i = 0\n \
    \ while i < x.length\n    if x[i].to_s(base).reverse != x\n      ret << x[i]\n\
    \      i += 1\n      break\n    else\n      ret << x[i]\n      i += 1\n    end\n\
    \  end\n  return ret.reverse\nend", "  if base == 10\n    # base of 10 is 0.\n\
    \    if x < 10\n      # if x is less than 10, return x with 0 as the base.\n \
    \     \"0\" + x\n    else\n      # if x is greater than 10, return a string with\
    \ leading 0 as the\n      # base and adding x as the number.\n      \"0\" + x\
    \ + \"\"\n    end\n  else\n    # base greater than 10 is 10.\n    return \"0\"\
    \ + change_base(x, 10) + \"\"\n  end\nend\n</code>\n<|/ a tags=math,ruby |>\n\
    <| a dscore=0 |>\n<code>", "  if x <> 0 then\n    if base > 10 then\n      print('Error:\
    \ Base number should be less than 10.')\n      exit\n    else \n      x = x /\
    \ base\n      base = base * base\n      return change_base(x, base)\n  else\n\
    \    return 1\n  end\nend", "  return x.to_s(base)\nend", "  digits = Array.new\n\
    \  temp = x.to_s\n  while temp.split(//).each { |digit| digits.push base**digit.to_i\
    \ } \n  digits.join\nend\n</code>\n<|/ a |>\n<| a |>\nA Ruby solution:\n<code>",
  "  n = base * x\n  n = [n % base]\n  return x.to_s\nend\n</cell>\n<code language=julia-1.5>",
  "  retVal = \"\"\n  if x != nil && base != nil && x.is_a?(String)\n    base = Integer(base)\n\
    \    x = x.to_i\n    if x.to_s.to_i != 0 && base < 10\n      power = x.to_s.to_i\n\
    \      power = base > power ? power : base\n      power = power - 1\n      while\
    \ power > 0\n        retVal += x.to_s.to_i.to_s(base)\n        x -= 1\n      \
    \  power -= 1\n      end\n    end\n  end\n  return retVal\nend", "  x = x.to_i\n\
    \  base = base.to_i\n  result = []", "    digits = x.to_s.split(//)\n    remainder\
    \ = digits.length\n    digits[0] = digits[0].to_i", "  if x > base\n    \"ERROR\"\
    \n  else\n    digit = x.to_s.chars.each_with_index.find do |d,i|\n      d == base**i\
    \ % base\n    end\n    return digit.to_s\n  end\nend", "  if base <= 0\n    return\
    \ \"Can't change base of negative number\"\n  x = x.to_i\n  while x\n    digit,\
    \ mod = x.divmod(base)\n    digit = digit.to_s\n    x = mod\n    return \"#{digit}#{base}\"\
    \n  end\nend", "  str = x.to_s\n  digits = str.split(//)\n  new_digits = []\n\
    \  for x in digits\n    base = base.to_i\n    if x < base\n      new_digits <<\
    \ x - base\n    else\n      new_digits << x.to_i\n    end\n  end\n  new_str =\
    \ new_digits.reverse.join\n  new_str.length <= 5 ? str + new_str : str\nend",
  "  case base\n  when 2 then return x.to_s\n  when 10 then return x.to_s\n  when\
    \ 16 then return x.to_s\n  when 8 then return x.to_i\n  when 16 then return x.to_i\n\
    \  when 10 then return x.to_i\n  when 2 then return x.to_i\n  else\n    raise\
    \ ArgumentError, \"Wrong argument base #{base}.\"\n  end\nend", "  return \"#{convert_base(x,\
    \ base)}\".to_i\nend\n</code>\nNow all you have to do is get the two strings in\
    \ and pass them into your function:\n<code>\ninput1 = \"10\"\ninput2 = \"2\"",
  "  if base<=2 then\n    return x end\n  ret=\"\"\n  while x>0 do\n    rep=string(x)%base\n\
    \    if rep==0 then\n      ret=x%base\n      break\n    end\n    ret=rep*base+ret\n\
    \    x=x/base\n  end\n  return ret\nend\n</cell>\n<code language=julia-1.5>\n\
    change_base(10,2)\n</cell>\n<code language=julia-1.5>\nfunction my_strpad(s,b)\n\
    \  ret=\"\"\n  while length(s)>b do\n    ret=string(s)+string(repeat(\"0\",b-b-length(s)))\
    \ + ret\n    s=string(s)\n  end\n  return ret\nend\n</cell>\n<code language=julia-1.5>\n\
    my_strpad(\"0123456789\", 6)\n</cell>\n<code language=julia-1.5>", "  case x of\n\
    \    0 | nil then return 0\n    1 | nil then return 1\n    2 | nil then return\
    \ 10\n    3 | nil then return 100\n    4 | nil then return 1000\n    5 | nil then\
    \ return 10000\n    6 | nil then return 100000\n    7 | nil then return 1000000\n\
    \    8 | nil then return 10000000\n    9 | nil then return 100000000\n    else\
    \ return nil\n  end\nend", "  if x <= 10\n    return x.to_s(base)\n  else\n  \
    \  return x.to_s(base).reverse\n  end\nend", "  if base < 10\n    return x.to_s\n\
    \  else\n    digit_base = 10\n    temp = x.to_s\n    digits = temp.chars.to_a\n\
    \    digit_power = base\n    tens = Array.new\n    tens.push(digits[0...-1])\n\
    \    tens = tens.reverse\n    tens.each do |ten|\n      digit_power -= 1\n   \
    \   digit_digit = 0\n      while digit_digit < 10\n        digit_digit += digit_power.to_i\n\
    \        digit_power = digit_power % base\n      end\n      digits[0...-1].push(digit_digit)\n\
    \    end\n    digits.reverse!\n    digits.unshift(temp[0...-1])\n    digits.join\n\
    \  end\nend", "  return x.to_s(base)\nend", "  raise ArgumentError, \"Invalid\
    \ argument for ChangeBase: #{x.inspect}\"\nend", "  # Change base\n  base_map\
    \ = { '2':0, '3':1, '4':2, '5':3, '6':4,\n              '7':5, '8':6, '9':7, '10':8,\
    \ '11':9,\n              '12':10, '13':11, '14':12, '15':13, '16':14,\n      \
    \        '17':15, '18':16, '19':17, '20':18, '21':19,\n              '22':20,\
    \ '23':21, '24':22, '25':23, '26':24,\n              '27':25, '28':26, '29':27,\
    \ '30':28, '31':29,\n              '32':30, '33':31, '34':32, '35':33, '36':34,\n\
    \              '37':35, '38':36, '39':37, '40':38, '41':39,\n              '42':40,\
    \ '43':41, '44':42, '45':43, '46':44,\n              '47':45, '48':46, '49':47,\
    \ '50':48, '51':49,\n              '52':50, '53':51, '54':52, '55':53, '56':54,\n\
    \              '57':55, '58':56, '59':57, '60':58, '61':59,\n              '62':60,\
    \ '63':61, '64':62, '65':63, '66':64,\n              '67':65, '68':66, '69':67,\
    \ '70':68, '71':69,\n              '72':70, '73':71, '74':72, '75':73, '76':74,\n\
    \              '77':75, '78':76, '79':77, '80':78, '81':79,\n              '82':80,\
    \ '83':81, '84':82, '85':83, '86':84,\n              '87':85, '88':86, '89':87,\
    \ '90':88, '91':89,\n              '92':90, '93':91, '94':92, '95':93, '96':94,\n\
    \              '97':95, '98':96, '99':97, '100':98, '101':99,\n              '102':100,\
    \ '103':101, '104':102, '105':103,\n              '106':104, '107':105, '108':106,\
    \ '109':107,\n              '110':108, '111':109, '112':110, '113':111,\n    \
    \          '114':112, '115':113, '116':114, '117':115,\n              '118':116,\
    \ '119':117", "  if x.to_s == \"0\"\n    puts \"Invalid input.\"\n  elsif x.to_s\
    \ < base\n    puts \"Invalid input.\"\n  elsif x.to_s > base\n    puts \"Invalid\
    \ input.\"\n  else\n    temp = x.to_s.split(\"\")\n    temp.each do |char|\n \
    \     temp = char.to_i(base)\n      if temp == -1\n        puts \"Invalid input.\"\
    \n        break\n      end\n      x = x * base + temp\n    end\n    x = x.to_i\n\
    \    puts \"#{x}\"\n  end\nend", "\tx = x.to_s\n\treturn x.reverse.gsub(/(.)(\\\
    d*)/) do\n\tbase = $1\n\tdigit = $2.to_i\n\tx = x.gsub(/\\d/, digit.to_s).gsub(/[\\\
    D]/, \"\")\n\tdigit = digit.to_s(base).reverse\n\t\n\t# If digit is a zero or\
    \ a letter,\n\t# then return x.\n\treturn x.empty? ? x : x.gsub(/(?<=\\d)0|(?<=\\\
    d)[A-Za-z]/, digit)\nend", "  if x < 0 then\n    return nil\n  end\n  local t\
    \ = {}\n  if base==10 then\n    for i=1,32 do\n      t[string.char(i+48)] =  string.char(x%base)\n\
    \      x = x//base\n    end\n    return table.concat(t, \"\")\n  elseif base==2\
    \ then\n    if x % 2 == 0 then\n      t[1] = '1'\n    else\n      t[1] = '0'\n\
    \    end\n    return table.concat(t, \"\")\n  end\nend", "  return x.to_s(base)\
    \ \nend", "  puts x\n  puts base\n  x = x.to_s # change x from a string to a float\n\
    \  x = x.to_i # change x from a float to an integer\n  x = x.to_s # change x from\
    \ a float to a string\n  return x.to_s(base) # change x from a float to an integer\n\
    end", "  if base > 10\n    puts \"  *** Sorry, the base can only be from 0-9 ***\"\
    \n  elsif base < 0\n    puts \"   --- Sorry, the base can only be from 0-9 ---\"\
    \n  else\n    # change all numbers to string.\n    x = \"#{x}\" # Convert x to\
    \ string.\n    # split the string into individual character of the string\n  \
    \  # x is string.\n    chars = x.chars\n    # make an empty string\n    temp =\
    \ \"\"\n    # convert each individual character in x to integer and multiply with\n\
    \    # base.\n    chars.each { |e| temp += e.to_i * base }\n    # rebuild string\
    \ from integer.\n    x = temp\n    # change base of x to base.\n    x = x.to_s.gsub(/\\\
    d/) { |e| e.to_i ** base }\n  end\n  return x\nend", "  if base < 0\n    fail\
    \ \"base cannot be negative\"\n  end\n  base = @base\n  x = x.to_i\n  if base\
    \ == 10\n    return x\n  else\n    digits = []\n    while x\n      digits.push(x)\n\
    \      x = x % base\n    end\n    digits.reverse\n    digits.map {|x| x + base}.reverse\n\
    \  end\nend", "  x_str, i = x.divmod(base)\n  result = x_str.to_i\n  while i >=\
    \ base\n    result *= base\n    result += 1\n    i -= 1\n  end\n  return x.divmod(base)[1].to_s\
    \ + result\nend\n</code>\nAnd finally the main program\n<code>", "  base_digits\
    \ = base_to_digits(base)\n  new_num = []\n  i = 0\n  while i <= base_digits.length\n\
    \    if base_digits[i] == 0 then\n      new_num.push x\n      break\n    end\n\
    \    digit_sum = digit_sum + base_digits[i]\n    i = i + 1\n  end\n  while x >\
    \ digit_sum\n    new_num.push 0\n    x = x - digit_sum\n  end\n  return new_num\n\
    end", "  str = x.to_s(base)\n  if base >= 10\n    str.reverse\n  end\n  str\n\
    end", "\tif base < 10 then\n\t\tbase_string = ''\n\t\twhile base > 0 do\n\t\t\t\
    base_string = base_string .. tostring(base%10)\n\t\t\tbase = base//10\n\t\tend\n\
    \t\treturn base_string .. x\n\tend\n\treturn x\nend", "    digits = []\n    digits_len\
    \ = base.length\n    while (digits.length < x)\n        digits = digits + base\n\
    \    return (digits[0...x]).reverse\nend", "  string = \"\"\n  while x\n    if\
    \ x < base\n      string = base - 1 + string\n      x = x % (base * 10)\n    else\n\
    \      string = string + x.to_s\n      x /= base\n    end\n  end\n  string\nend\n\
    </code>\nThe algorithm is as follows:", "  x.to_s.reverse # reverse number before\
    \ change base to make it readable.\n  x.to_s.reverse!\n  x = x.to_i(base) # change\
    \ base to numeral base\n  x.to_s.reverse!\n  x.to_s # reverse the number again\
    \ to make it readable.\nend", "\tstring = \"\"\n\twhile x != 0\n\t\tstring = string\
    \ + (x % base) + \", \"\n\t\tx = x / base\n\tstring = string[0..-2]\n\tputs \"\
    #{string} = #{x}\"\nend", "    digits = x.to_s.reverse.to_i(2)\n    (digits /\
    \ base) % 10\nend", "\tdigits = \"\"\n\twhile x > 0 do\n\t\tdigits = (digits[x%base]\
    \ + digits[base])\n\t\tx = x / base\n\tend\n\tdigits\nend", "  # Write your code\
    \ here.\n  return 0\nend\n</code>\n<|/ q tags=string,ruby,arrays |>\n<| c |>\n\
    Do you need to convert to an integer before performing the operation?\n<|/ c |>\n\
    <| c |>\nYes that is correct\n<|/ c |>\n<| c |>\nYes, I missed that part. I've\
    \ updated my answer.\n<|/ c |>\n<| c |>\nI added some more explanation.\n<|/ c\
    \ |>\n<| c |>\nI added some more explanation.\n<|/ c |>\n<| a tags=string,ruby,arrays\
    \ |>\nIf your only goal is to take a string and change it's base you can use the\
    \ following.\n<code>", "  str = \"\"\n  while x > 0\n    str = base_str[x%base]\
    \ + str\n    x = floor(x/base)\n  end\n  return str\nend", "  if x < 0\n    puts\
    \ \"Invalid Base\"\n  elsif base < 2 || base > 36\n    puts \"Invalid Base\"\n\
    \  else\n    y = x.to_s\n    z = y.reverse\n    z = z.gsub(/../){|a| a * (base**($&.ord.to_i-1))}\n\
    \    puts z \n  end\nend", "  case base\n  when 2\n    x % 2 != 0\n  when 10\n\
    \    x == 0\n  when 16\n    x == 0 && x % 2 == 0\n  else\n    raise \"invalid\
    \ base\"\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nIn your second function\
    \ you do not call change_base correctly, you should write `base` instead of `base`\
    \ and you should use `x = x.to_i` instead of `x = x.to_s.to_i`.\n<|/ c |>\n<|\
    \ a tags=ruby |>\nI see you have already accepted an answer, but I will just post\
    \ my own implementation of this problem for future viewers.\n<code>", "    # x\
    \ is the string number\n    # base is the new base\n    digits = Array.new()\n\
    \    digits[x] = '\\0'\n    tens, hundreds, tens_length = convert_base(x, base)\n\
    \    digits = digits.join\n    tens_base = get_base(tens, base)\n    hundreds_base\
    \ = get_base(hundreds, base)\n    tens_digits = Array.new(tens_length)\n    hundreds_digits\
    \ = Array.new(hundreds_length)\n    tens_index = 0\n    hundreds_index = 0\n \
    \   while tens_index < tens_length or hundreds_index < hundreds_length\n     \
    \   if tens_index == tens_length\n            tens_digits[tens_index] = tens[tens_index]\n\
    \            tens_index += 1\n        elif hundreds_index == hundreds_length\n\
    \            hundreds_digits[hundreds_index] = hundreds[hundreds_index]\n    \
    \        hundreds_index += 1\n        elsif tens[tens_index] == '0' and digits[tens_index\
    \ + tens_length - 1] == '0'\n            hundreds[hundreds_index] = digits[tens_index\
    \ + tens_length - 1]\n            hundreds_index += 1\n            tens[tens_index]\
    \ = '\\0'\n            tens_index += 1\n        else\n            tens[tens_index]\
    \ = digits[tens_index + tens_length - 1]\n            tens_index += 1\n      \
    \  end\n    end\n    hundreds[hundreds_index] = '\\0'\n    return tens_digits\
    \ + hundreds_digits + tens + hundreds\nend", "  res = \"\"\n  while (x != 0)\n\
    \    res = x.to_s + \".\" + res\n    x = x/base\n  end\n  res\nend\n</cell>\n\
    <code language=julia-0.5>", "  base_str = ''\n  if base == 16\n    base_str =\
    \ '0x'\n  elsif base == 8\n    base_str = '0b0'\n  elsif base == 2\n    base_str\
    \ = '0b00'\n  elsif base == 10\n    base_str = '0b000'\n  end\n  x.to_s(base_str)\n\
    end", "  x.to_s.reverse!\n  x.to_s.gsub!(/[^#{base}]+/,'')\n  while x[-1] >= base\n\
    \    x=x.to_s.reverse!+x.to_s.gsub!(/[^#{base}]+/,'').reverse\n  end\n  x.to_s.reverse!\n\
    end", "  if base==10 then return x end\n  if base==16 then return to_hex(x) end\n\
    \  if base==2 then return to_bin(x) end\nend", "  x.to_s\nend", "    digits =\
    \ Array.new\n    temp = x\n    digits.reverse!\n    while temp != 0\n        digits.unshift(temp\
    \ % base)\n        temp = temp / base\n    end\n    digits.reverse!\n    return\
    \ digits.to_s\nend", "    if base <= 0 or base > 36 or x < 0 \n        then return\
    \ \"Error: Invalid Input\"\n    \n    digits = []\n    # If the number is less\
    \ than 10\n    if x <= 10\n        then digits = [x]\n    # If the number is greater\
    \ than 10 and contains only one digit\n    if x > 10 and x <= 99\n        then\
    \ digits = [x, \"\"]\n    # If the number is greater than 10 and contains more\
    \ than one digit\n    if x > 10 and x % base > 0 \n        then digits = digits_to_list(digits_to_str(x),\
    \ base)\n    \n    # Add back the leading zero if necessary\n    if digits ==\
    \ [1]\n        then digits = [1]\n    \n    return to_str(digits)\nend", "  #\
    \ base10 number => base2 string => base10 string\n  base_chars = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  base2 = '0123456789abcdefghijklmnopqrstuvwxyz'\n  base10 = '0123456789'", " \
    \ case base\n    when 10, 16 then return to_s(x)\n    when 8 then return to_s(x).to_i(base)\n\
    \    else raise 'Invalid base for change method'\n  end\nend", "  digits = Array.new\n\
    \  x.to_s.split(\"\").each do |i|\n    digits.push(Integer(i) * base**Array.new(base.to_s.length).inject(:+))\n\
    \  end\n  digits.join.to_s\nend", "  strval = x.to_s\n  raise \"Invalid base.\"\
    \ if strval.length > base.length\n  nbase = strval.to_i\n  raise \"Invalid base.\
    \ Must be less than 10.\" if nbase > base.length\n  nval = x.to_i\n  nval2 = nval\
    \ % base\n  nval = nval / base\n  nval2 = nval2.to_i\n  strval = \"\"\n  nbase\
    \ = nbase\n  while nval2 > 0\n    strval = base[nbase] + strval\n    nval2 = nval2\
    \ % base\n    nval = nval / base\n    nbase = (nbase + 1).to_i\n  end\n  strval\n\
    end\n</code>\n<|/ a dscore=0 tags=base,ruby,ruby-on-rails |>\n<| a tags=base,ruby,ruby-on-rails\
    \ |>\nHere is my solution:\n<code>", "  if x <10\n    return x.to_s\n  end\n \
    \ result = x.to_s.reverse.split(//).reverse.join.to_i\n  result = num2base(result,\
    \ base)\n  result *= base\n  result = num2base(result+1, base)\n  return result\n\
    end", "  if base == 10\n    return x\n  elsif base < 10\n    raise ArgumentError\
    \ if base > x # base is too large\n    temp = ''\n  elsif base > x\n    raise\
    \ ArgumentError if base < x # base is too large\n    temp = x\n  else\n    temp\
    \ = x.to_s.split(//)\n    temp[0] = temp[0].to_i * base\n    temp[-1] = temp[-1].to_i\
    \ / base\n    temp.reverse\n    temp.reverse!\n  end\n  return temp.join\nend",
  "    string = \"\"\n    if x.is_a?(Integer)\n        if base < 2\n            string\
    \ = x.to_s(base)\n        else\n            string = x.to_s(base).to_i\n     \
    \   end\n    else\n        string.concat x\n    end\n    return string\nend",
  "  result = ''\n  while x > 0\n    digit = x % base\n    digit = digit == 0 ? 10\
    \ : digit\n    result << digit\n    x /= base\n  end\n  return result\nend", " \
    \ bases = {\n    2 => \"0b10\",\n    8 => \"0b11\",\n    10 => \"0b1010\",\n \
    \   16 => \"0b1011\",\n    20 => \"0b10100\",\n    25 => \"0b10101\",\n    30\
    \ => \"0b101010\",\n    40 => \"0b101011\",\n    50 => \"0b101101\",\n    60 =>\
    \ \"0b101100\",\n    70 => \"0b1011010\",\n    80 => \"0b1011011\",\n    90 =>\
    \ \"0b1011101\",\n    100 => \"0b1010011\",\n    127 => \"0b10110100\"\n  }\n\
    \  return bases[base][x] if bases[base]\n  return \"#{x} is not a valid base!\"\
    \nend", "  if base < 2\n    raise ArgumentError, \"invalid base #{base.inspect}\"\
    \n  end", "  # Convert the base\n  if base.to_i < 10 \n    base = base.to_i\n\
    \  end", "  if x < 0 then return \"error base\"\n  if base < 10 then return \"\
    error base\"\n  if base == 0 then return \"zero base\"\n  if x > 10 then return\
    \ \"error base\"\n  if x == \"zero\" then return \"zero\"\n  if x == \"one\" then\
    \ return \"one\"\n  if x == \"two\" then return \"two\"\n  if x == \"three\" then\
    \ return \"three\"\n  if x == \"four\" then return \"four\"\n  if x == \"five\"\
    \ then return \"five\"\n  if x == \"six\" then return \"six\"\n  if x == \"seven\"\
    \ then return \"seven\"\n  if x == \"eight\" then return \"eight\"\n  if x ==\
    \ \"nine\" then return \"nine\"\n  if x == \"ten\" then return \"ten\"\n  if x\
    \ == \"eleven\" then return \"eleven\"\n  if x == \"twelve\" then return \"twelve\"\
    \n  if x == \"thirteen\" then return \"thirteen\"\n  if x == \"fourteen\" then\
    \ return \"fourteen\"\n  if x == \"fifteen\" then return \"fifteen\"\n  if x ==\
    \ \"sixteen\" then return \"sixteen\"\n  if x == \"seventeen\" then return \"\
    seventeen\"\n  if x == \"eighteen\" then return \"eighteen\"\n  if x == \"nineteen\"\
    \ then return \"nineteen\"\n  if x == \"twenty\" then return \"twenty\"\n  if\
    \ x == \"twenty one\" then return \"twenty one\"\n  if x == \"twenty two\" then\
    \ return \"twenty two\"\n  if x == \"twenty three\" then return \"twenty three\"\
    \n  if x == \"twenty four\" then return \"twenty four\"\n  if x == \"twenty five\"\
    \ then return \"twenty five\"\n  if x == \"twenty six\" then return \"twenty six\"\
    \n  if x == \"twenty seven\" then return \"twenty seven\"\n  if x == \"twenty\
    \ eight\" then return \"twenty eight\"\n  if x == \"twenty nine\" then return\
    \ \"twenty nine\"\n  if x == \"thirty\" then return \"thirty\"\n  if x == \"thirty\
    \ one\" then return \"thirty one\"\n  if x == \"thirty two\" then return \"thirty\
    \ two", "  bases = ['1','2','3','4','5','6','7','8','9','10']\n  if x < base\n\
    \    base = '10'\n  idx = bases.index(base)\n  num = (x - base) * pow(base,idx)\n\
    \  return num.to_s\nend", "  s = \"\"\n  while x > 0 do\n    digit = x % base\n\
    \    x = x div base\n    s = s.to_s + digit.to_s + s.to_s\n  end\n  s\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nIt would be helpful if you could explain why this\
    \ is correct and how it works.\n<|/ c |>\n<| c |>\nThis doesn't work for the input\
    \ `5`. This only works if you convert `5` to `9`. For `5` you get `5` instead\
    \ of `101`. The method works by keeping track of how many `9` you have multiplied\
    \ by 10 and adding `digit` on that count.\n<|/ c |>\n<| c |>\nYou're right, I\
    \ forgot about that case in question. Thank you for pointing out.\n<|/ c |>\n\
    <| a |>\nA solution using modulo division. \n<code>", "  if x > 10\n    raise\
    \ ArgumentError, 'invalid base for number > 10'\n  digits = []\n  while x > 0\n\
    \    digit = x % base\n    digit = digit.to_i < base ? digit.to_i + base : digit.to_i\n\
    \    x /= base\n    digits << digit\n  end\n  digits.reverse\n  digits.join('')\n\
    end", "  return x.to_s.gsub(base) { |s| s.to_i(base) }\nend", "  if base < 2 ||\
    \ base > 36\n    raise ArgumentError, \"invalid base: #{base}\"\n  end\n  string\
    \ = \"\"\n  if x > 0\n    string = dec(string * base, (x / base).floor)\n    string\
    \ = (x % base) + 1\n  end\n  string\nend", "  if x == 0\n    '0'\n  elsif x ==\
    \ -1\n    '-1'\n  else\n    x_str = x.to_s\n    digits_base = x_str.split(//)\n\
    \    digits_base.map!{|d| d.to_i(base) if d.to_i(base).is_a? Fixnum}\n    digits_base.map!{|d|\
    \ d.to_s(base) if d.to_s(base).is_a? Fixnum}\n    digits_base.join\n  end\nend\n\
    </code>\n<|/ a tags=ruby,binary,base |>\n<| a |>\nA one liner:\n<code>\n\"10\"\
    .to_s(2).gsub(/\\d\\s/, '0')\n</code>\n<|/ a tags=ruby,binary,base dscore=2 |>\n\
    <| a tags=ruby,binary,base |>\nOne liner:\n<code>", "  # x is number\n  # base\
    \ is integer\n  # returns string\n  # change base to convert a number to its string\
    \ representation\n  # base numbers are less than 10.\n  # Examples\n  # change_base(123,\
    \ 10)\n  # return 123\n  # change_base(123, 8)\n  # return '13'\n  # change_base(123,\
    \ 1)\n  # return '1'\n  if x < 0 \n    return '-' + change_base(-x, base) \n \
    \ digits = []\n  while x\n    digit = x % base\n    x /= base\n    digits.push(digit)\n\
    \  digits.reverse\n  return digits.join('')\nend\n</code>\n<|/ a tags=numbers,ruby\
    \ |>\n<| c |>\nThis solution is very clever, but it only works for non-negative\
    \ numbers, and only if the base is 10.  (And not if the base is anything other\
    \ than 10.)\n<|/ c |>\n<| c |>\nYes, I forgot about negative numbers, my bad.\
    \ I'll make another update with my modified solution.\n<|/ c |>\n<| c |>\nThanks\
    \ man, I appreciate the help. I'm going to try this solution and hopefully it\
    \ works for me.\n<|/ c |>\n<| a tags=numbers,ruby dscore=2 |>\nThis is my first\
    \ time answering a question, so bear with me please...\n<code>", "  if x < base\n\
    \    return \"Error: number too small.\"\n  elsif x > base\n    return \"Error:\
    \ number too large.\"\n  else\n    str = x.to_s.reverse\n    idx = str.index(base)\n\
    \    str[idx] = x % base\n    return str.reverse\n  end\nend", "  if x.to_s ==\
    \ \"\"\n    \"Error: Enter a number greater than 0\"\n  elsif base.to_s == \"\"\
    \n    \"Error: Enter a base number greater than 0\"\n  else\n    digits = x.to_s.split(\"\
    \")\n    digits.map! {|digit| digit.to_i}\n    digits.map! {|digit| digit * base.to_i}\n\
    \    digits.reverse!\n    return digits.join(\"\")\n  end\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=0 |>\n<| a tags=ruby |>\nRuby has BigDecimal objects that provide\
    \ arithmetic to arbitrary precision.\n<code>\nrequire 'bigdecimal'", "    if base\
    \ < 10:\n        return \"Error: Base must be less than 10.\"\n    else:\n   \
    \     digits = []\n        while x > 0:\n            digits.append(x % base)\n\
    \            x /= base\n        return \"\".join(map(str, digits))\n    ", " \
    \ base_digits = (\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\")\n\
    \  digits = Array.new\n  digits_str = Array.new\n  digits_str.push \"\"\n  digits.push(x)\n\
    \  digits.reverse!", "    temp = str(x)\n    return base ** int(rindex(temp, \"\
    .\"))\nend", "  digits = [x,0,0,0,0,0,0,0,0,0,0]\n  i = 0\n  while i < base.length\n\
    \    digits[i] = digits[i - base.length] * base[base.length + i]\n    i += 1\n\
    \  end\n  return digits_to_string(digits)\nend", "  digits = Array.new\n  i =\
    \ 0\n  while x\n    digits[i] = x % base\n    x = x / base\n    i += 1\n  end\n\
    \  digits.reverse\n  digits.each do |d|\n    puts d\n  end\nend", "  str = x.to_s\n\
    \  str.reverse!\n  str.split(\"\").each do |i|\n    i = i.to_i\n    num = i*base\n\
    \    str = str.insert(str.length-1, num)\n  end\n  str.reverse!\n  return str\n\
    end", "  digits = []\n  i = 0\n  while x > 0\n    digits[i] = x % base\n    x\
    \ = x / base\n    i += 1\n  end", "  if base < 2 or base > 36:\n    raise ValueError\n\
    \  result = ''\n  n = x\n  while n != 0:\n    result, n = to_digits(result, base),\
    \ n // base\n  result = to_string(result)\n  return result", "  if x.is_a? Integer\n\
    \    if base <= 10\n      return x.to_s\n    else\n      string_number = ''\n\
    \      while x > 0\n\tstring_number = string_number.insert(1, x.modulo(base).to_s)\n\
    \tx = x.divide(base)\n      end\n      return string_number\n    end\n  else\n\
    \    string_number = ''\n    while x > 0\n      string_number = string_number.insert(1,\
    \ x.to_s)\n      x = x.to_i\n    end\n    return string_number\n  end\nend\n</code>\n\
    end\nAnd it works, although it won't work on a number with a leading 0, so I'll\
    \ just add leading zero's until I get one that works. Thanks for all the help.\n\
    <|/ a dscore=0 |>\n<| c |>\n`10 < base < 16` should be `10 < base < 16.0`.\n<|/\
    \ c |>\n<| c |>\n`0..9` are the digits 0-9, not `0123456789`.\n<|/ c |>\n<| a\
    \ dscore=0 |>\nHere is my solution. Hope it helps.\n<code>", "  x.to_s(base)\n\
    end", "  if x==0\n    return \"\"\n  x = x.to_s # Convert to string for easier\
    \ handling.\n  raise ArgumentError, \"'base' must be a number\" unless base.is_a?(Integer)\n\
    \  if base < 2\n    raise ArgumentError, \"'base' must be < 10\"\n  else # base\
    \ >= 2\n    digits = []\n    while (x.to_s.length < base) do\n      digits.push(x.to_s.rjust(base))\n\
    \    end\n  end\n  return digits.reverse.join\nend", "    # x is an integer\n\
    \    # base is an integer\n    # x should be less than or equal to base\n    #\
    \ return the string representation in base 10\n    \n    # Your code here\n  \
    \  \n    return x\n    \nprint(change_base(123, 10))", "  if x < 10\n    base\n\
    \  else\n    change_base((x/base) % 10, base)\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a tags=ruby dscore=0 |>\nThis implementation avoids using any\
    \ loops:\n<code>", "  if x.is_a?(Integer)\n    return x.to_s\n  else\n    to_s\
    \ = x.to_s\n    base = base.to_i\n    digits = to_s.length - base.length\n   \
    \ base = 10**base", "  x = x.to_s\n  if x.length <= base\n    return x\n  digits\
    \ = x.to_s.split(//)\n  new_digits = []\n  base_two = base ** 0\n  base_ten =\
    \ base ** 1\n  for i in digits do\n    if i.to_i < base\n      new_digits << i.to_i\n\
    \    else\n      remainder = i.to_i % base\n      new_digits << remainder.to_i\n\
    \    end\n  end\n  digit_sum = new_digits.inject(:+)\n  new_x = digit_sum % base\n\
    \  new_digits << new_x\n  digits.reverse!\n  digits.reverse!\n  new_digits <<\
    \ digit_sum\n  new_digits.reverse!\n  digits.reverse!\n  new_digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  new_digits << new_x\n\
    \  digits.reverse!\n  new_digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  new_digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  new_digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  new_digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  new_digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  new_digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  new_digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  new_digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  new_digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  new_digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  new_digits.reverse!\n  ", "  puts \"Your number in base\
    \ #{base} is: #{ x.to_s(base) }\"\nend", "  digits = Array.new\n  while x > 0\n\
    \    digits.push(x % base)\n    x = x / base\n  end\n  digits.reverse\n  digits.join('')\n\
    end", "  return x.to_s(base) if x.is_a? Integer\n  result = ''\n  x.times do\n\
    \    digit = x.to_s(base).to_i\n    result = result + (digit % base).to_s + digit\n\
    \  end\n  result\nend", "  x = x.to_s.reverse # reverse string\n  x.reverse!\n\
    \  result = \"\"\n  x.each_char do |c|\n    digit = c.to_i(base)\n    result =\
    \ result + (digit == 10 ? c.to_s : c.to_s(base))\n  end\n  result.reverse!\nend",
  "    if base > 10 \n        return \"Number too large\"\n    \n    # if the number\
    \ has no remainder when divided by base, \n    # then x is divisible by base.\
    \ \n    if x % base == 0\n        return x.to_s\n    end\n    \n    # if the number\
    \ has no remainder when divided by base,\n    # then x is not divisible by base.\
    \ \n    else \n        # change base to base times \n        # find the remainder\
    \ when x divided by base\n        # divide x by base\n        # repeat the above\
    \ process until x is zero\n        # return the number with its base changed.\n\
    \        base = base.to_s\n        y = x.to_s\n        result = \"\"\n       \
    \ for i in 0...(y.length - 1)\n            result = result + y[i] * base\n   \
    \     end\n        \n        # return the changed number as string.\n        return\
    \ result\n    end\nend\n</cell>\n<cell>\nputs change_base(124, 2)\n</cell>\n<cell>\n\
    puts change_base(124, 9)\n</cell>\n<cell>\nputs change_base(124, 2)\n</cell>\n\
    <cell>\nputs change_base(124, 9)\n</cell>\n<cell>\nputs change_base(124, 2)\n\
    </cell>\n<cell>\nputs change_base(124, 9)\n</cell>\n<cell>\nputs change_base(124,\
    \ 2)\n</cell>\n<cell>\nputs change_base(124, 9)\n</cell>\n<text>\n2.8 Write a\
    \ method to determine if a year is leap or not. Year is considered to be a leap\
    \ year if:", "  x.to_s(base).reverse\nend\n</code>\nThen to convert a number from\
    \ one base to another:\n<code>", "  return x.to_s(base) if x.is_a?(Fixnum)\n \
    \ digits = x.to_s(base).split(//).reverse\n  num_base = \"#{digits[base]}\".to_i\n\
    \  num_base == 10 ? \"0\" : num_base.to_s(base)\nend", "    digits = []\n    while\
    \ x > 0\n        digits = digits[-1..-1] + [x % base]\n        x /= base\n   \
    \ return digits.reverse\nend", "  base_digits = (0...base).to_a\n  digits = x.to_s.chars.map(&:to_i)\n\
    \  digits.map { |digit| base_digits[digit] }.reverse.join\nend", "  x = x.to_i\n\
    \  if x < base\n    x += base\n    puts \"x should be bigger than #{base}\"\n\
    \  else\n    while x > base\n      x /= base\n    end\n  end\n  puts \"#{x}\"\n\
    \  puts \"#{x.to_s}.to_i(#{base})\"\n  puts \"#{x.to_i(base).to_s}.to_s(#{base})\"\
    \n  puts \"#{x.to_s(base).to_i}\"\n  puts \nend", "  if base < 2 then\n    return\
    \ nil\n  end", "  \n  # TODO: Change code below to convert base to decimal from\
    \ binary. \n  \n  x.to_s(base)\n  \n  # TODO: Change code above to convert base\
    \ to decimal from binary.\n  # x = x.to_s(base) \n  \n  \n  # Return the string\
    \ after the change base operation\nend", "  base_array = ['0', '1', '2', '3',\
    \ '4', '5', '6', '7', '8', '9']\n  x_array = ['0', '1', '2', '3', '4', '5', '6',\
    \ '7', '8', '9', ]\n  new_base = 10\n  \n  while new_base >= base\n    new_base\
    \ = new_base/base\n  end\n  \n  if new_base < base\n    new_base = base\n  end\n\
    \  \n  while new_base != 1\n    x_array[0...new_base-1] = base_array[base..new_base-1]\n\
    \    x_array[new_base] = new_base\n    x = x_array.to_a.reverse.join\n  end\n\
    \  \n  return x\nend", "  if base.to_i == 16\n    return \"0x#{x.to_s(16)}\"\n\
    \  else\n    return x.to_s(base)\n  end\nend", "  x.to_s(base)\nend", "  return\
    \ x.to_s(base).reverse.tr(\"0\", \"\")\nend\n</code>\nSo now, all we need to do\
    \ is implement the methods to make use of our new functions.\n<code>", "  # Base\
    \ number in question\n  b = base\n  # Initialize new string\n  s = \"\"\n  # Loop\
    \ to add digits to the string\n  while (b > 0) and (x > 0) and (b > 0)\n    #\
    \ Get the last digit of the number\n    c = x % b\n    # Get the last digit\n\
    \    x = x // b\n    # Add it to the string\n    s = c * s + chr(b) + s\n    #\
    \ Get the next digit\n    b = b // base\n  end\n  # Return the converted string\n\
    \  return s\nend\n</code>\n<|/ a |>\n<| c |>\n`base` should be an integer, not\
    \ a string.\n<|/ c |>\n<| a tags=ruby,bigint,binary |>\nA few things to improve\
    \ on:\n1) You don't have to loop to find the number you're looking for. You can\
    \ use modulo and division operators. For example:\n<code>", "  if x.to_s.length\
    \ > base # check base of number\n    raise ArgumentError, \"Invalid base: #{base}\
    \ is not smaller than 10.\"\n  elsif x.to_s < 0 # check number is negative\n \
    \   raise ArgumentError, \"Invalid base: #{base} is not smaller than 10.\"\n \
    \ end\n  string = \"\"\n  x.to_s.split(//).each do |i|\n    if base < 0\n    \
    \  string += i.to_s[-base]\n    else # base > 10\n      string += i.to_s[base..base]\n\
    \    end\n  end\n  string\nend", "  if x > 10\n    puts \"The base cannot be greater\
    \ than 10.\"\n  elsif base < 2\n    puts \"The base cannot be less than 2.\"\n\
    \  else\n    return x.to_s(base)\n  end\nend", "  return x.to_s(base) # Convert\
    \ to string and back to number\nend\n</code>\nI hope this will help you understand\
    \ the concept.\n<|/ a dscore=1 |>\n<| c |>\nI agree this would be the easiest\
    \ way to approach this problem, but I think it makes for an unnecessarily complicated\
    \ solution.  I feel like there is a better way to do this without having to redefine\
    \ the number class, unless I am missing something.\n<|/ c |>\n<| a |>\nThe biggest\
    \ problem with your code is that you're trying to redefine the number class. \
    \ This is not possible in Ruby.  You're not allowed to modify the class of an\
    \ object in Ruby; it breaks encapsulation.  The error you're getting is due to\
    \ the fact that you're attempting to define a class method on the Fixnum class,\
    \ but your definition is using the method from the Integer class.  \nI suggest\
    \ that you use an accessor on your object to make it \"look\" like the number\
    \ is in base 10.  \n<code>", "  case base\n    when 1 then \"#{x}\"\n    when\
    \ 2 then \"0#{x}\"\n    when 10 then x.to_s\n    else x.to_s+\"0\"\n  end\nend",
  "  case x\n  when 0\n    \"0\"\n  when 1\n    \"1\"\n  when 2\n    \"10\"\n  when\
    \ 3\n    \"11\"\n  when 4\n    \"100\"\n  when 5\n    \"101\"\n  when 6\n    \"\
    110\"\n  when 7\n    \"111\"\n  when 8\n    \"1000\"\n  when 9\n    \"1001\"\n\
    \  when 10\n    \"1010\"\n  when 11\n    \"1011\"\n  when 12\n    \"11000\"\n\
    \  when 13\n    \"10011\"\n  when 14\n    \"10100\"\n  when 15\n    \"10101\"\n\
    \  when 16\n    \"11000\"\n  when 17\n    \"11010\"\n  when 18\n    \"11111\"\n\
    \  when base\n    \"0\"\n  when 1..base\n    x.to_s.reverse.split(//).map do |digit|\n\
    \      digit.to_s.reverse.split(//).map { |b| b * base }\n    end.join\n  else\n\
    \    x.to_s.reverse.split(//).map do |digit|\n      digit.to_s.reverse.split(//).map\
    \ { |b| base**b }\n    end.join\n  end\nend", "  digits = x.to_s.split(//).map{|d|\
    \ d.to_i}\n  power = digits.zip(digits[1..-1]).map { |a,b| a*b }\n  base = base.to_i\n\
    \  digits.reverse!\n  digits.zip(digits[1..-1]).map { |a,b| base*a + b }.join.to_s\n\
    end", "  x.to_s.reverse.each.with_index do |v, i|\n    if v == base\n      x =\
    \ x % base\n    else\n      break\n    end\n  end\n  return x\nend", "\tif base==0\n\
    \t\traise \"base must be non-zero\"\n\telse\n\t\tres = change_base(x, base-1)\n\
    \t\twhile res and res[-1]==\".\"\n\t\t\tres = change_base(res[:-1],base-1)\n\t\
    \twhile res\n\t\t\tres = res[:-1]+\".\"+change_base(x, base-1)\n\t\tres\n\tend\n\
    end", "  if base == 10\n  then return x\n  end\n  if base < 10\n  then return\
    \ 0\n  end\n  if x == 0\n  then return x\n  end\n  base = convert_base(x, base)\n\
    \  result = x\n  while base > 0\n  do\n    result = result * base\n    base =\
    \ convert_base(result/x, base)\n  end\n  return result\nend\n</cell>\n<code language=julia-1.5>\n\
    change_base(10, 2)\n</cell>\n<code language=julia-1.5>\nchange_base(2, 10)\n</cell>\n\
    <code language=julia-1.5>\nconvert_base(1, 10)\n</cell>\n<code language=julia-1.5>\n\
    convert_base(2, 10)\n</cell>\n<code language=julia-1.5>\nconvert_base(-7, 10)\n\
    </cell>\n<code language=julia-1.5>\nconvert_base(-16, 10)\n</cell>\n<code language=julia-1.5>\n\
    convert_base(-12, 10)\n</cell>\n<code language=julia-1.5>\nconvert_base(-10, 10)\n\
    </cell>\n<code language=julia-1.5>\nconvert_base(0, 10)\n</cell>\n<code language=julia-1.5>\n\
    convert_base(7, 10)\n</cell>\n<code language=julia-1.5>\nconvert_base(16, 10)\n\
    </cell>\n<code language=julia-1.5>\nconvert_base(12, 10)\n</cell>\n<code language=julia-1.5>\n\
    convert_base(10, 10)\n</cell>\n<code language=julia-1.5>", "  return x.to_s(base)\n\
    end", "  if x != nil then\n    if base < 2 then\n      raise \"Invalid base\"\n\
    \    end\n    if base == 2 then\n      if x ~= nil and x ~= \"\" then\n      \
    \  return x.to_s.reverse\n      else\n        return \"0\"\n      end\n    end\n\
    \    if base == 10 then\n      if x ~= nil and x ~= \"\" then\n        return\
    \ x.to_s.reverse\n      else\n        return \"0\"\n      end\n    end\n    if\
    \ base == 16 then\n      if x ~= nil and x ~= \"\" then\n        return x.to_s.reverse\n\
    \      else\n        return \"0\"\n      end\n    end\n    if base == 8 then\n\
    \      if x ~= nil and x ~= \"\" then\n        if x < 10 then\n          return\
    \ x.to_s\n        else\n          return x.to_s.reverse\n        end\n      else\n\
    \        return \"0\"\n      end\n    end\n  end\nend", "  digits = x.to_s.split(\"\
    \")\n  result = \"\"\n  digits.each { |digit| digit = digit.to_i(base).to_s(base)\
    \ }\n  digits.reverse.each_with_index do |digit, i|\n    digits[i] = digit\n \
    \ end\n  digits.reverse.join \"\"\nend", "  base = base.to_i\n  return \"#{x.to_s.reverse}\"\
    .chars.map{|digit| digit.to_i}.reverse.map{|digit|\n    ((digit.to_i * base) %\
    \ 10) + 1\n  }.reverse.join.to_s\nend", "  x.to_s(base).rjust((Math.log(x.to_s(base)).to_i).ceil,\
    \ base)\nend", "    \n    \n    temp = \"\"\n    \n    # loop to convert the string\n\
    \    for i in x\n        if i.to_i != 0\n            temp += i.to_i\n        end\n\
    \    end\n    \n    # base conversion\n    num = Integer(temp)\n    \n    # loop\
    \ to find base from base number\n    while temp != 0\n        temp = num % base\n\
    \        num = num / base\n    end\n    \n    \n    temp = num.to_s\n    \n  \
    \  # change base to string representation\n    while temp != 0\n        temp =\
    \ temp * base\n    end\n    \nend\n    \n    \n    ", "    digits = []\n    while\
    \ (x /= base)\n        digits.push(x % base)\n    return digits.reverse.join.to_s\n\
    end", "    x = x.to_s\n    i = 0\n    \n    # Loop while x has more digits than\
    \ base.\n    while x.length <= base\n        # Loop while x has more digits than\
    \ base.\n        while x.length <= base\n            x = x.to_s\n        \n  \
    \      # Convert x to string representation.\n        x = x.to_s(base)\n     \
    \   \n        # Change base.\n        i = 0\n        \n        # Loop while x\
    \ has more digits than base.\n        while x.length <= base\n            # Convert\
    \ x to integer representation.\n            x = x.to_i\n            # Divide x\
    \ by base while x is not equal to 1.\n            x /= base\n            # Add\
    \ digits in x.\n            i += 1\n        end\n        \n        # Return x.\n\
    \        x = x.to_s\n    end\n    \n    # Return x.\n    x\nend", "\tstr = \"\"\
    \n\twhile x > 0 do\n\t\tstr = base * x % base + str\n\t\tx = x / base\n\tend\n\
    \treturn str\nend", "  new_string = \"\"\n  while x > 1\n    if x mod base ==\
    \ 0\n      x /= base\n      new_string += x.to_s\n      new_string += \"\\n\"\n\
    \    else\n      x /= base\n    end\n  end\n  return new_string\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
