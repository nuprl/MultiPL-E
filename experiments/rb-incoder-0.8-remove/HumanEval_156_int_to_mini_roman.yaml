name: HumanEval_156_int_to_mini_roman
language: rb
prompt: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\ndef\
  \ int_to_mini_roman(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
  \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
  \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
  \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
  \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
  \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
  \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
  \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
  \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
completions: ["    roman = Array.new\n    if number < 0 || number > 999\n        puts\
    \ \"Invalid number: #{number}\"\n        return nil\n    end", "  int_to_roman(number,\
    \ \"\")\nend", "  roman_numeral = ''\n  i = 0\n  while i < number\n    roman_numeral\
    \ += get_roman_numeral(i)\n    i += 1\n  end\n  roman_numeral.downcase!\nend",
  "  if number == 0 then return \"0\"\n  roman_array = []\n  current_string = \"\"\
    \n  for i in 1..number do\n    current_string = \"#\" + current_string\n    roman_array\
    \ << current_string\n  end\n  roman_array.map do |x|\n    roman_to_int = x[1..-1].to_i\n\
    \    roman_int = (roman_to_int * 1000) + roman_int\n    roman_int = roman_int.to_s\n\
    \    roman_int = \"m#{roman_int}\"\n    x.slice!(0...1)\n    x.prepend(roman_int)\n\
    \    x\n  end\nend\nputs int_to_mini_roman(123)", "  # Write your code here.\n\
    \  result = ''\n  roman_value = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D':\
    \ 500, 'M': 1000}\n  roman_num_list = (1..number).map { |num| roman_value[roman_map[num.to_s.upcase]]\
    \ }\n  roman_num_list.uniq.sort_by { |x| x.to_i }.each do |x|\n    roman_num_list.delete(roman_num_list.index(x))\n\
    \  end\n  roman_num_list.each do |x|\n    result << (roman_map[x.to_s.upcase].to_s).upcase\n\
    \  end\n  result.downcase\nend", "    roman = Array.new(1000, '')\n    (number-1).times\
    \ do |i|\n        roman[i] = 'M'\n        (number-i+1).times do |j|\n        \
    \    roman[i+j] = roman[i] + ('C', 'D', 'M')[j]\n        end\n    end\n    roman.to_s.downcase\n\
    end", "  roman_num = nil\n  while number > 0\n    roman_num = roman_num.to_s +\
    \ [roman_num, int_to_roman(number % 1000)].last.upcase\n    number /= 1000\n \
    \ end\n  roman_num\nend", "  roman_number = ''\n  \n  # Iterate over integers\
    \ less than or equal to 1000\n  for i in 1..number\n    # Convert integer to roman\n\
    \    roman_number << int_to_roman(number)\n    # Divide by 10\n    number /= 10\n\
    \  end\n  \n  # Lower case roman numbers\n  roman_number.upcase!\n  \n  # Return\
    \ roman_number\n  roman_number\nend\n  ", "  # Write your code here.\n  if number\
    \ < 2\n    puts num.to_s\n  elsif number > 3\n    puts \"Error\"\n  elsif number\
    \ == 2\n    puts \"II\"\n  elsif number == 3\n    puts \"III\"\n  elsif number\
    \ == 4\n    puts \"IV\"\n  elsif number == 9\n    puts \"IX\"\n  elsif number\
    \ == 10\n    puts \"X\"\n  elsif number == 20\n    puts \"XX\"\n  elsif number\
    \ == 30\n    puts \"XXX\"\n  elsif number == 40\n    puts \"XL\"\n  elsif number\
    \ == 50\n    puts \"L\"\n  elsif number == 60\n    puts \"LX\"\n  elsif number\
    \ == 70\n    puts \"LXX\"\n  elsif number == 80\n    puts \"LXXX\"\n  elsif number\
    \ == 90\n    puts \"XC\"\n  elsif number == 100\n    puts \"C\"\n  elsif number\
    \ == 500\n    puts \"M\"\n  else\n    temp = 0\n    while number > 0\n      temp\
    \ << (number % 10)\n      number = number / 10\n    end\n    temp.to_s\n  end\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\nHere's a simple solution:\n\
    <code>", "  roman = \"I\"\n  while number > 1000\n    number -= 1000\n    roman\
    \ += \"M\"\n  while number >= 1000\n    number -= 1000\n    roman += \"CM\"\n\
    \  while number >= 100\n    number -= 100\n    roman += \"CD\"\n  while number\
    \ >= 10\n    number -= 10\n    roman += \"C\"\n  while number > 0\n    number\
    \ -= 10\n    roman += \"XC\"\n  return roman\nend", "  roms = %w(I IV V IX)\n\
    \  rom_string = roms[number % 100]\n  number %= 100\n  rom_string << roms[number\
    \ % 10]\n  number %= 10\n  rom_string << roms[number]\n  rom_string.downcase!\n\
    \  rom_string\nend\n</pre>\n</div>", "  int_to_roman(number)\nend", "  roman =\
    \ ''\n  while number > 0\n    roman, number = roman.insert(0, number % 10), (number\
    \ / 10)\n  end\n  roman\nend\nputs int_to_mini_roman(8) == \"'T\"\nputs int_to_mini_roman(9)\
    \ == 'XC'\nputs int_to_mini_roman(100) == 'C'\nputs int_to_mini_roman(1000) ==\
    \ 'C'\nputs int_to_mini_roman(123456) == 'MMMCMXCIX'\nputs int_to_mini_roman(654321)\
    \ == 'MMMDCCCLXXXVIII'\nputs int_to_mini_roman(19999) == 'MMMDCCCLXXXVIII'\nputs\
    \ int_to_mini_roman(12) == 'X'\nputs int_to_mini_roman(15) == 'V'\nputs int_to_mini_roman(21)\
    \ == 'C'\nputs int_to_mini_roman(26) == 'XC'\nputs int_to_mini_roman(35) == 'DCC'\n\
    puts int_to_mini_roman(52) == 'CD'\nputs int_to_mini_roman(61) == 'CCC'\nputs\
    \ int_to_mini_roman(71) == 'CC'\nputs int_to_mini_roman(81) == 'CD'\nputs int_to_mini_roman(91)\
    \ == 'CCC'\nputs int_to_mini_roman(101) == 'C'\nputs int_to_mini_roman(103) ==\
    \ 'XC'\nputs int_to_mini_roman(109) == 'C'\nputs int_to_mini_roman(111) == 'XC'\n\
    puts int_to_mini_roman(127) == 'C'\nputs int_to_mini_roman(131) == 'XC'\nputs\
    \ int_to_mini_roman(999) == 'MMMCMXCIX'", "  return case number\n  when 0..9\n\
    \    number.to_s\n  when 10..99\n    \"X\" * number\n  when 100..999\n    roman_to_mini_roman(number\
    \ / 10) + \" \" + \"M\" * (number % 10)\n  when 1000..9999\n    \"C\" * (number\
    \ / 100) + int_to_mini_roman(number % 100)\n  when 10000..99999\n    \"D\" * (number\
    \ / 1000) + int_to_mini_roman(number % 1000)\n  when 100000..999999\n    \"M\"\
    \ * (number / 10000) + int_to_mini_roman(number % 10000)\n  else\n    raise ArgumentError,\
    \ \"Invalid integer\"\n  end\nend", "  return roman_numeral_to_int(int_to_roman_numeral(number))\n\
    end\n</pre>\n    </td>\n  </tr>\n</table>\n</div></div><br class=\"example-break\"\
    \ />\n<a name=\"int_to_roman_numeral\"></a>\n<div class=\"api_metadata\">\n<span>Arguments:</span>\n\
    <ul>\n<li><code>number</code> <span class=\"type\">Integer</span></li>\n</ul>\n\
    </div>\n<div class=\"api_section\">\n<h2>Examples</h2>\n<table class=\"section\"\
    >\n  <tr>\n    <th class=\"code\">&nbsp;</th>\n    <th class=\"code\">&nbsp;</th>\n\
    \    <th class=\"code\">&nbsp;</th>\n    <th class=\"code\">&nbsp;</th>\n  </tr>\n\
    \  <tr>\n    <td class=\"docs\">\n<div class=\"pilwrap\">\n  <a class=\"pilcrow\"\
    \ href=\"#section-33\">&#182;</a>\n</div>\n<p><strong>int_to_roman_numeral(4)</strong></p>\n\
    \    </td>\n    <td class=\"code\">\n<pre class=\"ruby\"><span class=\"comment\"\
    ># 'IV'</span>\n</pre>\n    </td>\n    <td class=\"code\">\n<pre class=\"ruby\"\
    ><span class=\"comment\"># 'XCI'</span>\n</pre>\n    </td>\n    <td class=\"code\"\
    >\n<pre class=\"ruby\"><span class=\"comment\"># 'LXXV'</span>\n</pre>\n    </td>\n\
    \  </tr>\n</table>\n</div></div><br class=\"example-break\" />\n<a name=\"int_to_roman_numeral_with_base\"\
    ></a>\n<div class=\"api_metadata\">\n<span>Arguments:</span>\n<ul>\n<li><code>number</code>\
    \ <span class=\"type\">Integer</span></li>\n<li><code>base</code> <span class=\"\
    type\">Integer</span></li>\n</ul>\n</div>\n<div class=\"api_section\">\n<h2>Examples</h2>\n\
    <table class=\"section\">\n  <tr>\n    <th class=\"code\">&nbsp;</th>\n    <th\
    \ class=\"code\">&nbsp;</th>\n    <th class=\"code\">&nbsp;</th>\n    <th class=\"\
    code\">&nbsp;</th>\n  </tr>\n  <tr>\n    <td class=\"docs\">\n<div class=\"pilwrap\"\
    >\n  <a class=\"pilcrow\" href=\"#section-34\">&#182;</a>\n</div>\n<p><strong>int_to_roman_numeral(4,\
    \ 10)</strong></p>\n    </td>\n    <td class=\"code\">\n<pre class=\"ruby\"><span\
    \ class=\"comment\"># 'III'</span>\n</pre>\n    </td>\n    <td class=\"code\"\
    >\n<pre class=\"ruby\"><span class=\"comment\"># 'XLII'</span>\n</pre>\n    </td>\n\
    \    <td class=\"code\">\n<pre class=\"ruby\"><span class=\"comment\"># 'LIX'</span>\n\
    </pre>\n    </td>\n  </tr>\n</table>\n</div></div><br class=\"example-break\"\
    \ />\n<a name=\"int_to_roman_numeral_with_symbols\"></a>\n<div class=\"api_metadata\"\
    >\n<span>Arguments:</span>\n<ul>\n<li><code>:I</code> <span class=\"type\">Integer</span></li>\n\
    <li><code>:V</code> <span class=\"type\">Integer</span></li>", "  result = \"\"\
    \n  romans = [\"I\", \"IV\", \"V\", \"IX\", \"X\"]\n  while number > 0\n    roman_number,\
    \ number = divmod(number, 10)\n    result += romans[roman_number]\n  end\n  result\n\
    end", "  roman_digits = []\n  roman_digits_len = 8", "  roman_numerals = %w[I\
    \ V X L C D M D C L]\n  roman_numeral = roman_numerals[number - 1]\n  while roman_numeral.length\
    \ <= 3\n    roman_numeral += roman_numerals[roman_numeral.length - 1]\n  end\n\
    \  roman_numeral.upcase!\n  roman_numeral\nend\nprint int_to_mini_roman(123).inspect",
  "  # Write your code here.\n  roman = \"\"\n  roman_map = [['M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I']]\n\
    \  for i in 1..number.to_s.length\n    roman = roman + (roman_map[i-1][number.to_s.chars.last-2]\
    \ || \"\")\n  end\n  return roman\nend", "  roman = []\n  numerals = ['I', 'II',\
    \ 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII']", "  return int_to_roman(number,\
    \ 4)\nend", '  roman = ""', "    roman = \"\"\n    roman_digits = [[\"M\", \"\
    CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\"\
    , \"I\"]]\n    roman_num_to_roman = {0: \"M\", 1: \"CM\", 2: \"D\", 3: \"CD\"\
    , 4: \"C\", 5: \"XC\", 6: \"L\", 7: \"XL\", 8: \"X\", 9: \"IX\", 10: \"V\", 11:\
    \ \"IV\", 12: \"I\"}\n    \n    roman_digits = roman_digits[number - 1]\n    for\
    \ roman_digit in roman_digits:\n        roman += roman_num_to_roman[roman_digit]\n\
    \    \n    return roman.lower()", "    roman = \"\"\n    \n    # Convert each\
    \ of the four groups of digits to the corresponding number\n    # as given by\
    \ Roman numerals.\n    roman_digits = roman_numerals(number)", "  roman = ''\n\
    \  \n  # Reverse the digits\n  number = number.to_s.reverse\n  \n  # Add all the\
    \ digits\n  number.each_char do |digit|\n    # If the digit is greater than 7,\
    \ add 'i' to the roman numeral\n    digit = digit > 7 ? 'i' : digit\n    # Get\
    \ the roman numeral equivalent for that digit\n    roman = digit + roman \n  end\n\
    \  \n  # Return the roman numeral with it's digits reversed\n  return roman.downcase\n\
    end", "  roman_numerals = roman_numeral_table\n  roman_numeral = ''\n  while (number\
    \ != 0)\n    roman_numeral = roman_numerals[number % 10] + roman_numeral\n   \
    \ number /= 10\n  roman_numeral.downcase!\n  roman_numeral\nend", "  # Write your\
    \ code here.\n  roman_number = ''\n  int_to_roman = array.map {|n| n.to_s}\n \
    \ int_to_roman[number-1]\nend", "  return roman_to_int(to_roman(number))\nend",
  '  roman_numerals = []', "  str = ''\n  while number > 0\n    num, remainder = divmod(number,\
    \ 10)\n    str = (num.to_s + '.') if num != 0 else ''\n    str = (num.to_s + '.')\
    \ if num != 0 else ''\n    number = remainder\n  end\n  str.downcase\nend", " \
    \ roman = []\n  roman.push {'M' => 1000, 'D' => 500, 'C' => 100, 'L' => 50, 'X'\
    \ => 10, 'V' => 5, 'I' => 1}\n  roman.push {'M' => 1000, 'CM' => 400, 'D' => 500,\
    \ 'CD' => 400, 'C' => 100, 'XC' => 9, 'XL' => 40, 'X' => 10,\n              'IX'\
    \ => 9, 'V' => 5, 'IV' => 4, 'I' => 1}\n  roman.push {'M' => 1000, 'CM' => 400,\
    \ 'D' => 500, 'CD' => 400, 'C' => 100, 'XC' => 9, 'XL' => 40, 'X' => 10,\n   \
    \           'IX' => 9, 'V' => 5, 'IV' => 4, 'I' => 1}\n  roman.push {'M' => 1000,\
    \ 'CM' => 400, 'D' => 500, 'CD' => 400, 'C' => 100, 'XC' => 9, 'XL' => 40, 'X'\
    \ => 10,\n              'IX' => 9, 'V' => 5, 'IV' => 4, 'I' => 1}\n  roman.push\
    \ {'M' => 1000, 'CM' => 400, 'D' => 500, 'CD' => 400, 'C' => 100, 'XC' => 9, 'XL'\
    \ => 40, 'X' => 10,\n              'IX' => 9, 'V' => 5, 'IV' => 4, 'I' => 1}\n\
    \  roman.push {'M' => 1000, 'CM' => 400, 'D' => 500, 'CD' => 400, 'C' => 100,\
    \ 'XC' => 9, 'XL' => 40, 'X' => 10,\n              'IX' => 9, 'V' => 5, 'IV' =>\
    \ 4, 'I' => 1}\n  roman.push {'M' => 1000, 'CM' => 400, 'D' => 500, 'CD' => 400,\
    \ 'C' => 100, 'XC' => 9, 'XL' => 40, 'X' => 10,\n              'IX' => 9, 'V'\
    \ => 5, 'IV' => 4, 'I' => 1}\n  roman.push {'M' => 1000, 'CM' => 400, 'D' => 500,\
    \ 'CD' => 400, 'C' => 100, 'XC' => 9, 'XL' => 40, 'X' => 10,\n              'IX'\
    \ => 9, 'V' => 5, 'IV' => 4, 'I' => 1}\n  roman.push {'M' => 1000, 'CM' => 400,\
    \ 'D' => 500, 'CD' => 400, 'C' => 100, 'XC' => 9, 'XL' => 40, 'X' => 10,\n   \
    \           'IX' => 9, 'V' => 5, 'IV' => 4, 'I' => 1}\n  roman.push {'M' => 1000,\
    \ 'CM' => 400, 'D' => 500, 'CD' => 400, 'C' => 100, 'XC' => 9, 'XL' => 40, 'X'\
    \ => 10,\n              'IX' => 9", "  if number == 0\n    \"I\"\n  elsif number\
    \ == 1\n    \"IV\"\n  elsif number == 5\n    \"V\"\n  elsif number == 10\n   \
    \ \"IX\"\n  elsif number == 50\n    \"LV\"\n  elsif number == 100\n    \"M\"\n\
    \  elsif number == 500\n    \"D\"\n  elsif number == 1000\n    \"CD\"\n  end\n\
    end", "  roman_numbers = Array.new\n  while number > 0\n    roman_numbers.push(get_roman_number(number))\n\
    \    number -= 1\n  end\n  return roman_numbers.join('')\nend", "  roman_numeral\
    \ = nil\n  roman_numeral = number_to_roman(number)\n  roman_numeral.downcase!\n\
    \  return roman_numeral\nend\n</pre>", "  roman = []\n  roman_num = {\n    1000\
    \ => \"M\", 99 => \"CM\", 9  => \"D\", 8  => \"CD\", 7  => \"C\",\n    6  => \"\
    XC\", 5  => \"L\", 4  => \"XL\", 3  => \"X\", 2  => \"IX\", 1  => \"V\",\n   \
    \ 0  => \"IV\", -1 => \"I\"}\n  roman_num_length = roman_num.size\n  roman[0]\
    \ = roman_num[number]\n  for i in 0...roman_num_length-1\n    roman[i + 1] = roman_num[(roman_num[roman[i]]\
    \ * 10) + roman[i+1]]\n  end\n  return roman.join('').downcase\nend", "  roman\
    \ = []\n  while number > 0\n    roman.push(roman.to_s % 10)\n    number = number\
    \ / 10\n  end\n  roman.push(roman.to_s)\n  roman.join\nend", "    if number <\
    \ 1 || number > 1000\n        throw \"Number out of bound\"\n    roman = Array.new\n\
    \    roman[0] = \"I\"\n    roman[1] = \"II\"\n    roman[2] = \"III\"\n    roman[3]\
    \ = \"IV\"\n    roman[4] = \"V\"\n    roman[5] = \"VI\"\n    roman[6] = \"VII\"\
    \n    roman[7] = \"VIII\"\n    roman[8] = \"IX\"\n    roman[9] = \"X\"\n    roman[10]\
    \ = \"XI\"\n    roman[11] = \"XII\"\n    roman[12] = \"XIII\"\n    roman[13] =\
    \ \"XIV\"\n    roman[14] = \"XV\"\n    roman[15] = \"XVI\"\n    roman[16] = \"\
    XVII\"\n    roman[17] = \"XVIII\"\n    roman[18] = \"XIX\"\n    roman[19] = \"\
    XX\"\n    roman[20] = \"XXI\"\n    roman[21] = \"XXII\"\n    roman[22] = \"XXIII\"\
    \n    roman[23] = \"XXIV\"\n    roman[24] = \"XXV\"\n    roman[25] = \"XXVI\"\n\
    \    roman[26] = \"XXVII\"\n    roman[27] = \"XXVIII\"\n    roman[28] = \"XXIX\"\
    \n    roman[29] = \"XXX\"\n    roman[30] = \"XXXI\"\n    roman[31] = \"XXXII\"\
    \n    roman[32] = \"XXXIII\"\n    roman[33] = \"XXXIV\"\n    roman[34] = \"XXXV\"\
    \n    roman[35] = \"XXXVI\"\n    roman[36] = \"XXXVII\"\n    roman[37] = \"XXXVIII\"\
    \n    roman[38] = \"XXXIX\"\n    roman[39] = \"XL\"\n    roman[40] = \"XLI\"\n\
    \    roman[41] = \"XLII\"\n    roman[42] = \"XLIII\"\n    roman[43] = \"XLIIII\"\
    \n    roman[44] = \"XLIIV\"\n    roman[45] = \"XLIV\"\n    roman[46] = \"XLIVI\"\
    \n    roman[47] = \"XLIVII\"\n    roman[48] = \"", "  roman = \"\"\n  \n  # For\
    \ each integer less than or equal to 1000\n  (0...1000).each do |i|\n    \n  \
    \  # If the integer is divisible by 3\n    if (i % 3 == 0)\n      \n      # Add\
    \ three to the integer if it is even and divide by 3 if it is odd\n      roman\
    \ << i\n      roman << i\n      roman << i\n      \n    # Else, if the integer\
    \ is divisible by 5\n    else\n      \n      # Add five to the integer if it is\
    \ even and divide by 5 if it is odd\n      roman << i\n      roman << i\n    \
    \  roman << i\n    end\n    \n    # Add a new line at the end of the roman numeral\
    \ if a newline\n    # is added to the string\n    roman << \"\\n\"\n  end\n  \n\
    \  return roman.downcase\nend", "  roman = \"\"\n  counter = 0", "    if number\
    \ < 1 or\n       number > 1000 then\n           return nil\n    end\n    roman\
    \ = [\"\"]\n    number.times do |i|\n        roman[i.to_s.size - 1] +=\n     \
    \       i % 10 == 0 and \"M\" or i%10\n    end\n    roman.map! do |roman|\n  \
    \      roman.downcase!\n    end\n    return roman\nend", "  roman = nil\n  while\
    \ number > 0\n    roman = (roman.succ) if roman && roman.is_a? Bignum\n    roman\
    \ = roman.to_s + \"I\" if roman && roman.is_a? String\n    number -= 1000\n  end\n\
    \  return roman if roman\n  roman = String.new\n  while number > 0\n    roman\
    \ += (number % 10).to_s\n    number /= 10\n  end\n  return roman\nend", "  roman_to_int\
    \ = \nend\n</code>\nThen the algorithm for determining whether a roman numeral\
    \ is valid is this:", "  roman = \"IV\"\n  digits = number.to_s.split('')\n  digits.reverse!",
  "  roman = Array.new\n  roman.push( \"M\" )\n  roman.push( \"D\" )\n  roman.push(\
    \ \"C\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  roman.push( \"M\" )\n  roman.push( \"C\" )\n  roman.push(\
    \ \"D\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  roman.push( \"M\" )\n  roman.push( \"C\" )\n  roman.push(\
    \ \"D\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  roman.push( \"M\" )\n  roman.push( \"C\" )\n  roman.push(\
    \ \"D\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  roman.push( \"M\" )\n  roman.push( \"C\" )\n  roman.push(\
    \ \"D\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  roman.push( \"M\" )\n  roman.push( \"C\" )\n  roman.push(\
    \ \"D\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  roman.push( \"M\" )\n  roman.push( \"C\" )\n  roman.push(\
    \ \"D\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  roman.push( \"M\" )\n  roman.push( \"C\" )\n  roman.push(\
    \ \"D\" )\n  roman.push( \"L\" )\n  roman.push( \"X\" )\n  roman.push( \"V\" )\n\
    \  roman.push( \"I\" )\n  ", "  roman_arr = [1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1]\n  roman_arr.each do |roman_num|\n    if number < roman_num\n\
    \      break\n    end\n    number -= roman_num\n  end\n  roman_arr.unshift(number)\n\
    \  roman_arr.each do |roman_num|\n    roman_str = roman_num.to_s + \".\"\n  end\n\
    \  roman_arr.join\nend", "  numerals = [nil, 'I', 'II', 'III', 'IV', 'V', 'VI',\
    \ 'VII']\n  roman_numerals = [nil, \"\", \"M\", \"MM\", \"MMM\"]\n  roman_numerals[0...number.to_s.length].each\
    \ do |digit|\n    roman_numerals[number%1000].each do |numeral|\n      return\
    \ numeral\n    end\n    number = (number - number%1000)\n  end\n  nil\nend", " \
    \ # Special case\n  if number == 0\n    \"I\"\n  elsif number == 1\n    \"I\"\n\
    \  elsif number == 2\n    \"II\"\n  elsif number == 3\n    \"III\"\n  elsif number\
    \ == 4\n    \"IV\"\n  elsif number == 5\n    \"V\"\n  elsif number == 6\n    \"\
    VI\"\n  elsif number == 7\n    \"VII\"\n  elsif number == 8\n    \"VIII\"\n  elsif\
    \ number == 9\n    \"IX\"\n  else\n    int_to_mini_roman(number / 10) + int_to_mini_roman(number\
    \ % 10)\n  end\nend", "  return roman_to_int(int_to_roman(number)).to_s\nend\n\
    </pre>\n</section>\n<section id=\"string-reverse\">\n  <h3>String Reverse</h3>\n\
    \  <p>A string in Ruby has a <code>reverse</code> method that returns a new string\
    \ with characters in reverse order.</p>\n  <p>The <code>reverse</code> method\
    \ works on any object that has a <code>to_s</code> method (such as a string, hash\
    \ or array).</p>\n<pre>", "  roman = []\n  current_roman = 0\n  i = 0\n  while\
    \ current_roman < number\n    if number % current_roman == 0\n      i += 1\n \
    \     roman.unshift current_roman.to_s\n      current_roman = i\n    end\n   \
    \ current_roman += 1\n  end\n  roman.unshift current_roman.to_s\n  roman\nend",
  "    if number == 0 then\n        '0'\n    else\n        roman_numerals = %w[IVXLCDM]\n\
    \        s = ''\n        while number >= 10 do\n            number, digit = number\
    \ % 10, number / 10\n            s = roman_numerals[digit] + s\n        end\n\
    \        roman_numerals = %w[IXMC]\n        while number >= 5 do\n           \
    \ number, digit = number % 5, number / 5\n            s = roman_numerals[digit]\
    \ + s\n        end\n        roman_numerals = %w[VXL]\n        while number >=\
    \ 1 do\n            number, digit = number % 1, number / 1\n            s = roman_numerals[digit]\
    \ + s\n        end\n        s\n    end\nend", "  roman_numerals = Array.new(1000)\n\
    \  roman_numerals[0] = 'I'\n  roman_numerals[1] = 'V'\n  roman_numerals[2] = 'X'\n\
    \  roman_numerals[3] = 'L'\n  roman_numerals[4] = 'C'\n  roman_numerals[5] = 'D'\n\
    \  roman_numerals[6] = 'M'\n  roman_numerals[7] = 'I'\n  roman_numerals[8] = 'V'\n\
    \  roman_numerals[9] = 'X'\n  roman_numerals[10] = 'L'\n  roman_numerals[11] =\
    \ 'C'\n  roman_numerals[12] = 'D'\n  roman_numerals[13] = 'M'\n  roman_numerals[14]\
    \ = 'I'\n  roman_numerals[15] = 'V'\n  roman_numerals[16] = 'X'\n  roman_numerals[17]\
    \ = 'L'\n  roman_numerals[18] = 'C'\n  roman_numerals[19] = 'D'\n  roman_numerals[20]\
    \ = 'M'\n  roman_numerals[21] = 'I'\n  roman_numerals[22] = 'V'\n  roman_numerals[23]\
    \ = 'X'\n  roman_numerals[24] = 'L'\n  roman_numerals[25] = 'C'\n  roman_numerals[26]\
    \ = 'D'\n  roman_numerals[27] = 'M'\n  roman_numerals[28] = 'I'\n  roman_numerals[29]\
    \ = 'V'\n  roman_numerals[30] = 'X'\n  roman_numerals[31] = 'L'\n  roman_numerals[32]\
    \ = 'C'\n  roman_numerals[33] = 'D'\n  roman_numerals[34] = 'M'\n  roman_numerals[35]\
    \ = 'I'\n  roman_numerals[36] = 'V'\n  roman_numerals[37] = 'X'\n  roman_numerals[38]\
    \ = 'L'\n  roman_numerals[39] = 'C'\n  roman_numerals[40] = 'D'\n  roman_numerals[41]\
    \ = 'M'\n  roman_numerals[42] = 'I'\n  roman_numerals[43] = 'V'\n  roman_numerals[44]\
    \ = 'X'\n  roman_numerals[45] = 'L'\n  ro", "  roman_numbers = []\n  roman = Array.new\n\
    \  while number > 0\n    roman_numbers << number % 3\n    number /= 3\n  end\n\
    \  roman.concat(roman_numbers)\n  roman.reverse!\n  roman.each_with_index do |number,\
    \ index|\n    roman[index] = case number % 10\n      when 0 then \"M\"\n     \
    \ when 1 then \"D\"\n      when 2 then \"C\"\n      when 3 then \"L\"\n      when\
    \ 4 then \"X\"\n      when 5 then \"V\"\n      when 6 then \"I\"\n      else nil\n\
    \    end\n  end\n  roman.join\nend", "  if number < 1\n    raise \"Invalid input\"\
    \n  end\n  roman = \"\"\n  n1 = (number / 100) + 1\n  roman = roman + (n1.to_s.rjust(3,\"\
    0\")) if n1\n  n2 = number % 100\n  roman = roman + (n2.to_s.rjust(3,\"0\")) if\
    \ n2\n  roman = roman + (\"M\" * n1)\n  roman = roman.lstrip\n  return roman\n\
    end", "  roman = Array.new(9)\n  roman[0] = [\"M\", 1000]\n  roman[1] = [\"CM\"\
    , 900]\n  roman[2] = [\"D\", 500]\n  roman[3] = [\"CD\", 400]\n  roman[4] = [\"\
    C\", 100]\n  roman[5] = [\"XC\", 90]\n  roman[6] = [\"L\", 50]\n  roman[7] = [\"\
    XL\", 40]\n  roman[8] = [\"X\", 10]\n  roman.each_with_index { |n, i| roman[i]\
    \ += [n].join }\n  roman[number]\nend", "  roman = '' \n  roman_vals = { \"I\"\
    \  => 1,\n                \"V\"  => 5,\n                \"X\"  => 10,\n      \
    \          \"L\"  => 50,\n                \"C\"  => 100,\n                \"D\"\
    \  => 500,\n                \"M\"  => 1000}\n  while number > 0\n    roman_val\
    \ = roman_vals[number%10]\n    number -= roman_val\n    roman << roman_val\n \
    \ end\n  return roman\nend\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n   \
    \             \"V\"  => 5,\n                \"X\"  => 10,\n                \"\
    L\"  => 50,\n                \"C\"  => 100,\n                \"D\"  => 500,\n\
    \                \"M\"  => 1000}\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n\
    \                \"V\"  => 5,\n                \"X\"  => 10,\n               \
    \ \"L\"  => 50,\n                \"C\"  => 100,\n                \"D\"  => 500,\n\
    \                \"M\"  => 1000}\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n\
    \                \"V\"  => 5,\n                \"X\"  => 10,\n               \
    \ \"L\"  => 50,\n                \"C\"  => 100,\n                \"D\"  => 500,\n\
    \                \"M\"  => 1000}\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n\
    \                \"V\"  => 5,\n                \"X\"  => 10,\n               \
    \ \"L\"  => 50,\n                \"C\"  => 100,\n                \"D\"  => 500,\n\
    \                \"M\"  => 1000}\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n\
    \                \"V\"  => 5,\n                \"X\"  => 10,\n               \
    \ \"L\"  => 50,\n                \"C\"  => 100,\n                \"D\"  => 500,\n\
    \                \"M\"  => 1000}\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n\
    \                \"V\"  => 5,\n                \"X\"  => 10,\n               \
    \ \"L\"  => 50,\n                \"C\"  => 100,\n                \"D\"  => 500,\n\
    \                \"M\"  => 1000}\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n\
    \                \"V\"  => 5,\n                \"X\"  => 10,\n               \
    \ \"L\"  => 50,\n                \"C\"  => 100,\n                \"D\"  => 500,\n\
    \                \"M\"  => 1000}\n</cell>\n<cell>\nroman_vals = { \"I\"  => 1,\n\
    \                \"V\"  => 5,\n                \"X\"  => 10,\n               \
    \ \"L\"  ", "  roman_number = ''\n  roman_number << int_to_roman(number)\n  roman_number\
    \ << int_to_roman(number / 10)\n  roman_number << int_to_roman(number / 100)\n\
    \  roman_number << int_to_roman(number / 1000)\n  roman_number << int_to_roman(number\
    \ / 1000000)\n  roman_number << int_to_roman(number / 1000000000)\n  roman_number.strip\n\
    end", "  int_to_roman(number).downcase\nend\n</pre>", "  roman_numerals = []\n\
    \  digits = Array.new\n  roman_numerals.push []", "  if number == 0\n    \"zero\"\
    \n  elsif number > 0 and number < 400\n    \"not \"\n  elsif number < 0 and number\
    \ >= -1000\n    \"negative \"\n  else\n    roman = string.ascii_lowercase[ (number\
    \ / 100)%1000 ].to_s\n    roman += string.ascii_lowercase[ (number % 100)%10 ].to_s\n\
    \  end", "  return int_to_roman(number)\nend", "  roman_numeral = \"\"\n  roman_numeral\
    \ = mini_roman_to_int(number)\n  roman_numeral.downcase\nend", "  if number <\
    \ 1\n    raise ArgumentError, \"Invalid input\"\n  end\n  romans = ROMAN_ORDER.keys\n\
    \  romans.sort!", "    roman_array = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"\
    XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\n\
    \    i = 0\n    while i < number\n        if number % i == 0\n            roman\
    \ += roman_array[i]\n            number /= i\n        end\n        i += 1\n  \
    \  end\n    return roman.upcase\nend", '  roman_nums = []', "    roman = \"\"\n\
    \    roman_numerals = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"\
    XC\", \"C\", \"CD\", \"D\", \"CM\", \n                      \"M\", \"MN\", \"\
    N\", \"NO\", \"NX\", \"XO\", \"O\", \"OP\", \"P\", \"PR\", \"R\"]\n    \n    roman_numerals\
    \ = [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"\
    , \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\"\
    , \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXIX\", \"XL\", \"L\"\
    , \"LX\", \"LXX\", \"LXXX\", \"LXXXX\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    , \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXIX\", \"XC\", \"C\", \"CXX\", \"\
    CXXX\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"\
    CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\"\
    , \"CXXXVIII\", \"CXXIX\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"DCD\",\
    \ \"DCDC\", \"DCM\", \"DCMC\", \"DCP\", \"DCPC\", \"DCR\", \"DCRC\", \"DCT\",\
    \ \"DCTC\", \"DCV\", \"DCVC\", \"DCVC\", \"DCX\", \"DCXI\", \"DCXII\", \"DCXIII\"\
    , \"DCXIV\", \"DCXV\", \"DCXVI\", \"DCXVII\", \"DCXVIII\", \"DCXIX\", \"DXX\"\
    , \"DXXI\", \"DXXII\", \"DXXIII\", \"DXXIV\", \"DXXV\", \"DXXVI\", \"DXXVII\"\
    , \"DXXVIII\", \"DXXIX\", \"DXXX\", \"DXXXI\", \"", "  roman = Array.new(26, \"\
    IIIIIIII\")\n  roman[0] = roman[1] = roman[2] = roman[3] = \"II\"\n  roman[4]\
    \ = \"IV\"\n  roman[5] = \"V\"\n  roman[6] = \"I\"\n  roman[7] = \"III\"\n  roman[8]\
    \ = \"IV\"\n  roman[9] = \"V\"\n  roman[10] = \"VI\"\n  roman[11] = \"I\"\n  roman[12]\
    \ = \"II\"\n  roman[13] = \"III\"\n  roman[14] = \"IV\"\n  roman[15] = \"V\"\n\
    \  roman[16] = \"VI\"\n  roman[17] = \"I\"\n  roman[18] = \"II\"\n  roman[19]\
    \ = \"III\"\n  roman[20] = \"IV\"\n  roman[21] = \"V\"\n  roman[22] = \"VI\"\n\
    \  roman[23] = \"I\"\n  roman[24] = \"II\"\n  roman[25] = \"III\"\n  roman[26]\
    \ = \"IV\"\n  roman[27] = \"V\"\n  roman[28] = \"VI\"\n  roman[29] = \"I\"\n \
    \ roman[30] = \"II\"\n  roman[31] = \"III\"\n  roman[32] = \"IV\"\n  roman[33]\
    \ = \"V\"\n  roman[34] = \"VI\"\n  roman[35] = \"I\"\n  roman[36] = \"II\"\n \
    \ roman[37] = \"III\"\n  roman[38] = \"IV\"\n  roman[39] = \"V\"\n  roman[40]\
    \ = \"VI\"\n  roman[41] = \"I\"\n  roman[42] = \"II\"\n  roman[43] = \"III\"\n\
    \  roman[44] = \"IV\"\n  roman[45] = \"V\"\n  roman[46] = \"VI\"\n  roman[47]\
    \ = \"I\"\n  roman[48] = \"II\"\n  roman[49] = \"III\"\n  roman[50] = \"IV\"\n\
    \  roman[51] = \"V\"\n  roman[52] = \"VI\"\n  roman[53] = \"I\"\n  roman[54] =\
    \ \"II\"\n  roman[55] = \"III\"\n  roman[", "  if number == 0\n    roman = 'I'\
    \ \n  elsif number < 2\n    roman = 'I' \n  elsif number < 10 \n    roman = int_to_mini_roman(number\
    \ - 1) + '.'\n  elsif number < 100 \n    roman = int_to_mini_roman(number - 10)\
    \ + 'M'\n  elsif number < 1000\n    roman = int_to_mini_roman(number - 100) +\
    \ 'CM'\n  elsif number < 2000\n    roman = int_to_mini_roman(number - 1000) +\
    \ 'D'\n  elsif number < 3000\n    roman = int_to_mini_roman(number - 2000) + 'CD'\n\
    \  elsif number < 4000\n    roman = int_to_mini_roman(number - 3000) + 'C'\n \
    \ elsif number < 5000\n    roman = int_to_mini_roman(number - 4000) + 'XC'\n \
    \ elsif number < 6000\n    roman = int_to_mini_roman(number - 5000) + 'L'\n  elsif\
    \ number < 7000\n    roman = int_to_mini_roman(number - 6000) + 'XL'\n  elsif\
    \ number < 8000\n    roman = int_to_mini_roman(number - 7000) + 'X'\n  elsif number\
    \ < 9000\n    roman = int_to_mini_roman(number - 8000) + 'IX'\n  elsif number\
    \ < 10000\n    roman = int_to_mini_roman(number - 9000) + 'V'\n  elsif number\
    \ < 100000\n    roman = int_to_mini_roman(number - 10000) + 'IV'\n  elsif number\
    \ < 1000000\n    roman = int_to_mini_roman(number - 100000) + 'I'\n  elsif number\
    \ < 10000000\n    roman = int_to_mini_roman(number - 1000000) + 'X'\n  elsif number\
    \ < 100000000\n    roman = int_to_mini_roman(number - 10000000) + 'XL'\n  elsif\
    \ number < 1000000000\n    roman = int_to_mini_roman(number - 100000000) + 'L'\n\
    \  elsif number < 10000000000\n    roman = int_to_mini_roman(number - 1000000000)\
    \ + 'XC'\n  elsif ", "  return if number.zero?\n  roman = \"V\"\n  numeral = number.to_s\n\
    \  while numeral.size > 1\n    roman, numeral = roman.to_s.insert(0, \"M\"), (numeral\
    \ / 10).to_s.insert(0, \"CM\")\n    roman, numeral = roman.to_s.insert(0, \"D\"\
    ), (numeral / 10).to_s.insert(0, \"CD\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"C\"), (numeral / 10).to_s.insert(0, \"CC\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"XC\"), (numeral / 10).to_s.insert(0, \"XXX\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"L\"), (numeral / 10).to_s.insert(0, \"XL\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"XL\"), (numeral / 10).to_s.insert(0, \"L\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"X\"), (numeral / 10).to_s.insert(0, \"X\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"IX\"), (numeral / 10).to_s.insert(0, \"XX\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"V\"), (numeral / 10).to_s.insert(0, \"V\")\n    roman, numeral = roman.to_s.insert(0,\
    \ \"IV\"), (numeral / 10).to_s.insert(0, \"I\")\n  end\n  return roman\nend\n\
    </code>\n<|/ a tags=ruby dscore=5 |>\n<| c |>\nIn Ruby 1.9.3, `roman.to_s.reverse`\
    \ works, but `roman.to_s.reverse.insert(0,\"M\")` doesn't\n<|/ c |>\n<| c |>\n\
    : That's a nice and clear explanation why `to_s` can't be modified.\n<|/ c |>\n\
    <| c |>\n+1 for the detailed explanation. Thanks\n<|/ c |>\n<| c |>\n`roman =\
    \ roman.insert(0,\"M\")` works but `roman.insert(0,\"M\").insert(0,\"M\")` doesn't.\
    \ `roman.insert(0,\"M\").insert(0,\"M\").insert(0,\"M\")` does\n<|/ c |>\n<| c\
    \ |>\n`roman = roman.insert(0,\"M\").insert(0,\"M\").insert(0,\"M\").insert(0,\"\
    M\")` does work.\n<|/ c |>\n<|", "  roman = ''\n  while number >= 1000\n    roman\
    \ += (number/1000)\n    number = number/1000 - 1000\n  end\n  if number > 1\n\
    \    roman += number\n  end\n  roman.to_s.downcase\nend", "    if number < 1 ||\
    \ number > 1000\n        puts \"Invalid number\"\n        return\n    end\n  \
    \  romans = Array.new(number) { \"M\" * number }\n    roman =  roman + romans.join(\"\
    X\")\n    return roman[0..-2]\nend", "  # Write your code here\n  roman_num =\
    \ Array.new\n  \n  ones = 0\n  \n  if number <= 0\n    roman_num << 0\n  else\n\
    \    while (number > 0)\n      roman_num << number % 10\n      number /= 10\n\
    \    end\n    \n    while (roman_num.length > 0)\n      if roman_num[-1] == 10\n\
    \        ones +=1\n        roman_num.pop\n      end\n      \n      if roman_num[-1]\
    \ >= 5\n        ones -= 1\n        roman_num.pop\n      end\n    end\n  end\n\
    \  \n  roman_num.reverse\n  \n  if roman_num.length > 0\n    roman_num[-1] = roman_num[-1].to_s\
    \ << ones\n  end\n  \n  roman_num.join\nend", "  roms = (\"M\", \"CM\", \"D\"\
    , \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\")\n\
    \  ret = \"\"", "  roman = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII',\
    \ 'IX']\n  roman.map {|v| roman.index(v) + number}\nend", "    roman = ''\n  \
    \  roman_map = {\n        1 => 'I', \n        5 => 'V', \n        10 => 'X', \n\
    \        20 => 'L', \n        40 => 'C', \n        60 => 'D', \n        80 =>\
    \ 'M'\n    }\n    while number > 0 do\n        roman_digit = number % 100\n  \
    \      roman << roman_map[roman_digit]\n        number /= 100\n    end\n    roman.reverse!\n\
    \    return roman\nend\n</code>\n<|/ a tags=ruby,algorithm,roman |>\n<| c |>\n\
    `roman_digit = number % 100` should be `roman_digit = number % 100_000`\n<|/ c\
    \ |>\n<| a dscore=4 |>\nHere is my solution (using Ruby 1.9):\n<code>\nrequire\
    \ 'roman'", "    # Write your code here.\nend", "  roman = [\"m\", \"cm\", \"\
    d\", \"cd\", \"i\", \"ix\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"xc\"\
    ]\n  roman.to_s\nend", "  if number < 0\n    return nil\n  end\n  roman_num =\
    \ Array.new\n  roman_num.concat(int_to_mini_roman(number / 100), int_to_mini_roman(number\
    \ % 100))\n  roman_num.push((number % 100).to_s) if number > 100\n  roman_num.push((number\
    \ % 10).to_s) if (number % 10).to_s == 0\n  roman_num.push((number % 5).to_s)\
    \ if (number % 5).to_s == 0\n  roman_num.push((number % 1).to_s) if (number %\
    \ 1).to_s == 0\n  roman_num.join(\"\")\nend", "    roman = \"I\"\n    if number\
    \ < 0\n        number *= -1\n        roman = \"IV\"\n    else if number < 500\n\
    \        roman = \"V\"\n    else if number < 1000\n        roman = \"IX\"\n  \
    \  else if number < 5000\n        roman = \"X\"\n    else if number < 10000\n\
    \        roman = \"XL\"\n    else if number < 50000\n        roman = \"L\"\n \
    \   else if number < 100000\n        roman = \"XC\"\n    else if number < 500000\n\
    \        roman = \"C\"\n    else if number < 1000000\n        roman = \"CD\"\n\
    \    else if number < 5000000\n        roman = \"D\"\n    else if number < 10000000\n\
    \        roman = \"CM\"\n    else if number < 50000000\n        roman = \"M\"\n\
    \    else if number < 100000000\n        roman = \"MN\"\n    else if number <\
    \ 500000000\n        roman = \"M\"\n    else if number < 1000000000\n        roman\
    \ = \"CM\"\n    else if number < 5000000000\n        roman = \"D\"\n    else if\
    \ number < 10000000000\n        roman = \"CD\"\n    else if number < 50000000000\n\
    \        roman = \"C\"\n    else if number < 100000000000\n        roman = \"\
    XC\"\n    else if number < 500000000000\n        roman = \"X\"\n    else if number\
    \ < 1000000000000\n        roman = \"IX\"\n    else if number < 5000000000000\n\
    \        roman = \"V\"\n    else if number < 10000000000000\n        roman = \"\
    IV\"\n    else if number < 50000000000000\n        roman = \"I\"\n    else if\
    \ number < 100000000000000\n        roman = \"I\"\n    else if number < 500000000000000\n\
    \        roman = \"I\"\n    else if number < 1000000000000000\n        roman =\
    \ \"I\"\n    else if number < 5000000000000000\n        roman = \"I\"\n    else\
    \ if number < 1000000000000000000\n        roman = \"I\"\n    else \n        roman\
    \ = \"I\"\n    return roman\nend", "  roman = MiniRoman.new\n  roman.int_to_roman(number)\n\
    \  roman.downcase!\n  roman.to_s\nend", "  # TODO: implement this function\n \
    \ roman = ''\n  while (number > 0)\n    # Write your code here.\n    roman +=\
    \ (number % 10).to_s + ' '\n    number /= 10\n  end\n  return roman.strip\nend",
  "  roman = Array.new(4)\n  roman[0] = \"I\"\n  roman[1] = \"II\"\n  roman[2] = \"\
    III\"\n  roman[3] = \"IV\"", "  # Write your code here.\n  roman = ''\n  if number\
    \ < 0 or number > 999 then\n    return roman\n  end", '  roman = Array.new', '  roman_numeral
    = ""', "  roman = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\"\
    , \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n  return roman[number - 1]\nend\n</pre>",
  "  return int_to_roman(number)\nend", "  roman = \"I\"\n  while number > 0\n   \
    \ roman = roman.succ\n    number -= 1000\n  end\n  roman = roman.succ\n  while\
    \ number > 0\n    roman = roman.succ\n    number -= 100\n  end\n  roman = roman.succ\n\
    \  while number > 0\n    roman = roman.succ\n    number -= 10\n  end\n  roman\
    \ = roman.succ\n  while number > 0\n    roman = roman.succ\n    number -= 1\n\
    \  end\n  roman.to_s\nend\nputs int_to_mini_roman(33) # III", "  romans = [ \"\
    M\", \"D\", \"C\", \"L\", \"X\", \"V\", \"I\" ]\n  roman = romans[number-1]\n\
    \  result = \"\"\n  while number > 0\n    result << roman\n    number -= 1\n \
    \ end\n  return result.downcase\nend", "  romans = []\n  int_to_roman(number,\
    \ romans)\n  romans.join.downcase\nend\n</code></pre></div></div></div><div class=\"\
    section\"><div class=\"titlepage\"><div><div><h2 class=\"title\" style=\"clear:\
    \ both\"><a id=\"id810\"></a>6.3.\_Strings</h2></div></div></div><p><a id=\"id811\"\
    ></a>Strings are a useful data type for storing text.  They are often\nused to\
    \ store filenames, addresses, email addresses, passwords, and other text.\nStrings\
    \ in Ruby are enclosed in double quotes, and use the single quote\ncharacter for\
    \ text enclosed in single quotes.</p><div class=\"example\"><p><a id=\"ex-8\"\
    ></a>Here is a string that contains double quotes:</p><pre class=\"programlisting\"\
    >'a text string containing &quot;double quotes&quot;'</pre><p>And the equivalent\
    \ string containing single quotes:</p><pre class=\"programlisting\">\"a text string\
    \ containing 'single quotes'\"</pre><p>Both strings are equivalent in Ruby.</p></div><p><a\
    \ id=\"id812\"></a>Strings are immutable: you cannot make changes to a string\
    \ once you create it.\nThis includes appending a string to another string, which\
    \ is done with the <code class=\"methodname\">concat</code>\nmethod. <a class=\"\
    xref\" href=\"strings.html\" title=\"12.2. Strings\">Section\_12.2</a> (<a href=\"\
    #sec-strings\">9.2.2</a>) gives some examples of how methods that change\nstrings\
    \ actually return new strings that are the original string with the\nchanges applied.</p><div\
    \ class=\"section\"><div class=\"titlepage\"><div><div><h2 class=\"title\" style=\"\
    clear: both\"><a id=\"id813\"></a>6.4.\_Regular Expressions</h2></div></div></div><p><a\
    \ id=\"id814\"></a>The regular expression (<a class=\"ulink\" href=\"/ruby-spec/regexp.html\"\
    >Regexp</a>) object\nis the fundamental data structure for searching and manipulating\
    \ strings in Ruby.\nRegular expressions are a powerful, flexible and versatile\
    \ pattern matching language\nthat is often used by text processing applications.</p><div\
    \ class=\"section\"><div class=\"titlepage\"><div><div><h2 class=\"title\" style=\"\
    clear: both\"><a id=\"id815\"></a>6.5.\_Regular Expression Syntax</h2></div></div></div><p><a\
    \ id=\"id816\"></a>Regular expressions are written using the conventions of <a\
    \ class=\"ulink\" href=\"/ruby-spec/regexp.html\">Regexp</a>,\nincluding use of\
    \ curly brackets <code class=\"code\">{...}</code>, parentheses\n<code class=\"\
    code\">(...)</code>, and a character class <code class=\"code\">[...]</code>.\
    \  Regular expressions\nare often written and tested using the\n<a class=\"ulink\"\
    \ href=\"http://www.regular-", "  roman_numbers = []\n  tens_values = [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n\
    \  num = 0\n  while num < number\n    roman_numbers[num] = roman_to_int[number-num]\n\
    \    num += 1\n  end\n  roman_numbers.reverse\n  roman_numbers.map!{ |i| roman_numbers[i.to_s].upcase\
    \ }\n  return roman_numbers.join\nend\nputs int_to_mini_roman(50) == itoa", " \
    \ roman_numbers = %w{\n    I\n    V\n    X\n    L\n    C\n    D\n    M\n    S\n\
    \  }\n  return roman_numbers[number]\nend", "  romans = [\"\", \"I\", \"II\",\
    \ \"III\", \"IV\", \"V\", \"VI\", \"VII\"]\n  roman_num = 0\n  while (number >=\
    \ 1)\n    roman_num *= 10\n    roman_num += number % 10\n    number /= 10\n  return\
    \ romans[roman_num].downcase\nend", "  roman = Array.new\n  roman.push(\"I\")\n\
    \  roman.push(\"V\")\n  roman.push(\"X\")\n  roman.push(\"L\")\n  roman.push(\"\
    C\")\n  roman.push(\"D\")\n  roman.push(\"M\")\n  roman.push(\"_\")\n  roman.push(\"\
    _\")\n  roman.push(\"_\")\n  roman.push(\"_\")\n  roman.push(\"_\")", "  roman\
    \ = ''\n  i = 0\n  while (number >= i)\n    roman, i = roman.to_s(2) + roman.to_s(i)\n\
    \    number = number - i\n  roman, i = roman.to_s(2) + roman.to_s(i).to_s.upcase,\
    \ i-1\n  roman, i = roman.to_s(i) + roman.to_s(1).to_s.upcase, i\n  roman, i =\
    \ roman.to_s(i) + roman.to_s(1).to_s.upcase, i\n  roman, i = roman.to_s(i) + roman.to_s(1).to_s.upcase,\
    \ i\n  return roman\nend\n</code>\n<|/ a tags=ruby,string dscore=1 |>\n<| c |>\n\
    How does this work? I ran it, and it works. But I don't understand how it works.\
    \ Would someone be able to walk through it?\n<|/ c |>\n<| c |>\nThis works by\
    \ building a string with roman numerals corresponding to the number and then converts\
    \ that to a string with lower case letters corresponding to the number using #downcase.\n\
    <|/ c |>\n<| c |>\nI'm running it and it's giving me a stack overflow error.\n\
    <|/ c |>\n<| c |>\n, I have added an explanation.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  int_to_roman(number, \"\", false)\nend", "  roman = int_to_roman(number)\n\
    \  roman = roman.to_s.upcase.chars.map do |char|\n    char = char.downcase\n \
    \   case char\n    when \"I\", \"V\", \"X\"\n      \"V\"\n    when \"L\", \"C\"\
    \n      \"L\"\n    when \"D\", \"M\"\n      \"M\"\n    when \"M\"\n      \"M\"\
    \n    when \"I\"\n      \"M\"\n    else\n      char\n    end\n  end.join \"\"\n\
    end", "  int_to_roman(number)\n  number.to_s.gsub(/^(\\d*?)(.?)(\\d*?)\\1$/, '\\\
    1\\2\\3')\nend\nprint(int_to_mini_roman(13)) #=> \"Iii\"\nprint(int_to_mini_roman(400))\
    \ #=> \"IV\"\nprint(int_to_mini_roman(16)) #=> \"V\"\nprint(int_to_mini_roman(300))\
    \ #=> \"LVIII\"\nprint(int_to_mini_roman(500)) #=> \"MCMXCIX\"\nprint(int_to_mini_roman(550))\
    \ #=> \"MMMCMXCIX\"\nprint(int_to_mini_roman(6000)) #=> \"MMMMCMXCIX\"\nprint(int_to_mini_roman(8000))\
    \ #=> \"MMMMMMCMXCIX\"\nprint(int_to_mini_roman(9999)) #=> \"MMMMMMMMCMXCIX\"\n\
    print(int_to_mini_roman(10000)) #=> \"MMMMMMMMMMCMXCIX\"\nprint(int_to_mini_roman(10100))\
    \ #=> \"MMMMMMMMMMMMMMCMXCIX\"\nprint(int_to_mini_roman(12000)) #=> \"MMMMMMMMMMMMMMMMMMCMXCIX\"\
    \nprint(int_to_mini_roman(15000)) #=> \"MMMMMMMMMMMMMMMMMMMMMMCMXCIX\"\nprint(int_to_mini_roman(20000))\
    \ #=> \"MMMMMMMMMMMMMMMMMMMMMMMMMMCMXCIX\"\nprint(int_to_mini_roman(20000)) #=>\
    \ \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMCMXCIX\"\nprint(int_to_mini_roman(21000)) #=>\
    \ \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMCMXCIX\"\nprint(int_to_mini_roman(80000))\
    \ #=> \"IIIIIIIIIIIIIIIIIIIIIIIII\"\nprint(int_to_mini_roman(90000)) #=> \"V\"\
    \nprint(int_to_mini_roman(9)) #=> \"V\"\nprint(int_to_mini_roman(11)) #=> \"X\"\
    \nprint(int_to_mini_roman(12)) #=> \"C\"\nprint(int_to_mini_roman(3599)) #=> \"\
    MMMCMXCIX\"\nprint(int_to_mini_roman(36)) #=> \"MMCMXCIX\"\nprint(int_to_mini_roman(910))\
    \ #=> \"MMMCM", "  roman_num = ''\n  while number > 0\n    digit, number = number\
    \ / 10, number % 10\n    roman_num << digit\n  end\n  return roman_num.downcase.to_s\n\
    end", "  int_num = str(number)\n  int_num_array = int_num.split('')\n  roman_numeral\
    \ = ''\n  int_num_array.reverse!\n  for i in int_num_array\n    if i.to_s.include?\
    \ 'M'\n      roman_numeral += 'MM'\n    elsif i.to_s.include? 'CM'\n      roman_numeral\
    \ += 'CMC'\n    elsif i.to_s.include? 'D'\n      roman_numeral += 'CD'\n    elsif\
    \ i.to_s.include? 'CD'\n      roman_numeral += 'D'\n    elsif i.to_s.include?\
    \ 'C'\n      roman_numeral += 'CC'\n    elsif i.to_s.include? 'XC'\n      roman_numeral\
    \ += 'CX'\n    elsif i.to_s.include? 'L'\n      roman_numeral += 'L'\n    elsif\
    \ i.to_s.include? 'XL'\n      roman_numeral += 'XC'\n    elsif i.to_s.include?\
    \ 'X'\n      roman_numeral += 'X'\n    elsif i.to_s.include? 'I'\n      roman_numeral\
    \ += 'I'\n    elsif i.to_s.include? 'V'\n      roman_numeral += 'V'\n    elsif\
    \ i.to_s.include? 'IV'\n      roman_numeral += 'I'\n      roman_numeral += 'V'\n\
    \    elsif i.to_s.include? 'I'\n      roman_numeral += 'I'\n    elsif i.to_s.include?\
    \ 'V'\n      roman_numeral += 'V'\n    elsif i.to_s.include? 'V'\n      roman_numeral\
    \ += 'V'\n    else\n      roman_numeral += i.to_s\n    end\n  end\n  roman_numeral.downcase!\n\
    \  roman_numeral.gsub!(/\\+/, '-')\n  return roman_numeral\nend", "  if number\
    \ < 0\n    return \"#no such value\"\n  end", "  roman_num = Array.new\n  roman_num\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  roman_num.each_with_index\
    \ do |x, i|\n    if (number >= i).and((number < roman_num[i+1]))\n      roman_num[i+1]\
    \ = roman_num[i]\n      roman_num[i] = x\n    end\n  end\n  roman_num.join ''\n\
    end", "  roman_array = [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\"\
    ]\n  roman_digits = roman_array\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n  roman_digits.delete(' ')\n  roman_digits.delete('\
    \ ')\n  roman_digits.delete(' ')\n", "  roman = \"\"\n  while number > 0\n   \
    \ roman = (roman.to_i + roman.to_s + roman.to_f + roman.to_e)\n    number -= 100\n\
    \  end\n  roman.downcase!\n  roman\nend", "  rom = ''\n  while number > 0\n  \
    \  rom = (number % 10) + rom\n    number /= 10\n  end\n  rom.upcase\nend", " \
    \ roman = \"\"\n  roman_digits = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\"\
    , \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\n  roman = roman_digits[number\
    \ - 1]\n  if number > 2\n    roman += \"C\"\n    number -= 2\n  while number >\
    \ 0\n    roman += roman_digits[number % 10]\n    number /= 10\n  end\n  roman.downcase!\n\
    \  return roman\nend", "    roman = Array.new\n    roman = roman.push 'M'\n  \
    \  roman.push 'D'\n    roman.push 'C'\n    roman.push 'L'\n    roman.push 'X'\n\
    \    roman.push 'V'\n    roman.push 'I'", "  romanized = \"\"\n  roman_rev = {0\
    \ => \"I\", 1 => \"II\", 2 => \"III\", 3 => \"IV\", 4 => \"V\", 5 => \"VI\", 6\
    \ => \"VII\", 7 => \"VIII\", 8 => \"IX\", 9 => \"X\"}", "  nums = []\n  while\
    \ number > 0  \n    numeral, num = int_to_roman(number)\n    puts numeral\n  \
    \  number -= num\n  end\nend", "  roman_str = nil\n  \n  case number\n    when\
    \ 1..3\n      roman_str = \"I\"\n    when 4..5\n      roman_str = \"V\"\n    when\
    \ 6..9\n      roman_str = \"X\"\n    else\n      roman_str = \"M\"\n  end\n  \n\
    \  roman_str.downcase\nend\n</pre>\n          </td>\n        </tr>\n        <tr>\n\
    \          <td class=\"normal\" align=\"center\" valign=\"middle\" style=\"border:1px\
    \ solid black;padding:5px 30px 5px 10px;\">\n            <b>Solution</b>\n   \
    \       </td>\n          <td class=\"normal\" align=\"center\" valign=\"middle\"\
    \ style=\"border:1px solid black;padding:5px 30px 5px 10px;\">\n            <pre\
    \ class=\"solution\">", "  roms = []\n  roman_numerals = ['I', 'II', 'III', 'IV',\
    \ 'V', 'VI']\n  while number > 0\n    roms.push(roman_numerals[number % 10].reverse)\n\
    \    number = (number - number % 10) / 10\n  end\n  roms.join('')\nend", "  romans\
    \ = [\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"\
    , \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"]\n  roman_numeral = \"\"\n  i = 0\n\
    \  while i < number - 1\n    roman_numeral += romans[(i * 10) + 1]\n    i += 1\n\
    \  end\n  return roman_numeral\nend", "  roman = ''\n  roman_nums = { 'M'=> 1000,\
    \ 'D' => 500, 'C' => 100, 'L' => 50, 'X' => 10, 'V' => 5,\n                 'I'\
    \ => 1, 'M' => 10, 'D' => 50, 'C' => 100, 'L' => 50,\n                 'X' =>\
    \ 10, 'V' => 5, 'I' => 1, 'M' => 10 }\n  while number > 0\n    roman_num, number\
    \ = number % 1000, number / 1000\n    roman += roman_nums[roman_num.to_s]\n  end\n\
    \  roman\nend\nputs int_to_mini_roman(13) // => VII\nputs int_to_mini_roman(20)\
    \ // => XLIX\nputs int_to_mini_roman(2739) // => MMXLIX\nputs int_to_mini_roman(987654321)\
    \ // => MMMCMXCIX\nputs int_to_mini_roman(1234567890) // => MMCCCLXXXVII\nputs\
    \ int_to_mini_roman(987654321) // => MMMCMXCIX\nputs int_to_mini_roman(1234567890)\
    \ // => MMCCCLXXXVII\nputs int_to_mini_roman(0) // => MM\nputs int_to_mini_roman(-1)\
    \ // => MM\nputs int_to_mini_roman(-10) // => MM\nputs int_to_mini_roman(-100)\
    \ // => MM\nputs int_to_mini_roman(-1234567890) // => MMCCCLXXXVII\nputs int_to_mini_roman(-1234567890123)\
    \ // => MMCCCLXXXVII\nputs int_to_mini_roman(1234567890123) // => MMCCCLXXXVII\n\
    puts int_to_mini_roman(1234567890123456789) // => MMCCCLXXXVII\nputs int_to_mini_roman(1000000000000000000000000000000)\
    \ // => MMCCCLXXXVIII\nputs int_to_mini_roman(123456789012345678901234567890123456789)\
    \ // => MMCCCLXXXVIII\nputs int_to_mini_roman(123456789012345678901234567890123456789)\
    \ // => MMCCCLXXXVIII\nputs int_to_mini_roman(123456789012345678901234567890123456789)\
    \ // => MMCCCLXXXVIII\nputs int_to_mini_roman(123456789012345678901234567890123456789)\
    \ // => MMCCCLXXXVIII\nputs int_to_mini_roman(123456789012345678901234567890123456789)\
    \ // => MMCCCLXXXVIII\nputs int_", "  if number.nil?\n    \"NONE\"\n  elsif number\
    \ == 0\n    \"I\"\n  else\n    romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\",\
    \ \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n    roman = \"\"\
    \n    (number / 100).times do |i|\n      roman << romans[i+1]\n    end\n    roman\
    \ << romans[number%100]\n    roman.downcase!\n  end\nend\n</pre>", "  roman_to_int\
    \ = { \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\"\
    : 1000 }\n  int_to_roman = lambda i: roman_to_int[roman_to_int[i.to_s]]\n  roman_number\
    \ = int_to_roman(number)\n  roman_number[roman_number.length-1] = roman_number[roman_number.length-1].to_s.upcase\
    \ if roman_number.length < 10 else roman_number[roman_number.length-1].to_s\n\
    \  roman_number[0..0] = \"I\"\n  return roman_number\nend", "  if number == 1\n\
    \    return \"I\"\n  elsif number == 5\n    return \"V\"\n  elsif number == 10\n\
    \    return \"X\"\n  elsif number == 50\n    return \"L\"\n  elsif number == 100\n\
    \    return \"C\"\n  elsif number == 500\n    return \"D\"\n  elsif number ==\
    \ 1000\n    return \"M\"\n  else\n    return nil\n  end\nend\n</cell>\n<cell>",
  "    # Write your code here\n    if number < 1\n      return nil\n    elsif number\
    \ == 1\n      return 'I'\n    elsif number < 4\n      return \"IV\"\n    elsif\
    \ number == 4\n      return 'V'\n    elsif number < 9\n      return \"IX\"\n \
    \   elsif number == 9\n      return 'X'\n    elsif number < 16\n      return \"\
    XL\"\n    elsif number == 16\n      return 'L'\n    elsif number < 25\n      return\
    \ \"XC\"\n    elsif number == 25\n      return 'C'\n    elsif number < 36\n  \
    \    return \"CD\"\n    elsif number == 36\n      return 'D'\n    elsif number\
    \ < 49\n      return \"CM\"\n    elsif number == 49\n      return 'M'\n    elsif\
    \ number < 64\n      return \"M\"\n    elsif number == 64\n      return 'M'\n\
    \    elsif number == 100\n      return 'M'\n    else\n      return nil\n    end\n\
    end", "  roman = Array.new(1000, \"\")\n  roman[1000] = \"M\"\n  roman[10] = \"\
    CM\"\n  roman[100] = \"D\"\n  roman[1000] = \"C\"\n  roman[10] = \"XC\"\n  roman[900]\
    \ = \"L\"\n  roman[9000] = \"XL\"\n  roman[900] = \"X\"\n  roman[800] = \"IX\"\
    \n  roman[8000] = \"V\"\n  roman[8000] = \"IV\"\n  roman[7000] = \"I\"\n  if number\
    \ == 0\n    \"0\"\n  elsif number < 0\n    \"-\" + int_to_mini_roman(-number)\n\
    \  elsif number > 999\n    int_to_mini_roman(number % 1000)\n  else\n    roman[number].downcase\n\
    \  end\nend", "  result = ''", "    # Your code here\n    roman = \"V\"\n    mini_roman\
    \ = \"\"\n    while number >= 1000:\n        roman, number = roman, number / 1000\n\
    \    mini_roman += roman\n    return mini_roman", "  roman_numbers = %w[IX IV\
    \ IX X IX]\n  roman_value = roman_numbers[(number.to_s.length - 1).divmod(10)[0]]\n\
    \  roman_digits = roman_number.split(//).map { |d| d.to_i }\n  result = \"\"\n\
    \  roman_digits.each { |digit| result << roman_value*digit }\n  return result.downcase\n\
    end", "  # TODO: Implement this function\nend\n</pre>\n            </div>\n  \
    \        </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"tab-pane\"\
    \ id=\"panes_source\">\n      <div id=\"source-tab\" class=\"tab-pane active\"\
    >\n        <div class=\"row\">\n          <div class=\"col-md-12\">\n        \
    \    <div class=\"doc-source\">\n              <ul class=\"nav nav-tabs\">\n \
    \               <li class=\"nav-item\">\n                  <a class=\"nav-link\
    \ active\" onclick=\"toggleSource('source-tab', this, '/ruby-style-guide.html')\"\
    \ id=\"source-tab-button\" data-toggle=\"tab\" href=\"#source-tab-button\">Show\
    \ Source</a>\n                </li>\n              </ul>\n              <pre class=\"\
    prettyprint language-html\" id=\"sourceCode\" role=\"text\">\n<style data-target=\"\
    print-only\" media=\"print\">\n.line-numbers .line-numbers-rows {\n  -webkit-user-select:\
    \ none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n        \
    \  user-select: none;\n}\n.line-numbers-rows > span {\n  pointer-events: none;\n\
    }\n.line-numbers-rows > span:before {\n  content: attr(data-line-number);\n  pointer-events:\
    \ all;\n  cursor: default;\n  display: block;\n  position: absolute;\n  top: 0;\n\
    \  left: 0;\n  right: 0;\n  bottom: 0;\n  color: #999999;\n}\n</style>\n<style>",
  "  if number == 0\n    \"I\"\n  elsif number == 1\n    \"IV\"\n  elsif number ==\
    \ 2\n    \"V\"\n  elsif number == 3\n    \"VI\"\n  elsif number == 4\n    \"VII\"\
    \n  elsif number == 5\n    \"VIII\"\n  elsif number == 6\n    \"IX\"\n  elsif\
    \ number == 7\n    \"IX\"\n  elsif number == 8\n    \"X\"\n  elsif number == 9\n\
    \    \"XI\"\n  elsif number == 10\n    \"XII\"\n  elsif number == 11\n    \"XIII\"\
    \n  elsif number == 12\n    \"X\"\n  elsif number == 13\n    \"XI\"\n  elsif number\
    \ == 14\n    \"XII\"\n  elsif number == 15\n    \"XIII\"\n  elsif number == 16\n\
    \    \"XIV\"\n  elsif number == 17\n    \"XV\"\n  elsif number == 18\n    \"XVI\"\
    \n  elsif number == 19\n    \"XVII\"\n  elsif number == 20\n    \"XVIII\"\n  elsif\
    \ number == 21\n    \"XIX\"\n  elsif number == 22\n    \"XX\"\n  elsif number\
    \ == 23\n    \"XXI\"\n  elsif number == 24\n    \"XXII\"\n  elsif number == 25\n\
    \    \"XXIII\"\n  elsif number == 26\n    \"XXIV\"\n  elsif number == 27\n   \
    \ \"XXV\"\n  elsif number == 28\n    \"XXVI\"\n  elsif number == 29\n    \"XXVII\"\
    \n  elsif number == 30\n    \"XXVIII\"\n  elsif number == 31\n    \"XXIX\"\n \
    \ elsif number == 32\n    \"XXX\"\n  elsif number == 33\n    \"XXXI\"\n  elsif\
    \ number == 34\n    \"XXXII\"\n  elsif number == 35\n    \"XXXIII\"\n  elsif number\
    \ == 36\n    \"XXXIV\"\n  elsif number == 37\n    \"XXXV\"\n  elsif number ==\
    \ 38\n    \"XXXVI\"\n  elsif number ", "  romans = []\n  roman_num = number\n\
    \  while roman_num > 0\n    roman_num, roman = roman_num / 10, romans[romans.index(roman)].to_s.rjust(2,\
    \ '0')\n    romans[romans.index(roman)] = roman\n  end", "  int_to_roman_map =\
    \ { \"I\" => \"v\", \"V\" => \"vi\",\n                       \"X\" => \"x\", \"\
    L\" => \"l\", \"C\" => \"c\",\n                       \"D\" => \"d\", \"M\" =>\
    \ \"m\",\n                       \"C\" => \"c\", \"L\" => \"l\", \"X\" => \"x\"\
    ,\n                       \"V\" => \"vi\", \"I\" => \"v\", \"X\" => \"x\",\n \
    \                      \"L\" => \"l\", \"M\" => \"m\", \"D\" => \"d\" }", "  roman_numerals\
    \ = []\n  roman_numerals << number % 100\n  number -= roman_numerals.last\n  roman_numerals\
    \ << number % 10\n  number -= roman_numerals.last\n  roman_numerals << number\n\
    \  return roman_numerals.map {|n| int_to_roman_numeral(n) }.join('')\nend", " \
    \ # Only change code below this line\n  output = []\n  roman_values = { 'I': 1,\
    \ 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 }", "  romans = [\"\
    i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\
    , \"xi\",\n           \"xii\", \"xiii\", \"xiv\", \"xv\", \"xvi\", \"xvii\", \"\
    xviii\", \"xix\", \"xx\",\n           \"xxi\", \"xxii\", \"xxiii\", \"xxiv\",\
    \ \"xxv\", \"xxvi\", \"xxvii\", \"xxviii\",\n           \"xxix\", \"xxx\", \"\
    xxxx\"]", "  roman = roman_to_int(number)\n  int_to_roman(roman)\nend", "  if\
    \ number.to_s.length <= 1\n    return \"#\" + number.to_s\n  end\n  if number\
    \ == 0\n    return \"I\"\n  end\n  roman = \"#\"\n  roman = roman.upcase + roman\n\
    \  roman_numerals = (\"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"\
    DCCC\", \"CM\")\n  roman = roman.to_s\n  current_roman = roman\n  roman = roman.chars.to_a\n\
    \  roman.each_index do |i|\n    digit = roman[i]\n    roman[i] = roman_numerals.find\
    \ { |n| n.include?(digit) }\n    if digit != \"C\"\n      roman_numerals.delete(current_roman)\n\
    \    end\n    current_roman = current_roman + roman[i]\n  end\n  roman_numerals.each_index\
    \ do |i|\n    roman[i] = roman[i].upcase\n  end\n  roman.each_index do |i|\n \
    \   roman[i] = roman[i].to_s\n  end\n  roman = roman.join\n  roman = roman[0...-1]\n\
    \  roman = roman.upcase\n  roman\nend", "  return roman # String\nend", "    #\
    \ write your code here\n    return \"\"\nend", "  result = ''\n  while number\
    \ > 0\n    result = (number % 10) + result\n    number = number / 10\n  end\n\
    \  result = result.to_s\n  return result.gsub(/[0-9]/, '').lstrip\nend", "  return\
    \ case number\n    when 1\n      roman = \"I\"\n    when 2\n      roman = \"II\"\
    \n    when 3\n      roman = \"III\"\n    when 4\n      roman = \"IV\"\n    when\
    \ 5\n      roman = \"V\"\n    when 6\n      roman = \"VI\"\n    when 7\n     \
    \ roman = \"VII\"\n    when 8\n      roman = \"VIII\"\n    when 9\n      roman\
    \ = \"IX\"\n    else\n      roman = nil\n  end\nend", "  roman = ''\n  while number\
    \ > 0\n    roman = roman.succ\n    number -= 1\n  end", "    roman_array = ['M',\
    \ 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n    roman_numeral\
    \ = int_to_roman(number)\n    return roman_numeral.downcase.gsub(/\\b(\\w)\\1(?!\\\
    1)/) { $1.upcase }\nend", "    # Your code here\n    roman = \"\"\n    while(number\
    \ >= 100 and number >= 10)\n        roman << number.to_s.gsub(/^..../, \"\\\\\
    1\").slice(-2)\n        number -= 100\n    while(number >= 10)\n        roman\
    \ << number.to_s.gsub(/^../, \"\\\\1\")\n        number -= 10\n    while(number\
    \ > 0)\n        roman << number.to_s.gsub(/^./, \"\\\\1\").slice(-2)\n       \
    \ number -= 1\n    roman\nend", "  roman_values = %w{\n    I     V     X    L\
    \     C    D }\n  roman_values.product(['M', 'D'])\n    .select { |roman | number\
    \ >= roman }\n    .max\n    .to_s\nend", "    roman = ''\n    digits = [1000,\
    \ 500, 100, 50, 10, 5, 1]", "    # Your code goes here\n    nums = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    \n    for i in nums.reverse()\n\
    \        if number >= i\n            num = number / i\n            number -= num\
    \ * i\n            return num.to_s\n        end\n    end\n    \n    false\nend",
  "  roman = Array.new\n  roman.push( nil )\n  roman.push( nil )", "  roman = Array.new\n\
    \  (1000**number).step(10**number).each { |i| roman << i }\n  roman.map { |i|\
    \ i==0 ? 'M' : [(100*i).to_s.rjust(3, '0'), 'M'].join\n  }.join(\"\").downcase\n\
    end", "  if number == 1\n    'I'\n  elsif number == 2\n    'IV'\n  elsif number\
    \ == 3\n    'VI'\n  elsif number == 4\n    'IV'\n  elsif number == 5\n    'V'\n\
    \  elsif number == 6\n    'VI'\n  elsif number == 7\n    'VII'\n  elsif number\
    \ == 8\n    'VIII'\n  elsif number == 9\n    'IX'\n  elsif number == 10\n    'X'\n\
    \  elsif number == 11\n    'XII'\n  elsif number == 12\n    'XIII'\n  elsif number\
    \ == 13\n    'XIV'\n  elsif number == 14\n    'XVI'\n  elsif number == 15\n  \
    \  'XVII'\n  elsif number == 16\n    'XVIII'\n  elsif number == 17\n    'XIX'\n\
    \  elsif number == 18\n    'XX'\n  elsif number == 19\n    'XXI'\n  elsif number\
    \ == 20\n    'XXII'\n  elsif number == 21\n    'XXIII'\n  elsif number == 22\n\
    \    'XXIV'\n  elsif number == 23\n    'XXVI'\n  elsif number == 24\n    'XXVII'\n\
    \  elsif number == 25\n    'XXVIII'\n  elsif number == 26\n    'XXIX'\n  elsif\
    \ number == 27\n    'XXX'\n  elsif number == 28\n    'XXXI'\n  elsif number ==\
    \ 29\n    'XXXII'\n  elsif number == 30\n    'XXXIII'\n  elsif number == 31\n\
    \    'XXXIV'\n  elsif number == 32\n    'XXXVI'\n  elsif number == 33\n    'XXXVII'\n\
    \  elsif number == 34\n    'XXXVIII'\n  elsif number == 35\n    'XXXIX'\n  elsif\
    \ number == 36\n    'XL'\n  elsif number == 37\n    'LX'\n  elsif number == 38\n\
    \    'LXX'\n  elsif number == 39\n    'LXXX'\n  elsif number == 40\n    'LXXXX'\n\
    \  elsif ", "  roman_numeral = \"\"\n  while number > 0\n    # Add numerals one\
    \ at a time\n    num_string = number_to_mini_roman(number)", "  roman_num = [\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\"]\n  result = []\n  while number > 0\n    result.push roman_num[(number\
    \ % 100).floor]\n    number /= 100\n  end\n  result.push roman_num[number]\n \
    \ result.join(\", \")\nend", "  roman = Array.new\n  roman.push \"M\"\n  roman.push\
    \ \"CM\"\n  roman.push \"D\"\n  roman.push \"CD\"\n  roman.push \"C\"\n  roman.push\
    \ \"XC\"\n  roman.push \"L\"\n  roman.push \"XL\"\n  roman.push \"X\"\n  roman.push\
    \ \"IX\"\n  roman.push \"V\"\n  roman.push \"IV\"\n  roman.push \"I\"\n  roman.push\
    \ \"N\"\n  roman.push \"III\"\n  roman.push \"II\"\n  roman.push \"VIII\"\n  roman.push\
    \ \"VII\"\n  roman.push \"IXII\"\n  roman.push \"XIII\"\n  roman.push \"XIV\"\n\
    \  roman.push \"XXIII\"\n  roman.push \"XXII\"\n  roman.push \"XXXII\"\n  roman.push\
    \ \"XXXIV\"\n  roman.push \"X\"\n  roman.push \"XXX\"\n  roman.push \"MVIII\"\n\
    \  roman.push \"MVII\"\n  roman.push \"MVII\"\n  roman.push \"MVI\"\n  roman.push\
    \ \"MMVIII\"\n  roman.push \"MMVII\"\n  roman.push \"MMVI\"\n  roman.push \"MMM\"\
    \n  roman.push \"MMMM\"\n  roman.push \"MMMM\"\n  roman.push \"MM\"\n  roman.push\
    \ \"MMM\"\n  roman.push \"M\"\n  roman.push \"D\"\n  roman.push \"CD\"\n  roman.push\
    \ \"C\"\n  roman.push \"XC\"\n  roman.push \"L\"\n  roman.push \"XL\"\n  roman.push\
    \ \"X\"\n  roman.push \"IX\"\n  roman.push \"V\"\n  roman.push \"IV\"\n  roman.push\
    \ \"I\"\n  roman.push \"N\"\n  roman.push \"III\"\n", "  roman_numerals = [\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\"]\n  roman_numerals_reversed = [\"M\", \"D\", \"C\", \"L\", \"\
    X\", \"V\", \"I\"]\n  roman_numerals_lookup = Hash.new\n  roman_numerals_lookup.update(\"\
    I\" => 1000)\n  roman_numerals_lookup.update(\"V\" => 900)\n  roman_numerals_lookup.update(\"\
    X\" => 500, :D => 400)\n  roman_numerals_lookup.update(\"L\" => 250)\n  roman_numerals_lookup.update(\"\
    XL\" => 100, :D => 50)\n  roman_numerals_lookup.update(\"XC\" => 50, :D => 25)\n\
    \  roman_numerals_lookup.update(\"CD\" => 20)\n  roman_numerals_lookup.update(\"\
    CM\" => 10, :D => 5)\n  roman_numerals_lookup.update(\"M\" => 1)\n  roman_numerals_lookup.update(:D\
    \ => 10)\n  roman_numerals_lookup.update(:C => 100)\n  roman_numerals_lookup.update(:X\
    \ => 500)\n  roman_numerals_lookup.update(:L => 250)\n  roman_numerals_lookup.update(:XL\
    \ => 100)\n  roman_numerals_lookup.update(:XC => 50)\n  roman_numerals_lookup.update(:CD\
    \ => 20)\n  roman_numerals_lookup.update(:CM => 10)\n  roman_numerals_lookup.update(:M\
    \ => 1)\n  roman_numerals_lookup.update(:X => 500)\n  roman_numerals_lookup.update(:L\
    \ => 250)\n  roman_numerals_lookup.update(:XL => 100)\n  roman_numerals_lookup.update(:XC\
    \ => 50)\n  roman_numerals_lookup.update(:CD => 20)\n  roman_numerals_lookup.update(:CM\
    \ => 10)\n  roman_numerals_lookup.update(:M => 1)\n  roman_numerals_lookup.update(:X\
    \ => 500)\n  roman_numerals_lookup.update(:L => 250)\n  roman_numerals_lookup.update(:XL\
    \ => 100)\n  roman_numerals_lookup.update(:", "  roman = ['', 'I', 'II', 'III',\
    \ 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'M',\
    \ 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'XL']\n  roman.map { |r| return r if\
    \ number == 0 || number == r.length.to_f}\n  roman[number - 1]\nend", "  roman\
    \ = Array.new(4)\n  roman[0] = \"M\"\n  roman[1] = \"D\"\n  roman[2] = \"C\"\n\
    \  roman[3] = \"L\"", "  roman = \"\"\n  roman_numerals = (1000).to_s.split(\"\
    \").map { |i| i_to_roman(i) }\n  while number > 9\n    number, r = div(number,\
    \ 10)\n    roman << roman_numerals[r]\n  end\n  roman << roman_numerals[number]\
    \ if number > 9\n  roman.downcase\nend", "  int_roman = nil\n  while number >\
    \ 0\n    int_roman = int_roman + \"M\" * [1,2,3,4,5,6,7,8,9,10].index(number %\
    \ 10)\n    number /= 10\n  end\n  int_roman.reverse\nend", "  roman = \"I\"\n\
    \  roman_digit = 1\n  while roman_digit <= number\n    roman = roman.concat( roman_digit\
    \ > 1 ? get_roman_number_from_number(roman_digit).upcase : get_roman_number_from_number(roman_digit).downcase\
    \ )\n    roman_digit += 1\n  roman = roman.downcase\n  roman\nend", "  roman_numeral\
    \ = \"\"\n  while number > 0\n    roman_numeral = \"#{roman_numeral}#{int_to_roman(number\
    \ % 10)}\"\n    number /= 10\n  end\n  roman_numeral.downcase\nend\nputs int_to_mini_roman(1234)",
  "  if number == 0\n    number\n  else\n    str_val = number.to_s\n    int_val =\
    \ int(str_val)\n    roman_val = []\n    roman_val.push(int_val)\n    roman_val.push(\"\
    M\")\n    roman_val.push(\"C\")\n    roman_val.push(\"D\")\n    roman_val.push(\"\
    CD\")\n    roman_val.push(\"C\")\n    roman_val.push(\"XC\")\n    roman_val.push(\"\
    L\")\n    roman_val.push(\"XL\")\n    roman_val.push(\"X\")\n    roman_val.push(\"\
    IX\")\n    roman_val.push(\"V\")\n    roman_val.push(\"IV\")\n    roman_val.push(\"\
    I\")\n    roman_val.reverse!\n    roman_val.each{ |val| roman_val.pop }\n    roman_val.push(\"\
    I\")\n    roman_val.each{ |val| roman_val.pop }\n    roman_val.push(int_val %\
    \ 100)\n    roman_val.push(int_val % 10)\n    roman_val.reverse!\n    roman_val.each{\
    \ |val| roman_val.pop }\n    roman_val.push(\"I\")\n    roman_val.join\n  end\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,rubygems |>\n<| c |>\nWhile this link\
    \ may answer the question, it is better to include the essential parts of the\
    \ answer here and provide the link for reference.  Link-only answers can become\
    \ invalid if the linked page changes. - [From Review](/review/low-quality-posts/14994852)\n\
    <|/ c |>\n<| c |>\nThanks. I fixed my answer.\n<|/ c |>\n<| c |>\nThis answer\
    \ is a copy of an existing answer on [Ruby Online](https://stackoverflow.com/a/14994850/471380).\
    \ Would you consider deleting your answer?\n<|/ c |>\n<| c |>\nThank you for the\
    \ comment. I updated the answer according to your suggestion.\n<|/ c |>\n<| a\
    \ |>\nI have recently been playing around with this, and decided that I was doing\
    \ too much. Here is my solution:\n<code>", "  roman_numerals = []\n  roman_numerals\
    \ << \"\" if number < 1 || number > 1000\n  (number-1).downto(0) do |i|\n    numeral\
    \ = case i\n      when 1 then \"I\"\n      when 2 then \"II\"\n      when 3 then\
    \ \"III\"\n      when 4 then \"IV\"\n      when 5 then \"V\"\n      when 6 then\
    \ \"VI\"\n      when 7 then \"VII\"\n      when 8 then \"VIII\"\n      when 9\
    \ then \"IX\"\n      else \"\"\n    end\n    roman_numerals << numeral\n  end\n\
    \  return roman_numerals.join(\",\")\nend", '  roman_numerals = []', "  roman\
    \ = \"\"\n  i = 1\n  while number >= i * 10\n    roman += num.to_s[(i*10):].to_s\n\
    \    i += 1\n  end #end while\n  roman[0...(roman.length - 1)] = num.to_s[0...(roman.length\
    \ - 1)]\n  roman\nend #end function", "  if number < 0 \n    puts \"Invalid input\"\
    \n    return nil\n  end\n  roman = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\"\
    , \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n  roman_number = roman.map\
    \ {|a| a[number % 10]}.join\n  puts \"#{roman_number}\" \nend", "  roman = 0\n\
    \  while number > 0\n    case number\n    when 0..9\n      roman += string_to_number(to_string(number))\n\
    \      number -= 1\n    when 10..19\n      roman += string_to_number(to_string(number\
    \ / 10)) * 10\n      number %= 10\n    when 20..99\n      roman += string_to_number(to_string(number\
    \ / 100)) +\n        string_to_number(to_string(number / 10)) * 100\n      number\
    \ %= 100\n    when 100..999\n      roman += string_to_number(to_string(number\
    \ / 1000))\n      number %= 1000\n    when 1000..9999\n      roman += string_to_number(to_string(number\
    \ / 10000))\n      number %= 10000\n    when 10000..99999\n      roman += string_to_number(to_string(number\
    \ / 100000))\n      number %= 100000\n    when 1000000..999999\n      roman +=\
    \ string_to_number(to_string(number / 1000000))\n      number %= 1000000\n   \
    \ when 10000000..999999999\n      roman += string_to_number(to_string(number /\
    \ 10000000))\n      number %= 10000000\n    when 1000000000..9999999999\n    \
    \  roman += string_to_number(to_string(number / 100000000))\n      number %= 100000000\n\
    \    when 1000000000000..999999999999\n      roman += string_to_number(to_string(number\
    \ / 1000000000))\n      number %= 1000000000\n    else\n      raise \"No roman\
    \ representation for #{number}\"\n    end\n  end\n  return roman.to_s.downcase\n\
    end", "  roman = nil\n  roman = int_to_roman_roman_numeral(number)\n  roman =\
    \ roman.downcase\n  roman\nend", "    # Write your code here.\n    return int_to_roman(number)\n\
    end", "  if number.to_s.length <= 1\n    \"0\"\n  else\n    int_to_mini_roman_helper(number)\n\
    \  end\nend", "  result = ''\n  i = 0\n  while number >= 10\n    result += (number\
    \ % 10).to_s + ' '\n    number = number / 10\n    i += 1\n  result += (number.to_s).to_s\
    \ + ' '\n  result.strip!\n  result.downcase!\n  result\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThe OP wants roman numerals, not integers, this doesn't work with\
    \ integers. Also, your algorithm has O(n\xB2) complexity, the OP wants O(n).\n\
    <|/ c |>\n<| c |>\n- I see you wrote the algorithm in C#. My point was that I\
    \ was using the same algorithm as shown in the other answer and was just translating\
    \ it to Ruby rather than re-writing the algorithm from the scratch.\n<|/ c |>\n\
    <| c |>\nI didn't write it or post it, I got it from the other answer. As far\
    \ as complexity goes, I believe that his code runs in O(n\xB2) as it does division\
    \ and modulo for each number, but each iteration does O(1) math, so it's O(n\xB2\
    ). However, my code does O(n) math and it's O(n\xB2).\n<|/ c |>\n<| a |>\nHere's\
    \ my solution that uses no loops, recursion or anything that would use less memory\
    \ than a loop. It converts numbers from 0 to n to their respective roman numerals\
    \ in a single line.\n<code>", "  romans = %w(i v x l c d m l o n x)\n  roman =\
    \ romans[number]\n  result = roman.tr('ivxlcdmlo', 'ivxcmlo')\n  result.downcase\n\
    end\n</pre>\n</li>", "  roman = []\n  last_num = ''\n  \n  loop do\n    if number\
    \ == 0\n      break\n    \n    roman = [last_num.to_s.ljust(7, '0'), roman.to_s].join\n\
    \    \n    # Add one and reduce number\n    last_num = (number % 100).to_s\n \
    \   number /= 100\n  end\n  \n  roman\nend", "  roman = Array.new\n  roman.push\
    \ (0)\n  roman.push ('I')\n  roman.push ('V')\n  roman.push ('X')\n  roman.push\
    \ ('L')\n  roman.push ('C')\n  roman.push ('D')\n  roman.push ('M')\n  roman.push\
    \ ('C')\n  roman.push ('M')\n  roman.push ('C')\n  roman.push ('D')\n  roman.push\
    \ ('C')\n  roman.push ('L')\n  roman.push ('M')\n  roman.push ('M')\n  roman.push\
    \ ('D')\n  roman.push ('C')\n  roman.push ('V')\n  roman.push ('M')\n  roman.push\
    \ ('D')\n  roman.push ('L')\n  roman.push ('D')\n  roman.push ('C')\n  roman.push\
    \ ('V')\n  roman.push ('M')\n  roman.push ('L')\n  roman.push ('M')\n  roman.push\
    \ ('C')\n  roman.push ('D')\n  roman.push ('C')\n  roman.push ('V')\n  roman.push\
    \ ('M')\n  roman.push ('M')\n  roman.push ('D')\n  roman.push ('M')\n  roman.push\
    \ ('L')\n  roman.push ('M')\n  roman.push ('C')\n  roman.push ('D')\n  roman.push\
    \ ('C')\n  roman.push ('V')\n  roman.push ('M')\n  roman.push ('M')\n  roman.push\
    \ ('D')\n  roman.push ('C')\n  roman.push ('L')\n  roman.push ('M')\n  roman.push\
    \ ('C')\n  roman.push ('M')\n  roman.push ('C')\n  roman.push ('L')\n  roman.push\
    \ ('D')\n  roman.push ('C')\n  roman.push ('V')\n  roman.push ('M')\n  ro", " \
    \ if number == 1\n    'I'\n  elsif number == 2\n    'II'\n  elsif number == 3\n\
    \    'III'\n  elsif number == 4\n    'IV'\n  elsif number == 5\n    'V'\n  elsif\
    \ number == 6\n    'VI'\n  elsif number == 7\n    'VII'\n  elsif number == 8\n\
    \    'VIII'\n  elsif number == 9\n    'IX'\n  else\n    'X'\n  end\nend", "  roman_numerals\
    \ = %w[I II III IV V VI VII VIII IX X XI]\n  roman_numerals.map! { |n| n.to_s\
    \ } unless roman_numerals.is_a?(String)\n  roman_numerals.map { |n| n.gsub(/\\\
    d/, '#') }.\n    map { |n| n.gsub(/\\D/, '') }.\n    map { |n| n.to_i }.\n   \
    \ each_with_index.\n    map{ |n, i| n.to_s(i).ljust(3, '0') }.\n    join.\n  \
    \  each_char.\n    to_a.\n    map { |c| roman_numerals[c] }", "  roman_numerals\
    \ = []\n  roman_nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n\
    \  index = 0\n  roman_numerals[number] = ''\n  while roman_numerals.length <=\
    \ number\n    if roman_nums[index] >= number\n      roman_numerals << roman_nums[index]\
    \ unless index == roman_nums.length - 1\n      roman_nums[index] += 1\n    else\n\
    \      index += 1\n      roman_numerals << roman_nums[index]\n    end\n  end\n\
    \  return roman_numerals.join(\"\")\nend", "  roman_table = {}\n  roman_table[0]\
    \ = \"\"\n  roman_table[1] = \"I\"\n  roman_table[2] = \"II\"\n  roman_table[3]\
    \ = \"III\"\n  roman_table[4] = \"IV\"\n  roman_table[5] = \"V\"\n  roman_table[6]\
    \ = \"VI\"\n  roman_table[7] = \"VII\"\n  roman_table[8] = \"VIII\"\n  roman_table[9]\
    \ = \"IX\"\n  roman_table[10] = \"X\"\n  roman_table[11] = \"XI\"\n  roman_table[12]\
    \ = \"XII\"\n  roman_table[13] = \"XIII\"\n  roman_table[14] = \"XIV\"\n  roman_table[15]\
    \ = \"XV\"\n  roman_table[16] = \"XVI\"\n  roman_table[17] = \"XVII\"\n  roman_table[18]\
    \ = \"XVIII\"\n  roman_table[19] = \"XIX\"\n  roman_table[20] = \"XX\"\n  roman_table[21]\
    \ = \"XXI\"\n  roman_table[22] = \"XXII\"\n  roman_table[23] = \"XXIII\"\n  roman_table[24]\
    \ = \"XXIV\"\n  roman_table[25] = \"XXV\"\n  roman_table[26] = \"XXVI\"\n  roman_table[27]\
    \ = \"XXVII\"\n  roman_table[28] = \"XXVIII\"\n  roman_table[29] = \"XXIX\"\n\
    \  roman_table[30] = \"XXX\"\n  roman_table[31] = \"XXXI\"\n  roman_table[32]\
    \ = \"XXXII\"\n  roman_table[33] = \"XXXIII\"\n  roman_table[34] = \"XXXIV\"\n\
    \  roman_table[35] = \"XXXV\"\n  roman_table[36] = \"XXXVI\"\n  roman_table[37]\
    \ = \"XXXVII\"\n  roman_table[38] = \"XXXVIII\"\n  roman_table[39] = \"XXXIX\"\
    \n  roman_table[40] = \"XL\"\n  roman_table[41] = \"L\"\n  roman_table[42] = \"\
    LX\"\n  roman_table[43] = \"LXX\"\n  roman_table[44] = \"LXXX\"\n  roman_table[45]\
    \ = \"LXXXX\"\n  roman_table[46] = \"LXXXXX\"\n  roman_table[47] = \"LXXXII\"\n\
    \  roman_table[48] = \"LXXXIII\"\n  roman_table[49", "  roman = ''\n  roman_nums\
    \ = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV')\n  roman_nums\
    \ = roman_nums.zip(roman_nums.rotate!).to_a", "    ints = Array.new(number)\n\
    \    ints.map! { |i| i.to_s.roman.to_i  }\n    ints.uniq!\n    ints.sort_by! \
    \ { |i| -i }\n    ints.map! { |i| i.to_s.roman.to_i }\n    ints.uniq!\n    ints.join\n\
    end", "  if number <= 0 || number > 1000\n    throw :invalid_argument, sprintf(\"\
    %g\", number)\n  end\n  roman = \"I\"\n  for i in 2..number\n    roman << i\n\
    \  end\n  return roman.downcase\nend", "  result = ''\n  roman_numerals = [\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\"]\n  counter = 0\n  while counter < number\n    roman_numeral\
    \ = roman_numerals[counter % 10]\n    result += roman_numeral\n    counter +=\
    \ 1\n  end\n  result\nend", "  roman_numerals = []\n  while number > 0\n    case\
    \ number\n    when 0..9\n      roman_numerals.push int_to_roman_numeral(number)\n\
    \    when 10..24\n      roman_numerals.push \"C\"\n    when 25..44\n      roman_numerals.push\
    \ \"CC\"\n    when 45..69\n      roman_numerals.push \"CCC\"\n    when 70..99\n\
    \      roman_numerals.push \"DCC\"\n    when 100..999\n      roman_numerals.push\
    \ \"CCCC\"\n    end\n    number -= 10\n  end\n  roman_numerals.reverse.join\n\
    end", "  # Complete the code here.\n  roman = Array.new\n  roman[0] = nil\n  roman[1]\
    \ = nil\n  roman[2] = \"M\"\n  roman[3] = nil\n  roman[4] = \"D\"\n  roman[5]\
    \ = \"C\"\n  roman[6] = \"L\"\n  roman[7] = \"X\"\n  roman[8] = \"V\"\n  roman[9]\
    \ = \"I\"", "    roman = \"\"\n    int_to_roman(number, roman)\n    roman = roman.downcase\n\
    \    return roman\nend", "  if number.zero?\n    return \"\"\n  roman = roman_numerals(number)\n\
    \  roman.delete_if{ |item| item.blank? }\n  roman.delete_if{ |item| item == \"\
    i\"}\n  return roman.join.to_s\nend", "  # Write your code here.\nend", "    romans\
    \ = {\n        1 => 'I',\n        2 => 'II',\n        3 => 'III',\n        4 =>\
    \ 'IV',\n        5 => 'V',\n        6 => 'VI',\n        7 => 'VII',\n        8\
    \ => 'VIII',\n        9 => 'IX'\n    }\n    roman = ''\n    (num).times { roman\
    \ << romans[number] }\n    roman = roman.downcase\n    roman\nend", "  roman =\
    \ ''\n  i = 2\n  while i <= number\n    roman = roman + ((number % i).to_s.romanize.to_s.upcase)\n\
    \    i += 1\n  end\n  roman\nend", "  roman_array = num_to_roman_array(number)\n\
    \  roman_array.join('').to_s.downcase\nend", '  roman = ""', "  if number == 0\
    \ || number == 1\n    return ''\n  roman = int_to_mini_roman(number / 100) * 100\
    \ + number % 100\n  roman = roman + int_to_mini_roman(number % 100)\n  return\
    \ roman\nend", "  # Write your solution here\n  roman = \"IV\"\n  number_to_roman\
    \ = String.new(number)\n  if number_to_roman.length >= 1\n    number_to_roman.each_char\
    \ do |c|\n      roman << c\n      if c == number_to_roman[0]\n        roman =\
    \ roman.slice!(0, roman.length)\n        break\n      end\n    end\n  end\n  roman\n\
    end", "  romans = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\"\
    , \"X\", \"IX\", \"V\", \"IV\", \"I\" ]\n  int_to_roman = lambda num : romans[\
    \ (num - 1) // 100] + romans[ (num - 1) % 100 ]\n  int_to_roman(number)\nend",
  "  if number < 1\n    \"invalid\"\n  elsif number <= 100\n    roman = roman_to_int(roman_to_arabic(number))\n\
    \  else\n    roman = int_to_mini_roman(number / 100) + roman_to_int(roman_to_arabic(number\
    \ % 100))\n  end\n  return roman\nend", "  if number == 0 then return '0'\n  roman\
    \ = int_to_mini_roman(number / 10)\n  remainder = number % 10\n  return roman\
    \ + remainder * \"M\"\nend", "  rom = (number/1000).roman.to_s\n  rom += ((number\
    \ % 1000) / 100).roman.to_s\n  rom += ((number % 100) / 10).roman.to_s\n  rom\
    \ += ((number % 10) / 1).roman.to_s\n  rom.upcase\nend", "  roman = []\n  roman_num\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  i = number\n  while\
    \ i > 0 do\n    roman[i] = roman_num.shift\n    i -= 1\n  end\n  return roman.join.to_s\n\
    end", "    romanArray = Array.new(12) { |i| 0 }\n    romanArray[5] = 1 if (number\
    \ >= 5)\n    romanArray[10] = 1 if (number >= 10)\n    romanArray[100] = 1 if\
    \ (number >= 100)\n    romanArray[500] = 1 if (number >= 500)\n    romanArray[1000]\
    \ = 2\n    romanArray[5000] = 3\n    romanArray[10000] = 4\n    romanArray[100000]\
    \ = 5", "  roman = []\n  i = number", "  return roman_to_integral(int_to_roman(number))\n\
    end", "  # Write your code here.\n  roman_values = [1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1]\n  return roman_values[number]\nend\n</pre>\n</div>\n\
    </div>", "  romans = []\n  romans.concat([nil, \"\"])\n  romans.concat([\"\",\
    \ nil])\n  romans.concat([nil, nil])", "  # Write your code here.\nend\n</cell>\n\
    <code language=julia-0.5>", "  roman = \"\"\n  remainder = number\n  while remainder\
    \ > 0\n    remainder -= 10\n    roman += \"M\"\n  end", "  if number < 1\n   \
    \ return \"invalid roman\"\n  end\n  roman_numerals = %w{i ii iii iv v vi vii\
    \ viii ix x xi xii}\n  roman_numerals.each do |roman_numeral|\n    roman_numeral_as_string\
    \ = roman_numeral.to_s\n    roman_numeral_as_string[0] = roman_numeral_as_string[0].upcase\
    \ if roman_numeral_as_string[0] == \"I\"\n    roman_numeral_as_string.slice(1,\
    \ roman_numeral_as_string.length) = roman_numeral.to_s\n    roman_numeral_as_string.slice!\
    \ \"i\"\n    roman_numeral_as_string.slice! \"v\"\n    roman_numeral_as_string.slice!\
    \ \"x\"\n    roman_numeral_as_string.slice! \"vi\"\n    roman_numeral_as_string.slice!\
    \ \"i\"\n    roman_numeral_as_string.slice! \"xi\"\n    roman_numeral_as_string.slice!\
    \ \"i\"\n    roman_numeral_as_string.slice! \"vii\"\n    roman_numeral_as_string.slice!\
    \ \"ii\"\n    roman_numeral_as_string.slice! \"iii\"\n    roman_numeral_as_string.slice!\
    \ \"iv\"\n    roman_numeral_as_string.slice! \"v\"\n    roman_numeral_as_string.slice!\
    \ \"vii\"\n    roman_numeral_as_string.slice! \"vi\"\n    roman_numeral_as_string.slice!\
    \ \"vii\"\n    roman_numeral_as_string.slice! \"i\"\n    roman_numeral_as_string.slice!\
    \ \"x\"\n    roman_numeral_as_string.slice! \"vii\"\n    roman_numeral_as_string.slice!\
    \ \"vii\"\n    roman_numeral_as_string.slice! \"ii\"\n    roman_numeral_as_string.slice!\
    \ \"iii\"\n    roman_numeral_as_string.slice! \"ii\"\n    roman_numeral_as_string.slice!\
    \ \"iii\"\n    roman_numeral_as_string.slice! \"ii\"\n    roman_numeral_as_string.slice!\
    \ \"iv\"\n    roman_numeral_as_string.slice! \"vii\"\n    roman_numeral_as_string.slice!\
    \ \"vi\"\n    roman_numeral_as_string.slice! \"vii\"\n    roman_numeral_as_string.slice!\
    \ \"vi\"", "  # Your code here\n  roman = \"\"\n  i = 1\n  while i < number\n\
    \    roman = roman << i\n    i += 1\n  end\n  roman = roman.sub(/(.{3})/, '\\\
    1').downcase \n  return roman\nend", "  romans = Array.new(ROMAN_ALPHABET.length,\
    \ 0)\n  romans.map!{|char| ROMAN_ALPHABET[char]} # convert char to index then\
    \ to string\n  romans.map!{|char| char == 0 ? '' : char.to_s} # convert char to\
    \ string", "  result = ''\n  numerals = ['', 'I', 'II', 'III', 'IV', 'V', 'VI',\
    \ 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVIII']\n\
    \  numerals.each { |x| result += x[number%x.size].upcase }\n  result = result.squeeze\n\
    \  while result.size < 3\n    result = \"#{result}I\"\n  end\n  result[0...-1]\n\
    end\n</code>\nThen to test it:\n<code>\nint_to_mini_roman(123)\n=> \"III\"\nint_to_mini_roman(900)\n\
    => \"IV\"\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3,regex |>\n<|\
    \ c |>\nWon't work. `'111'` will return `\"I\"`.\n<|/ c |>\n<| c |>\n: Yeah, you're\
    \ right. I was thinking that was a typo. Thanks for catching it.\n<|/ c |>\n<|\
    \ c |>\nAm I missing something? Can you explain what this does?\n<|/ c |>\n<|\
    \ c |>\n: It gives you a string, containing only the roman numerals for any given\
    \ integer.\n<|/ c |>\n<| c |>\nI think you need to add a `.downcase` to the end,\
    \ or `int_to_mini_roman(321)` will give `\"III\"`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,regex\
    \ dscore=5 |>\nI like the other answers but they don't deal with numbers > 1000.\n\
    This solution will do exactly that. I've added a test to prove it.\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
