name: HumanEval_57_monotonic
language: rb
prompt: "# Return True is list elements are monotonically increasing or decreasing.\n\
  def monotonic(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n\
  \    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2,\
  \ 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false,\
  \ candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1,\
  \ 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\n\
  end\n"
completions: ["  l.inject(true) do |m, n|\n    m = false if n.nil?\n    m && m.zero?\
    \ || (m && n.first <= n.last)\n  end\nend", "  l.inject(0, :+) < l.inject(0, :-)\n\
    end\n</code>\n<|/ a |>\n<| a tags=list,ruby,comparison |>\nI do not know of a\
    \ way to do it efficiently in Ruby.  Ruby has set and hash sets, but no set comparison.\
    \  But here's an algorithm that will do it in O(N), where N is the length of list\
    \ a.\n<code>", "  return !l.empty? && l.all? { |x| x.is_a?(Numeric) }\nend", " \
    \ l.any? && l.all? { |e| e.is_a?(Numeric) }\nend", "  l.map { |e| e.is_a?(Numeric)\
    \ ? e.is_a?(Numeric) ? e >= e : e.between?(e, e+1) : e <=> e }.all?\nend\n</code>\n\
    <|/ a tags=arrays,ruby |>\n<| a dscore=0 tags=arrays,ruby |>\n<code>", "  l.any?\
    \ { |e| l.index(e) == l.size - 1 }\nend", "  (0...l.size-1).all? do |i|\n    l.at(i)\
    \ < l.at(i+1).to_f\n  end\nend", "  l.find { |x| x>l.last}\nend", "  l.inject(0,\
    \ :+).all? { |x, y| (x > y) || (x == y) }\nend\n</code>\n<|/ a dscore=3 tags=ruby-on-rails-4,ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby-on-rails-4,ruby,ruby-on-rails |>\nApart from monkey patching,\
    \ you could use Enumerable#each_concat :\n<code>", "  return l.all? && (l.all?\
    \ { |x| x.last <= x.first })\nend", "  sorted = l.sort\n  last = sorted[1]\n \
    \ for i in 2..l.size\n    diff = sorted[i] - last\n    if diff > 0 then return\
    \ false\n    last = sorted[i]\n  end\n  true\nend", "    l.sort == true or return\
    \ false\n    for i in 0..(l.length-1)\n        for j in i+1..l.length\n      \
    \      if l[i] > l[j] then\n                return false\n            end\n  \
    \      end\n    end\n    return true\nend", "  l.sort.inject(true){|result, elem|\
    \ result && elem > l[-1]}\nend", "    l.map!(&:to_i)\n    l.each { |e| e[1] =\
    \ e[1].to_i if e[1] && e[1] != false }\n    l.sort!\n    l.map!(&:first)\n   \
    \ l.size == l.uniq.size\nend", "  l.all? do |e|\n    a.nil? || (e > a) if a.nil?\n\
    \    e > a if e > a\n    e < a if e < a\n    true\n  end\nend", "  l.each do |e|\n\
    \    diff = e[-1] - e[1]\n    diff < 0 ? return false : next\n    diff > 0 ? return\
    \ false : next\n  end\n  true\nend\n</code>\nThis works as follows:\n<code>\n\
    [4, 3, 2, 1, 4, 3, 2, 5, 6, 1, 4].each_cons(2).any? {|x, y| monotonic?(x, y)}",
  "  return false if l.length < 2 else l[1] == l[-1]\nend", "  l.each do |e|\n   \
    \ return false if e.nil?\n    return true if e.length != 1\n    return true if\
    \ e.first < e.last\n  end\n  true\nend", "  return l.reduce(:<=>) > 0 && l.reduce(:-@>\
    \ > 0)\nend", "  l.inject(0, :<)\n  l.inject(0, :>)\n  l.all? { |x| x == l.min\
    \ || x == l.max }\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails,algorithm,sorting\
    \ |>\n<| a |>\nThis is also quite simple using partition:\n<code>", '  return
    false if l.nil? || l.empty? || l.size == 1 || (l.size > 1 && l.last.nil?) end',
  "  ls = l.dup\n  ls.length.times do |i|\n    j = i + 1\n    while j.length < i\n\
    \      j <<= 1\n    end", "  l.each_cons(2) do |a, b|\n    if b.nil?\n      return\
    \ true if (a.nil? or a.last < b[0])\n      return false if (b.nil? or a[0] > b.first)\n\
    \    end", "  return l.all? && l == l.sort.reverse ? !l.first : !l.first\nend",
  "  l.inject([1,-1]) { |r,n| r*n >= 0 ? r : (r-1)*n}\nend", "  l.sort.each do |x|\n\
    \    return false if x == l[0] || x == l[-1]\n  end\n  return true\nend", "  return\
    \ true if l > l[1] and l > l[end]\nend", "  if l.empty?\n    true\n  else\n  \
    \  (l[0] <= l[1]) && monotonic([l[1], l[0]].drop(1))\n  end\nend", "  l.each do\
    \ |x|\n    next if x == 0\n    break if x > 0 && x < 0\n    break if x <= 0 &&\
    \ x >= 0\n    break if x > 0 && x <= 0\n  end\n  l.each do |x|\n    next if x\
    \ == 0\n    break if x < 0 && x > 0\n    break if x <= 0 && x >= 0\n    break\
    \ if x < 0 && x <= 0\n  end\n  l.each do |x|\n    next if x == 0\n    break if\
    \ x > 0 && x < 0\n    break if x >= 0 && x < 0\n    break if x > 0 && x >= 0\n\
    \  end\n  l.each do |x|\n    next if x == 0\n    break if x < 0 && x > 0\n   \
    \ break if x >= 0 && x < 0\n    break if x < 0 && x >= 0\n  end\n  l.each do |x|\n\
    \    next if x == 0\n    break if x > 0 && x < 0\n    break if x >= 0 && x < 0\n\
    \    break if x < 0 && x >= 0\n  end\n  l.each do |x|\n    next if x == 0\n  \
    \  break if x < 0 && x > 0\n    break if x >= 0 && x < 0\n    break if x >= 0\
    \ && x > 0\n  end\n  l.each do |x|\n    next if x == 0\n    break if x > 0 &&\
    \ x < 0\n    break if x >= 0 && x < 0\n    break if x >= 0 && x > 0\n  end\n \
    \ l.each do |x|\n    next if x == 0\n    break if x < 0 && x > 0\n    break if\
    \ x >= 0 && x < 0\n    break if x >= 0 && x > 0\n  end\n  l.each do |x|\n    next\
    \ if x == 0\n    break if x > 0 && x < 0\n    break if x >= 0 && x < 0\n    break\
    \ if x >= 0 && x > 0\n  end\n  l.each do |x|\n    next if x == 0\n    break if\
    \ x < 0 && x > 0\n    break if x >= 0 && x < 0\n    break if x >= 0 && x > 0\n\
    \  end\n  l.each do |x|\n    next if x == 0\n    break if x > 0 && x < 0\n   \
    \ break if x >= 0 && x < 0\n    break if x >= 0 && x > 0\n  end\n  l.each do |x|\n\
    \    next if x == 0\n    break if x < 0 && x > 0\n    break if x >= 0 && x < 0\n\
    \    break if x >= 0 && x > 0\n  end\n  l.each do |x|\n    next if x == 0\n  \
    \  break if x > 0 && x < 0\n    break if x >= 0 && x < 0\n    break if x >= 0\
    \ && x > 0\n  end\n  l.each do |x", "  l.each do |v|\n    break if v == v[0]\n\
    \  end\n  v[0] == v[-1]\nend", "  l.sort\n  l.length == 1\nend", "  return l.all?\
    \ && (l[0] <= l[l.length-1])\nend\n</cell>\n<cell>\nmonotonic([10,2,4,6,2,4])\n\
    </cell>\n<cell>\nmonotonic([5,2,4,6,2,4])\n</cell>\n<cell>\nmonotonic([5,2,4,2,2])\n\
    </cell>\n<cell>", "  return true if l.reverse.sort.reverse.empty?\n  (l.reverse.sort.reverse.last\
    \ >= l.reverse.sort[0...-1].first)\nend", "  if l[-1] > l[-2]\n    true\n  else\n\
    \    false\n  end\nend\n</cell>\n<cell>", "  return l == l.sorted ? true : false\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,list dscore=2 |>\nIf you're open\
    \ to using an external gem then here you go.\n<code>\nrequire 'set'", "  l.each_index\
    \ do |i|\n    break if l[i] > l[i + 1]\n    break if l[i] < l[i + 1]\n  end",
  "  l.inject(:<=>) do |m, e|\n    m == 0 ? (e < 0 ? -1 : 1) : (e < 0 ? 1 : -1)\n\
    \  end\nend", "  l.last\n  first = l.first\n  while true\n    return true if l.first\
    \ != first\n    l.first == first ? l.first = true : l.first = nil\n    first =\
    \ l.first\n  end\nend", "  l.each do |e|\n    return false if e <= l[l.index(e)+1]\n\
    \  end\n  true\nend", "  l.sort!\n  prev = -Float::INFINITY\n  monotonic = true\n\
    \  l.each_with_index do |x, i|\n    return false if i > 0 && prev < x\n    prev\
    \ = x if monotonic\n    monotonic = false\n  end\n  monotonic\nend", "  l.is_a?(Array)\
    \ ? l.monotonic? : ((l == [[]]) || ((l.first == []) || (l.first.monotonic?)))\n\
    end", "  return not (l.empty? || l.first.nil? || l.last.nil?)\nend\n</code>\n\
    <|/ a dscore=4 tags=ruby,list |>\n<| c |>\nFor the first example `l.first.nil?`\
    \ returns `true`, while the first example of `monotonic` returns `false`. This\
    \ seems to be a difference in behaviour.\n<|/ c |>\n<| a |>\nJust an additional\
    \ note in case someone comes across this question in the future: Ruby has an 'inject'\
    \ method which can do this for you, with one line of code. \n<code>\narray = [1,\
    \ 2, 3, nil, 4, 5]\nresult = array.inject(0) { |sum, item| sum + item }\np result\
    \ #=> 15\n</code>\n<|/ a dscore=4 tags=ruby,list |>\n<| c |>\n+1 for pointing\
    \ out `inject` can be used with no block in recent versions of Ruby.\n<|/ c |>\n\
    <| a dscore=3 tags=ruby,list |>\nMonotonicity means that (1) each element of a\
    \ list is ordered relative to one another and (2)  each element of a list has\
    \ the same value for its order as that in another list.\nExample\n<code>\nirb(main):001:0>\
    \ array = [4, 5, 6, 3, 7, 2, 0]\n=> [4, 5, 6, 3, 7, 2, 0]\nirb(main):002:0> array.sort\
    \ == [0, 1, 2, 3, 4, 5, 6]\n=> true\n</code>\nThis means that the list [4, 5,\
    \ 6, 3, 7, 2, 0] is monotonic with respect to another list with values [4, 5,\
    \ 6, 3, 7, 2, 0] since they are ordered in the same way with respect to the other\
    \ list.\nThe Ruby code below implements this test:\n<code>", "  return l.all?\
    \ &&\n         l.all? &&\n         l.all? &&\n         l.all? &&\n         l.all?\
    \ &&\n         (l.all? &&\n          l.all? &&\n          l.all? &&\n        \
    \  l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n\
    \          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.all? &&\n     \
    \     !l.all? &&\n          !l.all? &&\n          !l.all? &&\n          !l.all?\
    \ &&\n          !l.all? &&\n          !l.all? &&\n          !l.", "  return false\
    \ if l.empty? \n    else if l[0].first > l[l.length - 1].first\n      then true\n\
    \      else false\n    end\nend", "  l.sort.map {|x| x >= l[-2] ? -Infinity :\
    \ x >= l[-1] ? Infinity : x}.all? {|x| (x >= 0 || x == 0) ? 1 : 0}\nend\n</code>\n\
    I haven't tested it so let me know if something is not working.\n<|/ a |>\n<|\
    \ c |>\n`l` is a list of numbers (not strings), so `l` in the `sort` method is\
    \ the wrong argument.\n<|/ c |>\n<| a |>\nIf you can assume that your list consists\
    \ only of positive numbers, then the solution below will work.\n<code>", "  l.map\
    \ { |x| l.count(x) }.uniq.size == 1\nend\n</code>\n<|/ a |>\n<| c |>\nThat's a\
    \ nice solution. One could even simplify the condition like this: `l.map { |x|\
    \ l.count(x) }.uniq.size == 1`\n<|/ c |>\n<| c |>\n: yes, that's true. I didn't\
    \ have time to get around to doing that and have just edited it in since I was\
    \ thinking about it when writing this answer.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nNot a Ruby expert, but I believe this can be done in O(n log n) time by\
    \ using sort:\n<code>\nnumbers = [1, 3, 2, 8, 1, 6, 10, 2, 7, 5, 3, 6, 9, 2, 10]",
  "  l.inject(false) { |isIncreasing, x| isIncreasing && x.nil? || x.gt(x.next) }\n\
    end", "  l.sort do |a, b|\n    a <=> b\n  end\n  l[0] == l[l.length - 1]\nend",
  "  l.each_with_index do |value, index|\n    if value <= l[index+1]\n      return\
    \ false\n    end\n  end\n  true\nend", "  l.each do |e|\n    break if e < l[0]\n\
    \    break if e > l[-1]\n  end\n  false\nend\n</code>\n<|/ a tags=sorting,ruby\
    \ |>\n<| a tags=sorting,ruby |>\nRuby's sort does a lot of things to make it fast.\n\
    The fastest way to sort arrays is to use quicksort which is O(n*log(n)).  Ruby's\
    \ sort uses quicksort internally.\nSorting by multiple keys is O(n*k) where n\
    \ is the number of elements and k is the number of keys.\nIf the number of keys\
    \ is fixed you can sort in a single pass.  If the number of keys is variable then\
    \ you can sort by each key and then merge the sorted arrays.\nTo sort multiple\
    \ keys use Hash merge to create an array of hashes with all of your keys as keys.\n\
    <|/ a dscore=3 |>\n<| c |>\nIf all elements are sorted in the first pass, then\
    \ you can do the merge on the second pass to merge all keys with each other. Otherwise\
    \ you can sort each key and put them all in one array and sort that.\n<|/ c |>\n\
    <| c |>\nThe merge sort is O(n^2) when there are two lists with size n. Which\
    \ is not necessarily a bad thing. Just wanted to point out that the \"merge\"\
    \ function can be replaced with a \"sort (merge)\".\n<|/ c |>\n<| a |>\nYou could\
    \ use the built-in sort with a custom comparer.\n<code>", "  return l.all? &&\
    \ l.all? { |e| e < l.last }\nend", "  l.inject(&:<)\nend", "    l.sort!\n    return\
    \ l.first <= l.last\nend", "    l.uniq!\n    l.sort!\n    l.size <= 1\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nFor those of us who don't speak english,\
    \ could you maybe give some comments to your code? It's much easier to understand\
    \ what it does rather than just read the code itself\n<|/ c |>\n<| c |>\nSure.\
    \ I did a bit of commenting.\n<|/ c |>\n<| c |>\n`arr.uniq` will remove all duplicates,\
    \ but it will keep the order of the elements, like [1,1,2,3]. If you want to remove\
    \ them as well you can use `arr.uniq!` which will return an array with duplicates\
    \ removed. See [here](http://ruby-doc.org/core-2.2.0/Array.html#method-i-uniq-21).\n\
    <|/ c |>\n<| c |>\nI don't think this is correct. Try testing it with `arr = [3,\
    \ 2, 4, 3]`\n<|/ c |>\n<| c |>\nIt's not correct because `arr.uniq` returns an\
    \ array with duplicates removed. I tested it with `arr = [3, 2, 4, 3]` and it\
    \ returned `[3, 2, 4]`. What do you think `uniq` does?\n<|/ c |>\n<| a dscore=5\
    \ tags=ruby,sorting,arrays |>\nI like the idea of putting this in a class like\
    \ so:\n<code>", "  return (l[1] < l[0] or l[1] > l[-1]) and all((l[i] > l[i+1]\
    \ or l[i] < l[i-1]) for i in range(1, len(l)))\nend", "  l.inject(&:+) >= l.inject(&:-)\n\
    end", "  l.size==0 || return false unless l.size>0\n  return false unless l.last.eql?(l.first)\n\
    \  l.each_with_index{|x,i| return false unless x.eql?(l.first)} if l.size==1\n\
    \  true\nend", "  if l.empty?\n    true\n  else\n    l = l.to_a\n    l.shift if\
    \ l[1] > l[0]\n    l.shift if l[1] < l[0]\n    l.all? { |e| l[1] < e }\n  end\n\
    end", "  l.last\n  return l.last.nil? || l.first.nil? || l.last.first <= l.first.last\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,sorting,arrays,algorithm\
    \ |>\n<code>", "  # Return true if list is monotonically increasing.\n  if l.empty?\n\
    \    true\n  else\n    l[0] <= l[-1] && l[0...-1].all? { |x| x <= l[-x] }\n  end\n\
    end\n</code>\nMonotonic list:\n<code>\n>> monotonic([5,8,8,10,13])\n=> true\n\
    >> monotonic([8,8,10,13])\n=> false\n</code>\nMonotonic array:\n<code>\n>> monotonic([8,8,10,13,13])\n\
    => true\n>> monotonic([8,8,10,13])\n=> false\n</code>\n<|/ a |>\n<| c |>\n`monotonic([7,7,7])`\
    \ returns `false`.\n<|/ c |>\n<| c |>\nYes it does. It works just fine on my machine\
    \ ;) Updated answer, thanks.\n<|/ c |>\n<| c |>\n: It doesn't work for `monotonic([7,7,7])`.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.size.times.reduce { |a, b| a\
    \ <=> b } >= 0 ? true : false\nend", "\tl.sort\n\tl.last\n\tl.first == l.last\n\
    end", "  l.inject(true) do |result, element|\n    result && (element <= result[result.size\
    \ - 1])\n  end\nend", "  l.sort == l.reverse ? l == l : l == l.reverse\nend",
  "  l.each_cons(2) do |x, y|\n    return false if y.nil?\n    return false if y.last\
    \ < x.last\n  end\n  true\nend", "  sorted = l.sort\n  l = sorted.count\n  (l.max\
    \ == 0 and l.min == 0) or (sorted == sorted and sorted == [sorted[0]] + sorted[-2..-1]\
    \ and\n  sorted.count > 2 and sorted.min >= sorted[-2..-1])\nend\n</cell>\n<code\
    \ language=julia-1.0>", "  return l.size > 1 and ((l[1] < l[0]) != (l[0] < l[1]))\n\
    end", "  l.sort.inject {|sum, e| sum + e <=> sum + e <=> sum + e}\n  l.all?(&:<)\n\
    end\n</code>\n<|/ a |>\n<| a tags=sorting,ruby,arrays,comparison dscore=1 |>\n\
    <code>\narr = [1, 2, 4, 3, 6, 6, 2, 1, 4, 3, 1]\narr.sort {|a, b| arr[b] - arr[a]}\n\
    </code>\n<|/ a |>\n<| a |>\nI wrote a little method to do the same.\n<code>",
  "  # This implementation relies on Python's sorted function which has an\n  # O(n\
    \ log n) running time.\n  return !!(l <= l[0..(l - 1)].sort)\nend", "  l.each_cons(2)\
    \ do |a, b|\n    return false if a.first > b.first\n  end\n  true\nend", "  return\
    \ l == [] || l.sort.is_a?(Enumerable)\nend", "    l.sort!\n    return l[-1] <\
    \ l[0]\nend\n</cell>\n<cell>\n@test monotonic([7,5,4,4,1,1,1]) == true\n</cell>\n\
    <text>\nExercise 3\nWrite a function that returns the reverse of a list.", " \
    \ l.inject([:<, :>]) { |t,(a,b)| t[a] <=> t[b] }\nend", "\tl = l == nil ? [] :\
    \ l.dup\n\tl.sort()\n\tl.each { |e| return false unless e <= l[0] }\n\ttrue\n\
    end", "  l.each_index {|i|\n    if l[i] > l[i+1]\n      return false\n    end\n\
    \  }\n  return true\nend", "  l.sort!\n  return l[0] > l[-1]\nend", "  l.sort\
    \ { |a,b| a <=> b }\n  l[0] == l[-1]\nend", "  return l.all? && l.all?(&:<)\n\
    end", "    l.inject(0) {|sum, e| sum + e if e > sum } == l.inject(0) {|sum, e|\
    \ sum + e if e <= sum }\nend\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\nYou\
    \ can use sort_by to sort a list according to a specific criteria. E.g.:\n<code>\n\
    [ 'a' , 'b' , 'c' ].sort_by { |value| -value.to_i }\n=> [\"c\", \"b\", \"a\"]\n\
    </code>\nThis assumes that your list contains strings, not numbers. If you are\
    \ trying to sort numbers, you might want to use Numeric#<=> instead:\n<code>\n\
    [5, 3, 1].sort_by { |value| -value <=> 0 }\n=> [1, 3, 5]\n</code>\n<|/ a tags=ruby,arrays,sorting,ruby-on-rails\
    \ |>\n<| c |>\nThe second example is what I am looking for. Thanks\n<|/ c |>\n\
    <| a dscore=2 tags=ruby,arrays,sorting,ruby-on-rails |>\nRuby has many ways to\
    \ sort arrays. Which one to use depends almost entirely on what the requirements\
    \ are of the sorting.\nIn your example case, the sorting criteria is that the\
    \ elements have to be in ascending order, so the best choice may be sort_by.\n\
    <code>\n[ 'a' , 'b' , 'c' ].sort_by { |s| s.to_i }\n</code>\n<|/ a |>\n<| a |>\n\
    You can use the sort_by method and specify the criteria in your block:\n<code>\n\
    array.sort_by do |value|\n  case value\n  when 1..10\n    1\n  when 10..20\n \
    \   2\n  when 20..30\n    3\n  else\n    4\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,sorting,ruby-on-rails\
    \ dscore=2 |>\n<| a tags=ruby,arrays,sorting,ruby-on-rails |>\nIf you need to\
    \ sort numerically and need to sort with some specific conditions you can do like\
    \ this:\n<code>\n['7', '15', '3', '6'].sort_by{|number| number.to_i} if number.to_i.to_s.to_i\
    \ % 2 != 0\n</code>\nThis will sort numbers which are even in descending order\
    \ and numbers which are odd in ascending order.\n<|/ a dscore=1 |>\n<| a |>\n\
    <code>\narray.sort_by { |a| a.to_i }\n</code>\n<|/ a tags=ruby,", "  l.inject(true)\
    \ do |m, e|\n    m |= e <= l[-2] # if e <= l[-2], e is monotonically increasing\n\
    \    m &= (e >= l[-3]) # if e >= l[-3], e is monotonically decreasing\n    m\n\
    \  end\nend", "  if l.is_a?(Array) or l.is_a?(Range)\n    l = l.to_a\n  end",
  "  l.each do |i|\n    j = i\n    while (j > 0 && l[j-1] > l[j])\n      j = j - 1\n\
    \    end\n    if (i < j)\n      return false \n    end \n  end\n  return true\
    \ \nend", "  # Return true is there are any equal elements.\n  return l.uniq.size\
    \ > 1\nend", "  l.sort!\n  l.first.is_a? Numeric\n  l.last.is_a? Numeric\n  l[0]\
    \ == l[-1] && l.all?(&:zero?)\nend\n</code>\nThen you can use the following in\
    \ Ruby 2.4+ to get your desired result (returns nil if list is monotonic):\n<code>",
  "  l.each_with_index do |element, index|\n    return false if elements[index] >=\
    \ element\n  end", "  return true if l.is_a?(Array) and l.length == 2 && l[1]\
    \ < l[0]\nend\n</code>\nExample usage:\n<code>\n[9,8,7].monotonic?     # => true\n\
    [\"9\", \"8\", \"7\"].monotonic?     # => false\n</code>\nThe implementation is\
    \ O(n), where n is the length of the list l, and can be optimized using binary\
    \ search on the list if the list is sorted.\n<|/ a tags=ruby,sorting |>\n<| c\
    \ |>\nNice, I like this one. I remember doing something like this in Python and\
    \ I didn't remember what it was called.\n<|/ c |>\n<| c |>\n: What is the time\
    \ complexity of this method ?\n<|/ c |>\n<| c |>\n: O(N), where N is the length\
    \ of the list. If the list is sorted, binary search on the list is O(log N), so\
    \ the total complexity is O(N log N).\n<|/ c |>\n<| a dscore=5 tags=ruby,sorting\
    \ |>\nIf you want something that works for both numeric and alphanumeric sorts,\
    \ you can use the sort_by method and provide your own sorting logic:\n<code>\n\
    %w(a b aa bb cc aaa bbb).sort_by { |x| [-x, x].sort_by(&:downcase) }", "  l.each_with_index\
    \ { |e, i| return true if i > 0 && e < l[i-1] }\n  l.each_with_index { |e, i|\
    \ return true if i < l.size-1 && e > l[i+1] }\n  true\nend", "  l.each do |e|\n\
    \    return false if e[0] != e[-1]\n  end\n  true\nend", "  l.each_cons(2) do\
    \ |a,b|\n    return false if a.nil? || b.nil?\n    return false if b.nil? || a.nil?\n\
    \    break if b.first < a.first\n  end\n  true\nend", "  return l == l[1..-1].sort\
    \ # or l.sort is probably faster\nend", "  l.each { |e| return false if e.nil?\
    \ || e < e[1..-1] }\n  true\nend", "  return l.all? && l.all?(&:<=>)\nend\n</cell>\n\
    <cell>\nmonotonic([1,2,3])\n</cell>\n<cell>\nmonotonic([3,1,2])\n</cell>\n<cell>\n\
    monotonic([3,2,1])\n</cell>\n<cell>\nmonotonic([1,1,1])\n</cell>\n<cell>\nmonotonic([1,2,2])\n\
    </cell>\n<cell>", "    l.sort == (l.reverse || l.reverse!).sort\nend", "  l.sort\n\
    \  return l.first == l.last\nend", "  l = l.to_a\n  return false if l.size <=\
    \ 1 \n  r = [1, 0]\n  r.each {|n| r[2] += 1 if n-l[0] > l[1]-n }\n  r[1] == 0\
    \ && r[2] == 0\nend\n</code>\nThen you can do:\n<code>", "  l.inject([0,-1]) {\
    \ |r,e| return (r[0] > e) || (r[0] < e) ? 1 : 0 } == 1\nend", "  l.sort == l.uniq.sort\n\
    end", "  l.sort.each do |i|\n    return false if l[i+1] < l[i]\n  end\n  true\n\
    end\n</code>\n<|/ a tags=performance,ruby,arrays dscore=5 |>\n<| c |>\nNice. Didn't\
    \ know that sort could be passed a block.\n<|/ c |>\n<| c |>\nThe only problem\
    \ with that solution is that it's O(n), where n is the number of elements in the\
    \ array.\n<|/ c |>\n<| c |>\n: Of course, that's exactly what I was referring\
    \ to. However, the array is presumably relatively small, and the cost of the sort\
    \ is likely to be negligible.\n<|/ c |>\n<| c |>\n: I wasn't thinking about the\
    \ sort, just the fact that you need to go through the whole array once to check\
    \ for monotonic behavior. In a situation where it's important to know whether\
    \ the list is monotonic or not, this might be a significant saving.\n<|/ c |>\n\
    <| c |>\n: Yes, I agree. That is one of the advantages of sort-block compared\
    \ to `sort` compared to `sort_by`. The downside is that `sort` can be inefficient\
    \ if the array is very large. On the other hand, the downside of `sort_by` is\
    \ that it is difficult to detect `ArgumentError` due to inconsistent elements.\n\
    <|/ c |>\n<| a tags=performance,ruby,arrays dscore=4 |>\nJust another solution:\n\
    <code>", "  return l != nil? and l[0] == l[-1] and all? l, method(:==)\nend",
  "  if l.length==1\n    return true\n  m = l.first\n  l.shift if m == l.last\n  l.each\
    \ do |x|\n    if m > x\n      return false\n    elsif m < x\n      return true\n\
    \    end\n    m = x\n  end\n  return true\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nI realize this is a very old thread, but the accepted answer by is very\
    \ close to the accepted answer by but is missing a few lines. His example is actually\
    \ checking the last element of the list, which would be the same as the second\
    \ element of the list minus one. Also, you could replace 'elsif m < x' with 'elsif\
    \ x <= m'. Otherwise great answer!\n<|/ c |>\n<| a |>\nJust a slight variation\
    \ on Aaron's answer, that works with ruby 1.9:\n<code>", "    l.map! { |e| e.to_i\
    \ }\n    l.sort { |a, b| a.to_i <= b.to_i }\n    l.empty?\nend\n</code>\n<code>\n\
    monotonic([1, 2, 5, 10]) # => true\nmonotonic([1, 2, 5, 11, 100]) # => false\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThanks for sharing this `monotonic` method.\
    \ It reminds me of `Enumerable#all?`, but I can't find it now. Do you know of\
    \ any other good references for this method?\n<|/ c |>\n<| c |>\nThe documentation\
    \ at http://ruby-doc.org/core-2.7.0/Enumerable.html describes all the methods\
    \ that are part of the Enumerable module. Many other core classes also have some\
    \ of these methods. For example, [Array](http://ruby-doc.org/core-2.7.0/Array.html)\
    \ has `all?` and `any?` methods. And of course, the documentation for [`Enumerable#sort`](http://ruby-doc.org/core-2.7.0/Enumerable.html#method-i-sort)\
    \ explains how to pass a block to sort.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\n\
    In response to the updated question, here is an example of how to determine if\
    \ all integers in a given array are monotonically increasing\n<code>\na = [1,2,3,5,6,8,12,13]",
  "  l.sort { |a, b| b <=> a } == l # or a.sort <=> b } == a # or b.sort <=> a }\n\
    end", "  if l.is_a?(Array) then\n    l.min < l.max\n  else\n    l < l.min\n  end\n\
    end", "  return l.max < l.min\nend", "  l.sort\n  l[0] < l[-1]\nend\n</code>\n\
    <|/ a tags=sorting,ruby |>\n<| a |>\n<code>\narray.sort { |x,y| x <=> y } #=>\
    \ nil\n</code>\n<|/ a dscore=5 tags=sorting,ruby |>\n<| c |>\nThis does exactly\
    \ what the OP asked, although (I think) is a little misleading, since it will\
    \ sort the array in descending order.\n<|/ c |>\n<| c |>\n`array.sort { |x,y|\
    \ x <=> y } #=> [nil]`\n<|/ c |>\n<| c |>\nIf you care about performance, be careful.\
    \ `<=>` is actually slower than `<` and `>`.\n<|/ c |>\n<| c |>\n, could you please\
    \ explain what you mean? `<=>` is implemented in C, so it should be faster than\
    \ `<` and `>`. And also `<=>` does not require additional objects (so this should\
    \ not be a problem).\n<|/ c |>\n<| c |>\nI was trying to point out that `array.sort\
    \ { |x,y| x <=> y } #=> [nil]` does not return `nil`, it returns `[nil]`. As you\
    \ can see from [this benchmark](https://gist.github.com/afayetzig/4c5970e57ebd5587f49e)\
    \ it's about twice as fast as `<=>`.\n<|/ c |>\n<| a |>\nI always prefer this\
    \ approach:\n<code>", "  l.each_with_index { |e, i| break true if i > 0 && e <=\
    \ l[i-1] }\nend\n</code>\n<code>\n>> monotonic([1, 2, 2, 3, 3, 3])\n=> true\n\
    >> monotonic([1, 2, 3, 4, 4, 5])\n=> false\n>> monotonic([1, 2, 3, 4, 4, 5])\n\
    => false\n</code>\n<|/ a tags=ruby,arrays dscore=0 |>\n<| a dscore=0 |>\nA solution\
    \ without using any sorting/comparing functions or sorting.\n<code>", "    l.sort\n\
    \    l.each_cons(2).none?(&:zero?)\nend\n</code>\nThen \n<code>\nis_sorted([[2,3],[3,4],[1,2],[2,3]])\n\
    => true\nis_sorted([[2,3],[3,4],[1,2],[2,4]])\n=> false\n</code>\n<|/ a tags=sorting,algorithm,ruby\
    \ |>\n<| c |>\nThis looks good, but I don't see how it handles empty lists or\
    \ lists of size 1. Can you add some tests to verify that it works?\n<|/ c |>\n\
    <| c |>\n: Yes, empty lists are sorted as well.\n<|/ c |>\n<| c |>\n\"If it comes\
    \ to complexity and speed, it always comes to trade-off.\" \u2014 What trade-off\
    \ does it mean? Are you talking about time or space? The algorithm is O(n), but\
    \ the question asked was about complexity and speed.\n<|/ c |>\n<| c |>\n\"The\
    \ algorithm is O(n), but the question asked was about complexity and speed.\"\
    \ \u2014 I didn't say it's O(n), I said it can handle lists of arbitrary length.\
    \ As you said, time complexity is O(n), space complexity O(1). It's a trade-off.\n\
    <|/ c |>\n<| a |>\nYou could do something like this \n<code>", '  sorted_list
    = l', '  l.sort!', "  l.sort.each { |e| return false if e != l.first }\n  true\n\
    end", "  return l.inject(true?) do |m, e|\n    m = m && (l > e) || m && (l < e)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks for the thorough\
    \ explanation.\n<|/ c |>\n<| c |>\n: Note that this code will only work if the\
    \ lists are sorted in ascending order - if the list is not sorted, you'll need\
    \ to do something like a binary search to find when the first element changes.\n\
    <|/ c |>\n<| c |>\nIf you're looking for a one liner that's also readable, this\
    \ should do the trick: `l.reverse.sort.reverse.uniq.empty?`\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=5 |>\n<code>", "  l[0], l[1] = l[1], l[0]\n  l.max_by { |e| e }\nend",
  "  l.sort.each do |e|\n    return false unless e <= l[0..e.size-1]\n  end\n  true\n\
    end\n</code>\nThis does two things:", "  l.to_a.sort{ |a, b| b <=> a } == l\n\
    end", "  l.sort == l.sort\nend", "  l[0] <= l[-1]\nend", "  l.inject(true) { |i,x|\
    \ i && !(x < l[i-1] || x > l[i+1]) }\nend\n</code>\n<|/ a |>\n<| c |>\nI thought\
    \ about doing this but I don't want to depend on `sorted` because it's not a very\
    \ efficient algorithm when sorting large lists.\n<|/ c |>\n<| c |>\nIn that case,\
    \ you'll probably want to do your own sorting algorithm. :-) And if you have a\
    \ strong feeling for what sort algorithm to use, check out http://www.sorting-algorithms.com/\n\
    <|/ c |>\n<| c |>\nYeah I would want to write my own sorting algorithm but I can't\
    \ find any good resources for writing an efficient one. I'm just looking for something\
    \ that's fast enough.\n<|/ c |>\n<| c |>\nYou might be better off asking someone\
    \ at SO who has done this already to point you at some good resources. :-) And\
    \ as I said before, if you have a strong feeling for what algorithm to use, you\
    \ might want to check out http://www.sorting-algorithms.com/\n<|/ c |>\n<| c |>\n\
    I went and looked at http://www.sorting-algorithms.com/  I haven't seen anything\
    \ in there about writing an efficient sorting algorithm. Maybe I just need to\
    \ learn to write one. Thanks for your help!\n<|/ c |>\n<| a tags=ruby |>\nHere's\
    \ a solution that uses the sorted method of Array. It relies on sort not modifying\
    \ the array but creating a copy and then sorting it.\n<code>", "    l.each_with_index\
    \ do |e,i|\n      if i < l.size-1 and e == l[i+1]\n        false\n      else\n\
    \        true\n      end\n    end\nend", "    l.each do |v|\n        begin\n \
    \           if v > l[0]\n                return false\n            end\n     \
    \   rescue\n            return false\n        end\n    end\n    return true\n\
    end\n</code>\n<|/ a tags=ruby,sorting dscore=1 |>\n<| a tags=ruby,sorting |>\n\
    You can use the sort_by method.\n<code>", "  l.each_index do |i|\n    return false\
    \ if l[i+1] < l[i] or l[i+1] > l[i]\n  end\n  true\nend", "  l.sort\n  res = (l[-1]-l[-2])\
    \ >= 0\n  l.sort! # undo sort\n  res\nend", "  if l.length > 1\n    diff = l[1...]\
    \ - l[0..(l.length - 2)]\n    return diff > 0 && diff < 1\n  end\n  false\nend",
  "    l.sort {|a,b| a<b ? -1 : 1}.empty?\nend", "  return l.compact.all? || (l.all?\
    \ && l.min...l.max < l.min...l.max)\nend", "  return true if l.first == l.last\
    \ or l.first < l.last\nend\n</code>\nThe reason this works is that all list elements\
    \ must be monotonically increasing or decreasing, so we only need to check the\
    \ first and last elements of the list.\n<|/ a |>\n<| c |>\nIt will fail with an\
    \ empty list. This is the kind of thing that should be in the standard library.\n\
    <|/ c |>\n<| a |>\nHere's another way:\n<code>", "  return l.inject{|m,e| m.compare_and_swap(e,e[1]<e[1]\
    \ ? e[1] : e[1]<e[0] ? e[1] : e[0]) ==\n              0 ? m : m} <= l[1]\nend",
  "  l.is_a?(Array) ? l.sort.each_with_index.all? {|e1,e2|\n    e1.eql?e2 || e1.eql?e2\
    \ - 1 || e1.eql?e2 + 1 \n  } : l.is_a?(Range) ? l.to_a.reverse_each.all? {|e1,e2|\n\
    \    e1.eql?e2 || e1.eql?e2 - 1 || e1.eql?e2 + 1 \n  } : l.is_a?(Set) ? l.all?\
    \ {|e1|\n    e1.eql?e2 || e1.eql?e2 - 1 || e1.eql?e2 + 1 \n  } : l.is_a?(Hash)\
    \ ? l.all? {|e,v|\n    v = v[1] if v.is_a?(Array) #Ruby >= 1.9\n    v.eql?(v.max)\
    \ || v.eql?(v.min) || v.eql?(v.midpoint) || v.eql?(v.end) || v.eql?(v.start) ||\
    \ v.eql?(v.first)\n  } : l.is_a?(Integer) ? l >= 0 && l <= Float::INFINITY : l.is_a?(Float)\
    \ ? l == Float::INFINITY : l.is_a?(Symbol) ? l.to_s == l.to_sym : l.is_a?(Float)\
    \ ? l == Float::INFINITY : l.is_a?(FalseClass) ? false : true\nend", "  l.sort\n\
    \  l.first > last(l) || l.last < first(l)\nend", "  l.sort.inject(true) { |l,e|\
    \ e == l.last ? l : !l }\nend\n</code>\nUsing this function, we can write an instance\
    \ method of Array, which will return true if the list is monotonic. We can then\
    \ use it in any Enumerable or Enumerator to determine whether it's sorted or not:\n\
    <code>\nmodule Monotonic\n  def monotonic?\n    monotonic(self) \n  end\nend",
  "  l.map { |i| i.is_a?(Numeric) ? i.succ : i }\n    .all? { |i| i.is_a?(Numeric)\
    \ }\nend", "  l.inject([]) {|a,e| a + [(a[-1] > e) ? true : false]}\nend", " \
    \ l.sort!\n  prev = 0\n  l = l.map{|x| (x - prev) }\n  l.all?{|x| (x < 0) or (x\
    \ == 0) }\nend", "  l.each do |x|\n    if l.last >= x\n      return false\n  \
    \  end\n  end\n  true\nend", "  l = l.sort\n  l.first\n  l.last - l.first + 1\n\
    end", "  l.last.nil? ? true : (l.last.<=>l.first) == 0\nend\n</code>\nIf you have\
    \ a large list, this might not be a good idea as the .last call is O(n).\nAlternatively,\
    \ you could try this:\n<code>", "  return l.all? ||\n    l.all? &&\n    l.reduce{|a,b|\
    \ a <=> b }.zero?\nend\n</pre>", "  return l == [l.first] if l.size == 1 || (l.size\
    \ > 1 && l.all? {|x| x.first} == l.first)\n  l.all? {|x| x.last < l.last}\nend",
  "  l.map { |e| e.is_a?(Numeric) ? e.between?(l.min.abs, l.max.abs) : e < l.min }\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI actually don't think this approach\
    \ is correct because you're not testing monotonicity, you just have a strict order\
    \ in the array (which is different from monotonicity).\n<|/ c |>\n<| c |>\nI thought\
    \ OP wanted monotonicity because of the way he described his use case. From the\
    \ question: `[1,2,3]` should return `true` but `[1,2,3]` should return `false`\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  return l.first == l.last\n\
    end", "  l = l.to_a\n  l[1] = l[1] || l[0]\n  l[-1] = l[-1] || l[-2]\n  l.last.nil?\
    \ && return true\n  l.map(&:to_i).zip(l[1..-1]).all? do |a, b|\n    a < b\n  end\n\
    end", "  l1 = l.map { |e| e.is_a?(Fixnum) ? e : e.to_i }.sort\n  l2 = l.map {\
    \ |e| e.is_a?(Fixnum) ? e : e.to_i }.sort\n  l1 == l2\nend", "  l1, l2 = l, l\
    \ # Remember first value.\n  diff = false\n  while l1.nil? or l2.nil? or l1.nil?\
    \ < l2 # Compare elements.\n    diff = false\n    if l1.nil? then # List is empty.\n\
    \      break\n    elsif l2.nil? then # List is monotonically increasing.\n   \
    \   break\n    elsif l1.last < l2.last then # List is monotonically decreasing.\n\
    \      break\n    end\n    l1, l2 = l2, l1 # Next values.\n  end\n  diff\nend",
  "  return l.first >= l.last\nend\n</cell>\n<code language=julia-1.5>", "  l.reverse!\n\
    \  l[0...-1] == l[0...-1].sort\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like\
    \ your answer, but `monotonic`'s performance is not great. I tried replacing `sort\
    \ #=> n` with `sort #=> n * log(N)` (n ~ 10), and it took 10x longer.\n<|/ c |>\n\
    <| c |>\nI didn't test it but I think that `sort #=> n * log(N)` should have been\
    \ `sort #=> N * (1 + log(N))`\n<|/ c |>\n<| a dscore=2 tags=sorting,ruby,arrays\
    \ |>\nHere's one more possible approach: convert each array element to a string\
    \ and sort that. Then convert the sorted string array back to integer array. \n\
    I find this to be a more elegant solution than the accepted answer, which sorts\
    \ the array in place and uses a lot of CPU time. \n<code>\narr = ['2', '10', '20',\
    \ '100', '2', '5']\narr.map{|e| [e.to_i, e.to_s] }.sort.map(&:to_i)", "  l.length\
    \ == 0 || l.any?{ |e| e < l.first }\nend", "  # Special case for empty list.\n\
    \  return nil unless l.any?", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return\
    \ false if a.first < b.first\n    return false if a.last > b.last\n  end\n  return\
    \ true\nend", "  return l.max < l.min\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work for lists containing strings. Any suggestions?\n<|/ c |>\n<| c |>\n: This\
    \ answer doesn't work for strings -- did you try it out? It works for the example\
    \ in question, but fails if there are more complex strings or empty lists in the\
    \ list.\n<|/ c |>\n<| c |>\nI did try it and it works, but I forgot to mention\
    \ that I'm looking for a generic solution that works for any type of list (including\
    \ strings) to sort and compare. I'll edit my question and add this point.\n<|/\
    \ c |>\n<| a dscore=3 |>\nI ended up building a solution to my question. I think\
    \ it can be made much more efficient by using hash tables, but that's for later.\n\
    <code>", "  l.each { |x| return true if x.is_a?(Numeric) && x.to_i >= x.to_i }\n\
    \  false\nend", "  l.inject(0, :+)\n  l.each_cons(2) do |e,e2,e2|\n    return\
    \ true if e2.nil?\n    return true if e < e2\n    return false if e == e2\n  end\n\
    \  true\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nWow, that's a lot\
    \ of code. I'll have to read it through and understand what it's doing. I can\
    \ see what it's doing. It's really clever. Thanks for posting!\n<|/ c |>\n<| c\
    \ |>\n: It takes two arrays A and B and returns true only if `A` contains all\
    \ the elements of `B` after removing any duplicates.\n<|/ c |>\n<| c |>\nAwesome.\
    \ Thanks much!\n<|/ c |>\n<| c |>\n: Thanks for the feedback. BTW, I also added\
    \ a more efficient solution that returns true even if one array has an element\
    \ more than once.\n<|/ c |>\n<| c |>\n: BTW, I also added a more efficient solution\
    \ that returns true even if one array has an element more than once.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\na = [1,2,3,2,1,3,3]\nb = [1,2,3,2,2,1,3,3]\na.all? {|x|\
    \ b.count {|y| x == y}}\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is not correct\
    \ because the question states that `[1,1,2,2]` should be false. Your solution\
    \ returns true.\n<|/ c |>\n<| c |>\nYou are right. I updated my answer.\n<|/ c\
    \ |>\n<| a tags=ruby |>\n<code>\na = [1,2,3,2,1,3,3]\nb = [1,2,3,2,2,1,3,3]\n\
    a.all?{|x| b.count {|y| x == y}}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is\
    \ not correct because the question states that `[1,1,2,2]` should be false. Your\
    \ solution returns true.\n<|/ c |>\n<| c |>\nyou are right. I updated my answer\n\
    <|/ c |>\n<| a dscore=0 |>\nThis should work:\n<code>\na = [1,1,2,2,2,3,3]\nb\
    \ = [1,2,3]", "  l.each_cons(2) do |a,b|\n    break if a.nil? || a.zero? || b.nil?\
    \ || b.zero?\n    break if a.succ == a\n    break if b.pred == b\n    break if\
    \ a.succ > b\n    break if b.pred < a\n  end\n  l.size > 0 && l.size == l.size-1\n\
    end", "  return false unless l and l.size > 0\n  l.each do |x|\n    if x.nil?\
    \ or x.is_a?(Numeric)\n      yield x if yield(x)\n    elsif x.is_a?(Range)\n \
    \     yield x if yield(x) and (x.begin >= x.end) or (x.end < x.begin)\n    else\n\
    \      yield x\n    end\n  end\nend", "  l.sort!\n  l.length == 0 || l[-1] < l[-2]\n\
    end\n</code>\nWith this we can easily define a method is_monotonic?, which checks\
    \ that an ordered list is monotonic. We could then implement the method in this\
    \ way.\n<code>", '  return true if l.uniq.size == l.size', "    l.each_with_index\
    \ do |element, index|\n        return true if element > l[index + 1]\n    end\n\
    \    return false\nend", "  l.each do |e|\n    break if e == e.next\n  end\n \
    \ !(l == l)\nend", "  l = l.dup\n  l.shift\n  return l.reverse.all? && l == l.uniq.sort\n\
    end", "\tl.each_index { |i| return true if l[i] > l[i-1] }\nend", "  return l[-1]<l[0]\
    \ if l.size != 0 else  l.first<l.last\nend", "  l.sort\n  l[0] == l[-1]\nend",
  "  return l.uniq.size == 1 and l[0] >= l[-1]\nend", "  l.is_a?(Array) && l.all?\
    \ { |x| x.is_a?(Numeric) }\nend", "  return l.all? { |v| v.all? { |e| e > v.last\
    \ }}\nend\n</code>\n<|/ a tags=ruby,list,arrays |>\n<| c |>\nThanks, I fixed the\
    \ error I was getting and added an explanation of why I think your code is more\
    \ elegant.\n<|/ c |>\n<| a tags=ruby,list,arrays |>\n<code>", "  l.all? { |x|\
    \ x.kind_of?(Numeric) }\nend", "  return l.all? && (l.first<l.last)\nend", " \
    \ return l.all? &&\n    (l.first.nil? || l.first.nil? ? false :\n      (l.first.zero?\
    \ || l.first.last <= l.last.first))\nend", "  if l.length==0 || l.length==1\n\
    \    return false\n  end\n  first = l[0]\n  last = l[-1]\n  length = l.length\n\
    \  for i in 1..length\n    elt = l[i]\n    if elt < first || elt > last\n    \
    \  return false\n    end\n  end\n  return true\nend", "  l.each do |i|\n    prev\
    \ = nil\n    l.each_index do |j|\n      return true if l[j] < l[j+1] if prev !=\
    \ l[j] or j == 0\n      prev = l[j]\n    end\n  end\n  false\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis code is working in ruby 2.2 but not working in\
    \ ruby 2.3.1. It is not returning any value.\n<|/ c |>\n<| c |>\nWorks for me\
    \ in 2.2. Do you get any error messages? You also need to define `l`\n<|/ c |>\n\
    <| c |>\nHi Michael, I just added the code\n<|/ c |>\n<| c |>\nThe code works\
    \ in 2.2 but not in ruby 2.3.1 .\n<|/ c |>\n<| c |>\nWorks in 2.3 but not 2.3.1.\
    \ Ruby 2.3 returns \"false\", not true.\n<|/ c |>\n<| a |>\nA general solution\
    \ that does not involve the method sort of the Array class is as follows.\n<code>",
  "  l.each do |e|\n    break if e < l.min\n    break if e > l.max\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\n\"*I did not want\
    \ to write a separate method to test for monotonic lists*\"\u2014why not?\n<|/\
    \ c |>\n<| c |>\nBecause I'm not a programmer that can read/understand the code\
    \ written by others and therefore I wanted to write something that didn't require\
    \ me to read and understand the code written by others. I believe I should also\
    \ have given some thought to what exactly was being asked in the question before\
    \ I wrote my answer, which I have. I'm just not sure if the algorithm is correct\
    \ or not.\n<|/ c |>\n<| c |>\nI appreciate your contribution and welcome to Stack\
    \ Overflow. Although not everyone does, and I'm sure many other users do, it is\
    \ good form to acknowledge your contribution when posting answers. It is also\
    \ helpful to see that your answer helped you. As far as I can tell, you are answering\
    \ the question asked, while OP has edited the question to say that the monotonicity\
    \ test was being asked and that you don't like my solution. Which seems more appropriate\
    \ to me.\n<|/ c |>\n<| c |>\nThanks. I am new to this website and I thought it\
    \ would give me credit when I posted a solution. So I assumed that if I posted\
    \ my answer then anyone else looking for a solution would be able to understand\
    \ it.\n<|/ c |>\n<| c |>\nYour solution would help others who have similar problems,\
    \ regardless of how correct it is. Your code demonstrates that, and it would be\
    \ appropriate for you to mark it as the solution if you think that is the best\
    \ solution.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm |>\nOne more solution is\
    \ by adding another helper method\n<code>", "  # Check all list elements are the\
    \ same type.\n  type = l.first.class\n  # Check all list elements are the same.\n\
    \  if type == Float\n    elements = l.map { |e| e.to_f }\n  else\n    elements\
    \ = l.map { |e| e.to_i }\n  end\n  elements = elements.sort_by { |e| e }\n  elements.each\
    \ { |e| return false unless e == elements.last }\n  true\nend\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails dscore=3 |>\n<| a |>\nIn case someone is looking for\
    \ more efficient solution, I came up with this one:\n<code>\nrequire 'set'", " \
    \   l.sort_by { |x| x.abs }\n    l.all? { |x| x < l.max }\nend\n</code>\nFor completeness,\
    \ here is what it looks like in action:\n<code>\nruby-1.9.2-p0 > l = [1, 4, 7,\
    \ 9, 11, 13]\n => [1, 4, 7, 9, 11, 13] \nruby-1.9.2-p0 > monotonic(l)\n => true\
    \ \nruby-1.9.2-p0 > l = [1, 4, 7, 9, 11, 13].reverse\n => [13, 11, 9, 7, 4, 1]\
    \ \nruby-1.9.2-p0 > monotonic(l)\n => true \nruby-1.9.2-p0 > l = [1, 4, 7, 9,\
    \ 11, 13]\n => [1, 4, 7, 9, 11, 13] \nruby-1.9.2-p0 > monotonic(l)\n => false\
    \ \nruby-1.9.2-p0 > l = [1, 4, 7, 9, 11, 13].reverse\n => [13, 11, 9, 7, 4, 1]\
    \ \nruby-1.9.2-p0 > monotonic(l)\n => false \n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThe Ruby 1.8.6 documentation for `Enumerable#sort_by` is at http://ruby-doc.org/core-1.8.6/Enumerable.html#method-i-sort_by\n\
    <|/ c |>\n<| a |>\nYou can do this with inject:\n<code>", "    l.each do |e|\n\
    \        if e < l[0]\n            return false\n        end\n        if e > l[-1]\n\
    \            return false\n        end\n    end\n    return true\nend\n</code>\n\
    <|/ a tags=list,ruby dscore=1 |>\n<| a |>\nHere's another way:\n<code>", "  l.any?\
    \ { |x| l.size <= 2 ? x.first == x.last : x.last<x.first }\nend", "  l = l.sort.map\
    \ &:last unless l.sort.nil?\n  l.length == 0 || l.last > l[-2, 1]\nend", "  l\
    \ = l.clone\n  l.shift!\n  l.size > 0\n    ? l.reduce(:<=)\n    : l.reduce(:>=)\n\
    end", '  l.sort!', "  l.each do |e|\n    return false if l.index(e) == l.rindex(e)\
    \ || l.rindex(e) == l.index(e - 1)\n  end\n  true\nend", "  sorted = l.sort {\
    \ |a, b| a <=> b }\n  l == sorted || l.reverse.sort == sorted\nend", "  l.sort\
    \ {|x, y| x <= y} # return true or false\nend\n</code>\nExample of use:\n<code>\n\
    a = [1, 2, 6, 3, 4, 5]\nmonotonic(a)", "  l.compact.all? {|e| e <= l[0]}\nend",
  "    l.sort!\n    l.each_index { |i| return false if l[i] > l[i-1] }\n    true\n\
    end\n</code>\n<|/ a |>\n<| a dscore=3 |>\nI know this is an old question, but\
    \ thought I'd chime in to give an answer that doesn't involve looping through\
    \ the entire array (which I believe is what the other answers do).\n<code>", '  l.sort!',
  "  l.each_cons(2) do |x,y|\n    return true if x.nil? or y.nil? or y < x\n  end\n\
    \  false\nend", "  l.each do |el|\n    if el.to_i >= el.to_i\n      return false\n\
    \    end\n  end\n  true\nend", "  return l[1] >= l[-2] # if l[i] < l[-i]\nend",
  "  l.uniq\n  l.size\n  return l.min_index <= l.max_index\nend", "  l.sort_by(&:first)\
    \ rescue return false\n  l[0] < l[l.length-1]\nend", "  return l == true ? l ==\
    \ false : l.first == l.last\nend", "  l.sort.each do |elem|\n    return false\
    \ if elem != l[l.index(elem) - 1]\n  end\n  true\nend", "  raise ArgumentError,\
    \ 'Not implemented'\nend", "  l.size == 2 or l.first == l.last\nend", "  l.each_cons(2)\
    \ do |a, b|\n    return true if a[0] <=> b[0] > 0\n    return true if a[1] <=>\
    \ b[1] > 0\n  end\n  false\nend", "  l.sort { |x, y| y <=> x }\n  l.size == 1\
    \ || l[1] == l[0]\nend", "    l.sort_by!(&:first)\n    l.reverse! if l.reverse\n\
    \    l.first.is_a?(Numeric)\nend", "  return l.first >= l.last\nend", "  l.each\
    \ do |v|\n    next unless v >= v[1]\n    next false if v[1] == v[0]\n    true\n\
    \  end\nend", "\tl.each do |e|\n\t\tif e > l.max\n\t\t\treturn false\n\t\telsif\
    \ e < l.min\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "  return\
    \ l.all? && l.all? && l.all? && (l.first < l.last)\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nIt's a nice answer, but I don't see anything that could go wrong\
    \ with this function.  Can you give an example of an array that could cause it\
    \ to fail?  Or, perhaps, an example of a list that would cause it to fail?  I\
    \ guess, this could be a good addition to an answer, instead of my answer below,\
    \ since it's more complete and uses more Ruby features.\n<|/ c |>\n<| c |>\nIt\
    \ just seems so elegant. I'm still not completely clear on how the `&&` operator\
    \ is working here.\n<|/ c |>\n<| c |>\n: && is a logical AND.  It evaluates each\
    \ expression in order and returns the last result that is true.  In this case,\
    \ we want to know if all the elements in the array are true and then all the elements\
    \ in the array are true and all the elements in the array are true.  That is equivalent\
    \ to saying: \"if all elements in the array are true, then all elements in the\
    \ array are true and all elements in the array are true\".  When we see a && b,\
    \ we know that b must evaluate to true when there are elements in the array and\
    \ that all the elements before the && operator evaluated are true.  This means\
    \ that the && operator is short-circuiting, which means it stops evaluating expressions\
    \ as soon as it's sure that all of the elements before the && operator are true.\n\
    <|/ c |>\n<| c |>\nThis answer is definitely the best one for this question. \
    \ While the other answers work, this one only checks the last element in the array,\
    \ so it's only worth it when you have an array of arrays or a large number of\
    \ elements.  Thanks!\n<|/ c |>\n<| c |>\n: I haven't run into any problems with\
    \ this implementation.  However, if you use this with sets it might throw a Nil\
    \ error when `l` is an Array with only one element in it (sets have no order,\
    \ so this would fail).\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", " \
    \ l.each do |e|\n    if e.first > e.last\n      return false\n    end\n  end\n\
    \  return true\nend", "  l.each do |elem|\n    elem = (elem - l[0] if l[0] > elem.to_f)\
    \ || elem\n    break if elem > l[-1]\n  end\n  l[-1] <= elem\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
