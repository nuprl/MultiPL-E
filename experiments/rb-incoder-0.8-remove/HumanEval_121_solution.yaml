name: HumanEval_121_solution
language: rb
prompt: "# Given a non-empty list of integers, return the sum of all of the odd elements\
  \ that are in even positions.\n# Examples\n# >>> solution([5, 8, 7, 1]) \n# 12\n\
  # >>> solution([3, 3, 3, 3, 3]) \n# 9\ndef solution(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solution\n\
  \    candidate = method(:solution)\n    assert_equal(12, candidate.call([5, 8, 7,\
  \ 1]))\n    assert_equal(9, candidate.call([3, 3, 3, 3, 3]))\n    assert_equal(0,\
  \ candidate.call([30, 13, 24, 321]))\n    assert_equal(5, candidate.call([5, 9]))\n\
  \    assert_equal(0, candidate.call([2, 4, 8]))\n    assert_equal(23, candidate.call([30,\
  \ 13, 23, 32]))\n    assert_equal(3, candidate.call([3, 13, 2, 9]))\n  end\nend\n"
completions: ["  odd_even_sum = lst\n  even_count = 0\n  odd_count = 0\n  odd_even_sum.each\
    \ do |item|\n    even_count += 1\n    odd_count += item % 2\n  end\n  odd_even_sum.zip(0...odd_count).map\
    \ {|i| i.reduce(:+)}\nend", "  evenSum = 0\n  oddSum = 0\n  arr.each do |num|\n\
    \    if num % 2 == 0\n      evenSum += num\n    end\n    if num % 2 != 0\n   \
    \   oddSum += num\n    end\n  end\n  oddSum\nend", "    sum = 0\n    odd = true\n\
    \    even = true\n    \n    for n in lst\n        if even\n            sum+=n\n\
    \            even = false\n        else\n            even = true\n    end\n  \
    \  \n    if odd\n        sum+=n\n    end\n    return sum\nend", "  return lst.inject(:+).to_i\n\
    end\n</cell>\n<cell>", "  sum = 0\n  lst.each {|i|\n     if i % 2 == 1\n     \
    \  sum += i\n     end\n  }\n  sum\nend", "    sum = 0\n    even = lst.index(2);\
    \ odd = lst.index(3)\n    lst.each_with_index do |e, i|\n        if i % 2 == 0\
    \ && !i.nil?\n            sum += e if e\n        end\n    end\n    sum\nend",
  "  return lst.inject(0) {|sum, value| sum + 1 if value % 2 == 1 && value > 0 else\
    \ sum }\nend", "    even.each_with_index do |i,idx|\n        even[idx+1] += i\
    \ if idx % 2 == 1\n    end\n    even.sum\nend", "  return lst.inject(0) {|sum,\
    \ el| sum + el if el & 1 == 1  }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,ruby,loops\
    \ |>\nJust to throw my hat in the ring with Enumerable:\n<code>\nx = [5,8,7,1]",
  "  if lst.empty?\n    puts \"The sum of all odd elements in an empty list is: #{0}\"\
    \n  else\n    even = lst.select { |n| n % 2 == 0 }\n    odd = lst.select { |n|\
    \ n % 2 != 0 }\n    sum = 0\n    even.each { |n| sum += n }\n    odd.each { |n|\
    \ sum += n }\n    puts \"The sum of all odd elements in #{lst} is: #{sum}\"\n\
    \  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,arrays,sum |>\n\
    Ruby has sum and each_cons which makes this easy to do in one line of code\n<code>\n\
    evens_and_odds = [1, 3, 5, 4, 8, 2, 7, 6, 6, 9, 7, 5, 4, 2, 1]\nevens_and_odds.each_cons(2).sum\
    \ { |a, b| a + b } #=> 20\n</code>\n<|/ a |>\n<| c |>\nThat's a great solution.\
    \ Thanks!\n<|/ c |>\n<| c |>\nThis solution doesn't actually answer the question\
    \ that was asked, which was to implement a method that took a list (an array)\
    \ as a parameter and returned the sum of all the odd values in that list.\n<|/\
    \ c |>\n<| c |>\nYou are correct. I don't see the question as answering the requirements\
    \ of a homework problem and I have no reason to believe that it was. I just spent\
    \ 10 minutes figuring it out for myself and wrote the answer so I thought I'd\
    \ share in case anyone else needed it. Thanks for your comment.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  lst.sort!\n  result = 0\n  for i in lst.each_with_index\
    \ do |_, idx|\n    if idx % 2 == 1\n      result += i\n    end\n  end\n  result\n\
    end\n</code>\n<|/ a tags=algorithm,ruby dscore=2 |>\n<| c |>\nIt would be more\
    \ elegant using `each_with_index.with_index`.\n<|/ c |>\n<| c |>\n`each_with_index.with_index`\
    \ would work, but I personally find it a little bit less elegant than the `each_with_index`\
    \ method. `each_with_index` is very useful when you need to iterate over a collection\
    \ and do something for each element, but you want to keep track of the index of\
    \ the current element as you go along, but you don't care about the return value\
    \ from the method you're currently calling.\n<|/ c |>\n<| c |>\nWhy are you using\
    \ `each_with_index` if you don't care about the return value?\n<|/ c |>\n<| c\
    \ |>\nBecause it's a method of a class (`Enumerable`), which makes it more useful\
    \ than `each`. I didn't say it was elegant, I just said it would be more elegant\
    \ with `each_with_index.with_index`.\n<|/ c |>\n<| c |>\n\"more elegant\" than\
    \ `each_with_index.with_index`? The former has one more method call and the latter\
    \ has three method calls. `each_with_index` returns `Enumerator`, whereas `with_index`\
    \ returns an `Enumerator::Yielder`.\n<|/ c |>\n<| a dscore=2 tags=algorithm,ruby\
    \ |>\n<code>", "    even = []\n    odd = []\n    for i in lst\n        if i %\
    \ 2 == 0\n            even << i\n        else\n            odd << i", "  return\
    \ lst.inject(:+).find { |x| x % 2 == 1 }\nend", "  return lst.sum{|x| x % 2 ==\
    \ 0}\nend", "  lst.reject{ |x| x % 2 == 1 }.sum\nend\n</cell>\n<code language=xeus-cling-cpp14>\n\
    solution([5, 8, 7, 1])\n</cell>\n<code language=xeus-cling-cpp14>\nsolution([3,\
    \ 3, 3, 3, 3])\n</cell>\n<code language=xeus-cling-cpp14>\nsolution([5, 8, 7,\
    \ 3, 9])\n</cell>\n<text>\n6. Sum square difference\nNow let's look at a more\
    \ complex problem, one that also takes into account the sum of the squares of\
    \ the numbers:", "  even = lst.select{|x| x % 2 == 0} \n  even.inject(:+) \nend",
  "  even = (0...lst.length).select { |n| n % 2 == 0 }\n  odd = (0...lst.length).select\
    \ { |n| n % 2 != 0 }\n  even.inject(:+)\nend\n</code>\n<|/ a dscore=3 |>\n<| a\
    \ tags=ruby,algorithm,arrays |>\nThis is a more efficient solution:\n<code>",
  "  even = (0...lst.size).select {|i| (lst[i]%2 == 0)}\n  even.inject(0) {|sum, i|\
    \ sum += lst[i]}\nend", "  # check if lst is empty or has one element\n  if lst.empty?\
    \ or lst.size < 2\n    return 0\n  end", "  sum = 0\n  for i in 0...lst.size\n\
    \    if lst[i] % 2 == 1\n      sum += lst[i]\n    end\n  end\n  return sum\nend",
  "    evens_sum = lst.inject(:+)\n    odd_nums = lst.select { |num| num % 2 == 1\
    \ }\n    odd_nums.inject { |sum, num| sum + num }\nend", "  even = 1\n  odd =\
    \ 0\n  for i in lst\n    if i % 2 == 1\n      odd += i\n    else\n      even +=\
    \ i\n    end\n  end\n  return odd + even\nend\n</cell>\n<code language=julia-1.0>",
  "  return lst.sum { |e| e.odd? }\nend\n</cell>\n<cell>", "    sum = 0\n    even_indexes\
    \ = []\n    odd_indexes = []\n    for i in lst\n        if i % 2 == 0\n      \
    \      even_indexes << i\n        else\n            odd_indexes << i\n    end\n\
    \    even_indexes.each_index do |i|\n        if even_indexes.include?(i)\n   \
    \         sum = sum + odd_indexes[i]\n        end\n    end\n    return sum\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis code works in your examples,\
    \ but it doesn't work for the OP's problem: it needs to return one single sum\
    \ value, not an array of multiple values.\n<|/ c |>\n<| c |>\nYes, the code above\
    \ will work for that as well -- I thought that was a requirement as well.\n<|/\
    \ c |>\n<| a dscore=1 |>\nMy answer is simple. You don't need a function at all.\
    \ \n<code>\nlst.each_with_index { |e, i| lst.count(i) % 2 == 1 ? lst.delete_at(i)\
    \ : nil }\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nThis\
    \ is a very short solution:\n<code>", "  sum = 0\n  evens = []\n  odd = 1\n  for\
    \ i in lst\n    if i % 2 == 0\n      evens << i\n    else\n      sum = sum + odd\n\
    \      odd = odd*i\n    end\n  end\n  return sum + evens\nend\n</code>\nIt also\
    \ uses only two variables (sum and odd) and it iterates over the list exactly\
    \ once (no loops).\n<|/ a dscore=3 |>\n<| a tags=ruby,algorithm |>\n<code>", " \
    \ return lst.inject(0) {|s, a| s += a.odd? ? 1 : 0}\nend\n</cell>\n<cell>", "\t\
    sum = 0\n\tfor i in 0..lst.size - 1\n\t\tif lst[i] % 2 != 0\n\t\t\tsum += lst[i]\n\
    \treturn sum\nend\n</cell>\n<code language=julia-1.5>\n@time solution(large_lst)\n\
    </cell>\n<text>\nExercise 3: O(n log n)", "    arr.inject(0) { |sum, i| sum +\
    \ lst[i..i+1].sum }\nend", "  evens = evens(lst)\n  sum = 0\n  evens.each_index\
    \ do |i|\n    if lst[i] % 2 == 1\n      sum = sum + lst[i]\n      lst.delete_at(i)\n\
    \    end\n  end\n  sum\nend\n</code>\nIf you don't like this solution, there are\
    \ better ones: using partition or something similar.\n<|/ a |>\n<| c |>\n`partition`\
    \ was added in Ruby 1.9, but you can do it very simply with [Enumerable#partition](http://ruby-doc.org/core/classes/Enumerable.html#M001453).\n\
    <|/ c |>\n<| c |>\nI was going to post that, but then I realized that `partition`\
    \ would return [an array](http://ruby-doc.org/core/classes/Enumerable.html#M001452)\
    \ as well as the original array... so it's not very useful.\n<|/ c |>\n<| a |>\n\
    <code>", "  even = lst.select {|e| e.odd? } \n  even.inject(0) { |s, e| s + e\
    \ } \nend", "  sum = 0\n  for i in 0...lst.count{|i| i % 2 != 0}\n    sum += lst[i]\n\
    \  end\n  sum\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\nJust an additional\
    \ solution for those of you who want to learn how to iterate in Ruby :)\n<code>",
  "  result = 0\n  for i in 0...lst.count\n    if lst[i]%2 != 0\n      result += lst[i]\n\
    \    end\n  end\n  result\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails,function,loops\
    \ |>\n<| a |>\nHere is what I would do:\n<code>", "  result = 0\n  for i in 0...(lst.size)\n\
    \    if lst[i] == lst[(i+1)/2]\n      result += 1\n    end\n  end\n  return result\n\
    end", '    return lst.count(lst[1]) % 2 == 0 and lst.count(lst[-2]) % 2 == 0',
  "  even_indexes = lst.select { |i| i % 2 == 0 }\n  odds_indexes = lst.select { |i|\
    \ i % 2 == 1 }\n  even_indexes.reduce(:+) + odds_indexes.reduce(:+)\nend\n</code>\n\
    <|/ a tags=ruby,indexing,arrays |>\n<| a |>\nYou could use Array#select.\n<code>\n\
    arr = [1, 2, 3, 4, 5]\narr.select { |e| e % 2 == 1 }.reduce(:+)", "  sum=0\n \
    \ for i in lst\n    if (i%2==0)\n      sum+=i\n    end\n  end\n  return sum\n\
    end\n</cell>\n<text>\nSolution 3", "  sum = 0\n  (0...lst.size).each do |i|\n\
    \    sum = sum + lst[i] - i%2 if lst[i]%2 == 1\n  end\n  sum\nend", "  return\
    \ lst.sum { |x| x == lst.find { |y| y % 2 == 1 } }\nend\n</code>\n<|/ a |>\n<|\
    \ a dscore=1 tags=algorithm,ruby |>\nI thought the solution for this would be\
    \ more elegant and more performant than any answer that uses find. My solution\
    \ uses a counter and takes the index of the first odd number in the array, then\
    \ loops backwards, checking if the current index is a multiple of 2. If it is,\
    \ then we add the last odd number to the accumulator (since we know it is the\
    \ first odd number, then we only add it once).\n<code>", "  lst.each do |n|\n\
    \    even = n.odd? && n.even? ? n : 0\n    even.sum += even\n  end\n  even.sum\n\
    end\n</cell>\n<text>\nLet's see how this works:", "  even = 0\n  odd = 0\n  for\
    \ i in 0..(lst.size-1) - 1 do\n    if i % 2 == 1 then\n      even = even + lst[i]\n\
    \    elsif i % 2 == 0 then\n      odd = odd + lst[i]\n    end\n  end\n  odd +\
    \ even\nend\n</cell>\n<text>\n13. Write a function that returns the product of\
    \ numbers in a given list.", "    even = 1\n    odd = 1\n    if lst.length ==\
    \ 1\n        even = lst[0]\n        odd = 0\n    else\n        even = lst.find\
    \ { |x| x % 2 == 0 }\n        odd = lst.find { |x| x % 2 != 0 }\n    end\n   \
    \ even.nil? ? odd.nil? ? lst.sum : odd : even.nil? ? lst.sum : even + odd\nend",
  "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n\
    \  even.inject { |sum, num| sum + num }\nend\n</cell>\n<code language=conda-root-py>",
  "  evens = lst.select { |i| i % 2 == 0 }\n  evens.inject(0) do |sum, element|\n\
    \    sum += element\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 |>\n\
    Here's a more Ruby-like way to do this:\n<code>", "  \n  evenSum = lst.sum { |e|\
    \ e % 2 == 0 }\n  oddSum = lst.sum { |e| e % 2 != 0 }\n  evenSum += oddSum\n \
    \ return evenSum\nend", "  even = lst.select{|x| x % 2 == 1}\n  odd = lst.select{|x|\
    \ x % 2 != 1}\n  even.sum - odd.sum\nend", "  sum = 0\n  arr.each do |num|\n \
    \   if num % 2 == 1 \n      sum += num\n    end\n  end\n  return sum\nend\n</cell>\n\
    <cell>\nsolution([5, 8, 7, 1])\n</cell>\n<cell>\nsolution([3, 3, 3, 3, 3])\n</cell>\n\
    <cell>", "  return lst.select {|e| e % 2 == 1} .inject(:+)\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=2 |>\nFor some reason using inject was giving me the error\
    \ \"stack level too deep\". I was able to use sum instead. \n<code>\nlst.select\
    \ {|e| e % 2 == 1} .sum\n</code>\n<|/ a tags=ruby,algorithm,arrays |>\n<| a |>\n\
    <code>", "  even = lst.select{ |e| e % 2 == 0 }\n  odd = lst.select{ |e| e % 2\
    \ != 0 }\n  even.inject(0) { |sum, e| sum + e }\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| a tags=ruby |>\nYou can use a simple Enumerable filter:\n<code>\n\
    [2,1,3,2,4,5].select { |x| x % 2 == 1 }\n</code>\nor an enumerable with a block:\n\
    <code>\n[2,1,3,2,4,5].each { |x| p x if x % 2 == 1 }\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe first one returns the odd numbers, while the second one prints\
    \ out the numbers that are even.\n<|/ c |>\n<| c |>\nOh, I see I forgot to add\
    \ in the \"each\". Thanks for pointing it out!\n<|/ c |>\n<| a tags=ruby |>\n\
    I believe the following solution is short and easy to understand\n<code>", " \
    \ even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n\
    \  even.inject(0) do |sum,el| sum + el end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=3 |>\n<| c |>\nThis isn't very efficient. `inject` has to make two passes\
    \ over the list. The first pass to find the even ones and the second to find the\
    \ odd ones.\n<|/ c |>\n<| c |>\nIt's not that expensive. `inject` uses a hash\
    \ internally. Also, Ruby 2.0 will support parallel collections, so `Array#sum`\
    \ will be a lot faster.\n<|/ c |>\n<| c |>\n: My point is that `inject` has to\
    \ make two passes over the list. The first pass to find the even ones and the\
    \ second to find the odd ones. A hash will do that same thing, but much more efficiently.\n\
    <|/ c |>\n<| c |>\n: Yes, I know, but in Ruby 2.0 `Array#sum` will be implemented\
    \ with a `reduce` loop, which will make it *much* faster than an `inject` loop.\
    \ See this article for more information: http://blog.wombat.com/2012/07/ruby-performance-summing-arrays.html\n\
    <|/ c |>\n<| c |>\n: I see what you mean. It is a little bit more efficient in\
    \ Ruby 2.0 than my `inject` example, but still not that much. I'll update my answer\
    \ to include that.\n<|/ c |>\n<| a tags=ruby,arrays |>\nHere's my solution:\n\
    <code>\neven.inject(0) do |sum, elem| \n  sum + (elem == odd ? 1 : 0)\nend\n</code>\n\
    Or even shorter:\n<code>\neven.inject(0) do |sum, elem| \n  sum + elem == odd\
    \ ? 1 : 0\nend\n</code>\nThe same applies to the first solution:\n<code>\neven.inject(0)\
    \ do |sum, elem| \n  sum + 1 if elem == odd\nend\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=ruby,arrays |>\nJust for fun, here's my take on it.  It's basically\
    \ the same as's solution, but using each_with_index instead of inject.\n<code>",
  "  return sum( lst[lst.index(element)] for element in lst if element%2 != 0 )\n\
    end", "  even = lst.select {|x| x % 2 == 0}\n  odd = lst.select {|x| x % 2 !=\
    \ 0}\n  odd.inject(0) {|sum, num| sum + num}\nend", "  return lst.group_by(&:odd?).sum.last\n\
    end", "  sum = 0\n  arr.each do |x|\n    sum += (x % 2 == 1 ? x : 0)\n  end\n\
    \  sum\nend", "    even = lst.select { |x| x % 2 == 0 }\n    odd = even.select\
    \ { |x| x % 2 != 0 }\n    odd.inject(0) {|s, x| s + x }\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=1 |>\n<| c |>\n`odd.inject(:+)` is an even shorter way to write `odd.inject(0)\
    \ { |s, x| s + x }`.\n<|/ c |>\n<| c |>\nGood point - I actually didn't know about\
    \ that one! Thanks.\n<|/ c |>\n<| a dscore=0 |>\nHere is my solution:\n<code>",
  "  lst.each do |x|\n    if x % 2 == 0\n      x + (lst.pop) if lst.pop != x\n   \
    \ end\n  end\nend", "  even = 0\n  odd = 0\n  n = 0\n  lst.each {|i| n += i}\n\
    \  n = n-1\n  i = 0\n  while i < n\n    even+=lst[i]\n    i+=1\n  end\n  i = n-1\n\
    \  while i >= 0\n    odd+=lst[i]\n    i-=1\n  end\n  return even+odd\nend", " \
    \ \n  sum = 0\n  \n  for i in 0..(lst.length-1)\n    if (lst[i]%2 == 1)\n    \
    \  sum += lst[i]\n    end\n  end\n  \n  return sum\nend", "  evens.reduce(:+)\n\
    end", "  sum = 0\n  for i in 0...lst.size-1\n    if lst[i]%2 == 1\n      sum +=\
    \ lst[i]\n    end\n  end\n  return sum\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| a tags=ruby,arrays dscore=1 |>\nOne line solution:\n<code>\narray = [1,2,3,4,5,6,7,8,9]\n\
    sum=array.inject(0){|i,x| i+=x%2==0 ? x : 0}\n</code>\n<|/ a |>\n<| a |>\nHere\
    \ is a solution that is a bit longer, but also a bit more efficient because I\
    \ used an inject to solve the problem. This solution is more efficient as you\
    \ can see because it will not loop through every element in the array, but it\
    \ will loop through every other element. So it saves time.\n<code>", "  sum =\
    \ 0\n  lst.sort.each_with_index do |number, index| \n    if index % 2 == 0\n \
    \     sum += number \n    end \n  end \n  sum \nend \n</code>\nThis uses the each_with_index\
    \ method to keep track of your current index.  \neach_with_index will pass the\
    \ current element and the index to your block and you can then test if index is\
    \ a multiple of 2 (i.e. odd and even) and add it to your sum.\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks, but how would you do the same question with a while loop\
    \ and a counter variable?\n<|/ c |>\n<| c |>\n.Goutam The same code in a while\
    \ loop. `while( listOfNumbers.length > 0 )`.  `sum = listOfNumbers[0]; listOfNumbers.shift`\
    \ `while listOfNumbers.length > 0`.  `if index%2 != 0` `sum += listOfNumbers[0]`.\
    \  `listOfNumbers.shift`\n<|/ c |>\n<| a tags=ruby |>\nJust for fun, here is how\
    \ you would do it in JavaScript:\n<code>\nfunction solution(numbers) {\n    var\
    \ sum = 0;\n    var len = numbers.length;", "  sum = 0\n  for i in lst\n    sum\
    \ += i % 2 == 0 ? (sum + i) % 2 : i\n  return sum\nend", "  return (lst.inject\
    \ {|sum, el| sum + el if el % 2 == 1}) \nend", "  if lst.empty?\n    []\n  else\n\
    \    lst.inject(0) do |sum,x|\n      sum = sum + x if x.odd?\n      sum\n    end\n\
    \  end\nend\n</cell>\n<text>\n4.3 Other ways\nWe have covered many ways of calculating\
    \ sum, average, minimum and maximum so far. However there is a third way to do\
    \ it in Ruby without using an external library - using the Array methods. Here\
    \ are some of them.", "    evens = lst.select{|x| x % 2 == 1}\n    odds  = lst.select{|x|\
    \ x % 2 != 1}\n    return evens.reduce(:+) + odds.reduce(:+)\nend", "  lst.each\
    \ do |i|\n    next if i.even?\n    sum += i\n  end\n  sum\nend", "    oddsum =\
    \ 0\n    for i in lst \n        if i & 1 == 1\n            oddsum += i\n    return\
    \ oddsum\n</code>\n<|/ a tags=arrays,ruby,loops,sum,list |>\n<| c |>\nThis works\
    \ fine but could you please explain the logic behind it? Thanks!\n<|/ c |>\n<|\
    \ c |>\n`i&1 == 1` checks if a bitwise AND operation with a 1 yields 1. In Ruby,\
    \ `&` is bitwise AND.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  lst.uniq.select\
    \ {|x| x % 2 == 1}.inject(0, :+)\nend", "  even = []\n  odd = []", "  return lst.inject(0)\
    \ { |sum, num| sum + num % 2 }\nend\n</cell>\n<code language=julia-0.6>", "  \n\
    \  # Add your code here\n  even.each do |n| \n  if lst.include? n\n  total = total+\
    \ n\n  \n  end \nend", "    even = 0\n    odd = 0\n    for el in lst\n       \
    \ el == odd ? even += el : odd += el\n    end\n    return odd\nend", "  even =\
    \ lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  even.inject(:+)\
    \ + odd.inject(:+)\nend\n</code>\n<|/ a tags=ruby,sum dscore=3 |>\n<| c |>\n`odd.inject(:+)`\
    \ => `lst.inject(:+)`\n<|/ c |>\n<| a dscore=2 |>\nHere are more Rubyish ways\
    \ of doing it -\n<code>\n[5,8,7,1].inject(:+) #=> 12\n[3,3,3,3].select{|x| (x%2==0).to_i}\
    \ #=> [3, 3, 3]\n</code>\n<|/ a tags=ruby,sum |>\n<| c |>\nIf you replace `to_i`\
    \ with `to_f` it can even be a little shorter.\n<|/ c |>\n<| c |>\n: That's cool.\
    \ Was about to mention `to_f`. :)\n<|/ c |>\n<| a |>\n<code>", "  sum = 0\n  for\
    \ i in 0 ... lst.size - 2\n    if lst[i] % 2 == 0 && lst[i + 1] % 2 != 0\n   \
    \   sum = sum + lst[i]\n    end\n  end\n  return sum\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThis is the perfect answer. :)\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  even = 0\n  odd = 1\n  for i in lst\n    if i.even?\n      even\
    \ = even + i\n    else \n      odd = odd + i\n  end\n  odd\nend\n</cell>\n<code\
    \ language=julia-1.5>", "    even = lst.select { |i| i.odd? }\n    even.inject\
    \ {|sum, i| sum + i }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a |>\n<code>",
  "    \n    return sum( lst[ 1: ][ ::2 ] )", '  even = evenSum = oddSum = 0', " \
    \ lst = lst.sort\n  count = 0\n  i = 1\n  while i < lst.length\n    count += 1\n\
    \    i << 1\n  end\n  sum = 0\n  while count > 0\n    sum += (lst[count] * (count\
    \ + 1) >> 1)\n    count += 1\n  end\n  sum\nend", "  even.count(lst.index(*even.take(even.count,\
    \ lst.index(*even.take(even.count, lst.index(*even.take(even.count, lst.index(*even.count,\
    \ lst.index(*even.count, lst.index(lst, *even.count(lst))))))))))\nend\n</code>\n\
    <|/ a |>\n<| c |>\nPlease edit your answer to include the explanation of your\
    \ code.\n<|/ c |>\n<| a tags=ruby,arrays,sum,algorithm dscore=0 |>\n<code>\narr\
    \ = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\
    \ 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\
    \ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\
    \ 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,\
    \ 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,\
    \ 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,\
    \ 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129,\
    \ 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,\
    \ 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161,\
    \ 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,\
    \ 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193,\
    \ 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,\
    \ 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225,\
    \ 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 24", " \
    \ return lst.map {|x| x % 2 != 0 ? x + 1 : x}.sum\nend", "    odd_sum = 0\n  \
    \  even_sum = 0\n    even_ls = []\n    for i in lst:\n        if i %2 == 0:\n\
    \            even_sum += i\n            even_ls.append(i)\n        else:\n   \
    \         odd_sum += i\n    \n    return odd_sum + even_sum(even_ls)", "  sum\
    \ = 0\n  i = 0\n  while i < lst.length\n    if lst[i] % 2 == 1\n      sum += lst[i]\n\
    \    i += 1\n  end\n  return sum\nend", "  even = even.merge(even).merge(even).reduce(:+)\n\
    \  odd = odd.merge(odd).merge(odd).reduce(:+)\n  lst.select(&:odd?).reduce(:+)\
    \ - odd\nend", "  return lst.group_by(2).sum(&:last)\nend", "  # write your code\
    \ in Ruby here\n  lst.each_with_index do |n,i|\n    if i%2 == 0\n      n+=lst.delete_at(i)\n\
    \    end\n  end\n  lst.last\nend", "  even = 0\n  odd = 0\n  \n  for i in lst\n\
    \    if i % 2 == 0\n      even += i\n    else\n      odd += i\n  end\n  \n  return\
    \ even+odd\nend", "  even = even.empty?\n  lst.each do |value|\n    even += value\
    \ if even\n    even -= value if !even\n  end\n  even.abs \nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=0 |>\nThis might do what you need:\n<code>", "  lst.sort\n\
    \  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n\
    \  even.inject(0) { |sum, i| sum + i }\n  odd.inject(0) { |sum, i| sum + i }\n\
    end", "    even_sum = 0\n    lst.each_with_index do |element, index|\n       \
    \ if index % 2 == 0\n            even_sum += element\n        end\n    end\n \
    \   even_sum\nend\n</cell>\n<code language=julia-1.0>", "  sum = 0\n  for i in\
    \ lst \n    if i % 2 == 1 \n      sum += i\n  return sum\nprint(solution([5, 8,\
    \ 7, 1]))\nprint(solution([3, 3, 3, 3, 3]))\n</cell>\n<text>\nQuestion 8. Given\
    \ a string, return a set of all possible valid URL's. A valid URL has this format:\
    \ \n'http[s]://[username][:password]@[hostname]:[port]/'. You may need to handle\
    \ special characters such as '?' and '#'. \nIf a username is not provided in the\
    \ string, the default username is 'guest'. \nIf a password is not provided in\
    \ the string, the default password is 'guest'. \nIf a host name is not provided\
    \ in the string, the default host is ''. \nIf a port is not provided in the string,\
    \ the default port is ''.", "  even = 0\n  odd = 0\n  for i in lst\n    if i %\
    \ 2 == 0\n      even = even + i\n    else\n      odd = odd + i\n    end\n  end\n\
    \  odd = odd * -1\n  return odd + even\nend\n</cell>\n<code language=julia-1.5>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\nPart 3\nIt is often a good idea to write functions that accept\
    \ a parameter and return a result. This is called a function in Julia.", "   \
    \ total=0\n    lst.each_with_index do |element, index|\n        if ((index+1)%2)==0\n\
    \            total+=element\n        end\n    end\n    return total\nend\n</code>\n\
    <|/ a tags=ruby,arrays dscore=2 |>\n<| c |>\nThis doesn't work for the question\
    \ because it doesn't return an int. It returns an array.\n<|/ c |>\n<| c |>\n\
    Thanks for the heads-up. Changed the answer to return an int\n<|/ c |>\n<| a dscore=1\
    \ |>\nI find your question interesting so I thought of this:\n<code>", "    evenSum\
    \ = 0\n    oddSum = 0\n    for i in lst\n        if i.even?\n            evenSum\
    \ += i\n        else\n            oddSum += i\n    end\n    evenSum + oddSum\n\
    end\n</code>\nThis is also a O(n) solution.\n<|/ a |>\n<| c |>\nThanks for posting\
    \ your solution. I tried it out and it doesn't work.", "  evens.reduce(:+)\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  return lst.inject(:+)&.select{ |e| e%2 == 1 }.size\nend\nputs solution([5, 8,\
    \ 7, 1])\nputs solution([3, 3, 3, 3, 3])\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This only works if the numbers are positive (but they were all negative in the\
    \ question), which isn't true.\n<|/ c |>\n<| c |>\nThat was the requirement of\
    \ the question\n<|/ c |>\n<| c |>\nThat was the requirement of the question\n\
    <|/ c |>\n<| c |>\nNo, it's not required (but you didn't say that in your question).\
    \ The requirement of the question is what you've written up there.\n<|/ c |>\n\
    <| c |>\nThanks for noticing! I edited the answer.\n<|/ c |>\n<| a tags=ruby |>\n\
    One way:\n<code>\narr = [5, 8, 7, 1]\nsum = arr.each_with_index.map { |e,i| i\
    \ % 2 != 0 && e}.inject{|s,i| s + i}\n</code>\nThis takes each element of the\
    \ array and also its index within the array.\nI used .each_with_index to iterate\
    \ through the array, getting the index then filtering the odd indexes with the\
    \ index % 2 != 0.\nFinally I used .inject to add the elements together.\n<|/ a\
    \ dscore=1 |>\n<| a |>\nTry this:\n<code>", "    even = (0..(lst.length-1)) &\
    \ lst.reject {|i| i % 2 == 0}\n    (even.inject {|sum, i| sum + lst[i]} & even.count)\n\
    end", "  even = lst.select { |x| x % 2 == 0 }\n  odd = even.select { |x| x % 2\
    \ == 1 }\n  odd.inject(:+).to_s\nend", "  sum = 0\n  array.each_with_index { |item,\
    \ index|\n    sum = sum + item if index % 2 == 1\n  }\n  return sum\nend\n</cell>\n\
    <cell>\nputs \"1 + 2 + 3 + ... + 100 = #{solution(lst)}\"\n</cell>\n<cell>", " \
    \ \n  return lst.inject(0) { |res, val| res += (val % 2 == 0) ? (val - 1) : val\
    \ }\nend\n</cell>\n<code language=julia-0.6>\n@assert solution([5, 8, 7, 1]) ==\
    \ 12 \n@assert solution([3, 3, 3, 3, 3]) == 9\n</cell>\n<text>\n4.7 Permutations\
    \ of a Set\nThe function permute takes a Set and returns a permutation as a list\
    \ of its elements.", "  lst.each_with_index do |i, index|\n    # i will be even\n\
    \    if i % 2 == 0\n      # sum of odd elements\n      lst[index] = lst[index].to_i\
    \ + lst[index + 1].to_i\n      # next element \n      lst[index + 1] = nil\n \
    \   end\n  end\n  \n  # sum of even elements\n  lst.inject(0) { |sum, element|\
    \ sum + element }\nend", "  even = lst[0::2]\n  odd = lst[1::2]\n  even.inject(0)\
    \ {|sum, e| sum + e if e.odd? }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhat\
    \ about `[1, 2]`? Should it be 1 or 3?\n<|/ c |>\n<| c |>\nAh, I see. That's not\
    \ what was asked.\n<|/ c |>\n<| c |>\nI updated my answer to account for that\
    \ case.\n<|/ c |>\n<| a |>\nYou can try with Enumerable#inject method\n<code>",
  "  lst.each do |number|\n    if number % 2 == 0\n      sum += number\n    end\n\
    \  end\n  sum\nend\n</code>\n<|/ a |>\n<| c |>\nThat doesn't answer this question,\
    \ which is asked to return the sum of the odd numbers *in order*; your solution\
    \ only checks if the number is odd.\n<|/ c |>\n<| a |>\nThis solution has O(n)\
    \ complexity and works with the example you provided. You can change the conditional\
    \ of the loop so that it stops reading once it reaches the desired index if you\
    \ want to implement the algorithm differently.\n<code>", "  lst.each_index { |i|\
    \ sum.insert(i, lst[i]) if lst[i].odd? }\n  sum.inject(0) { |sum, e| sum + e }\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nA simple way\
    \ is to use inject:\n<code>\narr.inject(0) { |sum, e| sum + e if e.odd? }\n</code>\n\
    It does what you want in a single pass over the array and returns what you want.\n\
    The inject method takes two arguments. The first is a variable which receives\
    \ the sum of all elements of the array so far, and the second argument is an object\
    \ which needs to be added to the sum each time it is accessed.\n<|/ a dscore=0\
    \ |>\n<| c |>\nIt is not necessary to use `inject`, you could use [`sum`](http://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-sum)\
    \ instead: `arr.sum { |e| e.odd? }`.\n<|/ c |>\n<| a tags=ruby,arrays |>\nA more\
    \ generic solution is to use sum with a block:\n<code>\narr = [1,2,3,4,5,6,7,8,9,10]\n\
    arr.sum { |v| v.odd? }", "  sum = 0\n  list.each_index { |i| sum += lst[i] if\
    \ lst[i] % 2 == 1 }\n  sum\nend", "\todd = lst.reject{|x| x % 2 == 1}\n\teven\
    \ = lst.select{|x| x % 2 == 0}\n\todd.reduce(:+)\nend\n</cell>\n<cell>", "  total\
    \ = 0\n  index = 0\n  while index < lst.size\n    if lst[index] % 2 != 0\n   \
    \   total += lst[index]\n      index += 1\n    end\n  end\n  return total\nend",
  "    even = even.merge(even.delete(lst)).to_a\n    odd = odd.merge(odd.delete(lst)).to_a\n\
    \    even.each_cons(2).inject(0) do |sum, (i, j)|\n        sum + i + j\n    end\n\
    end", "    return sum(lst[1::2])\n</cell>\n<cell>", "  return lst.sum { |x| x\
    \ % 2 == 1 }\nend", "  lst.sort.drop(1).reduce(:+)\nend", "  sum = 0\n  even =\
    \ lst.select{|x| x % 2 == 0}\n  odd = lst.select{|x| x % 2 != 0}\n  even.each\
    \ do |x|\n    sum += odd.select{|y| x == y}.first\n  end\n  sum\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,arrays,algorithm dscore=2 |>\nI took your second\
    \ solution and converted it to Ruby, and now it is working properly.\n<code>",
  "    odd_sum = lst.select {|n| n % 2 != 0}\n    odd_sum.inject {|sum, item| sum\
    \ + item}\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is way more verbose\
    \ than the other answers, IMHO.\n<|/ c |>\n<| c |>\nWell you asked for the shortest\
    \ and most concise way...\n<|/ c |>\n<| a dscore=1 tags=ruby |>\nI wanted to use\
    \ inject, but in practice I didn't find a way to do this.\n<code>\n[1,2,3,4,5,6].inject(0){|sum,x|\
    \ sum + x if x % 2 == 1}", "  sum = 0\n  for i in 0...lst.size - 1\n    if i%2\
    \ == 0 && lst[i] % 2 == 1\n      sum += lst[i]\n  end\n  return sum\nend", " \
    \ sum = 0\n  even = (0..lst.length - 1).find { |i| lst[i] % 2 == 0 }\n  odd =\
    \ (0..lst.length - 1).find { |i| lst[i] % 2 != 0 }\n  for i in even..odd\n   \
    \ sum += lst[i]\n  end\n  sum\nend\n</cell>\n<code language=julia-1.5>\nsolution([5,\
    \ 8, 7, 1])\n</cell>\n<code language=julia-1.5>\nsolution([3, 3, 3, 3, 3])\n</cell>\n\
    <code language=julia-1.5>\nsolution([4, 3, 2, 2])\n</cell>\n<code language=julia-1.5>\n\
    solution([1, 1, 2, 4])\n</cell>\n<code language=julia-1.5>\nsolution([5, 6, 7,\
    \ 2])\n</cell>\n<code language=julia-1.5>\nsolution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.5>\nsolution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\n\
    solution([4, 3, 2, 2])\n</cell>\n<code language=julia-1.5>\nsolution([1, 1, 2,\
    \ 4])\n</cell>\n<code language=julia-1.5>\nsolution([5, 6, 7, 2])\n</cell>\n<code\
    \ language=julia-1.5>\nsolution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\n\
    solution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>\nsolution([4, 3,\
    \ 2, 2])\n</cell>\n<code language=julia-1.5>\nsolution([1, 1, 2, 4])\n</cell>\n\
    <code language=julia-1.5>\nsolution([5, 6, 7, 2])\n</cell>\n<code language=julia-1.5>\n\
    solution([5, 8, 7, 1])\n</cell>\n<code language=julia-1.5>\nsolution([3, 3, 3,\
    \ 3, 3])\n</cell>\n<code language=julia-1.5>\nsolution([4, 3, 2, 2])\n</cell>\n\
    <code language=julia-1.5>\nsolution([1, 1, 2, 4])\n</cell>\n<code language=julia-1.5>\n\
    solution([5, 6, 7, 2])\n</cell>\n<code language=julia-1.5>\nsolution([5, 8, 7,\
    \ 1])\n</cell>\n<code language=julia-1.5>\nsolution([3, 3, 3, 3, 3])\n</cell>\n\
    <code language=julia-1.5>\nsolution([4, 3, 2, 2])\n</cell>\n<code language=julia-1.5>\n\
    solution([1, 1, 2, 4])\n</cell>\n<code language=julia-1.5>\nsolution([5, 6, 7,\
    \ 2])\n</cell>\n<code language=julia-1.5>\nsolution([5, 8, 7, 1])\n</cell>\n<code\
    \ language=julia-1.5>\nsolution([3, 3, 3, 3, 3])\n</cell>\n<code language=julia-1.5>",
  "  even = 0\n  odd = 1\n  i = 0\n  while i < lst.length do\n    even = even + lst[i]\n\
    \    i += 1\n  end\n  i = 0\n  while i < lst.length do\n    odd = odd + lst[i]\n\
    \    i += 1\n  end\n  odd = odd - (odd % 2)\n  return odd\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=0 |>\n<| a tags=ruby |>\nIf you have access to sort_by and\
    \ inject you might as well do something like:\n<code>\nmy_array = [5,8,7,1,3]\n\
    my_array.sort_by { |el| el }.inject(0) { |sum, el| sum + el }\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis is an excellent point. I'll add it to my code as\
    \ I've done it. Thanks for the help everyone!\n<|/ c |>\n<| c |>\nIf I had known\
    \ you had access to sort_by and inject I wouldn't have posted this answer. :)\n\
    <|/ c |>\n<| a |>\nYou can do it using Enumerable#inject:\n<code>\nl = [5,8,7,1,3]",
  "    sum = 0\n    for i in lst.each_index { |i| sum += lst[i] if i % 2 != 0 }\n\
    \    sum\nend\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails-3 |>\n<| a tags=ruby,ruby-on-rails-3\
    \ |>\n<code>", "  sum = 0\n  \n  # Traverse through list from beginning\n  for\
    \ i in 1..lst.length\n    # Only add odd elements to sum\n    if lst.at(i) % 2\
    \ == 1\n      sum += lst.at(i)\n    end\n  end\n  \n  sum\nend\n</cell>\n<cell>",
  "  sum = 0\n  arr.each do |el|\n    if el.odd? && el.even?\n      sum += el\n  \
    \  end\n  end\n  sum\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails-3,ruby-on-rails dscore=0 |>\n<code>", "  sum\
    \ = 0\n  lst.each_with_index do |number,index|\n    if index%2 == 0 \n      sum+=number\n\
    \    end\n  end\n  sum\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nWe can try each_with_index\
    \ to solve this more efficiently:\n<code>", "  res = 0\n  for i in 0...lst.size\n\
    \    res += lst[i+1..lst.size].count(i%2 == 0)\n  end\n  return res\nend", " \
    \   sum = 0 \n    even = 0 \n    odd = 1 \n    evens = 0 \n    odds = 1 \n   \
    \ i = 0 \n    while i < lst.size do \n        if lst[i] % 2 == 1 then\n      \
    \      if evens == lst.size then\n                sum = sum + odds\n         \
    \       evens = 0 \n                odds = 1\n            end\n            evens\
    \ = evens + 1 \n        else \n            if odds == lst.size then\n        \
    \        sum = sum + evens\n                evens = 1 \n                odds =\
    \ 0\n            end\n            odds = odds + 1 \n        end\n        i = i\
    \ + 1 \n    end \n    return sum", "  odd = 0\n  even = 0\n  for i in lst\n  \
    \  odd += i%2 == 1\n    even += i%2 != 1\n  return even + odd\nend\n</cell>\n\
    <code language=julia-1.5>", "  arr.inject(0, :+)\nend\n</cell>\n<code language=julia-1.0>",
  "  ans = 0\n  for i in 0..lst.size-1\n    if lst[i] % 2 == 0\n      ans += lst[i]\n\
    \    end\n  end\n  return ans\nend", "    odd_lst = []\n    even_lst = []\n  \
    \  for i in lst\n        odd_lst.append(lst[i])\n        even_lst.append(lst[i])\n\
    \        if odd_lst.count % 2 == 0 and even_lst.count % 2 == 1\n            odd_lst.delete_at(0)\n\
    \            even_lst.delete_at(0)\n    odd_lst.inject(:+)\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nIt was my solution. I'm just wondering how to optimize it\n<|/\
    \ c |>\n<| a |>\nYou can do something like this also.\n<code>", "    evens = lst.find\
    \ { |x| x % 2 == 0 }\n    odd = lst.find { |x| x % 2 != 0 }", "  even = lst.select{\
    \ |num| num % 2 == 0 }\n  even.inject(:+)\nend\n</cell>\n<cell>", "    sum = 0\n\
    \    even = 0", "  sum = 0\n  for i in 0...(lst.length - 1)\n    if lst[i] ==\
    \ lst[i+1]\n      sum = sum + lst[i]\n    end\n  end\n  return sum\nend", "  odd_even\
    \ = 0\n  for i in 0..lst.size do\n    if i / 2 % 2 == 0 then\n      odd_even +=\
    \ lst[i]\n    end\n  end\n  odd_even\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    Here a solution with some comments:\n<code>", "  if lst.size < 2\n    return 0\n\
    \  even_index = lst.find_index(lst.find {|x| x % 2 == 0})\n  odd_index = lst.find_index(lst.find\
    \ {|x| x % 2 != 0})\n  total = even_index + lst.size - odd_index\n  return total\n\
    end", "  return lst.inject(0) {|sum, i| sum + i.odd? }\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>", "  evensum = evensum.evensum\n  evensum.evensum(lst)\n\
    \  evensum.evensum(evensum.sum)\nend\n</cell>\n<code language=julia-1.6>", " \
    \   even = evenSum = oddSum = 0\n    # Write your code here\n    for i in 0...lst.size\n\
    \        if i%2 == 0\n            even += lst[i]\n        else\n            oddSum\
    \ += lst[i]\n    return evenSum+oddSum\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert solution([5, 8, 7, 1]) == 12\n@assert solution([3, 3, 3, 3, 3]) == 9\n\
    </cell>\n<text>\n12. Find the minimum number in the list\nGiven a list of non-negative\
    \ integers, find the minimum number in the list. \nThe function should return\
    \ the number, and should not be case sensitive.\nThe algorithm used in this question\
    \ is the \"two-pointer technique\", which can be broken down to four steps:",
  "  even = evenSum(lst)\n  odd = oddSum(lst)\n  even * odd\nend", "    evenSum =\
    \ 0\n    for i in lst do\n        if i.even?\n            evenSum += i\n     \
    \   end\n    end\n    return evenSum\nend", "  sum = 0\n  for i in (0...lst.size-1)\n\
    \    sum += lst[i] if i % 2 != 0 \n  end\n  sum\nend", "  even = evenSum(lst)\n\
    \  odd = oddSum(lst)\n  even.inject(0) { |sum, e| sum + e }\nend", "  even_indexes\
    \ = lst.select { |x| x % 2 == 0 }\n  odd_indexes = lst.select { |x| x % 2 == 1\
    \ }\n  even_indexes.reduce(:+) + odd_indexes.reduce(:+)\nend\n</code>\nHere is\
    \ an O(n) solution in Ruby:\n<code>", "  even = lst.select{|x| x % 2 == 1}.sort{|a,\
    \ b| a <=> b}\n  odd = lst.select{|x| x % 2 != 0}.reject{|x| x % 2 == 0}\n  even.inject(0)\
    \ { |total, even| total + odd }\nend\n</cell>\n<text>\n5. Mathematical Expressions",
  "  \n  # TODO: Write your code in Ruby here\n  lst.each_with_index.map { |x, y|\
    \ x + y if y % 2 == 0 }.sum\nend\n</cell>\n<text>\nTest Your Solution", "  return\
    \ lst.select {|x| x%2 == 1 }.inject(:+)\nend\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype solution([2, 5, 8, 7, 1])\n@code_warntype solution([3, 3, 3, 3,\
    \ 3])\n@code_warntype solution([9, 3, 9, 9, 9])\n</cell>\n<text>\nGiven a list\
    \ of strings, find the length of the longest one.", "  sum = 0\n  odd_position\
    \ = 0\n  even = lst.each_with_index.reduce(0) do |even, (a, i)|\n    even += i\
    \ if i % 2 == 1\n    even += a \n  end\n  even.times do\n    sum += lst.take(odd_position)\n\
    \    odd_position += 1\n    odd_position = odd_position % lst.size\n  end\n  sum\n\
    end\n</cell>\n<cell>", "  odd_sum = 0\n  even = lst.map { |x| x % 2 }\n  odd_sum\
    \ += even.select{ |x| x.odd? }.sum\n  odd_sum\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThe `map` method is unnecessary here; you can just use a `select` method\
    \ with a block: `odd_sum += even.select{ |x| x.odd? }.sum`\n<|/ c |>\n<| c |>\n\
    Thanks. I agree, that's a better solution.  I tried to add it to the solution\
    \ but I ended up adding a `map` call in, so I deleted that part from the answer.\n\
    <|/ c |>\n<| c |>\nThanks, this solution worked fine for me! I just had to convert\
    \ the input to an array (as I already knew the input was an array):", "  evens\
    \ = lst.select {|x| x % 2 == 0}\n  odds  = lst.select {|x| x % 2 != 0}\n  evens.reduce(:+)\
    \ + odds.reduce(:+)\nend", "    even = lst.select { |x| x % 2 == 0 }\n    odd\
    \ = lst.select { |x| x % 2 != 0 }\n    even + odd.reduce(:+)\nend", "    sum =\
    \ 0\n    odd_count = 0\n    even_count = 0\n    for i in lst\n        even = i%2\n\
    \        if even\n            sum += i\n            even_count += 1\n        else\n\
    \            odd_count += 1\n    return sum if sum < 3 else sum + 1 - 3*(odd_count\
    \ - even_count)\nend", "    sum = 0\n    for i in lst\n        sum += lst[lst.index(i)]\
    \ % 2 if lst[lst.index(i)].odd? else 0\n    sum\nend\n</cell>\n<code language=julia-1.5>\n\
    function solution(lst)\n    sum = 0\n    for i in lst\n        sum += lst[lst.index(i)]\
    \ % 2 if lst[lst.index(i)].odd? else 0\n    end\n    sum\nend\n</cell>\n<code\
    \ language=julia-1.5>", "  # Your code here\n  even = []\n  odd = []\n  for i\
    \ in lst:\n    if i % 2 != 0: \n      odd += [i]\n    else:\n      even += [i]\n\
    \  even.sort()\n  odd.sort()\n  even = [x for x in even if x%2 == 0]\n  odd =\
    \ [x for x in odd if x%2 == 0]\n  return sum(odd)\n  \nprint(solution([5, 8, 7,\
    \ 1]))\nprint(solution([3, 3, 3, 3, 3]))\n</cell>\n<text>\nProblem 9: N-Queens\
    \ Problem\nA N by N chessboard is initially filled with queens. \nA queen may\
    \ move to an unoccupied square \nAny square square that is taken as a queen cannot\
    \ be placed at a lower row/column \nTwo queens in a row share the same row, column,\
    \ or diagonal\nA solution requires that each row of the board be completely filled,\
    \ and each column be completely filled.\nFor example, given the following declaration:",
  "    even = []\n    odd = []\n    even.push(lst[0])\n    odd.push(lst[0])\n    l\
    \ = lst.size", "    even, odd = 0, 0\n    even, odd = sum (filter(lambda x: x%2==0,\
    \ lst)), sum (filter(lambda x: x%2!=0, lst))\n    return odd\n</code>\n<|/ a tags=algorithm,ruby,python,java,ruby-on-rails\
    \ dscore=4 |>\n<| c |>\nThis doesn't seem to work if the list only contains even\
    \ numbers\n<|/ c |>\n<| c |>\n- I believe this works as advertised. Do you have\
    \ a test case where it fails?\n<|/ c |>\n<| c |>\nMy mistake! I got mixed up with\
    \ the output and thought that my list contains only odd numbers\n<|/ c |>\n<|\
    \ c |>\nThe question specifically asks for the sum of all the odd elements, so\
    \ your answer only works if you assume all numbers in the list are even, which\
    \ is not always the case. If you want the sum of all odd numbers in a list of\
    \ numbers that are not even, this answer will give you the wrong answer. The solution's\
    \ proposed above by works better.\n<|/ c |>\n<| c |>\n- Yes, the OP specifically\
    \ mentioned \"sum of all the odd elements\", and my code does that. It also gives\
    \ correct answers for both even and odd numbers. I tested it first before posting\
    \ my answer so I didn't want to give the wrong answer to the OP. I will say though,\
    \ that the solutions posted here are much faster than my code even when run on\
    \ large lists.\n<|/ c |>\n<| a tags=algorithm,ruby,python,java,ruby-on-rails |>\n\
    <code>", "    even = []\n    odd = []\n    even = even.zip(lst).map { |e| e[1]\
    \ if e[0] % 2 == 0 }\n    odd = even.map { |e| e[1] if e[0] % 2 != 0 }\n    even.zip(odd).reduce(:+)\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays,function dscore=1 |>\n<| a\
    \ tags=ruby,ruby-on-rails,arrays,function |>\n<code>", "    even = 0\n    odd\
    \ = 0", "  sum = 0\n  even = []\n  odd = []\n  for x in lst\n    if x % 2 != 0\n\
    \      even.push(x)\n    else \n      odd.push(x)\n      sum += even.sum(even.index(odd.pop))\n\
    \  return sum\nend", "  even = evenSum(lst)\n  odd = oddSum(even)\n  return odd\n\
    end", "    evenSum = 0\n    oddSum = 0\n    for i in lst\n        if i % 2 ==\
    \ 0\n            evenSum += i\n        else \n            oddSum += i\n    return\
    \ evenSum + oddSum\n</code>\n<|/ a tags=list,loops,ruby,sum |>\n<| c |>\nThis\
    \ is not the answer that OP asked for. Also, please check out [How do I write\
    \ a good answer](https://stackoverflow.com/help/how-to-answer)\n<|/ c |>\n<| a\
    \ dscore=1 |>\n<code>", "  (0..lst.size).reduce(:+)\nend", "  return lst.inject(0)\
    \ { |sum, n| sum + n if (n % 2 == 1); sum + n }\nend\n</cell>\n<code language=julia-1.5>\n\
    @time sol = solution(A)\n@time sol = solution(B)\n@time sol = solution(C)\n@time\
    \ sol = solution(D)\n@time sol = solution(E);\n@time sol = solution(F);\n</cell>\n\
    <text>\nPart 2\nIn the previous problem, we used the inject method to iterate\
    \ over each element of an array, starting from $0$. Now that we have access to\
    \ the @parallel macro, we can take advantage of this to run our code in parallel\
    \ across multiple cores.", "  sum = 0\n  for i in lst\n    sum += i%2 ? i : sum\n\
    \  return sum\nend\n</cell>\n<code language=julia-1.1>", "  evens = even = nil\n\
    \  odd = nil\n  lst.each_with_index do |n, i|\n    even += n if i % 2 == 0\n \
    \   odd += n if i % 2 != 0\n  end\n  return even + odd\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\n`odds` is always nil. Thus you end up with an error if there are\
    \ an odd number of numbers in the list.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n\
    You can use each_cons to create 2 arrays, one with odd numbers and one with even\
    \ numbers, and then sum them up. Something like:\n<code>", "    sum = 0\n    even\
    \ = 0\n    odd = 1\n    for i in lst\n        if i % 2 != 0\n            sum +=\
    \ i\n        else \n            even = even * i\n    sum += odd\n    return sum",
  "  \n  # Sum up first half of even numbers\n  evens = lst[0..lst.size / 2]\n  sum\
    \ = 0\n  evens.each_index do |i|\n    if evens[i] % 2 == 0\n      sum += evens[i]\n\
    \    end\n  end", "    odd = lst.select{|x| x % 2 == 1}\n    return odd.inject(0)\
    \ {|m, n| m + n}\nend\n</code>\n<|/ a dscore=4 |>\n<| a |>\nThis question is interesting.\
    \ I just thought about it, and found a solution for that. \n<code>", "    even\
    \ = []\n    odd = []\n    even.push(0)\n    odd.push(lst[0])\n    i = 2\n    while\
    \ i < lst.length\n        if lst[i] % 2 == 0 then even += lst[i]\n        else\
    \ odd += lst[i]\n        i += 1\n    end\n    even.push(lst[lst.length])\n   \
    \ odd.push(lst[lst.length])\n    odd.push(lst[lst.length])\n    even.inject(0)\
    \ {|sum, element| sum + element }\n    odd.inject(0) {|sum, element| sum + element\
    \ }\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a tags=ruby |>\nOne approach\
    \ is to sort the array and then iterate through the odd numbers and add the sum\
    \ of these to the running sum, starting with the first odd number in the sorted\
    \ array (since each odd number in the sorted array is equal to the sum of all\
    \ preceding odd numbers):\n<code>", "  if lst.empty? \n    0 \n  else \n    (lst.size\
    \ - 1).to_f * (lst[lst.size - 1] / 2).to_i\n  end\nend\n</cell>\n<cell>", "  even\
    \ = lst.select { |x| x % 2 == 0 }\n  odd = lst.select { |x| x % 2 != 0 }\n  even.inject\
    \ { |sum, x| sum + x }\nend", "\teven = lst.index(0)\n\todd = even+1\n\t\n\tevens\
    \ = 0.0;\n\todds = 0.0;\n\t\n\tfor i in lst:\n\t\tif i>0:\n\t\t\tevens += i\n\t\
    \tif i<even:\n\t\t\todds += i\n\t\t\n\ttotal = odds-evens\n\treturn total\n</cell>\n\
    <cell>\nsolution([5, 8, 7, 1])\n</cell>\n<cell>\nsolution([3, 3, 3, 3, 3])\n</cell>\n\
    <cell>", "  sum = 0\n  \n  evenPositions.each { |index| sum += lst[index] } \n\
    \  \n  sum\nend", "  \n  # Add up the even numbers\n  evenSum = lst.inject(0)\
    \ { |sum, n| sum + n if n % 2 == 1 }\n  # Add up the odd numbers\n  oddSum = lst.inject(0)\
    \ { |sum, n| sum + n if n % 2 == 0 }\n  # Add them and return the result\n  return\
    \ evenSum + oddSum\nend", "  odd_count = 0\n  even_count = 0\n  sum = 0\n  for\
    \ i in lst\n    if i % 2 == 1\n      even_count += 1\n      sum += i\n    else\n\
    \      odd_count += 1\n      sum += i\n  end\n  puts sum\n  puts even_count +\
    \ odd_count\nend", "    sum = 0\n    even_index = lst.index(lst.index(0) + 1)\n\
    \    for i in lst.index(even_index..-1) # (even_index..-1)\n        sum += lst[i]\n\
    \    end\n    return sum\nend", "  return lst.sum { |n| n % 2 == 1 }\nend", " \
    \   even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd =\
    \ 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd\
    \ = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n  \
    \  odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n\
    \    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even =\
    \ 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even\
    \ = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n   \
    \ even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n\
    \    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd =\
    \ 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd\
    \ = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n  \
    \  odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n\
    \    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even =\
    \ 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even\
    \ = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n   \
    \ even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n\
    \    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd =\
    \ 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd\
    \ = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1\n    even = 0\n  \
    \  odd = 1\n    even = 0\n    odd = 1\n    even = 0\n    odd = 1", "  result =\
    \ lst.inject(:+) * lst.each_cons(2).map(&:last).select {|x| x.odd?}.inject(:+)\
    \ \n  return result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhoa this is an\
    \ awesome answer. Thanks!\n<|/ c |>\n<| c |>\nHe is very impressed with the quality\
    \ of the solution! This answer deserves a lot of upvotes and an explanation.\n\
    <|/ c |>\n<| c |>\nI wonder if there is a way we can use a ternary operator to\
    \ make the second solution shorter. Thanks!\n<|/ c |>\n<| c |>\n`@Ashwin Kumar\
    \ Sharma` Your solution is indeed a lot shorter, but it is also much slower in\
    \ Ruby 1.8.7 vs 1.9.3 because it does a lot of method calls.\n<|/ c |>\n<| a |>\n\
    <code>", "    odd_sum = 0\n    for n in lst\n        if n % 2 == 1\n         \
    \   odd_sum += n\n    return odd_sum", "  evenSum = 0\n  oddSum = 0\n  for elem\
    \ in lst\n    if elem % 2 == 0\n      evenSum += elem\n      next\n    else\n\
    \      oddSum += elem\n    end\n  end\n  return evenSum + oddSum\nend\n</cell>\n\
    <code language=julia-0.4>\nsolution([5, 8, 7, 1])\n</cell>\n<text>\nQ. Return\
    \ True if there exists a permutation of the list where the elements are ordered\
    \ in increasing order. \nFor example, given the list [1, 2, 3, 4], return True\
    \ as the list [4, 3, 2, 1] is also a permutation.\nThe function should take linear\
    \ time in the worst case. \nYou can assume that the given list does not contain\
    \ duplicate elements. \nFor this problem, we will assume a list has at least two\
    \ elements. ", "  sum = 0\n  for i in 0...lst.size\n    el = lst[i]\n    if el\
    \ % 2 == 0\n      sum += el\n      el = lst[i+1]\n      if el % 2 == 0\n     \
    \   sum += el\n      end\n    end\n  end\n  sum\nend", "  sum = 0\n  for i in\
    \ lst.each_index {|i| if i % 2 != 0; sum += lst[i]}\n  sum\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\n`lst.each_index` doesn't actually return an array, it\
    \ returns an Enumerator. Arrays are a type of Enumerator, but they're not the\
    \ same thing.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>\narray.uniq.map {\
    \ |el| el % 2 != 0 ? el : nil }.compact.sum\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\n<code>\narray.uniq.map { |x| x % 2 != 0 ? x : nil }.compact.sum\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nThis is a different take on some of the other\
    \ answers, but I wanted to see what it would look like without an additional method\
    \ or additional temporary variables:\n<code>\narray.inject(0) { |sum, i| sum +\
    \ i if i % 2 == 0 }\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`sum` and `i` are already\
    \ local variables. There\u2019s no need to create a closure.\n<|/ c |>\n<| c |>\n\
    Fair enough, although I tend to use the word \"closures\" in a very specific way.\
    \ I guess I tend to call them the blocks I mention in my answer.\n<|/ c |>\n<|\
    \ a tags=ruby |>\nI like my solution better than the others posted here. As others\
    \ have pointed out, Array#uniq returns a \"unique\" copy of the original array.\
    \ So, why not just use Array#map and Array#sum?\n<code>\narray.reject { |i| i\
    \ % 2 == 0 }.inject(0) { |sum, i| sum + i }\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nYou would need `|sum, i|` since `inject` returns the unmodified accumulator\
    \ from the previous iteration.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  sum=0\n\
    \  even=0\n  even.each do |x|\n    sum +=lst[even.index(x)]\n  end\n  return sum\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`even.index(x)` should be `even.index(x)\
    \ - 1`\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  result = 0\n  lst.each do |i|\n\
    \    result += (i % 2 != 0) ? i : nil\n  end\n  result\nend", "  if lst.empty?\n\
    \    []\n  else\n    lst.sort_by { |n| n % 2 == 0 }.map { |n| n + (lst.index(n)\
    \ + 1).odd? ? 0 : lst.index(n) + 1 }.sum\nend", "  even = []\n  odd = []\n  for\
    \ x in lst\n    if x % 2 == 0\n      even << x\n    else\n      odd << x\n  end\n\
    \  even.inject(0) { |sum, x| sum += x }\n  odd.inject(0) { |sum, x| sum += x }\n\
    end\n</code>\n<|/ a tags=ruby,math dscore=3 |>\n<| c |>\nThis is not really a\
    \ solution to my question but rather a way to solve the problem, which I appreciate\
    \ because I didn't know about inject yet. +1 from me.\n<|/ c |>\n<| c |>\nIt was\
    \ only to show how to do this with Ruby ;)\n<|/ c |>\n<| c |>\nAh, I understand\
    \ now, I was overthinking this.\n<|/ c |>\n<| c |>\nNo problem, if you feel my\
    \ answer was useful, you can always upvote it :) I see someone has already down\
    \ voted it btw\n<|/ c |>\n<| c |>\nI did upvote. Sorry about that. I was too hasty\
    \ with my upvote at first. I'm new to this.\n<|/ c |>\n<| a |>\nIt is a very simple\
    \ problem. You need to add all the even numbers in a hash and then add all the\
    \ odd numbers in a separate hash. Then, add the two hashes. You will get correct\
    \ result.\n<code>", "  lst.select {|e| e%2 == 1 }.inject(:+)\nend\n</cell>\n<cell>\n\
    solution([5,8,7,1])\n</cell>\n<cell>\nsolution([3,3,3,3])\n</cell>\n<text>\nProblem\
    \ 15\nGiven two lists sorted in increasing order, create and return a merged list\
    \ rearranging the original elements.", "    even = evenSum = 0\n    odd =[]\n\
    \    if lst.empty?\n        return\n    else\n        lst.each_with_index do |value,\
    \ index|\n            if index%2 == 0\n                even += value\n       \
    \     else\n                odd += value\n            end\n        end\n    end\n\
    \    even.zip(odd).reduce(:+)\nend\n</code>\n<|/ a tags=ruby,arrays,sum |>\n<|\
    \ a dscore=1 tags=ruby,arrays,sum |>\nAs long as you aren't doing this to learn\
    \ Ruby or homework, and are interested in how this could be done in Python, one\
    \ solution is:\n<code>", "  sum = 0\n  lst.each_with_index do |e, i|\n    return\
    \ sum if i % 2 == 0\n    sum+=e if e % 2 == 1\n  end\n  return sum\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,algorithm,optimization |>\n<code>", "  sum =\
    \ 0\n  lst.each_with_index do |number, index|\n    if index % 2 == 1\n      sum\
    \ += number\n    end\n  end\n  sum\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    You could also use [inject](http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-inject)\
    \ instead of a `each_with_index`+`if` block\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\n<code>\nlist = [1,2,3,4]", "  if lst.empty?\n    0\n  else\n    lst.sort.inject(0)\
    \ do |sum, i|\n      sum += (i % 2 == 0) ? i : nil\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nGreat solution! But you could simplify it by using\
    \ `each_cons(2)` instead of `chunk(2)`.\n<|/ c |>\n<| a dscore=4 |>\nThe fastest\
    \ solution is to use Array#sum with a block:\n<code>\nlist = [1, 2, 3, 4, 5, 6]\n\
    list.sum{ |x| x%2 }\n=> 6\n</code>\nThis code will be translated into C code,\
    \ so it will be fast.\nIf you can't use Array#sum, you could use this code:\n\
    <code>\nlist.inject(0){ |sum, el| sum + (el%2 ? el : 0) }\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=3 tags=ruby |>\n<code>\n(array).reduce(0) do |sum,n|\n  sum\
    \ + n % 2\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not Ruby-like\n<|/ c |>\n\
    <| a dscore=3 |>\nTo get even numbers from array without using Array#sum:\n<code>\n\
    array = [0,1,2,3,4,5,6,7,8,9,10,11,12,13]", "  even = lst.select { |i| i % 2 ==\
    \ 0 }\n  odd = lst.select { |i| i % 2 != 0 }\n  even.inject {|sum,x| sum + x }\n\
    end", "  lst.each_with_index do |n, idx|\n    if idx%2 == 0\n      n + lst[idx\
    \ + 1]\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer!\n\
    <|/ c |>\n<| c |>\nA nice clean solution -- I like the use of each_with_index.\
    \ Still my own solution is \"faster\" than the one above by about 5%. Not sure\
    \ why.\n<|/ c |>\n<| c |>\nI guess it is because my solution requires two index\
    \ accesses whereas the one above only requires one. Using `each_with_index` would\
    \ probably be better for large lists.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution\
    \ that doesn't use Ruby iterators:\n<code>", "  return lst.reduce(:+)\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,ruby |>\nI know this is an old question,\
    \ but I wanted to add this answer since it is so helpful to me. In addition to\
    \ other answers, a more straight forward way to find an even number in an array\
    \ is to search through the array and keep count of even numbers seen so far. For\
    \ example:\n<code>", "  even = 0\n  odd = 0\n  for i in lst\n    if i % 2 != 0\n\
    \      even += i\n    else\n      odd += i\n  even, odd\nend\n</cell>\n<text>\n\
    Now let's solve the problem:", "  sum = 0\n  for i in 0..(lst.size - 1)\n    if\
    \ lst[i] % 2 == 0\n      sum += lst[i]\n    end\n  end\n  sum\nend", "    even\
    \ = 0\n    odd = 0\n    for i in lst\n        if i % 2 == 0\n            even\
    \ = even + i\n        else\n            odd = odd + i\n    return even + odd\n\
    </cell>\n<cell>", "  # check if list is not empty\n  lst = lst if lst.empty? else\
    \ lst[0]\n  # init result\n  result = 0\n  # iterate through list\n  lst.each\
    \ do |x|\n    # check if element is odd\n    if x % 2 != 0\n      # add to result\n\
    \      result += x\n    end\n  end\n  result\nend\n</cell>\n<cell>", "  # first,\
    \ find the sum of all the odd values\n  odd_sum = 0\n  for i in lst \n    if i\
    \ % 2 == 1 \n      odd_sum += i\n    end\n  end\n  # now, the sum of all the even\
    \ values minus the sum of odd values\n  even_sum = odd_sum - odd_sum.even? ? odd_sum\
    \ : 0\n  \n  # return the sum of the even values\n  return even_sum\nend\n</cell>\n\
    <code language=julia-1.0>\nsolution([1,2,3,4,5,6,7,8,9,10])\n</cell>\n<text>\n\
    The solution to the above puzzle is 23 = 12 + 9 + 7.", "  sum = 0\n  for i in\
    \ 0...(lst.length)\n    sum += (lst[i] + lst[lst.length - 1 - i]) / 2\n    sum\
    \ = sum % 10\n  end\n  sum\nend\n</code>\n<|/ a dscore=4 |>\n<| a dscore=4 |>\n\
    The question says that you need to find the sum of all the odd elements that are\
    \ in even positions. So we need to find the sum of all the odd elements which\
    \ are in even positions and then multiply it by 2. We need to do this by dividing\
    \ each number by 2. So we need a loop to do this. Here is the code to do this:\n\
    <code>", "  lst.each_with_index do |e, i| \n    even_pos = i % 2 == 0 \n    odd\
    \ += e if even_pos\n  end\n  odd\nend", "  return sum( lst[ :: 2 ].take_while(&odd?))\n\
    end", "  odd_even = 0\n  for i in lst\n    if i.odd?\n      odd_even += i.value\n\
    \    end\n  end\n  return odd_even\nend", "  lst.sort.each do |x|\n    puts x%2\
    \ ? x + 1 : x\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
