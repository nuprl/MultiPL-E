name: HumanEval_91_is_bored
language: rb
prompt: "# You'll be given a string of words, and your task is to count the number\n\
  # of boredoms. A boredom is a sentence that starts with the word \"I\".\n# Sentences\
  \ are delimited by '.', '?' or '!'.\n# For example:\ndef is_bored(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_bored\n\
  \    candidate = method(:is_bored)\n    assert_equal(0, candidate.call(\"Hello world\"\
  ))\n    assert_equal(0, candidate.call(\"Is the sky blue?\"))\n    assert_equal(1,\
  \ candidate.call(\"I love It !\"))\n    assert_equal(0, candidate.call(\"bIt\"))\n\
  \    assert_equal(2, candidate.call(\"I feel good today. I will be productive. will\
  \ kill It\"))\n    assert_equal(0, candidate.call(\"You and I are going for a walk\"\
  ))\n  end\nend\n"
completions: ["  s[0] == 'I'\nend", "  s.scan(/(?:^|[\\?!])/)\n  s.count('I')\nend",
  "    count = Hash.new(0)\n    s.split(/[\\.\\?!]/).each do |word|\n      if word\
    \ == \"I\"\n        count += 1\n      end\n    end\n    return count\nend", " \
    \ s.downcase!\n  s.gsub!(/\\b(I|i|!)\\b/i, '')\n  s.gsub!(/\\.\\./, '.')\n  s.gsub!(/[?!]\\\
    ./, '.')\n  s.gsub!(/\\.\\./, '.')\n  s.split(\" \").inject(0) do |a, word|\n\
    \    a += 1 if word == \"I\" || word == \"i\"\n    a += 1 if word == \"!\" ||\
    \ word == \"!\"\n    a += 1 if word == \".\" || word == \"?\"\n    a\n  end\n\
    end\n</code>\nSome benchmarks:\n<code>\nBenchmark.bm do |b|\n  b.report(\"regexp\
    \ #1\") { 10000.times { is_bored('I love to play football.') } }\n  b.report(\"\
    regexp #2\") { 10000.times { is_bored('I love to play football.', false) } }\n\
    \  b.report(\"method #1\") { 10000.times { is_bored_method('I love to play football.')\
    \ } }\n  b.report(\"method #2\") { 10000.times { is_bored_method('I love to play\
    \ football.', false) } }\nend\n</code>\nResults:\n<code>\n            user   \
    \  system      total        real\nregexp #1   0.917000   0.000000   0.917000 (\
    \  0.918345)\nregexp #2   0.770000   0.000000   0.770000 (  0.770319)\nmethod\
    \ #1   0.980000   0.000000   0.980000 (  0.988975)\nmethod #2   0.900000   0.000000\
    \   0.900000 (  0.902984)\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\nInteresting\
    \ approach, though I wonder about the performance when processing long strings.\
    \ It's not like the regexp is going to be executed a lot if at all, but it's possible\
    \ that ruby can optimize those down.\n<|/ c |>\n<| c |>\nYeah I did notice that;\
    \ I guess it depends a lot on the speed of the machine and how well it can execute\
    \ regexes.\n<|/ c |>\n<| c |>\nIt does seem to be faster. See the updated results.\n\
    <|/ c |>\n<| c |>\nI wonder if Ruby can optimize this away, or if this is actually\
    \ faster: `s = \"I love to play football.\".gsub(/\\b(I|i|!)\\b", "  s.chars.grep(/i/).length\
    \ == 1\nend", "  s.each_char.all? do |c|\n    (c != '.' && c != '?' && c != '!')\n\
    \  end\nend", "  s.split('.').count { |word| word =~ /^I/ }\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\nHere is a simple Ruby version which can easily be adapted to include a case\
    \ for punctuation as well:\n<code>", "    boredom = 0\n    i = 0\n    while i\
    \ < s.length\n        if s[i] !~ /[\\.\\?\\!]/\n            boredom = boredom\
    \ + 1 if s[i] == \"I\" else boredom\n        end\n        i = i + 1\n    end\n\
    \    return boredom\nend", "  s[0] == 'I'\n  return s[1] == '.' or s[1] == '?'\
    \ or s[1] == '!'\nend", "  return s.include? \"I\"\nend", "    s_array = s.split('.')\n\
    \    num_boredoms = 0\n    for s_word in s_array\n        if s_word.strip() ==\
    \ \"I\"\n            num_boredoms += 1 \n    return num_boredoms\n</code>\nThis\
    \ code could be made more Pythonic and concise, but I wanted to point out some\
    \ issues and show you how to use functions with parameters. \nA function is called\
    \ with the arguments you define in the parentheses. If you only give it one argument,\
    \ you get the value returned by the function. If you give it two arguments, you\
    \ get the value returned by the function from the first argument, plus the value\
    \ returned by the function from the second argument. \nAlso, notice that I have\
    \ added a parameter s_word, which is an arbitrary name given to the argument of\
    \ the loop. Again, this is just an arbitrary name given to the argument of the\
    \ loop, which, when called on the string that represents the sentence of words,\
    \ will give me the sentence as a string. That string is then split into a list\
    \ of words, and I check each word for \"I\". \nFinally, I add a return statement\
    \ to the end of the function definition, which tells Python to return the value\
    \ of the num_boredoms variable defined in the body of the function.\n<|/ a dscore=2\
    \ tags=python |>\n<| a tags=python |>\n<code>", "  s.include?(\"I\")\nend", " \
    \ return s.split('.').all? { |word| word.starts_with?('I') }\nend", "  s.scan(/((?=^|\\\
    .)\\bI\\b)/)\n  return s.length\nend", "  return s.start_with?(\"I\")\nend\n</cell>\n\
    <cell>", "  s.split('.').each do |word|\n    return false if word.start_with?('I')\n\
    \  end\n  s.split('!').each do |word|\n    return false if word.start_with?('I')\n\
    \  end\n  s.split('?').each do |word|\n    return false if word.start_with?('I')\n\
    \  end\n  true\nend\n</pre>\n<p>Remember, Ruby has <code>map</code> for building\
    \ lists, and <code>start_with?</code>\nfor checking if the first element of an\
    \ array starts with another element.</p>\n<p>You will probably want to use <code>map</code>\
    \ to create a list of all words in a\nsentence. You can then pass that list to\
    \ <code>start_with?</code> to count boredoms.</p>\n<p>To recap: You'll need to\
    \ create a function <code>is_bored(s)</code> that\nreturns true or false depending\
    \ on whether the input string s contains boredom\nsentences.</p>\n<h3>Finding\
    \ the longest boredom</h3>\n<p>To find the longest boredom, you will need to use\
    \ <code>Enumerable#max_by</code>\nwhich allows you to pass in a block. The block\
    \ needs to return the word and the\nnumber of boredoms that word has. <code>max_by</code>\
    \ will then return the word\nwith the highest number of boredoms.</p>\n<p>Create\
    \ a method <code>longest_boredom(sentences)</code> that returns the longest boredom\n\
    sentence in the input array. If no boredom sentences exist, it should return nil.</p>\n\
    <p>For example, suppose that your input array contains these three boredom sentences:\n\
    <code>[\"Oh no, I&#39;m not feeling very well.\",\n \"It&#39;s okay, I&#39;m feeling\
    \ good.\",\n \"I hope so, I&#39;m feeling better!\"]</code>. Your method should\
    \ return \"It&#39;s okay, I&#39;m feeling good.\"\n</p>\n<p>The method should\
    \ assume that the input array does not contain any boredom sentences.</p>\n<p>In\
    \ this example, the longest boredom sentence is the second boredom sentence.\n\
    We could also have a boredom sentence like <code>\"Oh no, I&#39;m not feeling\
    \ very well. She ran and ate meat once a week before breakfast.\"</code> that\
    \ would return <code>nil</code>.</p>\n<h3>Finding the shortest boredom</h3>\n\
    <p>We already have <code>longest_boredom</code> which returns the longest boredom\
    \ sentence\nin a list of boredom sentences. Instead of returning the longest boredom\
    \ sentence,\nwe could return the shortest one. This ", "  return false if !s or\
    \ s.empty?\n  s.start_with?('I')\nend", "    count = 0\n    for word in s.split(\"\
    \ \")\n        count += 1 if word[0] == \"I\"\n    return count\nprint(is_bored(\"\
    I hate the world\")) # should print 1\nprint(is_bored(\"I love the world\")) #\
    \ should print 0\nprint(is_bored(\"I love the world?\")) # should print 0\nprint(is_bored(\"\
    I love the world!\")) # should print 1\n</cell>\n<text>\n3. Problem Statement\n\
    Write a Python program to find the first non-repeating character in a given string.\
    \ \nTo do so,", "  s.index(\"I\") != nil\nend", "  s.split(' ').select { |word|\
    \ word.match(/^I.*\\.?$/) }.count\nend", "  s.split('.').reduce(0) {|n,c| n +\
    \ c.split('?').length + c.split('!').length} == 0\nend", "  s.split(\" \").each\
    \ do |word|\n    if word[0..1] == \"I\"\n      true\n    end\n  end\nend", " \
    \ return s.downcase =~ /^[Ii][\\.\\?!]/i\nend", "  s.downcase!\n  s.gsub(/\\.|\\\
    ?|\\!/, \"\")\n  s.gsub(/\\b(I)+/)\nend\n</pre>", "  s.split(\" \").any? { |word|\
    \ word[0].upcase==\"I\" }\nend", "    return s[0] == 'I' and s.count('.')+s.count('?')+s.count('!')==1",
  "  return s == \"\" || s =~ /^\\W*(I)(\\W|$)/\nend", "  s.split(\".\").grep(/^I/i).size\
    \ > 0\nend\nprint(is_bored(ARGV[0]))", "    s = s.chomp\n    count = 0\n    (s.gsub!(/\\\
    .|\\?|!/, \"\")).split(\"i\").each do |x|\n      count += 1\n    end\n    return\
    \ count\nend", "  s.start_with?(\"I\")\nend", "  s = s.downcase\n  s.gsub!(/\\\
    .\\.\\.|!|?/i, '')\n  s.split('.').size.to_i > 0\nend\n</pre>\n<p class=\"fragment\"\
    >\nIf you want a more complete and detailed explanation of the\n\"boredom\" method,\
    \ see this page.\n</p>\n<p>\nYou will need to use methods like <code>downcase</code>\
    \ to filter the\nwords, and <code>split</code> to find the sentences. You may\
    \ use a\nvariety of other methods in the String class.\n</p>\n<p>\nThis example\
    \ uses the <code>gsub!</code> method which stands for \"globally substitute\n\
    all\". It replaces all the occurrences of the regular expression (/\\.\\.\\.|!|?/i,\
    \ '') with the\nempty string. In this example, it is the regular expression that\
    \ selects\nthe periods. If you wanted to find out the number of questions, you\n\
    would use <code>gsub!</code> with the regular expression /!/, which replaces all\n\
    occurrences of \"!\".\n</p>\n<p>\nA few points to keep in mind:\n</p>\n<ul>\n\
    \  <li>If you use <code>gsub!</code>, you do not need to save the result to a\
    \ variable</li>\n  <li>The regular expression can contain zero, one, or more occurrences\
    \ of the expression\n    (/\\.\\.\\.|!|?/i)</li>\n  <li>If you try to pass a regular\
    \ expression that is not enclosed in slashes\n    (<code>/\\.\\.\\.|!|?/i</code>),\
    \ you will get the error <code>ArgumentError: wrong number of arguments (0 for\
    \ 1)</code></li>\n  <li>If you call <code>gsub!</code> and pass a second argument,\
    \ it will\n    modify the original string instead of the return value</li>\n \
    \ <li>When using <code>gsub!</code>, you cannot pass an empty string as an argument</li>\n\
    </ul>\n<p>\n<b>Tip:</b> A regex literal can be enclosed in backticks:\n</p>\n\
    <pre class=\"example\">\ns = 'How many questions does this sentence have?'\ns.gsub(/\\\
    .\\.\\.|!|?/i)", "  s =~ /^I.+?[.?!]/\n  return $&.size >= 3\nend", "    i = s.index('.')\n\
    \    j = s.find('?')\n    k = s.find('!')\n    if i < 0 or j < 0 or k < 0 or j\
    \ > i or k > i or k > j:\n        return False\n    else:\n        return True",
  "  s.scan(/(?:\\.|\\?|\\!)/).count > 1\nend", "  return s.match(/^[I!.?]/)\nend\n\
    \ \n ", "  s.gsub!(/\\.$/,\"\") # remove trailing dot\n  s.gsub!(/[?!]/,\"\")\
    \ # remove question or exclamation point\n  s.gsub!(/[!?]/,\"\") # remove ! or\
    \ ?\n  s.gsub!(/\\A[!?]/,\"\") # remove beginning ! or ?\n  s.gsub!(/\\Z/,\"\"\
    )   # remove trailing ! or ?\n  return s.gsub(/\\bI\\b/,\"\").length == 0 # count\
    \ boredoms if no I\nend", "  count = 0\n  for i in s\n    if i == 'I'\n      count\
    \ += 1\n  end\n  count\nend\n</cell>\n<code language=julia-1.0>", "  s.gsub!(/\\\
    A[\\.\\?\\!]/, '')\n  s == 'I'\nend", "    bored_chars = [\"I\"]\n    bored_count\
    \ = 1\n    # remove punctuation\n    no_punct_str = s.translate(string.maketrans(\"\
    \",\"\"), string.punctuation)\n    # remove end-of-word and remove any word that\
    \ starts with 'I'\n    s_no_bored = no_punct_str.split('.?!').collect(&:strip)\n\
    \    s_no_bored.collect! { |word| if word.start_with?(\"I\") && !word[/^I(/) ||\
    \ word.start_with?('I')] \n        bored_count += 1\n        bored_chars.concat(word.split(\"\
    I\")) \n    end}\n    if bored_count > 0\n      return true\n    else\n      return\
    \ false\n    end\nend", "  s.downcase!\n  s.gsub!(/[.?!]/,'')\n  s.scan(/^I+$/,0)\n\
    end", "  s.to_s.gsub!(/\\.|\\?|\\!/, '').strip\n  s.to_s.start_with?('I')\nend",
  "  s.scan(/[^I\\.!?]\\.?/)\nend", "  s.gsub!(/(^|\\W)(I)(\\W|$)/, \"\\\\1I\\\\2\\\
    \\3\")\n  s.gsub!(/([?!])/, '\\1')\n  s.gsub!(/([.])/, '\\1I\\1')\n  s.gsub!(/([!?])/,\
    \ '\\1I\\1')\n  s.scan(/([\\.])([^\\.?!]+)/)\n  s.count('I')\nend", "  s.chars.first(2).include?(\"\
    I\")\nend\n</cell>\n<code language=conda-env-sentiment-py>\nis_bored(\"My friends\
    \ love I\")\n</cell>\n<code language=conda-env-sentiment-py>\nis_bored(\"My friends\
    \ hate I\")\n</cell>\n<code language=conda-env-sentiment-py>\nis_bored(\"My friends\
    \ hate I and I love each other.\")\n</cell>\n<code language=conda-env-sentiment-py>\n\
    is_bored(\"My friends love I and I hate each other.\")\n</cell>\n<code language=conda-env-sentiment-py>\n\
    is_bored(\"My friends love I, I, I, I, I, I, and I hate each other.\")\n</cell>\n\
    <code language=conda-env-sentiment-py>\nis_bored(\"My friends love I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, and I love each other.\")\n</cell>\n\
    <code language=conda-env-sentiment-py>\nis_bored(\"My friends love I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, and I love I, I, I, I, I, I, I, I,\
    \ I, I, and I hate I, I, I, I, I, I, I, I, I, and I love each other.\")\n</cell>\n\
    <code language=conda-env-sentiment-py>\nis_bored(\"My friends love I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, I, and I love I, I, I, I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, I, I, and I love I, I, I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, I, I, and I love each other.\")\n</cell>\n\
    <code language=conda-env-sentiment-py>\nis_bored(\"My friends love I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, I, and I love I, I, I, I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, I, I, and I love I, I, I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, I, I, I, I, I, and I love I, I, I, I, I, I,\
    \ I, I, I, and I hate I, I, I, I, ", "    boredom_count = 0\n    for word in s.split('.')\n\
    \       if word.start_with?('I')\n          boredom_count += 1\n       end\n \
    \   end\n    boredom_count\nend", "  s.downcase!\n  s.gsub!('\\.',' .') # replace\
    \ any period before the first letter\n  s.gsub!('\\?',' ?') # replace any question\
    \ mark before the first letter\n  s.gsub!('!',' !')\n  s.gsub!(/I/,\" I \") #\
    \ replace all I at the beginning of the string with a space\n  s.gsub!(/I/,\"\
    \ I \") # replace all I at the beginning of the string with a space\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  s.gsub!(/\\\
    bI\\b/,\"I \")\n  s.gsub!(/\\bI\\b/,\"I \")\n  ", "    boredoms = 0\n    for word\
    \ in s.split(' ')\n        if word =~ /^I$/\n            boredoms += 1\n     \
    \   end\n    end\n    return boredoms\nend\nis_bored('I like Ice!')\n</cell>\n\
    <cell>", "  s.split.any?{|w| w =~ /^I/ }\nend", "  s.chars.all? {|c| (c == '.'\
    \ || c == '?' || c == '!') }\nend", "  return s.start_with?(\"I\") || s.include?(\"\
    .\") || s.include?(\"?\") || s.include?(\"!\")\nend", "    boredom = s.start_with?(\"\
    I\")\n    return boredom\nend", "  s =~ /I\\w*\\.|I\\w*?|I\\w*!/\n  return $&.to_i\n\
    end", "  s.split(\".\").count(\"I\") == 0\nend\n</cell>\n<cell>", '    return
    s == "I."', "    count = 0\n    for word in s.split(\" \"):\n        if word ==\
    \ \"I\":\n            count += 1\n    return count", "    boredoms = [\"I\", \"\
    you\", \"it\", \"she\", \"it\", \"its\", \"they\",\n                \"i\", \"\
    me\", \"my\", \"myself\", \"your\", \"yours\", \"yourself\",\n               \
    \ \"he\", \"him\", \"his\", \"himself\", \"she\", \"her\", \"hers\",\n       \
    \         \"herself\", \"it\", \"its\", \"itself\", \"they\", \"them\",\n    \
    \            \"their\", \"theirs\", \"themselves\", \"what\", \"which\",\n   \
    \             \"who\", \"whom\", \"this\", \"that\", \"these\", \"those\",\n \
    \               \"am\", \"is\", \"are\", \"was\", \"were\", \"be\", \"been\",\
    \ \"being\",\n                \"have\", \"has\", \"had\", \"having\", \"do\",\
    \ \"does\", \"did\", \"doing\",\n                \"a\", \"an\", \"the\", \"and\"\
    , \"but\", \"if\", \"or\", \"because\", \"as\",\n                \"until\", \"\
    while\", \"of\", \"at\", \"by\", \"for\", \"with\", \"about\",\n             \
    \   \"against\", \"between\", \"into\", \"through\", \"during\", \"before\",\n\
    \                \"after\", \"above\", \"below\", \"to\", \"from\", \"up\", \"\
    down\", \"in\",\n                \"out\", \"on\", \"off\", \"over\", \"under\"\
    , \"again\", \"further\", \"then\",\n                \"once\", \"here\", \"there\"\
    , \"when\", \"where\", \"why\", \"how\", \"all\",\n                \"any\", \"\
    both\", \"each\", \"few\", \"more\", \"most\", \"other\", \"some\",\n        \
    \        \"such\", \"no\", \"nor\", \"not\", \"only\", \"own\", \"same\", \"so\"\
    , \"than\",\n                \"too\", \"very\", \"s\", \"t\", \"can\", \"will\"\
    , \"just\", \"don\", \"should\",\n                \"now\"]\n    count = 0\n  \
    \  for w in s.split():\n        if w not in boredoms:\n            count += 1\n\
    \    return count\n    \n</cell>\n<cell>", "  s.gsub!(/\\.|!/, '')\n  s.gsub!(/[?]/,\
    \ '')\n  s.gsub!(/I/, '')\n  s.count('I')\nend", "    boredoms = 0\n    boredom_pattern\
    \ = \"^I.*\"\n    boredom_regex = Regexp.new(boredom_pattern)\n    return s.match(boredom_regex)\n\
    end", "    boredom = s.count('I')\n    return boredom", "    word_list = s.split('.')\n\
    \    bored_word_count = len(word_list) - 3\n    if word_list[0] == 'I' and len(word_list)\
    \ == 1:\n        return True\n    return False\n</cell>\n<cell>", "  i = s.length\n\
    \  boredom = 0\n  while i > 0\n    if i == 1\n      break\n    if s[i] == 'I'\n\
    \      boredom = boredom + 1 + is_bored(s[i..-1])\n    i = i - 1\n  end\n  boredom\n\
    end", "  s = s.downcase\n  s.gsub!(/[^?.!]/, '')\n  s.sub!(\"i.\", \"I \")\n \
    \ s.scan(/^I\\s?/)\nend", "  s.gsub!(/\\.|!/, '')\n  s.gsub!(/[?!]/, '')\n  if\
    \ s.downcase == \"i\"\n    return true\n  end\n  false\nend", "  s.split('.').count.('I')\n\
    end\nputs is_bored(ARGV[0])", "  s.split('.').count('I')\nend", "  return s.scan(/\\\
    bI\\b/).size > 0\nend\n</cell>\n<code language=julia-0.3>", "    \n    return\
    \ s.lower().startswith(\"i\")", "  i = 0\n  s.each_char do |c|\n    if (c == '?'\
    \ || c == '!')\n      i += 1\n    end\n  end\n  i\nend", "  s.gsub!('.','')\n\
    \  s.gsub!('?','')\n  s.gsub!('!','')\n  s.chomp!\n  if s.start_with? \"I\"\n\
    \    return 1\n  else\n    return 0\n  end\nend\nputs is_bored(\"I hate you.\"\
    ) # => 1\nputs is_bored(\"I'm not a boredom.\") # => 0\nputs is_bored(\"Hi there!\"\
    ) # => 0\nputs is_bored(\"Hi I!\") # => 0\nputs is_bored(\"I'm fine\") # => 1\n\
    </cell>\n<cell>", "  return s.start_with?(\"I\")\nend", "  s.split('.')[0].to_s.downcase\
    \ == 'i'\nend", "  s.split\n  s.starts_with?(\"I\")\n  s.include?(\".\")\n  s.include?(\"\
    ?\")\n  s.include?(\"!\")\nend", "  s.split('.').count.include?('I')\nend\n  ",
  "  return s.chomp(\" \").chomp(\".?!\").starts_with?(\"I \")\nend", "\tbored_count\
    \ = 0\n\ts.split\n\tbored_count = s.split[0].index('I')\n\treturn bored_count\n\
    end", "  s.split(%r{\\.|\\?|!})\nend", "  s.split('.').all? { |e| e =~ /^I/ }.size\n\
    end", "  s.split.first == \"I\"\nend", "  s.gsub!(/\\.\\W*$/, '') # strip trailing\
    \ punctuation.\n  s.gsub!(/\\.\\W+/, '.') # strip trailing punctuation.\n  s.gsub!(/\\\
    ?/, '') # strip trailing punctuation.\n  s.gsub!(/\\!/, '') # strip trailing punctuation.\n\
    \  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\b.*?\\b/, ' ') # strip trailing punctuation.\n\
    \  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/,\
    \ \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\\
    bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n  s.gsub!(/\\bI\\b/, \"I\")\n", " \
    \ return s.downcase[0] == 'i'\nend", "  s.each_char.map { |word| word.downcase\
    \ }.chars.all? { |c| c == ?i }\nend\n</code>\n<|/ a dscore=4 tags=ruby,count,arrays\
    \ |>\n<| a dscore=4 |>\n<code>", "  return s.include? \"I\".to_sym && s.include?(\"\
    .\".to_sym)\nend", "  s.gsub!(/[\\.?!]/,\"\") # Strip punctuation characters.\n\
    \  s.match?(\"^I\") # Check if the first character of the string is \"I\".\nend",
  "  return s.match(/^I[\\.\\?!]/)\nend", "  s.split('.').map { |e| e.split('?').count\
    \ { |x| x == '!' } }.sum > 0\nend", "  s.chars.each do |c|\n    return false if\
    \ c !~ /[\\.\\?\\!]/\n    return false if c =~ /^[I]/\n  end\n  true\nend", " \
    \ boredoms = (0..9).to_a\n  s.split(//).each_with_index do |char, i|\n    return\
    \ false if (boredoms.include? char.ord)\n  end\n  true\nend", "    s = 0\n   \
    \ boredom = []", "  return s.split('.').count {|part| part == 'I'}\nend", "  \
    \  i = 0\n    j = 0\n    while i < len(s) and j < len(s) and s[i].upcase == s[j].upcase\
    \ do\n        i += 1\n        j += 1\n    end\n    return j > i\nend", "  s.slice!(0)\
    \ if s[0] == 'I' # removes I from the string\n  s.slice!(0) if s[0] == '.' # removes\
    \ . from the string\n  s.slice!(-1) if s[-1] == '.' # removes . from the string\n\
    \  s.slice!(-1) if s[-1] == '?' # removes ? from the string\n  s.slice!(-1) if\
    \ s[-1] == '!' # removes ! from the string\n  s.slice!(-1) if s[-1] == '.' # removes\
    \ . from the string\n  s.slice!(-1) if s[-1] == '?' # removes ? from the string\n\
    \  s.slice!(-1) if s[-1] == '!' # removes ! from the string\n  return s.size ==\
    \ 0\nend", "  s.split\n  s = s[0]\n  if(s.start_with?(\"I\"))\n    boredom +=\
    \ 1\n  end\nend\n</cell>\n<cell>", "  return s.chomp =~ /I/ \nend\nprint is_bored(\"\
    I am bored\")\nprint is_bored(\"I am not bored\")\nprint is_bored(\"I am bored.\"\
    )\nprint is_bored(\"I am bored and I love my job\")\nprint is_bored(\"I am bored\
    \ and I love my job.\")\nprint is_bored(\"I am bored and I love my job!\")\nprint\
    \ is_bored(\"I am bored and I love my job.!\")\nprint is_bored(\"I am bored and\
    \ I love my job!!\")\nprint is_bored(\"I am bored and I love my job??\")\nprint\
    \ is_bored(\"I am bored and I love my job??.\")\nprint is_bored(\"I am bored and\
    \ I love my job??!\")\nprint is_bored(\"I am bored and I love my job??!\")\nprint\
    \ is_bored(\"I am bored and I love my job??!\")\nprint is_bored(\"I am bored and\
    \ I love my job??!\")\nprint is_bored(\"I am bored and I love my job??!\")\nprint\
    \ is_bored(\"I am bored and I love my job??!\")\nprint is_bored(\"I am bored and\
    \ I love my job??!\")\nprint is_bored(\"I am bored and I love my job??!\")\nprint\
    \ is_bored(\"I am bored and I love my job??!\")\nprint is_bored(\"I am bored and\
    \ I love my job??!\")\nprint is_bored(\"I am bored and I love my job??!\")\nprint\
    \ is_bored(\"I am bored and I love my job??!\")\nprint is_bored(\"I am bored and\
    \ I love my job??!\")\nprint is_bored(\"I am bored and I love my job??!\")\nprint\
    \ is_bored(\"I am bored and I love my job??!\")\nprint is_bored(\"I am bored and\
    \ I love my job??!\")\nprint is_bored(\"I am bored and I love my job??!\")\nprint\
    \ is_bored(\"I am bored and I love my job??!\")\nprint is_bored(\"I am bored and\
    \ I love my job??!\")\nprint is_bored(\"I am bored and I love my job??!\")\nprint\
    \ is_bored(\"I am bored and I love my job", "    boredom = 0\n    count = 0\n\
    \    \n    for word in s.split() do\n        if word[0] = 'I' then\n         \
    \   boredom = boredom + 1\n            count = count + 1\n        end\n    end\n\
    \    \n    return boredom, count\nend\n</cell>\n<code language=julia-0.5>\nis_bored(\"\
    This is a bored sentence.\")\n</cell>\n<code language=julia-0.5>\nis_bored(\"\
    This sentence is a! bored sentence.\")\n</cell>\n<code language=julia-0.5>\nis_bored(\"\
    This sentence is a? bored sentence.\")\n</cell>\n<code language=julia-0.5>\nis_bored(\"\
    This sentence is a! bored sentence.\")\n</cell>\n<text>\nPutting it all together\n\
    Once you've written a function like is_bored(), you can put it into another function\
    \ like count_boredoms(), or combine them together:", "  s.scan(/\\.|\\?|\\!/)\n\
    \  s.count(\"I\")\nend", "  s.to_s.scan(/I ./).size\nend", "  s.scan(/^I\\w+/)\n\
    end", "  return s.start_with? \"I\"\nend\nis_bored \"Im watching TV?! That's great!\"\
    \nis_bored \"I like cheeseburger!\"\nis_bored \"Where did I make my coffee with\
    \ my friends?\"\nis_bored \"My dog likes ice cream!\"\nis_bored \"I like pizza!\"\
    \nis_bored \"Who is Leo Tolstoy?\"\nis_bored \"I love New York City so much!\"\
    \nis_bored \"I love New York City so much!\"\nis_bored \"Do you like ice cream\
    \ with your dog?\"\nis_bored \"Do you like pizza with your dog?\"\nis_bored \"\
    Do you like ice cream with your dog?\"\nis_bored \"Do you like pizza with your\
    \ dog?\"\nis_bored \"Do you like ice cream with your dog?\"\nis_bored \"Do you\
    \ like pizza with your dog?\"\nis_bored \"Do you like ice cream with your dog?\"\
    \nis_bored \"Do you like pizza with your dog?\"\nis_bored \"Do you like ice cream\
    \ with your dog?\"\nis_bored \"Do you like pizza with your dog?\"\nis_bored \"\
    Do you like ice cream with your dog?\"\nis_bored \"Do you like pizza with your\
    \ dog?\"\nis_bored \"Do you like ice cream with your dog?\"\nis_bored \"Do you\
    \ like pizza with your dog?\"\nis_bored \"Do you like ice cream with your dog?\"\
    \nis_bored \"Do you like pizza with your dog?\"\nis_bored \"Do you like ice cream\
    \ with your dog?\"\nis_bored \"Do you like pizza with your dog?\"\nis_bored \"\
    Do you like ice cream with your dog?\"\nis_bored \"Do you like pizza with your\
    \ dog?\"\nis_bored \"Do you like ice cream with your dog?\"\nis_bored \"Do you\
    \ like pizza with your dog?\"\nis_bored \"Do you like ice cream with your dog?\"\
    \nis_bored \"Do you like pizza with your dog?\"\nis_bored \"Do you like ice cream\
    \ with your dog?\"\nis_bored \"Do you ", "    boredoms = 0\n    i = 0\n    while\
    \ i < length(s) do\n        if s[i] == 'I' then\n            i = i + 1\n     \
    \   else\n            i = i + 1\n        end\n    end\n    boredoms = i - 1\n\
    \    return boredoms\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"\
    cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"\
    >\n</div><div class=\"inner_cell\">\n<div class=\"text_cell_render border-box-sizing\
    \ rendered_html\">\n<h3 id=\"Exercise-2\">Exercise<a class=\"anchor-link\" href=\"\
    #Exercise-2\">&#182;</a></h3><p>Write a function that takes in a string and returns\
    \ whether or not the string contains a word that starts with an uppercase letter.</p>\n\
    </div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell rendered\"\
    ><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"\
    text_cell_render border-box-sizing rendered_html\">\n<p>For example, if <code>s\
    \ = 'Hello World'</code>, <code>hello</code> is a valid word while <code>Hell</code>\
    \ is an invalid word.</p>\n<p>Note that 'Hello' and 'Hello!' are different words.</p>\n\
    </div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell rendered\"\
    ><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"\
    text_cell_render border-box-sizing rendered_html\">\n<p><strong><code>.</code></strong></p>",
  "\tcount = 0\n\tfor i in 0..(s.length - 1) do\n\t\tcount += s[i] == 'I' && s[i +\
    \ 1] == '.' && s[i + 2] == '?'\n\t\tcount = count && s[i] == '!' && s[i + 1] ==\
    \ '!'\n\t\tcount = count && s[i + 1] == '.'\n\t\tcount = count && s[i + 2] ==\
    \ '.'\n\t\tcount = count && s[i] == '.'\n\tend\n\treturn count\nend", "  return\
    \ s[0] == \"I\" && s.include?(\".\") && !s.include?(\"!\") && !s.include?(\"?\"\
    )\nend", "  s.include?(\"I\")\nend", "  boredoms = 0\n  s.split(\" \").each do\
    \ |word|\n    if word =~ /^I\\w*$/ and word =~ /^\\./\n      boredoms += 1\n \
    \   end\n  end\n  boredoms\nend", "  return s.include? \"I\"\nend", "  return\
    \ s.include?(\"I\") && s.count(\"I\") == 3\nend", "    boredoms = [\"I\",\"me\"\
    ,\"my\",\"myself\",\"we\",\"our\",\"ours\",\"ourselves\",\n                \"\
    you\",\"your\",\"yours\",\"yourself\",\"yourselves\",\"he\",\"him\",\n       \
    \         \"his\",\"himself\",\"she\",\"her\",\"hers\",\"herself\",\"it\",\"its\"\
    ,\n                \"itself\",\"they\",\"them\",\"their\",\"theirs\",\"themselves\"\
    ,\n                \"what\",\"which\",\"who\",\"whom\",\"this\",\"that\",\"these\"\
    ,\"those\",\n                \"am\",\"is\",\"are\",\"was\",\"were\",\"be\",\"\
    been\",\"being\",\"have\",\"has\",\n                \"had\",\"having\",\"do\"\
    ,\"does\",\"did\",\"doing\",\"a\",\"an\",\"the\",\"and\",\n                \"\
    but\",\"if\",\"or\",\"because\",\"as\",\"until\",\"while\",\"of\",\"at\",\"by\"\
    ,\"for\",\n                \"with\",\"about\",\"against\",\"between\",\"into\"\
    ,\"through\",\"during\",\"before\",\n                \"after\",\"above\",\"below\"\
    ,\"to\",\"from\",\"up\",\"down\",\"in\",\"out\",\"on\",\n                \"off\"\
    ,\"over\",\"under\",\"again\",\"further\",\"then\",\"once\",\"here\",\"there\"\
    ,\n                \"when\",\"where\",\"why\",\"how\",\"all\",\"any\",\"both\"\
    ,\"each\",\"few\",\"more\",\n                \"most\",\"other\",\"some\",\"such\"\
    ,\"no\",\"nor\",\"not\",\"only\",\"own\",\"same\",\n                \"so\",\"\
    than\",\"too\",\"very\",\"s\",\"t\",\"can\",\"will\",\"just\",\"don\",\n     \
    \           \"should\",\"now\",\"d\",\"ll\",\"m\",\"o\",\"re\",\"ve\",\"y\"]\n\
    \    words = s.split() #split string s into list words\n    boredoms_count = 0\n\
    \    for word in words:\n        if word in boredoms:\n            boredoms_count\
    \ += 1\n    return boredoms_count", "    boredoms = {\n        \"I\",\n      \
    \  \"me\",\n        \"he\",\n        \"him\",\n        \"his\",\n        \"her\"\
    ,\n        \"it\",\n        \"them\",\n        \"my\",\n        \"you\",\n   \
    \     \"your\",\n        \"yours\",\n        \"yourself\",\n        \"yourselves\"\
    ,\n    }\n    count = 0\n    split = s.split(\".\")\n    for word in split:\n\
    \        count += 1 if word not in boredoms else 0\n    return count", "  s =\
    \ s.downcase\n  s.gsub!(/[.!?]/, '')\n  s.gsub!(/\\s*I\\s*/i, '')\n  s.chars.empty?\n\
    end", "    s = s.downcase\n    bored = 0\n    s.gsub!(\"^i\", \"\") # Remove \"\
    i\"\n    s.gsub!(\"^\\.\", \"\") # Remove \".\"\n    s.gsub!(\"^!\", \"\") # Remove\
    \ \"!\"\n    s.gsub!(\"[.?!]\", \"\")\n    \n    sentences = s.split(\".\") #\
    \ Split into sentences\n    sentences.each do |sentence|\n        bored += 1 if\
    \ sentence =~ /^i/ # Count boredoms\n    end\n    \n    return bored\nend\n</cell>\n\
    <cell>", "  return s.include?(\"I\") && s.include?(\".\") && s.include?(\"?\"\
    ) && s.include?(\"!\")\nend\nis_bored(\"I saw a fish named Wolverine.\")\nis_bored(\"\
    My sister said he would go to heaven.\")\nis_bored(\"My sister said he would go\
    \ to heaven today.\")\nis_bored(\"He went to heaven yesterday.\")\nis_bored(\"\
    I saw a fish named Wolverine.\")\nis_bored(\"He went to the beach.\")\nis_bored(\"\
    He went to the beach yesterday.\")\nis_bored(\"He went to the beach today.\")\n\
    is_bored(\"He went to the beach tomorrow.\")\nis_bored(\"He went to the beach\
    \ yesterday evening.\")\nis_bored(\"He went to the beach next week.\")\nis_bored(\"\
    He went to the beach next month.\")\nis_bored(\"He went to the beach next year.\"\
    )\nis_bored(\"He went to the beach next year.\")\nis_bored(\"I saw a fish named\
    \ Wolverine.\")\nis_bored(\"He went to the beach next month.\")\nis_bored(\"He\
    \ went to the beach next year.\")\nis_bored(\"He went to the beach next month.\"\
    )\nis_bored(\"He went to the beach next month.\")\nis_bored(\"He went to the beach\
    \ next month.\")\nis_bored(\"He went to the beach next month.\")\nis_bored(\"\
    He went to the beach next month.\")\nis_bored(\"He went to the beach next month.\"\
    )\nis_bored(\"He went to the beach next month.\")\nis_bored(\"He went to the beach\
    \ next month.\")\nis_bored(\"He went to the beach next month.\")\nis_bored(\"\
    He went to the beach next month.\")\nis_bored(\"He went to the beach next month.\"\
    )\nis_bored(\"He went to the beach next month.\")\nis_bored(\"He went to the beach\
    \ next month.\")\nis_bored(\"He went to the beach next month.\")\nis_bored(\"\
    He went to the beach next month.\")\nis_bored(\"He went to the beach next month.\"\
    )\nis_bored(\"He went to the beach next month.\")\n", "  s.chars.each do |c|\n\
    \    return true if c == '.' || c == '?' || c == '!'\n  end\n  return false\n\
    end", "  s.split('.').count 'I'\nend", "  s.downcase!\n  s.gsub!(/\\.|!/, '')\
    \ # remove stopwords\n  s.gsub!(/(?:^|\\s)([I])/, '\\1bored') # prepend bored\n\
    \  s.gsub!(/[?!]/, '') # remove question marks\n  return s =~ /^bored$/ ? true\
    \ : false\nend\n</cell>\n<text>\nRun the cell below to test your function", " \
    \ s.split(\".\").each do |word|\n    puts \"I\" if word == \"I\"\n  end\nend\n\
    is_bored \"Idios!\"", "  return s.start_with?('I')\nend", "    boredoms = 0\n\
    \    \n    # Check for sentence delimiters.\n    if s == '.'\n        boredoms\
    \ += 1\n    if s == '?'\n        boredoms += 1\n    if s == '!'\n        boredoms\
    \ += 1", "    # Split s on \".\", \"?\", and \"!\".\n    array = s.split(\".?!\"\
    )\n    \n    # Count how many times \"I\" appears in s.\n    count = 0\n    for\
    \ word in array\n        if word == \"I\"\n            count += 1\n    \n    return\
    \ count\n    \nprint(is_bored(\"Is that all? No? Then what?\")) # 2\nprint(is_bored(\"\
    He is bored.\")) # 0\nprint(is_bored(\"I like cars!\")) # 1", "  s.include?('I')\n\
    end", "  s.split(//).all? { |word| word == 'I' }.count\nend", "  return s.split(%r{(\\\
    .|\\?|\\!)}).length == 1\nend", "  s.split == '.?!'\nend", "  count = 0\n  s.scan(/(?:^|\\\
    s)I.*?(?:$|\\s)/).each do |word|\n    count += 1 if word == \"I\"\n  end\n  count\n\
    end", "    # Split s into tokens by splitting on whitespace boundaries.\n    tokens=s.split()\n\
    \    # Return the number of tokens with \"I\" as the first\n    # word.\n    return\
    \ tokens.count(\"I\")", "  # Return the number of boredoms in a string.\n  count\
    \ = 0\n  i = s[0]\n  while i != \"I\" do\n    if s[i] == \"I\" then\n      count\
    \ = count + 1\n    end\n    i = s[i+1]\n  end\n  return count\nend", "  return\
    \ s.split(/\\W+/)[0].eql? \"I\"\nend", "  return s[0] == 'I' and s[3] or s[5]\
    \ == '!' and s[6] or s[9] == '?'\nend\n</cell>\n<text>\nNow you can put it all\
    \ together into a function, which will return a count for the given string.",
  '  return s.scan(/^I[^.?!]/)[0].size > 0', "  s.split.any? { |word| word.start_with?('I')\
    \ }\nend\n</pre>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing\
    \ text_cell rendered\"><div class=\"prompt input_prompt\">\n</div>\n<div class=\"\
    inner_cell\">\n<div class=\"text_cell_render border-box-sizing rendered_html\"\
    >\n<h2 id=\"Code-Used\">Code Used<a class=\"anchor-link\" href=\"#Code-Used\"\
    >&#182;</a></h2><p>We used the code written above in this notebook to learn about\
    \ data structures. The code is available on <a href=\"https://github.com/johnmcfarland/Data-Structures-for-Practice\"\
    >GitHub</a>.</p>", "\ts.split('.')[0].include?('I')\nend", "  s.split('.').size.zero?\n\
    end", "  return s.start_with?(\"I\")\nend", "  s.scan(/[\\.\\?!]I/i).count\nend",
  "  s.chars.grep(/\\bI/).size\nend", "  s.split(\" \").map(&:capitalize).all? do\
    \ |word|\n    word[0] === \"I\"\n  end\nend", "    i = s.index(\"I\")\n    return\
    \ s.count(\".\") == 3 or s.count(\"?\") == 1 or s.count(\"!\") == 1", "    i =\
    \ 0\n    while i < s.length and s[i] == 'I' and s[i+1] == '?'\n        i += 1\n\
    \    i = s.length - 1\n    while i >= 0 and s[i] != '!'\n        i -= 1\n    return\
    \ i != 0", "    i = 0\n    while i < s.length\n        if s[i] =~ /^[ie]$/\n \
    \           return true\n        end\n        i = i + 1\n    end\n    return false\n\
    end", "  return s.split(0,1).any? {|w| w == \"I\"}\nend", "  s.gsub!(/([.?!])/,\
    \ '\\1'.freeze)\n  s.gsub!('I', '\\1'.freeze)\n  s.gsub!('\\1'.freeze, 'I'.freeze)\n\
    \  s.gsub!('!', '\\1'.freeze)\n  s.gsub!('\\1'.freeze, '!'.freeze)\n  s.downcase!\n\
    \  s.chomp!\n  s.scan(/^I(.*)$/)\nend", "    count=0\n    bored=s.index(\"I\"\
    )+1\n    bored=bored-s.rindex(\".\",0,bored)\n    bored=bored-s.rindex(\"?\",0,bored)\n\
    \    bored=bored-s.rindex(\"!\",0,bored)\n    count=bored\n    return count\n\
    \        \nprint is_bored( \"What a bored world, you say? I love you and don't\
    \ think about anything else.\" )\nprint is_bored( \"You think I'm just going to\
    \ shoot myself in the foot with a cannon, will you? You get it buddy.\" )\nprint\
    \ is_bored( \"You think I'm just going to shoot myself in the foot with a cannon,\
    \ will you? You get it buddy.\" )\nprint is_bored( \"I guess not, I won't bother\
    \ to shoot myself in the foot with a cannon, will you? You get it buddy.\" )\n\
    print is_bored( \"I guess not, I won't bother to shoot myself in the foot with\
    \ a cannon, will you? You get it buddy.\" )\n</cell>\n<cell>", "    count = 0\n\
    \    for word in s.split(\" \")\n        if word[0] == \"I\"\n            count\
    \ += 1\n    return count\n</code>\nNow the code will work for any word. For example,\
    \ if I type \"I'm not a boredom.\" it will return 1, because there is only one\
    \ boredom.\n<|/ a dscore=0 |>\n<| a tags=ruby,loops dscore=0 |>\nYou can use the\
    \ below code to get count of boredom in a string:\n<code>\nstring = 'I am not\
    \ bored to tell you my boredom is. I am not bored to tell you my boredom is. I\
    \ am not bored to tell you my boredom is. I am not bored to tell you my boredom\
    \ is. I am not bored to tell you my boredom is. I am not bored to tell you my\
    \ boredom is. I am not bored to tell you my boredom is. I am not bored to tell\
    \ you my boredom is. I am not bored to tell you my boredom is. I am not bored\
    \ to tell you my boredom is. I am not bored to tell you my boredom is. I am not\
    \ bored to tell you my boredom is. I am not bored to tell you my boredom is. I\
    \ am not bored to tell you my boredom is. I am not bored to tell you my boredom\
    \ is. I am not bored to tell you my boredom is. I am not bored to tell you my\
    \ boredom is. I am not bored to tell you my boredom is. I am not bored to tell\
    \ you my boredom is. I am not bored to tell you my boredom is. I am not bored\
    \ to tell you my boredom is. I am not bored to tell you my boredom is. I am not\
    \ bored to tell you my boredom is. I am not bored to tell you my boredom is. I\
    \ am not bored to tell you my boredom is. I am not bored to tell you my boredom\
    \ is. I am not bored to tell you my boredom is. I am not bored to tell you my\
    \ boredom is. I am not bored to tell you my boredom is. I am not bored to tell\
    \ you my boredom is. I am not bored to tell you my boredom is. I am not bored\
    \ to tell you my boredom is. I am not bored to tell ", "  s.split('.').count.('?').count.('!')\n\
    end\n</cell>\n<cell>", "    count = 0\n    for word in s.split\n        if word\
    \ == 'I'.first\n            count += 1\n        end\n    end\n    count\nend",
  "  s.scan(/\\bI\\b/).count\nend\n</cell>\n<code language=julia-1.3>\nis_bored(s)\n\
    </cell>\n<text>\nQ2. Implement is_bored function.\nHint 1: Remember that regex\
    \ starts with ^.\nHint 2: Remember that you can scan all characters in a string\
    \ with scan.", "    return s.chars[0] == \"I\"\nend", "  s.gsub!(/[.?!]/, '')\n\
    \  s.split(' ').count { |word| word =~ /^I/ }\nend\n</pre>\n          </li>\n\
    \          <li>\n            <p>\n              <strong>Exercise</strong>\n  \
    \            Write a function called \"is_bored(s)\" that takes a string\n   \
    \           of words and returns true if the string contains more than\n     \
    \         one boredom and false otherwise.\n            </p>\n          </li>\n\
    \          <li>\n            <p>\n              <strong>Exercise</strong>\n  \
    \            Write a function called \"is_bored(s)\" that takes a string\n   \
    \           of words and returns true if the string contains more than\n     \
    \         one boredom and false otherwise.\n            </p>\n          </li>\n\
    \        </ul>\n        \n        <ul>\n          <li>\n            <p>\n    \
    \          <strong>Exercise</strong>\n              Write a function called \"\
    is_bored(s)\" that takes a string\n              of words and returns true if\
    \ the string contains more than\n              one boredom and false otherwise.\n\
    \            </p>\n          </li>\n          <li>\n            <p>\n        \
    \      <strong>Exercise</strong>\n              Write a function called \"is_bored(s)\"\
    \ that takes a string\n              of words and returns true if the string contains\
    \ more than\n              one boredom and false otherwise.\n            </p>\n\
    \          </li>\n          <li>\n            <p>\n              <strong>Exercise</strong>\n\
    \              Write a function called \"is_bored(s)\" that takes a string\n \
    \             of words and returns true if the string contains more than\n   \
    \           one boredom and false otherwise.\n            </p>\n          </li>\n\
    \          <li>\n            <p>\n              <strong>Exercise</strong>\n  \
    \            Write a function called \"is_bored(s)\" that takes a string\n   \
    \           of words and returns true if the string contains more than\n     \
    \         one boredom and false otherwise.\n            </p>\n          </li>\n\
    \          <li>\n            <p>\n              <strong>Exercise</strong>\n  \
    \            Write a function called \"is_bored(s)\" that takes a string\n   \
    \           of words and returns true if the string contains more than\n     \
    \         one boredom and false otherwise.\n            </p>\n          </li>\n\
    \          <li>\n            <p>\n              <strong>Exercise</strong>\n  \
    \            Write a function called \"is_bored(s)\" that takes a string\n   \
    \           of words and returns true if the string contains more than\n     \
    \         one boredom and false otherwise.\n            </p>\n          </li>\n\
    \        </ul>\n        \n        <ul>\n          <li>\n            <p>\n    \
    \          <strong>Exercise</strong>\n              Write a function called \"\
    is_bored(s)\" that takes a string\n", "  boredoms = %w(i ii iii iv v vi vii viii).select\
    \ {|word| s.starts_with(word) }\n  boredoms.count { |b| b == 'i' }\nend\n</pre>",
  "    # Split s into tokens by using space as a delimiter\n    tokens = s.split(\"\
    \ \") \n    count = 0\n    # Iterate through tokens and add one for each boredom\n\
    \    for token in tokens:\n        # Check if token starts with an \"I\"\n   \
    \     if token.startswith(\"I\"):\n            count += 1\n    return count\n\
    </cell>\n<text>\nRun the following cell to check your implementation. Does it\
    \ count how many boredoms are there in each provided string?", "    s.length ==\
    \ 1 && s[0] == 'I' ? true : false\nend\n</cell>\n<cell>", "    bored = 0\n   \
    \ i = 0\n    while i < s.length\n      if s[i] == \"I\" and s[i+1] != \"I\" and\
    \ s[i+1] != \"!\"\n        bored++\n      i += 1\n    return bored\nend", "  s.split(\"\
    .\").count(\"I\") > 0\nend", "  word = 'I' if s.start_with?('I') else nil\n  sentence\
    \ =~ (/(\\.|\\?|!)/ and word =~ /^I(\\.|!)?/)\nend", "    count = 0\n    i = 0\n\
    \    while i < s.length\n        if s[i] == \"i\"\n            count += 1\n  \
    \      i += 1\n    end", "  s.split('.').count 'I' > 0\nend\n</cell>\n<code language=julia-0.6>",
  "  s.split('.').include? \"I\"\nend", "  s.downcase!\n  return s.include?('i')\n\
    end", "    count = 0\n    for c in s\n        if c == 'I'\n            count +=\
    \ 1\n    return count", "  s.chars.any? { |ch| ch == '.' || ch == '?' || ch ==\
    \ '!' }\nend", "    \n    is_boredom = s.split(\" \") if \".\" in s else [s]\n\
    \    return s.startswith(\"I\") or any(s.startswith(x) for x in [\"I'\", \"i\"\
    ])\n</cell>\n<cell>\nassert is_bored(\"Bored. I'm bored.\")\nassert not is_bored(\"\
    I'm sleepy\")\n</cell>\n<cell>", "  s.chomp\n  if s.include? \"I\"\n    return\
    \ true\n  else\n    return false\n  end\nend", "  s.split('.').map { |w| w ==\
    \ 'I' ? 1 : 0 }.sum == 0\nend", "  s.gsub!(/\\.|\\?|!/, '')\n  if s == 'I'\n \
    \   1\n  else\n    0\n  end\nend\nprint(is_bored(ARGV[0]))", "    return s.downcase[0]\
    \ == 'i'", "  s.downcase!\n  s.gsub(/[^ !?.]/, '')\n  s.start_with?('I')\nend",
  "  s.gsub(/^I/, '').split('.')\nend", "  return s[0] == 'I'\nend\n</cell>\n<code\
    \ language=julia-0.5>\n@assert is_bored(\"What is the airspeed of an unladen swallow\
    \ ?\") #false\n@assert is_bored(\"I am sick\") #false\n@assert is_bored(\"I like\
    \ swallows\") #false\n@assert is_bored(\"The sky is blue\") #true\n@assert is_bored(\"\
    Swallow\") #true\n</cell>\n<text>\nTask 1: Complete the function count_boredoms.",
  "  s.split('.').count { |w| w.index(\"I\") }\nend\n</cell>\n<code language=julia-1.0>\n\
    is_bored(s)\n</cell>\n<text>\nis_bored also works with arrays:", "    boredoms\
    \ = [ 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I', 'I' ]\n\
    \    count = 0\n    for word in s.split(\" \"):\n        if word not in boredoms:\n\
    \            count += 1\n    return count", "  s.split('.')\n  s.split('?')\n\
    \  s.split('!')\n  s.split(' I')\n  s.split('I')\n  s.split('I.')\n  s.split('I?.')\n\
    \  s.split('I?!?')\n  s.split('I!?')\n  s.split('!')\n  s.split('!.')\n  s.split('?!')\n\
    \  s.split('?!.')\n  s.split('?')\n  s.split('?.')\n  s.split('.?!')\n  s.split('.!?')\n\
    \  s.split('?!?.')\n  s.split('!?.')\n  s.split('!?!')\n  s.split('I?!?')\n  s.split('I!?')\n\
    \  s.split('I?!')\n  s.split('I?.')\n  s.split('.?')\n  s.split('.!?')\n  s.split('!?.')\n\
    \  s.split('!?!')\n  s.split('.?!')\n  s.split('.?!?')\n  s.split('.!?')\n  s.split('.?!?!')\n\
    \  s.split('!?!?')\n  s.split('!?!')\n  s.split('!?.')\n  s.split('.!?!')\n  s.split('.!?!?')\n\
    \  s.split('.?!?!')\n  s.split('?!?!')\n  s.split('!?!?')\n  s.split('!?!')\n\
    \  s.split('!?.')\n  s.split('.?!?!')\n  s.split('?!?!?')\n  s.split('?!?!.')\n\
    \  s.split('?!?!?!')\n  s.split('?!?!?.')\n  s.split('!?!?!?')\n  s.split('!?!?!.')\n\
    \  s.split('!?!?!?!')\n  s.split('!?!?!?.')\n  s.split('!?!?!?!?')\n  s.split('!?!?!?!.')\n\
    \  s.split('!?!?!?!?!')\n  s.split('!?!?!?!?.')\n  s.split('!?!?!?!?!?')\n  s.split('!?!?!?!?!.')\n\
    \  s.split('!?!?!?!?!?!')\n  s.split('!?!?!?!?!?')\n  s.split('!?!?!?!?!.')\n\
    \  s.split('!?!?!?!?", "  s.downcase!\n  s.gsub!(/\\?/,'')\n  s.gsub!(/\\!/,'')\n\
    \  s.gsub!(/\\./,'')\n  s.gsub!(/I/,' ')\n  s.gsub!(/[,?!]+/,'')\n  s.count('I')\
    \ > 0\nend", "    return s =~ /^I.*\\.$/\nend\nprint is_bored( \"I like animals.\
    \ I hate turtles.\" ) # prints true", "  s = s.downcase\n  s.sub!(/[\\.\\?\\!]/,\
    \ '')\n  s.sub!(\"i'm\", 'i am')\n  s.sub!(\"i'll\", 'i will')\n  s.sub!(\"i'd\"\
    , 'i would')\n  s.sub!(\"i've\", 'i have')\n  s.sub!(\"i're\", 'i are')\n  s.sub!(\"\
    i'll\", 'i will')\n  s.sub!(\"i've\", 'i have')\n  s.sub!(\"i'd\", 'i would')\n\
    \  s.sub!(\"i're\", 'i are')\n  s.sub!(\"i'm\", 'i am')\n  s.sub!(\"i've\", 'i\
    \ have')\n  s.sub!(\"i'll\", 'i will')\n  s.sub!(\"i'd\", 'i would')\n  s.sub!(\"\
    i've\", 'i have')\n  s.sub!(\"i'll\", 'i will')\n  s.sub!(\"i'd\", 'i would')\n\
    \  s.sub!(\"i're\", 'i are')\n  s.sub!(\"i've\", 'i have')\n  s.sub!(\"i'd\",\
    \ 'i would')\n  s.sub!(\"i're\", 'i are')\n  s.sub!(\"i've\", 'i have')\n  s.sub!(\"\
    i'll\", 'i will')\n  s.sub!(\"i'd\", 'i would')\n  s.sub!(\"i're\", 'i are')\n\
    \  s.sub!(\"i'm\", 'i am')\n  s.sub!(\"i've\", 'i have')\n  s.sub!(\"i'll\", 'i\
    \ will')\n  s.sub!(\"i'd\", 'i would')\n  s.sub!(\"i're\", 'i are')\n  s.sub!(\"\
    i've\", 'i have')\n  s.sub!(\"i'll\", 'i will')\n  s.sub!(\"i'd\", 'i would')\n\
    \  s.sub!(\"i're\", 'i are')\n  s.sub!(\"i've\", 'i have')\n  s.sub!(\"i'll\"\
    , 'i will')\n  s.sub!(\"i'd\", 'i would')\n  s.sub!(\"i're\", 'i are')\n  s.sub!(\"\
    i've\", 'i have')\n  s.sub!(\"i'll\", 'i will')\n  s.sub!(\"i'd\", 'i would')\n\
    \  s.sub!", "    return s.scan(/\\bI\\b/) != nil\nend", "    count = 0\n    s.split('.').each\
    \ { |x|\n      if x.match(/^I.*[.!?]$/)\n        count += 1\n      end\n    }\n\
    \    return count\nend", "  s.downcase!\n  if s !~ /^[Ii][.?!]*\\./\n    puts\
    \ \"false\"\n    return\n  end\n  boredom_count = 0\n  s.gsub(/^[Ii][.?!]*\\./)\
    \ { |s| boredom_count += 1; s }\n  puts \"#{boredom_count}\"\nend", "    boredoms\
    \ = [\"I\", \"you\", \"we\", \"us\", \"i\", \"you\", \"we\", \"us\"]\n    count\
    \ = 0\n    i = 0\n    while i < len(s):\n        if s[i] == \".\" and s[i+1] ==\
    \ \".\":\n            count += 1\n            i += 2\n        elif s[i] in boredoms\
    \ and s[i+1] in boredoms:\n            count += 1\n            i += 2\n      \
    \  elif s[i] in boredoms and s[i+1] not in boredoms:\n            count += 1\n\
    \            i += 1\n        elif s[i] not in boredoms and s[i+1] in boredoms:\n\
    \            count += 1\n            i += 1\n        else:\n            i += 1\n\
    \    return count", "    i = 0\n    while i < len(s)\n        if s[i] == \"i\"\
    \ and not s[i+1].isalpha() and s[i+2].isalpha()\n            return true\n   \
    \     end\n        i += 1\n    return false\nend\n</cell>\n<code language=julia-1.0>",
  "  s.gsub(/[?!.]/, '')\nend", "  return s.chars.grep(/\\bI\\b/).length == 0\nend\n\
    </pre>", "    boredom_words = {'I', 'I', 'I', 'I', 'I', \"'\"}\n    boredom_count\
    \ = 0", "  s.downcase!\n  s = s.gsub(/[\\.\\?\\!]/, ' ').gsub(/\\bI /, '').gsub(/\\\
    bI\\. /, '').downcase\n  s = s[0].to_i + (s[1..-1].to_i).count('I') + s[1].to_i\n\
    \  # A sentence must start with an \"I\"\n  return s > 0\nend\n</cell>\n<cell>\n\
    assert is_bored(\" is it a boredom ?\") #=> true\n</cell>\n<cell>\nassert is_bored(\"\
    \ I am bored\") #=> false\n</cell>\n<cell>\nassert is_bored(\" I am not a boredom.\"\
    ) #=> false\n</cell>\n<cell>", "    s_array = s.split('.')\n    count_bored =\
    \ 0\n    for i in s_array\n        if i == 'I'\n            count_bored += 1\n\
    \    return count_bored\n</code>\nNow, we can write our main program like so:\n\
    <code>", "  s.each_char do |c|\n    return false if c != 'I'\n  end", "    bored\
    \ = [ 'I' ]\n    for x in s:\n        if x in bored:\n            return 1\n \
    \       else:\n            bored.append(x)\n    return 0", "  boredoms = {'I',\
    \ 'I'm, 'I', 'I\\'m', 'I\\'re', 'I', 'I\\'ve', 'I'll, 'I', 'I', 'I\\'ll', 'I',\
    \ 'my', 'I\\'ve'}\n  words = s.split #split into array of words\n  bored = 0 \n\
    \  for word in words do\n    if word <> 'I' and word <> 'my' and word <> '!' then\n\
    \      bored = bored + 1\n    end\n  end\n  return bored\nend", "  # +++your code\
    \ here+++\n  s.split.include? \"i\"\nend", "  s.starts_with?('I')\nend", "  s.gsub!(/[.?!]/,'')\n\
    \  s.split(' ').each do |word|\n    if word == 'I' then\n      return true\n \
    \   end\n  end\n  return false\nend", "    s.count('I')\nend\nBreath First", " \
    \ boredom_words = [\"I\"]\n  \n  s.downcase!\n  s = s.gsub(/['?!\\.]/,'')\n  \n\
    \  boredom_words.each do |b|\n    s.sub!(/#{b}/, '')\n  end\n  \n  s.empty? ||\
    \ s.to_i == 0\nend\n</pre>\n<p>\n  Given the following inputs:\n</p>\n<pre>\n\
    1.  \"I am not a boredom.\"\n2.  \"I am a boredom.\"\n3.  \"I am not a boredom.\"\
    \n4.  \"I am not a boredom, and he is a boredom.\"\n</pre>\n<p>\n  Your code should\
    \ return the following:\n</p>\n<pre>\n1.  1\n2.  1\n3.  0\n4.  1\n</pre>\n<p>\n\
    \  In other words, if the string ends with one of the words \"I\", \"am\",\n \
    \ \"are\", \"am\", or \"were\", then it is a boredom.\n</p>\n<p>\n  Assume that\
    \ you are given a string of words <em>without</em> the\n  delimiters.\n</p>\n\
    <h3 id=\"ruby-string-split\">\n  ruby.string.split\n</h3>\n<p>\n  Ruby has the\
    \ <code>split</code> method which takes two arguments:\n</p>\n<ul>\n  <li>\n \
    \   <em>delimiter</em>\n  </li>\n  <li>\n    <em>string</em>\n  </li>\n</ul>\n\
    <p>\n  In ruby, you can split a string into an array of strings using a \n  delimiter.\
    \ For example:\n</p>\n<pre>\n\"hello,bye,how,are,you\".split(',') # [\"hello,bye\"\
    , \"how,are,you\"]\n</pre>\n<p>\n  The <code>split</code> method can also take\
    \ an optional second \n  argument that specifies the maximum number of splits.\
    \ For example, \n  splitting a string into an array of strings using \n  a comma\
    \ as delimiter and limiting the number of splits to two:\n</p>\n<pre>\n\"hello,bye,how,are,you\"\
    .split(',', 2) # [\"hello,bye\", \"how\"]\n</pre>\n<p>\n  If the first argument\
    \ is an integer, <code>split</code> will split the\n  string into an array of\
    \ strings  up to that number:\n</p>\n<pre>\n\"hello,bye,how,are,you\".split(',',\
    \ 1) # [\"hello,bye\"]\n</pre>\n<p>\n  If the second argument is a positive integer,\
    \ <code>split</code> will \n  only split the string into that number of substrings:\n\
    </p>\n<pre>\n\"hello,bye,how,are,you\".split(',', 2) # [\"hello,bye\", \"how,are,you\"\
    ]\n", "  s.gsub(/(^I)/, \"\\\\1\\\\.\")\n  s.gsub(/(\\?|\\!)/, \"\\\\1\\\\.\"\
    )\n  s.gsub(/(\\..*)/, \"\\\\1\")\nend", "  return true if s.include? \"I\"\n\
    \  return false\nend", "  s = s[0].capitalize\n  s.count('I')\nend", "    count_boredoms\
    \ = 0\n    for c in s.chomp('.!?')\n        count_boredoms += 1\n        if c\
    \ == 'i'\n            break\n    end\n    return count_boredoms\nend", "  # Initialize\
    \ the count to 0.\n  count = 0.\n  # Loop through each character in the string.\n\
    \  for c in s\n    # If the character is a 'I', add one to the count variable.\n\
    \    if c == \"I\"\n      count += 1\n  # Return the boredom count.\n  return\
    \ count", "  s.split == '.' || s.split == '?' || s.split == '!'\nend", "  s.split('.').map\
    \ {|word| word.index('i') }.uniq.size > 0\nend", "    s = s.split(' ')\n    return\
    \ s[0].lower().startswith('i') and len(s) > 1", "  s.downcase!\n  s.gsub!(/[.?!]/,\
    \ '') # remove these punctuation marks\n  s.scan(/\\b[I]/).size # return the number\
    \ of times \"I\" appears in s\nend\n</pre>\n</div>", "  # Initialize the count\
    \ here to zero.\n  count = 0\n  # Loop through each character in s.\n  for i in\
    \ s\n    # If the character is a '.', then increment the count by 1.\n    if i\
    \ == \".\"\n      # If s starts with \"I\", then increment the count by 1.\n \
    \     if s == \"I\"\n        count += 1\n    end\n  end\n  # Return the count\
    \ here.\n  return count\nend\nis_bored(\"I feel great!\")\n</cell>\n<cell>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
