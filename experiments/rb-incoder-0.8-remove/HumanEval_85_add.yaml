name: HumanEval_85_add
language: rb
prompt: "# Given a non-empty list of integers lst. add the even elements that are\
  \ at odd indices..\n# Examples:\ndef add(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_add\n\
  \    candidate = method(:add)\n    assert_equal(88, candidate.call([4, 88]))\n \
  \   assert_equal(122, candidate.call([4, 5, 6, 7, 2, 122]))\n    assert_equal(0,\
  \ candidate.call([4, 0, 6, 7]))\n    assert_equal(12, candidate.call([4, 4, 6, 8]))\n\
  \  end\nend\n"
completions: [" \nend", "  even = lst.select { |x| x % 2 == 0 }\n  odd = lst.select\
    \ { |x| x % 2 != 0 }\n  even.zip(odd).map { |e| e[0] }\nend\nadd(lst) #=> [2,\
    \ 4, 6, 8]\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays,multidimensional-array\
    \ |>\nTo do it in one line (thanks to Ruby's splat operator):\n<code>\narr.reduce([])\
    \ { |memo, el| memo << [el] + arr[(memo.length-1)..-1].flatten(1) }", " lst=[]\n\
    \ lst.each do |el|\n  if el % 2 == 0\n   lst.push el\n  end\n end\n return lst\n\
    end\nadd([\"1\",\"3\",\"4\",\"5\"])\n</cell>\n<cell>", "  return [] if lst.empty?\
    \ # empty list -> []\n  return lst.map { |x| x * 2 if x % 2 == 0 } # even indices\
    \ are even, odd indices are odd\nend", "  even = []\n  odd = []\n  lst.each_with_index\
    \ do |e, i|\n    if i % 2 == 0\n      even << e\n    else\n      odd << e\n  \
    \  end\n  end\n  even.zip(odd).inject(:+)\nend", "  lst.inject(0){|sum, el| sum+el}\
    \ \nend", "    even = []\n    odd = []\n    i = 0\n    while i < lst.size\n  \
    \      if lst[i] % 2 == 0\n            even.push(lst[i])\n        else\n     \
    \       odd.push(lst[i])\n    end\n    i = 0\n    while i < even.size - 1\n  \
    \      if even[i] % 2 == 0\n            even.push(even[i])\n        end\n    \
    \    i += 1\n    end\n    i = 0\n    while i < odd.size - 1\n        if odd[i]\
    \ % 2 == 0\n            even.push(odd[i])\n        end\n        i += 1\n    end\n\
    \    return even\nend", "    lst1 = []\n    for i in lst\n        if i % 2\n \
    \           lst1.push(i)\n    return lst1\n</code>\n<|/ a |>\n<| c |>\nThanks,\
    \ but can you please give me an idea of how to solve it in a better way? I'm only\
    \ a beginner, and I really want to learn the correct way of solving these types\
    \ of problems because in the future they come up in my job interview questions\n\
    <|/ c |>\n<| c |>\nI added a solution to my answer. Hope it helps.\n<|/ c |>\n\
    <| c |>\nThat doesn't quite work. When I put \"[1,2,3,4], it returns [1,2,3] instead\
    \ of [2,4,6].\n<|/ c |>\n<| c |>\nIt returns [2,4,6] for me. Did you miss a `do`?\n\
    <|/ c |>\n<| c |>\nHmm. I'm on ruby 2.3.3\n<|/ c |>\n<| a dscore=0 tags=ruby,loops,arrays\
    \ |>\nHere's a solution using inject:\n<code>", "  return lst.map{|i| i + 2 if\
    \ i.odd?}.compact\nend\nadd(l) # => [2, 4, 6]\nadd(l) # => [2, 4, 6, 8, 10, 12]\n\
    add(l) # => [2, 4, 6, 8, 10, 12, 14, 16, 18]\nadd(l) # => [2, 4, 6, 8, 10, 12,\
    \ 14, 16, 18, 20]\nadd(l) # => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]\nadd(l)\
    \ # => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26]\nadd(l) # => [2, 4, 6,\
    \ 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]\nadd(l) # => [2, 4, 6, 8, 10,\
    \ 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34]\nadd(l) # => [2, 4, 6, 8, 10,\
    \ 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38]\nadd(l) # => [2, 4,\
    \ 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]\nadd(l)\
    \ # => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,\
    \ 40, 42, 44]\nadd(l) # => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28,\
    \ 30, 32, 34, 36, 38, 40, 42, 44, 46]\nadd(l) # => [2, 4, 6, 8, 10, 12, 14, 16,\
    \ 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50]\nadd(l)\
    \ # => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,\
    \ 40, 42, 44, 46, 48, 50, 52, 54]\nadd(l) # => [2, 4, 6, 8, 10, 12, 14, 16, 18,\
    \ 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,\
    \ 58]\nadd(l) # => [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,\
    \ 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60]\nadd(l) # => [2, 4,\
    \ 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,\
    \ 46, 48, 50, 52, 54, 56, 58, 60, 62, 64]\nadd(l) # => [2, 4, 6, 8, 10, 12, 14,\
    \ 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,\
    \ 54, 56, 58, 60, 62, 64, 66, 68]\nadd(l) # => [2, 4, 6, 8, 10, 12, 14, 16, 18,\
    \ 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, ", "    return lst +\
    \ lst.drop(1).select{ |i| i%2 == 0}\nend", "  # Your Code Here\nend", end, " \
    \ i = 0\n  evens = 0\n  while i < lst.length\n    if i % 2 == 0\n      evens +=\
    \ lst[i]\n    end\n    i += 1\n  end\n  lst.length = evens\nend", "  lst.each_with_index\
    \ do |n, i| \n    # If the ith element is odd, add it.\n    return n if i.odd?\n\
    \    # If the ith element is even, add it if it is in the odd indices.\n    lst[(i\
    \ + 1)%lst.size] += n if i.even?\n  end\nend", "  # code...\nend", "    # your\
    \ code here\n    return 0", "  return lst.select{|i| i%2 == 0}.inject(:+) \nend\n\
    assert add([])    == 0\nassert add([2])   == 2\nassert add([2, 3]) == 2\nassert\
    \ add([4, 2, 5])  == 7\nassert add([1, 3, 5])  == 5\nassert add([3, 5])  == 5\n\
    assert add([6, 5])  == 5\nassert add([6, 3, 5])  == 5\nassert add([6])    == 6\n\
    assert add([3, 6, 5])  == 6", "    lst = lst.to_a if lst.respond_to?(:to_a)\n\
    \    evens = []\n    odd = []\n    lst.each_with_index do |item, index|\n    \
    \  index % 2 == 0 ? even << item : odd << item\n    end\n    evens << odd\n  \
    \  evens.flatten\nend", "    lst.each_with_index do |x,i|\n      lst[i] << x if\
    \ i % 2 != 0\n    end\nend", "  even = []\n  odd = []\n  i = 0\n  while i < lst.length\n\
    \    if i % 2 == 0\n      even.push(lst[i])\n    else\n      odd.push(lst[i])\n\
    \    i += 1\n  end\n  even.zip(odd).each { |(ev, od)| lst.push(ev + od) }\n  lst\n\
    end\nprint(add(lst)) # should print => [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n</code>\n\
    <|/ a dscore=0 tags=arrays,ruby,sum |>\n<| c |>\nWhat do you mean by `each { |(ev,\
    \ od)| lst.push(ev + od) }`?\n<|/ c |>\n<| c |>\nIt creates a new array of pairs\
    \ based on the old array and adds them to the new array. See the [docs](http://ruby-doc.org/core-2.2.0/Array.html#method-i-zip)\
    \ for more info\n<|/ c |>\n<| a dscore=0 |>\nAnother solution that I use:\n<code>\n\
    arr = [1,2,3,4,5,6,7,8,9,10]\nresult = arr.each_with_index.with_object([]) { |(el,\
    \ index), arr| index % 2 == 0 ? arr.push(el) : arr.unshift(el) }\nresult", " \
    \ evens = []\n  for i in lst do\n    if i.even? then\n      evens << i\n    end\n\
    \  end\n  return evens\nend", "    # lst = [2, 3, 4, 6, 7]\n    # add([4, 6, 8,\
    \ 10])\n    # lst = [2, 4, 6, 8]\n    i = 0\n    j = 0\n    even = []\n    odd\
    \ = []\n    while i < len(lst):\n        if lst[i] % 2 == 0:\n            even.append(lst[i])\n\
    \            i += 1\n        else:\n            odd.append(lst[i])\n         \
    \   i += 1", "  evens = lst.take_while {|i| i % 2 == 0}\n  odds = lst.take_while\
    \ {|i| i % 2 != 0}\n  evens.concat(odds)\nend\nassert add [1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9]  == [2, 4, 6, 8, 10]\nassert add [5, 6, 7, 8, 9]        == [5, 6, 7, 8,\
    \ 9]", "    # Write your code here.\nend\n</cell>\n<code language=julia-1.1>",
  "  lst.each_with_index do |e, i|\n    if i % 2 == 0\n      lst.insert(i+1,e)\n \
    \   end\n  end\nend\n</cell>\n<cell>", "  lst.inject(0) { |a, x| a + (lst.count(x)\
    \ % 2 == 0 ? x : 0) }\nend\n</cell>\n<code language=ruby-1.9.3-p194>\nadd(lst)\n\
    </cell>\n<code language=ruby-1.9.3-p194>", "  even = nil\n  odd = nil\n  even\
    \ = lst[1]\n  even = nil\n  lst[1] = nil\n  odd = lst[0]\n  lst[0] = nil\n  even.times\
    \ do |i|\n    if lst[i].even?\n      even.push lst[i]\n      lst[i] = nil\n  \
    \  end\n  end\n  lst[0].each do |i|\n    if i.odd?\n      odd.push i\n      i\
    \ = nil\n    end\n  end\n  return even.to_s + \" #{even.count} #{even.count}/#{odd.count}\"\
    \nend", "  # Write your code here\nend", "  lst = lst.to_a\n  (lst[0 .. -1] &\
    \ lst[1 .. -1]).inject(0) do |sum, val|\n    sum + val\n  end\nend\nadd([1, 1,\
    \ 3, 5, 3, 5, 7, 7, 11])", "  even = []\n  odd = []\n  lst.each { |i| i % 2 ==\
    \ 0 ? even << i : odd << i }\n  even.zip(odd).flatten\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\n<code>", "    lst = lst + [lst[i] for i in range(0,len(lst),\
    \ 2)]\n    return lst\nend", "  even = lst[0 .. arr.length]\n  odd =  lst[1 ..\
    \ arr.length]\n  even.each do |i|\n    odd << arr[i] if (arr[i] + 1) mod 2\n \
    \ end\n  even.clear\nend\nadd(lst)\n=> [3, 5, 7, 11, 13]\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby |>\nThis is in Ruby 1.9.3. It should be fairly readable and\
    \ self-explanatory. \n<code>", "  lst.inject(0) do |sum, element|\n    sum + element\
    \ if element.odd? \n  end\nend", "  res = []\n  for i in lst\n    if i % 2 ==\
    \ 0\n      res << i\n    end\n  end\n  puts res\nend", " res = []\n lst.each do\
    \ |i|\n  if i.odd? && i =! lst.last\n   res << i\n  end\n end\n return res\nend",
  "  lst = lst.sort!\n  lst.each_with_index do |i, index|\n    if index % 2 == 1\n\
    \      lst[index] += i\n    end\n  end\n  lst\nend\n</cell>\n<code language=julia-0.6>\n\
    add(lst)\n</cell>\n<text>\nThe same can be done in a single line:", "  even_odd\
    \ = lst.select { |i| i.odd? }\n  even_odd.reduce(:+)\nend", "    even_pos = lst.each_with_index.select\
    \ { |(index, value)| index % 2 == 0 }.map(&:first)\n    lst.each_with_index.map\
    \ { |(value, index)| value + even_pos[index] }\nend\n</code>\n<|/ a tags=ruby,list,arrays\
    \ |>\n<| a dscore=2 |>\nYou could also use Array#map for this:\n<code>\na = [1,\
    \ 2, 3, 4, 5, 6]\np a.map.with_index { |e, i| a[i..-1].include?(e) ? e : 0 }",
  "  evens = []\n  odd =  []\n  n = 1\n  while n <= lst.size\n    if n % 2 == 0\n\
    \      evens << n\n      n += 1\n    else\n      odd << n\n      n += 1\n    end\n\
    \  end\n  evens.concat(odd)\n  evens\nend", "  return lst\nend", "  even = lst.select\
    \ { |x| x % 2 == 0 }\n  lst.select { |x| x % 2 == 1 }.each do |i|\n    even.push\
    \ lst[i]\n  end\n  even \nend", "    evens = lst[2..-1].each_with_index.reduce(:+)\n\
    \    odd_els = lst[1..-2].each_with_index.reduce(:+)\n    evens + odd_els\nend",
  "  sum = 0\n  for i in 0..(lst.length -1)\n    if i % 2 == 0\n      sum += lst[i]\n\
    \    end\n  end\n  return sum\nend", "\tevens=[]\n\todds=[]\n\tfor i in lst\n\t\
    \tif i%2==0\n\t\t\tevens.push i\n\t\telse\n\t\t\todds.push i\n\tend\n\tevens.concat\
    \ odds\n\tevens.sort\n\treturn evens\nend\nadd(3)\nadd(2)\nadd(4)\nadd(1)\nadd(5)\n\
    add(6)\nadd(7)", "  count = 0\n  for i in lst \n    if i%2 != 0\n      count +=\
    \ 1\n      lst[count] = i\n    else \n      lst[count] = lst[count] + 1\n    \
    \  count += 1\nend", "  lst.each_with_index do |num, index|\n    lst[index] +=\
    \ 2 if index % 2 == 0\n  end\n  lst\nend", "  lst.each_with_index do |x, i| \n\
    \    lst[i] += (x % 2 == 0) ? (x + 1) : x\n  end\nend\n</code>\n<|/ a |>\n<| a\
    \ |>\n<code>", "  lst.map{|e| e if e.odd?}.flatten\nend", "  lst.each_with_index\
    \ do |el, index|\n    next if index == 0\n    el += (lst[index-1] / 2) if index\
    \ % 2 == 1\n  end\nend", "  evens = []\n  odd = []\n  for i in 0..(lst.size %\
    \ 2)\n    if i = (lst.size % 2) == 0\n      evens.push(lst[i])\n    else\n   \
    \   odd.push(lst[i])\n    end\n  end\n  evens.each do |i|\n    lst.push(i)\n \
    \ end\n  odd.each do |i|\n    lst.push(i)\n  end\nend", "  lst.map {|x| lst.shift\
    \ if x%2 == 0}\nend\nadd(lst) #=> [4, 6]", "  if lst.empty?\n    return lst\n\
    \  res = []\n  even = lst.first(2)\n  odd = lst.last(2)\n  even.zip(odd) do |x,y|\n\
    \    if x.even? || y.even?\n      res << x.to_i + y.to_i\n    end\n  end\n  return\
    \ res\nend", "  even = 0\n  odd = 1", "  evens = []\n  odd = []\n  for i in lst.each_index\n\
    \    if i % 2 == 0\n      evens << i\n    else\n      odd << i\n    end\n  end\n\
    \  evens.concat(odd)\nend", "  odd_ints = lst.select { |el| el % 2 != 0 }\n  evens\
    \ = lst.select { |el| el % 2 == 0 }\n  odd_ints + evens\nend", "    even_count\
    \ = 0\n    lst.each_with_index do |item, index|\n        if index % 2 != 0\n \
    \           even_count += item\n        end\n    end\n    even_count\nend\nprint(add(lst))",
  "  sum = 0\n  for i in lst\n    if i.odd?\n      sum += i\n    end\n  end\n  sum\n\
    end", "    return lst + lst[(lst.index(1)):lst.index(2)]\nend", ' ', " \n  lst.each_with_index\
    \ do |num,idx|\n  if idx % 2 == 0 then\n    lst[idx] = num + num\n  end\n  end\n\
    end", "  even = []\n  odd = []\n  lst.each_with_index do |x,index|\n    if index.odd?\n\
    \      odd << x\n    elsif index.even?\n      even << x\n    end\n  end\n  even\
    \ + odd\nend", "    return lst + lst.select { |x| x % 2 == 0 }\nend", "  evens\
    \ = []\n  odd = lst[0..-1]\n  even = lst[1..-2]\n  evens << even unless even.nil?\
    \ || even.even?\n  even += 2 while even.odd?\n  odd.concat(evens)\nend", "  result\
    \ = 0\n  lst = lst.to_a\n  lst.each_with_index do |x, index|\n    if index % 2\
    \ != 0\n      result += x\n    end\n  end\n  return result\nend", "    evens =\
    \ []\n    odd_indices = []\n    odd_indices.each_with_index do |element, index|\n\
    \      if index % 2 == 0\n        evens.push(element)\n      else\n        odd_indices.push(index)\n\
    \      end\n    end\n    return evens\nend", "  even = lst.delete_at(lst.index(lst.first))\n\
    \  odd = lst.delete_at(lst.index(lst.last))\n  return even + odd\nend", "  even\
    \ = []\n  odd = []\n  for i in lst\n    if i % 2\n      odd << i\n    else\n \
    \     even << i\n  end\n  return even + odd\nend", "  result = 0\n  for i in lst\
    \ do \n    if i.even? then result += i\n  end\n  return result\nend", "  # Your\
    \ code here\nend", "  # Your code here\nend\n</cell>\n<cell>\nadd(lst_a) # Should\
    \ be [0,2,4,6]\n</cell>\n<cell>\nadd(lst_b) # Should be [0,2,4,6]\n</cell>\n<cell>\n\
    add(lst_c) # Should be [0,2,4,6]\n</cell>\n<text>\nPart 5: Subtraction\nGiven\
    \ a non-empty list of integers lst. subtract the even elements that are at odd\
    \ indices..\nExamples:\nlst = [1, 2, 3, 4] ==> lst = [1, 3, -3, 0]\nlst = [-2,\
    \ -4, -6] ==> lst = [-2, -4, -4]", "  lst.each.with_index do |e, i|\n    lst[i\
    \ % 2] += e\n  end\nend", "  even = []\n  odd = []\n  even.concat(lst[0,2])\n\
    \  odd.concat(lst[1,4])\n  even.concat(lst[3,6])\n  odd.concat(lst[5,8])\n  even.concat(lst[7,10])\n\
    \  odd.concat(lst[9,12])\n  even.concat(lst[13,16])\n  odd.concat(lst[17,20])\n\
    \  return [even, odd]\nend", "  even = []\n  odd = []", "  \n  # your code here\n\
    \  lst=[]\n  for i in lst\n    lst[i]+=i/2\n  lst.each{|x|puts x if x%2==0}\n\
    end\n</code>\nand for those who really want to understand this solution:\n<code>",
  "    odd_elems = lst.select { |x| x % 2 == 1 }\n    even_elems = lst.select { |x|\
    \ x % 2 == 0 }\n    return odd_elems + even_elems\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby |>\n<| c |>\nThanks, this makes sense. Is there a better way of doing\
    \ this in terms of computational complexity? I'm just starting learning Ruby and\
    \ trying to get my head around all the different methods and how they work.\n\
    <|/ c |>\n<| c |>\nThe first part is O(n), where n is the size of the list; the\
    \ second is O(n), where n is the size of the list. Since you're mutating the array,\
    \ I'm going to assume you don't care about that. My guess is that Ruby will use\
    \ a lot of copying, so it's not surprising that it would take longer on large\
    \ lists. You might want to benchmark different implementations to see what's faster;\
    \ it would be interesting to see what implementation is fastest on your system,\
    \ but you might not need to care about that for this problem.\n<|/ c |>\n<| c\
    \ |>\nI ran the test using Array#map and Array#each and found that the former\
    \ was 2x faster on my system. The second was 3x faster.\n<|/ c |>\n<| c |>\nThanks\
    \ Tin Man, I'm starting to understand, I've run this on 1000 elements and it's\
    \ coming out at around 20x faster.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>",
  "    even=[]\n    odd=[]\n    lenList=len(lst)\n    if lenList < 2:\n        return\
    \ even\n    elif lenList > 2:\n        for i in range(1,lenList-1):\n        \
    \    if i%2==0:\n                even.append(lst[i])\n            else:\n    \
    \            odd.append(lst[i])\n        return add(even)+add(odd)\n    elif lenList\
    \ == 2:\n        if lst[0]%2==0 and lst[1]%2==0:\n            return lst[0]+lst[1]\n\
    \        elif lst[0]%2!=0 and lst[1]%2!=0:\n            return lst[0]+lst[1]\n\
    \        elif lst[0]%2==0 and lst[1]%2!=0:\n            return lst[0]\n      \
    \  elif lst[0]%2!=0 and lst[1]%2==0:\n            return lst[1]\n    return even",
  " \n  # write your code in Ruby\n  \nend", "  even = []\n  odd = []\n  for n in\
    \ lst\n    even << n if n % 2 == 0\n    odd << n if n % 2 != 0\n  end\n  even\
    \ + odd\nend", "  # +++your code here+++\n  raise \"not implemented\"\nend", " \
    \ sum = 0\n  for i in 0..(lst.length-1)\n    sum += lst[i]*lst[i+1]\n  end\n \
    \ sum\nend\nadd(ARGV)", "  # Write your code here.\nend\n</cell>\n<code language=julia-1.5>\n\
    using Test", "  even = []\n  odd = []\n  for i in lst\n    if i % 2 == 0 then\n\
    \      even.push(i)\n    else\n      odd.push(i)\n    end\n  end\nend", "  i =\
    \ 0\n  even = lst.select {|x| x % 2 == 0}\n  odd = lst.select {|x| x % 2 != 0}\n\
    \  even.each do |e|\n    lst[i] = e\n    i += 1\n  end\n  odd.each do |e|\n  \
    \  lst[i] = e\n    i += 1\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks\
    \ for your answer, but this was just a poor example. I am looking for a more general\
    \ answer to this problem that I could use for any nth element in a list, not just\
    \ evens.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays,algorithm |>\nHow about this?\n\
    <code>", "  # base case\n  return [] unless lst", "  even = lst[2..-1].select\
    \ {|x| x % 2 == 0}\n  even.each do |x|\n    lst << x\n  end\n  lst\nend", "  lst.inject(0){\
    \ |sum, el| sum + el } + lst.inject(0){ |sum, el| sum + el } #+ lst.inject(0){\
    \ |sum, el| sum + el } #=> 4\nend", "  # your code\nend", "  res=[]\n  i=0\n \
    \ while  i < lst.size\n    if lst[i] % 2 == 1\n      res << lst[i]\n      i +=\
    \ 1\n    end\n    i += 1\n  end\n  res\nend", "  result = lst\n  (0...lst.size).each\
    \ do |i|\n    if i % 2 == 0\n      result << lst[i]\n    end\n  end\n  result\n\
    end", "  even = []\n  odd = [1, 3, 5, 7, 9]\n  lst.each do |i|\n    i.even? ?\
    \ even << i : odd << i\n  end\nend\n</code>\nWe can also write it as a more compact\
    \ code using map and zip:\n<code>", "  even = []\n  odd = []\n  even.each do |value|\n\
    \    odd << lst[value] if lst.include?(value)\n  end\n  even + odd\nend", "  evens\
    \ = []\n  odd = []", " even_odd=[]\n even=0\n odd=1\n i=0\n while i<lst.length\n\
    \  even_odd << lst[i]\n  i=i+1\n end\n i=lst.length\n while i>0\n  if lst[i]%2==0\n\
    \   even=even+lst[i]\n  else\n   odd=odd+lst[i]\n  end\n  i=i-1\n end\n lst.length=0\n\
    \ i=0\n while i<even_odd.length\n  lst<<even_odd[i]\n  i=i+1\n end\n i=even_odd.length\n\
    \ while i>0\n  lst<<even\n  i=i-1\n end\nend\n</pre>\n<pre>", "  # your code here\n\
    end", "    lst.map!{|x| x+1}\n    lst\nend\n ", "  return nil if lst.nil?\n  lst.each\
    \ do |i|\n    if (i%2==1)\n      i+= 2\n      lst[i]\n    end\n  end\nend", " \
    \ even = 0\n  odd = 1\n  result = []\n  lst.each do |e|\n    if e % 2 == 0\n \
    \     even += e\n    else\n      odd += e\n    end\n  end\n  result += [even,\
    \ odd]\n  return result\nend", "    i=0\n    even=0\n    odd=0\n    lenght=length(lst)\n\
    \    while i < lenght\n        if lst[i]%2==0 then \n            even += lst[i]\n\
    \        end\n        if lst[i]%2!=0 then \n            odd += lst[i]\n      \
    \  end\n        i+=1\n    end\n    even+odd\nend\n</cell>\n<code language=julia-0.5>\n\
    add(1:10)\n</cell>\n<code language=julia-0.5>\nadd ([1,2,3,4,5,6,7,8,9,10])\n\
    </cell>\n<code language=julia-0.5>\nadd ([1,2,3,4,5,6,7,8,9,10])\n</cell>\n<code\
    \ language=julia-0.5>\nadd ([1,2,3,4,5,6,7,8,9,10])\n</cell>\n<text>\nExercise:\n\
    Given an array of real numbers ar. return a new array of double the length of\
    \ the array ar, each element of which is ar[i]/2", "    lst.reject!{|e| e.odd?}\n\
    \    lst.reject!{|e| e.even?}\nend", "  evens = []\n  odd = []\n  for el in lst\n\
    \    if el mod 2 != 0\n      odd << el\n    else\n      evens << el\n    end\n\
    \  end\n  evens << odd\n  evens.flatten!\n  return evens\nend\nadd([1,3,5,7,9])\n\
    </code>\n<|/ a |>\n<| c |>\nThis only works because the lists are the same size.\
    \ OP's example is a bit of a stretch to begin with. I guess you could do some\
    \ kind of pairwise search to determine if the elements are even and odd though,\
    \ although that would be O(n^2) and would require a full linear scan which would\
    \ be worse than O(n).\n<|/ c |>\n<| c |>\nYou are correct, my example was a bit\
    \ too simple. I edited my answer with a more comprehensive answer.\n<|/ c |>\n\
    <| c |>\n: OP wants to find elements at odd indexes in each sub-list. Do you know\
    \ a way to find elements at odd index in each sub-list?\n<|/ c |>\n<| c |>\nYes,\
    \ but I think my answer will still be O(n^2) where n is the number of sub-lists.\n\
    <|/ c |>\n<| c |>\nYes, I think this is still O(n^2).\n<|/ c |>\n<| a tags=ruby,algorithm,list,recursion\
    \ |>\nThis would be easiest if you were to just iterate through the list. I'd\
    \ use a hash to keep track of whether each element was odd or even, but you can\
    \ just use a boolean for that.\n<code>", "    i=0\n    evens=[]\n    while i <\
    \ lst.count\n        if lst[i]%2 ==0 \n            evens << lst[i]\n        end\n\
    \        i+=1\n    end\n    return evens\nend", "    even = lst.select { |x| x\
    \ % 2 == 0 }\n    odd = lst.select { |x| x % 2 == 1 }\n    even.zip(odd).inject\
    \ { |a, b| a + b }\nend\n</code>\n<code>", "  i = 0\n  while i < lst.size - 1\
    \ do\n    if lst[i].odd? and lst[i + 1].even?\n      lst[i + 1] += lst[i]\n  \
    \    i += 1\n    end\n    i += 1\n  end\n  lst\nend", "    even_sum = 0\n    odd_sum\
    \ = 0\n    even_count = 0\n    odd_count = 0\n    even_odd = 0\n    even = 0\n\
    \    odd = 1\n    even_list = []\n    odd_list = []\n    for index in range(0,\
    \ len(lst)):\n        if index % 2 == 0 and lst[index] % 2 != 0:\n           \
    \ even_list.append(lst[index])\n            even = even + 1\n        elif index\
    \ % 2 != 0 and lst[index] % 2 == 0:\n            odd_list.append(lst[index])\n\
    \            odd = odd + 2\n        else:\n            even_sum = even_sum + lst[index]\n\
    \            even_count = even_count + 1\n            odd_sum = odd_sum + lst[index]\n\
    \            odd_count = odd_count + 1\n    if even == 0 and odd == 0:\n     \
    \   even_odd = even_sum\n    elif even != 0:\n        even_odd = even_sum / even\n\
    \    else:\n        even_odd = odd_sum / odd\n    return even_list, odd_list,\
    \ even_odd, even, odd", "    even = []\n    for num in lst\n      if num % 2 ==\
    \ 0\n        even << num\n      end\n    end\n    odd  = []\n    for num in lst\n\
    \      if num % 2 != 0\n        odd << num\n      end\n    end\n    even.concat(odd)\n\
    \  end", "  even = []\n  odd = []", "    even = []\n    odd = []", "  return lst.inject([]){|a,v|\
    \ a << v unless v.odd? }\nend\nadd([1,2,3,4]) # => [2,4,6]", "  result = 0\n \
    \ for i in 0...(lst.size - 1)\n    if i % 2 == 0 then\n      result += lst[i]\n\
    \    end\n  end\n  return result\nend", "  lst.each_with_index {|x, i| lst.slice!(i)\
    \ if i.odd? && (x % 2).zero? && (x != 0)}\n  lst\nend", "  even = []\n  odd =\
    \ []\n  for n in lst\n    if n.even?\n      even.push(n)\n    else\n      odd.push(n)\n\
    \  even.concat(odd)\nend", "  lst.inject(0){ |sum, element| sum + element }\n\
    end", "  lst.each_with_index { |n, i| lst[i] = n + 2 if i % 2 == 1 }\nend\nadd(lst)",
  "    lst = lst.to_a\n    result = []\n    lst.each_with_index do |el,i|\n      \
    \  if i.odd?\n            result << el\n        end\n    end\n    result\nend",
  "  lst.each_with_index do |i, index|\n    index % 2 == 0 ? (lst[index], lst[index\
    \ + 1]) : nil\n  end\nend\nprint(add(lst))", "  i = 0\n  even = nil\n  even =\
    \ lst[i]\n  while i < lst.length\n    if lst[i] % 2 == 0\n      lst[i] = nil\n\
    \      even = lst[i]\n    else\n      lst[i] = even\n    end\n    i += 1\n  end\n\
    \  return lst\nend\n</cell>\n<code language=julia-1.0>", "  even = []\n  odd =\
    \ []\n  even = lst.each_with_index { |e, i| if i % 2 == 0 then even.push e else\
    \ odd << e end }\n  even.concat(odd)\n  even.uniq\nend\nprint add([]) #=> []\n\
    print add([1]) #=> [1]\nprint add([1,3]) #=> [1, 3]\nprint add([1,2,4]) #=> [1,\
    \ 3, 5]\nprint add([1,2,3,4]) #=> [1, 3, 5]\nprint add([1,2,3,5,6]) #=> [1, 3,\
    \ 5]\nprint add([1,2,3,4,5,6]) #=> [1, 3, 5]\nprint add([1,2,3,4,5,7,8]) #=> [1,\
    \ 3, 5]", "  even = [lst[index] for index in lst if index % 2 == 0]\n  odd = [lst[index]\
    \ for index in lst if index % 2 == 1]\nend", "    even = []\n    odd = []", " \
    \   lst.each_with_index do |e, i|\n        if i.odd?\n            lst[i] += 1\n\
    \        end\n    end\nend", "  # write your code\nend\n</cell>\n<cell>\nadd(lst)\n\
    </cell>\n<cell>", "  # Your code here\n  sum = 0\n  for i in 0...lst.size\n  \
    \  if i % 2 == 0\n      sum += lst[i]\n  end\n  return sum\nend\n</cell>\n<code\
    \ language=julia-1.5>\n@code_warntype add([])\n</cell>\n<code language=julia-1.5>\n\
    @code_warntype add([1])\n</cell>\n<code language=julia-1.5>\n@code_warntype add(collect(1:10))\n\
    </cell>\n<code language=julia-1.5>\n@code_warntype add(map(x->x+2, 1:10))\n</cell>\n\
    <text>\nYour Turn\nWrite a function that returns true if a number is palindrome\n\
    Write a function that checks if an input is a palindrome\nWrite a function that\
    \ checks if two strings are palindromes\nWrite a function that checks if two vectors\
    \ are palindromes", "  # your code here\nend", "  even_lst = []\n  for i in lst\n\
    \    if i % 2 == 0\n      even_lst << i\n    end\n  end\n  return even_lst\nend\n\
    add(lst)", "  if lst.length % 2 == 1 then return lst\n  evens = lst[0..length/2]\n\
    \  odds = lst[1..lst.length/2]\n  evens.zip(odds).inject(:+)\nend", "  return\
    \ [] if lst.empty? || lst.size < 2 \n  even_elements = []\n  lst.each_with_index\
    \ do |value, index| \n    if index % 2 == 0\n      even_elements << value\n  \
    \  end\n  end\n  even_elements.flatten!\n  even_elements.uniq!\n  return even_elements\n\
    end", "    return lst + odd_even(lst)\nend", "  return lst.zip(lst[1..-1]).map\
    \ { |e| e[0] + (e[1] % 2 ? 1 : 0) }\nend", "  result = []\n  for i in 0...lst.size\
    \ -1 do\n    if i%2 == 1 then\n      result << lst[i]\n    end\n  end\n  return\
    \ result\nend", "end\n</cell>\n<code language=julia-1.5>", "  return lst.each.with_index.each_with_index\
    \ do |e,i|\n    if i%2 == 0 then e\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThe code is working and I am very happy to see it working but I\
    \ have one question: how is `each_with_index` being used here? Is it a method\
    \ of the Array class? I don't see it being used anywhere in the code.\n<|/ c |>\n\
    <| c |>\n`each_with_index` is being used here because we need the index to know\
    \ whether an element is an odd or an even. `Array#each` does this job for us.\n\
    <|/ c |>\n<| c |>\nThis was very helpful but now I am confused: what is `each`\
    \ in this code? I know that `each` is the method of Enumerable, so I used it but\
    \ I don't see `each` being used anywhere in there. I can't understand what `each`\
    \ is doing here because it's not being used anywhere else in the code.\n<|/ c\
    \ |>\n<| c |>\nI edited my answer. Hope it makes it clear now. Happy to help you\
    \ :)\n<|/ c |>\n<| c |>\nThanks! That makes perfect sense now that you explained\
    \ it.\n<|/ c |>\n<| a |>\n<code>", "  return lst.inject{|sum,x| sum + x % 2 }\n\
    end", "  evens = lst.select { |x| x % 2 == 0 }\n  evens.reduce(:+) + evens.reduce(:+)\n\
    end", "  odd_index_count = lst.select{|x| x % 2 == 0}.count\n  lst.select{|x|\
    \ x % 2 != 0}.map!{|x| x + odd_index_count}\nend\n</cell>\n<code language=other-env>\n\
    add([3, 8, 2, 6])\n</cell>\n<code language=other-env>", "  even = []\n  odd =\
    \ []\n  lst.each do |x|\n    if x % 2 == 0\n      even << x\n    elsif x % 2 !=\
    \ 0\n      odd << x\n    end\n  end\n  even.zip(odd).each do |x, y|\n    puts\
    \ x\n    puts y\n  end\nend", "  return lst.map { |x| x if x.odd? }\nend\n</code>\n\
    You can even do lazy evaluation with map like this:\n<code>", "  lst.map { |i|\
    \ i + 1 }\nend", "  even = []\n  odd = []\n  even.push lst[0] if lst.length >\
    \ 0\n  even.push lst[1] if lst.length > 1\n  odd.push lst[2] if lst.length > 2\n\
    \  even.push lst[3] if lst.length > 3\n  even.push lst[4] if lst.length > 4\n\
    \  odd.push lst[5] if lst.length > 5\n  even.push lst[6] if lst.length > 6\n \
    \ even.push lst[7] if lst.length > 7\n  odd.push lst[8] if lst.length > 8\n  even.push\
    \ lst[9] if lst.length > 9\n  even.push lst[10] if lst.length > 10\n  odd.push\
    \ lst[11] if lst.length > 11\n  even.push lst[12] if lst.length > 12\n  even.push\
    \ lst[13] if lst.length > 13\n  odd.push lst[14] if lst.length > 14\n  even.push\
    \ lst[15] if lst.length > 15\n  even.push lst[16] if lst.length > 16\n  odd.push\
    \ lst[17] if lst.length > 17\n  even.push lst[18] if lst.length > 18\n  even.push\
    \ lst[19] if lst.length > 19\n  odd.push lst[20] if lst.length > 20\n  even.push\
    \ lst[21] if lst.length > 21\n  even.push lst[22] if lst.length > 22\n  odd.push\
    \ lst[23] if lst.length > 23\n  even.push lst[24] if lst.length > 24\n  even.push\
    \ lst[25] if lst.length > 25\n  odd.push lst[26] if lst.length > 26\n  even.push\
    \ lst[27] if lst.length > 27\n  even.push lst[28] if lst.length > 28\n  odd.push\
    \ lst[29] if lst.length > 29\n  even.push lst[30] if lst.length > 30\n  even.push\
    \ lst[31] if lst.length > 31\n  even.push lst[32] if lst.length > 32\n  odd.push\
    \ lst[33] if lst.length > 33\n  even.push lst[34] if lst.length > 34\n  even.push\
    \ lst[35] if lst.length > 35\n  odd.push lst[36] if lst.length > 36\n  even.push\
    \ lst[37] if lst.length > 37\n  even.push lst[38] if lst.length > 38\n  odd.push\
    \ lst[39] if l", "  even_counter = 0\n  odd_counter = 0\n  result = 0\n  for i\
    \ in 0...(lst.size - 1)\n    even_counter += 1\n    if lst[i] % 2 == 0\n     \
    \ even_counter += 1\n    else\n      even_counter = 0\n    end\n    if lst[i]\
    \ % 2 != 0\n      odd_counter += 1\n    else\n      odd_counter = 0\n    end\n\
    \    result += lst[i]\n  end\n  return result\nend", "  return [] if lst.empty?\n\
    \  even = []\n  odd = []\n  lst.each_with_index do |e, i|\n    if i % 2 == 0\n\
    \      even << e\n    else\n      odd << e\n    end\n  end\n  (even + odd).join\n\
    end", "  lst.each do |i|\n    i%2 == 0 ? (lst[i] += 0) : nil\n  end\n  return\
    \ lst\nend\nadd([])\nadd([1])\nadd([1])\nadd([1])\nadd([1])\nadd([1])\nadd([2])\n\
    add([2])\nadd([2])\nadd([2])\nadd([2])\nadd([2])\nadd([2])\nadd([2])\nadd([3])\n\
    add([3])\nadd([3])\nadd([3])\nadd([3])\nadd([3])\nadd([3])\nadd([3])\nadd([4])\n\
    add([4])\nadd([4])\nadd([4])\nadd([4])\nadd([4])\nadd([4])\nadd([4])\nadd([5])\n\
    add([5])\nadd([5])\nadd([5])\nadd([5])\nadd([5])\nadd([5])\nadd([5])\nadd([5])\n\
    add([6])\nadd([6])\nadd([6])\nadd([6])\nadd([6])\nadd([6])\nadd([6])\nadd([6])\n\
    add([6])\nadd([6])\nadd([7])\nadd([7])\nadd([7])\nadd([7])\nadd([7])\nadd([7])\n\
    add([7])\nadd([7])\nadd([7])\nadd([7])\nadd([7])\nadd([7])\nadd([7])\nadd([8])\n\
    add([8])\nadd([8])\nadd([8])\nadd([8])\nadd([8])\nadd([8])\nadd([8])\nadd([8])\n\
    add([8])\nadd([8])\nadd([8])\nadd([9])\nadd([9])\nadd([9])\nadd([9])\nadd([9])\n\
    add([9])\nadd([9])\nadd([9])\nadd([9])\nadd([9])\nadd([9])\nadd([10])\nadd([10])\n\
    add([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\n\
    add([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\n\
    add([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\n\
    add([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\nadd([10])\n\
    add([10])\nadd([10])\n", "  # TODO: Your code here\n  return\nend\n</cell>\n<text>\n\
    Question: Using the function above, add the even elements to the list.\nBelow\
    \ are some examples of how your function should work. Assume lst contains one\
    \ or more elements.", "  even = []\n  odd = []", "    even = [i for i, v in enumerate(lst)\
    \ if v mod 2 == 0]\n    odd = [i for i, v in enumerate(lst) if v mod 2 == 1]\n\
    \    lst[:] = [e for e in even if e not in odd]\nend\n</cell>\n<code language=julia-0.5>",
  "  return lst.inject do |sum,el|\n    if el%2 == 1\n      sum + el\n    end\n  end\n\
    end\nadd(l).to_s #=> 9\n</code>\nA good resource for these kind of problems is\
    \ Chris Pine's Programming Ruby book\n<|/ a |>\n<| a tags=ruby,inject |>\nI see\
    \ two solutions to solve the problem using inject in Ruby 1.8.6.\nFirst, a solution\
    \ that doesn't use inject but a loop:\n<code>", "  res = []\n  for i in lst\n\
    \    if i % 2 != 0\n      res << i\n    end\n  end\n  res\nend\nadd(lst) # =>\
    \ [2,4,6]\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays dscore=3\
    \ |>\nI like to play with Array's enumerate method. It also gives you access to\
    \ the array element number itself.\n<code>\narray = [1, 2, 3]\narray.each_index.map\
    \ { |i| array[i] }", "  lst.map!{|i| if i.odd? then i+1 else i end }\n  lst\n\
    end\nputs add(list1).inspect", "  if lst.empty? # empty list can not add anything\
    \ so return nil\n    return nil\n  end\n  return nil if lst.size < 1 # not enough\
    \ even numbers\n  evens = []\n  evens << lst[0] # add the original first even\
    \ number\n  lst.each do |x|\n    if x % 2 == 0\n      evens << x # add the current\
    \ even number\n    end\n  end\n  return evens\nend", "  even = []\n  odd =[]\n\
    \  lst.each_with_index do |num, i|\n    if i.odd?\n      odd << num\n    else\n\
    \      even << num\n    end\n  end\n  even + odd\nend\nprint(add(lst)) # prints\
    \ [1, 2, 3, 6, 7, 8]", "    lst = lst.sort\n    even_odd_indexes = []\n    even\
    \ = even = odd =0\n    i = 0\n    while i < lst.size\n        if odd <= lst.size\
    \ - 1 and even <= lst.size - 1\n        even_odd_indexes << even\n        even_odd_indexes\
    \ << odd\n        even += 2\n        odd += 2\n        i += 1\n        else\n\
    \            even += 2\n            odd += 2\n        even_odd_indexes << even\n\
    \        even_odd_indexes << odd\n        end\n    end\n    return even_odd_indexes\n\
    end", "  even = lst.select { |x| x % 2 == 0 }\n  odd =  lst.select { |x| x % 2\
    \ != 0 }\n  even.zip(odd).map {|e| e[0].to_i + e[1].to_i }.inject { |result, x|\
    \ result + x }\nend", " lst.each_with_index do |value,index|\n  if index.odd?\
    \ && value % 2 == 0\n    lst[index + 2] += 1\n  else\n    lst[index] += 1\n  end\n\
    \ end\nend\nadd(arr)", "  # Write your code here.\nend", "  even = 0\n  odd =\
    \ 0\n  for x in lst\n    if x % 2 == 0\n      even += x\n      else\n      odd\
    \ += x\n  end\n  return even + odd\nend", "  lst.select {|i| i % 2 == 0}.inject(:+)\n\
    end", "    return lst.select { |i| i.odd? }.inject(:+) \nend\n</code>\nThis does\
    \ one iteration; there are more efficient ways to do it.\n<code>", "  count =\
    \ 0\n  for i in 1..lst.length\n    if lst[i] % 2 == 0\n      lst[count] += lst[i]\n\
    \      count += 1\n    end\n  end\n  lst\nend", "  a = []\n  for i in lst\n  \
    \  if i.odd?\n      a << i\n    else\n      a << i + lst.pop\n    end\n  end\n\
    \  a\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for sharing! I like your solution\
    \ but it's not quite there: `add(lst) # => [6, 2, 1]`\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby |>\nI wanted to share my solution to this, I believe this is more\
    \ elegant than a while/for loop and a variable that is incremented, however I\
    \ thought I'd share this in case it is useful to anyone. I also wanted to thank\
    \ you for sharing this solution. I had tried something similar but I had a syntax\
    \ error.\n<code>", '  return add_recu(lst,1)', "  return lst.inject(0){|sum, e|\
    \ sum + e if e.odd? }\nend", "  lst.map!{|x| x + 2 }\nend\nadd(l) =>  [2, 4, 6,\
    \ 8]\n</pre>\n</div>\n</div>\n</div>\n    </div>\n  </div>\n</body>", "  even=0\n\
    \  odd=1\n  even+=lst[even]\n  odd+=lst[odd]\n  lst[even]=lst[odd]\n  lst[odd]=0\n\
    \  return lst\nend", "  # your solution here\nend", "  lst.each_with_index { |n,i|\
    \ lst[i] = n+2*i if i%2 == 1 }\nend", "  even = 0\n  odd = 0\n  lst.each do |i|\n\
    \    if i.even?\n      even += 1\n    elsif i.odd?\n      odd += 1\n    end\n\
    \  end\n  even + odd\nend", "  even = lst.select { |e| e.odd? }\n  even.product(*even).inject\
    \ { |acc, e| acc + e.first }\nend", "  lst.each_with_index do |x, i|\n    lst[i+1]\
    \ = x if i % 2 == 0\n  end\nend", "  lst.each do |e|\n    if e % 2 == 0\n    \
    \  lst.insert(lst.index(e), e)\n    end\n  end\nend\n</cell>\n<cell>\nlst = [1,2,3,4,5,6,7,8,9]\n\
    add(lst)\nlst.inspect\n</cell>\n<cell>", "  result = []\n  even_index = 0\n  odd_index\
    \ = 1\n  while even_index < lst.size do \n    if lst[even_index] % 2 == 0 then\n\
    \      result += [lst[even_index]]\n      even_index += 1\n    else\n      result\
    \ += [lst[odd_index]]\n      odd_index += 1\n    end\n  end\n  result\nend", " \
    \ even_sum = 0\n  even_count = 0\n  for i in lst.to_a\n    if i % 2 == 0\n   \
    \   even_sum += i\n      even_count += 1\n    end\n  end\n  return even_sum\n\
    end", "  return lst[1..-1].inject(0) { |acc, x| acc += x if x % 2 == 0 }\nend\n\
    assert(add(List.new(0) + List.new(10) + List.new(20) + List.new(30) + List.new(40)\
    \ + List.new(50)) == 70, \"Add evens\")\nassert(add(List.new(0) + List.new(10)\
    \ + List.new(20) + List.new(30) + List.new(40)) == 70, \"Add evens\")\nassert(add(List.new(0)\
    \ + List.new(10) + List.new(20) + List.new(30)) == 60, \"Add evens\")\nassert(add(List.new(0)\
    \ + List.new(10) + List.new(20)) == 50, \"Add evens\")\nassert(add(List.new(0)\
    \ + List.new(10)) == 50, \"Add evens\")\nassert(add(List.new(0)) == 0, \"Add evens\"\
    )\nassert(add([]) == 0, \"Add evens\")\nassert(add([1]) == 1, \"Add evens\")\n\
    assert(add([1]).empty?, \"Add evens\")", "  even = []\n  odd = []\n  \n  for i\
    \ in lst\n    if i.even?\n      even << i\n    else\n      odd << i\n    end\n\
    \  end\n  \n  even.each_with_index do |e, i|\n    lst[i] += e\n  end\n  \n  odd.each_with_index\
    \ do |e, i|\n    lst[i] += e\n  end\n  \n  return lst\nend", "  lst.each do |i|\n\
    \    lst[i] = lst[i.to_i] if (lst[i] % 2 == 0)\n  end\nend\nprint add(lst)", " \
    \ even = []\n  odd = []", "  return lst.inject { |sum, num| sum + num if num %\
    \ 2 != 0 } if lst\nend", "    even = []\n    odd = []\n    for num in lst\n  \
    \      if num % 2 == 0\n            even.push(num)\n        else\n           \
    \ odd.push(num)\n    end\n    return even.concat(odd)\nend", "    i=0\n    while\
    \ i < lst.len\n        if lst[i] % 2 == 0\n            lst[i] += lst[i+1]\n  \
    \          i += 2\n        end\n        i += 1\n    return lst\nend", "  # +++your\
    \ code here+++\nend", "    evenIndexes\n    oddIndexes\nend\n</cell>\n<cell>\n\
    add(lst)\n</cell>\n<text>\nGiven a non-empty string s. We need to return a string\
    \ where for every character in s, there is an even\nnumber character next to that\
    \ character. The string should also end with a '\\0' character.", "    lst.reject!\
    \ {|x| x % 2 == 0}\n    puts lst.inject(0, :+)\nend\nadd(lst)\n</code>\nThis prints\
    \ \n<code>\n[4, 6, 8, 10, 12, 14, 16, 18, 20]\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nHmmm I didn't know about inject so I learned something new today! But\
    \ how does it work?\n<|/ c |>\n<| c |>\nit passes the current value to the next\
    \ function in the chain - `inject` just adds the current value to the accumulator\
    \ and returns the accumulator.\n<|/ c |>\n<| c |>\nOh okay I understand now. I\
    \ think I understand what the function does but I'm not sure how I feel about\
    \ it now that I think about it.\n<|/ c |>\n<| c |>\nI would prefer the `reduce`\
    \ method over `inject` for this task\n<|/ c |>\n<| a dscore=0 |>\nHere is another\
    \ way to do it using recursion.\n<code>", "  even = even.empty? ? lst.dup : even\n\
    \  lst.each_with_index do |e, i|\n    if i % 2 == 1\n      even.push(e)\n    end\n\
    \  end\n  even.map(&:to_i)\nend", "  return lst.inject(0) do |even, index|\n \
    \   if index % 2 == 0\n      even + lst[index / 2]\n    end\n  end\nend", "  evens\
    \ = []\n  odd = []", "  lst.each do |num|\n    lst[num % 2].push num\n  end\n\
    \  lst.flatten!\nend", "  # Your code here\nend\n</cell>\n<cell>\nadd(lst)\n</cell>\n\
    <text>\nQuestion 7", "  res = []\n  i = 0\n  while i < lst.count\n    if i % 2\
    \ != 0\n      res += lst[i]\n    end\n    i += 1\n  end\n  return res\nend", " \
    \ if lst.size == 0\n    []\n  else\n    lst + [lst[1..-1].map {|num| num if num\
    \ % 2 == 0}.reduce(:+)]\nend\nprint(add([])) # => []\nprint(add([1])) # => [1]\n\
    print(add([1,2])) # => [1, 2]\nprint(add([1,2,3])) # => [1, 3, 5]\nprint(add([1,2,3,4]))\
    \ # => [1, 3, 5]\nprint(add([1,2,3,5,6])) # => [1, 3, 5, 7, 9]\nprint(add([7,4,2,3,5,6,9]))\
    \ # => [7, 9, 13, 17, 21, 25, 31]\nprint(add([7,4,2,3,5,6,9,10,1])) # => [7, 9,\
    \ 13, 17, 21, 25, 31, 35, 43, 51, 61, 71, 81, 91]\nprint(add([7,4,2,3,5,6,9,10,1,2]))",
  "  even_index = 0\n  odd_index = 1\n  evens = []\n  odds = []\n  loop do\n   element\
    \ = lst[even_index]\n   evens << element\n   if odd_index < lst.length\n     element\
    \ = lst[odd_index]\n     odds << element\n   else\n     break even_index\n   end\n\
    \   even_index += 2\n   odd_index += 2\n  end\n  evens + odds\nend", "  lst.each_with_index\
    \ { |n, i| lst[i..-1].each_with_index { |a, j| lst.insert i+j, a+n+a if j % 2\
    \ == 1 } }\nend\nadd(lst)\n  #=> [12, 3, 7, 4, 12, 10, 13, 4, 11, 18, 8, 2, 15,\
    \ 5, 17, 6, 19, 9, 3, 18, 15, 10, 21, 17, 6, 22, 13, 7, 23, 14, 8, 1, 20, 14,\
    \ 6, 1, 21, 17, 7, 1, 22, 18, 8, 2, 23, 19, 9, 1, 24, 5, 17, 5, 25, 6, 19, 6,\
    \ 10, 23, 7, 24, 8, 1, 22, 9, 2, 23, 8, 1, 3, 10, 6, 3, 12, 9, 4, 8, 1, 5, 11,\
    \ 7, 7, 7, 8, 8, 9, 10, 11, 12, 3, 7, 4, 12, 10, 13, 4, 11, 18, 8, 2, 15, 5, 17,\
    \ 6, 19, 9, 3, 18, 15, 10, 21, 17, 6, 22, 13, 7, 23, 14, 8, 1, 20, 14, 6, 1, 21,\
    \ 17, 7, 1, 22, 18, 8, 2, 23, 19, 9, 1, 24, 5, 17, 5, 25, 6, 19, 6, 10, 23, 7,\
    \ 24, 8, 1, 22, 9, 2, 23, 8, 1, 3, 10, 6, 3, 12, 9, 4, 8, 1, 5, 11, 7, 7, 7, 8,\
    \ 8, 9, 10, 11, 12, 3, 7, 4, 12, 10, 13, 4, 11, 18, 8, 2, 15, 5, 17, 6, 19, 9,\
    \ 3, 18, 15, 10, 21, 17, 6, 22, 13, 7, 23, 14, 8, 1, 20, 14, 6, 1, 21, 17, 7,\
    \ 1, 22, 18, 8, 2, 23, 19, 9, 1, 24, 5, 17, 5, 25, 6, 19, 6, 10, 23, 7, 24, 8,\
    \ 1, 22, 9, 2, 23, 8, 1, 3, 10, 6, 3, 12, 9, 4, 8, 1, 5, 11, 7, 7, 7, 8, 8, 9,\
    \ 10, 11, 12, 3, 7, 4, 12, 10, 13, 4, 11, 18, 8, 2, 15, 5, 17, 6, 19, 9, 3, 18,\
    \ 15, 10, 21, 17, 6, 22, 13, 7, 23, 14, 8, 1, 20, 14, 6, 1, 21, 17, 7, 1, 22,\
    \ 18, 8, 2, 23, 19, 9, 1, 24, 5, 17, 5, 25, 6, 19, 6, 10, 23, 7, 24, 8, 1, 22,\
    \ 9, 2, 23, 8, 1, 3, 10, 6, 3, 12, 9, 4, 8, 1, 5, 11, 7, 7, 7, 8, 8, 9, 10, 11,\
    \ 12, 3, 7, 4, 12, 10, 13, 4, 11, 18, 8, 2, 15, 5, 17, 6, 19, 9, 3, 18, 15, 10,\
    \ 21, 17, 6, 22, 13, 7, 23, 14, 8, 1, 20, 14, 6, 1, 21, 17, 7, 1, 22, 18, 8, 2,\
    \ 23, 19, 9, 1, 24, 5, 17, 5, 25, 6, 19, 6, 10, 23, 7, 24, 8, 1, 22, 9, 2, 23,\
    \ 8, 1, 3, 10, 6, 3, 12, 9, 4, 8, 1, 5, 11, 7, 7, 7, 8, 8, 9, 10, 11, 12, 3, 7,\
    \ 4, 12, 10, 13, 4, 11, 18, 8, 2, 15, 5, 17, 6, 19, 9, 3, 18, 15, 10, 21, 17,\
    \ 6, 22, 13, 7, 23, 14, 8, ", "  evens = lst.select { |e| e % 2 == 0 }\n  return\
    \ evens.reduce(:+)\nend", "  return [] if lst.empty?\n  (2,*even) = (*lst,2).to_a\n\
    \  even.compact!\n  even.uniq!\n  even.map!{|i| i%2==0 ? i : nil}.compact!\n \
    \ (2,*even).flatten!\nend\n</pre>", "  puts \"Your list is #{lst}\"\n  lst.each\
    \ do |element|\n    if element % 2 == 0\n      lst.push(element)\n    end\n  end\n\
    end", end, "  if lst.empty?\n  else\n    even = lst.map {|i| i if i.even?}\n \
    \   odd = lst.map {|i| i if i.odd?}\n    even + odd\n  end\nend\nadd([]) #=> []\n\
    add([1]) #=> [1]\nadd([1,2]) #=> [1,2]\nadd([1,2,3]) #=> [2,4,6]\nadd([1,2,3,4])\
    \ #=> [3,6,10,12]\nadd([1,2,3,4,5]) #=> [3,7,12,15,18]\n</cell>\n<text>\nThe solution\n\
    You already know how to add two lists together:", "    even = []\n    odd = []\n\
    \    i = 0\n    while i < lst.size\n        if i % 2 == 0\n            even.push(lst[i])\n\
    \        else \n            odd.push(lst[i])\n        i += 1\n    return even.concat(odd)\n\
    end \n</code>\nAnd here is an example where I print out a list of even numbers\
    \ in order:\n<code>\nadd(2..10).each do |even|\n  print even\nend\n</code>\nAnd\
    \ here is an example of where I print out a list in reverse order:\n<code>\nadd(2..10).reverse_each.each\
    \ do |even|\n  print even\nend\n</code>\nAnd here is where I print out a list\
    \ that has even elements at the end and odd elements at the start:\n<code>\nadd(2..10).reverse_each.each_cons(2).each\
    \ do |even|\n  print even\nend\n</code>\n<|/ a |>\n<| c |>\nI actually like this.\
    \ But you forgot to mention that the array should be passed as a parameter, i.e.\
    \ `add(lst.to_a)`\n<|/ c |>\n<| a tags=ruby,arrays,iteration |>\nYou can use the\
    \ Array index and slice method in this case:\n<code>\narr = [1, 2, 3, 1, 2, 3,\
    \ 4]", "  # +++your code here+++\n  i = 0\n  while i < lst.size\n    if i % 2\
    \ == 1\n      lst[i] += lst[i + 1]\n    i += 1\n  lst\nend", "  result = 0\n \
    \ lst.each do |num|\n    if num.odd?\n      result += num\n    end\n  end\n  result\n\
    end\n</cell>\n<cell>\nadd(lst)\n</cell>\n<cell>", "    return lst.map { |x| x\
    \ + if x % 2 != 0; 0; else x }.flatten.compact\nend\nadd([\"a\", \"b\", \"c\"\
    , \"d\", \"e\"]) => [\"a\",\"b\",\"c\"]\nadd([1,3,5,7]) => [2,4,6]\nadd([1]) =>\
    \ []", "  even = []\n  odd = []\n  for i in lst.each_with_index do |number, index|\n\
    \    if index % 2 == 0\n      even << number\n    else\n      odd << number\n\
    \    end\n  end\n  return even + odd\nend", " \nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
