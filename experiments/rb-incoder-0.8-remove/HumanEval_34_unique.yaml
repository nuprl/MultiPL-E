name: HumanEval_34_unique
language: rb
prompt: "# Return sorted unique elements in a list\ndef unique(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n\
  \    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"
completions: ["  if l.uniq.size == l.size\n    l.uniq\n  else\n    l.uniq\n  end\n\
    end", "  l.reduce do |a,b|\n    if a != b\n      a.last <=> b.last\n    else\n\
    \      0\n    end\n  end\nend", "    seen = set()\n    seen_add = seen.add\n \
    \   return [x for x in l if not (x in seen or seen_add(x))]", "  l.uniq.sort\n\
    end", "  # Return sorted unique elements in a list\n  return l.uniq\nend\n</code>\n\
    You can find a more detailed answer here: Removing duplicates from an array in\
    \ Ruby\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n<code>\na = [1,2,2,3,5,6,8]\n\
    </code>\nIf you want the unique elements you can use uniq\n<code>\na.uniq", " \
    \   l.sort\n    l.reverse\n    unique = nil\n    until unique.nil?\n        unique\
    \ = l.shift\n    end\n    unique\nend\n</code>\n<|/ a |>\n<| c |>\n`if unique.nil?`\
    \ is an ugly way of expressing `unless unique`\n<|/ c |>\n<| c |>\nYes, but if\
    \ one wants to know why it works like that (as opposed to just `unless`)... so\
    \ I decided to post it anyway.\n<|/ c |>\n<| c |>\nI don't think this answer is\
    \ correct. On line 7, you are calling `unique` but then you are using `uniques`...\
    \ so line 9 should be: `return uniques.uniq`. Or even better, `return uniques`.\
    \ And also on line 10 you are using `uniq!`, so `uniq` should be on line 11. Also\
    \ on line 12 you are using `uniq!`, so `uniq` should be on line 13.\n<|/ c |>\n\
    <| a |>\n<code>", "  l.sort\n  l.reverse.uniq\nend", "  uniq = Set.new\n  l.each\
    \ { |i| uniq.add(i) }\n  uniq.to_a\nend\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,sql,ruby-on-rails-3,sql\
    \ |>\nThis may be overkill, but if you really want to avoid using ActiveRecord's\
    \ find_by_sql you can use a raw SQL call and manipulate the result in your controller.\
    \ Here's an example that assumes your database is PostgreSQL:\n<code>", "  l.sort\
    \ # sort list before returning\n  l.reject do |value| \n    l.include? value\n\
    \  end \nend", "  l.uniq\nend", "  l.sort\n  l.reverse!\n  l\nend\n</pre>\n<h2>See</h2>\n\
    <ul>\n  <li> <a href=\"https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure\"\
    >OWASP Top 10 2017 Category A3</a> - Sensitive Data Exposure\n  </li>\n  <li>\
    \ <a href=\"http://cwe.mitre.org/data/definitions/489.html\">MITRE, CWE-489</a>\
    \ - Weak Password Requirements </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/529.html\"\
    >MITRE, CWE-529</a> - Use of a Broken or Risky Cryptographic Algorithm </li>\n\
    \  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/tgAg\">CERT,\
    \ MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>\n\
    \  <li> <a href=\"https://www.sans.org/top25-software-errors/#cat3\">SANS Top\
    \ 25</a> - Porous Defenses </li>\n  <li> Derived from FindSecBugs rule <a href=\"\
    http://h3xstream.github.io/find-sec-bugs/bugs.htm#WEAK_CRYPTO\">WEAK_CRYPTO</a>\
    \ </li>\n</ul>\n\t\t\t\t\t\t</details>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\
    \t\n\t\t\t\t<tr>\n\t\t\t\t\t<td><a\n\t\t\t\t\t\t\thref=\"https://next.sonarqube.com/sonarqube/coding_rules#rule_key=ruby\"\
    >ruby</a>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<details>\n\t\t\t\t\t\t\
    \t<p>Ruby is a dynamic language. This means you can add methods to objects. These\
    \ methods are called \"methods\" in Ruby.</p>\n<p>This rule raises an issue when\
    \ a method is defined without a parameter and is called with one parameter. This\
    \ issue only happens for Ruby 1.9+, since Ruby 1.8 did not have this issue but\
    \ added a warning if you tried to call the method with a parameter. </p>\n<p>This\
    \ rule is based on the <code>squid:S3776</code> rule. </p>\n<h2>Noncompliant Code\
    \ Example</h2>\n<pre>", "  return l.uniq\nend", "  l.uniq.sort\nend", "  l.sort\n\
    \  l.remove\n  l\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,ruby |>\n\
    I came up with a solution that uses sorted hashes where the keys are the letters\
    \ of the alphabet and the values are arrays containing the letters of the words\
    \ in the sorted order of the word's letters. For example, for \"pig\"\n<code>\n\
    sorted_hash = Hash.new{ |h,k| h[k] = [] }\n</code>\nwill be the hash for the word\
    \ \"pig\".\nWe then use a loop to iterate through the sorted word's letters and\
    \ add them to the appropriate array in the hash.\n<code>\nfor letter in sorted_word\n\
    \    sorted_hash[sorted_word.letters[letter]] << letter\nend\n</code>\nWe then\
    \ return the sorted hash:\n<code>\nsorted_hash\n</code>\nHere's the full code:\n\
    <code>", "    seen = {}\n    seen_add = seen.add\n    return [x for x in l if\
    \ x not in seen and not seen_add(x)]", "  l.sort\n  l.reject{ |i| l.index(i) ==\
    \ l.lastIndex }\nend", "  l.sort.uniq.to_a\nend", "  l.uniq\nend", "  # Remove\
    \ nil values\n  l.delete_if {|e| e.nil?}\n  # Return sorted unique values\n  l.sort\n\
    end", "    seen = []\n    seen_add = seen.add\n    return [x for x in l if x not\
    \ in seen and not seen_add(x)]", "  l.sort\n  l.reverse.uniq\nend", "  return\
    \ l.uniq.sort\nend\n</code>\n<|/ a dscore=5 |>\n<| a |>\n<code>\nrequire 'set'",
  "    unique = []\n    \n    for i in l\n        if i not in unique\n           \
    \ unique.push(i)\n    end\n    \n    unique\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This is a great solution, but I believe the op was looking for something slightly\
    \ different.\n<|/ c |>\n<| c |>\nI agree with that. The OP has given us little\
    \ to work with so I'm just trying to answer the question as stated. That said,\
    \ I'm pretty sure the OP does want unique elements, not duplicates. Also, the\
    \ use of a `unique` variable is unnecessary - you could have just `return l.uniq`\
    \ after the `end`\n<|/ c |>\n<| c |>\nYeah, I got my answer from this. Thanks.\n\
    <|/ c |>\n<| a |>\nYou can achieve this by looping through the array and adding\
    \ the elements to a hash table:\n<code>\nh = {}\narray.each { |e| h[e] = 0 }\n\
    </code>\nAfter this, hash table will have the key as the element and value as\
    \ how many times it has occurred. So you can just return the keys (keys of the\
    \ hash table) from this hash table to achieve the desired result.\n<|/ a dscore=0\
    \ tags=ruby,hash,arrays |>\n<| c |>\nIt's a hash, not an array. Also, using a\
    \ hash table for a trivial operation like this is very wasteful.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right. Hash table is overkill for this problem. I'll edit\
    \ the answer.\n<|/ c |>\n<| c |>\nNo it's not. `array.uniq.size` will do the trick\
    \ here.\n<|/ c |>\n<| a |>\nIf your intention is to keep the original order of\
    \ your original array then all you need is this:\n<code>\narray.uniq.size\n</code>\n\
    If you just want the unique elements and to keep them in the same order as they\
    \ were in your original array then the following will do that:\n<code>\narray.reduce(:&).size\n\
    </code>\nIf you only want the unique elements then this will be enough:\n<code>\n\
    array.reduce(&:uniq).size\n</code>\nThe above will give you the count of all unique\
    \ elements in your original array. Here are some examples:\n<code>\nirb(main):002:0>\
    \ arr = [\"one\", \"two\", \"three\", \"two\", \"two\", \"two\", \"two\", \"three\"\
    , \"four\", \"four\"]\n=> [\"one\", \"two\", \"three\", \"four\"]\nirb(main):003:0>\
    \ arr.uniq.size\n=> 2\nirb(main):004:0> arr.re", "  seen = {}\n  l.inject([])\
    \ {|result, x| result.uniq! if seen[x] || !seen[x] }\nend\n</code>\nAnd if you\
    \ want to get all the unique keys of a hash (i.e. the keys sorted by their value):\n\
    <code>", "  return l.to_a.uniq.compact\nend", "  l.sort\n  h = {}\n  loop do\n\
    \    return if h[l.shift]\n    h[l.shift] = true\n  end\nend", "  seen = {}\n\
    \  result = []\n  for x in l\n    if !seen[x]\n      seen[x] = true\n      result\
    \ << x\n    end\n  end\n  result\nend", "  l.uniq\nend", "  l.uniq.sort\nend",
  "  l.sort!\n  l = l.reverse\n  l = [l.pop] until l.empty?\n  l\nend", "  l.uniq!\n\
    \  l\nend", "  l.uniq!\n  l\nend", "    l.sort!\n    unique = []\n    unique.concat(l)\
    \ if l.size > 0\n    unique.uniq! if l.size > 0\n    unique\nend", "    l.sort\n\
    \    l.pop if l.size > 1 # remove any duplicates\nend", "    l.sort!\n    return\
    \ l.reject { |i| l.include? i }\nend", "  l.uniq\nend", "  l.uniq!\nend", "  l.uniq\n\
    end\n</code>\nNow you can use it like\n<code>\nunique([1,2,2,3,4])", "  l.sort\n\
    \  l.uniq\nend\n</code>\nThis could be useful in a situation where you want to\
    \ convert all nil values in a hash to some other value, or all non-truthy values\
    \ in a hash to some other. For example, if you had a hash with some nil values\
    \ but some non-truthy values\n<code>\n{ \"name\" => \"frank\", \"age\" => nil,\
    \ \"occupation\" => \"doctor\" }\n</code>\nYou could do\n<code>\nhash =\n{ \"\
    name\" => \"frank\", \"age\" => nil, \"occupation\" => \"doctor\" }", "  return\
    \ l.uniq\nend\n</code>\n<|/ a tags=ruby,arrays,sorting dscore=2 |>\n<| c |>\n\
    This is interesting, but what about `[1, 1, 2, 2, 3, 3, 3, 3, 3]`? Would that\
    \ return `[1, 2, 3, 3]`?\n<|/ c |>\n<| c |>\n, yes, you are right. Fixed it with\
    \ `uniq` method.\n<|/ c |>\n<| a dscore=1 |>\nThis answer is based off of's answer\
    \ (which works), while avoiding creating an extra variable.\n<code>", "  l.sort\n\
    \  l.reverse.uniq\nend", "  l.sort\n  uniq = []\n  for i in 0 .. l.length\n  \
    \  if l[i] != l[i+1]\n      uniq.push(l[i])\n    end\n  end\n  return uniq\nend",
  "  l.sort\n  l.uniq\nend", "    l.sort\n    uniq = l[1..-1]\n    uniq.compact!\n\
    \    uniq\nend\n</code>\n<|/ a tags=arrays,ruby,sorting,duplicates |>\n<| c |>\n\
    Nice answer! Thank you. One minor mistake though - \"uniq\" should be \"uniq!\"\
    \ in order to avoid modifying the original array.\n<|/ c |>\n<| c |>\nI believe\
    \ `uniq.sort` does the same thing as `uniq!` but is more efficient because it\
    \ doesn't require creating a new array just to call `sort`.\n<|/ c |>\n<| c |>\n\
    `uniq!` modifies the original array.\n<|/ c |>\n<| c |>\nYes, I know. But I thought\
    \ it was worth noting that `uniq!` is preferable in most circumstances over `uniq`.\
    \ `uniq!` modifies the original array as opposed to `uniq` which creates a new\
    \ array.\n<|/ c |>\n<| a dscore=4 tags=arrays,ruby,sorting,duplicates |>\nI prefer\
    \ using inject for this.\n<code>", "    l.uniq!\nend", "  l.sort.uniq\nend\n</code>\n\
    I put this together with the help of the docs and this question on SO\n<|/ a tags=ruby-on-rails,ruby,arrays,unique,ruby-on-rails-3\
    \ |>\n<| c |>\nThis is a great solution. Thank you.\n<|/ c |>\n<| c |>\nI used\
    \ this solution and it works fine for me except when I try to add a new element\
    \ to an array containing existing elements. I got an error \"cannot modify frozen\
    \ array\" and the program ends. Any idea why?\n<|/ c |>\n<| c |>\n: My guess is\
    \ that you were trying to modify the array somewhere else in the application.\
    \ I think it's best to ask this as a separate question so that someone who knows\
    \ Ruby better than I can be sure :)\n<|/ c |>\n<| c |>\nI ran into a similar issue.\
    \ What I found that my array was frozen somewhere else. After I added this line\
    \ of code before the .uniq line it worked just fine.", "  l.sort\n  l.reduce do\
    \ |a,b|\n    (a..b).include? a ? a : b\n  end\nend", "  l.uniq\nend\n</code>\n\
    This also works in Ruby 1.9\n<|/ a |>\n<| c |>\nThanks Robbie. I am not able to\
    \ figure out this \"Use Hash to remove duplicates\" part. Can you please explain\
    \ or post a link ?\n<|/ c |>\n<| c |>\n`Hash` has `[]` method which returns value\
    \ of a key. So if two keys return same value then same key will be added into\
    \ hash again. That's why it returns only the last value.\n<|/ c |>\n<| c |>\n\
    Thanks Robbie :) Now I understand why I got duplicate values in my array even\
    \ after using uniq.\n<|/ c |>\n<| c |>\nThis solution is very inefficient for\
    \ large arrays. This is O(N^2), as each element must be compared against all others.\
    \ A better solution is to use `Hash::new`, which uses the supplied block to compute\
    \ hash values, and then adds the value if the hash doesn't already contain the\
    \ key. Even better would be to replace `Hash` with a `Set`, which has a constant\
    \ lookup time.\n<|/ c |>\n<| c |>\nCan you please post code snippet for that as\
    \ I have been looking for such a snippet for quite a while. Thanks.\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>", "  l.uniq\nend", "    l.uniq!\nend\n</code>\n<|/ a\
    \ tags=ruby dscore=0 |>\n<| a |>\nHere is an answer that uses inject to count\
    \ elements and then uniq at the end\n<code>\narray = [1,3,2,2,5,1]\np array.inject(Hash.new(0))\
    \ { |h, i| h[i] += 1 }.uniq => [1,3,5]\n</code>\n<|/ a dscore=0 tags=ruby |>\n\
    <| a dscore=0 |>\n<code>", "    l.uniq\nend\n</cell>\n<cell>", "  l.sort\n  l\n\
    end", "  u = {}\n  for i in l do u[i] = nil end\n  l.each do |i|\n    u[i.to_s]\
    \ = nil\n  end\n  u.keys\nend", "    l.sort\n    l.uniq\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=arrays,ruby |>\nSince Ruby 2.5, there is a handy way to do this\
    \ with Enumerable:\n<code>\n[1,2,3,2,3].uniq", "  l.sort!\n  l.reject!{ |a| a\
    \ == l.last }\n  l\nend\n</code>\nand you just need to do:\n<code>\nunique(input.split)\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays dscore=0 |>\n<code>", "  seen\
    \ = Set.new\n  l.uniq.map { |e| seen << e } if Enumerable\n  seen\nend\n</code>\n\
    I added a case where Enumerable is available since it can be useful.\n<|/ a tags=arrays,ruby\
    \ |>\n<| c |>\nI believe it can be done using [inject(:&)](https://ruby-doc.org/core-2.4.1/Enumerable.html#method-i-inject).\n\
    <|/ c |>\n<| c |>\n`inject` returns `nil` when the block throws an exception.\
    \ `uniq` would not do this.\n<|/ c |>\n<| c |>\nThat's why I added `Enumerable`\
    \ check\n<|/ c |>\n<| c |>\nYes, I understand that, but if you were to check it\
    \ first and avoid `nil`s then you'd get `uniq` behavior without `Enumerable`.\
    \ But if your use case requires the check, then it makes a bit more sense to use\
    \ `inject`\n<|/ c |>\n<| c |>\nI thought about it, but I decided that it was more\
    \ readable to not use `inject` since it requires two steps and `uniq` only one.\
    \ Also, I don't see any advantage in using `inject` over `uniq` which also require\
    \ `uniq`\n<|/ c |>\n<| a tags=arrays,ruby |>\nHere is a simple method that doesn't\
    \ require Enumerable (it uses Set or Hash internally):\n<code>", "  # Remove duplicates\n\
    \  u = {}\n  l.each { |x| u[x] = true }\n  l = u.keys\nend", "  result = []\n\
    \  l.each do |value|\n    result.push value if !result.include?(value)\n  end\n\
    \  result.sort!\n  return result\nend", "  r = l.uniq.sort\n  r.first\nend", " \
    \   l.uniq { |x| x }\nend", "  l.sort\n  l.reverse!\n  l = l + l[0...-1]\n  l.uniq\n\
    end\n</code>\nThe above is from my blog where I talk about various array functions.\n\
    <|/ a |>\n<| c |>\nI wouldn't recommend using `!` as an operator, since it does\
    \ two things: 1) it changes the current object in a way that would cause unexpected\
    \ behaviour elsewhere and 2) it mutates a value. So it isn't appropriate for Ruby\
    \ code outside of just one place (e.g. a method called in a loop, where you know\
    \ it won't mutate the object).\n<|/ c |>\n<| a dscore=3 |>\nIn case anyone is\
    \ looking for an efficient way to sort an Array by a given key, you can use Enumerable#sort_by\
    \ (which returns a new array):\n<code>\nmy_array.sort_by(&:key)\n</code>\nAnd\
    \ of course you can sort in descending order too using the method Enumerable#sort_by!.\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\nIn case anyone\
    \ else finds this, I was trying to find the quickest way to convert an array from\
    \ one format into another, so I ended up writing a quick method that loops through\
    \ the array and creates a new array with the converted values.  It's not as quick\
    \ as some of the other methods, but it only converts once.  \n<code>", "  l.uniq\n\
    end", "  l.sort!\n  l.reject!{|v| l.count(v) > 1}\n  l\nend", "  l.uniq\nend",
  "  l.sort do |x, y|\n    y <=> x\n  end unless l.size <= 1\nend", "  l.sort!\n \
    \ n = 0\n  while n < l.size\n    if l[n] == l[n+1]\n      n+=1\n    else\n   \
    \   return l[n..-1]\n    end\n  end\n  nil\nend", "   if l.nil? || l.length ==\
    \ 0\n      return l\n   end\n   seen = Set.new\n   uniq_array = []\n   l.each\
    \ do |x|\n      break if seen.add(x)\n      uniq_array << x\n   end\n   return\
    \ uniq_array\nend\n</code>\n<|/ a tags=ruby,hashmap |>\n<| c |>\nWhat does it\
    \ return?\n<|/ c |>\n<| c |>\nit returns all the unique elements\n<|/ c |>\n<|\
    \ c |>\nIt returns a new Array, which contains all the unique elements. A Hash\
    \ would contain different keys, where as the Array would contain the different\
    \ keys. Please remember that, Hash doesn't contain duplicate elements. It doesn't\
    \ even allow you to do so. But Array does. And that's what this function returns.\n\
    <|/ c |>\n<| a dscore=2 |>\nA simple way would be:\n<code>\nhash.uniq.map { |k,\
    \ v| k }\n</code>\nwhich outputs:\n<code>\n[\"foo\", \"bar\", \"baz\"]\n</code>\n\
    <|/ a tags=ruby,hashmap |>\n<| a dscore=0 |>\n<code>\nhsh = Hash.new\nhsh.store(\"\
    foo\")\nhsh.store(\"bar\")\nhsh.store(\"baz\")", "  l.reduce(:&)\nend", "  seen\
    \ = []\n  result = []\n  l.each do |elem|\n    elem == elem if !seen.include?(elem)\n\
    \    seen << elem\n    result << elem\n  end\n  result\nend", "  # Return empty\
    \ list if list is empty\n  return l if l.size <= 1 \n  # Create new empty hash\n\
    \  result = {}\n  # Iterates through all elements in hash and adds to hash\n \
    \ l.each {|el| result[el] = true}\n  # Returns all elements that are in hash\n\
    \  result.keys\nend\n</code>\n<|/ a tags=ruby-on-rails-3.2,ruby,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your help. That worked great for me and I learned a\
    \ little bit about hashes :)\n<|/ c |>\n<| a tags=ruby-on-rails-3.2,ruby,ruby-on-rails\
    \ |>\nHere is a simple way to get unique elements.\n<code>", "  l.sort\n  l.reverse!\n\
    \  l\nend", "    seen = []\n    seen_add = seen.add\n    return [x for x in l\
    \ if x not in seen and not seen_add(x)]\n</code>\n<|/ a dscore=5 tags=sorting,unique,list,python\
    \ |>\n<| c |>\nYou just saved my life after a lot of frustration and headache!\n\
    <|/ c |>\n<| c |>\nThis answer doesn't work for Python 3.6 or later. `l.sort()`\
    \ returns a `TypeError`\n<|/ c |>\n<| c |>\n`list.sort()` sorts the list in place,\
    \ `sorted(l)` returns a sorted copy of `l`\n<|/ c |>\n<| c |>\n`sorted(l)` would\
    \ return a new sorted copy of a list.\n<|/ c |>\n<| c |>\n`[x for x in l if x\
    \ not in seen and not seen_add(x)]` is enough. `seen.add()` returns `None` if\
    \ no item was added to the `set`. `False` is falsy.\n<|/ c |>\n<| a dscore=5 tags=sorting,unique,list,python\
    \ |>\nUsing a set instead of a list will eliminate duplicates in the first pass.\
    \ \n<code>\n>>> x=[3,4,4,5,5,5,7]\n>>> x\n[3, 4, 4, 5, 5, 5, 7]\n>>> x.sort()\n\
    >>> x\n[3, 4, 5, 5, 5, 7]\n>>> set(x)\nset([3, 4, 5, 7, 5])\n</code>\n<|/ a |>\n\
    <| c |>\nThis does not work for me. If I use `x.sort()` instead of `sorted(x)`\
    \ it works.\n<|/ c |>\n<| c |>\nThanks, this actually worked for me after I used\
    \ sorted() on the original list\n<|/ c |>\n<| c |>\nSets are unsorted, so I wouldn't\
    \ consider this the right answer if order matters.\n<|/ c |>\n<| c |>\nSets are\
    \ also unordered; this is also not a good answer.\n<|/ c |>\n<| c |>\nthis one\
    \ is the only one which worked for me because all others returned unordered set\
    \ of items. Thanks !\n<|/ c |>\n<| a |>\nThis works as well:\n<code>\n>>> x =\
    \ [3, 3, 4, 5, 5, 5, 7]\n>>> sorted(set(x))\n[3, 4, 5, 7, 5]\n</code>\n<|/ a tags=sorting,unique,list,python\
    \ dscore=5 |>\n<| c |>\nThis is not the best answer because the original question\
    \ explicitly asks for sorted uniqueness.\n<|/ c |>\n<| c |>\nThis answer should\
    \ be edited to say that the original question explicitly asks for sorted uniqueness.",
  "  l.uniq!\nend", "    l.sort!\n    uniq = l.pop if l.size == l.size else nil\n\
    \    l.uniq! { |n| n == uniq }\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe\
    \ question is about ruby, not rubyo.\n<|/ c |>\n<| c |>\nIf you look at the comments\
    \ to my answer, you'll find that [Marcel](http://stackoverflow.com/users/365441/marcel-kelemen)\
    \ has now posted his [Answer](http://stackoverflow.com/a/9045343/2440) about a\
    \ time when rubyo was still an option.\n<|/ c |>\n<| c |>\nI should also point\
    \ out that while this answer does work with rubyo, it requires Ruby 1.9.\n<|/\
    \ c |>\n<| c |>\nThis doesn't seem to work for me for ruby 1.9.3\n<|/ c |>\n<|\
    \ c |>\nThis is not working with Ruby 1.9. \n```unique([1, 2, 3, 2, 2, 3, 1, 2,\
    \ 3, 1])", "  uniq = Hash.new{|h,k| h[k] = []}\n  l.each do |i|\n    if uniq.has_key?(i)\n\
    \      uniq[i] += [i]\n    else\n      uniq[i] = [i]\n    end\n  end\n  uniq.values\n\
    end\n</code>\nThis way is slightly faster, and requires less memory.\n<|/ a dscore=0\
    \ |>\n<| c |>\nYour code has a bug; you are checking `uniq.has_key?(i)`, but `uniq[i]`\
    \ exists before you check if it exists. I fixed it, and it appears to be faster,\
    \ so I think your code is faster. I also wrote my own version of a hash which\
    \ allows duplicates to be added, but this also requires less memory.\n<|/ c |>\n\
    <| c |>\nYes, my code is faster, but it is slower with larger lists. I didn't\
    \ notice that until I tested it, which was when I saw your answer. I suspect it\
    \ is because the `Hash` class does a hash table lookup for each access, which\
    \ gets slower as the number of elements in the hash table grows. `Set` has similar\
    \ problems, since it uses arrays internally to implement its `#include?` method.\
    \ `Set` also doesn't preserve the order of its elements. Those problems are more\
    \ severe than my version's bug. Yes, it does have less memory usage, but I believe\
    \ it is faster than my version.\n<|/ c |>\n<| a tags=arrays,ruby |>\nMy first\
    \ thought is to use Array#uniq! method. You can also pass a block that returns\
    \ the criteria of uniqueness.\n<code>", "  l.uniq { |i| i }\nend\n</code>\nI wouldn't\
    \ trust myself in that code though, since I'm unsure as to how it will perform\
    \ on huge lists.\n<|/ a tags=ruby,sorting,algorithm |>\n<| a |>\nThis solution\
    \ doesn't require any extra space (just two integers) and is fast and uses O(n)\
    \ memory.\n<code>", "  l.uniq!\nend", "  l.uniq!\n  l\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=5 |>\n<| a |>\n<code>\na = ['a', 'b', 'c', 'a']\na.uniq.sort", "  l.uniq!\n\
    \  l\nend", "  l.uniq!\n  l\nend", "    l.sort\n    l.uniq\nend", "  # Set default\
    \ value\n  v = nil\n  # For each element in list\n  l.each do |element|\n    #\
    \ Check if not already included in unique list\n    if v.nil? or element != v\n\
    \      # Set current value to new unique element\n      v = element\n      # Add\
    \ to unique list\n    end\n  end\n  # Return unique list\n  return v\nend\n</code>\n\
    Then you write an iterator to iterate over this collection and print the elements\
    \ you want:\n<code>", "  l.uniq!\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby\
    \ |>\nHere is another solution. Instead of using uniq, I used delete_if, which\
    \ removes the items that match a certain condition from the collection. In this\
    \ case, we want to remove any array item that has a duplicate element.\n<code>",
  "    return l.uniq\nend", "  l.sort!\n  l.reverse!\n  l\nend", "  l.sort\n  l.reject{|x|\
    \ l.count(x) > 1}\nend", "  l.uniq!\nend\n</code>\n<|/ a |>\n<| a |>\nUse a Hash,\
    \ which is designed exactly for this task.\n<code>\nrequire 'set'", "  return\
    \ l.uniq\nend", "    seen={}\n    seen_add=seen.add\n    return [x for x in l\
    \ if not (x in seen or seen_add(x))]\n</code>\n<|/ a |>\n<| a tags=list,python\
    \ |>\nAn efficient algorithm is to use binary search as shown below. This algorithm\
    \ is O(log(N)) which means it's faster than most of the other algorithms and it's\
    \ easy to implement. \n<code>", "  l.uniq.sort\nend", "    h = Set.new\n    l.each\
    \ do |x|\n        if !h.include?(x)\n            h.add x\n        end\n    end\n\
    \    return h.to_a\nend", "  seen = {}\n  result = []\n  l.each do |item|\n  \
    \  if seen[item] == nil\n      seen[item] = 1\n      result << item\n    end\n\
    \  end\n  result\nend\n</cell>\n<cell>", "  l.uniq\nend", "  l.sort.uniq\nend",
  "    l.uniq.sort\nend\n</cell>\n<code language=julia-1.6>\nunique(l)\n</cell>\n\
    <code language=julia-1.6>\nunique(l)\n</cell>\n<code language=julia-1.6>\nunique(l)\n\
    </cell>\n<text>\nSort!", "  l.sort\n  l.reverse.delete_if { |e| l.include? e }\n\
    end", "    a.uniq = true\n    a.sort(&:first)\nend", "  unique = []\n  l.each\
    \ do |i|\n    if unique.include?(i)\n      next\n    else\n      unique << i\n\
    \    end\n  end\n  unique\nend\n</code>\n<|/ a tags=ruby,sorting,unique,arrays,multidimensional-array\
    \ |>\n<| a |>\nIf you just want to remove duplicates, I like using Set.  It can\
    \ take arrays as well:\n<code>\narray = [[1, 2],\n         [3, 4],\n         [3,\
    \ 4],\n         [3, 4]]\nset = array.to_set\n  #=> #<Set: {1, 2, 3, 4}>\narray.size.times.reduce(set)\
    \ { |set, i| set & array[i] }.to_a\n  #=> [[1, 2], [3, 4]]\n</code>\nThis doesn't\
    \ require converting your array to an Array object, but does require converting\
    \ your Array to a Set.\n<|/ a dscore=2 tags=ruby,sorting,unique,arrays,multidimensional-array\
    \ |>\n<| a tags=ruby,sorting,unique,arrays,multidimensional-array |>\n<code>",
  "  # Create a set containing the unique elements\n  s = Set.new\n  l.each { |v|\
    \ s.add(v) }\n  return s\nend", "    unique = []\n    l.each do |i|\n        if\
    \ unique.include?(i) == false\n            unique << i\n        end\n    end\n\
    \    return unique\nend", "  l.sort!\n  l.uniq!\n  l\nend", "  l.sort\n  l.reject\
    \ { |i| l.count(i) > 1 }\nend", "  l.uniq!\n  l\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis is very close to what I want but I'm looking to find an ArrayList\
    \ method that would return the unique values rather than a List that could contain\
    \ duplicates.\n<|/ c |>\n<| c |>\nYeah, it's more straight forward and efficient\
    \ to just use Array#uniq!. +1\n<|/ c |>\n<| c |>\nThe above method works for any\
    \ Enumerable object, but it is not part of the Array class. You can simply `require\
    \ 'enumerator'` then `Array#uniq!` will work.\n<|/ c |>\n<| c |>\n`uniq!` method\
    \ doesn't seem to be documented anywhere in rubydocs, but I found it in [ActiveSupport](https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/uniq.haml)\
    \ which is in the `active_support` gem.\n<|/ c |>\n<| a tags=ruby,arrays,set |>\n\
    Another way that works with arrays is to use the inject method:\n<code>", "  \
    \  sorted = l.sort\n    uniq = sorted\n    (1..l.length).each do |i|\n       \
    \ uniq.unshift sorted[i] if sorted[i] != uniq[-1]\n    end\n    uniq\nend", " \
    \ seen = {}\n  u = []\n  \n  l.each do |x|\n    if seen[x]\n      u += [x]\n \
    \   else\n      seen[x] = true\n    end\n  end\n  \n  return u\nend", "  l.sort\n\
    \  l.reverse!\n  l.uniq!\n  l\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,ruby,ruby-on-rails\
    \ |>\nTo remove duplicates in an array (without using sort/uniq/to_set)\n<code>\n\
    arr = [1,2,1,2,1,3,4,5,6]\narr.dup.delete_if { |x| arr.count(x) > 1 }\n=> [1,\
    \ 2, 3, 4, 5]\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis approach is slow, especially\
    \ for large arrays. See my answer for more efficient ways to remove duplicates.\n\
    <|/ c |>\n<| c |>\nI like this one because it's more general, because it allows\
    \ for any custom condition (such as `return true if array.count > 1`\n<|/ c |>\n\
    <| a tags=arrays,ruby,ruby-on-rails dscore=1 |>\n<code>\narray = [1, 2, 4, 3,\
    \ 7, 5, 6, 9, 8, 1, 2, 4, 3, 7, 5, 6]", "  l.sort!\n  luniq = []\n  l.uniq!{|e|\
    \ luniq << (l.index(e) + 1) if luniq.empty? || luniq.last[0] != e}\n  luniq\n\
    end", "  l = l.sort.uniq\n  return l\nend\n</code>\nAnd now it's easy to do this:\n\
    <code>\nunique([\"a\", \"b\", \"a\", \"b\", \"c\"])\n=> [\"a\", \"b\", \"c\"]\n\
    </code>\n<|/ a |>\n<| a |>\n<code>", "  l.sort\n  l[l.index(l[0])..-1]\nend",
  "  l.sort\n  l.reverse.inject(:+) # uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ dscore=2 tags=ruby,arrays,hash |>\nIn case you want a Ruby-esque version:\n\
    <code>", "  uniq = nil\n  uniq = l.to_a.reduce([], :<<)\n  uniq.uniq!\n  return\
    \ uniq\nend\n</code>\n<|/ a dscore=5 |>\n<| a tags=ruby,sorting |>\nAnother option\
    \ is to use Enumerable#sort:\n<code>", "  l.sort\n  l = l[1..-1]\n  l.each { |x|\
    \ break if l.index(x) == l.size - 1 }\n  l\nend", "  l.uniq!\n  l\nend", "  l.uniq!\n\
    \  l\nend", "    l.sort\n    uniq = l.uniq\n    uniq\nend", "    l = l.sort()\n\
    \    l = [l[0]]\n    l.uniq!\n    l\nend", "  seen = {}\n  l.delete_if do |e|\n\
    \    if seen[e] then\n      true\n    else\n      seen[e] = true\n      false\n\
    \    end\n  end\nend", "  l.uniq!\n  l\nend\n</code>\nThen we can write the following\
    \ to get our desired result (thanks to Sarah for catching my mistake):\n<code>",
  "  l.uniq!\n  l\nend", "    l.uniq\nend", "  return l.sort!.uniq!\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks for your reply. I tried your solution with my dataset.\
    \ Although I get exactly the same array as I got before, the array has one more\
    \ element which is not in the initial one. So I guess it's probably the method\
    \ I used to get the initial array. Could you please give me some hints on what\
    \ went wrong? Thanks a lot!\n<|/ c |>\n<| c |>\nI guess you are still using Ruby\
    \ 1.9. This was introduced in Ruby 1.9 for Hash keys order to be stable for sorting.\
    \ This means you cannot rely on the ordering returned by the order method. In\
    \ other words, if you are using Ruby 1.9, you can use `Hash#sort_by` instead and\
    \ sort by keys. Otherwise, you have to use an external library like `RubySort.sort`.\n\
    <|/ c |>\n<| a tags=arrays,ruby,unique,sorting |>\nAs an alternative to the solutions\
    \ presented here which are quite comprehensive, I thought I'd post this solution\
    \ that works in Ruby 1.9 and sorts by a custom order. The custom order is simply\
    \ an array of integers containing all the indexes of the original array.\n<code>",
  "  # Add all elements of l to set\n  s = Set.new\n  l.each do |elem|\n    # Add\
    \ elem to set only once\n    s << elem unless s.include? elem\n  end\n  # Return\
    \ sorted unique elements from set\n  s.sort\nend", "    l = l.uniq \nend\n</code>\n\
    You have to add that method to Array class. It is only available in Rails 4 or\
    \ 5.\n<|/ a dscore=3 |>\n<| c |>\nYou probably want to change `uniq` to `uniq!`\
    \ to avoid modifying the original array, just so that you can chain it with `sort`.\n\
    <|/ c |>\n<| c |>\nThank you! I was stuck on this for ages.\n<|/ c |>\n<| a dscore=3\
    \ |>\nI had the same problem as you and I decided to just make a method of it\
    \ like this (Rails 5):\n<code>", "  l.uniq!\n  l\nend", "  l.uniq\nend\n</code>\n\
    So now let's take a look at how we can use our filter!:\n<code>", "  l.sort!\n\
    \  l.reverse.unique\nend", "  l.uniq\nend", "  l.uniq.sort\nend", "  uniq = nil\n\
    \  l.each { |x| uniq << x unless uniq.include?(x) }\n  uniq\nend", "    seen =\
    \ Set.new\n    uniques = []\n    l.each {|x| seen << x unless seen.include? x}\n\
    \    uniques\nend\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  l.uniq!\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,unique,ruby-on-rails-3,ruby-on-rails-4\
    \ dscore=3 |>\n<| a dscore=2 |>\n<code>\nrequire 'set'", "    seen = Set.new\n\
    \    l.inject([]) do |s, x|\n        return s if seen.include?(x)\n        seen\
    \ << x\n        s + [x] \n    end\nend\n</code>\nThe difference between uniq and\
    \ uniq is, uniq:", "  l.uniq\nend\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n\
    <| a dscore=1 |>\nIn Ruby 2.4+, use Enumerable#to_h for this:\n<code>\nhsh.to_h.values.sort\n\
    </code>\nOr more concisely:\n<code>\nhsh.to_h.sort.values\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI think `hsh.to_h.values` will be enough.\n<|/ c |>\n<| c |>\n\
    `hsh.to_h.values` returns an enumerator on `hsh` but `hsh.sort.values` returns\
    \ a new array on which you can call `values`. You might prefer `hsh.to_h.sort.values`\
    \ where you can call `sort` on the hash object while `values` on the array object.\n\
    <|/ c |>\n<| c |>\nYes, I missed that. Thanks!\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\nIn Ruby 1.9.3+ (but not earlier), use this:\n<code>\narray.uniq.sort_by(&:to_s)\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI don't think this works, because `Array#to_s`\
    \ returns the string representation of `self`, not the string representation of\
    \ the elements inside the array.\n<|/ c |>\n<| c |>\n: That's a very good point,\
    \ actually.\n<|/ c |>\n<| c |>\nThis will not work because `Array#to_s` does not\
    \ return a unique string.  For example `[1,1,2,2,3,3].to_s` will return `[\"1\"\
    , \"1\", \"2\", \"2\", \"3\", \"3\"]` but `[1,1,2,2,3,3].to_s.uniq` will just\
    \ return the string `\"1,2,3\"`.\n<|/ c |>\n<| c |>\n: That was a typo. Fixed\
    \ it.\n<|/ c |>\n<| a tags=ruby,arrays dscore=0 |>\nIf you can depend on Ruby\
    \ 1.9.2+, you can use Hash::new, like this:\n<code>\nhash = {}\narray.each do\
    \ |element|\n  hash[element] = hash[element] + 1 || 1\nend\narray = hash.keys\n\
    </code>\n<|/ a |>\n<| a tags=ruby,arrays dscore=0 |>\n<code>\narray.uniq.sort\n\
    </code>\n<|/ a |>\n<| c |>\nI like this one the best, but I did have to use sort_by\
    \ because I'm using Rails.  array.uniq.sort_by(&:to_s)\n<|/ c |>\n<|", "  l.sort\n\
    \  l.reverse!\n  l.uniq!\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=arrays,ruby\
    \ dscore=0 |>\nHere's an example of a method that uses the uniq method which does\
    \ what it says on the tin.\n<code>", "    uniques = []\n    \n    l.each do |element|\n\
    \        if uniques.include? element\n            uniques << element\n       \
    \ else\n            uniques << element\n        end\n    end\n    uniques\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 tags=ruby,algorithm |>\n<code>", " \
    \ return l.uniq\nend", "  l.sort\n  l.reject { |e| l.count(e) == 1 }\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby |>\nHere's an approach that uses Enumerable#group_by,\
    \ then converts it to a hash using Hash#from_xml:\n<code>\nrequire 'nokogiri'",
  "  l.sort\n  l.reverse\n  l\nend", "    l.uniq!\n    l\nend", "  if l == nil or\
    \ l.length == 0\n    return nil\n  end\n  sorted = l.sort\n  l.reject { |e| sorted\
    \ == e.sort }\nend", "  h = {}\n  l.each {|x| h[x] = x}\n  l = h.values\n  l.sort\n\
    end", "  return l.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`uniq` isn't\
    \ available for Rails 4.2+\n<|/ c |>\n<| c |>\nYes, Rails 4.2+ only has `.uniq`,\
    \ but that doesn't really answer his question as he is asking for a Rails way.\n\
    <|/ c |>\n<| c |>\nThanks for mentioning this.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ dscore=2 |>\nThis answer builds on Boris's and Frederick's answers. \n<code>",
  "  l.uniq.sort\nend", "  # Return unique elements in a list while preserving order\n\
    \  seen = {}\n  l = l.sort.uniq\n  l.each do |v|\n    seen[v] = true\n  end\n\
    \  seen.keys\nend\n</code>\n<code>", "  l = (l).uniq\n  l.sort\nend", "  l.uniq\n\
    end", "    l.sort!\n    return l.reduce :| nil\nend", "    uniques = []\n    l.each{\
    \ |x| uniques << x unless uniques.include? x}\n    uniques\nend", "    seen={}\n\
    \    seen_add=seen.add\n    return [x for x in l if x not in seen and not seen_add(x)]",
  "    l.uniq!\n    l.sort!\n    return l\nend\n</code>\nIt can then be used like\
    \ so to remove the duplicates from an array\n<code>\nunique_array = [[\"test\"\
    , \"test1\", \"test2\", \"test3\"], [\"test\", \"test4\", \"test5\", \"test6\"\
    ]]\nuniqued_array = []\nunique_array.each do |arr|\n  arr = arr.reduce(:merge)\n\
    \  arr.uniq!\n  uniqued_array.push(arr)\nend\n</code>\nWhich yields:\n<code>\n\
    [[\"test\", \"test1\", \"test2\", \"test3\"], [\"test4\", \"test5\", \"test6\"\
    ]]\n</code>\n<|/ a |>\n<| c |>\nThis is great! Could you help me understand how\
    \ this is functionally different than the other solutions I've seen so far? I'm\
    \ a little confused as to why we cannot use the built-in uniq method. Are there\
    \ any performance implications or other concerns I should be aware of?\n<|/ c\
    \ |>\n<| c |>\n, The only difference I can think of is this doesn't require you\
    \ to explicitly create the initial array and instead creates a new array each\
    \ iteration. Also, `uniq` won't work on arrays within arrays so this could potentially\
    \ be an issue.\n<|/ c |>\n<| c |>\nAwesome, thank you so much!\n<|/ c |>\n<| a\
    \ dscore=1 |>\nI like the previous answers with Array#uniq. Here's another one,\
    \ with reduce.\n<code>", "  uniq.sort l\nend", "    l.sort\n    l.uniq\nend",
  "  l\n  .group_by{|x| x}\n  .map{|k, v| [k, v.count]}.sort{|a, b| a[1] <=> b[1]}.map{|k,\
    \ v| k}\nend", "  # Create a new array to hold unique elements\n  u = []\n  #\
    \ Iterate over array and add elements to new array if they are not already in\
    \ the array\n  l.each do |i|\n    u.push i unless u.include? i\n  end\n  # Return\
    \ unique array\n  u\nend\n</code>\nThe first line is just to show you that unique\
    \ will return an array, but can be called a variable to make it easier to read\
    \ in the code.\nThe second line is just to show you that uniq is better than sort.uniq,\
    \ which would remove duplicates.\nThe last line is just to show you that uniq\
    \ can take block arguments.\n<|/ a |>\n<| a tags=ruby,arrays |>\n<code>\narray\
    \ = [1, 2, 3, 4, 2, 1, 3, 1, 2]\n</code>\nIf you want unique elements use uniq\n\
    <code>\narray.uniq", "    unique_elements = []\n    unique_elements_set = Set.new()\n\
    \    unique_elements_set.add(l[0])", "    l.uniq \nend\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby |>\n<code>\n[1,2,3,4,5,6,7,8].uniq\n</code>\nuniq is an Array method\
    \ in ruby.\n<|/ a dscore=3 |>\n<| a |>\n<code>\nx = [1,2,3,4,5,6,7,8]\nx.delete_if\
    \ { |e| x.count(e) == 1 }\n</code>\nThe first line creates a variable named x\
    \ containing an array containing the numbers from 1 to 8. The second line removes\
    \ any element from the array that appears only once (so removes 1,3,5 and 7).\n\
    <|/ a dscore=3 tags=ruby |>\n<| a tags=ruby |>\nThe code below removes duplicates\
    \ from an array:\n<code>", "    l.sort\n    return l.reduce { |x,y| x == y ? x\
    \ : [x,y]}.flatten\nend", "  l.sort!\n  l.reverse!\n  l\nend", "  l.reduce(:<<)\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nAh, `reduce` - I was trying to solve\
    \ this with `inject`\n<|/ c |>\n<| c |>\nHmm... I'm sure there's a reason why\
    \ `Array#uniq` didn't come out as a built-in, but this doesn't work for me (Rails\
    \ 3.2.13). In rails console, I tried `u = User.uniq.pluck(:name)` then `u` and\
    \ `u.first`, both returned `#<User:0x0000000613b888>`. The method `#uniq` doesn't\
    \ seem to be defined, even though `uniq` is listed as a method.\n<|/ c |>\n<|\
    \ c |>\nI believe you want: `u = User.uniq.pluck(:name)`.\n<|/ c |>\n<| c |>\n\
    I think you mean `pluck(:name)`. `pluck` doesn't work since `uniq` only returns\
    \ unique records, not unique values.\n<|/ c |>\n<| a |>\nHere is a more generalizable\
    \ solution that works with Enumerable as well as Enumerator:\n<code>", "  l.sort\n\
    \  l.reject{|x| l.count(x) > 1}\nend", "  # Initialize new empty array\n  new_l\
    \ = []\n  \n  # Loop through all elements and add them to new array\n  l.each\
    \ do |element|\n    if new_l.include?(element)\n      next # Continue if already\
    \ in new array\n    end\n    new_l << element\n  end\n  \n  return new_l # Return\
    \ new array with unique elements\nend\n</code>\nThis uses unique from Array. More\
    \ information can be found in the documentation.\n<|/ a tags=ruby |>\n<| c |>\n\
    Thank you for the great answer. I'm curious, is this more efficient than using\
    \ each_with_object?\n<|/ c |>\n<| c |>\nIt's not more efficient, but `each_with_object`\
    \ is more elegant. I think if you wanted to avoid a method, you could use the\
    \ `.uniq` method instead, but I'm not sure if that's an improvement. `uniq` would\
    \ probably be faster.\n<|/ c |>\n<| c |>\nThe downside of the `each_with_object`\
    \ approach is that it doesn't return an array, which means that it can't easily\
    \ be used in a more complex chain of operations. Also, since it modifies the object,\
    \ the `uniq` variant might not do what you expect if your object is modified in-place.\n\
    <|/ c |>\n<| c |>\nAwesome, thank you for your help. This works well, just what\
    \ I needed.\n<|/ c |>\n<| c |>\nI agree, `uniq` is the better choice.\n<|/ c |>\n\
    <| a tags=ruby |>\nI like using inject, as it's easier to read and write:\n<code>",
  "  l.sort!\n  u = {}\n  for i in 0..(l.size - 1)\n    u[l[i]] = l[i]\n  end\n  u.sort!\n\
    \  l\nend", "  # Create a hash with all seen elements set to false\n  h = {}\n\
    \  # Iterate over all elements\n  l.each do |x|\n    # Check if this element has\
    \ been seen before\n    if h[x] == false\n      # Mark this element as seen\n\
    \      h[x] = true\n      # Yield it\n      yield x\n    end\n  end\nend\n</pre>\n\
    </div>", "    l.uniq\nend", "    a.uniq = lambda l: sorted(set(l))\n    a.uniq(l);\n\
    end\n</code>\nThe output will be:\n<code>\n[5, 3, 7]\n</code>\n<|/ a |>\n<| a\
    \ dscore=2 tags=ruby |>\n<code>\n[3, 7].sort.uniq", "    l.uniq { |v| l << v }\n\
    end", "  u = {}\n  l.uniq {|x| u[x] ||= x}\n  u.values\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis isn't efficient, O(n log n) instead of O(n). A better approach would\
    \ be to sort then remove duplicates\n<|/ c |>\n<| c |>\n, You're probably thinking\
    \ of `to_set`\n<|/ c |>\n<| c |>\nYeah I thought so too, but I couldn't remember\
    \ if uniq had already been implemented on Array or Hash.  My guess is Hash.\n\
    <|/ c |>\n<| c |>\n, `uniq` is also O(n), but `to_set` is O(n^2). Also, `to_set`\
    \ doesn't allow for duplicates ;-)\n<|/ c |>\n<| c |>\n, Ruby has Hash objects\
    \ that don't allow duplicates, though they aren't Arrays. A Hash is like an object\
    \ that implements the `==` method, which means it's basically just a Hash :P\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>\n[1,1,1,2].uniq {|x| x}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis is very efficient and concise.\n<|/ c |>\n<|\
    \ c |>\nThis is the most efficient solution if you don't want to implement the\
    \ uniq method yourself. It is also the most readable solution.\n<|/ c |>\n<| c\
    \ |>\nThis is by far the best answer, as it is concise and efficient.\n<|/ c |>\n\
    <| c |>\nThis is most correct in that it answers the question asked, and not that\
    \ other answers don't.  I used this in my code, with a slight modification `[1,\
    \ 1, 2, 1].uniq{ |x| x }` returns `[1]`\n<|/ c |>\n<| c |>\nThis is the best answer,\
    \ and I wonder why it isn't at the top. This is a very elegant solution!\n<|/\
    \ c |>\n<| a tags=ruby,arrays |>\nAvoiding uniq could be done by sorting and removing\
    \ duplicates.\n<code>\n[1,1,1,2].sort.uniq { |i| i }\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI think this is a much better approach. Sort first because then\
    \ you are not sorting every item you check against every other item. Also, you\
    \ don't have to convert an array to a set, which is a O(n) operation.\n<|/ c |>\n\
    <| c ", "  l.uniq\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThat's great!\
    \ The reason I prefer this one to the `inject` method is that it works with `Array`\
    \ objects as well, which is necessary in some cases when you only want to know\
    \ whether a particular element is in a list or not.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ dscore=5 |>\n<code>\nrequire 'set'", "  l.sort!\n  l.reverse!\n  l.uniq!\n \
    \ l\nend", "  l.uniq.sort\nend\n</code>\n<|/ a tags=arrays,ruby,sorting |>\n<|\
    \ c |>\nThis is an awesome solution! Thank you\n<|/ c |>\n<| a tags=arrays,ruby,sorting\
    \ |>\nI recently needed a similar functionality in Python and ended up with the\
    \ following:\n<code>", "    uniqueArray = []\n    uniqueSet.eachWithIndex do |element,\
    \ index|\n        if uniqueArray.include?(element)\n            next\n       \
    \ else\n            uniqueArray << element\n        end\n    end\n    return uniqueArray\n\
    end", "    l.sort\n    return uniques! l\nend\n</code>\nThis can be used in conjunction\
    \ with Sets:\n<code>\n> s = Set[\"a\", \"b\", \"c\", \"c\"]\n> s\nSet(\"a\", \"\
    b\", \"c\")\n> unique(s)\nSet(\"a\", \"b\", \"c\")\n</code>\n<|/ a tags=julia,list\
    \ dscore=2 |>\n<| c |>\nThe question was about sorting and deduplicating elements\
    \ in a list, not about sorting and deduplicating sets of elements. Sets are not\
    \ ordered collections and therefore the question doesn't make sense.\n<|/ c |>\n\
    <| c |>\nThis question was also about sorting and deduplicating lists.\n<|/ c\
    \ |>\n<| c |>\nThe question explicitly says \"in a list\". Lists are ordered collections.\
    \ Therefore the question is legitimate. The answer is actually correct, and the\
    \ only answer here that does what it's asked.\n<|/ c |>\n<| c |>\nMy bad, sorry,\
    \ I'll edit my post to make it more clear what I am asking\n<|/ c |>\n<| a dscore=2\
    \ tags=julia,list |>\nTo deduplicate a list you can do the following:\n<code>\n\
    julia> L = copy([\"dog\", \"cat\", \"dog\", \"fish\"])\n3-element Array{String,1}:\n\
    \ \"dog\"\n \"cat\"\n \"fish\"", "  l.sort\n  l.reverse\n  l.reject{|x| l.count(x)\
    \ > 1}\nend", "  l.uniq!\n  l\nend", "  l.uniq\nend", "  l.sort\n  l.uniq\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 tags=ruby,arrays |>\nAnother option\
    \ is to create an array with uniq:\n<code>", "  l.uniq!\nend", "  l.uniq!\n  l\n\
    end", "  l.uniq\nend", "    l.sort\n    uniq = l[1..-1]\n    uniq\nend", "  l.uniq\n\
    end\n</code>\nA solution in Ruby would look like so,\n<code>\nrequire 'set'",
  "  l.sort!\n  l.reject! { |e| l.count(e) > 1 }\n  l\nend", "  # Return only unique\
    \ elements in a list\n  return l.uniq.sort\nend\n</code></pre>", "  l.sort\n \
    \ l = l.reverse\n  l.uniq!\n  l\nend", "    return l.sort!.uniq\nend\n</code>\n\
    <|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nThis won't work correctly on\
    \ `nil`s. `uniq` won't return the non-nil elements.\n<|/ c |>\n<| a dscore=0 |>\n\
    I like Jordan's answer but I would suggest using a block instead of an inline\
    \ if statement.\n<code>", "    seen = Set.new\n    l.select { |x| !seen.include?\
    \ x << x }\nend", "  return l.uniq\nend", "  # O(n) time, O(1) space\n  new_list\
    \ = []\n  seen = []\n  \n  l.each do |e|\n    if !new_list.include?(e) && e.to_s\
    \ not in seen\n      new_list << e\n      seen << e\n    end\n  end\n  \n  new_list\n\
    end\n</code>\n<|/ a |>\n<| a |>\nThis should do the trick:\n<code>\nrequire 'set'",
  "    l.sort!\n    l = l.uniq\nend\n</cell>\n<code language=julia-0.5>\nxs = [1,3,1,1,4,4,3,1,1,1,2,3]\n\
    </cell>\n<code language=julia-0.5>\nunique(xs)\n</cell>\n<text>\nIn julia you\
    \ can get the unique elements in a vector using the unique() function. Note that\
    \ unique() is already included in the Julia language and you can access it using\
    \ the @ operator.", "  l.uniq!\nend", "  l.sort\n  l.reverse\n  l\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,arrays |>\n<code>\n>> a = [1,2,3,4]\n=> [1, 2, 3, 4]\n\
    >> a.uniq\n=> [1, 2, 3, 4]\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq` is Ruby\
    \ 1.9+, so this will work in Ruby 1.9 and Rails 2 and 3. http://stackoverflow.com/a/4054474/604687\n\
    <|/ c |>\n<| c |>\nNote that this removes nil elements. `[1, 2, nil, 3].uniq`\
    \ would return `[1, 2, 3]`, while `[1,2,nil,3].uniq` would return `[1,2,nil]`\n\
    <|/ c |>\n<| c |>\nAlso note that this removes any duplicates whereas `uniq` will\
    \ keep the unique values where duplicates may arise from hashes and arrays.\n\
    <|/ c |>\n<| c |>\n`a = [1,2,nil,3]` will return `nil` as well. `a = [1,2,nil,3];\
    \ a.uniq; a` will return: `[1, 2, 3]`\n<|/ c |>\n<| c |>\n`uniq` does not remove\
    \ nil elements. `[1,nil,2,3].uniq` returns `[1, 2]`\n<|/ c |>\n<| a |>\n<code>\n\
    a = [1,3,2,2,3,3,5,5,5,1]\na.uniq { |x| x }", "  l.uniq\nend", "  l.uniq!\nend",
  "  l.uniq\nend\n</code></pre>\n            </div>\n            \n            \n\
    \            \n            \n            \n            \n            \n      \
    \      \n        </div>\n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n        \n\
    \        \n        \n        \n        \n        \n        \n        \n      \
    \  \n        \n        \n        \n        \n        \n        \n        \n  \
    \      \n        \n        \n        \n        \n        \n        \n", "  l.sort\n\
    \  l.uniq\nend", "  uniq = l.sort\n  uniq << nil\n  uniq.uniq!\nend", "  u = {}\n\
    \  for i in l\n    u[i] = nil\n  end\n  u.sort!\n  u\nend", "  l.reduce { |a,b|\
    \ a.uniq << b unless a.include?(b) }\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\n<code>", "   s = Set()\n   for el in l\n     s.add( el )\n   s.to_a\nend\n\
    </code>\nThe Set#to_a method returns a sorted array of the Set.\nA Set is like\
    \ a HashSet in that it returns only unique elements.  You can then add additional\
    \ elements to that Set and it will ignore duplicates.\n<|/ a |>\n<| c |>\n`Array#uniq`\
    \ will perform better than `Set#to_a` in this case\n<|/ c |>\n<| c |>\nYep, that\
    \ is true.  I actually went with `Array#uniq` because it was closer to what OP\
    \ already had.  I wasn't going to edit my answer because I felt this was more\
    \ directly what he wanted.\n<|/ c |>\n<| a tags=ruby |>\nIf you don't mind using\
    \ ActiveSupport gem you can use the OrderedSet from ActiveSupport gem\n<code>\n\
    require 'active_support/ordered_hash' # <= 1.8.7, 1.9.2", "  if l.nil?\n    return\
    \ l\n  end\n  l2 = l.clone\n  l2.reject!{|x| l.include?(x)}\n  return l2 if l2.empty?\n\
    \  l2.each_with_index{|x,i| l2.delete_at(i) if l2.count(x) > 1}\n  l2.sort!\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis does not work if I use a Hash instead\
    \ of an Array, like this `h = { a => b, c => d, a => f}`, but works if I do `h\
    \ = { a => b, c => d, a => f}.reduce(Hash.new{|h,k| h[k] = []}).values_at(*h.keys)`\n\
    <|/ c |>\n<| c |>\nAh, `a`, `b`, and `c` should be unique keys, right?  I assumed\
    \ that would have to be true as well.\n<|/ c |>\n<| a dscore=2 |>\n<code>\na =\
    \ [1,2,2,3,3,4,4]"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
