name: HumanEval_100_make_a_pile
language: rb
prompt: "# Given a positive integer n, you have to make a pile of n levels of stones.\n\
  # The first level has n stones.\n# The number of stones in the next level is:\n\
  # - the next odd number if n is odd.\n# - the next even number if n is even.\n#\
  \ Return the number of stones in each level in a list, where element at index\n\
  # i represents the number of stones in the level (i+1).\n# Examples:\ndef make_a_pile(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_a_pile\n\
  \    candidate = method(:make_a_pile)\n    assert_equal([3, 5, 7], candidate.call(3))\n\
  \    assert_equal([4, 6, 8, 10], candidate.call(4))\n    assert_equal([5, 7, 9,\
  \ 11, 13], candidate.call(5))\n    assert_equal([6, 8, 10, 12, 14, 16], candidate.call(6))\n\
  \    assert_equal([8, 10, 12, 14, 16, 18, 20, 22], candidate.call(8))\n  end\nend\n"
completions: ["    arr = []\n    arr.push(n)\n    if n.odd? \n        arr.push(n.next)\n\
    \    else \n        arr.push(n.next*2)\n        arr.push(n.next*3)\n    arr.each\
    \ { |i| puts i + 1 }\nend\n</code>\n<|/ a |>\n<| c |>\nI didn't know this kind\
    \ of programming could be done this way, nice job!\n<|/ c |>\n<| c |>\n: It can\
    \ be done this way, but it's way more complicated than it needs to be.\n<|/ c\
    \ |>\n<| c |>\nI agree with you, but I didn't want to complicate the answer more\
    \ than necessary.\n<|/ c |>\n<| c |>\nActually I like the other one that uses\
    \ only a couple of lines of ruby. I tried yours as an exercise and yours looked\
    \ simple and easy to understand.\n<|/ c |>\n<| c |>\n: It's also possible without\
    \ using an array.  See my answer.\n<|/ c |>\n<| a tags=ruby |>\nI came up with\
    \ the following solution. I'm not entirely sure if it uses less memory than your\
    \ solution, but it does use an array.\n<code>", "  result = []\n  result.push(n)\n\
    \  while n > 0\n    n = n % 2\n    result.push(n)\n  end\n  result.reverse\nend",
  "  levels = []\n  for i in 1..n\n    levels.push(i % 2 == 0 ? i : i + 1)\n  end\n\
    \  levels.map { |i| i + 1 }\nend\n</pre>\n            </div>\n          </section>\n\
    \          <section>\n            <h1>Exercises</h1>\n            <section>\n\
    \              <h2>Pile of Stones</h2>\n            </section>\n            <section>\n\
    \              <h3>1. Pile of Stones</h3>\n              <p>\n               \
    \ <img src=\"http://i.imgur.com/mL6nHdQ.jpg\">\n              </p>\n         \
    \     <p>\n                Write a function that determines the number of stones\
    \ in a pile\n                of stones.\n              </p>\n            </section>\n\
    \            <section>\n              <h3>2. Pile of Stones</h3>\n           \
    \   <p>\n                <img src=\"http://i.imgur.com/gZ2PqhR.jpg\">\n      \
    \        </p>\n              <p>\n                Write a function that returns\
    \ an array of integers that represent\n                the height of the pile.\
    \ The first element of the array represents the\n                number of stones\
    \ in the first pile, the second element of the\n                array represents\
    \ the number of stones in the second pile, etc.\n              </p>\n        \
    \    </section>\n            <section>\n              <h3>3. Pile of Stones</h3>\n\
    \              <p>\n                Write a function that returns an array of\
    \ integers that represent\n                the height of the pile. The first element\
    \ of the array represents the\n                number of stones in the first pile,\
    \ the second element of the\n                array represents the number of stones\
    \ in the second pile, etc.\n              </p>\n            </section>\n     \
    \       <section>\n              <h3>4. Pile of Stones</h3>\n              <p>\n\
    \                Write a function that takes a positive integer n and returns\
    \ the number\n                of stones in a pile of n levels.\n             \
    \ </p>\n            </section>\n            <section>\n              <h3>5. Pile\
    \ of Stones</h3>\n              <p>\n                Write a function that takes\
    \ a positive integer n and returns the number\n                of stones in a\
    \ pile of n levels.\n              </p>\n            </section>\n            <section>\n\
    \              <h3>6. Pile of Stones</h3>\n              <p>\n               \
    \ Write a function that returns a list of the number of stones in each\n     \
    \           level in a pile of n levels. Each element of the list represents\n\
    \                the number of stones in the level i+1.\n              </p>\n\
    \            </section>\n            <section>\n              <h3>7. Pile of Stones</h3>\n\
    \              <p>\n                Write a function that takes a positive integer\
    \ n and returns the number\n                of stones in a pile of n levels.\n\
    \              </p>\n            </section>\n            <section>\n         \
    \     <h3>8. Pile of Stones</h3>\n              <p>\n                Write a function\
    \ that returns a list of the number of stone", "  # Solution\n  stones_in_each_level\
    \ = []\n  \n  stones_in_each_level << n if n & 1 == 0\n  stones_in_each_level\
    \ << n if n & 2 == 1\n  stones_in_each_level\nend", "  raise NotImplementedError\n\
    end", "  return [n] if n.odd? or n.even? else [n,make_a_pile(n.odd?(n):n.even?(n):n.odd?(n.odd?(n):n.even?(n))).sum]\n\
    end\n</cell>\n<code language=julia-0.5>", "  if n.even?\n    []\n  else\n    [n..(n+2).floor]\n\
    \  end\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n    </div>\n  </div>\n</body>\n\
    </html>", "  arr = []\n  n = n.to_i\n  return n != 0 ? make_pile(n / 2, arr) +\
    \ make_pile(n % 2, arr) : arr\nend", "  return n.times.map {\n    n => n == 0\
    \ ? 0 : n == 1 ? 1 : n % 2 == 0 ? n - 1 : n\n  }\nend", "  stones = Array.new(n){\
    \ Array.new(n){0} }\n  stones.map! do |level|\n    level + 1 = level / 2\n   \
    \ level % 2 ? level + 1 : level\n  end\n  stones\nend", "  result = []\n  if n.odd?\n\
    \    n -= n.odd? ? 1 : 2\n  else if n.even?\n    n -= n.even? ? 2 : 1\n  end\n\
    \  result.push n\n  while n > 0\n    n = n.odd? ? n - 1 : n / 2\n    result.push\
    \ n\n  end\n  result.reverse\nend", "  n.upto(0){ |i| puts(i+1) }\nend", "  levels\
    \ = []\n  levels_count = 0", "  results = []\n  if n % 2 == 0\n    results.push([n])\n\
    \  else # n % 2 == 1\n    results.push(n/2, [n - (n/2)/2])\n  n.times do |i|\n\
    \    level = i + 1\n    if level % 2 == 0\n      results.push([level])\n    else\
    \ # level % 2 == 1\n      results.push(level/2, [level - (level/2)])\n    end\n\
    \  end\n  results\nend", "  # +++your code here+++\n  pile = Array.new(n,0)\n\
    \  pile[0] = n\n  pile.collect!{|i| (i&1)==0 ? i+1 : (i+1 & ~1) }\n  return pile\n\
    end", "  list = []\n  n = 0 unless n\n  loop do\n    list << n unless n % 2 ==\
    \ 1\n    n = n / 2 unless n\n  end\n  list\nend", "  # +++your code here+++\n\
    end\n</pre>", "  result = []\n  n.times do |i|\n    result << i % 2 == 0 ? n :\
    \ n / 2\n  end\n  result\nend", "    # write your code here\n    pile =[]\n  \
    \  if( n%2 != 0):\n        pile.append(n)\n        return pile\n    elif( n==1):\n\
    \        pile.append(0)\n        return pile\n    else:\n        for i in range(1,n+1):\n\
    \            pile.append(i)\n        return pile\n    ", "  pile = Array.new(n)\n\
    \  pile[0] = n\n  pile[0] += n / 2\n  for i in 1..n-1\n    if n % 2 == 1\n   \
    \   pile[i] = pile[i-1] + n\n    else\n      pile[i] = pile[i-1] + 2 * n\n  end\n\
    \  pile\nend", "  stk = []\n  odd_even = (n & 1).zero? : :odd\n  for i in 1..n\n\
    \    stk << (odd_even.zero? ? i : odd_even)\n  end\n  stk\nend\n</pre>\n<h2>\n\
    <a id=\"permutation-problems\" name=\"permutation-problems\">25. Permutation Problems</a>\n\
    </h2>", "  if n % 2 != 0\n    puts \"The given number is odd\"\n    return []\n\
    \  elsif n % 2 == 0\n    puts \"The given number is even\"\n    return [n]\n \
    \ else \n    puts \"The given number is too large\"\n    return make_a_pile(n-1)\n\
    \  end\nend", "  pile = []\n  pile[0] = (n+1).odd? ? n : (n+1).even? ? 2*n : nil\n\
    \  pile[1] = pile[0].odd? ? pile[0].even? : nil\n  pile[2..-1].each do |i|\n \
    \   pile[i] = (n+1).odd? ? n : (n+1).even? ? 2*n : nil\n  end\n  pile\nend", " \
    \ pile = Array.new(2*n-1)\n  pile = pile.dup\n  pile = pile.map{|i| i%2==0 ? i\
    \ : i+1}\n  pile\nend", "  if n == 0\n    return [0]\n  if n % 2 == 0\n    return\
    \ [n + 1, make_a_pile(n-1)]\n  return [n/2, make_a_pile(n/2)]", "    pile = [n]\
    \ * n\n    pile.pop(0)\n    pile.pop(0)\n    i = 0\n    while i < len(pile)\n\
    \        if i % 2 == 1\n            pile[i] = pile[i] - 1\n            i += 1\n\
    \        else\n            pile[i] = pile[i] + 1\n            i += 1\n       \
    \ end\n    end\n    i = 0\n    while i < len(pile)\n        pile[i] = pile[i]\
    \ + 1\n        i += 1\n    end\n    return pile\nend", "  if n == 0\n    0\n \
    \ elsif n == 1\n    1\n  elsif n % 2 == 1\n    make_a_pile(n-1)\n  else\n    make_a_pile(n/2)+1\n\
    \  end\nend\nmake_a_pile(5) # => [1, 3, 6, 1, 2]", "  levels = []\n  levels <<\
    \ make_level(n)\n  levels << make_level(n - levels[0].length)\n  levels.map!{|l|\
    \ l.map{|e| e == 0 ? 1 : e}}\n  levels\nend", "    if n == 0 then return [0]\n\
    \    if n == 2 then return [0, 1]\n    if n % 2 == 0 then \n        odd = n +\
    \ 1\n        even = n + 1\n    else \n        odd = n\n        even = n + 1\n\
    \    end\n    pile = make_a_pile(odd)\n    pile.push((odd % 2) == 0 ? even : odd)\n\
    \    pile.push(odd % 2)\n    return pile\nend\n</cell>\n<code language=julia-1.0>\n\
    make_a_pile(10)\n</cell>\n<code language=julia-1.0>\nfunction make_a_pile2(n)\n\
    \    arr = []\n    if n == 0 then return arr\n    if n == 2 then return arr ==\
    \ [0, 1], arr\n    if n % 2 == 0 then \n        odd = n + 1\n        even = n\
    \ + 1\n    else \n        odd = n\n        even = n + 1\n    end\n    make_a_pile2(odd)\
    \ == make_a_pile2(odd + 1) && arr.push((odd % 2) == 0 ? even : odd)\n    arr.push(odd\
    \ % 2)\n    return arr\nend\n</cell>\n<code language=julia-1.0>\nmake_a_pile2(10)\n\
    </cell>\n<text>\nExercise 2\nWrite a function named make_a_dice that returns an\
    \ array of n elements: the first element represents the number $n$, the second\
    \ element represents the number $n-1$, and so on. For example:\n$$\n\\begin{align}\n\
    & make_a_dice(5) =& \\begin{bmatrix}5 & 4 & 3 & 2 & 1 \\end{bmatrix} \\\n& =&\
    \ \\begin{bmatrix}5 & 4 & 3 & 2 & 1 \\end{bmatrix} = \\begin{bmatrix}0 & 1 & 2\
    \ & 3 & 4 \\end{bmatrix}\n\\end{align}\n$$\nHint: to create an array with n elements,\
    \ use the built-in function repeat.", "  if n < 0 then\n    return nil\n  else\n\
    \    pile = Array.new(1,n)\n    pile.first = (n % 2 == 0) ? n : n * 3 + 1\n  \
    \  pile.last  = pile.first + n\n    pile\n  end\nend", "  levels = []\n  n.times\
    \ do\n    levels << n.odd? ? n.odd? ? n - n.odd? : n.even? ? n.even? : nil : nil\n\
    \  end\n  levels\nend", "  result = []\n  while n > 0\n    result = [n.odd? ?\
    \ n + 1 : n + 1 ]\n    n = n.even? ? n + 2 : n\n  end\n  result\nend", "  return\
    \ n.times.map { |i| i%2 == 0 ? n : n/2 }\nend", "  pile = Array.new(2*n+1)\n \
    \ pile[0] = n\n  pile[n] = 1", "  if n < 0\n    puts \"ERROR: n must be positive\"\
    \n    return\n  end\n  result = []\n  n = 0 if n % 2 == 0 # handle odd n\n  n\
    \ += 1 if n % 2 != 0 # handle even n\n  n = 0 if n < 0\n  result[0] = n\n  result[1]\
    \ = n - 1 + make_a_pile(n/2) if n % 2 == 0\n  result[2] = n - 1 + make_a_pile(n/2)\
    \ - 1 if n % 2 != 0\n  return result\nend", "    # write your code here\n    return\
    \ []\nend", "  if n == 0\n    0\n  elsif n % 2 == 0\n    n+1\n  else\n    n-1\n\
    \  end\nend\n</pre>", "  level = [n] * n\n  level[0] = (n % 2 == 0 ? n : n - 1)\n\
    \  level[1] = (n % 2 == 0 ? n - 1 : n)\n  level.map { |n| n.downto(1).count {\
    \ |i| i % 2 == 1 } }\nend", "    piles = []\n    if n > 0\n        piles << [n]\n\
    \        while piles.last.even?\n            piles << [piles.last.floor + 1]\n\
    \            piles << [piles.last.floor + 2]\n        end\n    end\n    piles.reverse\n\
    \    piles\nend", "  arr = []\n  i = 0\n  while i < n do\n    arr.push n\n   \
    \ i += 2\n  end\n  arr.push n\n  return arr\nend", "    pile = Array.new(n + 1)\n\
    \    pile[1] = n\n    pile[2] = n\n    n.times do |i|\n        pile[i] = pile[i\
    \ + 1] = if i % 2 == 1\n            pile[i + 1] + 2\n        else\n          \
    \  pile[i + 1] + 3\n        end\n    end\n    pile\nend", "    # write your code\
    \ here\n    pile = []\n    if n == 0 then\n        pile.push(0)\n        return\
    \ pile\n    elif n % 2 == 1 then\n        pile.push(n / 2)\n        return pile\n\
    \    else\n        pile.push(n / 2)\n        return make_a_pile(n / 2)\n    end\n\
    end", "    if n <= 0 then return nil\n    if n == 1 then return [1]\n    if n\
    \ % 2 == 0 then return [n] + make_a_pile(n / 2)\n    return [n] + make_a_pile((n\
    \ / 2) + 1)\nend\n</cell>\n<code language=julia-1.0>\n@assert make_a_pile(6) ==\
    \ [1, 1, 1, 1, 1, 1]\n@assert make_a_pile(3) == [1, 2, 1]\n</cell>\n<text>\nStone\
    \ on a Lego\nNow let's solve the problem for n = 2.", "  # n is even\n  if n %\
    \ 2 == 0\n    level = make_a_pile(n / 2)\n    level.push n\n  else\n    level\
    \ = make_a_pile(n / 2).push(n)\n  end", "  stones = Array.new(n+1)\n  for i in\
    \ 1..n+1\n    stones[i] = (i+1) * i\n  end\n  stones.delete_at(n)\n  stones.last\n\
    end", "  levels = []\n  while n > 0\n    levels << n\n    if n & 1\n      n =\
    \ n - 2\n    else\n      n = n / 2\n    end\n  end\n  levels << n\n  levels.reverse\n\
    end", "    list = []\n    if n == 0\n        return list\n    if n % 2 == 0\n\
    \        list = make_a_pile(n / 2)\n        list.push(n * 2)\n        return list\n\
    \    list = make_a_pile(n / 2)\n    list.push(n * 2)\n    list.push(n / 2)\n \
    \   return list\nend", "    levels = []\n    i = 0\n    while i < n do\n     \
    \   levels << [(n-1)]\n        i += 1 if n.odd?\n        i += 2 if n.even?\n \
    \   end\n    return levels\nend", "  return [n] * (n+1)\nend", "    # Write your\
    \ code here.\n    if n <= 1:\n        return [n]\n    elif n % 2 == 0:\n     \
    \   return [n / 2, n - n / 2]\n    else:\n        return [n / 2, n / 2] + make_a_pile(n\
    \ - n / 2)", "    # n is even\n    if n % 2 == 0\n        stones = n\n       \
    \ n -= 1\n        i += 1\n        while n < stones\n            n += 2\n     \
    \       stones += 1\n            i += 1\n        return [n]\n    # n is odd\n\
    \    else\n        stones = n\n        n -= 1\n        i += 1\n        while n\
    \ < stones\n            n += 3\n            stones += 1\n            i += 1\n\
    \        return [n]\nend", "  # Your code here\n  arr = []\n  arr[0] = 0\n  if\
    \ n % 2 == 1\n    arr[1] = n\n    arr = arr[0..(n-1)]\n  else\n    arr[1] = n-1\n\
    \    arr = arr[0..(n-1)]\n    arr.each do |i|\n      if i % 2 == 0\n        arr[i+1]\
    \ += 1\n      else\n        arr[i+1] += 1\n      end\n    end\n  end\nend", " \
    \ return [] if n.odd? or n.even?\n  return [n] + make_a_pile(n.odd? - 1) + make_a_pile(n.even?\
    \ - 1)\nend", "  # return a list of n integers\n  if n == 0 then return [0]\n\
    \  if n == 1 or n % 2 == 0 then return [n]\n  ret = []\n  (n % 2 == 0 ? (ret.concat\
    \ [n, (n+1)/2]) : ret.concat [n,n/2])\n  ret\nend\n</pre>\n            </div>\n\
    \          \n          \n          \n            \n            <pre class=\"p2\
    \ no-shadow\"><code class=\"language-bash\" data-lang=\"bash\">cat &lt;&lt;EOF",
  "    level = 0\n    while n > 0\n        n -= 1\n        level += 1\n    end\n \
    \   levels = Array.new(level+1)\n    levels.push n / 2\n    levels.push n % 2\
    \ == 0 ? 1 : 2\n    levels[level] = n / 2\n    return levels\nend\n</cell>\n<code\
    \ language=julia-1.0>\nmake_a_pile(12)\n</cell>\n<code language=julia-1.0>\nmake_a_pile(23)\n\
    </cell>\n<code language=julia-1.0>\nmake_a_pile(37)\n</cell>\n<code language=julia-1.0>\n\
    make_a_pile(500)\n</cell>\n<code language=julia-1.0>\nmake_a_pile(100000000)\n\
    </cell>\n<text>\nPart 3: The Minesweeper Side Diameter\nYou will work with the\
    \ Minesweeper puzzle game, which involves placing bombs next to a mine (the game\
    \ is similar to chess).  You will use the Minesweeper puzzle to teach a computer\
    \ how to solve the classic puzzle problem of placing bombs on mines.  You will\
    \ also explore a mathematical approach to solving the puzzle.", "    # write your\
    \ code here\n    levels = []\n    if n % 2 == 0:\n        for i in range(0,n,2):\n\
    \            levels.append(i)\n    else:\n        for i in range(0,n,1):\n   \
    \         levels.append(i)\n    return levels", "  result = []\n  (1..n).each\
    \ do |i|\n    if i.even? then\n      result << i\n    else\n      result << i.odd?\
    \ ? i.next : i.next + 1\n    end\n  end\n  result\nend", "  if n<0\n    return\
    \ []\n  res=[]\n  while n > 0\n    if n&1 \n      res.push(2**(n-1))\n      n=n>>1\n\
    \    else\n      res.push(n)\n      n=1\n    end\n  end\n  return res\nend", " \
    \ if n == 0\n    return [0]\n  else\n    if n % 2 == 0\n      pile = make_a_pile(n\
    \ / 2) + [n]\n    else\n      pile = make_a_pile(n / 2) + [n-1] + make_a_pile(n\
    \ / 2)\n    end\n  end\nend", "  result = []\n  pile = []\n  i = 0\n  while i\
    \ < n do\n    if i % 2 == 0\n      pile.push(i)\n    else\n      pile.push(i -\
    \ 2)\n    end\n    i += 1\n  end\n  i = 0\n  while i < n do\n    result.push((pile.pop\
    \ * 3 + 1) if pile.pop % 3 == 0 else\n                  (pile.pop * 3 + 2))\n\
    \    i += 1\n  end\n  return result\nend", "  pile = Array.new(n+1, 0) # +1 to\
    \ have first index be 0\n  pile[0] += n\n  (1..n).each { |i| pile[i+1] = pile[i]\
    \ + i % 2 }\n  pile\nend", "  pile = []\n  for i in range(0, n):\n    pile.push\
    \ i\n    if i % 2 == 0 then\n      pile.push i * 2\n      pile.push i * 3\n  \
    \  end\n  end\n  return pile\nend\nprint(make_a_pile(14))", "  return n==0 ? []\
    \ : make_a_pile(n-1).map {|i| (n%2 == 0 ? i*2 : i*2+1).to_s}\nend", "  result\
    \ = []\n  num_stones = n\n  \n  while num_stones > 1\n    next_num_stones = num_stones\n\
    \    \n    if num_stones % 2 == 0 then\n      next_num_stones = next_num_stones.next\n\
    \    end\n    \n    result.push num_stones\n    num_stones = next_num_stones\n\
    \  end\n  \n  result\nend", "  if n == 0\n    0\n  elsif n % 2 == 1\n    make_a_pile(n\
    \ - 1)\n    make_a_pile(1)\n    make_a_pile(0)\n  else\n    make_a_pile(n - 2)\n\
    \    make_a_pile(n / 2)\n    make_a_pile(n / 2)\n  end\nend\n</pre>\n</div>\n\
    <h2 id=\"testing-the-code-with-a-simple-program-\">Testing the code with a simple\
    \ program:</h2>\n<p>Let's test the code. Here is an example of how we would test\
    \ the code:</p>\n<div class=\"sourceCode\" id=\"cb8\">\n<pre data-filter-output=\"\
    (out)\" class=\"sourceCode ruby script\"><code class=\"sourceCode ruby\"><a class=\"\
    sourceLine\" id=\"cb8-1\" data-line-number=\"1\">pile_of_stones(1) <span class=\"\
    kw\">==</span> <span class=\"dv\">1</span>    <span class=\"co\"># 1</span></a>\n\
    <a class=\"sourceLine\" id=\"cb8-2\" data-line-number=\"2\">pile_of_stones(2)\
    \ <span class=\"kw\">==</span> <span class=\"dv\">2</span>    <span class=\"co\"\
    ># 2</span></a>\n<a class=\"sourceLine\" id=\"cb8-3\" data-line-number=\"3\">pile_of_stones(3)\
    \ <span class=\"kw\">==</span> <span class=\"dv\">3</span>    <span class=\"co\"\
    ># 3</span></a>\n<a class=\"sourceLine\" id=\"cb8-4\" data-line-number=\"4\">pile_of_stones(4)\
    \ <span class=\"kw\">==</span> <span class=\"dv\">6</span>    <span class=\"co\"\
    ># 6</span></a>\n<a class=\"sourceLine\" id=\"cb8-5\" data-line-number=\"5\">pile_of_stones(5)\
    \ <span class=\"kw\">==</span> <span class=\"dv\">10</span>   <span class=\"co\"\
    ># 10</span></a>\n<a class=\"sourceLine\" id=\"cb8-6\" data-line-number=\"6\"\
    >pile_of_stones(6) <span class=\"kw\">==</span> <span class=\"dv\">20</span> \
    \  <span class=\"co\"># 20</span></a>\n<a class=\"sourceLine\" id=\"cb8-7\" data-line-number=\"\
    7\">pile_of_stones(7) <span class=\"kw\">==</span> <span class=\"dv\">40</span>\
    \   <span class=\"co\"># 40</span></a>\n<a class=\"sourceLine\" id=\"cb8-8\" data-line-number=\"\
    8\">pile_of_stones(8) <span class=\"kw\">==</span> <span class=\"dv\">80</span>\
    \   <span class=\"co\"># 80</span></a>\n<a class=\"sourceLine\" id=\"cb8-9\" data-line-number=\"\
    9\">pile_of_stones(9) <span class=\"kw\">==</span> <span class=\"dv\">120</span>\
    \  <span class=\"co\"># 120</span></a>\n<a class=\"sourceLine\" id=\"cb8-10\"\
    \ data-line-number=\"10\">pile_of_stones(10) <span class=\"kw\">==</span> <span\
    \ class=\"dv\">200</span>  <span class=\"co\"># 200</span></a>\n<a class=\"sourceLine\"\
    \ id=\"cb8-11\" data-line-number=\"11\">pile_of_", "\tstones = []\n\tfor i in\
    \ 1..n\n\t\tstones = stones + [n]\n\t\tstones[1..i%2].push(stones[i/2] + stones[i/2-1])\
    \ \n\t\tstones[1..i/2].push(stones[i/2+1] + stones[i/2]) \n\t\tstones[1..i].push(stones[i/2-1]\
    \ + stones[i/2] + stones[i/2+1] + stones[i]) \n\treturn stones\nend\nprint make_a_pile(4)",
  "  pile = Array.new(2*n, 0)\n  pile[0].upto(2*n) do |i|\n    pile[i+1] = pile[i]\
    \ + 1 if i % 2 == 1\n    pile[i+1] = pile[i] + 1 if i % 2 == 0\n  end\n  pile\n\
    end", "    # your code here\n    if n % 2 == 0:\n        pile = [1]\n        for\
    \ i in range(1, n, 2):\n            pile.append(pile[-1] * 2)\n        return\
    \ pile\n    else:\n        pile = [1]\n        for i in range(1, n, 2):\n    \
    \        pile.append(pile[-1] * 3)\n        return pile\n</cell>\n<cell>", " \
    \ count = 0\n  while n > 0\n    if n.odd?\n      count += n.odd? ? 1 : 2\n   \
    \   n -= 1\n    else if n.even?\n      count += n.even? ? 1 : 2\n      n -= 1\n\
    \    else\n      count += 1\n      n -= 1\n  end\n  []\nend", "\tarr = []\n\t\
    arr[0] = 0\n\tarr[1] = 0\n\tarr[2] = 1\n\tfor i in 2..n\n\t\tarr[i] = arr[i-1]\
    \ + 1\n\t\tarr[i] = arr[i-1] + 1 if i%2 == 0 \n\tarr[n-1]\nend", "  \nend", " \
    \   total = []\n    i = 0\n    while i < n do\n        total[i] = n\n        if\
    \ n&1 == 0 then\n            n = n + 1\n        elsif n&1 == 1 then\n        \
    \    n = n / 2\n        else\n            n = n * 3 + 1\n        end\n       \
    \ i = i + 1\n    end\n    total\nend", "  # n is guaranteed to be an integer.\n\
    \  return n % 2 == 0 ? [n] : [n * 2] + make_a_pile(n / 2)\nend", "  pile = Array.new(n)\n\
    \  pile.push n\n  pile.push n+1\n  pile.push n+2\n  pile.push n+3\n  pile.push\
    \ n+4\n  pile.push n+5\n  return pile\nend", "  # TODO: complete this method\n\
    end\n</pre>\n<p>\n  In case you are wondering, the last level of the pile has\
    \ one more element\n  than the number of stones in the previous level.\n</p>\n\
    <p>\n  <b>Extra credit</b>\n  If you only need to compute the answer for a few\
    \ values of n, you can do\n  the same computation without using loops or recursion.\n\
    </p>\n<pre>", "  stones = []\n  stones << [n]\n  if n % 2 == 1\n    stones <<\
    \ (n+1)\n  else\n    stones << (n+1)/2\n  end\n  stones.each_with_index do |n,i|\n\
    \    stones[i] == 0 ? stones.delete(i) : stones[i] == 1 ? stones.delete(2*i) :\
    \ stones.delete(3*i+1)\n  end\nend\n</cell>\n<code language=ruby-1.9.3-p448>",
  "  # Your code here\nend", "  if n == 0\n    return []\n  i = 2\n  result = make_a_pile(i)\
    \ + [n % 2 ? 1 : -1]\n  while i <= n / 2\n    result = make_a_pile(i) + result\n\
    \    i += 2\n  return result\nend", "  # n is odd\n  if n & 1\n    puts \"too\
    \ large\"\n  else\n    puts \"too small\"\n  end\nend\n</pre>", "    pile = Array.new(n)\
    \ do |i| \n       if i.even?\n           i.odd\n       else\n           i.even\n\
    \       end\n    end\n    i = 0\n    until pile.empty? do \n        pile[i] =\
    \ pile.first\n        i += 1 \n    end \n    return pile\nend", "    list = []\n\
    \    i = 1\n    while n > i:\n        if n % 2 == 0:\n            n /= 2\n   \
    \         list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \        else:\n            n /= 2\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            list.append(i)\n\
    \            list.append(i)\n            list.append(i)\n            ", "  result\
    \ = []\n  while n > 0\n    if n % 2 == 0\n      result[-1] += n\n      n /= 2\n\
    \    else \n      result[-1] += n\n      n /= 2\n      result[-1] += n\n  end\n\
    \  result\nend", "  a = n.odd? ? 1 : n.even? ? 2 : -1\n  levels = []\n  i = 0\n\
    \  while a != 0\n    i += 1\n    next unless a\n    levels << i\n    a = a.even?\
    \ ? a.next : a.next\n  end\n  levels\nend", "    stones = []\n    if n % 2 ==\
    \ 0\n        stones.push n\n        stones.push 2 * n\n    else\n        stones.push\
    \ n \n        stones.push n + (n / 2)\n    end\n    return stones\nend", "  levels\
    \ = []\n  levels_n = n % 2 == 0 ? [n] : [n-1, n+1]\n  levels.concat levels_n.map\
    \ { |n| make_a_pile(n) }\n  levels\nend", "  a = Array.new(n)\n  a.map! {|i| i\
    \ % 2 ? i : (i + 1) % 4}\n  a.compact!\n  a\nend\n</pre>\n            </div>\n\
    \          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\
    <footer class=\"footer\">\n  <div class=\"container\">\n    <p class=\"pull-right\"\
    >\n      <a href=\"#\">Back to top</a>\n    </p>\n    <p>\n        &copy; Copyright\
    \ 2013 Monty Grave.\n    </p>\n  </div>\n</footer>\n<!-- Global site tag (gtag.js)\
    \ - Google Analytics -->\n<script async src=\"https://www.googletagmanager.com/gtag/js?id=UA-3769691-37\"\
    ></script>\n<script>\n  window.dataLayer = window.dataLayer || [];\n  function\
    \ gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());", "  stones =\
    \ []\n  i = 0\n  while i < n do\n    stones << i+1\n    i += 1 if n%2 == 0\n \
    \   i += 1 if n%2 != 0\n  end\n  stones\nend", "  n = n.to_i\n  if n.odd? \n \
    \   n.next\n  elsif n.even?\n    2*n\n  else\n    n+2\n  end\nend\n</pre>", " \
    \ if n % 2 == 0\n    next_odd = n+1\n  else\n    next_even = (n+1)/2\n  end\n\
    \  result = []\n  result[0] = n\n  for i in (1..next_even)\n    level = result[0...i]\n\
    \    level[1] = i\n    result.concat(level)\n  end\n  for i in (1..next_odd)\n\
    \    level = result[0...i]\n    level[1] = i\n    result.concat(level)\n  end\n\
    \  result\nend", "  # +++your code here+++\nend", "  if n < 1\n    return nil\n\
    \  elsif n == 1\n    return [1]\n  elsif n % 2 == 0\n    return [n, 1]\n  else\n\
    \    return [n, make_a_pile(n.odd).last + make_a_pile(n.even).last]\n  end\nend\n\
    </pre>\n</div>", "  stones = []\n  if n % 2 == 1 then\n    stones[2] = 1\n  else\
    \ \n    stones[0] = 1\n  end\n  for i in 1..n do\n    if n % 2 == 0 then\n   \
    \   stones[(i+1)..2] = stones[0..i].map { |x| x + 1 }\n    else\n      stones[(i+1)..0]\
    \ = stones[0..i].map { |x| x - 1 }\n    end\n  end\n  stones\nend", "  levels\
    \ = []\n  levels << n if n % 2 == 0\n  levels << (n - 1) if n % 2 == 1\n  levels.inject([]){|sum,\
    \ el| sum << el}\nend", "  levels = []\n  levels.push(n)\n  n.times do\n    levels.push(\
    \ (n+1).odd? ? n.odd? ? n : n.even? ? n.even? ? n : n+1 : n+1)\n  end\n  levels\n\
    end", "  # TODO: Write your code here.\n  stones = []\n  \n  stones.append(n)\n\
    \  \n  while n > 0:\n    \n    if n % 2 == 0:\n      n //= 2\n      stones.append(n)\n\
    \      \n    else:\n      n /= 2\n      stones.append(n)\n  \n  return stones\n\
    </cell>\n<cell>", "  result = []\n  stones = n", "  levels = []\n  while n > 0\n\
    \    if n % 2 == 1\n      levels.push(n % 2)\n      n /= 2\n    else \n      levels.push(n\
    \ % 2)\n      n /= 2\n      levels.push(n % 2)\n      n /= 2\n  end\n  levels\n\
    end", "    # Fill this in.\nend", "  pile = []\n  pile.push(n)\n  for i in 1..n\n\
    \    pile.push((n+i-1)%2)\n  end\n  pile\nend", "  return n.times.map { make_a_stone(n\
    \ % 2 == 0 ? n : n % 2 + 1) }\nend", "  nums = []\n  nums[1] = n\n  if n.odd?\n\
    \    nums[2] = n.odd?\n  else\n    nums[2] = n.even?\n  end\n  (1..nums.length).each\
    \ do |i|\n    nums[i] = nums[i+1] + nums[i+2]\n  end\n  nums\nend", "    if n\
    \ % 2 == 1\n        stones_in_the_pile = [n]\n    else\n        stones_in_the_pile\
    \ = []\n        pile = n\n        while pile != 1\n            pile = (((pile/2)+1)/2)\n\
    \            stones_in_the_pile.push(pile)\n        end\n    end\n    return stones_in_the_pile\n\
    end", "  if n <= 0 then\n    return nil\n  else\n    stones = make_a_pile(n/2)\
    \ # first level has n stones\n    stones = stones + [n%2] # last level has n stones,\
    \ add an extra stone if n is even\n    return stones\n  end\nend", "  arr = (0..n).to_a\n\
    \  even, odd = arr.partition { |i| i.odd? }\n  odd.map { |i| i.even? ? i.next::0\
    \ : (i+1).next::0 }.flatten\nend\n</pre>", "  result = []\n  while n > 0\n   \
    \ result << n\n    if n.odd?\n      n /= 2\n    elsif n.even?\n      n = n/2\n\
    \    else\n      n = 3*n +1\n    end\n  end\n  result\nend\n</pre>", "  if n <\
    \ 0\n    puts \"Invalid n\"\n    return\n  odd_pile =\n  even_pile =\n  result\
    \ = []\n  result[0] = n\n  if n == 0\n    return 0\n  if n % 2 == 0\n    even_pile\
    \ += n\n  else\n    odd_pile += n\n  end\n  return [odd_pile, even_pile]\nend",
  "  pile = []\n  pile.push(n)\n  while pile.length > 0\n    pile.push(make_next_level(pile))\n\
    \  end\n  pile\nend", "    if n < 1\n        puts \"Error!, n must be positive\"\
    \n        return\n    levels = []\n    if n % 2 == 0\n        levels << n # odd\n\
    \        n -= 1 # n - 1\n    else # n % 2 == 1\n        levels << n # even\n \
    \       n -= 1 # n - 2\n    while n > 0 # while n > 0 means n is odd, even, odd\n\
    \        if n % 2 == 1 # odd\n            levels << n # n + 1\n            n -=\
    \ 1 # n - 1\n        else # even\n            levels << n # n + 2\n          \
    \  n -= 2 # n - 2\n    levels << n # last even\n    return levels\nend", "  return\
    \ n.times.map {|i| [n*(i+1)%2, n*(i+2)%2].max}\nend", "  # TODO: Your code here!\n\
    end", "    levels = []\n    if n % 2 == 1\n        levels << n\n        n += 1\n\
    \    levels << n\n    return levels.map { |l| make_a_pile(l) }\nend", "  piles\
    \ = [[]]\n  piles.push [n]\n  \n  for i in (1..n)\n    piles.push [i, i % 2]\n\
    \  end\n  \n  return piles\nend", "  return [n] + make_a_pile(n % 2 ? 1 : 2)\n\
    end", "  stones = n.even? ? n : (n.odd? ? 2*n : n)\n  pile = []\n  (1..stones).each\
    \ { |i| pile.push(i + 1) }\n  pile\nend\n</pre>", "  arr = []\n  for i in 0...n\n\
    \    if n & 1\n      arr.push(n - i)\n    else \n      arr.push(2*n - 2*i + 1)\n\
    \  end\n  arr\nend", "  level = []\n  for i in 0...n\n    level << i + (i&1)\n\
    \  end\n  level\nend", "  list = Array.new(n)\n  if n % 2 == 0\n    list[n/2].push(n/2)\n\
    \  else\n    list[n/2].push(n/2)\n    list[n/2+1].push(n/2)\n  end\n  list\nend",
  "  return n if n.even? or n.odd? else n.odd? ? 1 : 2 * n + 1\nend\n</cell>\n<code\
    \ language=conda-root-py>\nmake_a_pile(1)\n</cell>\n<code language=conda-root-py>\n\
    make_a_pile(2)\n</cell>\n<code language=conda-root-py>\nmake_a_pile(7)\n</cell>\n\
    <code language=conda-root-py>\nmake_a_pile(9)\n</cell>\n<code language=conda-root-py>",
  "  stones = Array.new(n)\n  for i in 0...n\n    stones[i] = if i % 2 == 0\n    \
    \  stones[i+1] = if n == 1 then 1 else stones[i+1] - 1\n      stones[i+1] = if\
    \ n % 2 == 1 then 1 else stones[i+1] - 1\n      stones[i+1]\n    else stones[i+1]\
    \ + 2\n  stones.map { |i| i + 1 }\nend", "  result = []\n  for i in 1..n do\n\
    \    if i.odd?\n      result[i] = i.next\n    else\n      result[i] = i.next\n\
    \    end\n  end\n  result\nend", "\tresult = []\n\tif n % 2 == 0 then result.push(n\
    \ % 2)\n\tfor i in 1..n-1 do\n\t\tif i%2 == 1 then result.push(i % 2)\n\t\telse\n\
    \t\t\tif n%2 == 0 then result.push(n-i)\n\t\t\telse result.push(n-(i/2))\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn result\nend", "  count = 0\n  for i in 0...n\n\
    \    count = count + 1 if i&1 \n    count = count + 1 if i%2\n  end\n  return\
    \ count\nend\nprint make_a_pile(8)", "  return [n] if n.even? && n.odd?\n  [n.odd?\
    \ ? make_a_pile(n-2) : n.even? ? make_a_pile(n-1) : 1]\nend", "    stones = []\n\
    \    if n > 0\n        stones += make_a_pile(n/2)\n        if n % 2 == 1\n   \
    \         stones << [n]\n        else\n            stones << [n/2]\n        end\n\
    \    end\n    stones\nend", "  pile = Array.new(n) do |i|\n    next i if i.odd?\
    \ || i.even?\n    next i + 1 if i.even?\n    i + 1\n  end\n  return pile\nend\n\
    make_a_pile(12)", "  result = []\n  for i in 0...n\n    result.push((n%2 == 0)\
    \ ? (n+i+1) : (2*i+1))\n    n /= 2\n  return result\nend", "  arr = [n]\n  i =\
    \  1\n  while i <= n do\n    if n%2 == 1 then\n      arr.push(2 * i)\n      n\
    \ /= 2\n      i += 1\n    else\n      arr.push(i)\n      n /= 2\n    end\n  end\n\
    \  return arr\nend\nmake_a_pile(5)", "  num_stones = 1\n  while n > 0\n    if\
    \ n % 2 == 0\n      num_stones += n\n      n /= 2\n    else\n      num_stones\
    \ += n\n      n /= 2\n    end\n  end\n  return num_stones\nend", "  i = 0\n  pile\
    \ = []\n  while i < n\n    if i % 2 == 0\n      pile.push( n )\n      i += 1\n\
    \    else # n % 2 == 1\n      pile.push( n * 2 )\n      i += 1\n  end\n  pile\n\
    end", "    pile = []\n    pile = [n] + pile\n    return pile\nend", "  result\
    \ = Array.new(2*(n+1)) { |i| i }\n  result[0] = n\n  result[1] = n\n  if n > 0\n\
    \    if n % 2 == 0\n      result[2] = (n+1) * 2\n    else\n      result[2] = n\n\
    \    end\n  else\n    result[2] = n\n  end\n  result\nend", "  list = []\n  i\
    \ = 0\n  while n > 0\n    list = [n] + list\n    if n % 2 == 0\n      n /= 2\n\
    \    else\n      n = 3*(n + 1)\n    end\n    i += 1\n  end\n  return list\nend",
  "  return [n] + make_a_pile(n % 2 == 0 ? n - 1 : n - 2)\nend", "  a = Array.new(n)\
    \ { |i| i }\n  a.size.times do |i|\n    a[i] = (a[i - 1] + a[i + (n % 2) == 0\
    \ + 1].floor)\n  end\nend", "  # Your code here\nend", "  if n == 0\n    return\
    \ []\n  if n / 2 == n\n    return [n - 1]\n  odds = make_a_pile(n / 2)\n  evens\
    \ = make_a_pile(n / 2 - 1)\n  return odds + evens\nend\n</cell>\n<code language=julia-1.0>\n\
    @assert make_a_pile(5) == [6, 5, 4]\n</cell>\n<code language=julia-1.0>\n@assert\
    \ make_a_pile(8) == [5, 4, 3, 2, 8, 7, 6, 5]\n</cell>\n<text>\nStrings", "  piles\
    \ = []\n  i = 0\n  while i < n\n    piles.push(i += 2) if n.odd? || n.even?\n\
    \    piles.push(i += 3) if n.odd? && n.even?\n    piles.push(i += 4) if n.even?\
    \ && n.odd?\n    piles.push(i += 5) if n.even? && !n.odd?\n  end\n  return piles\n\
    end", "  return n.even? ? [n, 2*n - 1] :\n    n.odd? ? [n, 2*n - 1] + make_a_pile(n-2)\
    \  :\n    make_a_pile(n-1)\nend", "  pile = Array.new(Integer(n).to_i)\n  (1..n).each\
    \ do |i|\n    pile[i] = pile[i - 1] + i.odd? ? 1 : 0\n  end\n  return pile\nend",
  "  if n<=1\n    return []\n  \n  piles = [make_a_pile(n//2)] \n  piles.last.push(n)",
  "  levels = []\n  levels << n\n  even = if n % 2 == 0\n    true\n  else\n    false\n\
    \  end\n  even? ? levels << n : levels << (n + (n & 1 ? 2 : 1))\n  levels.count\n\
    end", "  return [] if n < 0\n  even = n % 2 == 0\n  odd = n % 2 != 0\n  return\
    \ odd and [n + 1] or [n / 2] + make_a_pile(n//2)\nend", "    if n == 0\n     \
    \   0\n    elsif n & 1\n        n\n    else\n        n / 2\n    end\nend", " \
    \ count = [0]\n  while n > 0\n    if n % 2 == 0\n      n = (n / 2)\n    else\n\
    \      n = (n * 3) + 1\n    count << n\n  end\n  count\nend\n</cell>\n<cell>",
  "  arr = (1..n).to_a\n  arr.each do |i|\n    arr[i] = arr[i] + (n % 2 ? 2 : 1)\n\
    \    n = n / 2\n  end\n  arr.last\nend\n</pre>\n</td>\n</tr>\n</tbody>\n</table>\n\
    <pre>", "  # +++your code here+++\n  if n % 2 == 1\n    n += 1 if n > 0 else -1\n\
    \  end\n  levels = Array.new(n+1)\n  for i in 0..(n+1) \n    level = Array.new(n+1)\n\
    \    level[i] = i\n    levels.push level\n  end\n  levels.reverse!\n  levels.map\
    \ do |level|\n    level.map{|v| v + 1}\n  end\nend", "  if n < 0\n    return nil\n\
    \  else\n    stones = Array.new(1 + n) # +1 is because we start with stone 1,\
    \ not 0\n    stones.rotate!([n].max)\n    stones.rotate!([n].min)\n    stones.rotate!(n).flatten!\n\
    \    stones.each { |stone| stones.rotate!(stone) }\n    stones\n  end\nend", " \
    \   pile = Array.new(1..n)\n    pile[0] = n\n    pile[1] = (n**2) unless n&1",
  "    piles = Array.new(n)\n    piles[0] = make_a_level(n - 1)\n    piles.map {|i|\
    \ make_a_level(i, piles[i+1]) }\nend", "  levels = Array.new(n, nil)\n  for i\
    \ in 0...n\n    levels[i] = Array.new(\n      if i.odd?\n        (i + 1).odd?\n\
    \      else\n        (i + 1).even?\n      end, 0)\n  end\n  levels.flatten!\n\
    \  return levels.inject(:+)\nend\nmake_a_pile(5)\n  #=> [1, 1, 3, 3, 3, 5]\n</code>\n\
    The steps are as follows:", "    pile = []\n    i = 0\n    while i < n\n     \
    \   pile.push(i)\n        i += 2 if n % 2 == 0\n        i += 1 if n % 2 == 1\n\
    \    end\n    pile\nend", "  levels = [n]\n  while levels.length > 0\n    levels.unshift(n\
    \ % 2 == 0 ? n : 2 * n)\n    n = n / 2\n  end\n  levels\nend\n</pre>\n<div id=\"\
    postamble\" class=\"status\">\n<p class=\"author\">Author: Abhinav Rastogi N <br></p>\n\
    <p class=\"date\">Created: Sat Jan 11 22:21:38 -0500 2016<br></p>\n<p class=\"\
    validation\"><a href=\"http://validator.w3.org/check?uri=referer\">Validate</a></p>\n\
    </div>\n</body>\n</html>", "    if n == 1\n        return [n]\n    if n % 2 ==\
    \ 1\n        return make_a_pile(n/2) + [n]\n    stone, count = make_a_pile(n/2),\
    \ 0\n    while n % 2 != 0\n        stone = stone + [n]\n        count += 1\n \
    \       n = n/2\n    return stone\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n\
    \    </div>\n  </div>\n</body>", "  res = []\n  if n % 2 == 1\n    res.push(n)\n\
    \    n = (n - 1)\n  end\n  res.push(n / 2)\n  until n == 0\n  res.push(n)\n  n\
    \ = (n - 1)/2\n  until n == 0\n  res\nend", "  n = n.to_i\n  if n % 2 == 0 then\n\
    \    n = [n] * (n/2)\n  else\n    n = [2*n] * (n/2 + 1)\n  end\n  n\nend\n</pre>\n\
    </div>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell\
    \ rendered\"><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\"\
    >\n<div class=\"text_cell_render border-box-sizing rendered_html\">\n<h2 id=\"\
    Exercise-22\">Exercise 22<a class=\"anchor-link\" href=\"#Exercise-22\">&#182;</a></h2><h3\
    \ id=\"Question:-What-is-the-smallest-and-the-largest-numbers-that-can-be-produced-from-a-n-stones-pile-and-be-made-from-the-pile-of-another-n\"\
    >Question: What is the smallest and the largest numbers that can be produced from\
    \ a n stones pile, and be made from the pile of another n<a class=\"anchor-link\"\
    \ href=\"#Question:-What-is-the-smallest-and-the-largest-numbers-that-can-be-produced-from-a-n-stones-pile-and-be-made-from-the-pile-of-another-n\"\
    >&#182;</a></h3><p>You will write a program to find the smallest and the largest\
    \ numbers that can be produced from a n stones pile, and be made from the pile\
    \ of another n.</p>\n<p>In other words, you will be given the number of stones\
    \ in one pile, and the size of another pile. You will have to make the smallest\
    \ possible number of new piles from your original pile, and the largest possible\
    \ number of new piles from the other pile.</p>\n<h4 id=\"Answer:-\">Answer:</h4>\n\
    <p>The smallest number of new piles is 1 and the largest is n - 1.</p>\n<ul>\n\
    <li>We can create as many new piles as needed using the following formula for\
    \ the number of stones in the new piles:</li>\n</ul>\n<p>$$ n_{new}=n_{original}+(n-1)$$</p>\n\
    <ul>\n<li>To make the largest number of new piles, we subtract the original pile\
    \ size from n - 1.</li>\n</ul>\n<p>$$ n_{new}=n_{original}+(n-2)$$</p>\n<ul>\n\
    <li>To make the smallest number of new piles, we subtract 1 from the original\
    \ pile size.</li>\n</ul>\n<p>$$ n_{new}=n_{original}+1$$</p>", "  # Your code\
    \ here\nend\n</cell>\n<cell>", "  res = []\n  num = 0\n  while n > 0\n    num\
    \ += 1\n    res << num\n    if n % 2\n      n /= 2\n    else\n      n -= 1\n \
    \   end\n  end\n  res\nend", "  total = []\n  num = 1\n  while num <=n\n    total\
    \ << num\n    num = num + 1 if n % 2 == 1\n    num = num + 1 if n % 2 == 0\n \
    \ end\n  return total\nend", "  result = Array.new(n) do\n    i = n\n    while\
    \ i\n      i = (i + i).odd?\n      i += 2\n    end\n  end\n  result\nend\n</pre>",
  "  a = [0] * (n + 1)\n  a[1] = n\n  a[2] = n + 1 - (n % 2)\n  a[n] = n\n  return\
    \ a\nend", "    # Write your code here.\n    if n % 2 == 0:\n        return [n\
    \ / 2]\n    else:\n        return [n / 2, n / 2 + 1]\nprint(make_a_pile(5))\n\
    print(make_a_pile(3))\nprint(make_a_pile(8))\n</cell>\n<text>\nThe next function\
    \ takes a positive integer n, then returns (n+1)th smallest number in the array.",
  "  result = [n] unless n\n  n.times do\n    next if n.odd?\n    next if n.even?\n\
    \    result.unshift(n.next)\n  end\n  result\nend", "    # write your code here\n\
    \    pile = []\n    if n % 2 == 0:\n        for i in range(1, n, 2):\n       \
    \     pile.append(i)\n        pile.append(n / 2)\n        pile.append(n / 2)\n\
    \    else:\n        for i in range(1, n, 2):\n            pile.append(i)\n   \
    \     pile.append(n / 2)\n    return pile\n</cell>\n<cell>", "    if n == 0 then\
    \ []\n    else if n == 1 then [1]\n    else make_a_pile(n % 2 == 0 ? n - 1 : n)\
    \ + [n % 2 == 0 ? 1 : 2]\n    end\nend\n</cell>\n<code language=julia-1.6>", " \
    \ result = []\n  num = 1\n  while n > 0\n    if n % 2 == 1\n      result.push\
    \ num\n      num+=1\n    end\n    n /= 2\n  end\n  result\nend", "  pile = [n]\n\
    \  while pile[-1] > 0\n    pile = make_a_pile_aux(pile, n)\n  end\n  pile\nend",
  "  pile = []\n  pile.push(n) # levels start at 1\n  while pile.length > 0\n    pile.push(pile.last.even?\
    \ ? pile.last.next - 2 : pile.last.next - 1)\n  end\n  pile\nend\n</pre>", " \
    \ result = []\n  for i in (0..n).step(2) { |i| result.push(i.even? ? i : i+1)\
    \ }\n  result\nend\n</pre>\n</div>\n</div>\n</div>\n    </div>\n  </div>\n</body>",
  "    # Your code here\n    pile = []\n    for i in range(n):\n        if n % 2 ==\
    \ 1:\n            pile.append(n+1)\n        else:\n            pile.append(n+2)\n\
    \    return pile", "  pile = [n]\n  \n  # If the number is even then add an extra\
    \ stone\n  if n % 2 == 0\n    pile.push n + 1\n  \n  # Now the number is odd\n\
    \  else\n    pile.push n\n    \n    pile.push n - 1 if n % 2 == 1\n    \n    pile.push\
    \ n + 1 unless n % 2 == 1\n    \n  end\n  \n  return pile\nend", "  lst = []\n\
    \  for i in (1..n).step(2) do\n    lst[i] = n\n  end\n  lst\nend\nputs make_a_pile(3)",
  "  piles = Array.new(n)\n  i = 0\n  while i < n\n    piles[i] = i + 1\n    i = i+2\n\
    \  end\n  return piles\nend", "  res = []\n  make_pile_aux(n, res)\n  res.reverse!\n\
    \  return res\nend", "  list = []\n  if n % 2 != 0\n    list << [n]\n  elsif n\
    \ == 1\n    list << [1]\n  elsif n == 2\n    list << [1, 2]\n  elsif n % 3 ==\
    \ 0\n    list << [n, n-1, n-2]\n  end\n  list\nend", "  i = 0\n  levels = []\n\
    \  while n > 0\n    i += 1\n    next if n % 2 == 0\n    next if n % 2 == 1\n \
    \   n /= 2\n    levels.push(:odd => i, :even => i)\n  end\n  levels.each {|k,v|\
    \ v}\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2\
    \ id=\"_variables\">Variables</h2>\n<div class=\"sectionbody\">\n<div class=\"\
    paragraph\">\n<p>All variables are immutable in Ruby. All values assigned to a\
    \ variable\nare automatically frozen for immutable objects, otherwise the variable\
    \ is\ntruly a variable.</p>\n</div>\n<div class=\"paragraph\">\n<p>Variables always\
    \ have to be declared before they are used.</p>\n</div>\n</div>\n</div>\n<div\
    \ class=\"sect1\">\n<h2 id=\"_global_variables\">Global variables</h2>\n<div class=\"\
    sectionbody\">\n<div class=\"paragraph\">\n<p>Global variables do not have to\
    \ be declared before they are used, and\nare often declared at the top of a source\
    \ file.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_lexical_scope\"\
    >Lexical scope</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n\
    <p>Variables declared inside a method or block are local to that\nmethod, while\
    \ variables are declared globally.</p>\n</div>\n<div class=\"paragraph\">\n<p>This\
    \ means, for example that if you had two methods both defining an\ninstance variable,\
    \ you could not refer to the instance variable of one\ninside the other. Instead,\
    \ you would need to qualify the variable name with\nthe name of the method you\
    \ are referring to with <code>self.</code>.</p>\n</div>\n</div>\n</div>\n<div\
    \ class=\"sect1\">\n<h2 id=\"_exceptions\">Exceptions</h2>\n<div class=\"sectionbody\"\
    >\n<div class=\"paragraph\">\n<p>Unlike languages like C, in Ruby exceptions are\
    \ not actually exceptional\ncases, they are just an error that has happened.</p>\n\
    </div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_exceptional_conditions\"\
    >Exceptional conditions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\"\
    >\n<p>A condition that has caused an exception in Ruby is called an\n<em>exceptional\
    \ condition</em>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Exceptional conditions\
    \ are checked by the interpreter if they are raised\nby the code, and are typically\
    \ used to handle exceptional cases.</p>\n</div>\n<div class=\"paragraph\">\n<p>An\
    \ exception can be raised by the code only by:</p>\n</div>\n<div class=\"ulist\"\
    >\n<ul>\n<li>\n<p>Using the <code>raise</code> keyword.</p>\n</li>\n<li>\n<p>Throwing\
    \ an exception in the code.</p>\n</li>\n<li>\n<p>Calling a method which throws\
    \ an exception.</p>\n</li>\n</ul>\n", "  if n<=1\n    return []\n  res = []\n\
    \  for i in 1..n do\n    if n%i==0\n      res.push(n/i)\n    else\n      res.push(3*i-1)\n\
    \    end\n  end\n  res\nend", "  levels = []\n  while n\n    levels.push n % 2\
    \ == 0 ? n : n+1\n    n /= 2\n  end\n  levels\nend\n</cell>\n<cell>", "  return\
    \ [] if n == 0\n  return [n] if n % 2 == 1\n  odd_pile = make_a_pile(n / 2)\n\
    \  even_pile = [n] if n % 2 == 0\n  odd_pile.concat even_pile\n  return odd_pile\n\
    end", "  stones = Array.new(n / 2) # create an array to hold the number of stones\
    \ in each level\n  stones[n & 1] += 1 # if the number is odd, then put an odd\
    \ number of stones in that level\n  stones[n % 2] -= 1 # if the number is even,\
    \ then put an even number of stones in that level\n  return stones\nend\nputs\
    \ make_a_pile(5)\nputs make_a_pile(8)", "  return if n == 1\n  return if n % 2\
    \ == 0\n  return if n % 2 == 1\n  make_a_pile(n-1)\n  make_a_pile(n-1)\n  make_a_pile(n-1)\n\
    \  make_a_pile(n-1)\nend\n</pre>", "  count = Array.new(n)\n  count[0] = 1\n \
    \ for i in 1..n\n    if i.odd?\n      count[i] = count[i-1] + 1\n    else\n  \
    \    count[i] = count[i-1] + 2\n    end\n  end\n  count\nend", "  levels = [[]]\n\
    \  count = 0\n  while n > 0\n    if n.odd?\n      levels << n.odd\n      count\
    \ += 1\n      n -= n.odd\n    elsif n.even?\n      levels << n.even\n      count\
    \ += 1\n      n -= n.even\n    else\n      levels << n\n      count += 1\n   \
    \   n -= 1\n  end\n  levels.flatten!\n  return levels\nend", "  return n.times.map\
    \ {|i| i % 2 == 0 ? (i + 1) : i}\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n\
    <h2 id=\"ruby-leetcode-9\">Ruby: Leetcode 9</h2>\n<p><a href=\"https://leetcode.com/problems/poker-hand-evaluator/\"\
    >Leetcode 9</a>:</p>\n<pre data-filter-output=\"(out)\" class=\"runnable-example\"\
    \ rel=\"nofollow\">", "  if n <= 0\n    return []\n  if n == 1\n    return [n]\n\
    \  if n % 2 == 0\n    return make_a_pile(n / 2) + [n]\n  else\n    return make_a_pile(n\
    \ / 2) + make_a_pile(n / 2)\nend\n</cell>\n<code language=julia-1.0>", "  if n\
    \ == 0\n    [1]\n  else\n    [n % 2 == 0 ? n : 2 * n + 1, n % 2 == 0 ? n - 1 :\
    \ n - 1]\n  end\nend", "  count = Array.new\n  count << n\n  loop do\n    count\
    \ << n % 2 == 0 ? n : n / 2\n    n /= 2\n  end\n  count\nend", "    # Your code\
    \ here\n    return n\nend", "  if n == 1\n    return [1]\n  \n  odd = n+1\n  even\
    \ = odd.next\n  odd.next = 2\n  \n  res = []\n  while odd != 1\n    res << even\n\
    \    odd += even\n    even = odd.next\n    odd.next = 1\n  end\n  \n  res\nend",
  "  arr = []\n  i = 0\n  loop do\n    break i if n == 0\n    arr[i] = n % 2 ? n /\
    \ 2 : n / 2 + 1\n    n -= 1\n    i += 1\n  end\n  arr\nend", "  return [] if n.zero?\n\
    \  levels = []\n  levels << [] if n.odd?\n  levels << [n - 1] if n.even?\n  levels\
    \ << [n - 2] if n.odd? && n.even?\n  levels << [n - 3] if n.odd? && n.even? &&\
    \ n.odd?\n  levels << [n - 4] if n.odd? && n.even? && n.even? && n.odd?\n  levels\
    \ << [n - 5] if n.odd? && n.even? && n.even? && n.even? && n.odd?\n  levels <<\
    \ [n - 6] if n.odd? && n.even? && n.even? && n.even? && n.even? && n.odd?\n  levels\
    \ << [n - 7] if n.odd? && n.even? && n.even? && n.even? && n.even? && n.even?\
    \ && n.odd?\n  levels << [n - 8] if n.odd? && n.even? && n.even? && n.even? &&\
    \ n.even? && n.even? && n.even? && n.odd?\n  levels << [n - 9] if n.odd? && n.even?\
    \ && n.even? && n.even? && n.even? && n.even? && n.even? && n.even? && n.odd?\n\
    \  levels << [n - 10] if n.odd? && n.even? && n.even? && n.even? && n.even? &&\
    \ n.even? && n.even? && n.even? && n.even? && n.odd?\n  levels << [n - 11] if\
    \ n.odd? && n.even? && n.even? && n.even? && n.even? && n.even? && n.even? &&\
    \ n.even? && n.even? && n.even? && n.odd?\n  levels << [n - 12] if n.odd? && n.even?\
    \ && n.even? && n.even? && n.even? && n.even? && n.even? && n.even? && n.even?\
    \ && n.even? && n.even? && n.odd?\n  levels << [n - 13] if n.odd? && n.even? &&\
    \ n.even? && n.even? && n.even? && n.even? && n.even? && n.even? && n.even? &&\
    \ n.even? && n.even? && n.even? && n.odd?\n  levels << [n - 14] if n.odd? && n.even?\
    \ && n.even? && n.even? ", "    stones = []\n    odd_count = 1\n    even_count\
    \ = 1\n    for _ in 0...n do\n        if n % 2 == 0 then\n            even_count\
    \ = even_count + 1\n        else\n            odd_count = odd_count + 1\n    \
    \    end\n        stones.push even_count * odd_count\n        n = n / 2\n    end\n\
    \    stones.push even_count * odd_count\n    return stones\nend", "  return Array.new(n)\
    \ do |i|\n    next i if i % 2 == 0\n    next i if i % 3 == 0\n    return i\n \
    \ end\nend", "  level = [n]\n  num = 1\n  while num > 0\n    num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    level.push num\n  end\n  level\nend", "  list\
    \ = []\n  i = 0\n  while i <= n\n    list.push i\n    i += 2\n  end\n  return\
    \ list\nend", "  level = 1\n  stones = [n] + [(n/2).floor] * (n/2)\n  while level\
    \ < n\n    stones.shift\n    level = (level + 1).floor\n  end\n  stones\nend",
  "  # Your code here\nend", "  # n is a positive integer number greater than 0.\n\
    \  # Return an n element list where each element represents the number of stones.\n\
    \  if n == 0\n    return []\n  result = []\n  while n != 0\n    if n % 2 == 0\n\
    \      n /= 2\n      result.push n\n    else\n      n = ((n - 1) / 2) * 2\n  \
    \    result.push n\n  end\n  result\nend", "  pile = Array.new(n) { Array.new(n)\
    \ }\n  pile[0][0] = 1\n  for i in 1..n\n    pile[i-1][1] = pile[i-1][0] + (i&1)*2\n\
    \    pile[i-1][2] = pile[i-1][1] + (i&2)*2\n  end\n  pile\nend", "  result = []\n\
    \  while n > 0\n    result[n % 2] += 1\n    n /= 2\n  end\n  return result\nend\n\
    </pre>", "    arr = []\n    i = 0\n    while i < n\n        arr << i + 1\n   \
    \     i = i + 1\n        if i % 2 == 1\n            arr.delete_at(i-1)\n     \
    \       i = 0\n        i += 1\n    return arr\nend\n</cell>\n<code language=julia-1.0>\n\
    make_a_pile(5)\n</cell>\n<code language=julia-1.0>\nfunction make_a_pile(n)\n\
    \    arr = []\n    i = 0\n    while i < n\n        arr << i + 1\n        i = i\
    \ + 1\n        if i % 2 == 1\n            arr.delete_at(i-1)\n            i =\
    \ 0\n        i += 1\n    end\n    return arr\nend\n</cell>\n<code language=julia-1.0>\n\
    function make_a_pile(n)\n    arr = Array{Int}(n)\n    i = 0\n    while i < n\n\
    \        arr[i] = i + 1\n        i = i + 1\n        if i % 2 == 1\n          \
    \  arr.delete_at(i-1)\n            i = 0\n        end\n    end\n    return arr\n\
    end\n</cell>\n<code language=julia-1.0>\nmake_a_pile(5)\n</cell>\n<code language=julia-1.0>\n\
    function make_a_pile(n)\n    arr = Array{Int}(n)\n    i = 0\n    while i < n\n\
    \        arr[i] = i + 1\n        i = i + 1\n        if i % 2 == 1\n          \
    \  arr.delete_at(i-1)\n            i = 0\n        end\n    end\n    return arr\n\
    end\n</cell>\n<code language=julia-1.0>\nmake_a_pile(5)\n</cell>\n<code language=julia-1.0>\n\
    function make_a_pile(n)\n    arr = Array{Int}(n)\n    i = 0\n    while i < n\n\
    \        arr[i] = i + 1\n        i = i + 1\n        if i % 2 == 1\n          \
    \  arr.delete_at(i-1)\n            i = 0\n        end\n    end\n    return arr\n\
    end\n</cell>\n<code language=julia-1.0>\nmake_a_pile(5)\n</cell>\n<code language=julia-1.0>\n\
    function make_a_pile(n)\n    arr = Array{Int}(n)\n    i = 0\n    while i < n\n\
    \        arr[i] = i + 1\n        i = i + 1\n        if i % 2 == 1\n          \
    \  arr.delete_at(i-1)\n            i = 0\n        end\n    end\n    return arr\n\
    end\n</cell>\n<code language=julia-1.0>\nmake_a_pile(5)\n</cell>\n<code language=julia-1.0>\n\
    function make_a_pile(n)\n    arr = Array{Int}(n)\n    i = 0\n    while i < n\n\
    \        arr[i] = i + 1\n        i = i + 1\n        if i % 2 == 1\n          \
    \  arr.delete_at(i-1)\n            i = 0\n        end\n    end\n    return arr\n\
    end\n</cell>\n<code language=julia-1.0>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
