name: HumanEval_93_encode
language: rb
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\ndef encode(message)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n\
  \    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"\
  ))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"\
  ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"\
  This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"\
  I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"
completions: ["  message.downcase!\n  message.gsub(/[aeiou]/) { |w| w.succ }\n  message.tr!('aeiouAEIOU',\
    \ 'AEIOUaeiou')\n  message\nend", "  # Write your code here.\n  \nencode(\"aasda\"\
    )\nencode(\"Bbbbbb\")\nencode(\"CcccCcC\")\nencode(\"AbbbbcAAbbCcc\")\nencode(\"\
    aaaBBbCCC\")\nencode(\"aaaBbccC\")\nencode(\"aBbccC\")\nencode(\"aaaBBbCCCddd\"\
    )\nencode(\"AAaBBbCCC\")\nencode(\"AAbBBcCCC\")\nencode(\"aAaBcCCC\")\nencode(\"\
    aaaaBbCCC\")\nencode(\"aaaaBbCCCddd\")\nencode(\"AAAaBbCCC\")\nencode(\"AaAbBcCCC\"\
    )\nencode(\"aAaBcCCCddd\")\nencode(\"aaaaBbCCCddd\")\nencode(\"aaaaBbCCCdddd\"\
    )\nencode(\"AaAaBcCCCdddd\")\nencode(\"aAaBcCCCdddd\")\nencode(\"aAAaBcCCCdddd\"\
    )\nencode(\"AaAaBcCCCdddd\")\nencode(\"AaAaBBcCCCdddd\")\nencode(\"AaAaBBcCCCddd\"\
    )\nencode(\"AaAaBbccCCCdddd\")\nencode(\"AaAaBbccCCCddd\")\nencode(\"AaAaBbccCCC\"\
    )\nencode(\"AaAaBbccCCCd\")\nencode(\"AaAaBbccCCCc\")\nencode(\"AaAaBbccCCCc\"\
    )\nencode(\"AaAaBBbccCCCc\")\nencode(\"AaAaBBbccCCCd\")\nencode(\"AaAaBBbccCCCd\"\
    )\nencode(\"AaAaBBbccCCC\")\nencode(\"AaAaBBbccCCC\")\nencode(\"AaAaBBbccCCCc\"\
    )\nencode(\"AaAaBBbccCCCc\")\nencode(\"AaAaBBbccCCC\")\nencode(\"AaAaBBbccCCCc\"\
    )\nencode(\"AaAaBBbccCCCc\")\nencode(\"AaAaBBbccCCCd\")\nencode(\"AaAaBBbccCCCd\"\
    )\nencode(\"AaAaBBbccCCCd\")\nencode(\"", "    puts \"The encoded message is:\
    \ \" + \n      message.gsub(/a/){|a| a.upcase + a.downcase } + \n      message.gsub(/e/){|e|\
    \ e.upcase + e.downcase } + \n      message.gsub(/i/){|i| i.upcase + i.downcase\
    \ } + \n      message.gsub(/o/){|o| o.upcase + o.downcase } + \n      message.gsub(/u/){|u|\
    \ u.upcase + u.downcase }\nend", "    encoded = message.downcase\n    vowels =\
    \ ['a','e','i','o','u']\n    translated = {}\n    \n    translated[0] = translated[1]\
    \ = translated[2] = message\n    \n    \n    \n    for letter in message.split(//)\n\
    \        translated[0] = translated[1]\n        translated[1] = translated[2]\n\
    \        translated[2] = letter\n    \n    return translated.join(//)\n    \n\
    \    # Replace all vowels in message with the letter that appears 2 \n    # places\
    \ ahead of those vowels in the english alphabet. \n    # Assume only letters.\
    \ \n    # Examples:\n    \n    #encode('abC')\n    \nend", "    # Write your code\
    \ below\n    message = message.lower()\n    \n    # Convert all letters to their\
    \ english equivalent \n    letters = {\n        'a': '@', 'e': '.', 'i': '%',\
    \ 'o': '|', 'u': '$', \n        't': '~', 'n': '!', 's': '^', 'h': '#', 'd': '$',\
    \ \n        'f': '&', 'g': '+', 'z': '*', 'x': '&', 'y': '^', \n        'r': '`',\
    \ 'p': '*', 'm': '@', 'q': '@', 'z': '-'}\n    \n    # Iterate through each letter\
    \ in the message\n    for i in message:\n        # Replace each letter in the\
    \ message with the letter at \n        # the appropriate position on the english\
    \ alphabet\n        message = message.replace(i, '')\n        \n        # Replace\
    \ all vowels in the message with the letter \n        # that appears two places\
    \ ahead of the vowel in the english \n        # alphabet.\n        message = message.replace(letters[i],\
    \ '')\n        \n        # Add the letter that appears two places ahead of the\
    \ vowel\n        # to the message string\n        message += letters[i]\n    \
    \    \n        # Return the message string.\n    return message\n</cell>\n<text>\n\
    After your have encoded the message in the cell below, use the assert statement\
    \ below to verify that your code functions correctly.", end, "  new_message =\
    \ message\n  new_message.downcase!\n  new_message.gsub!(/[aeiou]/) do |letter|\n\
    \    vowel_letter = English.chars.find { |c| \n      (c[1] == letter.downcase)\
    \ && (c[0] >= 'a' && c[0] <= 'z')\n    } \n    vowel_letter\n  end\n  new_message\n\
    end", "  letters = message.split(//)\n  encoded = \"\"\n  for letter in letters\
    \ \n    encoded = encoded + letter.upcase + letter.downcase \n    return encoded\n\
    end", "    letters_2af = []\n    vowels_2af = ['a','e','i','o','u']\n    \n  \
    \  # Write your code here\n    letters_2af = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    vowels_2af = ['a','e','i','o','u']\n    \n    \n    letters_2af = [x for\
    \ x in message]\n    vowels_2af = [x for x in message]\n    \n    letters_2af\
    \ = [letters_2af.pop(letters_2af.index(letter)) for letter in letters_2af]\n \
    \   vowels_2af = [vowels_2af.pop(vowels_2af.index(vowel)) for vowel in vowels_2af]\n\
    \    \n    letters_2af = [x for x in message]\n    vowels_2af = [x for x in message]\n\
    \    \n    \n    letters_2af = [letters_2af.pop(letters_2af.index(letter)) for\
    \ letter in letters_2af]\n    vowels_2af = [vowels_2af.pop(vowels_2af.index(vowel))\
    \ for vowel in vowels_2af]\n    \n    letters_2af = [x for x in message]\n   \
    \ vowels_2af = [x for x in message]\n    \n    \n    letters_2af = [letters_2af.pop(letters_2af.index(letter))\
    \ for letter in letters_2af]\n    vowels_2af = [vowels_2af.pop(vowels_2af.index(vowel))\
    \ for vowel in vowels_2af]\n    \n    letters_2af = [x for x in message]\n   \
    \ vowels_2af = [x for x in message]\n    \n    \n    letters_2af = [letters_2af.pop(letters_2af.index(letter))\
    \ for letter in letters_2af]\n    vowels_2af = [vowels_2af.pop(vowels_2af.index(vowel))\
    \ for vowel in vowels_2af]\n    \n    letters_2af = [x for x in message]\n   \
    \ vowels_2af = [x for x in message]\n    \n    \n    letters_2af = [letters_2af.pop(letters_2af.index(letter))\
    \ for letter in letters_2af]\n    vowels_2af = [vowels_2af.pop(vowels_2af.index(vowel))\
    \ for vowel in vowels_2af]\n    \n    letters_", end, "    message = message.downcase\n\
    \    message.gsub!('a', 'z')\n    message.gsub!('o', 'a')\n    message.gsub!('u',\
    \ 'a')\n    message.gsub!('i', 'y')\n    message.gsub!('y', 'a')\n    message.gsub!('e',\
    \ 'i')\n    message.gsub!('c', 'o')\n    message.gsub!('n', 'o')\n    message.gsub!('h',\
    \ 'a')\n    message.gsub!('d', 'i')\n    message.gsub!('s', 'o')\n    message.gsub!('r',\
    \ 'e')\n    message.gsub!('d', 's')\n    message.gsub!('r', 'a')\n    message.gsub!('s',\
    \ 'e')\n    message.gsub!('t', 'e')\n    message.gsub!('l', 'i')\n    message.gsub!('s',\
    \ 'a')\n    message.gsub!('n', 'o')\n    message.gsub!('d', 'a')\n    message.gsub!('t',\
    \ 'a')\n    message.gsub!('a', 'e')\n    message.gsub!('l', 'y')\n    message.gsub!('n',\
    \ 'y')\n    message.gsub!('h', 'o')\n    message.gsub!('t', 'i')\n    message.gsub!('n',\
    \ 'o')\n    message.gsub!('y', 'e')\n    message.gsub!('a', 'i')\n    message.gsub!('r',\
    \ 'e')\n    message.gsub!('n', 'e')\n    message.gsub!('y', 'a')\n    message.gsub!('e',\
    \ 'o')\n    message.gsub!('a', 'o')\n    message.gsub!('n', 'a')\n    message.gsub!('o',\
    \ 'y')\n    message.gsub!('a', 'e')\n    message.gsub!('n', 'o')\n    message.gsub!('y',\
    \ 'a')\n    message.gsub!('r', 'y')\n    message.gsub!('a', 'o')\n    message.gsub!('r',\
    \ 'o')\n    message.gsub!('e', 'o')\n    message.gsub!('e', 'y')\n    message.gsub!('e',\
    \ 'a')\n    message.gsub!('n', 'a')\n    message.gsub!('a', 'e')\n    message.gsub!('o',\
    \ 'o')\n    message.gsub!('o', 'a')\n    message.gsub!('o', 'u')\n    message.gsub!('i',\
    \ 'a')\n    message.g", "  # Return the encoded message. \nend\n</cell>\n<code\
    \ language=julia-1.3>", "   result = ''\n   for char in message\n       if char\
    \ == 'a'\n          result += \"b\"\n       if char == 'e'\n          result +=\
    \ \"f\"\n       if char == 'i'\n          result += \"g\"\n       if char == 'o'\n\
    \          result += \"h\"\n       if char == 'u'\n          result += \"j\"\n\
    \       if char == 'A'\n          result += \"B\"\n       if char == 'E'\n   \
    \       result += \"F\"\n       if char == 'I'\n          result += \"G\"\n  \
    \     if char == 'O'\n          result += \"H\"\n       if char == 'U'\n     \
    \     result += \"J\"\n   return result", "    message = message.upcase\n    vowels\
    \ = %w(a e i o u)\n    vowel_map = {}\n    letters_map = {}\n    letters = message.split(//).collect\
    \ { |letter| letter[/[a-z]/] }\n    letters.each do |letter|\n      letter = letter.to_s.downcase\n\
    \      letter = letter.gsub(vowels, \"_\")\n      letter = letter.gsub(/[_]/,\
    \ letters[vowel_map[letter]])\n      letters_map[letter] = letter\n    end\n \
    \   letters = letters_map.values.join(\"\")\n    message = message.gsub(vowels,\
    \ letters)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI'm pretty sure the question\
    \ is asking for an explanation rather than code. I understand that an explanation\
    \ would not help the OP understand the logic, but a code sample might help.\n\
    <|/ c |>\n<| c |>\nI agree. This sample was just to show how to implement the\
    \ encode method - I did not want to give an actual answer\n<|/ c |>\n<| a |>\n\
    This is my solution:\n<code>", "  new_message = message.split('')\n  new_message\
    \ = new_message.map{|l| l.downcase}\n  new_message = new_message.map{|l| l.split('')}\n\
    \  new_message = new_message.map{|l| l.map{|w| w.reverse.split(/(.)\\1{2}/)[0].to_sym}}\n\
    \  new_message = new_message.join('')\n  new_message = new_message.split('').map{|l|\
    \ l.upcase}\n  return new_message\nend\n</code>\nI hope this helps. I'm happy\
    \ to clarify or give suggestions\n<|/ a tags=ruby,algorithm |>\n<| c |>\nThanks\
    \ for the reply! I do have to do some research and study your answers to make\
    \ sure I understand how this works. I didn't know map existed and that it's designed\
    \ to do things like this. I thought that map applied a block to every element\
    \ of an array and returned the modified array. It looks like you defined a block\
    \ to split the words. Would you mind telling me what each line does? I understand\
    \ everything except the block definition.\n<|/ c |>\n<| c |>\nOkay, I understand\
    \ what is happening now. I'll study it more and try to understand how it works.\
    \ I appreciate it.\n<|/ c |>\n<| c |>\nThe first map is used to split each letter\
    \ into individual words, and the second map is used to reverse each word and split\
    \ it at the first two occurrences of the same letter (the one that appears 2 places\
    \ ahead of the original letter).\n<|/ c |>\n<| c |>\nThe second map is used to\
    \ convert all letters to upper case. The first map is used to split each word\
    \ into individual letters, and then the second map is used to reverse each letter\
    \ and convert it back to uppercase.\n<|/ c |>\n<| c |>\nThanks! I understand the\
    \ first 2 maps, but what do you mean by the second one? I couldn't find where\
    \ it splits the word into letters.\n<|/ c |>\n<| a |>\nHere's a way to do it with\
    \ each_char and each_cons methods :\n<code>", "    vowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n    charsA = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"]\n    charsB = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    charsC = [\"\
    a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"]\n    charsF = [\"a\", \"b\", \"c\", \"d\", \"e\", \"\
    f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    charsG\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n    charsP = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \   charsS = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    charsT = [\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]\n    charsV = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"\
    i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    charsY = [\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"]\n    charsZ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    vowels = \"AEIOUaeiou\"", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    encoded = \"\"\n    for letter in message\n        pos = alphabet.index(letter.upcase)\
    \ + 1\n        encoded << alphabet.charAt[pos]\n    return encoded\n    ", " \
    \ message.upcase.gsub(/[AEIOUYaeiouy]/) { |x| x[/[aeiouy]/].upcase }\nend", " \
    \   puts message\nend", "    message.gsub!(/[a-z]/){|letter| letter.upcase }\n\
    \    message.gsub!(/[aeiou]/){|vowel| vowel.succ }\n    message.to_i\nend", " \
    \   \n    encoded_message = ''\n    \n    for letter in message.lower()\n    \
    \    \n        letter_index = english_letter_s.index(letter.upper())\n       \
    \ \n        if letter_index >= 2:\n            \n            encoded_letter =\
    \  english_letter_s[letter_index-3] + english_letter_s[letter_index-2] + english_letter_s[letter_index-1]\n\
    \            \n        elif letter_index == 1 and letter_index != 0:\n       \
    \     \n            encoded_letter = english_letter_s[letter_index-2] + english_letter_s[letter_index-1]\n\
    \            \n        else:\n            \n            encoded_letter = letter.upper()\n\
    \        \n        encoded_message += encoded_letter\n        \n    return encoded_message",
  '    encoded_message = ""', "  str = ''\n  vowels = (\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"y\")\n  for letter in message\n    puts \"#{letter}\"\n    puts vowels.each\
    \ {|vowel| puts \"#{vowel}\"}\n    puts letter\n  end\nend", "  new_message =\
    \ message.gsub(/a/, \"A\").gsub(/e/, \"E\").gsub(/i/g, \"I\").gsub(/o/, \"O\"\
    ).gsub(/u/, \"U\").gsub(/y/g, \"Y\")\n  new_message\nend\n</cell>\n<cell>", " \
    \   vowels = \"aeiouAEIOU\"\n    letters = \"abcdefghijklmnopqrstuvwxyz\"\n  \
    \  newmessage = message\n    replaced_string = \"\"\n    count = 0\n    for letter\
    \ in newmessage:\n        if letter in letters:\n            if letter in vowels:\n\
    \                replaced_string += letters[vowels.index(letter)+1]\n        \
    \    else:\n                replaced_string += letter\n        else:\n       \
    \     count += 1\n            replaced_string += letter\n        if count == 2:\n\
    \            replaced_string += letter\n            count = 0\n    return replaced_string",
  "    message.gsub!( /[a-z]/ ) do\n        letter = case $0\n            when \"\
    a\"; \"g\"\n            when \"b\"; \"x\"\n            when \"c\"; \"q\"\n   \
    \         when \"d\"; \"y\"\n            when \"e\"; \"v\"\n            when \"\
    f\"; \"z\"\n            else \"A\"\n        end\n        letter\n    end\n   \
    \ message.gsub!( /[aeiou]/ ) do\n        letter = case $0\n            when \"\
    a\"; \"A\"\n            when \"b\"; \"B\"\n            when \"c\"; \"C\"\n   \
    \         when \"d\"; \"D\"\n            when \"e\"; \"E\"\n            when \"\
    f\"; \"F\"\n            when \"g\"; \"G\"\n            when \"h\"; \"H\"\n   \
    \         when \"i\"; \"I\"\n            when \"j\"; \"J\"\n            when \"\
    k\"; \"K\"\n            when \"l\"; \"L\"\n            when \"m\"; \"M\"\n   \
    \         when \"n\"; \"N\"\n            when \"o\"; \"O\"\n            when \"\
    p\"; \"P\"\n            when \"q\"; \"Q\"\n            when \"r\"; \"R\"\n   \
    \         when \"s\"; \"S\"\n            when \"t\"; \"T\"\n            when \"\
    u\"; \"U\"\n            when \"v\"; \"V\"\n            when \"w\"; \"W\"\n   \
    \         when \"x\"; \"X\"\n            when \"y\"; \"Y\"\n            when \"\
    z\"; \"Z\"\n            else \"a\"\n        end\n        letter\n    end\n   \
    \ message.tr!( \"aeiou\", \"AEIOU\" )\n    puts message\nend", '    return message',
  "  message.gsub!(/./) { |character| character.upcase }\n  message.gsub!(/a/, 'A')\n\
    \  message.gsub!(/e/, 'E')\n  message.gsub!(/i/, 'I')\n  message.gsub!(/o/, 'O')\n\
    \  message.gsub!(/u/, 'U')\n  message.gsub!(/y/, 'Y')\n  message\nend", "  result\
    \ = \"\"\n  message.downcase!\n  message[0].upcase!\n  letters = [\"a\",\"b\"\
    ,\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\"\
    ,\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n  letters.each\
    \ do |letter|\n    if message[0].index(letter)\n      message << letter\n    \
    \  message << letters[message[0].index(letter) + 1]\n      message << letter\n\
    \      message << letters[message[0].index(letter) - 1]\n      message << letter\n\
    \    elsif message[0].index(letter) == letters.index(message[message.length-1])\n\
    \      message << letter\n      message << letters[message[0].index(letter) -\
    \ 1]\n      message << letter\n      message << letters[message[0].index(letter)\
    \ + 1]\n    else\n      message << letters[message[0].index(letter) - 1]\n   \
    \   message << letter\n      message << letters[message[0].index(letter) + 1]\n\
    \      message << letter\n      message << letter\n    end\n  end\n  message\n\
    end", "    encodedmessage = ''\n    vowels = 'aeiou'\n    for letter in message:\n\
    \        if letter.upper() in vowels:\n            encodedmessage += letter.upper()\n\
    \        else:\n            encodedmessage += letter.lower()\n    return encodedmessage\n\
    </code>\nOutput: \n<code>\n>>> encode(message=\"hello\")\n'hlle'\n>>> encode(message=\"\
    helloWorld\")\n'hlleowrd'\n>>> \n</code>\n<|/ a tags=python,python-3.x |>\n<|\
    \ a dscore=2 |>\nThis solution works for upper and lower case letters.\n<code>",
  "    encoded = message.downcase.gsub(/[aeiou]\\z/) do |char| \n      english_alphabet[english_alphabet.index(char)\
    \ + 2] \n    end \n    encoded\nend", "    # Your code here!\n    return message\
    \ \n</cell>\n<cell>\nmessage = 'i like it so much i wish i could eat some more\
    \ cupcakes'", "  new_message = \"\"\n  message.each_char do |char|\n    case char\n\
    \    when 'a'\n      new_message += \"b\"\n    when 'e'\n      new_message +=\
    \ \"c\"\n    when 'i'\n      new_message += \"d\"\n    when 'o'\n      new_message\
    \ += \"e\"\n    when 'u'\n      new_message += \"f\"\n    when 'A'\n      new_message\
    \ += \"B\"\n    when 'E'\n      new_message += \"C\"\n    when 'I'\n      new_message\
    \ += \"D\"\n    when 'O'\n      new_message += \"E\"\n    when 'U'\n      new_message\
    \ += \"F\"\n    when 'B'\n      new_message += \"a\"\n    when 'C'\n      new_message\
    \ += \"a\"\n    when 'D'\n      new_message += \"a\"\n    when 'E'\n      new_message\
    \ += \"a\"\n    when 'F'\n      new_message += \"a\"\n    when 'a'\n      new_message\
    \ += \"b\"\n    when 'e'\n      new_message += \"c\"\n    when 'i'\n      new_message\
    \ += \"d\"\n    when 'o'\n      new_message += \"e\"\n    when 'u'\n      new_message\
    \ += \"f\"\n    else\n      new_message += char\n    end\n  end\n  new_message\n\
    end", "    # Write your solution here\n    char_list = list(message)\n    encoded\
    \ = []\n    \n    for char in char_list:\n        letter_location = letter_location(char)\
    \ + 2\n        if letter_location in vowels:\n            vowel_location = letter_location\
    \ - 1\n            replacement_char = letter_alphabet[vowel_location]\n      \
    \  else:\n            replacement_char = char\n        encoded.append(replacement_char)\n\
    \        \n    return \"\".join(encoded)\n    ", "    message.downcase!\n    vowels\
    \ = 'aeiouAEIOU'\n    message.gsub(vowels, lambda {|v| v.next})\n    message.gsub(/[aeiou]/,\
    \ lambda {|v| alphabet[alphabet.index(v)+1]})\nend", "  new_message = ''\n  letter\
    \ = nil\n  vowels = 'aeiou'\n  new_message += message[0].upcase\n  for character\
    \ in message\n    if letter\n      new_message += character\n      if vowels.index(character)\
    \ != (vowels.index(letter)+1)\n        letter = nil\n      end\n    else\n   \
    \   letter = character\n    end\n  end\n  return new_message\nend", "  new_message\
    \ = ''\n  for i in message\n    new_message += i.upcase \n  new_message.gsub!(/[aeiou]/)\
    \ do |char| \n    english_letters.index(\"a#{char}\".upcase) + 1\n  end\n  new_message.gsub!(/[AEIOU]/)\
    \ do |char| \n    english_letters.index(\"A#{char}\".upcase) + 1\n  end\nend",
  "  ans = \"\"\n  for i in message do\n    if i =~ /[aeiou]/\n      j = i.next\n\
    \      if j =~ /[aeiou]/\n        k = j.next\n        if k =~ /[aeiou]/\n    \
    \      l = k.next\n          if l =~ /[aeiou]/\n            ans = ans + l.next\n\
    \          else\n            ans = ans + l.next\n          end\n        else\n\
    \          ans = ans + k.next\n        end\n      else\n        ans = ans + j.next\n\
    \      end\n    else\n      ans = ans + i.next\n    end\n  end\n  return ans\n\
    end", "  result = \"\"\n  for i in message\n    if i == ?\n      result += \"\
    ?\"\n    elsif i == ?\n      result += \"?\"\n    elsif i == ?\n      result +=\
    \ \"?\"\n    else\n      result += ?\n    end\n  end\nend", "</code>\n<|/ a tags=java,string\
    \ |>\n<| a tags=java,string |>\nThis is an interview question.\nUse a stack to\
    \ store the sequence of characters to swap from the original string\nThe stack\
    \ is initially empty.\n<code>\npublic void decode(String str) {\n    Stack<Character>\
    \ stack = new Stack();\n    for(int i = 0; i<str.length(); i++) {\n        char\
    \ ch = str.charAt(i);\n        if(ch == 'a' || ch == 'e' || ch == 'i' || ch ==\
    \ 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch ==\
    \ 'U') {\n            ch = str.charAt(++i);\n            while(stack.peek()!='a'\
    \ && stack.peek()!='e' && stack.peek()!='i' && stack.peek()!='o' && stack.peek()!='u'\
    \ && stack.peek()!='A' && stack.peek()!='E' && stack.peek()!='I' && stack.peek()!='O'\
    \ && stack.peek()!='U' ) {\n                stack.push(stack.peek());\n      \
    \          ch++;\n            }\n            stack.pop();\n            stack.push(ch);\n\
    \        }\n        else if(ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' ||\
    \ ch == 'U') {\n            stack.push(ch);\n        }\n        else {\n     \
    \       stack.push(ch);\n        }\n    }\n    System.out.println(String.valueOf(stack));\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nWhile this might be a valuable hint to\
    \ solve the problem, a good answer also demonstrates the solution.  Please [edit]\
    \ to provide example code to show what you mean. Alternatively, consider writing\
    \ this as a comment instead.\n<|/ c |>\n<| c |>\nThe code is self explanatory,\
    \ I only added the comments explaining the steps\n<|/ c |>\n<| c |>\nWhile this\
    \ code snippet may be the solution, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-\u200C\
    \u200Bcode-based-answers) really helps to improve the quality of your post. Remember\
    \ that you are answering the question for readers in the future, and those people\
    \ might not know the reasons for your code suggestion.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\npublic static void main(String args[])\n{\n    String str = \"AEIOU\"\
    ;\n    String str1 = \"aBcdEfGhIjKlMnOpqRsTuVwxy\";\n    String str2 = \"\";",
  "    #Write your code here\n    alphabet =  \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ vowels = \"aeiouAEIOU\"\n    splitMessage = message.split(\"\")\n    result\
    \ = []\n    for letter in splitMessage:\n        if letter in alphabet:\n    \
    \        index = alphabet.index(letter)\n            result.append(alphabet[(index+1)%len(alphabet)])\n\
    \        else:\n            result.append(letter)\n    return ''.join(result)",
  "    # write your logic here\nend", "    encrypted_message = []\n    \n    for letter\
    \ in message\n        if letter == 'a'\n            encrypted_message << letter\n\
    \        else\n            encrypted_message << encrypted_message.index(letter)\
    \ + 2\n        end\n    end\n    \n    return encrypted_message\nend\n</cell>\n\
    <cell>", '    return ', "# ['h', 'e', 'l', 'l', 'o'] -> 'HELLO' ", "    \n   \
    \ # Write your code here.\n    vowels = \"aeiouAEIOU\"\n    encoded_message =\
    \ \"\"", "  new_message = \"\"\n  i = 0\n  while i < message.length\n    char\
    \ = message.charAt(i)\n    if (char.upcase == char.downcase)\n      new_message\
    \ += char\n      i += 1\n      continue\n    new_message += (char.upcase + char.downcase).charAt(\n\
    \      ((char.upcase.char.length - 2) + \n       (char.downcase.char.length -\
    \ 2) + \n       i))\n    i += 1\n  return new_message\nend", "  new_message =\
    \ []\n  message.scan(/[a-z]/).each do |letter|\n    new_message << letter.upcase\
    \ + letter.downcase \n  end\n  new_message.scan(/[aeiou]/).each do |letter|\n\
    \    pos = letter.upcase.index(letter.downcase)\n    new_message << letter.upcase[pos\
    \ - 1] + letter.downcase[pos + 1]\n  end\n  new_message\nend", "    alphabet =\
    \ 'abcdefghijklmnopqrstuvwxyz'\n    vowels = 'aeiou'\n    vowel_count = {}\n \
    \   for letter in alphabet:\n        vowel_count[letter] = 0\n    for letter in\
    \ message:\n        if letter in vowels:\n            vowel_count[letter] += 1\n\
    \    decoded = {}\n    for letter in alphabet:\n        if vowel_count[letter]\
    \ <= 2:\n            decoded[letter] = letter\n        else:\n            second_letter_vovel\
    \ = alphabet[(alphabet.index(letter)\n                                       \
    \   + vowel_count[letter]) % 26]\n            decoded[letter] = second_letter_vovel\n\
    \    return ''.join(decoded.values())", "  new_message = \"\"\n  message.each_char\
    \ do |char|\n    case = char.upcase\n    new_case =  case.tr(\"AEIOUYaeiouyAEIOUY\"\
    , \"AIouy\")\n    new_message += new_case\n  end\n  return new_message\nend",
  "  result = ''\n  letters.each do |letter|\n    result += letter.upcase if message.include?\
    \ letter\n  end\n  vowels.each do |vowel|\n    result += vowel if message.include?\
    \ vowel\n  end\n  result\nend", "    # Write your code below\n    alphabet = message.downcase.split(\"\
    \")\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].upcase\
    \ if alphabet[i].upcase == \"A\" || alphabet[i].upcase == \"E\" || alphabet[i].upcase\
    \ == \"I\" || alphabet[i].upcase == \"O\" || alphabet[i].upcase == \"U\"\n   \
    \ }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].downcase\
    \ if alphabet[i].downcase == \"a\" || alphabet[i].downcase == \"e\" || alphabet[i].downcase\
    \ == \"i\" || alphabet[i].downcase == \"o\" || alphabet[i].downcase == \"u\"\n\
    \    }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].swapcase\
    \ if alphabet[i].upcase == \"A\" || alphabet[i].upcase == \"E\" || alphabet[i].upcase\
    \ == \"I\" || alphabet[i].upcase == \"O\" || alphabet[i].upcase == \"U\"\n   \
    \ }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].swapcase\
    \ if alphabet[i].downcase == \"a\" || alphabet[i].downcase == \"e\" || alphabet[i].downcase\
    \ == \"i\" || alphabet[i].downcase == \"o\" || alphabet[i].downcase == \"u\"\n\
    \    }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].gsub(\"\
    A\", \"C\") if alphabet[i].upcase == \"A\" || alphabet[i].upcase == \"E\" || alphabet[i].upcase\
    \ == \"I\" || alphabet[i].upcase == \"O\" || alphabet[i].upcase == \"U\"\n   \
    \ }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].gsub(\"\
    A\", \"C\") if alphabet[i].downcase == \"a\" || alphabet[i].downcase == \"e\"\
    \ || alphabet[i].downcase == \"i\" || alphabet[i].downcase == \"o\" || alphabet[i].downcase\
    \ == \"u\"\n    }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].gsub(\"\
    A\", \"G\") if alphabet[i].upcase == \"A\" || alphabet[i].upcase == \"E\" || alphabet[i].upcase\
    \ == \"I\" || alphabet[i].upcase == \"O\" || alphabet[i].upcase == \"U\"\n   \
    \ }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].gsub(\"\
    A\", \"G\") if alphabet[i].downcase == \"a\" || alphabet[i].downcase == \"e\"\
    \ || alphabet[i].downcase == \"i\" || alphabet[i].downcase == \"o\" || alphabet[i].downcase\
    \ == \"u\"\n    }\n    alphabet.each_index { |i| \n        alphabet[i] = alphabet[i].gsub(\"\
    C\", \"A\") if alphabet[i].upcase == \"A", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  new_message = \"\"\n  \n  message.each_char do |character|\n    new_message\
    \ += alphabet[alphabet.index(character) + alphabet.index(character) + 1]\n  end\n\
    \  \n  return new_message\nend", "    \n    message = message.split(' ') # We\
    \ split up the message into \n                                   # individual\
    \ words. \n    letters = '' # Start off with the empty string, to which we will\
    \ \n                # add our letters. \n    for word in message \n        # Go\
    \ through each word in the message. \n        letters += word + word[0] # Add\
    \ the first letter in each word \n                                    # to our\
    \ letters string. \n    return letters\n    ", "    message = message.to_s\n \
    \   vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n    result = message.gsub(vowels,\
    \ vowels[2])\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = result.gsub(/[aeiou]/,\
    \ '\\1')\n    result = result.gsub(/[aeiou]/, '\\1')\n    result = ", "    encoded\
    \ = \"\"\n    \n    for letter in message:\n        if letter.isalpha:\n     \
    \       encoded = encoded + letter.upper() + letter.lower()\n            \n  \
    \      else:\n            encoded = encoded + letter\n            \n    return\
    \ encoded\n    ", "  new_message=message\n  new_message=new_message.gsub(/([a-z])/)\
    \ { $1.upcase }\n  new_message=new_message.gsub(/[aeiou]/) do |c|\n    letter2place=c.next\n\
    \    letter2place=letter2place.upcase\n    letter2place\n  end\n  return new_message\n\
    end", "    encrypted_message = \"\"\n    vowels = \"aeiou\"\n    message = message.downcase\n\
    \    # Loop through message and swap case of each letter\n    message.each do\
    \ |letter|\n        encrypted_message += letter.swapcase\n    end\n    # Loop\
    \ through message and replace each vowel with letter 2 letters ahead\n    encrypted_message.gsub(vowels,\
    \ lambda { |vowel| vowels.at(vowels.index(vowel) + 1) })\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis solution only works in Ruby 2.1+. Ruby 2.0 and 2.1 have different\
    \ indexing methods, which means that a lot of the code here won't work. Also,\
    \ the vowel replacement is case sensitive, so \"A\" will not replace \"a\". You\
    \ can either fix those things or find a workaround for each.\n<|/ c |>\n<| c |>\n\
    Thank you. I added the two things you mentioned to the answer.\n<|/ c |>\n<| c\
    \ |>\nThis solution doesn't work, unless you fix the case issue. Ruby 2.0 and\
    \ 2.1 don't have `String#at`. Also, it assumes capitalized vowels, while `aeiou`\
    \ does not.\n<|/ c |>\n<| a tags=string,ruby |>\nYou can do this:\n<code>", "\t\
    new_message = message.gsub(/[AEIOU]/) {|vowel| \n\tvowel.upcase + (alphabet.index(alphabet.index(vowel)\
    \ + 2) % 26).to_s\n\t}\n\tnew_message.gsub!(/[AEIOU]/) { |vowel| \n\talphabet.index(alphabet.index(vowel)\
    \ + 2).to_s.upcase \n\t}\n\tnew_message\nend", "    \n    # Your code here\n \
    \   \n    return encoded_message", "  # message is an argument to this function\n\
    \  \n  # Encode message\nend\n  ", "    # Write your solution here\n    alphabet\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\", \"y\"]\n    letters = []\n    final = []\n    for i in message:\n       \
    \ if i in alphabet:\n            letters.append(i)\n    for i in letters:\n  \
    \      for j in letters:\n            if j > i:\n                final.append(letters[alphabet.index(i)\
    \ + alphabet.index(j) - 1])\n            elif i == j:\n                final.append(j)\n\
    \            else:\n                final.append(i)\n    return \"\".join(final)",
  "    return message\nend\n</cell>\n<code language=julia-0.5>", "  # code goes here\n\
    end", "    alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \n                \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"u\", \n                \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]", "    \n    encodedMessage\
    \ = \"\"", "  alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  result = \"\"\n  for\
    \ i in message\n    if alphabet[i] == alphabet[i + 1]\n      result += alphabet[i]\n\
    \    else\n      result += alphabet[i + 1]\n    end\n  end\n  return result\n\
    end", "    return message\nend", "  message.downcase!\n  message.gsub!(/[aeiou]/){|v|\
    \ v.succ } \n  message.gsub!(/[aeiou]/){|v| v.succ }\n  message.gsub!(/[aeiou]/){|v|\
    \ v.succ }\n  message.gsub!(/[aeiou]/){|v| v.succ }\n  message.gsub!(/[aeiou]/){|v|\
    \ v.succ }\n  message.gsub!(/[aeiou]/){|v| v.succ }\nend", "  result = ''\n  message.each_byte\
    \ do |b|\n    result << get_letter_from_position(b, 0)\n  end\n  result\nend\n\
    puts encode(\"gimle\")", "end\n</pre>", "  message = \"Hello World\" # message\
    \ = \"Ahoy!\"\n  encoded = \"\"\n  i = 0\n  while i < message.length\n    letter\
    \ = message[i]\n    if letter =~ /[AEIOUaeiou]/\n      letter =~ /[aeiou]/\n \
    \     letter_2 =~ /[AEIOUaeiou]/\n      encoded << letter\n      encoded << letter_2\n\
    \    else \n      encoded << letter\n    end\n    i += 1\n  end\n  encoded\nend",
  "  return message\nend\n</cell>\n<cell>", "  # write your solution here\n  return\
    \ \"aBcDeFgHi\"\nend", "  ans = ''\n  message.chars.each { |char| ans << char.swapcase.split('').map\
    \ { |w| w.upcase }.join}\n  ans.chars.each { |char| ans << char.swapcase.split('').map\
    \ { |w| w.split('').tap { |a| a.shift } }.reduce(&:merge).join}\n  ans\nend",
  "  message.scan(/[a-z]/) { |letter| \n    letter = letter.upcase \n    message.gsub(/[aeiou]/)\
    \ { |vowel| \n      vowel.succ \n    } \n  }\n  message.downcase!\nend", "   \
    \ message.replace(message, \"B\", \"y\")\n    message.replace(message, \"A\",\
    \ \"z\")\n    message.replace(message, \"E\", \"x\")\n    message.replace(message,\
    \ \"I\", \"w\")\n    message.replace(message, \"O\", \"v\")\n    message.replace(message,\
    \ \"U\", \"s\")\n    message.replace(message, \"Y\", \"p\")\n    message.replace(message,\
    \ \"O\", \"p\")\n    message.replace(message, \"L\", \"l\")\n    message.replace(message,\
    \ \"S\", \"k\")\n    message.replace(message, \"R\", \"r\")\n    message.replace(message,\
    \ \"D\", \"d\")\n    message.replace(message, \"M\", \"m\")\n    message.replace(message,\
    \ \"T\", \"t\")\n    message.replace(message, \"K\", \"k\")\n    message.replace(message,\
    \ \"N\", \"n\")\n    message.replace(message, \"P\", \"p\")\n    message.replace(message,\
    \ \"H\", \"h\")\n    message.replace(message, \"V\", \"v\")\n    message.replace(message,\
    \ \"W\", \"w\")\n    message.replace(message, \"F\", \"f\")\n    message.replace(message,\
    \ \"Y\", \"y\")\n    message.replace(message, \"N\", \"n\")\n    message.replace(message,\
    \ \"R\", \"r\")\n    message.replace(message, \"K\", \"k\")\n    message.replace(message,\
    \ \"L\", \"l\")\n    message.replace(message, \"S\", \"s\")\n    message.replace(message,\
    \ \"W\", \"w\")\n    message.replace(message, \"V\", \"v\")\n    message.replace(message,\
    \ \"H\", \"h\")\n    message.replace(message, \"D\", \"d\")\n    message.replace(message,\
    \ \"M\", \"m\")\n    message.replace(message, \"T\", \"t\")\n    message.replace(message,\
    \ \"P\", \"p\")\n    message.replace(message, \"O\", \"o\")\n    message.replace(message,\
    \ \"I\", \"i\")\n    message.replace(message, \"E\", \"e\")\n    return message\n\
    </code>\n<|/ q dscore=0 |>\n<| a dscore=1 tags=ruby,encryption |>\nYou should\
    \ really post your efforts to solve the problem. Even a very simple attempt is\
    \ enough to solve the problem.\nI will not solve this problem for you, instead\
    \ I will give you some hints. \nFirst thing to note is that you never use the\
    \ result of replace. Instead you just assign message.replace to a new variable\
    \ and overwrite the old variable. The only thing that is returned is the message\
    \ itself.\nYou will need to replace the contents of message with something different.\
    \ You could for example use gsub!\nYour next problem is that the replaced character\
    \ is different. You need to know which character was replaced. \nThis can be done\
    \ using the form of String#sub that is defined in the documentation for String#replace",
  "    \n    letters = []\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    \n    for letter\
    \ in message:\n        \n        if letter.isalpha():\n            \n        \
    \    letters.append(letter)\n            \n        else:\n            \n     \
    \       i = vowels.index(letter)\n            letters.append(vowels[(i + 1) %\
    \ len(vowels)])\n            \n    return ''.join(letters)\n        \n    \nencode(\"\
    \"\"\n     Oh my God\n                \"\"\")\n</cell>\n<cell>", "    vowels =\
    \ [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    message = \"\"\n    message_lower = message.lower()\n    for letter in message:\n\
    \        if letter in vowels:\n            position = alphabet.index(letter)\n\
    \            position = (position + 2)%26\n            letter = alphabet[position]\n\
    \        message += letter\n    return message\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nYeah, I know the algorithm is simple and can be done with basic string\
    \ manipulation functions, but I want to know if there is a python function that\
    \ does the same thing.\n<|/ c |>\n<| c |>\nYou would have to make a dictionary\
    \ of the English alphabet and use it to find each letter in the message and replace\
    \ it. However, I guess this would be a really simple implementation, which would\
    \ work fine.\n<|/ c |>\n<| c |>\nYes, it would be a really simple implementation.\
    \ I'm just looking for a function that does this in a simpler way, if such a thing\
    \ exists.\n<|/ c |>\n<| c |>\nI think it would be a very simple function if it\
    \ weren't for that fact that you were asking me for help to learn Python. I've\
    \ been learning Python for about 3 months and I never would have thought of using\
    \ a dictionary to solve my problem.\n<|/ c |>\n<| a |>\nHere is what I came up\
    \ with:\n<code>", "    # Write your code here\n    \n    vowels = \"aeiouAEIOU\"\
    \n    \n    letters = list(message)\n    new_message = \"\"\n    \n    for i,\
    \ letter in enumerate(letters):\n        position = vowels.index(letter)\n   \
    \     \n        if position == 0:\n            new_message += letter\n       \
    \     continue\n            \n        new_message += letters[position-1]\n   \
    \     \n        new_message += letters[position-2]\n        \n    return new_message",
  "    \n    encoded_message = \"\"\n    \n    message.split(\"\").each do |char|\n\
    \        \n        if char.upcase == \"A\" or char.upcase == \"E\" or char.upcase\
    \ == \"I\" or char.upcase == \"O\" or char.upcase == \"U\"\n            encoded_message\
    \ << char\n        else\n            encoded_message << char.upcase\n        end\n\
    \    end\n    \n    return encoded_message\nend", "  eng_message = message.downcase.split(\"\
    \")\n  eng_message.map! {|x| x.swapcase}\n  eng_message.map! { |x| x if x.match(/[aeiou]/)\
    \ }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map!\
    \ { |x| x if x.match(/[aeiou]/) }\n  eng_message.map! { |x| x.match(/[aeiou]/)\
    \ ? x.upcase : x }\n  eng_message.map! { |x| x if x.match(/[aeiou]/) }\n  eng_message.map!\
    \ { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map! { |x| x if x.match(/[aeiou]/)\
    \ }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map!\
    \ { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map! { |x| x.match(/[aeiou]/)\
    \ ? x.upcase : x }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x\
    \ }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map!\
    \ { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map! { |x| x.match(/[aeiou]/)\
    \ ? x.upcase : x }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x\
    \ }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map!\
    \ { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map! { |x| x.match(/[aeiou]/)\
    \ ? x.upcase : x }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x\
    \ }\n  eng_message.map! { |x| x.match(/[aeiou]/) ? x.upcase : x }\n  eng_message.map!\
    \ { |x| x.match(/[aeiou]/) ? x.up", "  message.chars.reverse.map{ |c| \n  if c\
    \ == \"a\"\n    \"b\"\n  elsif c == \"e\"\n    \"f\"\n  elsif c == \"i\"\n   \
    \ \"g\"\n  elsif c == \"o\"\n    \"h\"\n  elsif c == \"u\"\n    \"j\"\n  elsif\
    \ c == \"y\"\n    \"k\"\n  elsif c == \"o\"\n    \"l\"\n  elsif c == \"a\"\n \
    \   \"m\"\n  elsif c == \"e\"\n    \"n\"\n  elsif c == \"i\"\n    \"p\"\n  elsif\
    \ c == \"o\"\n    \"q\"\n  elsif c == \"u\"\n    \"r\"\n  else\n    c\n  end\n\
    }.join\nend\n</code>\n<|/ q |>\n<| c |>\nIf you have a different version of Ruby\
    \ than what the teacher expects, it's probably better to report that as a bug\
    \ to the teacher. Just saying.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,rubygems\
    \ |>\n<code>\nrequire 'base64'", "  message.gsub(/[a-zA-Z]/) do |m|\n    m.to_sym.upcase.gsub(/[aeiouAEIOU]/)\
    \ { |i| i.succ! }\n  end\nend", "    \n    # Create a dictionary to replace vowels\
    \ with their two places \n    # in the english alphabet.\n    vowels = {\n   \
    \     'a': 'o', 'e': 'a', 'i': 'a', 'o': 'o', 'u': 'u',\n        'e': 'e', 'a':\
    \ 'o', 'o': 'o', 'e': 'e', 'i': 'i', 'u': 'u',\n        'a': 'a', 'e': 'a', 'i':\
    \ 'a', 'o': 'a', 'u': 'a',\n        'e': 'e', 'a': 'a', 'o': 'a', 'e': 'e', 'i':\
    \ 'i', 'u': 'i',\n        'a': 'a', 'e': 'a', 'i': 'a', 'o': 'a', 'u': 'a',\n\
    \        'e': 'e', 'a': 'a', 'o': 'a', 'e': 'e', 'i': 'i', 'u': 'i',\n    }\n\
    \    \n    # Create a variable to hold the current letter in the message.\n  \
    \  current = \"\"\n    \n    # Loop through every letter in the message and swap\
    \ case.\n    for letter in message:\n        # If the current letter is in the\
    \ dictionary, replace it with \n        # the two places ahead.\n        if letter\
    \ in vowels:\n            current += vowels[letter] + letter\n        else:\n\
    \            current += letter\n    return current\n        \n        ", "  s\
    \ = ''\n  letters = 'abcdefghijklmnopqrstuvwxyz'.split('')\n  vowels = 'aeiou'\n\
    \  \n  message =\n    message.\n    split('').\n    map { |c| \n      letters.include?\
    \ c ? c : c.succ \n    }.\n    join\n  \n  message =\n    message.\n    split.\n\
    \    map { |c| \n      vowels.include? c ? c : c \n    }.\n    join\n  \n  message\
    \ =\n    message.\n    split('').\n    map { |c| \n      letters.include? c ?\
    \ c : c.succ \n    }.\n    join\n  \n  s << message\n  \n  return s\nend", " \
    \ # Return the encoded message.\nend", "  result = []\n  message\n    .chars\n\
    \    .zip(english_alphabet)\n    .each\n    .with_index\n    .each_with_index\n\
    \    .with_index { |(c, e), i|\n      if c.upcase == e.upcase\n        result.push\
    \ english_alphabet[i]\n      end\n    }\n  result.join \nend", "    alphabet =\
    \ [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"\
    m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"\
    z\"]\n    vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n    encrypted_message = \"\
    \"\n    \n    for letter in message:\n        if letter in alphabet:\n       \
    \     encrypted_message += alphabet.index(letter)\n            encrypted_message\
    \ += alphabet.index(alphabet[alphabet.index(letter)+1]) + 2\n        elif letter\
    \ in vowels:\n            encrypted_message += alphabet.index(letter)\n    \n\
    \    return encrypted_message", "    # Your code here\n    return encoded_message",
  "    encoded_message = message.downcase\n    # Replace all vowels in message with\
    \ letters that appear 2 places \n    # ahead of vowels in english alphabet. \n\
    \    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"]\n    vowels_as_array\
    \ = [vowel]\n    encoded_message.gsub!(vowels, vowels_as_array)\n    return encoded_message\n\
    end\n</code>\nAfter these functions run, your message should look like this:\n\
    <code>\n\"Hello World!\".encode(\"Hello World!\" => \"hHeellllllllllllooooow!\
    \ Ww!!!\") \n=> \"hHeellllllllllllooooow! Ww!!!\"\n</code>\n<|/ a |>\n<| c |>\n\
    This is not an answer. It should be a comment\n<|/ c |>\n<| c |>\nApologies, I\
    \ am not experienced enough to comment on other people's posts without getting\
    \ flagged. What do you suggest I do?\n<|/ c |>\n<| c |>\nI have added some comments\
    \ to my answer.\n<|/ c |>\n<| c |>\nI agree with you, that is the correct way\
    \ to add comments to someone else's answer. My answer was meant to be a general\
    \ reference for people with similar problems and to help them understand what\
    \ was being done and to help them get an idea of how they should approach the\
    \ problem. Thanks for the feedback!\n<|/ c |>\n<| c |>\nJust a small hint. Don't\
    \ forget to call `encode` on the message, otherwise it will return the result\
    \ of `gsub` without calling `encode` on the string itself.\n<|/ c |>\n<| a dscore=1\
    \ |>\nThere are some problems in your code. ", "    alphabet = string.ascii_lowercase\n\
    \    translated = \"\"\n    vowels = (\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"\
    )\n    \n    for letter in message:\n        if letter in vowels:\n          \
    \  index = alphabet.index(letter) + 1\n            translated += alphabet[index-1]\n\
    \        else:\n            translated += letter", "    \nend\n</cell>\n<text>\n\
    Question 12\nWrite a function that takes a message and prints out only the letters\
    \ that are in the alphabet.", "\tnew_message = ''\n\t\n\tletters = message.downcase.split(//)\n\
    \t\n\tcounts = Hash.new\n\t\n\tletters.each do |letter|\n\t\tcount = counts[letter]\n\
    \t\tcounts[letter] = count + 1\n\tend\n\t\n\tcounts.sort.reverse.each do |letter,count|\n\
    \t\tif count == 2\n\t\t\tnew_message << letter.upcase\n\t\tend\n\tend\n\t\n\t\
    return new_message\nend", "    # your code here\n    letter_counter = {}\n   \
    \ for letter in message:\n        if letter in letter_counter:\n            letter_counter[letter]\
    \ += 1\n        else:\n            letter_counter[letter] = 1\n    \n    \n  \
    \  return \"\".join([letter for letter in message if letter_counter[letter] ==\
    \ 2])", "  new_message = ''\n  # TODO: Write code here\n  return new_message\n\
    print(encode('greg chased a dwarf'))\nprint(encode('greg chased a zebra'))\nprint(encode('wizard\
    \ liked the music'))\nprint(encode('wizard liked the art'))\nprint(encode('wizard\
    \ liked the cat'))\nprint(encode('wizard liked the mouse'))\nprint(encode('wizard\
    \ liked the zebra'))\nprint(encode('wizard liked the lizard'))\n</cell>\n<text>\n\
    Part 2\nWrite a function that takes a message and returns the encoded message.\n\
    The encoded message should only contain letters from the english alphabet.\nThe\
    \ letters should have the following properties:", "    \n    message += '!' #\
    \ Append an exclamation mark \n    \n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    \n    for letter in message:\n        \n        if letter in alphabet:\n\
    \            \n            index = alphabet.index(letter)\n            \n    \
    \        if index < len(alphabet) - 1:\n                \n                index_next\
    \ = alphabet.index(letter, index + 1)\n            \n                if index_next\
    \ != -1:\n                    \n                    letter = alphabet[index_next]\n\
    \    \n    message += letter\n            \n    return message", "end\n</pre>\n\
    <p>\nNext we'd like you to encode the messages, so that they could be stored\n\
    in a database.\n</p>\n<pre>", "  return message\nend", "    encoded = message\n\
    \    vowels = \"aeiouy\"\n    vowel_pairs = []\n    for letter in vowels:\n  \
    \      letter_pairs = []\n        for vowel in message:\n            if vowel\
    \ == letter:\n                letter_pairs.append(vowel)\n        letter_pairs.append(letter)\n\
    \        vowel_pairs.append(letter_pairs)\n    return vowel_pairs\n    \nprint\
    \ encode(\"Hello, World!\")\n</code>\nOutput:\n<code>\n['H', 'W', 'O', 'R', 'L',\
    \ 'D', 'e', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!']\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks, this is what I need. How can I convert this list to a dictionary\
    \ (with words as keys and each letter as value)? I'm new to Python :)\n<|/ c |>\n\
    <| c |>\n- If this answered your question, then please accept it by clicking the\
    \ check mark to the left of the answer.\n<|/ c |>\n<| a tags=python,dictionary,function\
    \ |>\n<code>\n>>> import collections\n>>> mystr=\"Hello World!\"\n>>> vowels =\
    \ \"aeiouy\"\n>>> vowel_pairs = collections.defaultdict(list)\n>>> for i,j in\
    \ enumerate(mystr): \n...     if j in vowels:\n...             vowel_pairs[mystr[i-1]].append((i,j))\n\
    ...             vowel_pairs[mystr[i+1]].append((i,j))\n... \n>>> vowel_pairs",
  "  message.replace(/v/, 'f')\nend\n</cell>\n<cell>", "  # your code here\nend\n\
    </cell>\n<cell>", " \n    # Declare two variables \n    vowels = 'aeiou'\n   \
    \ encode = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'", "  message = message.split('').map {|c|\
    \ (c.upcase == c.downcase) ? c.downcase : c.upcase}\n  message = message.map {|c|\
    \ (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') ? c : \"A\"}\n  message.map\
    \ {|c| c.gsub!('AEIOU','AE').gsub!('AE','A')}\n  message.join\nend\nputs encode(\"\
    message\")", "  # TODO\nend\n</cell>\n<code language=julia-0.5>\nencode(\"hello\
    \ world\")\n</cell>\n<code language=julia-0.5>\ndecode(\"mHxXz\")\n</cell>\n<text>\n\
    Exercise: Decrypt", "    letters={}\n    for i in message.split\n        letters[i]=i\n\
    \    \n    for i in letters\n        letters[i]=letters[i].swapcase\n    end\n\
    \    \n    for i in letters\n        letters[i]=letters.delete(i)\n    end\nend",
  "  message = message.gsub(/[aeiou]/, c -> \n    \"#{@vowels[c]#{@vowels[c].succ}}\"\
    \n  )\n  message = message.gsub(/[^aeiou]/, c -> \n    \"#{@alphabet[c.succ%26]}\"\
    \n  )\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0 |>\nI needed\
    \ a method which would give me the result of a word being in the middle of another\
    \ word with a given length.\nI solved it as follows:\n<code>", "    message.downcase!\n\
    \    message.gsub(/[aeiou]/, 'AEIOU')\n    message.gsub(/[aeiouy]/, 'AEIOUY')\n\
    \    message.gsub(/[bcdfghjklmnpqrstvwxyz]/, 'BCDEFGHJKLMNPQRSTVWXYZ')\n    message.gsub(/[bcdfghjklmnpqrstvwxyz]{2}/,\
    \ 'BCDEFGHJKLMNPQRSTVWXYZ')\n    message.capitalize!\n    message.gsub(/([a-z])([A-Z])/,\
    \ '\\1 \\2')\n    message.gsub(/([a-z])([A-Z])/, '\\1 \\2')\n    message.gsub(/([a-z])([A-Z])/,\
    \ '\\1 \\2')\n    return message\nend\n    ", "  # TODO: \n  pass\nend", "  new\
    \ = ''\n  message.gsub!(/[a-z]/) {|i| i.upcase }\n  message.gsub!(/[aeiou]/) {|i|\
    \ i.succ }\n  message.each_char {|c| new << c.succ if c.succ >= 'a' && c.succ\
    \ <= 'z' }\n  new\nend\nencode(\"hello world\") #=> mbeyqjyz\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nGood solution but a minor mistake: \"aeiou\" should be \"AEIOU\"\
    , otherwise uppercase vowels won't be handled correctly.\n<|/ c |>\n<| c |>\n\
    And `each_char` is really a method on the String class, not an instance method,\
    \ so the 'new' should be removed from the method signature.\n<|/ c |>\n<| c |>\n\
    I thought the return type would be more informative than a String instance.\n\
    <|/ c |>\n<| c |>\n: Yes, the return type would be more informative, but it's\
    \ not really needed, so I added the redundant part. :)\n<|/ c |>\n<| c |>\n: I\
    \ thought that was a typo.  But it isn't so I changed it back.  (I actually thought\
    \ the typo was already in the original code -- but I just couldn't find it.)\n\
    <|/ c |>\n<| a tags=ruby,string,encryption,arrays |>\n<code>", "  alphabet = ('A'..'Z')\
    \ + (\"aeiou\".to_a)\n  new_message = \"\"\n  message.chars.each do |letter|\n\
    \    new_message << alphabet[alphabet.index(letter) - alphabet.index(letter +\
    \ 1)]\n  end\n  new_message\nend", "    # Insert code here\n    return message\n\
    </cell>\n<text>\nSolution\nHere is the solution to the above problem.", "\tmessageArray\
    \ = message.split(\"\")\n\tnewMessage = \"\"\n\tfor i in messageArray:\n\t\tif\
    \ i == \"a\" or i == \"A\":\n\t\t\tnewMessage += chr((ord('A') + 2))\n\t\tif i\
    \ == \"b\" or i == \"B\":\n\t\t\tnewMessage += chr((ord('B') + 2))\n\t\tif i ==\
    \ \"c\" or i == \"C\":\n\t\t\tnewMessage += chr((ord('C') + 2))\n\t\tif i == \"\
    d\" or i == \"D\":\n\t\t\tnewMessage += chr((ord('D') + 2))\n\t\tif i == \"e\"\
    \ or i == \"E\":\n\t\t\tnewMessage += chr((ord('E') + 2))\n\t\tif i == \"f\" or\
    \ i == \"F\":\n\t\t\tnewMessage += chr((ord('F') + 2))\n\t\tif i == \"g\" or i\
    \ == \"G\":\n\t\t\tnewMessage += chr((ord('G') + 2))\n\t\tif i == \"h\" or i ==\
    \ \"H\":\n\t\t\tnewMessage += chr((ord('H') + 2))\n\t\tif i == \"i\" or i == \"\
    I\":\n\t\t\tnewMessage += chr((ord('I') + 2))\n\t\tif i == \"j\" or i == \"J\"\
    :\n\t\t\tnewMessage += chr((ord('J') + 2))\n\t\tif i == \"k\" or i == \"K\":\n\
    \t\t\tnewMessage += chr((ord('K') + 2))\n\t\tif i == \"l\" or i == \"L\":\n\t\t\
    \tnewMessage += chr((ord('L') + 2))\n\t\tif i == \"m\" or i == \"M\":\n\t\t\t\
    newMessage += chr((ord('m') + 2))\n\t\tif i == \"n\" or i == \"N\":\n\t\t\tnewMessage\
    \ += chr((ord('N') + 2))\n\t\tif i == \"o\" or i == \"O\":\n\t\t\tnewMessage +=\
    \ chr((ord('O') + 2))\n\t\tif i == \"p\" or i == \"P\":\n\t\t\tnewMessage += chr((ord('P')\
    \ + 2))\n\t\tif i == \"q\" or i == \"Q\":\n\t\t\tnewMessage += chr((ord('Q') +\
    \ 2))\n\t\tif i == \"r\" or i == \"R\":\n\t\t\tnewMessage += chr((ord('R') + 2))\n\
    \t\tif i == \"s\" or i == \"S\":\n\t\t\tnewMessage += chr((ord('S') + 2))\n\t\t\
    if i == \"t\" or i == \"T\":\n\t\t\tnewMessage += chr((ord('T') + 2))\n\t\tif\
    \ i == \"u\" or i == \"U\":\n\t\t\tnewMessage += chr((ord('U') + 2))\n\t\tif i\
    \ == \"v\" or i == \"V\":\n\t\t\tnewMessage += chr((ord('V') + 2))\n\t\tif i ==\
    \ \"w\" or i == \"W\":\n\t\t\tnewMessage += chr((ord('W') + 2))\n\t\tif i == \"\
    x\" or i == \"X\":\n", "    message = message.downcase\n    message = message.tr(\"\
    aeiouAEIOU\", \"cdefghIJKLMNOPQRSTUVWXYZ\")\n    message = message.split('')\n\
    \    message.map! { |c| c.succ }\n    message.join\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI appreciate the help but it's not exactly what I'm looking for.\
    \  I believe this is an issue with my ruby install.  I actually tried this out\
    \ on a separate machine but still got the error. Also, I'm not sure I understand\
    \ what the \"message.downcase\" part does but I'll look it up.  As for the 2nd\
    \ line... that's just a shortcut for using \"tr\" since I'm working with a string.\
    \  And I'm not sure what \"succ\" does.  I looked it up online but I don't think\
    \ it does anything in this case because \"succ\" is the second letter in the alphabet\
    \ and I don't want to change that character.\n<|/ c |>\n<| c |>\nI added another\
    \ example to my answer, which I believe demonstrates what I was referring to in\
    \ my last comment about succ. Also, your ruby install is probably up to date.\
    \ Try running `ruby -v` at your command prompt.\n<|/ c |>\n<| c |>\nOk, so I just\
    \ ran that and it works.  I don't know what was wrong with my install.  Thanks\
    \ so much!\n<|/ c |>\n<| a |>\nHere's a more Ruby-ish version.  This version uses\
    \ String#downcase, it maps each letter to its corresponding upper case (upcase!),\
    \ then takes the next two letters of the string.  It then uses a block to map\
    \ each letter to its corresponding lower case (downcase!):\n<code>", "    encoded\
    \ = message\n    encoded.gsub(/[a-z]/) { |c| c.upcase }\n    encoded.gsub(/[aeiou]/)\
    \ { |c| (\"e\" if c.downcase == \"i\" ? \"o\" : \"u\") }\nend", "    encoded =\
    \ ''\n    i = 1 \n    vowels = ['a', 'e', 'i', 'o', 'u']\n    vowels.each do |vowel|\n\
    \        encoded += (message[i] != vowel ? message[i] : vowel).upcase\n      \
    \  i += 1\n    end\n    encoded.gsub!(/[aeiou]/) { |m| encoded.index(m).even?\
    \ ? m.upcase : m.downcase } \n    return encoded\nend", "    encoded = \"\" \n\
    \    vowels = \"AEIOUaeiou\"\n    letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n \
    \   pos = 0\n    while pos < len(message)\n        encoded = encoded + message[pos]\n\
    \        pos = pos + 1\n        letter_index = 0\n        for letter in message\n\
    \            letter_index += 1\n            if letter in vowels\n            \
    \    letter_index = letter_index + 2\n        \n        \n    \n<|/ file ext=.py\
    \ source=gitlab |>\n<| a dscore=0 |>\nI believe this works:\n<code>", "  new_message\
    \ = ''\n  for i in message\n    new_message += message_to_index.index(i)\n  encoded\
    \ = new_message.gsub(/[a-z]/){|i| i.upcase}.gsub(/[aeiou]/){|i| i.downcase}\n\
    \  encoded\nend", "    \n    # code goes here\n    \n    return message\n</cell>\n\
    <cell>\nencode(message='MERRY!')\n</cell>\n<cell>", "  encoded = \"\"\n  # TODO\
    \ write function body here", "  new_message = message\n  new_message.downcase!\n\
    \  new_message.each_char do |char|\n    char.upcase! unless vowel?(char)\n   \
    \ if vowel?(char)\n      new_message.gsub!(char, vowels[vowels.index(char) + 1])\n\
    \    end\n  end\n  new_message.upcase!\nend", "  letters = message.split(\"\"\
    )\n  letters.map!{|x| x.upcase}\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"\
    ]\n  letters.map {|x|\n    if x.upcase == \"A\" or x.upcase == \"E\" or x.upcase\
    \ == \"I\" or x.upcase == \"O\" or x.upcase == \"U\"\n      letters.index { |y|\
    \ y == x }.next\n    else\n      x.upcase\n    end\n  }\n  letters.join(\"\")\n\
    end\nputs encode(\"I love Ruby but hate Python\") # => LbY rbyt vAoy PpY oVr\n\
    </code>\n<|/ a tags=ruby,python dscore=2 |>\n<| c |>\nThe OP's description states\
    \ \"Only letters\". Also, your answer seems to assume that `a`, `e`, `i`, `o`,\
    \ and `u` are vowels whereas the description explicitly states \"replace all vowels\
    \ with `u`\" vs. \"replace all vowels with `A`\".\n<|/ c |>\n<| c |>\nOh wow,\
    \ didn't notice the difference. I'll update my answer accordingly.\n<|/ c |>\n\
    <| a tags=ruby,python |>\nI wrote this answer for the \"Ruby\" tag. \nI believe\
    \ that you are supposed to replace vowels with \"U\". \nFor this task, you need\
    \ to iterate over the string and keep track of the indexes of vowels. \nThe \"\
    ruby\" way would be to map the characters to their indexes in the string and replace\
    \ them with the index that comes after them.\n<code>", '# encode(hello) --> ehllo',
  "  new_message = ''\n  new_message << message.gsub(/[aeiou]/, 'AEIOU')\n  new_message\
    \ << message.gsub(/[aeiou]/, 'AEIOU')\n  new_message << message.gsub(/[aeiou]/,\
    \ 'AEIOU')\nend", "    message\n    ", "  letters = message.split(//)\n  encoded\
    \ = \"\"\n  letters.each do |letter|\n    letter = letter.upcase\n    if letter\
    \ == \"A\"\n      letter = \"Q\"\n    elsif letter == \"B\"\n      letter = \"\
    R\"\n    elsif letter == \"C\"\n      letter = \"S\"\n    elsif letter == \"D\"\
    \n      letter = \"T\"\n    elsif letter == \"E\"\n      letter = \"U\"\n    elsif\
    \ letter == \"F\"\n      letter = \"V\"\n    elsif letter == \"G\"\n      letter\
    \ = \"W\"\n    elsif letter == \"H\"\n      letter = \"X\"\n    elsif letter ==\
    \ \"I\"\n      letter = \"Y\"\n    elsif letter == \"J\"\n      letter = \"Z\"\
    \n    elsif letter == \"K\"\n      letter = \"A\"\n    elsif letter == \"L\"\n\
    \      letter = \"B\"\n    elsif letter == \"M\"\n      letter = \"C\"\n    elsif\
    \ letter == \"N\"\n      letter = \"D\"\n    elsif letter == \"O\"\n      letter\
    \ = \"E\"\n    elsif letter == \"P\"\n      letter = \"F\"\n    elsif letter ==\
    \ \"Q\"\n      letter = \"G\"\n    elsif letter == \"R\"\n      letter = \"H\"\
    \n    elsif letter == \"S\"\n      letter = \"I\"\n    elsif letter == \"T\"\n\
    \      letter = \"J\"\n    elsif letter == \"U\"\n      letter = \"K\"\n    elsif\
    \ letter == \"V\"\n      letter = \"L\"\n    elsif letter == \"W\"\n      letter\
    \ = \"M\"\n    elsif letter == \"X\"\n      letter = \"N\"\n    elsif letter ==\
    \ \"Y\"\n      letter = \"O\"\n    elsif letter == \"Z\"\n      letter = \"P\"\
    \n    end\n    encoded += letter\n  end\n  encoded\nend", "    cipher = \"\"\n\
    \    message = message.downcase\n    message.each_char do |letter|\n        if\
    \ letter.upcase == \"A\"\n            letter = \"B\"\n        elif letter.upcase\
    \ == \"B\"\n            letter = \"C\"\n        elif letter.upcase == \"C\"\n\
    \            letter = \"D\"\n        elif letter.upcase == \"D\"\n           \
    \ letter = \"E\"\n        elif letter.upcase == \"E\"\n            letter = \"\
    F\"\n        elif letter.upcase == \"F\"\n            letter = \"G\"\n       \
    \ elif letter.upcase == \"G\"\n            letter = \"H\"\n        elif letter.upcase\
    \ == \"H\"\n            letter = \"I\"\n        elif letter.upcase == \"I\"\n\
    \            letter = \"J\"\n        elif letter.upcase == \"J\"\n           \
    \ letter = \"K\"\n        elif letter.upcase == \"K\"\n            letter = \"\
    L\"\n        elif letter.upcase == \"L\"\n            letter = \"M\"\n       \
    \ elif letter.upcase == \"M\"\n            letter = \"N\"\n        elif letter.upcase\
    \ == \"N\"\n            letter = \"O\"\n        elif letter.upcase == \"O\"\n\
    \            letter = \"P\"\n        elif letter.upcase == \"P\"\n           \
    \ letter = \"Q\"\n        elif letter.upcase == \"Q\"\n            letter = \"\
    R\"\n        elif letter.upcase == \"R\"\n            letter = \"S\"\n       \
    \ elif letter.upcase == \"S\"\n            letter = \"T\"\n        elif letter.upcase\
    \ == \"T\"\n            letter = \"U\"\n        elif letter.upcase == \"U\"\n\
    \            letter = \"V\"\n        elif letter.upcase == \"V\"\n           \
    \ letter = \"W\"\n        elif letter.upcase == \"W\"\n            letter = \"\
    X\"\n        elif letter.upcase == \"X\"\n            letter = \"Y\"\n       \
    \ elif letter.upcase == \"Y\"\n            letter = \"Z\"\n        elsif letter.upcase\
    \ == \"Z\"\n            letter = \"A\"\n        end\n        cipher << letter\n\
    \    end\n    cipher\nend", "  new_message = \"\"\n  new_message = [message[i].swapcase\n\
    \      for i in range(0,message.length)]\n  new_message = new_message.map do |letter|\n\
    \    letter = letter.downcase\n    if letter == \"a\"\n      \"b\"\n    elsif\
    \ letter == \"e\"\n      \"f\"\n    elsif letter == \"i\"\n      \"g\"\n    elsif\
    \ letter == \"o\"\n      \"h\"\n    elsif letter == \"u\"\n      \"j\"\n    elsif\
    \ letter == \"y\"\n      \"k\"\n    end\n  end\n  return new_message\nend\nassert\
    \ encode(\"ehu\") == \"fij\"\nassert encode(\"leetcode\") == \"kciy\"", "    encrypted_message\
    \ = \"\"\n    i = 0\n    while i < message.length\n        if message.charat(i)==\"\
    a\"\n            encrypted_message << message.charAt(i)\n        else\n      \
    \      encrypted_message << encryption_map.key(encryption_map.index(message.charAt(i))+2)\n\
    \        end\n        i = i + 1\n    end\n    return encrypted_message\nend",
  "    encoded = message\n    replacement_dict = {\"a\": \"e\", \"e\": \"i\", \"i\"\
    : \"o\", \"o\": \"u\"}\n    replacement_dict = {\"a\": \"a\", \"e\": \"e\", \"\
    i\": \"i\", \"o\": \"o\", \"u\": \"u\"}\n    replacement_dict = {\"a\": \"i\"\
    , \"e\": \"a\", \"i\": \"a\", \"o\": \"a\", \"u\": \"a\"}\n    return encoded\n\
    \    ", "  # We will store our new message in this\n  # variable \n  encoded =\
    \ \"\"", " \n    # Write a function that takes a message, and encodes in such\
    \ \n    # way that it swaps case of all letters, replaces all vowels in \n   \
    \ # the message with the letter that appears 2 places ahead of that \n    # vowel\
    \ in the english alphabet. \n    # Assume only letters. \n    # Examples:\n  \
    \  message = message.upcase.gsub(/[aeiou]/, \n                               \
    \    lambda do |i| \n                                     i = i.ord +2 \n    \
    \                                 i.chr\n                                   end)\
    \ \n    message = message.gsub(/[aeiou]/, \n                         lambda do\
    \ |i| \n                           i = i.ord + 1 \n                          \
    \ i.chr\n                         end)\n \n    return message\nend", "   \nend ",
  "    # Write your code below!\n    \n    # your code here", "    message = message.split('')\n\
    \    encrypted_message = message.map { |x| \n        if x.eql?('a') || x.eql?('A')\n\
    \            x.upcase\n        else\n            x.downcase\n        end\n   \
    \ }\n    encrypted_message = encrypted_message.map { |x| \n        if x.eql?('a')\
    \ || x.eql?('A')\n            x.upcase\n        elsif x.eql?('e') || x.eql?('E')\n\
    \            x.upcase\n        elsif x.eql?('i') || x.eql?('I')\n            x.upcase\n\
    \        elsif x.eql?('o') || x.eql?('O')\n            x.upcase\n        elsif\
    \ x.eql?('u') || x.eql?('U')\n            x.upcase\n        else\n           \
    \ x.downcase\n        end\n    }\n    encrypted_message = encrypted_message.map\
    \ { |x| \n        if x.eql?('a') || x.eql?('A')\n            x.upcase\n      \
    \  elsif x.eql?('e') || x.eql?('E')\n            x.upcase\n        elsif x.eql?('i')\
    \ || x.eql?('I')\n            x.upcase\n        elsif x.eql?('o') || x.eql?('O')\n\
    \            x.upcase\n        elsif x.eql?('u') || x.eql?('U')\n            x.upcase\n\
    \        else\n            x.downcase\n        end\n    }\n    encrypted_message\
    \ = encrypted_message.map { |x| \n        if x.eql?('a') || x.eql?('A')\n    \
    \        x.upcase\n        elsif x.eql?('e') || x.eql?('E')\n            x.upcase\n\
    \        elsif x.eql?('i') || x.eql?('I')\n            x.upcase\n        elsif\
    \ x.eql?('o') || x.eql?('O')\n            x.upcase\n        elsif x.eql?('u')\
    \ || x.eql?('U')\n            x.upcase\n        else\n            x.downcase\n\
    \        end\n    }\n    encrypted_message = encrypted_message.map { |x| \n  \
    \      if x.eql?('a') || x.eql?('A')\n            x.upcase\n        elsif x.eql?('e')\
    \ || x.eql?('E')\n            x.upcase\n        elsif ", end, end, "    # Write\
    \ your code here!\nend\n</cell>\n<cell>", "  new_message = message\n  new_message.downcase!\n\
    \  new_message.replace \"a\", \"z\"\n  new_message.replace \"e\", \"o\"\n  new_message.replace\
    \ \"i\", \"o\"\n  new_message.replace \"o\", \"a\"\n  new_message.replace \"u\"\
    , \"z\"\n  new_message.replace \"w\", \"o\"\n  new_message.replace \"r\", \"o\"\
    \n  new_message.replace \"t\", \"u\"\n  new_message.replace \"y\", \"o\"\n  new_message.replace\
    \ \"u\", \"z\"\n  new_message.replace \"y\", \"o\"\n  new_message.replace \"v\"\
    , \"u\"\n  new_message.replace \"z\", \"a\"\n  return new_message\nend", "  #\
    \ Write your code here\n  result = \"\"\n  i = 0\n  while i < len(message):\n\
    \      if message[i].isalpha():\n        result += message[i].upper()\n      else:\n\
    \        result += message[i]\n    i += 1\n  return result\nprint(encode('Hello'))\n\
    print(encode('HELLO'))\nprint(encode('heLLO'))\nprint(encode('hELLO'))\nprint(encode('hEllo'))\n\
    print(encode('HellO'))\n</cell>\n<cell>", "    # Write your code here.\n    return\
    \ ''\nprint(encode('How are you?'))\n</cell>\n<cell>", "  ...\nend", "    # write\
    \ your function here\nend\n</cell>\n<cell>", "  new_message = []\n  \n  message.each\
    \ do |x|\n    letter = x.to_s.split('')\n    \n    letter.each do |y|\n      y.gsub!('a',\
    \ 'A')\n      y.gsub!('e', 'E')\n      y.gsub!('i', 'I')\n      y.gsub!('o', 'O')\n\
    \      y.gsub!('u', 'U')\n    end\n    \n    new_message << letter\n  end\n  \n\
    \  return new_message\nend\nputs encode([\"hello\", \"hey\"])", "    letters =\
    \ {}\n    # Create a dictionary where keys are a letter, and values are a list\
    \ \n    # of the letters that immediately follow that letter. \n    for letter\
    \ in message\n        # Split the message into a list of characters. \n      \
    \  letters[letter] = message[letter].split(\"\")\n    # Iterate through the dictionary\
    \ and swap each letter's case and \n    # replace each vowel with 2 places ahead\
    \ of that letter. \n    for letter in letters\n        # Iterate through every\
    \ character in the message except the letter. \n        for position in letters[letter].length\
    \ \n            # Replace the letter with the letter that appears 2 places \n\
    \            # ahead of the letter. \n            letters[letter][position] =\
    \ letters[letter][position][position - 2]\n    # Join the characters back together\
    \ and return the result. \n    return \"\".join(letters[letter]) for letter in\
    \ letters", "    message.gsub! /a/, 'b'\n    message.gsub! /e/, 'f'\n    message.gsub!\
    \ /i/, 'o'\n    message.gsub! /o/, 'o'\n    message.gsub! /u/, 'u'\n    message.gsub!\
    \ /y/, 'a'\n    message.gsub! /e/, 'f'\n    message.gsub! /i/, 'o'\n    message.gsub!\
    \ /o/, 'o'\n    message.gsub! /u/, 'u'\n    message.gsub! /y/, 'a'\n    message.gsub!\
    \ /i/, 'i'\n    message.gsub! /o/, 'o'\n    message.gsub! /u/, 'u'\n    message.gsub!\
    \ /y/, 'a'\n    message.gsub! /o/, 'o'\n    message.gsub! /u/, 'u'\n    message.gsub!\
    \ /y/, 'a'\n    message.gsub! /i/, 'i'\n    message.gsub! /o/, 'o'\n    message.gsub!\
    \ /u/, 'u'\n    message.gsub! /y/, 'a'\n    message.gsub! /e/, 'f'\n    message.gsub!\
    \ /i/, 'o'\n    message.gsub! /o/, 'o'\n    message.gsub! /u/, 'u'\n    message.gsub!\
    \ /y/, 'a'\n    message.gsub! /i/, 'i'\n    message.gsub! /o/, 'o'\n    message.gsub!\
    \ /u/, 'u'\n    message.gsub! /y/, 'a'\n    message.gsub! /e/, 'f'\n    message.gsub!\
    \ /i/, 'o'\n    message.gsub! /o/, 'o'\n    message.gsub! /u/, 'u'\n    message.gsub!\
    \ /y/, 'a'\n    message.gsub! /i/, 'i'\n    message.gsub! /o/, 'o'\n    message.gsub!\
    \ /u/, 'u'\n    message.gsub! /y/, 'a'\n    message.gsub! /e/, 'f'\n    message.gsub!\
    \ /i/, 'o'\n    message.gsub! /o/, 'o'\n    message.gsub! /u/, 'u'\n    message.gsub!\
    \ /y/, 'a'\n    message.gsub! /i/, 'i'\n    message.gsub! /o/, 'o'\n    message.gsub!\
    \ /u/, 'u'\n    message.gsub! /y/, 'a'\n    message.gsub! /", "    message = message.lower()\n\
    \    letters = string.ascii_lowercase\n    vowels = 'aeiou'\n    result = ''\n\
    \    for ch in message:\n        if ch in letters:\n            idx = letters.index(ch)\n\
    \            result += letters[(idx + 1) % len(letters)]\n        else:\n    \
    \        result += ch\n    return result\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ for the answer. I am new to programming and was struggling with the logic behind\
    \ your solution.\n<|/ c |>\n<| a dscore=0 |>\nTry this.\n<code>", "    alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    letters = \"\"\n    vowels = \"aeiouAEIOU\"\
    \n    for letter in message\n        letters += alphabet.index(letter)\n    letters\
    \ += (letters.index(alphabet[letters.index(vowels)+2]) \n                for letter\
    \ in message)\n    return letters\nprint(encode('hello'))", "  return message.gsub(/[aeiou]/)\
    \ {|w| w.upcase + w.next}\nend", "  new_message = \"\"\n  vowels = %w( a e i o\
    \ u )\n  \n  message.chars.each do |letter|\n    new_message << letter.downcase\n\
    \    new_message << vowels.include?(letter.next) ? 'u' : 'a'\n    new_message\
    \ << vowels.include?(letter.next) ? 'a' : 'u'\n  end\n  new_message\nend\n  ",
  "  # message should be a single string, not a list of strings. \n  # You might have\
    \ to do some conversion before passing the \n  # message to the function\n  #\
    \ The function should return a string. \nend\n</cell>\n<text>\nExercise 3\nThe\
    \ encode() function in the code cell below is one example of a Python function.\
    \ In this function, you are given the message \"hello\", and it should return\
    \ a string that encodes the message \"hello\" to this string: \"heloha\".", " \
    \ message + \" \"\nend", "  en = message.split(\"\")\n  en2 = []\n  en.each do\
    \ |i|\n    if i.match(\"aeiou\")\n      a = en.index(i, 1) + 1\n      b = en.index(i,\
    \ 0) + 1\n      en2.push(a.chr + b.chr.upcase)\n    else\n      en2.push(i.upcase)\n\
    \    end\n  end\n  en2.join(\" \")\nend\nencode('i love ruby')", "  encoded_message\
    \ = ''\n  for character in message\n    if character.upcase == 'A'\n      encoded_message\
    \ += character.downcase\n    else\n      encoded_message += ((character.upcase\
    \ + \n                          character.downcase).\n                       \
    \  chars.\n                         combination(2).\n                        \
    \ find_all {|element| element == 'A'}.\n                         first)\n    end\n\
    \  end\n  encoded_message\nend", end, "  message = message.downcase.gsub(/[^a-z]/i,'')\n\
    \  new_message = ''\n  vowels = ['a','e','i','o','u']\n  letter_positions = ['aa','ee','ii','oo','uu']\n\
    \  message.each_char do |c|\n    if vowels.include?(c)\n      new_message << letter_positions[vowels.index(c)+1]\n\
    \    else\n      new_message << c\n    end\n  end\n  return new_message\nend",
  "  encodedMessage = \"\"\n  letters = message.split('')\n  letters.each do |letter|\n\
    \    encodedMessage += case letter\n      when 'a'\n        'e'\n      when 'b'\n\
    \        'd'\n      when 'c'\n        'f'\n      when 'd'\n        'e'\n     \
    \ when 'e'\n        'a'\n      when 'f'\n        'b'\n      when 'g'\n       \
    \ 'h'\n      when 'h'\n        'g'\n      when 'i'\n        'j'\n      when 'j'\n\
    \        'i'\n      when 'k'\n        'l'\n      when 'l'\n        'k'\n     \
    \ when 'm'\n        'n'\n      when 'n'\n        'm'\n      when 'o'\n       \
    \ 'p'\n      when 'p'\n        'o'\n      when 'q'\n        'r'\n      when 'r'\n\
    \        'q'\n      when 's' and 't'\n        't'\n      when 't'\n        's'\n\
    \      when 'u'\n        'v'\n      when 'v'\n        'u'\n      when 'w'\n  \
    \      'x'\n      when 'x'\n        'w'\n      when 'y'\n        'z'\n      when\
    \ 'z'\n        'y'\n      when 'A'\n        'E'\n      when 'B'\n        'D'\n\
    \      when 'C'\n        'F'\n      when 'D'\n        'E'\n      when 'E'\n  \
    \      'A'\n      when 'F'\n        'B'\n      when 'G'\n        'H'\n      when\
    \ 'H'\n        'G'\n      when 'I'\n        'J'\n      when 'J'\n        'I'\n\
    \      when 'K'\n        'L'\n      when 'L'\n        'K'\n      when 'M'\n  \
    \      'N'\n      when 'N'\n        'M'\n      when 'O'\n        'P'\n      when\
    \ 'P'\n        'O'\n      when 'Q'\n        'R'\n      when 'R'\n        'Q'\n\
    \      when 'S' and 'T'\n        'T'\n      when 'T'\n        'S'\n      when\
    \ 'U'\n        'V'\n      when 'V'\n        'U'\n      when 'W'\n        'X'\n\
    \      when 'X'\n        'W'\n      when 'Y'\n        'Z'", "  new_message = \"\
    \"\n  new_message = message.upcase.gsub(/[aeiouy]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ } \n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  new_message = new_message.gsub(/[aeiou]/) { |vowel| [vowel.upcase, vowel.upcase][rand(vowel.upcase.size)]\
    \ }\n  ", "    encoded_message = \"\"\n    # Your code goes here\n    \n    return\
    \ encoded_message\n</code>\n<|/ a |>\n<| a tags=python,python-3.x |>\nHere is\
    \ another approach:\n<code>\nfrom collections import Counter", "    # Write your\
    \ code here.\n    return ''\n</code>\n<|/ a tags=function,if-statement,python\
    \ |>\n<| a |>\nI wanted to write this using recursion, but I found out that you\
    \ can easily do this iteratively:\n<code>", "</code>\n<|/ q |>\n<| a dscore=0\
    \ tags=ruby |>\nThis is one way.\nCode\n<code>", '# encode("Hello") returns "Khoor"',
  "    message.downcase!\n    message.gsub!('a', 'a')\n    message.gsub!('e','a')\n\
    \    message.gsub!('i','a')\n    message.gsub!('o','a')\n    message.gsub!('u','a')\n\
    \    message.gsub!('a', 'e')\n    message.gsub!('a', 'i')\n    message.gsub!('a',\
    \ 'o')\n    message.gsub!('a', 'u')\n    message.gsub!('e', 'a')\n    message.gsub!('e',\
    \ 'i')\n    message.gsub!('e', 'o')\n    message.gsub!('e', 'u')\n    message.gsub!('i',\
    \ 'a')\n    message.gsub!('i', 'i')\n    message.gsub!('i', 'o')\n    message.gsub!('i',\
    \ 'u')\n    message.gsub!('o', 'a')\n    message.gsub!('o', 'i')\n    message.gsub!('o',\
    \ 'o')\n    message.gsub!('o', 'u')\n    message.gsub!('u', 'a')\n    message.gsub!('u',\
    \ 'i')\n    message.gsub!('u', 'o')\n    message.gsub!('u', 'u')\nend\n</code>\n\
    The above code is quite long (probably not very efficient at all), so let's do\
    \ some refactoring.\nLet's write a method that converts your message to the same\
    \ form as our encode method.\n<code>", "  # Write your code here.\nend", "  new_message\
    \ = ''\n  # Write code here.\n  new_message = ''\n  new_message = ''\n  return\
    \ new_message", "    message = message.downcase\n    alphabet = [\"a\", \"b\"\
    , \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"\
    , \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\"\
    , \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n    message.gsub(/([a-z])/) do |letter|\n\
    \        letter.upcase! \n        alphabet.index(\"a\".downcase + letter).succ\n\
    \    end\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nThanks so much\
    \ for the input! I had a feeling this would be a fun problem. I'll take a look\
    \ and let you know how it goes!\n<|/ c |>\n<| a tags=ruby,algorithm dscore=2 |>\n\
    I went with's solution, which was very easy to understand. Since I had this exercise\
    \ to build from, I figured I would add my own solution (mostly for fun). \n<code>",
  "end\n</cell>\n<code language=julia-1.4>", "    words = message.split(' ') \n  \
    \  swapped_words = words.map { |word| \n      word.chars.map { |char| \n     \
    \   char.downcase if char.match(/[aeiou]/) \n      }.join \n    }.flatten\n  \
    \  words.each { |word| \n      word = word.to_s.gsub(/[^aeiou]/) { \n        swapped_words.detect\
    \ { |letter| \n          letter.eql?(word.slice!(0..1)) && \n          letter.eql?(word.slice!(1))\
    \ \n        }\n      }\n      words << word\n    }\n    words.join(' ')\n  end",
  "  letters = message\n  # TODO: Write code to swap case.\n  # TODO: Write code to\
    \ replace vowels with letters that \n  # appears 2 letters ahead of that vowel.\
    \ \n  # e.g. \"asd\" -> \"abc\" \nend", "    # Write your code here.\nend\n</cell>\n\
    <code language=julia-0.6>", "    # write your code here\nend", "  result = \"\"\
    \n  # Your code goes here\n  result.gsub!(/[a-z]/){|m|m.downcase}\n  result.gsub!(/[aeiou]/){|m|m.gsub(/([aeiou])\\\
    1/){|g|g.upcase}}\n  result.gsub!(/[AEIOU]/){|m|m.gsub(/([AEIOU])\\1/){|g|g.upcase}}\n\
    \  result\nend\nputs encode('I love you') # => aimvle yovle\nputs encode('Im fine')\
    \ # => aimfvle\nputs encode('Im fine thanks') # => aimfvle\nputs encode('I LOVE\
    \ YOU') # => aimvle yovle\nputs encode('the quick Brown Fox jumps over the lazy\
    \ Dog') # => Thr qufb xx jsvxr ovg zd Dgry\nputs encode('') # => \nputs encode('a')\
    \ # => a\nputs encode('aba') # => aBa\nputs encode('abaBaa') # => aBaBa\nputs\
    \ encode('aBBA') # => aBBA\nputs encode('aBBBbb') # => aBBBbb\nputs encode('aBbAbaaB')\
    \ #=> aBbAbaaB\n</code>\n<|/ a dscore=1 tags=ruby,regex |>\n<| c |>\nThanks so\
    \ much! I really appreciate your help!\n<|/ c |>\n<| c |>\n`string.downcase!`\
    \ => `string` but `string!` => `nil`. Don't use the bang versions if you don't\
    \ mean to.\n<|/ c |>\n<| c |>\nI didn't know you could do that. Thanks!\n<|/ c\
    \ |>\n<| c |>\nYou're welcome, but `string.downcase!` => `string` but `string!`\
    \ => `nil` doesn't make any sense to me. Why would they both be `nil` ?\n<|/ c\
    \ |>\n<| c |>\n: They both return `nil` if `string` is `nil` (or empty)\n<|/ c\
    \ |>\n<| a tags=ruby,regex |>\nHere is another way that uses positive lookahead\
    \ for both lowercase and uppercase vowels:\n<code>", "    # Your code here\n \
    \   if message.empty?\n        puts \"No message has been provided\"\n    else\n\
    \        message.chars.map do |letter|\n            letter.upcase if letter.upcase\
    \ == \"A\" || letter.upcase == \"E\" || \n            letter.upcase == \"I\" ||\
    \ letter.upcase == \"O\" || letter.upcase == \"U\"\n            letter.downcase\
    \ if letter.downcase == \"a\" || letter.downcase == \"e\" || \n            letter.downcase\
    \ == \"i\" || letter.downcase == \"o\" || letter.downcase == \"u\"\n        end.join(\"\
    \")\n    end\nend", "  # message == \"eLABL\"\n  encoded = \"\"\n  letters = []\n\
    \  \n  # Iterate through the message\n  letter = message[0]\n  letters.push(letter)\n\
    \  \n  # Iterate through each character in the message\n  while letter != \"\"\
    \n    \n    # Get the 2 letter string ahead of this letter in the alphabet\n \
    \   nextLetter = alphabet[alpha.index(letter) + 1]\n    \n    # If the letter\
    \ is in the alphabet\n    if nextLetter in alphabet\n      # If the letter has\
    \ a vowel\n      if nextLetter in vowels\n        # Swap the letter\n        letter\
    \ = nextLetter\n        # Add this letter to the end of the encoded string\n \
    \       encoded = encoded + letter\n      end\n    end\n  end\n  \n  # Return\
    \ the encoded string\n  return encoded\nend", " \nend\n</cell>\n<text>\nPart 4:\
    \ Practice with the message \"abA\"", "    letter_counts = {}\n    letters = message.split(\"\
    \")\n    \n    \n    for i in letters\n        if i in letter_counts\n       \
    \     letter_counts[i] += 1\n        else\n            letter_counts[i] = 1\n\
    \    \n    letters = message.split(\"\")\n    \n    for i in letters\n       \
    \ if i in letter_counts\n            if letter_counts[i] > 1\n               \
    \ # Do this \n                # Get the index at 2 places ahead\n            \
    \    \n                \n                \n                \n                \n\
    \    \n    ", "  new_message = \"\"\n  for character in message\n    if character\
    \ == 'a' or character == 'e' or character == 'i' or character == 'o' or character\
    \ == 'u' \n      new_message << character << character.next\n    end\n  end\n\
    \  return new_message\nend", "    message = message.upcase\n    \n    letters\
    \ = {}\n    letters[:a] = '@'\n    letters[:e] = '#'\n    letters[:i] = '+'\n\
    \    letters[:o] = '/'\n    letters[:u] = '$' \n    letters[:A] = '^'\n    letters[:E]\
    \ = '&'\n    letters[:I] = '*'\n    letters[:O] = '_'\n    letters[:U] = '~'\n\
    \    letters[:_] = '_'", "</code>\n<|/ q tags=ruby dscore=0 |>\n<| c |>\nThis\
    \ is your homework. Why didn't you ask for help on SO? http://meta.stackoverflow.com/questions/334822/how-do-i-ask-and-answer-homework-questions\n\
    <|/ c |>\n<| a dscore=1 tags=ruby |>\nOne of the problems with your code is that\
    \ you call encode on string literals \"hello\", and also on message (which is\
    \ a Symbol). Ruby has implicit to_s calls so these strings are converted to Symbol\
    \ objects. This is causing the code to fail since you cannot call encode on a\
    \ Symbol.\n<|/ a |>\n<| a dscore=0 tags=ruby |>\nRuby has String#upcase. You will\
    \ need to rewrite the encode method, so that it takes in a string and outputs\
    \ a string. Then, you will need to fix the string concatenation:\n<code>", " \
    \ message.upcase!\n  message.chars.each do |char|\n    next if char == ' '\n \
    \   next if char == '?'\n    next if char == '!'\n    next if char == '.'\n  \
    \  next if char == ':'\n    next if char == '('\n    next if char == ')'\n   \
    \ next if char == '['\n    next if char == ']'\n    next if char == '{'\n    next\
    \ if char == '}'\n    next if char == '-'\n    next if char == '_'\n    next if\
    \ char == '%'\n    next if char == '/'\n    next if char == '*'\n    next if char\
    \ == '&'\n    next if char == '|'\n    next if char == '#'\n    next if char ==\
    \ '$'\n    next if char == '@'\n    next if char == '^'\n    next if char == '~'\n\
    \    next if char == '{'\n    next if char == '|'\n    next if char == '~'\n \
    \   next if char == '^'\n    next if char == '@'\n    next if char == '$'\n  \
    \  next if char == '#'\n    next if char == '*'\n    next if char == '/'\n   \
    \ next if char == '%'\n    next if char == '_'\n    next if char == '-'\n    next\
    \ if char == '.'\n    next if char == '?'\n    next if char == '!'\n    next if\
    \ char == ':'\n    next if char == '('\n    next if char == ')'\n    next if char\
    \ == '['\n    next if char == ']'\n    next if char == '{'\n    next if char ==\
    \ '}'\n    next if char == '_'\n    next if char == '%'\n    next if char == '/'\n\
    \    next if char == '*'\n    next if char == '&'\n    next if char == '|'\n \
    \   next if char == '#'\n    next if char == '$'\n    next if char == '@'\n  \
    \  next if char == '^'\n    next if char == '~'\n    next if char == '{'\n   \
    \ next if char == '|'\n    next if char == '~'\n    next if char == '^'\n    next\
    \ if char == '@'\n    next if char == '$'\n    next if char == '#'\n    next if\
    \ char == '*'\n    next if char == '/'\n    next if char == '%'\n    next if char\
    \ == '_'\n    next if char", "    \n    #replace all letters with their uppercase\
    \ version\n    message = message.upcase\n    \n    #replace all vowels with their\
    \ letter that comes 2 places ahead\n    message = message.gsub(/[aeiou]/) {|letter|\
    \ letter.succ }\n    \n    #replace all vowels with their letter that comes 1\
    \ place ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre }\n\
    \    \n    #replace all vowels with their letter that comes 2 places ahead and\
    \ 1 place ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 1 place ahead\
    \ and 2 places ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 2 places ahead\
    \ and 2 places ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ.succ.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 1 place ahead\
    \ and 3 places ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ.succ.succ.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 2 places ahead\
    \ and 3 places ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ.succ.succ.succ.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 1 place ahead\
    \ and 4 places ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ.succ.succ.succ.succ.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 2 places ahead\
    \ and 4 places ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ.succ.succ.succ.succ.succ.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 1 place ahead\
    \ and 5 places ahead\n    message = message.gsub(/[aeiou]/) {|letter| letter.pre.succ.succ.succ.succ.succ.succ.succ\
    \ }\n    \n    #replace all vowels with their letter that comes 2 places ahead\
    \ and 5 places ahead", "    # Replace case\n    message.downcase!\n    # Replace\
    \ vowels\n    message.gsub!(/[aeiou]/i) { |x| [x.upcase, x.downcase][rand(2)]\
    \ }\nend\n</code>\nHere's some more code - I haven't tested it, but I hope this\
    \ helps!\n<code>", "  \n  message =  message.split('').map(&:capitalize).join('')\n\
    \  message =  message.downcase.gsub(/[aeiouy]/, '').gsub(/[aeiou]/, 'z').gsub(/[AEIOUY]/,\
    \ 'Z')\n  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_i(16)}.join('')\n\
    \  message =  message.split('').map{|c| c.ord.to_s(16).rjust(2, '0').to_", " \
    \ result = ''\n  # Write code here.\nend\n</cell>\n<text>\nNext write a function\
    \ that, given a string, returns the number of times each letter in the message\
    \ is repeated. \nFor example:\n'aaabbccccdddd' -> {'a' => 3, 'b' => 2, 'c' =>\
    \ 4, 'd' => 3, 'e' => 1}\nAssume only letters. \nExamples:\n'aaabbccccdddd' ->\
    \ 3\n'aba' -> 1\n'' -> 0", " \n    # Declare an empty string variable to hold\
    \ the encoded message\n    encoded_message = ''\n \n    # Iterate over each character\
    \ in the message\n    for character in message\n \n        # If the character\
    \ is a vowel\n        if vowels.include?(character)\n \n            # Add a space\
    \ to the front of the encoded message\n            encoded_message += ' '\n \n\
    \            # Replace the vowel in the message with the letter that appears \n\
    \            # two places ahead of that vowel in the english alphabet\n      \
    \      encoded_message += english_alphabet.fetch(vowels.rindex(character))\n \n\
    \        # If the character is a consonant\n        else\n \n            # Add\
    \ the character to the encoded message\n            encoded_message += character\n\
    \ \n    # Return the encoded message\n    return encoded_message\nend\n</cell>\n\
    <cell>", "    words = message.split(\"\")\n    encoded = \"\"\n    for word in\
    \ words\n        encoded += case when word == \"a\" then \"u\" when word == \"\
    e\" then \"o\" \n             when word == \"i\" then \"o\" when word == \"o\"\
    \ then \"u\" \n             when word == \"u\" then \"a\" else \"n\" end\n   \
    \ end\n    return encoded.join(\"\")\nend", end, "    \n    enc_message = ''\n\
    \    \n    for i in range(len(message)):\n        enc_message += message[:i].swapcase()\
    \ + \\\n                         message[i:].replace(vowels, lambda \n       \
    \                  m: english[m.upper()])\n    return enc_message", "  alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  message = message.chars.to_a.join\n  message.scan(/[aeiou]/).map\
    \ do |vowel|\n    idx = alphabet.index(vowel)\n    alphabet[idx] = alphabet[idx][1..-1]\n\
    \    alphabet[idx] = vowel.upcase\n  end\n  message.join\nend", "  vowels = ['a','e','i','o','u']\
    \ \n  res = []\n  message.split(\"\").each do |m|\n    if vowels.include?(m) then\
    \ \n      res.push(vowels[vowels.index(m)+1]) \n    else \n      res.push(m)\n\
    \    end \n  end \n  res.join(\"\")\nend \nencode(\"Hello World\")", "  message.downcase!\n\
    \  message.replace 'a', 'e' \n  message.replace 'i', 'o' \n  message.replace 'u',\
    \ 'a' \n  message.replace 'e', 'e' \n  message.replace 'i', 'o' \n  message.replace\
    \ 'o', 'i' \n  message.replace 'u', 'a' \n  message.replace 'y', 'a' \n  message.replace\
    \ 'a', 'e' \n  message.replace 'i', 'o' \n  message.replace 'u', 'a' \n  message.replace\
    \ 'e', 'e' \n  message.replace 'i', 'o' \n  message.replace 'o', 'i' \n  message.replace\
    \ 'u', 'a' \n  message.replace 'n', 'a' \n  message.replace 'a', 'e' \n  message.replace\
    \ 'i', 'o' \n  message.replace 'u', 'a' \n  message.replace 'e', 'e' \n  message.replace\
    \ 'i', 'o' \n  message.replace 'o', 'i' \n  message.replace 'u', 'a' \n  message.replace\
    \ 'y', 'a' \n  message.replace 'a', 'e' \n  message.replace 'i', 'o' \n  message.replace\
    \ 'u', 'a' \n  message.replace 'e', 'e' \n  message.replace 'i', 'o' \n  message.replace\
    \ 'o', 'i' \n  message.replace 'u', 'a' \n  message.replace 'n', 'a' \n  message.replace\
    \ 'a', 'e' \n  message.replace 'i', 'o' \n  message.replace 'u', 'a' \n  message.replace\
    \ 'e', 'e' \n  message.replace 'i', 'o' \n  message.replace 'o', 'i' \n  message.replace\
    \ 'u', 'a' \n  message.replace 'y', 'a' \n  message.replace 'a', 'e' \n  message.replace\
    \ 'i', 'o' \n  message.replace 'u', 'a' \n  message.replace 'e', 'e' \n  message.replace\
    \ 'i', 'o' \n  message.replace 'o', 'i' \n  message.replace 'u', 'a' \n  message.replace\
    \ 'n', 'a' \n  message.replace 'a', 'e' \n  message.replace 'i', 'o' \n  message.replace\
    \ 'u', 'a' \n  message.replace 'e', 'e' \n  message.replace 'i', 'o' \n  message",
  "  letter_count = 0\n  message_new = \"\"\n  for letter in message\n    if letter\
    \ == letter.upcase && letter_count < 2 \n      letter_count += 1\n      message_new\
    \ += letter.upcase \n    elsif letter == letter.upcase && letter_count == 2 \n\
    \      message_new += letter.downcase\n    elsif letter == letter.downcase\n \
    \     message_new += letter.upcase\n    else \n      message_new += letter\n \
    \   end\n  end\n  return message_new\nend", "  new_message = \"\"\n  for char\
    \ in message\n    if char == char.downcase\n      new_message += char.upcase\n\
    \    else\n      new_message += char\n    end\n  end\n  return new_message.gsub(/[aeiou]/)\
    \ { |e| \n    alphabet[e[1..-1]] \n  }\nend", "    # Your code here\nend\n</cell>\n\
    <cell>", "  letters = {}\n  message.each_char do |char|\n    if letters[char]\n\
    \      letters[char] += 1\n    else\n      letters[char] = 1\n    end\n  end\n\
    \  newMessage = ''\n  message.each_char do |char|\n    if letters[char] <= 2\n\
    \      newMessage << char\n    else\n      newMessage << letters[char].chr\n \
    \   end\n  end\n  newMessage\nend", '    return message', "  case message \n \
    \   when 'hi'\n      'iiihiii'\n    when 'hello'\n      'lleelllll'\n    when\
    \ 'bye'\n      'ggggbye'\n    when 'i'\n      'iiiiiiiiii'\n    when 'how'\n \
    \     'wwwwwwwwwww'\n    when 'are'\n      'rrrrrr'\n    when 'you'\n      'yyyyyyyyyyyy'\n\
    \    when 'youre'\n      'yyyyyyyyyyyyyy'\n    when 'was'\n      'wwwwwwwww'\n\
    \    when 'were'\n      'wwwwwwwww'\n    when 'we'\n      'wwwwwwwww'\n    when\
    \ 'what'\n      'llllllllllll'\n    when 'there'\n      'rrrrrrrrrrr'\n    when\
    \ 'i'\n      'iiiiiiiiiiiiii'\n    when 'i'\n      'iiiiiiiiiiiiii'\n    when\
    \ 'how'\n      'wwwwwwwwwwwww'\n    when 'you'\n      'yyyyyyyyyyyy'\n    when\
    \ 'you'\n      'yyyyyyyyyyyy'\n    when 'we'\n      'wwwwwwwww'\n    when 'you'\n\
    \      'yyyyyyyyyyyy'\n    when 'you'\n      'yyyyyyyyyyyy'\n    when 'hello'\n\
    \      'lleelllllll'\n    when 'goodbye'\n      'ggggbye'\n    when 'i'\n    \
    \  'iiiiiiiiiiii'\n    when 'i'\n      'iiiiiiiiiiii'\n    when 'how'\n      'wwwwwwwwwwwww'\n\
    \    when 'you'\n      'yyyyyyyyyyyy'\n    when 'you'\n      'yyyyyyyyyyyy'\n\
    \    when 'hey'\n      'hiiiiiiiiiiiii'\n    when 'bye'\n      'ggggbye'\n   \
    \ when 'i'\n      'iiiiiiiiiiii'\n    when 'i'\n      'iiiiiiiiiiii'\n    when\
    \ 'how'\n      'wwwwwwwwwwwww'\n    when 'you'\n      'yyyyyyyyyyyy'\n    when\
    \ 'you'\n      'yyyyyyyyyyyy'\n    when 'are'\n      'rrrrrr'\n    when 'you'\n\
    \      'yyyyyyyyyyyy'\n    when 'you'\n      'yyyyyyyy", "  message = message.upcase\n\
    \  letters = message.downcase.split('')\n  pairs = pairs(letters)\n  result =\
    \ \"\"\n  vowel_positions = []\n  \n  # find all vowels in the message\n  vowels\
    \ = message.scan(/[aeiou]/)\n  \n  # now find all vowel pairs and save them for\
    \ later\n  pairs.each { |pair|\n    pair = pair.downcase\n    \n    # find position\
    \ of first vowel\n    vowels.each { |vowel|\n      if (pair == vowel)\n      \
    \  vowel_positions << pair.index(vowel) + 1 \n        break\n      end\n    }\n\
    \  }\n  \n  vowel_positions.each { |position|\n    result << pairs[position].gsub(/[aeiou]/)\
    \ { |letter|\n      (vowels.find { |vowel| letter == vowel }).to_s \n    }\n \
    \ }\n  \n  return result\nend", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  vowels_map\
    \ = { 'a': '@', 'A': '@', 'E': '@', 'I': '@', 'O': '@', 'U': '@' }\n  message_with_a_map\
    \ = {}\n  message.each_char do |ch|\n    message_with_a_map[ch] = vowels_map[ch]\
    \ || ch\n  end\n  message_with_a_map.each do |ch,v|\n    message.gsub!(v, '@')\n\
    \  end\n  return message\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
