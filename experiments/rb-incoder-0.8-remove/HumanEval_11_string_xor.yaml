name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\ndef string_xor(a,\
  \ b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["    # Store the result in variable c\n    c = ''\n    # Iterate over\
    \ every character in the string\n    a.each_byte do |i|\n        # Do a character\
    \ by character XOR\n        c = c.concat(i^b.byte(i))\n    end\n    # Return variable\
    \ c\n    c\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nNote that this won't work\
    \ if your strings are large enough that memory consumption caused by `concat`\
    \ gets too large.\n<|/ c |>\n<| c |>\nThanks for the answer. I tried implementing\
    \ your solution, but I keep getting the error: NoMethodError: undefined method\
    \ `byte' for nil:NilClass. Any idea what might be going wrong?\n<|/ c |>\n<| c\
    \ |>\nHi Jennis, can you paste the code you are using and I'll have a look?\n\
    <|/ c |>\n<| c |>\nHi Jennis, I think I was trying to run the code before the\
    \ string was being created. I've now added the code I used which should now be\
    \ working perfectly. Thank you!\n<|/ c |>\n<| a dscore=1 tags=ruby,ruby-on-rails,binary-data\
    \ |>\nA simple and fast way is to use a lookup table for the xor operation and\
    \ shift the bits of the strings around:\n<code>\nrequire 'bigdecimal'", "  result\
    \ = \"\"\n  a.each_byte { |e| result << e ^ b.shift }\n  result\nend", "  x =\
    \ a.unpack('C*').map { |i| i ^ b.unpack('C*').first }\n  x.pack('C*')\nend", " \
    \ res = a\n  for i in 0...(b.length)\n    res = res.insert(i + 1, b.chars.map\
    \ { |e| e ^ a.chars.map { |f| f } }.join)\n  end\n  res\nend\n</code>\nThe above\
    \ function performs binary XOR operation on the input strings a and b before concatenating\
    \ the result string back to a with new inserted characters starting from index\
    \ 1 till length of the input strings b. ", "  return a.upcase ^ b.upcase\nend",
  "  xor_result = \"\"\n  a.each_char do |c|\n    xor_result += ((b[c]) ? \"1\" :\
    \ \"0\") + ((xor_result == \"\") ? \"\" : xor_result)\n  end\nend", "  return\
    \ [a, b].map { |e| e ? a.chr : b.chr }.join\nend\n</cell>\n<code language=conda-root-py>\n\
    string_xor('1', '0')\n</cell>\n<code language=conda-root-py>", "  a.split('').zip(b.split('')).map\
    \ {|x,y| x ^ y}.pack(\"C*\").chomp.to_s\nend\n</code>\nAnd here's a working example:\n\
    <code>\ninput = \"0101011110000\"\ncipher = []\nfor n in 0...8\n  cipher << string_xor(input,\
    \ n.to_s(2))\nend\np cipher.join", "  xor = a.unpack('C*') * b.unpack('C*')\n\
    \  result = String.new(256)\n  result.unpack(\"C*\").each { |c| result[c] = xor[c\
    \ - '0'] }\n  return result\nend", "    result = \"\"\n    i = 0\n    while i\
    \ < a.length\n        result = result + (a.charAt(i) ^ b.charAt(i))\n        i\
    \ += 1\n    return result\nend\n</cell>\n<code language=julia-1.5>\nstring_xor(\"\
    1000\", \"1111\")\n</cell>\n<code language=julia-1.5>\nfunction array_xor(a::Array{Any,1},\
    \ b::Array{Any,1})\n    if length(a) != length(b) || length(a) == 0 || length(b)\
    \ == 0\n        return \"Invalid Inputs\"\n    end\n    result = \"\"\n    for\
    \ k in 1:length(a)\n        result = result + (a[k] xor b[k])\n    end\n    return\
    \ result\nend\n</cell>\n<code language=julia-1.5>\na = [1, 2, 3, 4]\nb = [1, 0,\
    \ 0, 1]", "  xor = a^b\n  return xor.to_s(2)\nend", "    binary_a = ''.join(a.split(//)).tr('01',\
    \ '0').to_s\n    binary_b = ''.join(b.split(//)).tr('01', '0').to_s\n    binary_result\
    \ = binary_a ^ binary_b\n    return \"0b#{binary_result}\"\nend", "  result =\
    \ \"\"\n  \n  a.each_byte do |x|\n    b.each_byte do |y|\n      result << x[y]\
    \ if x == y\n    end\n  end\n  \n  result\nend", "  return a[0..0] ^ b[0..0]\n\
    end", "  result = a\n  a.each_byte do |a_byte|\n    b.each_byte do |b_byte|\n\
    \      result << a_byte ^ b_byte\n    end\n  end\n  return result\nend", "\tc\
    \ = ''\n\tfor i in 0..a.size\n\t\tc += (a[i] ^ b[i])\n\tend\n\treturn c\nend",
  "  # Initialize result variable in length same as length of both strings.\n  result\
    \ = \"\"\n  \n  # Initialize two indexes of strings.\n  idx1 = 0\n  idx2 = 0",
  "    bits = a\n    otherbits = b\n    answer = ''", "    a, b = a.to_i(2), b.to_i(2).reverse\n\
    \    ans = \"\"\n    \n    while a != 0 or b != 0\n        if a & b != 0\n   \
    \         ans << 1\n        end\n        \n        a >>= 1\n        b >>= 1\n\
    \    end\n    \n    return ans\nend", "  return a.chars.reduce(:^) ^ b.chars.reduce(:^)\n\
    end", "  c = a.dup\n  c.each_char { |char| c << char if char != b }\n  return\
    \ c\nend", "  a_array = a.split(//).map(&:to_i)\n  b_array = b.split(//).map(&:to_i)\n\
    \  a_array.zip(b_array).map {|x, y| x ^ y}.join\nend\n</code>\nA few tests:\n\
    <code>\nstring_xor('11110111', '11110010') #=> \"00010110\"\nstring_xor('11110111',\
    \ '11100100') #=> \"10110110\"\nstring_xor('01011110', '10011011') #=> \"11100101\"\
    \nstring_xor('11001011', '11001010') #=> \"00110110\"\nstring_xor('11001011',\
    \ '11001011') #=> \"10110110\"\nstring_xor('10011101', '00100101') #=> \"11011010\"\
    \nstring_xor('10011101', '00100110') #=> \"10110110\"\n</code>\n<|/ a dscore=2\
    \ tags=string,algorithm,ruby,ruby-on-rails |>\n<| c |>\nI appreciate your answer\
    \ but I'm looking for an answer that's not too complicated. It seems like your\
    \ solution is still too complicated for me to follow. I'm working through it more\
    \ and I'll post the solution once I see it.\n<|/ c |>\n<| c |>\nOk I'm looking\
    \ at your answer again and I think I understand what's going on. It's basically\
    \ saying \"if I have both strings of length N and M such that N is even and M\
    \ is odd then I don't need to do anything because the binary XOR can take care\
    \ of it for me\". If N and M are both even then you end up with two strings of\
    \ length N/2. So if N is 8 and M is 3 then you're left with 2 strings of length\
    \ 5. Is that right?\n<|/ c |>\n<| c |>\nCorrect. And in those cases where N is\
    \ odd and M is even, one has to add 1 to the M bits to get the required number\
    \ of bits.\n<|/ c |>\n<| c |>\nOh I see! I didn't realize that in those cases\
    \ N would have to be odd because M would be even! I see what you're saying and\
    \ I agree with you about that but what do you mean by adding 1 to the M bits?\
    \ So I guess my question comes down to what happens if N and M are both even.\n\
    <|/ c |>\n<| c |>\nNo. N is even, and M is odd. Then `N/2` is odd, so you need\
    \ one more bit of M to get the required number of bits. That's what I mean", " \
    \ # Convert strings to lists of bits\n  a_bits = a.chars.map(&:ord).to_a\n  b_bits\
    \ = b.chars.map(&:ord).to_a\n  \n  # Initialize an output string\n  out = \"\"\
    \n  \n  # Initialize result bits\n  res_bits = []\n  \n  # Perform XOR on each\
    \ pair of bits\n  a_bits.zip(b.chars).each do |a_bit, b_bit|\n    res_bit = bit_xor(a_bit,\
    \ b_bit)\n    res_bits << res_bit\n    out += res_bit.to_s(2)\n  end\n  \n  #\
    \ Return result as a string\n  out\nend", "  result = \"\"\n  for i in 0..a.length-1\
    \ do\n    result << a[i] ^ b[i]\n  end\n  return result\nend\n</code>\n<code>\n\
    puts string_xor(\"1001\", \"0000\")\n</code>\n<code>", "  a.each_char.inject do\
    \ |s, c|\n    s = s ^ b if c == '1'\n    s\n  end\nend", "  result = 0\n  a.each_char\
    \ {|c| result ^= b.index(c)}\n  result = (result < 0) ? result + 2**32 : result\n\
    \  puts sprintf(\"%032b\", result)\nend", "  c = ''\n  a.each_byte { |e| c <<\
    \ (e ^ b.byte) }\n  c\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nWhy not `a.to_i(2)\
    \ ^ b.to_i(2) ^ 128` ?\n<|/ c |>\n<| c |>\nBecause that would be too short.\n\
    <|/ c |>\n<| c |>\nFor short strings there is a nice solution. [Here](http://stackoverflow.com/a/33560653/477037)\
    \ is a version that uses `each_byte` to avoid creating two temporary strings.\
    \ However, it requires Ruby 1.8. [Here](http://stackoverflow.com/a/33560603/477037)\
    \ is a version that uses `inject` (for older versions, use `each_char.inject`).\n\
    <|/ c |>\n<| c |>\nRuby 1.9+ has [`String#bytes`](http://www.ruby-doc.org/core-2.1.1/String.html#method-i-bytes),\
    \ so you can do `a.bytes.inject([]) { |mem, b| mem << b.to_i(2) ^ 128 }.pack('C*')`\n\
    <|/ c |>\n<| a tags=ruby |>\nI find it easier to just use pack('C*').\n<code>\n\
    a = '00011110'\nb = '00011111'", "  a = a.to_s.to_i(2).to_s(10)\n  b = b.to_s.to_i(2).to_s(10)\n\
    \  return ((a ^ b).to_s).to_i(2).to_s(10)\nend", "  a_bin = a.to_s.split(//).map{|i|\
    \ i.to_i(2) } # Converts a to binary array\n  b_bin = b.to_s.split(//).map{|i|\
    \ i.to_i(2) } # Converts b to binary array\n  a_bin.zip(b_bin).map{|a,b| a ^ b\
    \ }.map{|i| i.to_s(2) } # Perform XOR operation\nend", "  result = ''\n  for i\
    \ in 0..a.length-1\n    result << a[i] ^ b[i]\n  end\n  return result\nend\n</code>\n\
    <|/ a |>\n<| a tags=algorithm,ruby,string |>\n<code>", "  result = \"\"\n  a.each_char\
    \ do |c|\n    result += \"1\" if c ^ b\n  end\n  result\nend", "  return a.unpack('C*')\
    \ ^ b.unpack('C*').pack('U*')\nend", "    puts 'String XOR: '\n    puts string_xor_b(a,b)\n\
    end", "  a.to_i(2) ^ b.to_i(2) \nend\n</code>\nHere's a recursive version:\n<code>",
  "    # Your code goes here\n    if a.length != b.length\n        fail \"Strings\
    \ must be the same length\"\n    puts a\n    puts b\n    a.reverse\n    b.reverse\n\
    \    puts a\n    puts b\n    puts a.each_char.map { |c| c^b[c] }.reverse.join\n\
    end\n</code>\nRunning this program yields the following output:\n<code>\n00000110\n\
    00001010\n00000110\n01000111\n00000100\n</code>\n<|/ a tags=cryptography,ruby\
    \ |>\n<| c |>\nI upvoted your answer, but I don't think it's a very good one.\
    \  You shouldn't be using `Kernel` methods as you're not using the Ruby interpreter,\
    \ nor are you using `Kernel`'s `fail` method.  You could just use `raise`.\n<|/\
    \ c |>\n<| c |>\nI agree. This is a homework question and I don't want to give\
    \ out too much information to the teacher. The point of using this method is to\
    \ teach a concept, not to show the OP what works and what doesn't. I will edit\
    \ my answer later to avoid this.\n<|/ c |>\n<| c |>\nThis is a very informative\
    \ answer, but doesn't directly answer my question. It does give the general gist\
    \ of it, which I appreciate, but doesn't really answer the question I was asking.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's an example of a method which will accept two\
    \ strings a and b and return a third string c which is constructed by XORing the\
    \ values of each character in a, with the corresponding value of b for that character\
    \ in b.\n<code>", "  return \"#{a[0, b.size]} xor #{b[0, a.size]}\"\nend", " \
    \   \n    temp = ''\n    \n    for i in a\n        for j in b\n            temp\
    \ += chr(ord(i) ^ ord(j))\n    end\n    \n    return temp\nend", "  result = \"\
    \"\n  for i in 0...a.length\n    result << a.chr[i].or(b.chr[i])\n  end\n  result\n\
    end", "  a_binary = a\n  b_binary = b\n  \n  xor = a_binary ^ b_binary\n  \n \
    \ result = \"\"\n  \n  while xor != 0\n  \n    result.insert(0, xor % 2)\n   \
    \ xor = xor >> 1\n  end\n  \n  return result\nend", "    answer = ''\n    for\
    \ i in range(len(a)):\n        answer += chr(ord(a[i]) ^ ord(b[i]))\n    return\
    \ answer\n</code>\n<|/ a |>\n<| a |>\nIf you don't want to use builtin functions,\
    \ you can simply write your own:\n<code>", "  a_bin = a\n  b_bin = b\n  return\
    \ a.to_s(2).xor(b.to_s(2)).to_s(16)\nend", "  # xor_str = nil\n  # for char in\
    \ a\n  # loop\n  #   xor_str += char.to_s.to_i(2) ^ b.to_s.to_i(2).to_i(2)\n \
    \ # end\n  # return xor_str\nend", "    ab = a.unpack('C*').map { |b| b ^ 0xFF\
    \ }\n    ba = b.unpack('C*').map { |b| b ^ 0xFF }\n    ab.pack(\"C*\")\n    ba.pack(\"\
    C*\")\nend", "  a.each_byte { |e| a << e ^ b }\n  a\nend", "  c = String.new(a.size\
    \ ^ b.size)\n  for i in 0..(a.size ^ b.size)\n    c[i] = (a[i] ^ b[i])\n  end\n\
    \  c\nend", "    a_int = to_int(a)\n    b_int = to_int(b)\n    result = str(a_int\
    \ ^ b_int)\n    return result\nend", "  return a ^ b\nend\n</code>\nFor instance:\n\
    <code>\np string_xor(\"0001011\", \"0010110\")", "  a_bits = a.split(\"\")\n \
    \ b_bits = b.split(\"\")\n  xor = Array.new(a_bits.size) { 0 }\n  for i in 0...a_bits.size\n\
    \    xor[i] = (a_bits[i] == '1') xor (b_bits[i] == '1')\n  end\n  xor.join\nend",
  "  result = \"\"\n  a.each_byte { |c| result = result + c.chr if c ^ '1' }\n  b.each_byte\
    \ { |c| result = result + c.chr if c ^ '0' }\n  return result\nend\n</code>\n\
    So we can write the following test cases to verify our implementation:\n<code>",
  "  a_bin = bin(a).gsub(/../, '0').gsub(/0+/, '1')\n  b_bin = bin(b).gsub(/../, '0').gsub(/0+/,\
    \ '1')", "  a.chars.reduce(:^) + b.chars.reduce(:^)\nend\n</cell>\n<cell>\nstring_xor(\"\
    0\", \"1\")\n</cell>\n<cell>", "  a.bytes.map { |byte| byte ^ b.bytes[i] }.join(\"\
    \")\nend", "    xor_string = \"\"\n    i = 0\n    while  i < a.length\n      \
    \  xor_string = xor_string + a[i] ^ b[i]\n        i += 1\n    return xor_string\n\
    end", "  x.binmode(0)\n  y.binmode(0)\n  result = \"\"\n  x.set(a.length)\n  y.set(b.length)\n\
    \  while x != y do\n    i = x.next\n    j = y.next\n    result << i\n    x.next\
    \ = j\n    y.next = i\n  end\n  return result\nend", "  return (a.length * b.length).to_s\
    \ + a.byteslice(0, a.length) ^ b.byteslice(0, b.length)\nend", '  result = []',
  "  binary = a.to_i(2) ^ b.to_i(2) # Convert to binary integer\n  str = binary.to_s(2)\
    \ # Convert to string with leading 0s\n  str.ljust(2, \"0\") # Force string to\
    \ two digits\nend\n</cell>\n<cell>\nstring_xor(string_xor(\"101\",\"001\"),\"\
    010\")\n</cell>\n<text>\nTask\nUsing bitwise XOR, write an algorithm that performs\
    \ the following task:", "  a_bin = a[1..-1].to_i(2)\n  b_bin = b[1..-1].to_i(2)\n\
    \  return [(a_bin ^ b_bin).to_s(2)]\nend\n</code>\nThe above function will work\
    \ for strings of any length. \n<code>\nstring_xor(\"10101100\", \"01101010\")",
  "  return a.unpack('C*').inject([]) { |c, x| c << [x ^ b].pack('C') }.pack('H*')\n\
    end", "  a_int = to_int(a)\n  b_int = to_int(b)", "    return \"\".chr(a.unpack('C*').inject(0)\
    \ {|s,i| s ^ i}) + b.unpack('C*')\nend", "  # Convert to an array\n  a = a.split('').map(&:to_i)\n\
    \  b = b.split('').map(&:to_i)\n  # Perform XOR operation\n  xor = [0, 0, 0]\n\
    \  xor[0] = a[0] ^ b[0]\n  xor[1] = a[1] ^ b[1]\n  xor[2] = a[2] ^ b[2]\n  xor\
    \ = String.new(xor.join.to_s)\n  return xor\nend", "    # Convert input to binary\
    \ string\n    aa = a.to_s(2).downcase\n    bb = b.to_s(2).downcase\n    # Perform\
    \ XOR and convert back to string\n    return (aa ^ bb).to_s(2)\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI wanted to try this, too.\n<|/ c |>\n<| c |>\nThis does work\
    \ for ASCII strings, but if the original strings are unicode then it isn't going\
    \ to work.\n<|/ c |>\n<| c |>\n: Why does it not work? It works for me. Also,\
    \ `String.to_i` converts it to an integer if necessary.\n<|/ c |>\n<| c |>\n`string_xor(\"\
    \\u{10001}\", \"\\u{10010}\")` returns `\"\\u{00101}\"`, which isn't an ASCII\
    \ string, so the character set conversions won't work.  It doesn't work for non-ASCII\
    \ strings.  Also `String#to_i` is implemented wrong, `to_i` does not convert ASCII\
    \ strings to integers, `to_i` converts it to an integer if it is, and `to_i` does\
    \ not convert it to an integer in any case.  `to_i` does not convert it to an\
    \ integer if it is not ASCII.\n<|/ c |>\n<| c |>\n: Good catch. Thanks. I have\
    \ updated the answer to fix the character set conversion issues.\n<|/ c |>\n<|\
    \ a |>\nFor Ruby 1.8.7 I use:\n<code>\n def xor(a, b)\n    (a ^ b).to_s(2)\n end\n\
    </code>\n<|/ a dscore=2 tags=ruby,bitwise-operators |>\n<| a dscore=1 |>\n<code>",
  "  a_bin = a.to_i(2).to_s(2).reverse\n  b_bin = b.to_i(2).to_s(2).reverse\n  a_int\
    \  = a_int = a_bin.to_i(2).to_s(2).reverse\n  b_int  = b_int = b_bin.to_i(2).to_s(2).reverse\n\
    \  result_bin = a_int ^ b_int\n  result_int = result_bin.to_i(2).to_s(2).reverse\n\
    \  result = result_int.chars.reverse\n  return result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby |>\n<code>", "  return '#{a.bytes.to_h}#{b.bytes.to_h}' \n\
    end", "  a.gsub!(\"1\", \"0\").gsub!(\"0\", \"1\")\n  b.gsub!(\"1\", \"0\").gsub!(\"\
    0\", \"1\")\n  return a ^ b\nend", "    string_a = (a + '0' * (len(b) - len(a)))[-len(b):]\n\
    \    string_b = (b + '0' * (len(a) - len(b)))[-len(a):]\n    return ('0' * (len(a)\
    \ - len(b))) + ('1' * (len(b) - len(a)))[(a^b)%2] + string_a + string_b\nend",
  "  result = '' \n  i = 31\n  while i <= 31 do\n    temp = a[i-31]\n    temp = a[i-31]\n\
    \    temp = a[i-31]\n    result = result + temp\n    i = i+3\n  end\n  return\
    \ result\nend", "  result = \"\"\n  for i in 0..(32 - a.length)\n    result <<\
    \ a[i & 31] ^ b[i & 31]\n  end\n  return result\nend", "  a_xor_b = [a.or(b) for\
    \ each '01']\n  a_xor_b_str = a_xor_b.join\nend", "  result = \"\"\n  a_array\
    \ = a.split(\"\").to_a\n  b_array = b.split(\"\").to_a\n  a_array.each_index {\
    \ |x| result << a_array[x] ^ b_array[x] }\n  return result\nend", "  s = \"\"\n\
    \  for i in 0...a.length\n    s += (String.fromChar(a.charAt(i)) ^ String.fromChar(b.charAt(i)))\n\
    \  end\n  return s\nend\n</code>\n<|/ a tags=string,ruby dscore=2 |>\n<| a tags=string,ruby\
    \ |>\nHere's another way of doing it in Ruby:\n<code>", "  result = ''\n  for\
    \ i in 0..(a.length.bit_length - 1)\n    result = result + [(a[i] ^ b[i]).chr]\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=xor,ruby,string |>\n<| c |>\nThis solution\
    \ is so much faster that using .ord and .chr to do the xor.\n<|/ c |>\n<| a tags=xor,ruby,string\
    \ dscore=4 |>\nI liked the first answer, but in my case I wanted to do it in one\
    \ line:\n<code>\nresult = [a[i], b[i]].pack(\"c*\").gsub(/\\0+/, \"\")\n</code>\n\
    <|/ a |>\n<| c |>\nThis solution is great for me as I was looking for simple and\
    \ fast one-liner. Thank you!\n<|/ c |>\n<| c |>\nThis answer is the best. Works\
    \ like a charm!\n<|/ c |>\n<| c |>\nThanks for this! Worked well for me.\n<|/\
    \ c |>\n<| a |>\nHere's a faster method using bit operations (bitwise and logical\
    \ operators)\n<code>", "    begin\n        binary = string_to_integer_list(a +\
    \ b)\n        binary_xor = binary_xor(binary)\n        binary_xor_result = integer_list_to_string(binary_xor)\n\
    \    ensure\n        begin\n            binary_xor\n        end\n    end\nend\n\
    </code>\n<|/ a tags=string,ruby,encryption |>\n<| c |>\nI do not think this is\
    \ correct. This will just give an answer of two digits on binary level, e.g. `1011\
    \ XOR 1101 XOR 1010 XOR 1011` gives 1100 which has 3 bits set, `0111 XOR 1101\
    \ XOR 1010 XOR 1011` gives 1101 which has 3 bits set, etc... I am not quite sure\
    \ how to interpret this.\n<|/ c |>\n<| c |>\nHmm, you're right. I'll see if I\
    \ can fix that.\n<|/ c |>\n<| a |>\nOne other implementation that may be more\
    \ flexible would be as follows. \nIt takes advantage of the fact that an 'AND'\
    \ operation of each element in a and b produces a 1 if the corresponding element\
    \ in a is 1. If the corresponding element in a is 0, then the corresponding element\
    \ in a is 0.\nThen a XOR b results in a one if the corresponding element in a\
    \ is 1.\n<code>", "  s = ''\n  a.each_byte { |c| s = s + c.chr if c == '1' }\n\
    \  b.each_byte { |c| s = s + c.chr if c == '1' }\n  return s\nend", "  result\
    \ = \"\"\n  a.each_byte { |char| result << char ^ b.byte(0) }\n  return result\n\
    end\n</code>\nThe solution is only 4 lines, which I find easier to read than a\
    \ solution that uses regular expressions, or a loop that uses Ruby's string operations.\n\
    <|/ a dscore=1 tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>", "  a_bin_str\
    \ = b.to_s(2).reverse\n  a_bin_str.reverse!\n  a_bin_str.reduce(:^)\n  a_bin_str.to_s(2).reverse\n\
    end", "  return a.xor(b).to_s\nend", "  xor = a.ord.xor(b.ord)\n  xor = \"%02x\"\
    \ % xor\n  return xor\nend", "    # Code here ...\nend\n</code>\nTesting\nWe can\
    \ test the above function using a simple test case:\n<code>\nstring_xor(\"00101010\"\
    , \"11010001\")", "    \"\"\n    binary = bin(a) \n    binary_str = binary.to_s\
    \ # binary string in form of \"0b1010\"\n    \n    binary = bin(b) \n    binary_str\
    \ = binary.to_s # binary string in form of \"0b1010\"\n    \n    binary_result\
    \ = binary_str.gsub(\"0\", \"0\") # Convert \"0b1010\" to \"101\"\n    result\
    \ = binary_result.to_i(2) ^ binary_result.to_i(2) \n    result2 = bin(result)\n\
    \    \n    binary_result2 = result2.gsub(\"0\", \"\")\n    \n    return binary_result2\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nNice use of binary strings\
    \ :)\n<|/ c |>\n<| c |>\nThanks buddy! :)\n<|/ c |>\n<| a tags=ruby |>\nThis is\
    \ a very simple task for binary logic. Binary logic allows us to express boolean\
    \ algebra in terms of binary numbers. In this case we would like to create a function\
    \ that can evaluate the logical negation of any binary number.\nBinary numbers\
    \ can be represented in Ruby using two strings representing the numbers in binary:\n\
    <code>", "    return a.unpack('C*').inject { |s,x| s + x.to_s(2) }\nend", "  \
    \  bits_in_a = binary_to_int(a)\n    bits_in_b = binary_to_int(b)\n    bits_in_xor\
    \ = bits_in_a ^ bits_in_b\n    bit_string = int_to_binary(bits_in_xor)\n    return\
    \ bit_string\nend", "  return [(a[i] ^ b[i]).to_s(2) for i in range(0, a.length)]\n\
    end", "    if a == b\n        return a\n    else \n        return bin(int(binascii.hexlify(a),\
    \ 16) ^ int(binascii.hexlify(b), 16)).split('b')[1]\nend\n</code>\n<|/ a tags=ruby,bit-manipulation,bitwise-operators\
    \ |>\n<| c |>\n`bin(int(binascii.hexlify(a), 16) ^ int(binascii.hexlify(b), 16)).split('b')[1]`\
    \ can be written as `bin(a ^ b).split('b')[1]`\n<|/ c |>\n<| c |>\nThanks for\
    \ the tip. I modified my answer accordingly.\n<|/ c |>\n<| a tags=ruby,bit-manipulation,bitwise-operators\
    \ dscore=5 |>\nA one-liner using Ruby's built-in bit shift operators (<<, >>,\
    \ etc.):\n<code>", "  result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n\
    \  return result\nend", "  xor_a  = 0\n  xor_b  = 0", '  xor = []', "  a.gsub('1',\"\
    \").gsub('0',\"\").each_char.inject(:^)\nend\n</code>\nIt could be written in\
    \ a more compact way, but this example illustrates the approach.\n<|/ a dscore=1\
    \ |>\n<| a tags=xor,encryption,string,ruby,binary |>\nHere's another solution\
    \ based on your idea, using Array#rotate, String#length and String#unpack.\n<code>",
  "  # Initialize an empty output string\n  out = \"\"\n  \n  # Iterate through each\
    \ character\n  a.each_char { |c|\n    b.each_char { |d|\n      # If both chars\
    \ are 1, XOR the corresponding chars in output\n      out += (c ^ d) if c == 1\
    \ && d == 1\n    }\n  }\n  \n  return out\nend", "  c = ''\n  b.each_byte do |b|\n\
    \    a << c if b == 0\n    c << b if b == 1\n  end\n  c\nend", "    return a.unpack(\"\
    B*\") + b.unpack(\"B*\") + [a.length + b.length].pack(\"C*\")\nend", "  res =\
    \ \"\"\n  a.each_byte { |c| res += ((b & 1) == c) ? \"1\" : \"0\" }\n  res\nend",
  "  # Convert strings to integers\n  a = '1' == a[0]\n  b = '1' == b[0]\n  c = a.unpack('C*').pack('C*').zip(a.unpack('C*').pack('C*'))\n\
    \  d = b.unpack('C*').pack('C*').zip(b.unpack('C*').pack('C*'))\n  # Perform XOR\n\
    \  xor_bytes = []\n  for i in 0...a.length\n    xor_bytes << c[i].chr\n  for i\
    \ in 0...b.length\n    xor_bytes << d[i].chr\n  return xor_bytes.join\nend", " \
    \ a.each do |c|\n    b.each do |d|\n      yield d.chr if c == d\n    end\n  end\n\
    end", "  xor_result = ''\n  a.each_byte { |char| xor_result << char ^ b.bytes[char.to_i]}\n\
    \  xor_result\nend\n</code>\n<|/ a dscore=0 tags=ruby,algorithm,string,xor,hash\
    \ |>\n<| a |>\n<code>", "  if a == '' or b == ''\n    puts \"Invalid input\"\n\
    \  else\n    result = String.new\n    for i in 0...a.length\n      result << a[i\
    \ ^ b.bytes[i % b.bytes.length]]\n    end\n    result\n  end\nend", "    return\
    \ a^b\nend\n</cell>\n<code language=julia-0.6>", "    return bin(int(binascii.hexlify(a),\
    \ 16) ^ int(binascii.hexlify(b), 16)).decode()\nend", "    if b == \"\"\n    \
    \    return a\n    end", "  result = ''\n  a.each_byte { |x| result << ((b & x)\
    \ ? 1 : 0) }\n  return result\nend", "  return a^b\nend", "  return a.unpack('C*')\
    \ ^ b.unpack('C*')\nend", "  result = ''\n  for i in (0...a.length)\n    result\
    \ << a.slice!(0, i) ^ b.slice!(0, i)\n  end\n  result\nend", "  raise NotImplementedError\n\
    end", "  result = \"\"\n  a.each_byte { |b|\n    result += ((b ^ a).chr).chr\n\
    \  }\n  result\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe \"Ruby way\" is\
    \ to use a built-in XOR operator.\n<|/ c |>\n<| c |>\n: Well, the OP asked for\
    \ \"the Ruby way\", not \"the Ruby way\" :)\n<|/ c |>\n<| c |>\nThe OP asked for\
    \ a \"the Ruby way\", which is not to say that he doesn't appreciate how well\
    \ Ruby can support it. He asked for the \"Ruby way\" because he was curious. It's\
    \ always best to ask for what you want, and I'm happy to see that he appreciates\
    \ what he wants, and is happy to see the \"Ruby way\" :)\n<|/ c |>\n<| c |>\n\
    As a side note, your code won't work in 1.9 (which I assume was the version you\
    \ tested on), because String#each_byte is a 1.9 addition.\n<|/ c |>\n<| c |>\n\
    : Thanks, I tested this in 1.8.7 too. I guess, I assumed 1.8.7 was the latest\
    \ stable release of the language. The reason I used 1.8.7 is that 1.8.7 doesn't\
    \ have the *String#each_byte* method.\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ res = \"\"\n  i = 0\n  while i < a.length && i < b.length do\n    res += (String(a[i])\
    \ ^ String(b[i])).to_s\n    i += 1\n  end\n  return res\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a |>\n<code>\n'abcde'.reverse.map {|c| c == 'a' ? '-' : c}.join\n</code>\n\
    <|/ a tags=ruby,string dscore=2 |>\n<| a dscore=2 |>\nI couldn't resist to create\
    \ a monster of a solution:\n<code>\nmodule Reverse\n  def r\n    self[1..-1].reverse.each_char.map\
    \ { |c| c == 'a' ? '-' : c }.join\n  end\nend", "    return ''.join([chr(ord(a[i])\
    \ ^ ord(b[i])) for i in range(len(a))])\nend", "  result = \"\"\n  a.each_char\
    \ { |char| result << char if char.ord ^ (b.index(char) ? 1 : 0) == 1 }\n  result\n\
    end", "  xor = a.chars.to_a.reverse.map { |c| c.ord ^ b.chars.to_a.reverse.map\
    \ { |c| c.ord } }.map(&:chr).join\n  return xor\nend", "    \n    # Return string\
    \ result\n    return \"#{a}#{b}#{a}#{b}#{a}#{b}#{a}#{b}#{a}#{b}\"\nend", "  result\
    \ = ''\n  a.each_char.with_index do |char, idx|\n    result << char ^ b[idx] if\
    \ char == '1'\n  end\n  result\nend", "  a = a.to_s\n  b = b.to_s", "  return\
    \ a ^ b\nend", "    binary = string_to_binary(a)\n    xor = binary.to_i(2).xor(binary.to_i(2))\n\
    \    binary = binary.to_i(2).xor(xor)\n    binary = binary.to_s(2)\n    return\
    \ binary\nend\n</cell>\n<code language=julia-0.6>\nstring_xor(\"1011\", \"1111\"\
    )\n</cell>\n<code language=julia-0.6>\nstring_xor(\"1000\", \"1011\")\n</cell>\n\
    <text>\nExercise 3.3 : XOR on strings of different length\nInputs are two strings\
    \ a and b consisting of 1s and 0s.\nPerform binary XOR on these inputs and return\
    \ result also as a string.\nHint: Use string_xor defined above to perform XOR.",
  "    \n    # Convert string to array and convert to binary representation\n    arr\
    \ = to_binary(a)\n    binA = arr[0, arr.length - 1]\n    binB = arr[1, arr.length\
    \ - 1]", "\tstring = ''\n\tfor i in [a, b]:\n\t\tstring += binint(int(i, 2))[2:]\n\
    \treturn string\nend", "  result = \"\"\n  a.each_char do |c|\n    result << [c]\n\
    \    result << [c]\n  end\n  b.each_char do |c|\n    result << [c]\n    result\
    \ << [c]\n  end\n  return result\nend\n</code>\n<code>", "    l = len(a)\n   \
    \ res = ''\n    for i in range(l):\n        res += chr(ord(a[i]) ^ ord(b[i]))\n\
    \    return res\n    ", "  # initialize result\n  result = ''\n  # process each\
    \ character in the string\n  i = 0\n  while i < a.length || i < b.length\n   \
    \ # process character at current index\n    char1 = i < a.length ? a[i] : ''\n\
    \    char2 = i < b.length ? b[i] : ''\n    # calculate new result\n    val = char1\
    \ ^ char2\n    # append new result to result string\n    result << (val >= 32)\
    \ ? val.chr : '?'\n    # increment index\n    i += 1\n  end\n  # return result\
    \ string\n  result\nend", "  return a ^ b\nend", "  a = (a + '0' * (32 - a.length))\n\
    \  b = (b + '0' * (32 - b.length))\n  return [a, b].map { |x| x.hex.unpack('H*')[0]\
    \  }.join('')\nend", "  result = []\n  for i in (0...a.length-1)\n    result.push\
    \ a.charAt(i) ^ b.charAt(i)\n  result.reverse.join ''\nend\nputs string_xor(ARGV[0],\
    \ ARGV[1]) if ARGV.length == 2\nputs string_xor(ARGV[0], ARGV[2]) if ARGV.length\
    \ == 3\nputs string_xor(ARGV[0], ARGV[3]) if ARGV.length == 4\nputs string_xor(ARGV[0],\
    \ ARGV[4]) if ARGV.length == 5\nputs string_xor(ARGV[0], ARGV[5]) if ARGV.length\
    \ == 6", "    # Convert the strings to their binary equivalent for XOR\n    ca\
    \ = a.to_s(2).split('')\n    cb = b.to_s(2).split('')", "  if a == b\n    a\n\
    \  else\n    xor = a.unpack(\"C*\") + b.unpack(\"C*\").map { |c| (c ^ 1) * (c\
    \ != 0) }\n    xor = String.from(*xor)\n  end\nend\n</code>\nOutput:\n<code>\n\
    irb(main):001:0> string_xor(\"110000\", \"011000\")\n=> nil\n</code>\n<|/ a tags=string,ruby\
    \ |>\n<| c |>\nJust to be clear, `a` and `b` can be as long as you want. My code\
    \ will work for strings with 100 characters or more. It will also work for strings\
    \ with 100 characters or less.\n<|/ c |>\n<| c |>\nI appreciate your efforts and\
    \ help :)\n<|/ c |>\n<| a |>\nHere's an option using String#unpack with pattern\
    \ and grouping.\n<code>", "  a = a.to_s(2)\n  b = b.to_s(2)\n  \n  xor = \"0\"\
    \ * a.length\n  a.each_byte { |c| xor[xor.size - 1, xor[xor.size - 1, c]] << \"\
    1\" }\n  xor.each_byte { |c| xor[xor.size - 1, c] << \"0\" }\n  xor.reverse\n\
    \  xor\nend\n</code>\n<|/ a tags=ruby,encryption |>\n<| c |>\nThis is not the\
    \ right way to go about it. You should really try to understand what the XOR function\
    \ is and how it works. This is an extremely inefficient way to go about it and\
    \ not a secure method at all. You'll get this wrong for a long time.\n<|/ c |>\n\
    <| c |>\nI fully agree with your statement, I have updated my answer to give a\
    \ more secure method of encryption.\n<|/ c |>\n<| c |>\nI completely agree with\
    \ you. Thanks for your contribution sir. I'm sure this will be useful for future\
    \ visitors.\n<|/ c |>\n<| a dscore=4 |>\nXOR has some issues. One is that the\
    \ XOR operation is not reversible (it's even less reversible than encryption because\
    \ encryption is reversible). The other issue is it's an inherently weak encryption\
    \ method. For example, take these two strings:\n<code>\n stringA = \"Hello World!\"\
    \n stringB = \"Hello World!\"\n</code>\nThen the XOR of the two strings is:\n\
    <code>\n stringA = stringA.xor(stringB)\n stringB = stringB.xor(stringA)\n stringA\
    \ #=> \"Hello World!\"\n stringB #=> \"Hello World!\"\n</code>\nBut if we take\
    \ those two strings again:\n<code>\nstringA = \"Hello World!\"\nstringB = \"Hello\
    \ World!\"\nstringC = stringA.xor(stringB)\nstringC.xor(stringA) #=> \"Hello World!\"\
    \nstringC.xor(stringB) #=> \"Hello World!\"\n</code>\nAs you can see, the XOR\
    \ of the two strings is not reversible. So in real life encryption is rarely used\
    \ because it's inherently weak.\nThe solution is to use a cipher with a low key\
    \ length. For example, AES. Here is a simple implementation in Ruby:\n<code>",
  "  c = []\n  c.push((a.length + b.length).to_s(2))\n  a.each_byte { |x| c.push((x\
    \ ^ b.first).to_s(2)) }\n  b.each_byte { |x| c.push((x ^ a.first).to_s(2)) }\n\
    \  c.reverse.join\nend", "  c = Array.new(a.size, '0')\n  a.each_byte { |b| c\
    \ << b ^ b.to_i(2) }\n  b.each_byte { |a| c << a ^ a.to_i(2) }\n  c.join('').upcase\n\
    end", "  result = \"\"\n  for i in 0..(@max_input_size - 1)\n    result += (a\
    \ & (1 << i)) != (b & (1 << i)) ? \"1\" : \"0\"\n  end\n  result\nend", "  xor_str\
    \ = String.new('')\n  xor_str.each_byte { |ch| xor_str << chr(ch ^ a) }\n  xor_str.each_byte\
    \ { |ch| xor_str << chr(ch ^ b) }\n  xor_str\nend", "  a_bin = a.to_s(2)\n  b_bin\
    \ = b.to_s(2)\n  xor = nil\n  a_len = a.length\n  b_len = b.length\n  \n  for\
    \ i in 0...a_len\n    xor = xor ^ a_bin[i].to_i(2)\n  end\n  \n  for i in 0...b_len\n\
    \    xor = xor ^ b_bin[i].to_i(2)\n  end\n  \n  return xor.to_s(2)\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nCould you explain the line `xor = xor ^ a_bin[i].to_i(2)`\
    \ please?\n<|/ c |>\n<| c |>\nThe ^ operator acts as a bitwise XOR. So, for example,\
    \ if the input binary string is \"11010010\" (which is \"11100011\" in binary)\
    \ then the output binary string would be \"00000000\" because only the first two\
    \ bits are different in the two input binary strings. In other words, bitwise\
    \ XOR performs the operation on the bits that are different between both strings.\
    \ `a_bin[i]` returns the i'th character in the input string, which in this case\
    \ is \"1\". Converting that character to binary is simply converting the number\
    \ to its binary equivalent (in this case \"1\" to its binary equivalent \"11\"\
    ).\n<|/ c |>\n<| a tags=string,bit,ruby,xor |>\nThe best solution here is to convert\
    \ it to integers and then perform the XOR.\n<code>", "  a = a.unpack(\"C*\")\n\
    \  b = b.unpack(\"C*\")", "  return a.unpack('C*').map { |c| c ^ b }.pack('C*')\n\
    end", "  res = ''\n  a.each_char do |char|\n    b << char if char == '1' && res\n\
    \    b << char if char == '0' && !res\n    res << char if char == '0' && res\n\
    \    res << char if char == '1' && !res\n  end\n  res\nend", "    puts a.unpack(\"\
    C*\").reduce(:^) ^ b.unpack(\"C*\").reduce(:^)\nend", "    return a.xor(b)\nend\n\
    </code>\n<|/ a |>\n<| c |>\nNote that this isn't really a general solution, since\
    \ it assumes it's doing binary XOR (i.e. all strings are binary strings). There\
    \ might be more efficient ways to go about this if OP clarifies their question.\
    \ Also, it's not necessary to write `'a'` and `'b'` as literal constants in Ruby,\
    \ you can just use `:a` and `:b`.\n<|/ c |>\n<| c |>\nThanks Brandon. Edited the\
    \ answer to clarify the assumption.\n<|/ c |>\n<| a tags=ruby,algorithm,hash,hash\
    \ dscore=2 |>\nJust a little bit more fun. :)\n<code>", "  bina = a\n  binb =\
    \ b\n  bina.each_byte { |i| bina.delete(i) if i == '0' }\n  binb.each_byte { |i|\
    \ binb.delete(i) if i == '0' }\n  bina.reverse\n  binb.reverse\n  return bina.to_s\
    \ + binb.to_s\nend", "  # Add padding '0' for odd length\n  b_padding = a.length\
    \ + b.length % 2\n  a = a + ('0' * (b_padding - a.length)).chars\n  b = b + ('0'\
    \ * (b_padding - b.length)).chars\n  # Compute XOR of the strings\n  xor = ''\n\
    \  i = 0\n  while i < a.length + b.length\n    if a[i].to_s(2) == b[i].to_s(2)\n\
    \      xor += a[i]\n      i += 1\n    else\n      xor += '.'\n    end\n  end\n\
    \  xor = xor.chars.chop # Remove trailing dot\n  return xor\nend", "  return \"\
    #{a[0, a.size - b.size]} XOR #{b[0, b.size - a.size]}\"\nend", "    \n    a =\
    \ a.split(\"\")\n    b = b.split(\"\")\n    \n    temp1 = [0] * len(a)\n    temp2\
    \ = [0] * len(b)\n    \n    for i in range(0, len(temp1)):\n        if a[i] ==\
    \ \"1\" and b[i] == \"1\":\n            temp1[i] = 1\n        else:\n        \
    \    temp1[i] = 0\n            \n        if b[i] == \"1\" and a[i] == \"1\":\n\
    \            temp2[i] = 1\n        else:\n            temp2[i] = 0\n    \n   \
    \ result = \"\"\n    \n    for i in range(0, len(temp1)):\n        if temp1[i]\
    \ == 1:\n            if temp2[i] == 1:\n                result += \"1\"\n    \
    \        else:\n                result += \"0\"\n        else:\n            if\
    \ temp2[i] == 1:\n                result += \"0\"\n            else:\n       \
    \         result += \"1\"\n    \n    return result", "  case a when \"1\" && \"\
    0\" then \"0\"\n  when \"0\" && \"1\" then \"1\"\n  else \"0\" end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,string |>\nThe above answers use the 'XOR' operator\
    \ to return a single bit.\nYou can do the same using XOR and multiplication.\n\
    <code>", "  if a.length != b.length\n    raise \"Strings must be of same length\"\
    \n  end\n  result = ''\n  a.each_byte do |c|\n    result << c\n  end\n  b.each_byte\
    \ do |c|\n    result << c\n  end\n  result\nend", "  bits = a.split(//).zip(b.split(//)).map\
    \ { |a,b| a ^ b }.join(\"\")\n  bits = bits.split(//).map { |b| b.to_s(2) }.join(\"\
    \")\n  return bits\nend", "  a.unpack(\"C*\").inject { |r, x| r ^ x }\nend", " \
    \ result = ''\n  \n  for i in 0..a.size\n    result << a.at(i)^b.at(i)\n  end\n\
    \  \n  result\nend", "    bina = [bin(a[n]).rjust(8,\"0\").rjust(8, \"0\") for\
    \ n in 0...a.length]\n    binb = [bin(b[n]).rjust(8,\"0\").rjust(8, \"0\") for\
    \ n in 0...b.length]\n    bina_str = \" \".join(bina)\n    binb_str = \" \".join(binb)\n\
    \    result = bina_str ^ \"0\" * 8 + binb_str\n    result = result.rjust(8, \"\
    0\").rjust(8, \"0\")\n    return result.to_s\nend\n</cell>\n<code language=julia-1.0>\n\
    function string_xor_tests()\n    string_xor(\"1100011\", \"1000111\")\n    string_xor(\"\
    1100011\", \"0100011\")\n    string_xor(\"1100011\", \"00100011\")\n    string_xor(\"\
    1100011\", \"000100011\")\n    string_xor(\"1100011\", \"11110011\")\n    string_xor(\"\
    1100011\", \"11101111\")\n    string_xor(\"1100011\", \"1011111\")\n    string_xor(\"\
    1100011\", \"111100\")\n    string_xor(\"1100011\", \"111011\")\n    string_xor(\"\
    1100011\", \"101111\")\n    string_xor(\"1100011\", \"111111\")\n    string_xor(\"\
    1100011\", \"110110\")\n    string_xor(\"1100011\", \"11010\")\n    string_xor(\"\
    1100011\", \"1101\")\n    string_xor(\"1100011\", \"11011\")\n    string_xor(\"\
    1100011\", \"110111\")\n    string_xor(\"1100011\", \"11101\")\n    string_xor(\"\
    1100011\", \"1110111\")\n    string_xor(\"1100011\", \"11101111\")\n    string_xor(\"\
    1100011\", \"111011111\")\n    string_xor(\"1100011\", \"111100111\")\n    string_xor(\"\
    1100011\", \"111100111011\")\n    string_xor(\"1100011\", \"1111001110111\")\n\
    \    string_xor(\"1100011\", \"1111001011\")\n    string_xor(\"1100011\", \"11110010111\"\
    )\n    string_xor(\"1100011\", \"11110011101111\")\n    string_xor(\"1100011\"\
    , \"111100111011111\")\n    string_xor(\"1100011\", \"1111001110111011\")\n  \
    \  string_xor(\"1100011\", \"11110011101110111\")\n    string_xor(\"1100011\"\
    , \"111100111011101111\")\n    string_xor(\"1100011\", \"11110011", "  ab = a.to_s(2).dup\n\
    \  ba = b.to_s(2).dup\n  result = ''\n  until ab.length == ba.length\n    ab,\
    \ ba = a_bitwise(ab, ba)\n    result << (ab ^ ba)\n  end\n  result\nend", "  #\
    \ Convert binary representation to decimal number\n  n = bintodec(hextobin(a))\n\
    \  m = bintodec(hextobin(b))\n  \n  # Binary XOR result\n  c = bintodec(xor(bintodec(hextobin(n)),\
    \ bintodec(hextobin(m))))", "  xor = a^b\n  xor = \"0\" * (xor.length % 2) + xor.to_s\
    \ + \"0\" * (xor.length % 2)\n  xor\nend", "  result = \"\"\n  for i in 0..a.length\n\
    \    result << a[i] ^ b[i]\n  end\n  result\nend", "  xor = (a ^ b)\n  return\
    \ xor\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis is one of the first\
    \ things I tried, but for some reason I get an unexpected error - this looks like\
    \ it's for Ruby on Rails. Am I missing something here?\n<|/ c |>\n<| c |>\nIt\
    \ is for ruby. I use it frequently in my Rails projects as well.\n<|/ c |>\n<|\
    \ c |>\nI get no errors on my end.  What version of Ruby are you using?  What\
    \ OS are you running on?\n<|/ c |>\n<| c |>\nThis is really nice and compact.\
    \ Is it possible to get the same output in ruby without `String#split`?\n<|/ c\
    \ |>\n<| c |>\n, yes, it is possible without `split`.  See my answer.\n<|/ c |>\n\
    <| a tags=ruby,string |>\nIn Ruby 1.8.7, this works:\n<code>\na = \"101010101\"\
    \nb = \"101010110\"", "  xor_result = a.unpack('C*').zip(b.unpack('C*')).map {\
    \ |i| i[0]^i[1] }\n  xor_result.pack('c*')\nend\n</code>\nNow let's try it out:\n\
    <code>\np string_xor('1100111001', '110011010')", "    a.to_i(2) ^ b.to_i(2)\n\
    end", "    return a ^ b\nend", "    bina = \"0\" * 32 + \"1\" * 32\n    binb =\
    \ \"0\" * 32 + \"0\" * 32\n    x = bina.split('0')\n    y = binb.split('0')\n\
    \    z = \"\"\n    for i in range(32):\n        z += chr(ord(a[x][i]) ^ ord(b[y][i]))\n\
    \    return z", '  raise "Binary XOR cannot be performed on string inputs" unless
    a.size == b.size', "  xor = a.unpack('C*')\n  xor.each_index do |i|\n    xor[i]\
    \ = xor[i].ord.xor(b[i].ord).chr\n  end\n  xor.join\nend", "  a_and_b = a.chars.map{|x|\
    \ x.ord ^ b.ord}.join\n  a_and_b.force_encoding(Encoding::ASCII_8BIT)\nend", " \
    \ \n  a_bin = bin(a) # convert a to binary\n  b_bin = bin(b) # convert b to binary\n\
    \  \n  result_bin = '' # concatenate binary values of two strings\n  \n  # perform\
    \ XOR on individual bits of strings\n  for i in 0..a.length-1 # loop through strings\n\
    \    result_bin += a_bin[i] ^ b_bin[i] # XOR and append\n  \n  return result_bin\n\
    end\n</code>\nHere are some examples of how to use string_xor:\n<code>\nstring_xor('0001',\
    \ '0010')", "  result = 0\n  a.each_byte do |ch|\n    result <<= 1\n    result\
    \ |= ch ^ b.byte(b.length - 1)\n  end\n  result\nend\n</code>\n<|/ a tags=cryptography,xor,binary,string,ruby\
    \ |>\n<| c |>\nWow, this is some nifty code. I'm not sure if this is Ruby's way\
    \ to go about this problem or if it's something specific to my Ruby environment,\
    \ but it works well in most cases, so thank you for sharing!\n<|/ c |>\n<| c |>\n\
    This method is incorrect. In the line `a.each_byte { |ch| result << 1 }` the `ch`\
    \ variable is of type `Integer`. You should use `a.each_byte { |ch| result <<\
    \ 1 }` instead.\n<|/ c |>\n<| c |>\n: Thanks for catching my typo!\n<|/ c |>\n\
    <| a |>\nHere is a simple solution which works with Ruby versions up to 2.5.\n\
    <code>", "    if a.length == 0 or b.length == 0\n        return \"0\"\n    end\n\
    \    c = \"\"\n    i = 0\n    while i < a.length\n        if a[i] ^ b[i] == 1\n\
    \            c << a[i]\n            i += 1\n        end\n    end\n    return c\n\
    end", "  result = a\n  result ^= b\n  result\nend", "  # Convert each character\
    \ to a number.\n  # 'a' is first character in each string, 'b' is second character\
    \ in each string.\n  a_bits = a.each_char.map { |c| c =~ /./; c.to_i }\n  b_bits\
    \ = b.each_char.map { |c| c =~ /./; c.to_i }\n  # Bitwise XOR the two numbers.\n\
    \  xor_bits = a_bits ^ b_bits\n  # Convert each number back to a character.\n\
    \  # For each character, multiply by the length of the character and add back\
    \ the character.\n  # Convert the result to a string.\n  xor_chars = xor_bits.map\
    \ { |c| (c * a.length + a.first).chr }.join(\"\")\n  return xor_chars\nend", " \
    \   binary_a = a.split('').map(&:to_i)\n    binary_b = b.split('').map(&:to_i)\n\
    \    return binary_a.zip(binary_b).map { |e| e[0].to_s(2) + e[1].to_s(2) }.join\n\
    end", "  if a.length != b.length\n    raise \"Inputs must have same length\"\n\
    \  end\n  result = \"\"\n  for i in 0...a.length\n    result += (Integer(a[i])\
    \ ^ Integer(b[i])) + \" \"\n  end\n  return result\nend", "  bin = \"\"\n  a.each_byte\
    \ { |e| bin << [e ^ b].pack(\"c\") }\n  return bin\nend", "  result = \"\"\n \
    \ a.each_byte {|x| result << x[b]}\n  return result\nend", "  c = ''\n  a.each_byte\
    \ { |c| c ^= b }\n  a\nend\n</code>\nThen we need a way to iterate over the ASCII\
    \ characters of a given string (also known as a String#codepoints). We can do\
    \ this using each_byte on a string:\n<code>", "  return [a.gsub(/[01]/, ''), b.gsub(/[01]/,\
    \ '')].reduce(:^)\nend", "  result = \"\"\n  for i in 0...b.length\n    result\
    \ << b.chars[i] ^ a.chars[i]\n  end\n  result\nend", "   a.each_byte {|b| b ^=\
    \ b.to_i}\n   b.each_byte {|b| b ^= b.to_i}\n   a.each_byte {|b| b.to_s}\nend",
  "    bits = a.unpack('H2'*a.length).inject([]) { |bits,i| bits << \"1#{(i == b.unpack('H2'*b.length).join('0'))}\"\
    .chr }\n    bits.join('')\nend\n</code>\n<|/ a |>\n<| a |>\nI believe you can\
    \ do this with only one function call:\n<code>", "  if a.length != b.length\n\
    \    puts \"The length of a and b are not equal\"\n  else\n    puts \"The xor\
    \ of the two strings is #{b.ord.to_s(2).rjust(8,'0')}\"\n  end\nend", "  result\
    \ = ''\n  a.each_byte {|c| result += ((c^b.bytes[c]) % 2)}\n  return result\n\
    end", "  a.chars.reduce(:^)\nend", "  a = a.to_s\n  b = b.to_s\n  result = a.to_s\n\
    \  a.each_byte do |x|\n    result.prepend('0' if x ^ b.slice!(0, 1))\n  end\n\
    \  result\nend", "    bina = \"\"\n    binb = \"\"\n    bina = [int(x) for x in\
    \ a]\n    binb = [int(x) for x in b]\n    bina = [1 if x==1 else 0 for x in bina]\n\
    \    binb = [1 if x==1 else 0 for x in binb]\n    bina = \" \".join(bina)\n  \
    \  binb = \" \".join(binb)\n    x = bina ^ binb\n    x = format(x, 'b')\n    x\
    \ = x.zfill(len(a))\n    return x", "  # If both strings are of same length, return\
    \ empty string\n  return a if (a.length == b.length) && a.eql?(b) else \"\"\n\
    end", "  # Convert to binary\n  ab = bin( a ^ b )[2:].zfill(8)", "  return a.gsub(/[01]/)\
    \ {|i| b ^ i}.gsub(/[01]/) {|i| a ^ i}\nend", "  return \"#{$a} xor #{$b}\" if\
    \ a.length != b.length\n  return [a.chars.map { |c| a.index(c) ^ b.index(c) }].pack('c*')\n\
    end", "  res = \"\"\n  for i in 0..(b.length-1)\n    res << b[i] ^ a[i] \n  end\n\
    \  return res\nend\n</cell>\n<cell>", "  result =  a.scan(/(\\w+)/g).inject(0)\
    \ { |acc, x| acc ^ x.to_i }\n  result\nend\n</cell>\n<text>\nNow let's try it\
    \ out on our example:", "  ret = a\n  ret ^= b\n  return ret\nend\n</code>\nIt\
    \ also works with symbols. I assume that you're working with strings that only\
    \ contain 0s and 1s.\n<code>", "    # Return empty string if either input string\
    \ is empty.\n    return \"\" if a.length == 0 || b.length == 0 || !(a.length ==\
    \ b.length && a.chars.all? { |c| c == '0' || c == '1' }) \n    return a.chars.map\
    \ { |c| c == '0' ? b : a }.join\nend", "    l = len(a)\n    m = len(b)\n    if\
    \ l != m:\n        return \"Binary XOR works on strings of same size\"\n    result\
    \ = \"\"\n    for i in xrange(0, l):\n        result += chr(int(a[i]) ^ int(b[i]))\n\
    \    return result\n</code>\nHope this helps\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for your suggestion, unfortunately this doesn't really address my problem as\
    \ this simply outputs the original string. My question was specifically about\
    \ the algorithm itself rather than just getting the correct output string.\n<|/\
    \ c |>\n<| a tags=python,algorithm,python-2.7 |>\nHere is one way to do this in\
    \ Python:\n<code>", "  a.each_byte {|x| a.each_byte {|y| a << y ^ x } }\n  b.each_byte\
    \ {|x| b.each_byte {|y| b << y ^ x } }\n  a\nend", "  return [((a ^ b) % 2).to_s(2)].pack('H*')\n\
    end", "  c = a\n  c.each_byte { |b| c << b.to_s }\n  c.each_byte { |b| c << b.to_s\
    \ }\n  c << b\n  c\nend", "  return (\"%064b\" % [(a^b)].pack('N')).unpack(\"\
    H*\")[0]\nend", "    a_nums = a.split(//)\n    b_nums = b.split(//)\n    \n  \
    \  # Convert strings to binary numbers\n    a_nums_bin = []\n    for a in a_nums\n\
    \        a_nums_bin.push(bin.to_bnumber(a))\n    \n    b_nums_bin = []\n    for\
    \ b in b_nums\n        b_nums_bin.push(bin.to_bnumber(b))\n    \n    # Perform\
    \ binary XOR on two strings' binary numbers\n    # and return result as a string\n\
    \    result = []\n    result.push(bin.to_bnumber(a_nums_bin).xor bin.to_bnumber(b_nums_bin))\n\
    \    return result.to_s\nend", "  xor_result = \"\"\n  a.each_byte do |x|\n  \
    \  xor_result << x\n  end\n  b.each_byte do |x|\n    xor_result << x\n  end\n\
    \  return xor_result\nend", "  # convert strings to char arrays\n  ca = a.chars\n\
    \  cb = b.chars", "  # Return empty string if one or both inputs are empty.\n\
    \  if a.empty? || b.empty?\n    return \"\"\n  end", "  result = ''\n  for i in\
    \ 0..(b.length-1)\n    result += (a[i..i+1]^b[i..i+1])\n  end\n  return result\n\
    end", "    a_int = to_int(a)\n    b_int = to_int(b)\n    return to_str(intxor(a_int\
    \ ^ b_int , a_int))\nend\n</cell>\n<code language=julia-1.5>", "  xor_str = \"\
    0\";\n  for c = 0; c < b.length; c++\n    xor_str = xor_str + x[c].to_s + x[b[c]].to_s\
    \ + \"1\";\n  end\n  xor_str.chomp!\n  return xor_str;\nend", "  # Convert each\
    \ string to an array of integers\n  a = a.split(\"\")\n  b = b.split(\"\")\n \
    \ # Convert the array of integers into an array of binary strings\n  a = a.map\
    \ { |e| bin(e) }\n  b = b.map { |e| bin(e) }\n  # Perform XOR and join back into\
    \ a string\n  return a.map { |e| e[1] ^ e[2] }.join(\"\").to_s(2)\nend\n</code>\n\
    <|/ a |>\n<| a |>\nHere's a solution that uses some of your ideas.  It's not pretty,\
    \ but it works.\n<code>", "  result = a\n  result << b\n  result\nend", "  result\
    \ = ''\n  a.each_byte do |i|\n    result << i ^ b[i.succ]\n  end\n  return result\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
