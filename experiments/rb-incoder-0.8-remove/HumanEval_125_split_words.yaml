name: HumanEval_125_split_words
language: rb
prompt: "# Given a string of words, return a list of words split on whitespace, if\
  \ no whitespaces exists in the text you\n# should split on commas ',' if no commas\
  \ exists you should return the number of lower-case letters with odd order in the\n\
  # alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n# Examples\n# >>> split_words(\"\
  abcdef\") \n# 3\ndef split_words(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n\
  \    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"],\
  \ candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"\
  Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello\
  \ world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"\
  Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2,\
  \ candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n \
  \   assert_equal(0, candidate.call(\"\"))\n  end\nend\n"
completions: ["  words = txt.split(\" \")\n  if words.count != 0\n    words.count\n\
    \  else\n    words.count(\",\".to_sym)\n  end\nend", "  words = txt.split(' ')\n\
    \  count = words.count('') #number of empty words\n  count += words.count(',')\
    \ + words.count(','.downcase) - words.count('.') #count the number of commas,\
    \ dots and letters\n  count = count.to_i\n  return count if count > 0 \n  words.each\
    \ { |x| x.split(//).count { |y| y == '' } } #count the number of empty words\n\
    end", "    words = txt.split(\" \") #create an array of words\n    return words.length\
    \ if words.count != 0 else words.count + 1 #return length of array or return length\
    \ of array + 1\nend\n</cell>\n<cell>", "    words = txt.split(' ')\n    return\
    \ words.length if words.all? { |w| !w.empty? } || words.all? { |w| w.downcase.count\
    \ 'a' }.odd? \n    words.size \nend", "  txt.downcase!\n  txt.each_char.with_index\
    \ do |char, index|\n    if char == ',' \n      words += 1\n    elsif char == '\
    \ '\n      words -= 1\n    end\n  end\n  words.to_i\nend\n</code>\nThe above code\
    \ uses each_char to enumerate over the string, passing each character and its\
    \ index to the block. Then in the block, if the character is a comma or space,\
    \ increment the words counter and decrement it if it is a space, else increment\
    \ the words counter by one if the character is a comma, otherwise by -1 if the\
    \ character is a space.\nThe return value of the block is the number of words\
    \ found. You can use Enumerable#with_index to return the count (by using the index),\
    \ or use Enumerable#count if you want a Hash where the key is the count and the\
    \ value is an array of the words found:\n<code>\n\"a, b, c\".each_char.with_index.count\
    \ do |char, index|\n  char == ',' || char == ' '\nend", "  words = []\n  if txt.include?('\
    \ ')\n    words = txt.split(' ')\n  else\n    words = txt.split(',')\n  end\n\
    \  words.each do |word|\n    word.split('').each do |char|\n      if char.ord('a')\
    \ <= char.ord('z')\n        if char.ord('a') > char.ord('z')\n          if char.ord('a')\
    \ > char.ord('z')\n            words[words.index(word) + 1] += ',' + char\n  \
    \        end\n          words[words.index(word) + 1] += char\n        end\n  \
    \    else\n        if char.ord('z') > char.ord('a')\n          if char.ord('z')\
    \ > char.ord('a')\n            if char.ord('z') > char.ord('a')\n            \
    \  words[words.index(word) + 1] += ',' + char\n            end\n            words[words.index(word)\
    \ + 1] += char\n          end\n          words[words.index(word) + 1] += char\n\
    \        end\n      end\n    end\n  end\n  words.uniq\nend", "  words = []\n \
    \ whitespaces = []\n  commas = []\n  lowercase_letters = []", "  words = txt.split\
    \ (' ')\n  words.uniq.each do |word|\n    if word.start_with?(\",\")\n      words[word.index(\"\
    ,\")+1..-1].each do |word|\n        if word.start_with?(\",\")\n          words[word.index(\"\
    ,\")+1..-1].uniq.each do |word|\n            words[word.index(\",\")+1..-1].each\
    \ do |word|\n              words.uniq.push(\"#{word}\")\n            end\n   \
    \       end\n        end\n      end\n    end\n    words.uniq.push(\"#{word}\"\
    )\n  end\n  words.length-1\nend", "    return txt.split(' ') if txt.size % 2 ==\
    \ 0 else txt.split(',')\nend", "    return txt.split(' ') if ' ' in txt else txt.split(',')\n\
    \    ", "    txt_splitted = txt.split\n    word_list = []\n    letter_list = [ord('a'),\
    \ ord('b'), ord('c'), ord('d'), ord('e'), ord('f'), ord('g'), ord('h'), ord('i'),\
    \ ord('j'), ord('k'), ord('l'), ord('m'), ord('n'), ord('o'), ord('p'), ord('q'),\
    \ ord('r'), ord('s'), ord('t'), ord('u'), ord('v'), ord('w'), ord('x'), ord('y'),\
    \ ord('z')]\n    for i in txt_splitted\n        word_list.push(i)\n        letter_list.each{|x|\
    \ word_list.push((x.to_s.downcase).gsub(/\\s/, ''))}\n    word_list.each_with_index\
    \ {|word, i|\n        word_list[i] = word_list[i].gsub(/,/, ', ').strip.downcase\n\
    \    }\n    word_list.uniq.count\nend", "    words = txt.split(\" \")\n    if\
    \ words.count && words.first && words.last && words.all? { |word| word.length.odd?\
    \ }\n        return words.size\n    end\n    words.count + words.map { |w| w.split(\"\
    ,\").count }.max\nend\n    ", "  words = txt.split\n  words.each do |word|\n \
    \   if word.length > 0\n      return word.length\n    else\n      return (word.length\
    \ / 2)\n    end\n  end\nend\n</code>\nThis should work for you. I hope this helps!\n\
    <|/ a tags=ruby dscore=0 |>\n<| c |>\nNo need for `each`, you can call `.length`\
    \ directly on the `word` variable.\n<|/ c |>\n<| c |>\nI suppose I should mention\
    \ that this solution is case sensitive (which is not the case).\n<|/ c |>\n<|\
    \ c |>\nNot only that, but `word.length` will never return `nil`.\n<|/ c |>\n\
    <| c |>\n`word.length` will never return `nil` in this case, because `word` is\
    \ an instance of `Array` and therefore will never be `nil`. `word` is an `Array`\
    \ of `String`s, therefore `word.length` will return the length of each `String`.\n\
    <|/ c |>\n<| c |>\n: You are right! I did a lot of things that I shouldn't have.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou were very close to it, just a few changes: \n\
    <code>", "    txt.split(%r{\\s+})\nend", "    txt = txt.downcase\n    words =\
    \ txt.split(' ')\n    word_list = []\n    word_count = 0\n    count = 0\n    for\
    \ word in words\n        word = word.strip\n        word_count = word_count +\
    \ 1\n        word = word.split(',').map(&:strip)\n        count = count + word.length\n\
    \        word_list << word\n        if count > 26 \n            word_list.insert(word_count,\
    \ \"\")\n            word_count = word_count + 1\n            count = 0\n    \
    \    end = word.length - 1\n        word_list[word_count].insert(end,\" \")\n\
    \    end\n    return word_list\nend\n</code>\n<|/ a dscore=0 tags=ruby |>\n<|\
    \ a |>\nHere's a variation on Mohammad Abdallah's answer that uses only a regular\
    \ expression to split the string. I'm not entirely convinced that this solution\
    \ is more elegant than mine though:\n<code>", "    words = txt.split(\" \") \n\
    \    return words.length if words.length > 0 else txt.length / txt.count(\"a\"\
    )\nend", "    # Write your code here\n    words = txt.split(' ')\n    \n    return\
    \ len([word for word in words if word.isalpha() and len(word) % 2 == 1])", " \
    \   words = txt.split(' ')\n    count = words.count('')\n    if count > 0: return\
    \ count\n    words = words.split(',')\n    count = words.count('')\n    if count\
    \ > 0: return count\n    words = words.split('-')\n    count = words.count('')\n\
    \    if count > 0: return count\n    count = words.count('-')\n    if count >\
    \ 0: return count\n    words = words.split('^')\n    count = words.count('')\n\
    \    if count > 0: return count\n    count = words.count('^')\n    if count >\
    \ 0: return count\n    words = words.split('~')\n    count = words.count('')\n\
    \    if count > 0: return count\n    count = words.count('~')\n    if count >\
    \ 0: return count\n    words = words.split(';')\n    count = words.count('')\n\
    \    if count > 0: return count\n    count = words.count(';')\n    if count >\
    \ 0: return count\n    words = words.split(':')\n    count = words.count('')\n\
    \    if count > 0: return count\n    count = words.count(':')\n    if count >\
    \ 0: return count\n    count = words.count(':')\n    if count > 0: return count\n\
    \    words = words.split(',,')\n    count = words.count('')\n    if count > 0:\
    \ return count\n    count = words.count(',')\n    if count > 0: return count\n\
    \    count = words.count(',')\n    if count > 0: return count\n    words = words.split(',;')\n\
    \    count = words.count('')\n    if count > 0: return count\n    count = words.count(';')\n\
    \    if count > 0: return count\n    count = words.count(',')\n    if count >\
    \ 0: return count\n    count = words.count(';')\n    if count > 0: return count\n\
    \    words = words.split('--')\n    count = words.count('')\n    if count > 0:\
    \ return count\n    count = words.count('--')\n    if count > 0: return count\n\
    \    words = words.split('-;')\n    count = words.count('')\n    if count > 0:\
    \ return count\n    count = words.count(';')\n    if count > 0: return count\n\
    \    count = words.count('-')\n    if count > 0: return count\n    count = words.count(';')\n\
    \    if count > 0: return count\n    count = words.count('-')\n    if count >\
    \ 0: return count\n    count = words.count(';')\n    if count > 0: return count\n\
    \    count = words.count('-')\n    if count > 0: return count\n    count = words.count('-')\n\
    \    if count > 0: return count\n    count = words.count('-')\n    if count >\
    \ 0: return count\n    count = words.count('-", "  words = txt.split(//) # Split\
    \ on whitespace\n  return words.length if words.all? { |word| word.size != 0 and\
    \ word.scan(/[A-Z]/) }\n  words.count { |word| word.size != 0 and word.scan(/[A-Z]/)\
    \ }\nend", "  txt.scan(/[\\w']+/).select { |w| w =~ /\\s/ }.count\nend", "\twords\
    \ = txt.split(\" \") #split on whitespace\n\twords = [word for word in words if\
    \ word != \"\"] #remove empty words\n\tif len(words) == 1: return 1\n\twordCount\
    \ = 1\n\tlowerLettersCount = 1\n\tfor i in xrange(len(words)):\n\t\tif words[i]\
    \ not in \",\\n\": lowerLettersCount += 1\n\t\telse: wordCount += 1\n\treturn\
    \ wordCount + lowerLettersCount", "  # Write your code here\n  words = txt.split(\"\
    \ \")\n  count = 0\n  for word in words\n    if word !~ /\\s/\n      count+=1\n\
    \    else \n      if count == 1\n        word\n      else \n        words\n  words.map!{|w|\
    \ w.gsub(/\\,/, \"\")}\n  words.map!{|w| w.gsub(/\\./, \"_\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  words.map!{|w|\
    \ w.gsub(/\\-/, \"\")}\n  words.map!{|w| w.gsub(/\\-/, \"\")}\n  ", "  words =\
    \ txt.split(' ')\n  words.compact!\n  words.delete_if{|w| w.blank?}\n  words.delete_if{|w|\
    \ w =~ /[,.]/}\n  words.delete_if{|w| w =~ /^[A-Z]/}\n  return words.length if\
    \ words.length % 2 != 0\n  words.size / 2 # number of lower-case letters with\
    \ odd order\nend\n</cell>\n<text>\nProblem 3", "  words = txt.split(' ')\n  words.length.times\
    \ do\n    words.slice!(1).join(',')\n  end\n  words.join(',')\nend", "  words\
    \ = txt.split(' ')\n  if words == nil\n    return 0\n  end\n  words.each do |word|\n\
    \    if word.include? ','\n      word.gsub!(',', '')\n    end\n  end\n  words.count('a')\
    \ + words.count('b') + words.count('c') + words.count('d') + words.count('e')\
    \ + words.count('f') + words.count('g') + words.count('h') + words.count('i')\
    \ + words.count('j') + words.count('k') + words.count('l') + words.count('m')\
    \ + words.count('n') + words.count('o') + words.count('p') + words.count('q')\
    \ + words.count('r') + words.count('s') + words.count('t') + words.count('u')\
    \ + words.count('v') + words.count('w') + words.count('x') + words.count('y')\
    \ + words.count('z')\nend\nputs split_words('abcdef')", "  txt.split(\" \") unless\
    \ txt.include?(' ')\n  txt.split(',') unless txt.include?(',')\n  txt.chars.sort.each_with_index.inject(0)\
    \ do |sum, i| \n    sum + (i % 2 == 1) ? i.to_i + 1 : i.to_i + 26\n  end\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThis is a great answer and I appreciate\
    \ the explanation!\n<|/ c |>\n<| c |>\nI wanted to up-vote this answer, but it\
    \ doesn't seem to be working since my ruby version isn't 2.1.2\n<|/ c |>\n<| c\
    \ |>\nYour ruby version is old and doesn't have `chars` method, but in 2.1.2 you\
    \ can replace `txt.chars.sort` with `txt.chars.sort {|a,b| a <=> b }`\n<|/ c |>\n\
    <| a |>\nJust to add on to what others have already suggested, here's another\
    \ approach to doing this in Ruby that might be easier to read:\n<code>", "  txt\
    \ = txt.downcase.strip unless txt.include?(' ')\n  words = txt.split(' ')\n  words.each\
    \ {|word| word.downcase!}\n  words.each {|word| word.split(//, 1).map {|letter|\
    \ letter.to_i}}\n  words.map {|word| word.scan(/[a-z]/).size}\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,algorithm,ruby,split |>\n<| c |>\nThis works great for\
    \ my needs. I am going to try to remember to come back and mark this as answered\
    \ when I can in a couple days. Thanks!\n<|/ c |>\n<| c |>\nThis was a great help.\
    \ Thank you!\n<|/ c |>\n<| a tags=ruby-on-rails,algorithm,ruby,split |>\nMy two\
    \ cents is to look at it as a different problem, because you want to find words\
    \ whose length are odd, and their positions are even:\n<code>\nwords = 'asdf asdfl\
    \ asdf'\nwords.split(//).each_slice(2).select { |w1, w2| w1.length == w2.length\
    \ }.count", "    words = txt.split(' ')\n    if words[2] != ','\n        words[2]\
    \ = ','\n        words.insert(3, ' ')\n    words.delete_at(3)\n    return words.count\n\
    end\n</cell>\n<code language=julia-1.4>", "  return txt.split(' ').inject(0) do\
    \ |sum, str|\n    return 0 if sum % 2 == 1 && str.length % 2 != 0\n    return\
    \ sum + str.length if str.split(//).any? { |x| x.downcase != x }\n    sum + 1\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nI have found a solution\
    \ using Ruby 2.2.0. Hope it helps:\n<code>", "  words = txt.split\n  words = words.to_i\n\
    \  words.odd? ? words.reduce(0) { |sum, n| sum + n } : words.reduce(0) { |sum,\
    \ n| sum + n } + 1.ord\nend", "  txt = txt.downcase\n  txt = txt.gsub(\",\",\"\
    \")\n  words = txt.split(\" \").count\n  words.to_i\nend\n</cell>\n<cell>", " \
    \ word = \"\"\n  word_count = 0\n  lowers = 0\n  word_list = []\n  for char in\
    \ txt\n    word += char\n    if char =~ /\\s/\n      word_count += 1\n    else\n\
    \      word_count += lowers\n      lowers = 0\n      if word.length % 2 == 1\n\
    \        word_list << word\n        word = \"\"\n      end\n    end\n  end\n \
    \ if word.length > 0\n    word_list << word\n  end\n  return word_count\nend",
  "  result = txt.split(' ')\n  if result.length == 1\n    return 0\n  result = result[0].split(',')\n\
    \  word_count = 0\n  lower_letter_count = 0\n  for i in result\n    if i.length\
    \ == 1 && (i.upcase >= i.downcase)\n      lower_letter_count += 1\n    else\n\
    \      word_count += 1\n  word_count += lower_letter_count\n  return word_count\n\
    end", "  words = txt.split(' ')\n  words.delete_if { |word| word.empty? }\n  words.delete_if\
    \ { |word| word !~ /[!a-z]/i }\n  words.delete_if { |word| word !~ /[!A-Z]/i }\n\
    \  words.delete_if { |word| word !~ /[!0-9]/i }\n  words.delete_if { |word| word\
    \ !~ /[!,]/i }\n  words.delete_if { |word| word !~ /[!.]/i }\n  words.delete_if\
    \ { |word| word !~ /[!!]/i }\n  words.delete_if { |word| word !~ /[!?]/i }\n \
    \ words.delete_if { |word| word !~ /[!!]/ }\n  words.delete_if { |word| word !~\
    \ /[!?!]/ }\n  words.delete_if { |word| word !~ /[!?!]/ }\n  words.delete_if {\
    \ |word| word !~ /[!?!]/ }\n  words.delete_if { |word| word !~ /[!?!]/ }\n  words.delete_if\
    \ { |word| word !~ /[!?!]/ }\n  words.delete_if { |word| word !~ /[!?!]/ }\n \
    \ words.delete_if { |word| word !~ /[!?!]/ }\n  words.delete_if { |word| word\
    \ !~ /[!?!]/ }\n  words.delete_if { |word| word !~ /[!?!]/ }\n  words.delete_if\
    \ { |word| word !~ /[!?!]/ }\n  words.delete_if { |word| word !~ /[!?!]/ }\n \
    \ words.delete_if { |word| word !~ /[!?!]/ }\n  words.delete_if { |word| word\
    \ !~ /[!?!]/ }\n  words.delete_if { |word| word !~ /[!?!]/ }\n  words.delete_if\
    \ { |word| word !~ /[!?!]/ }\n  words.delete_if { |word| word !~ /[!?!]/ }\n \
    \ words.delete_if { |word| word !~ /[!?!]/ }\n  ", "    words = txt.split.join(\"\
    \ \")\n    words = \"#{words}\".split(\" \").count\n    return words\nend", " \
    \ words = txt.split(\" \")\n  \n  words.each do |w|\n    w.gsub!(\",\", \" \"\
    )\n    w.gsub!(\",\", \" \").upcase\n  end\n  words.uniq!", "  result = txt.split(\"\
    \ \") \n  result.map! do |x| \n    if x.include?(\",\") \n      x.split(\",\"\
    ).map { |word| word.downcase.count(\"a\") }\n    else\n      x.downcase.count(\"\
    a\")\n    end\n  end\n  result.inject(:+)\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=0 |>\n<| c |>\nI think you mean `result.map! {|x| if x.include?(\",\"\
    ) x.split(\",\").map(&:downcase).count(&:odd?) else x.downcase.count(\"a\") end}`\
    \ since you want the number of non-`\"a\"` letters.\n<|/ c |>\n<| c |>\nNope.\
    \ Try `split_words(\"a a b c c c d e f g\")` which outputs `0`.\n<|/ c |>\n<|\
    \ c |>\n, Oh yes, you're right. I didn't catch it until I saw the edit, sorry.\
    \ Fixed.\n<|/ c |>\n<| c |>\nI wonder what happens if you pass a multi-digit word\
    \ like `'12abc'`. You will count the letters in all numbers first. E.g. `'12abc'.split('\
    \ ').map{|word| word.count(\"a\")}`\n<|/ c |>\n<| a tags=ruby,arrays dscore=0\
    \ |>\nHere's one way to do it:\n<code>", "    words = []\n    word = \"\"\n  \
    \  l = len(txt)\n    while l > 0:\n        c = txt[l - 1]\n        if c == ',':\n\
    \            words.append(word)\n            word = \"\"\n        elif c == '\
    \ ':\n            words.append(word)\n            word = \"\"\n        else:\n\
    \            word += c\n        l -= 1\n    words.append(word)\n    return len([w\
    \ for w in words if w != \"\"])", "  txt.split(/\\s+/).inject(:+)\nend", "\ttxt.count(\"\
    ,\") != 0 ? txt.split(\",\") + [txt.count(\",\").to_i] : [txt.downcase.chars.count.to_i]\n\
    end", "  words = txt.split(\" \").map {|s| s.downcase}\n  words.delete_if {|s|\
    \ s.empty? }\n  words.delete_if {|s| s.include?(\",\") }\n  words.delete_if {|s|\
    \ s.include?(\",.\") }\n  return words.length\nend\n</code>\n<|/ a |>\n<| a dscore=1\
    \ tags=ruby,arrays |>\nYou can use gsub to replace all occurrences of \",\" with\
    \ \", \"\n<code>\ntext.gsub(/,/, \", \").split.map(&:downcase).join\n</code>\n\
    <|/ a |>\n<| a tags=ruby,arrays |>\nYou can try below - \n<code>", "  return txt.split('\
    \ ') if txt.count ' ' > 0 else  txt.count(',') if txt.count(',') > 0 else  txt.length\n\
    end", "    txt.scan(/\\w*/).flatten.uniq.length\nend", "    splitted = []\n  \
    \  word = \"\"\n    count = 0\n    for c in txt:\n        if c == \" \":\n   \
    \         if word != \"\":\n                splitted.append(word)\n          \
    \      word = \"\"\n            count = 1\n        else:\n            count +=\
    \ 1 if c == \"\\n\" else 0\n            word += c", "  words = txt.split\n  words[0..-2].each\
    \ do |word|\n    next unless word.strip != ''\n    next unless word.strip != '\
    \ '\n    break word.strip.count <= 1 ? 1 : word.strip.count * 25\n  end\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,string |>\n<| c |>\nThanks so much for the effort,\
    \ I appreciate it. I actually came up with a similar solution in a different way.\
    \ I used a regex to search for all instances of whitespace and commas and then\
    \ used a counter variable to keep track of the number of words and used the modulo\
    \ operator to determine odd/even numbers. Thanks again for your help!\n<|/ c |>\n\
    <| c |>\nHmm, I think I misunderstood your original question. Maybe you should\
    \ add that to your question\n<|/ c |>\n<| c |>\nSorry, yeah I must have confused\
    \ the problem a little bit. Well I guess my problem is that I wasn't able to get\
    \ the logic down using regex or anything similar. Your solution works perfectly\
    \ though, and I appreciate all the help you've given me to think through this.\n\
    <|/ c |>\n<| a tags=ruby,string |>\nTo find the number of words with even number\
    \ of characters, you can use a simple regex /\\w(?=(\\w))/ to find all words followed\
    \ by another word and then use length on the result array to find out the even\
    \ number of the words.\n<code>", "    word_count = {}\n    words = txt.split('\
    \ ')\n    for word in words\n        word = word.downcase\n        word_count[word]\
    \ ||= 0\n        word_count[word] += 1\n    \n    sorted_words = [word for word,\
    \ count in word_count.sort { |a, b| b[1] <=> a[1] }]\n    \n    return word_count.length\
    \ if sorted_words.length == word_count.length\n    return sorted_words.length\
    \ if sorted_words.sort.length == 26\n    \nend\n</code>\nYou will need to change\
    \ some code in your other methods so your app doesn't break.\n<|/ a dscore=2 |>\n\
    <| a tags=ruby |>\n<code>", "  words = txt.split(//)\n  words.each do |word|\n\
    \    word.downcase!\n  end\n  words.uniq!\n  words.sort!\n  words.length\nend\n\
    </code>\n3.\nWrite a method called reverse_letters that should take in a string\
    \ that has letters in lower case and return the string in reverse order with the\
    \ letters lower case (e.g A becomes z and z becomes A).\nExamples\n>>> reverse_letters(\"\
    zab\")\n'abz'\n>>> reverse_letters(\"zya\")\n'yza'\n>>> reverse_letters(\"a\"\
    )\n'a'\n>>> reverse_letters(\"ab\")\n'ab'\n>>> reverse_letters(\"zab\")\n'abz'\n\
    >>> reverse_letters(\"zya\")\n'yza'\n>>> reverse_letters(\"a\")\n'a'\n>>> reverse_letters(\"\
    ab\")\n'ab'\n>>> reverse_letters(\"zab\")\n'abz'\n>>> reverse_letters(\"zya\"\
    )\n'yza'\n>>> reverse_letters(\"a\")\n'a'\n>>> reverse_letters(\"ab\")\n'ab'\n\
    >>> reverse_letters(\"zab\")\n'abz'\n>>> reverse_letters(\"zya\")\n'yza'\n>>>\
    \ reverse_letters(\"a\")\n'a'\n>>> reverse_letters(\"ab\")\n'ab'\n>>> reverse_letters(\"\
    zab\")\n'abz'\n>>> reverse_letters(\"zya\")\n'yza'\n>>> reverse_letters(\"a\"\
    )\n'a'\n>>> reverse_letters(\"ab\")\n'ab'\n>>> reverse_letters(\"zab\")\n'abz'\n\
    >>> reverse_letters(\"zya\")\n'yza'\n>>> reverse_letters(\"a\")\n'a'\n>>> reverse_letters(\"\
    ab\")\n'ab'\n>>> reverse_letters(\"zab\")\n'abz'\n>>> reverse_letters(\"zya\"\
    )\n'yza'\n>>> reverse_letters(\"a\")\n'a'\n>>> reverse_letters(\"ab\")\n'ab'\n\
    >>> reverse_letters(\"zab\")\n'abz'\n>>> reverse_letters(\"zya\")\n'yza'\n>>>\
    \ reverse_letters(\"a\")\n'a'\n>>> reverse_letters(\"ab\")\n'ab'\n>>> reverse_letters(\"\
    zab\")\n'abz'\n>>> reverse_letters(\"zya\")\n'yza'\n>>> reverse_letters(\"a\"\
    )\n'a'\n>>> reverse_letters(\"ab\")\n'ab'\n>>> reverse_letters(\"zab\")\n'abz'\n\
    >>> reverse_letters(\"zya\")\n'y", "    # your code here\n    lst = []\n    for\
    \ letter in txt:\n        if letter in \" \":\n            lst.extend(list(letter))\n\
    \        else:\n            lst.extend(list((ord(letter) - ord('a') + 1) * \"\
    #\"))\n    lst = list(set(lst))\n    return len(lst)", "  words = txt.split(\"\
    \\n\")\n  words.map!(&:split)\n  words.map!(&:uniq)\n  words.map!(&:downcase)\n\
    \  words.map!(&:join)\n  words.map!(&:count)\n  words.map!(&:sort)\n  words.map!(&:select{|word|word.length\
    \ ==1})\n  words.map!(&:join)\nend", "    txt = txt.upcase\n    if txt.split.count\
    \ % 2 == 1\n        txt << \", \"\n    else\n        txt << \", \"\n    end\n\
    \    txt.split.count + txt.split.split.count + 1\nend", "  txt.split(/\\s+/)\n\
    end", "  words = ''\n  letters = []\n  i = 0\n  while i < txt.length\n    letters\
    \ += txt[i]\n    i += 1\n  while i < txt.length\n    letters += txt[i]\n    i\
    \ += 1\n    break if letters.blank?\n    words << letters.downcase\n    letters.empty!\n\
    \  end\n  return words if words.blank?\n  return words.split(',').length % 2 !=\
    \ 0\nend", "  words = txt.split(' ')\n  no_spaced_words = (words.delete_if{|w|\
    \ w.strip.empty?}.length)\n  commad_words = no_spaced_words.delete_if{|w| w.chars.split(',').length\
    \ != words.length}\n  odd_words = (commad_words.to_a - commad_words.first).length\n\
    \  odd_words\nend", "\twords = txt.split\n\tfor i in 0..25\n\t\tif words[i] !~=\
    \ \" \" and words[i] !~= \",\" then \n\t\t\treturn words[i] \n\telse\n\t\treturn\
    \ words.count(\"a\") + words.count(\"b\") + words.count(\"c\") +  words.count(\"\
    d\") + words.count(\"e\") +\n\t\twords.count(\"f\") + words.count(\"g\") + words.count(\"\
    h\") + words.count(\"i\") + words.count(\"j\") +\n\t\twords.count(\"k\") + words.count(\"\
    l\") + words.count(\"m\") + words.count(\"n\") + words.count(\"o\") +\n\t\twords.count(\"\
    p\") + words.count(\"q\") + words.count(\"r\") + words.count(\"s\") + words.count(\"\
    t\") +\n\t\twords.count(\"u\") + words.count(\"v\") + words.count(\"w\") + words.count(\"\
    x\") + words.count(\"y\") + words.count(\"z\")\n\tend\nend", "  return txt.split('\
    \ ').length if txt.include?(\" \") else txt.split(',').length\nend", "  words\
    \ = txt.split / ' '\n  words.shift\n  words.reject { |word| word =~ /[^a-z]/i\
    \ }\n  words.map { |word| word.downcase }.uniq.count\nend\n</code>\n<|/ a |>\n\
    <| a tags=ruby,regex dscore=0 |>\nI thought of posting a pure Ruby solution:\n\
    <code>", "  words = txt.split(\" \").each do |word|\n    word.split(\"\").each\
    \ { |letter| letter << letter[0] if letter[0].upcase <= 'Z' and letter[0].downcase\
    \ >= 'A' and letter[0].downcase <= 'Z' }\n  end\n  words.count{|word| word ==\
    \ \"\"}\nend\n</code>\n<|/ a dscore=3 tags=ruby,algorithm |>\n<| a dscore=1 tags=ruby,algorithm\
    \ |>\nHere's an answer based on regexes (which can be tricky). My solution is\
    \ about three times as slow as others but I thought I'd post it anyway since it\
    \ could be useful for other people:\n<code>", "  split_words = []\n  txt.split(\"\
    \ \").each do |word|\n    if word.size == 0\n      split_words.push(word)\n  \
    \  else\n      split_words.push(word.split(',').size)\n    end\n  end\n  split_words.uniq\n\
    end", "  words = txt.downcase.split(//)\n  return words.length\nend\n</cell>\n\
    <text>\n3.3 Return the sum of all of the numbers that are divisible by 7", " \
    \ words=txt.split(\" \") #splits the string on whitespace\n  if words.empty? then\
    \ words=txt.split(',') #splits the string on commas\n  words.map! { |w| w.downcase\
    \ } #lower-cases each word\n  words.select!(&:empty?) #removes empty words\n \
    \ return words.count + words.select{|w| w.isalpha}.count #returns the number of\
    \ letters with odd order in the alphabet\nend\n</code>\n<|/ a tags=ruby dscore=0\
    \ |>\n<| a |>\n<code>\ns = \"Hello, how are you doing?\"\n</code>\nFirst split\
    \ the words and strip the whitespace, then sort the result alphabetically, then\
    \ count the words that start with an odd (alphabetically) index. \n<code>\ns.split.map\
    \ { |w| w.strip }.sort_by(&:downcase).each_cons(2) do |a,b|\n  a.start_with?(b.downcase)\
    \ ? a.size : -1\nend", "    words = txt.split(\" \")\n    words = words.collect\
    \ { |w| w }\n    words.each { |w| w.tr!('a-z', \"z\") }\n    words.count{|w| w.length}\n\
    end", "\twords = txt.split(' ')\n\treturn words.count(' ') == 0 or words.count(',')\
    \ == 0 ? words.count : words.count(',') + 1\nend", "  words = txt.downcase.split(//)\n\
    \  if words.length == 1\n    words.shift\n    words\n  else\n    words\n  end\n\
    end", "    return splitAndCount(txt, /[a-z]+/, /[a-z,]+/, /[a-z]/)\nend", "  return\
    \ txt.split.size\nend", "  word_array=Array.new()\n  word_array=txt.split(\"\\\
    s+\")\n  word_array=word_array.map do |x| \n    x.gsub!(\",\",\"\")\n    x.gsub!(\"\
    \ \",\"\")\n    x.downcase!\n    x.gsub!(\" \",\"\")\n    x.gsub!(\"'\",\"_\"\
    )\n    x.gsub!(\"!\",\"\")\n    x.gsub!(\"\\n\",\"\")\n    x.gsub!(\"\\r\",\"\"\
    )\n  end\n  word_array=word_array.map do |x| \n    x.gsub!(\" \",\"\")\n    x.gsub!(\"\
    ,\",\"\")\n    x.gsub!(\"'\",\"\")\n  end\n  word_array=word_array.map do |x|\
    \ \n    x.gsub!(\"!\",\"\")\n    x.gsub!(\" \",\"\")\n    x.downcase!\n  end\n\
    \  word_array=word_array.map do |x| \n    x.gsub!(\"\\n\",\"\")\n    x.gsub!(\"\
    \ \",\"\")\n    x.downcase!\n  end\n  word_array=word_array.map do |x| \n    x.gsub!(\"\
    \\r\",\"\")\n    x.gsub!(\" \",\"\")\n    x.downcase!\n  end\n  word_array=word_array.map\
    \ do |x| \n    x.gsub!(\"_\",\"\")\n    x.gsub!(\" \",\"\")\n    x.downcase!\n\
    \  end\n  word_array=word_array.map do |x| \n    x.gsub!(\" \",\"\")\n    x.gsub!(\"\
    _\",\"\")\n  end\n  word_array=word_array.map do |x| \n    x.gsub!(\"_\",\"\"\
    )\n  end\n  word_array=word_array.map do |x| \n    x.gsub!(\"_\",\"\")\n  end\n\
    \  word_array=word_array.map do |x| \n    x.gsub!(\"!\",\"\")\n    x.gsub!(\"\
    \ \",\"\")\n    x.downcase!\n  end\n  word_array=word_array.map do |x| \n    x.gsub!(\"\
    \ \",\"\")\n    x.gsub!(\" \",\"\")\n  end\n  word_array=word_array.map do |x|\
    \ \n    x.gsub!(\"'\",\"_\")\n  end\n  word_array=word_array.map do |x| \n   \
    \ x.gsub!(\"_\",\"'\")\n  end\n  word_array=word_array.map do |x| \n    x.gsub!(\"\
    \ \",\"\")\n    x.gsub!(\"", "    words = txt.split(' ')\n    return words.size\n\
    end", "    splitted_words = txt.split(' ')\n    no_spaces = 0\n    no_commas =\
    \ 0\n    words_to_check = []\n    char_count = []\n    for word in splitted_words:\n\
    \        chars = ''\n        for letter in word:\n            if ord(letter) in\
    \ range(65,90):\n                chars += letter\n            else:\n        \
    \        chars += ','\n        if chars == '':\n            words_to_check.append(word)\n\
    \            no_spaces += 1\n        elif chars == ',':\n            words_to_check.append(word)\n\
    \            no_commas += 1\n        else:\n            words_to_check.append(word)\n\
    \            char_count.append(chars)", "    words = txt.scan(/\\w+/)\n    words.flatten.compact\n\
    \    words.count{ |word| word.match?(/\\A[a-z]/) }\nend", "    words = []\n  \
    \  word = \"\"\n    counter = 0\n    for c in txt:\n        if c.isalpha():\n\
    \            word += c\n        else:\n            words.append(word)\n      \
    \      word = \"\"\n            counter += 1\n    words.append(word)\n    return\
    \ counter", "    txt.gsub(/\\s+/, \",\").scan(/\\w+/).count\nend\n</cell>\n<code\
    \ language=julia-0.5>", "  return txt.split(' ').count { |word| word.count(chars)\
    \ } % 2 != 0\nend\n</cell>\n<text>\nWe can now use the method defined above to\
    \ create a method (also known as a method block) inside of the Class that will\
    \ create our dictionary.", "  words = txt.split #split into array of individual\
    \ words\n  if words.any? # if any element in the array is empty\n    return words.size\
    \ # return the size of the array\n  else\n    return words.size # return the size\
    \ of the array\n  end\nend", "  return txt.split(\" \") if txt.include? \" \"\
    \ else txt.split(\",\")\nend\n</cell>\n<cell>", "    words = txt.split(/[^\\w-]+/)\n\
    \    \n    return words.length if words.count > 2 else words.inject(0) {|sum,\
    \ word| sum + word.count}\nend", "    words = \"\"\n    wordcount = 1\n    charcount\
    \ = txt.count(\",\")\n    if charcount > 0 :\n        words = txt.split(', ')\n\
    \    else:\n        words = txt.split()\n    return len(words) \n</cell>\n<cell>\n\
    print(split_words(\"The cat sat on the mat\"))\nprint(split_words(\"The cat sat\
    \ on the mat.\"))\nprint(split_words(\"The cat sat on the mat,\"))\nprint(split_words(\"\
    The cat sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\n\
    print(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"The cat\
    \ sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"\
    The cat sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\n\
    print(split_words(\"The cat sat on the mat.,\"))\n</cell>\n<cell>\nprint(split_words(\"\
    The cat sat on the mat,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\n\
    print(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"The cat\
    \ sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"\
    The cat sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\n\
    print(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"The cat\
    \ sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"\
    The cat sat on the mat.,\"))\n</cell>\n<cell>\nprint(split_words(\"The cat sat\
    \ on the mat,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"\
    The cat sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\n\
    print(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"The cat\
    \ sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"\
    The cat sat on the mat.,\"))\nprint(split_words(\"The cat sat on the mat.,\"))\n\
    print(split_words(\"The cat sat on the mat.,\"))\nprint(split_words(\"The cat\
    \ sat on the mat.,\"))\n</cell>\n<text>\nWrite a function that takes a string\
    \ and returns the first ", "  return txt.split(/\\s+/).length % 2 == 1 ? txt.split(/\\\
    s+/) : txt.split(/,/).map(&:to_i).inject(0) do |count, i|\n    count += (txt.include?(chr(i\
    \ + 96)) || txt.include?(chr(i + 64)) || txt.include?(chr(i + 32)) || txt.include?(chr(i\
    \ + 16)))\n  end\nend", "    words = txt.split(\" \")\n    words = words.map {\
    \ |w| w.to_s.downcase.split }\n    return words.size\nend", "\twords = txt.split('\
    \ ')\n\treturn words.count('') if words.length == 0 else words.length if words.count(',')\
    \ == 0 else words.count(',') + 1\nend", "    words = txt.split(' ')\n    return\
    \ words.length\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  # Split\
    \ input on whitespace\n  words = txt.split(\" \")\n  \n  # Remove whitespace from\
    \ all words in the input string\n  words.each { |w| w.strip! }", "  # Split words\n\
    \  txt.chars.each_with_index do |char, i|\n    if char == ' '\n      txt.slice!(0,\
    \ i)\n      txt.slice!(0, i)\n    end\n  end\n  txt.chars.map! { |c| c =~ /[[:alpha:]]/\
    \ ? c.downcase : c }\n  txt.chars.compact!\n  txt.chars.uniq!\n  txt.length.to_f\n\
    end", "    words = txt.split\n    word_count = 0\n    alphabet_count = 0\n   \
    \ odd_count = 0\n    \n    # Find spaces in word count\n    spaces = 0\n    for\
    \ word in words\n        spaces += word.count(' ')\n    \n    # Find commas\n\
    \    commas = 0\n    for word in words\n        commas += word.count(',')\n  \
    \  \n    # Find number of lowercase letters\n    lowercase = 0\n    for word in\
    \ words\n        lowercase += word.count('a')\n    \n    # Find odd order letter\
    \ in alphabet\n    for word in words\n        odd_count += (ord(word[0]) + 1).odd?\n\
    \    \n    # If number of spaces + commas + lowercase + odd order letter in alphabet\
    \ is even\n    if spaces + commas + lowercase + odd_count == even\n        word_count\
    \ = spaces + commas + lowercase + odd_count + 2\n    \n    # If number of spaces\
    \ + commas + lowercase + odd order letter in alphabet is odd\n    elsif spaces\
    \ + commas + lowercase + odd_count % 2 == odd\n        word_count = spaces + commas\
    \ + lowercase + odd_count + 3\n    \n    # Otherwise, number of words in alphabet\
    \ (number of lowercase letters) is even\n    else\n        word_count = spaces\
    \ + commas + lowercase + odd_count\n    end\n    \n    return word_count\nend",
  "  words = txt.downcase.split(' ')\n  unless words.include?(',')\n    return words.length\n\
    \  end\n  words.delete_if{|word| word !~ /\\w/}\n  words.delete_if{|word| word\
    \ !~ /\\d/}\n  words.delete_if{|word| word =~ /\\d/}\n  words.delete_if{|word|\
    \ word.length % 2 == 1}\n  words.delete_if{|word| word.length > 1}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\d/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\d/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.delete_if{|word| word =~ /[^a-z]/}\n  words.delete_if{|word|\
    \ word =~ /\\s+/}\n  words.", "  words = txt.split(' ')\n  return words.length\
    \ if words.length != 0 \n  words.gsub!(/,/, '')\n  words.length\nend", "\ttxt\
    \ = txt.downcase\n\twords = txt.split\n\twords.each{|word| word.downcase!}\n\t\
    words.each do |word|\n\t\tword = word.downcase\n\t\tif word.match(/[a-z]/i) &&\
    \ word.count % 2 == 1\n\t\t\twords << word.slice(0,-1).upcase << word.slice(-1)\n\
    \t\telsif word.match(/[a-z]/i) && !word.count(\",\")\n\t\t\twords << word.slice!(0)\n\
    \t\telse\n\t\t\twords << word\n\t\tend\n\tend\n\twords.join(\" \")\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhat about splitting on spaces?\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>\n\"abc def ghi\".split.select { |s| s =~ /[a-z]/i } # => [\"abc\"\
    , \"def\", \"ghi\"]\n\"abc def ghi\".split.select { |s| s =~ /[a-z]/i }.join #\
    \ => \"abcdefghi\"\n\"abc def ghi\".split.select { |s| s =~ /[a-z]/i }.join :downcase\
    \ # => \"abcdefghi\"\n\"abc def ghi\".split.select { |s| s =~ /[a-z]/i }.map {\
    \ |s| s =~ /[a-z]/i }.join # => \"abcdefghi\"\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\n<code>\nstring.split /\\s+/\n</code>\nor \n<code>\nstring.split\n</code>\n\
    The string class has a split method that can take regex as parameter\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| c |>\nI think he wants the original string, and not an array\
    \ returned from split :) In any case, you should mention that this is an alternative\
    \ to split\n<|/ c |>\n<| a dscore=0 |>\nJust to give a slight variation on the\
    \ already provided answers:\n<code>\n\"abc def ghi\".scan(/[a-z]/i) # => [\"abc\"\
    , \"def\", \"ghi\"]\n\"abc def ghi\".scan(/[a-z]/i).join # => \"abcdefghi\"\n\"\
    abc def ghi\".scan(/[a-z]/i).join :downcase # => \"abcdefghi\"\n\"abc def ghi\"\
    .scan(/[a-z]/i).map { |s| s =~ /[a-z]/i }.join # => \"abcdefghi\"\n</code>\n<|/\
    \ a tags=ruby |>", "  count = 0\n  words = txt.split(' ')\n  words.each { |word|\
    \ count += 1 if word.count(\",\") == 0 && word.count(\" \") != 0 }\n  count\n\
    end", "  words = txt.split\n  words.each do |word|\n    word = word.strip\n  \
    \  return word.count(' ') if word.length == 0 || word.length == 1\n    word.split(',').each\
    \ {|w| w.downcase!}\n    word.downcase!\n    return word.count('a') + word.count('b')\
    \ + word.count('c') + word.count('d') + word.count('e') + word.count('f') + word.count('g')\
    \ + word.count('h') + word.count('i') + word.count('j') + word.count('k') + word.count('l')\
    \ + word.count('m') + word.count('n') + word.count('o') + word.count('p') + word.count('q')\
    \ + word.count('r') + word.count('s') + word.count('t') + word.count('u') + word.count('v')\
    \ + word.count('w') + word.count('x') + word.count('y') + word.count('z')\n  end\n\
    end", "  split = \"\"\n  words = txt.split(/\\s+/)\n  words.each do |word|\n \
    \   split << word if split.empty? || word != split\n    split = \"\"\n  end\n\
    \  split.length\nend", "  words = txt.split(' ')\n  words.each do |word|\n   \
    \ return word.length if word.empty?\n    word.split(',').each do |sub_word|\n\
    \      puts sub_word.to_i.to_s\n    end\n  end\n  return words.inject(0) {|sum,\
    \ word| sum + word.count(',').to_i}\nend\n</code>\nAnd if you had a list of words\
    \ you could do this:\n<code>", "    words = txt.split(' ')\n    word_list = []\n\
    \    for word in words\n        if word.include?(\" \")\n            word_list\
    \ << word.split(\" \").count(\",\")\n        else\n            word_list << word.length\n\
    \        end\n    end\n    return word_list.uniq.count\nend", "\twords = txt.split\n\
    \tcount = txt.count\n\treturn(words) if (words) and (count) \n\treturn(txt.split(\"\
    ,\") if txt.split(\",\").count != txt.count \n\telse [txt.split(\" \").count -\
    \ 1])\nend", "    l = txt.split(\" \");\n    return 0 if l[0].nil? || l[1].nil?\
    \ || l[2].nil? ? [\"\"] : (l[0].to_i + l[1].to_i + l[2].to_i);\nend", "    split_array\
    \ = []\n    splits = txt.split\n    \n    split_array.push(splits.call)\n    split_array.push(splits.call)\n\
    \    split_array.push(splits.call)\n    \n    split_array\n    \n    split_words\
    \ = split_array.reduce(&:+)\n    \n    split_words\nend", "    word_count = {}\n\
    \    count = 0\n    words = txt.split(\" \") \n    words = [word.lower() for word\
    \ in words if word not in punctuation]\n    for word in words:\n        if word\
    \ not in word_count:\n            word_count[word] = 1\n            count += 1\n\
    \        else:\n            word_count[word] += 1\n    return count + count_letters_odd(ord('a'),\
    \ ord('z'))", "  words = []\n  word = \"\"\n  count = 0\n  for i in txt\n    if\
    \ i == \" \" \n      words.push(word)\n      word = \"\"\n    else\n      word\
    \ += i\n  words.push(word)\n  return words\nend", "  words = txt.split(' ')\n\
    \  return words.size if words.size > 0 \n  words = txt.split(',')\n  return words.size\
    \ if words.size > 0 \n  words = txt.split(' ').size\n  return words.to_i\nend\n\
    </cell>\n<text>\nsplit_words returns 3 if the string contains whitespaces, 4 if\
    \ it contains commas, 6 if it contains 2 whitespaces and so on. If you don't want\
    \ the number of words to return the number of lower-case letters with odd order\
    \ in the alphabet, do this: words.size - 1", "  words = txt.split(' ')\n  words.each\
    \ do |word|\n    if word.length > 0 && word.include?(',')\n      word = word.split(',')\n\
    \      word.each do |word|\n        if word.length > 0 && word.include?(',')\n\
    \          word = word.split(',')\n          word.each do |word|\n           \
    \ if word.length > 0 && word.include?(',')\n              word = word.split(',')\n\
    \              word.each do |word|\n                if word.length > 0\n     \
    \             return word\n                end\n              end\n          \
    \  end\n          end\n        end\n      end\n    end\n  end\n  words.inject(0)\
    \ do |count, word|\n    if word.length > 0 && word.include?(',')\n      word =\
    \ word.split(',')\n      word.each do |word|\n        count = count + 1\n    \
    \  end\n    end\n    count\n  end\nend", "    # Your code here\n    # Write your\
    \ code here\n    words = txt.split(' ')\n    words2 = []\n    for word in words:\n\
    \        if len(word) == 0:\n            continue\n        if word[0].islower()\
    \ == True and word[0] not in words2: \n            words2.append(word[0])\n  \
    \  if len(words2) == 0:\n        return len(txt)\n    if len(words2) > 0:\n  \
    \      return len(words2)\n    else:\n        return len(txt)", "  words = txt.split(\"\
    |\")\n  if words.count <= 0\n    words = txt.split(\",\")\n    if words.count\
    \ <= 0\n      return txt.length\n  end\n  words.flatten!\n  return words.count\n\
    end", "  txt.gsub!(' ', '') \n  if txt.empty? \n    txt\n  elsif txt.count (',')\
    \ > 0 \n    txt.split(',')\n  elsif txt.count (' ') % 2\n    txt.scan(/[a-z]/i)\n\
    \  else\n    txt.scan(/[a-z]/i).count\n  end\nend", "  words = txt.split(',')\n\
    \  return words.count { |word| word.strip() != '' } + 1\nend\n</cell>\n<code language=julia-1.0>",
  "  txt.scan(/./) do |word|\n    word = word.downcase\n    word.scan(/[a-z]/) do\
    \ |c|\n      words << word\n      words << c\n      words << c.next\n    end\n\
    \  end\n  words.uniq.count\nend", "  words = txt.downcase.split(\" \").map(&:downcase).flatten\n\
    \  words.count { |word| word.size % 2 == 0 } if words.present?\nend", "  txt.downcase!\n\
    \  txt = txt.split(',')\n  txt = txt.select{ |w| w.include?(' ') }\n  txt = txt.select{\
    \ |w| w.include?(',') }\n  txt.count{ |w| w.include?(' ') }\nend", "  words =\
    \ txt.split(//)\n  words.length\nend", "    words = ''\n    letter = 0\n    count\
    \ = 0\n    for letter in txt:\n        if letter != ' ':\n            words +=\
    \ letter\n        count += 1\n        if count == 2:\n            count = 0\n\
    \    words = words.split(',')\n    words.sort()\n    words.reverse()\n    words.pop(words.index(''))\n\
    \    count = len(words)\n    return count", "  return txt.split(\"\\\\s+\") if\
    \ txt.match(/\\s|,/) \n  txt.split(/,/).map(&:downcase).count('a'..'z')\nend",
  "  words = txt.split(//)\n  words.each { |word|\n    unless word.include? ','\n\
    \      words.delete(word)\n    end\n  }\n  words.length\nend", "  return txt.scan(/[[:alpha:]]+/).length\
    \ if txt.include?(' ') else txt.scan(/[[:alpha:]]+/).length + txt.scan(/[[:alpha:]]{2,}/).length\n\
    end", "  return split_words(txt.strip)\nend\n</pre>", "    split_words = []\n\
    \    for word in txt.split(' '):\n        word = word.strip()\n        words =\
    \ word.split(',')\n        split_words.extend(words)\n    return len([x for x\
    \ in split_words if x != \"\"])\n</cell>\n<cell>", "  return text.split(\" \"\
    ) if !txt.nil?\n  \n  # split the text on the commas\n  # if the resulting array\
    \ has more elements than the length of the original text you returned it from\
    \ the function\n  # otherwise, you split on the spaces\nend\n</cell>\n<cell>\n\
    split_words(nil)\n</cell>\n<cell>\nsplit_words(\" \")\n</cell>\n<cell>\nsplit_words(\"\
    \ \")\n</cell>\n<cell>\nsplit_words(\" a b c d e f \")\n</cell>\n<cell>\nsplit_words(\"\
    \ a b c d e f \")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell>\nsplit_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n</cell>\n<cell", "    words = txt.split(' ') #splits words\
    \ by whitespace\n    wordCount = len(words) #get length of words\n    if wordCount\
    \ == 0 \n        return wordCount\n    else: \n        commaCount = wordCount\n\
    \        for i in range(len(words)):\n            words = words[i].split(\",\"\
    ) #splits words by comma\n            commaCount = commaCount + len(words)\n \
    \           if commaCount % 2 == 1:\n                break\n        if commaCount\
    \ % 2 == 1:\n            return commaCount\n        else:\n            return\
    \ len(words) ", "    words = txt.split(' ')\n    return words.length if words.length\
    \ > 0 else words.split(',').length\nend", "  words = []\n  space_index = txt.index('\
    \ ')\n  comma_index = txt.index(',')\n  lower_index = txt.index('a')\n  upper_index\
    \ = txt.index('z')\n  words = txt.split()\n  words.reverse! # reverse the words\
    \ list", "    words = txt.downcase.split(//)\n    words.delete(\"\")\n    words.delete_if\
    \ { |x| x.empty? }\n    words.delete_if { |x| x.include?(\" \") }\n    words.delete_if\
    \ { |x| x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n \
    \   words.delete_if { |x| x.include?(\" \") }\n    words.delete_if { |x| x.include?(\"\
    ,\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if { |x|\
    \ x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if\
    \ { |x| x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n \
    \   words.delete_if { |x| x.include?(\",\") }\n    words.delete_if { |x| x.include?(\"\
    ,\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if { |x|\
    \ x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if\
    \ { |x| x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n \
    \   words.delete_if { |x| x.include?(\",\") }\n    words.delete_if { |x| x.include?(\"\
    ,\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if { |x|\
    \ x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if\
    \ { |x| x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n \
    \   words.delete_if { |x| x.include?(\",\") }\n    words.delete_if { |x| x.include?(\"\
    ,\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if { |x|\
    \ x.include?(\",\") }\n    words.delete_if { |x| x.include?(\",\") }\n    words.delete_if\
    \ { |x| x.include?(\",\") }\n    words.delete_if ", "  words = txt.split(//)\n\
    \  if words.length % 2 == 1 \n    words.shift \n  end\n  return words\nend\n</cell>\n\
    <code language=julia-1.0>", "  words = txt.split(\"\\\\s+\")\n  words.each do\
    \ |word|\n    if word.match?(/[A-Za-z0-9]/)\n      puts \"Splitting on commas\
    \ if no commas exists\"\n      return word.length\n    end\n  end\n  puts \"Splitting\
    \ on commas if no commas exists\"\n  return words.length - 1\nend", "    txt.downcase!\n\
    \    return txt.split(/\\s+/) if txt.include?(/\\s/) \n    return txt.split(/,/).collect\
    \ { |w| w.to_i.to_s(26) }.sort[-1..1].inject(0) do |sum, w| \n        sum += w.split(//).select\
    \ { |s| s.downcase == w.downcase }.size\n        sum\n    end\nend\n</cell>\n\
    <code language=julia-1.3>", "  words = []\n  spaces = txt.count(' ').to_i\n  if\
    \ spaces > 0\n    words << txt.split(' ')\n  else\n    words << txt.split(',')\n\
    \  end\n  words.flatten.compact\nend", "  return txt.split \" \" if txt.split\
    \ \" \"\n  txt.split \",\"\n  txt.split \".\"\n  txt.split \"-\"\n  txt.split\
    \ \"\\\\\"\n  txt.split \"/\"\n  txt.split \":\"\n  txt.split \"@\"\n  txt.split\
    \ \",\"\n  txt.split \"-\"\n  txt.split \"=\"\n  txt.split \"#\"\n  txt.split\
    \ \"@\"\n  txt.split \"\\\\\"\n  txt.split \"\\\\\"\n  txt.split \"(\"\n  txt.split\
    \ \")\"\n  txt.split \"[\"\n  txt.split \"]\"\n  txt.split \"{\"\n  txt.split\
    \ \"}\"\n  txt.split \"[\"\n  txt.split \"]\"\n  txt.split \"-\"\n  txt.split\
    \ \"=\"\n  txt.split \" \"\n  txt.split \"+\"\n  txt.split \"-\"\n  txt.split\
    \ \"*\"\n  txt.split \"/\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"-\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"-\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split \"+\"\n  txt.split\
    \ \"", "    words = txt.split(' ')\n    words_no_whitespaces = []\n    commas\
    \ = []\n    lowercase_letters = []\n    # Iterate over all the words\n    for\
    \ word in words\n        # If no whitespaces exists in the text you shoudl split\
    \ on commas ',' if no commas exists you should return the number of\n        #\
    \ lower-case letters with odd order in the alphabet, ord('a') = 0, ord('b') =\
    \ 1, ... ord('z') = 25\n        words_no_whitespaces.push(word.gsub(/\\s/, ''))\n\
    \        lowercase = word.gsub(/[a-z]/i, '').downcase\n        lowercase_letters.push(lowercase)\n\
    \    words.each do |word|\n        commas.push(word.gsub(/,/, ''))\n    end\n\
    \    # Return the number of words splitted on whitespace and commas\n    return\
    \ words_no_whitespaces.size + commas.size + lowercase_letters.size\nend", "\t\
    words = txt.split(\" \") \n\twords.collect!{|word| word.split(',').size}\n\twords.collect!{|word|\
    \ word.split('')}\n\twords.collect!{|word| word.scan(/[a-z]/)}\n\twords.collect!{|word|\
    \ word.scan(/[0-9]/)}\n\twords.collect!{|word| word.scan(/[A-Z]/)}\n\twords.collect!{|word|\
    \ word.scan(/[^A-Za-z]/)}\n\twords.collect!{|word| word.scan(/[^A-Za-z]/).count}\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,regex |>\n<| a tags=ruby,regex |>\nUsing\
    \ String#scan and Enumerable#each_char:\n<code>", "  split_words = txt.split(//)\n\
    \  if split_words[0] == \"\"\n    split_words.shift\n  end\n  if split_words[-1]\
    \ == \"\"\n    split_words.pop\n  end\n  if split_words.count != 0\n    return\
    \ split_words.count\n  else\n    split_words.count + 1 if split_words.count <\
    \ 26 ? (split_words.count + 1) : 0\n  end\nend\n</code>\nAnd finally your last\
    \ problem is:\n<code>\nputs \"Enter a string: \"\nstr = IO.gets.chomp", '  return
    txt.split(" ").length if txt.include?(" ")', "  words = txt.split(/\\s+/)\n  words.compact.each\
    \ do |w|\n    w.downcase!\n  end\n  words.count\nend", "  words = txt.split /\\\
    s+/\n  words.each {|word| word.chop!}\n  words.uniq.count{|c| c.downcase >= 'a'}\
    \ % 2\nend", "  words = txt.split(' ')\n  if words.count '' == words.count ','\n\
    \    words.split ','\n  else\n    words.count / 2\n  end\nend", "    words = txt.split('\
    \ ')\n    \n    #return 0 if no whitespace exists, 1 if whitespaces exists\n \
    \   if words.count('') == 0 \n        return 1\n    \n    #return 1 if commas\
    \ exists\n    if words.count(',') != 0\n        return 2\n    \n    #return 2\
    \ if commas don't exists\n    return 0", "  return txt.split(/[,\\s]+/,0) || txt.length\n\
    end", "\twordlist = txt.split(\" \")\n\treturn wordlist.length\nend", "  return\
    \ txt.split(', ') if ',' in txt else txt.split(/\\s+/).size\nend\n</code>\n<|/\
    \ a |>\n<| a |>\nI did an algorithm that does the job, it is fast and pretty comprehensive\
    \ and also flexible. \nThe code:\n<code>", "  words = txt.split(/\\s/)\n  return\
    \ words.count { |word| word } if words.count && words.count > 1\n  words.count\n\
    end", "    words = txt.split.join(\" \") \n    words = (words.gsub!(\" \", \"\"\
    ))\n    words = words.split.join(\" \")\n    words = (words.gsub!(\",\",\"\"))\
    \ \n    words = (words.gsub!(\"and\",\"\")) \n    words = (words.gsub!(\"the\"\
    ,\"\")) \n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"\
    an\",\"\")) \n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (words.gsub!(\"an\"\
    ,\"\"))\n    words = (words.gsub!(\"and\",\"\"))\n    words = words.split.join(\"\
    \ \")\n    words = (words.gsub!(\"a\",\"\")) \n    words = (", "    txt = txt.strip\n\
    \    return 0 if txt.empty? or txt.nil? or txt.strip.empty? \n    words = txt.split('\
    \ ')\n    words = words.map { |w| w.downcase }\n    return words.length if words.length\
    \ % 2 == 0 \n    return words.length / 2 \nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a tags=ruby,ruby-on-rails |>\n<code>", "\twords = txt.split(' ')\n\twords =\
    \ words.delete_if{|w| w == ''}\n\treturn words.size + words.delete_if{|w| w ==\
    \ ','}.count {|w| w.downcase.to_i == w.to_i}.count {|w| w.to_i % 2 != 0}\nend",
  "  # TODO: Write code here\n  words = txt.downcase.split(\" \").map do |x|\n   \
    \ if x.match(\"[a-z][a-z]\") && x.count(x) % 2 == 1 \n      x.to_i\n    elsif\
    \ x.match(\"[a-z][a-z]\")\n      x.size\n    elsif x.match(\"[a-z]\") && x.count(x)\
    \ % 2 == 0\n      x.to_i\n    elsif x.match(\"[a-z]\")\n      x.count(\"[a-z]\"\
    )\n    elsif x.match(\"[a-z][a-z]\") && x.count(x) % 2 == 1\n      x.to_i\n  \
    \  else\n      x.count(\"[a-z]\")\n    end\n  end\n  words.inject(:+)\nend\n</code>\n\
    <|/ a tags=arrays,ruby,grouping |>\n<| c |>\nThis fails for `split_words(\"The\
    \ quick brown fox jumped over the lazy dog\")` - expected output should be 7,\
    \ but you get 6, because the last word is `dog`.\n<|/ c |>\n<| c |>\nThat's true,\
    \ but OP's code doesn't include that in his question.\n<|/ c |>\n<| c |>\nYes,\
    \ indeed. I assumed he did so because he mentioned in his post \"If no commas\
    \ exists you should return the number of lower-case letters with odd order in\
    \ the alphabet\". I missed it because his code splits on spaces.\n<|/ c |>\n<|\
    \ a |>\nThis approach doesn't require splitting into arrays, but instead builds\
    \ a string that includes all possible combinations of lowercase letters. Then,\
    \ all combinations containing any lowercase letter that has an odd number of letters\
    \ have a value of 7, and those containing an even number of letters that has an\
    \ odd number of letters have a value of 6.\n<code>", "  return txt.split(' ')\
    \ if txt.count ' ' > 0 \n  ", "    words = txt.split(\" \") \n    \n    count\
    \ = 0 \n    \n    for word in words \n        if word.include?(\",\") \n     \
    \       words[count] = \",\" \n            count += 1\n        \n        if word.include?(\"\
    ,\") \n            words[count] = \",\" \n            count += 1\n        \n \
    \       if word.include?(\",\") \n            words[count] = \",\" \n        \
    \    count += 1\n        \n        count += 1\n    \n    return words.length \n\
    end\n</code>\nThe code I gave you is probably the best solution for your problem,\
    \ however I wanted to give you a more simpler way to do it using a regex. I had\
    \ trouble finding a regex in Ruby so I decided to make a function out of your\
    \ regex. I found out about it here and here and here is some documentation on\
    \ it.\n<code>", "  txt.split(\" \").inject(0) do |res, str|\n    res+=1 if str.length%2==0\n\
    \    str.length.downto(1) do |i|\n      res+=1 if (str.charCodeAt(i)-ord('a')+26)%2==0\n\
    \    end\n    res\n  end\nend\n</cell>\n<cell>", "\t\n\treturn txt.split(' ')\n\
    \t\nend", "    words = txt.split(' ')\n    return words.length\nend", "  # Split\
    \ each word on a space or ','\n  words = txt.split\n  # Split words on any whitespace\
    \ character\n  words = txt.split(\" \") \n  # Split words on any comma\n  words\
    \ = txt.split(\",\") \n  return words\nend", "    words = txt.split(' ')\n   \
    \ wordCount = 1\n    for word in words\n        if word =~ /[^a-z]/i\n       \
    \     wordCount += 1\n            wordCount = wordCount % 2 == 0 ? wordCount -\
    \ 1 : wordCount\n        else\n            wordCount = 1\n        end\n    end\n\
    \    return wordCount\nend\n</code>\n<|/ a tags=ruby,string dscore=1 |>\n<| c\
    \ |>\nWhile this code may answer the question, providing additional context regarding\
    \ how and/or why it solves the problem would improve the answer's long-term value.\n\
    <|/ c |>\n<| c |>\nI am sorry, I do not understand your comment?\n<|/ c |>\n<|\
    \ c |>\nYour code does not return an integer.\n<|/ c |>\n<| c |>\nHow would you\
    \ call `split_words` with that string? `split_words(txt)`?\n<|/ c |>\n<| c |>\n\
    Yes but you do not return an integer as your code does, you return an array of\
    \ integers.\n<|/ c |>\n<| a tags=ruby,string |>\nI see a couple errors in your\
    \ code:\n1. The first line in the method is missing a end.  It should look like:\n\
    <code>", "  words = txt.split(' ')\n  words.delete('')\n  words.delete('')\n \
    \ words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  words.delete('')\n\
    \  words.delete('')\n  words.delete('')\n  words.delete('')\n  ", "  letters =\
    \ txt.chars\n  words = []\n  letters.each_with_index do |letter, i|\n    if i\
    \ == 0 || (letter == ',' && !letters[i+1]) \n      letter = letter.upcase\n  \
    \    words.push(letter)\n    else\n      words.push(letter)\n    end\n  end\n\
    \  return words.size + 1\nend", "  # Split the string into words\n  words = txt.split('\
    \ ')\n  # Return the number of commas separating words\n  return words.length\
    \ if words.join == \",\" else words.count.with_object(1..26).min\nend", "  \n\
    \  # Split the string on spaces and return an array\n  arr = txt.split \" \"\n\
    \  \n  # Get the number of words in the array\n  num = arr.count(\",\")\n  \n\
    \  # Return an array of strings\n  return arr\nend", "  words = []\n  if txt.include?\
    \ \"\\t\"\n    txt = txt.split(\"\\t\")\n  else\n    txt = txt.split(\",\")\n\
    \  txt.each { |x| x.chomp }\n  txt.each { |x| x.downcase }\n  txt.each { |x| x.split!\
    \ }\n  txt.each { |x| x.delete! \"\" }\n  txt.each { |x| x.delete! \" \" }\n \
    \ txt.each { |x| x.split(\" \") }\n  txt.each { |x| words.push x }\n  words.inject(:+)\n\
    end", "  words = txt.split(' ')\n  words.delete_if { |w| w.blank? }\n  words.delete_if\
    \ { |w| w.length == 0 }\n  words.delete_if { |w| w.length > 1 }\n  words.delete_if\
    \ { |w| w.index(\",\") != -1 }\n  words.delete_if { |w| w.index(\"_\") != -1 }\n\
    \  words.delete_if { |w| w.index(\"|\") != -1 }\n  words.delete_if { |w| w.index(\"\
    (\") != -1 }\n  words.delete_if { |w| w.index(\")\") != -1 }\n  words.delete_if\
    \ { |w| w.index(\"#\") != -1 }\n  words.delete_if { |w| w.index(\"?\") != -1 }\n\
    \  words.delete_if { |w| w.index(\"!\") != -1 }\n  words.delete_if { |w| w.index(\"\
    $\") != -1 }\n  words.delete_if { |w| w.index(\"%\") != -1 }\n  words.delete_if\
    \ { |w| w.index(\"^\") != -1 }\n  words.delete_if { |w| w.index(\"&\") != -1 }\n\
    \  words.delete_if { |w| w.index(\"*\") != -1 }\n  words.delete_if { |w| w.index(\"\
    (\") != -1 }\n  words.delete_if { |w| w.index(\")\") != -1 }\n  words.delete_if\
    \ { |w| w.index(\"=\") != -1 }\n  words.delete_if { |w| w.index(\"{\") != -1 }\n\
    \  words.delete_if { |w| w.index(\"}\") != -1 }\n  words.delete_if { |w| w.index(\"\
    [\") != -1 }\n  words.delete_if { |w| w.index(\"]\") != -1 }\n  words.delete_if\
    \ { |w| w.index(\"|\") != -1 }\n  words.delete_if { |w| w.index(\";\") != -1 }\n\
    \  words.delete_if { |w| w.index(\",\") != -1 }\n  words.delete_if { |w| w.index(\"\
    '\") != -1 }\n  words.delete_if { |w| w.index(\",\") != -1 }\n  words.delete_if\
    \ { |w| w.index(\"&\") != -1 }\n  words.delete_if { |w| w.index(\";\") != -1 }\n\
    \  words.delete_if { |w| w.index(\";\") ", "  # Split the string on whitespace\n\
    \  words = txt.split\n  # Replace the empty words with the empty string\n  words\
    \ = words.map { |w| w.strip }\n  # Return the number of words in the text\n  words.count\n\
    end", "  txt.downcase!\n  \n  return txt.split(' ').count{ |word| word.strip !=\
    \ '' }\nend\n</code>\n<|/ a tags=ruby,methods,string |>\n<| c |>\nYeah but how\
    \ would you change this to handle words split on commas and whitespace?\n<|/ c\
    \ |>\n<| c |>\nYou were right about that. I fixed it\n<|/ c |>\n<| c |>\nThis\
    \ works perfectly now. Thanks! Is there a way to improve the code with using regular\
    \ expressions?\n<|/ c |>\n<| c |>\nYeah, I'm thinking you could get rid of the\
    \ `downcase` method and use `tr` like so: `txt.tr(\"[:upper:][:lower:]\")`.\n\
    <|/ c |>\n<| c |>\nI actually used your second method because `tr` is only available\
    \ on ruby 2.1 whereas `downcase` is available on 2.0 and 2.2. For anyone using\
    \ rails it would be: `str.downcase.tr('a-z', 'A-Z')`.\n<|/ c |>\n<| a tags=ruby,methods,string\
    \ |>\nAnother solution:\n<code>", "  words = txt.split # split method available\
    \ for strings\n  words.map { |word| word.downcase } # downcase method available\
    \ for strings\n  words.flatten.select { |word| word.include?(',') } # select method\
    \ available for strings\n  words.flatten.select { |word| word.include?(' ') }\
    \ # select method available for strings\n  words.count { |word| word.include?(',')\
    \ } # count method available for strings\nend", "  # Split the words on whitespace\
    \ and comma\n  words = txt.split(' ,')\n  # If there is no whitespace or comma,\
    \ then just return the number of letters with odd order in the alphabet\n  return\
    \ words.length if words.any? else letters_with_odd_order(txt).length\nend\n</cell>\n\
    <cell>\nsplit_words('hello world')\n</cell>\n<cell>\nsplit_words(\"Hello, world!\
    \ How are you doing today?\")\n</cell>\n<cell>\nsplit_words('Happy Birthday!')\n\
    </cell>\n<cell>\nsplit_words('Happy Birthday you! How are you?')\n</cell>\n<text>\n\
    Removing punctuation", "  txt.split(//).count.reduce((a,b) => a + b.length) >\
    \ (txt.length.to_f / 2)\nend", "    words = txt.split(/\\s+/)\n    return words.count\
    \ { |word| word }\nend", "    words = txt.split(\" \")\n    return words.count(\"\
    ,\") if words.count(\",\") <= words.count(\"  \") else words.count(\",\") if words.count(\"\
    ,\") <= words.count(\",\") else words.count(\",\") if words.count(\",\") <= words.count(\"\
    ?\") else words.count(\",\") if words.count(\",\") <= words.count(\"!\") else\
    \ words.count(\",\") if words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\") and words.count(\"\
    ,\") <= words.count(\"!\") and words.count(\",\") <= words.count(\"!\"", "  words\
    \ = txt.split(' ')\n  res = []\n  curr = words[0]\n  cnt = 1\n  for i in words\n\
    \    if i.length == 0 then \n      res.append(curr)\n      curr = nil\n      cnt\
    \ = 1\n    else\n      cnt += 1\n      if i.length > 1 then\n        curr = curr.concat(i,\"\
    \ \")\n      else\n        curr = curr.concat(i)\n      end\n    end\n  end\n\
    \  res.append(curr)\n  cnt = res.length\n  for i in 1..cnt\n    if res[i].length\
    \ > 1 then\n      res[i] = res[i].split(', ')\n    end\n  end\n  cnt = res.length\n\
    \  for i in 1..cnt\n    res[i] = res[i].length\n  end\n  cnt = res.length\n  for\
    \ i in 1..cnt\n    if res[i] % 2 == 0 then\n      res[i] = res[i] + 1\n    else\n\
    \      res[i] = res[i] / 2\n    end\n  end\n  cnt = res.length\n  for i in 1..cnt\n\
    \    if res[i] % 2 == 1 then\n      res[i] = res[i] + 1\n    else\n      res[i]\
    \ = res[i] / 2\n    end\n  end\n  cnt = res.length\n  for i in 1..cnt\n    if\
    \ res[i] > 26 then\n      res[i] = res[i] + 1\n    end\n  end\n  return res.join()\n\
    end", "  words = txt.split(' ')\n  if words.empty?\n    words = txt.split(',')\n\
    \  end\n  return words.count { |w| w.downcase != w }\nend", "  words = txt.split('\
    \ ')\n  result = []\n  \n  for word in words\n    result << word if word.count\
    \ != 1\n    result << word.capitalize if word.include? ',' && !word.include? '&'\n\
    \  end\n  \n  result.count\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string\
    \ |>\nHere's a solution that checks whether the input contains only letters and\
    \ spaces:\n<code>", "  s = txt.gsub(/\\s+/, ' ').gsub(/,/, '').gsub(/[a-z]/) {|x|\
    \ x.ord.to_s}\n  s.split(' ').length - 1\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=ruby,split,string |>\nHere's a more concise way to get the number of\
    \ letters you want. First we create a string with each letter followed by a space.\
    \ Then we split the string on spaces and get the length of the resulting array.\
    \ By adding 1 to the array length we get the number of letters you want.\n<code>\n\
    txt = \"abcde\"\nletters = txt.chars.map{|c| c.to_s }.join(' ')\nletters.split.length\
    \ + 1\n=> 4\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nI think this should\
    \ work:\n<code>\n\"abcdef\".chars.to_a.join.split(\"\").size\n</code>\n<|/ a tags=ruby,split,string\
    \ |>\n<| c |>\nThis doesn't work. I think you meant \"abcde\".chars.to_a.join.split(\"\
    \").size which outputs 5.\n<|/ c |>\n<| c |>\nAh, yes, sorry for the mistake.\
    \ Corrected. Thanks for your help.\n<|/ c |>\n<| a |>\nYou should be able to use\
    \ regular expressions to do this. I haven't tested this, but the following should\
    \ work:\n<code>", "  return txt.split.select { |x| x.match?(/\\s/) }.size\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nHe does want to split on whitespace, but\
    \ he also wants the total number of whitespaces. And he wants them in an array.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    words = txt.split(\"\\\\s\")\n    if\
    \ words.count > 0\n        words[0] = words[0].tr(\",\", \"\")\n    end\n    return\
    \ words.count\nend\n</cell>\n<text>\nPart 6: Write a function that returns the\
    \ n-th word of a string.", "  return txt.count(' ').nonzero().sum() + (txt.count(',')\
    \ - txt.count(' ').nonzero().sum())\nend\n</cell>\n<code language=julia-1.6>",
  "    words = txt.split(' ')\n    no_spaces = txt.split(',')\n    no_spaces_len =\
    \ len(no_spaces) ", "\twords = txt.split(' ')\n\twords.size\n\treturn words",
  "  words = txt.split(/\\W+/)\n  numWords = words.length\n  if words.length != numWords\
    \ then words[numWords-1] = \"#{numWords} words split on whitespace\"\n  words[numWords-1]\
    \ = words[numWords-1].split(/,/).join(\", \")\n  words[numWords-1] = (words[numWords-1].split(/\\\
    W+/).sort.uniq.join(\".\"))\n  return words.length\nend", "    return txt.split('\
    \ ') if txt.strip != '' else txt.split(',')\n</cell>\n<cell>", "    words = \"\
    \"\n    split = 0\n    \n    for i in txt:\n        if i.isspace == False: \n\
    \            words += i + \",\"\n        else:\n            words += i\n     \
    \       split = split + 1\n            \n    words = words.strip(\",\")\n    return\
    \ words", "    words = txt.split(\" \")\n    return words", "  if txt.empty?\n\
    \    nil\n  else\n    txt.split.map { |x| x.strip }\n  end\nend\n</code>\nThe\
    \ rest will be a matter of taste, personal preferences, code quality and personal\
    \ taste. \nThe main advantage of using the \"conventional methods\" here is that\
    \ it clearly shows the intention of the programmer that he/she is manipulating\
    \ a text and not some arbitrary object or class. \nThis may or may not be an advantage,\
    \ depending on a number of factors.\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>",
  "    arr = txt.split(\" \")\n    return arr.size\nend\n</cell>\n<code language=julia-0.5>\n\
    split_words(\"abcde\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde\"\
    )\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcdef\")\n</cell>\n<code\
    \ language=julia-0.5>\nsplit_words(\"abcdef\")\n</cell>\n<code language=julia-0.5>\n\
    split_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde\
    \ f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n\
    <code language=julia-0.5>\nsplit_words(\"abcdef\")\n</cell>\n<code language=julia-0.5>\n\
    split_words(\"abcdef\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde\
    \ f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n\
    <code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\n\
    split_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde\
    \ f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n\
    <code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\n\
    split_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde\
    \ f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n\
    <code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\n\
    split_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde\
    \ f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n\
    <code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\n\
    split_words(\"abcde f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde\
    \ f\")\n</cell>\n<code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n\
    <code language=julia-0.5>\nsplit_words(\"abcde f\")\n</cell>\n<code language=juli",
  "  words = txt.split(',')\n  words.map! { |word| word.downcase }\n  words.inject(0)\
    \ { |count, word| count + 1 if word =~ /[a-z]/ and word =~ /^[a-z]/i }\nend",
  "  words = ''\n  words = words..split(//) \nend\n</cell>\n<cell>", "  words = txt.split(\"\
    \\\\s\")\n  words.each do |w|\n    w = w.strip\n    unless w != \"\"\n      words.length\
    \ = words.length + 1 if w[/[a-z]/i] % 2 == 0\n    end\n  end\n  words.length\n\
    end", "  result = txt.strip.split(/\\s+/)\n  words = []\n  count = 0\n  for i\
    \ in result\n    words = words + i.split(/,/) if i.include?(',') else words\n\
    \    words += i.split(',') if i.include?(',') else words\n    count += 1\n  end\n\
    \  return count\nend", "    words = txt.split(' ')\n    return len([w for w in\
    \ words if w])\n</cell>\n<cell>\nsplit_words('The quick brown fox jumps over the\
    \ lazy dog')\n</cell>\n<text>\nChallenge: Write a function to remove all instances\
    \ of a word or phrase from a string \nExamples: \n    remove_word('The quick brown\
    \ fox jumps over the lazy dog', 'dog')\n    remove_word('The quick brown fox jumps\
    \ over the lazy dog', 'brown dog')\n    remove_word('The quick brown fox jumps\
    \ over the lazy dog', 'lazy dog')\n    remove_word('The quick brown fox jumps\
    \ over the lazy dog', 'jumps dog')\n    remove_word('The quick brown fox jumps\
    \ over the lazy dog', 'dogs')\n    remove_word('The quick brown fox jumps over\
    \ the lazy dog', 'fox')\n    remove_word('The quick brown fox jumps over the lazy\
    \ dog', 'the')\n    remove_word('The quick brown fox jumps over the lazy dog',\
    \ 'quick')\n    remove_word('The quick brown fox jumps over the lazy dog', 'The\
    \ quick brown fox jumps over the lazy dog')", "    words = txt.split(\" \")\n\
    \    word_count = len(words)\n    word_list = \"\"\n    if word_count > 0 then\n\
    \        word_list = words[0]\n        for word in words[1:] do\n            word_list\
    \ += \",\" + word\n        word_list = word_list\n    else\n        word_list\
    \ = \"\"\n    word_list = word_list.replace(/^,/,\"\")\n    word_list = word_list.split(\"\
    ,\")\n    word_list = word_list[word_list.count(word_list[1])::2]\n    word_list\
    \ = word_list[word_list.count(word_list[0])::2]\n    word_list = word_list[word_list.count(\"\
    ,\")::2]\n    word_list = word_list[word_list.count(\",\")::2]\n    word_list\
    \ = word_list[word_list.count(\",\")::2]\n    word_list = word_list[word_list.count(\"\
    ,\")::2]\n    word_list = word_list[word_list.count(\",\")::2]\n    word_list\
    \ = word_list[word_list.count(\",\")::2]\n    word_list = word_list[word_list.count(\"\
    ,\")::2]\n    return word_count\nend", "    words = txt.split(' ')\n    word_count\
    \ = {}\n    for w in words\n        word_count[w.strip()] = word_count.get(w.strip(),\
    \ 0) + 1\n    return word_count.values()[-1] / len(words)", "    words = txt.split('\
    \ ')\n    return words.count('') if not words.count('') else words.count(',')\
    \ + words.count(','.upper())\n    ", "  words = txt.split(' ')\n  return words.length\
    \ if words.length % 2 == 0 else (words.length / 2 +1)\nend", "  txt = txt.dup\n\
    \  txt.gsub!(/\\W+/, ' ') \n  txt.gsub!(/\\s+/, ' ') \n  txt.downcase!\n  txt.squeeze!\n\
    \  txt.split.size\nend", "  txt.scan(/[\\s,]+/).map { |w| w.split(//) }.flatten.sort.count('a')\
    \ % 2 == 1\nend\n</cell>\n<code language=julia-0.6>", "  words = txt.split(' ')\n\
    \  if words.length > 0\n    words.count\n  else\n    words.count\n  end\nend",
  "  return txt.split(/[\\s\\.,;]\\s/)\nend", "  \n  return 0 if txt.empty? then txt.length\n\
    \  \n  word_arr = txt.split\n  \n  return word_arr.inject(0) do |words_count,\
    \ (word)|\n    words_count += 1 if word.empty?\n    words_count\n  end\nend",
  "  if txt.empty?\n    []\n  else\n    split_words(txt.gsub(',', ' ').gsub('\\s',\
    \ ' ')).uniq.count{|word| word =~ /^[a-z]/}.to_s + \\\n      split_words(txt.gsub('\\\
    s', ' ')).uniq.count{|word| word =~ /^[a-z]/}.to_s\n  end\nend", "  words = ''\n\
    \  word = ''\n  letter = ''\n  split = ''\n  i = 0\n  while i < txt.length\n \
    \   if txt[i] != ' '\n      letter = txt[i].chr\n      word << letter\n    else\n\
    \      split << word\n      word = ''\n    end\n    i += 1\n  end\n  split <<\
    \ word\n  return split.size\nend", "    words = \"\"\n    alphabet = string.ascii_lowercase\n\
    \    words = txt.split() \n    length = len(words)\n    \n    if length > 1 and\
    \ length < 26:\n        if string.ascii_lowercase[ord(words[length-1][0]) - ord('a')]\
    \ == 'b':\n            return split_words(words[length-1] + words[length-2])\n\
    \        elif string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'c':\n\
    \            return split_words(words[length-1] + words[length-2])\n        elif\
    \ string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'd':\n       \
    \     return split_words(words[length-1] + words[length-2])\n        elif string.ascii_lowercase[ord(words[length-1][0])\
    \ - ord('a')] == 'e':\n            return split_words(words[length-1] + words[length-2])\n\
    \        elif string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'f':\n\
    \            return split_words(words[length-1] + words[length-2])\n        elif\
    \ string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'g':\n       \
    \     return split_words(words[length-1] + words[length-2])\n        elif string.ascii_lowercase[ord(words[length-1][0])\
    \ - ord('a')] == 'h':\n            return split_words(words[length-1] + words[length-2])\n\
    \        elif string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'i':\n\
    \            return split_words(words[length-1] + words[length-2])\n        elif\
    \ string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'j':\n       \
    \     return split_words(words[length-1] + words[length-2])\n        elif string.ascii_lowercase[ord(words[length-1][0])\
    \ - ord('a')] == 'k':\n            return split_words(words[length-1] + words[length-2])\n\
    \        elif string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'l':\n\
    \            return split_words(words[length-1] + words[length-2])\n        elif\
    \ string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'm':\n       \
    \     return split_words(words[length-1] + words[length-2])\n        elif string.ascii_lowercase[ord(words[length-1][0])\
    \ - ord('a')] == 'n':\n            return split_words(words[length-1] + words[length-2])\n\
    \        elif string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'o':\n\
    \            return split_words(words[length-1] + words[length-2])\n        elif\
    \ string.ascii_lowercase[ord(words[length-1][0]) - ord('a')] == 'p':\n", "  words\
    \ = []\n  words.push txt.split('')\n  words.push txt.split(//)\n  words.push txt.split\
    \ /\\s/\n  words.push txt.split /[,]/\n  words.push txt.split /[!,]/\n  words.push\
    \ txt.split /[=,]/\n  words.push txt.split /[>,<,>=,<=,!=]/\n  words.push txt.split\
    \ /[\\(\\)\\{\\}\\[\\]\\*\\+\\-\\/,;:!\\.]/\n  words.push txt.split /[\\t]/\n\
    \  return words.uniq.length\nend\n</code>\nFor this specific problem you can get\
    \ an expected result in less than a second with something like this (I added comments\
    \ to the code so that you can follow along):\n<code>", "  \n  # Initialize empty\
    \ array\n  words = []", "    # Your code here\n    # txt = txt.split(' ')\n  \
    \  words = txt.split(\" \")\n    if words.count == 0\n        words = txt.split(',')\n\
    \    end\n    letters = words.map {|w| w.chars.map(&:downcase).count('a'..'z').odd?\
    \ ? w.chars.map(&:downcase).count('a'..'z').odd? : w}\n    return letters.count\
    \ - 1 # Because the letters array contains the empty string\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| c |>\nThis is actually more complicated than it needs\
    \ to be. The input string is already splitting on whitespace, no need for the\
    \ `map`.\n<|/ c |>\n<| a dscore=1 |>\nThis looks like a good place to use the\
    \ regex feature of Ruby strings. It isn't as efficient as using regular expressions\
    \ in Ruby, but it is easy to read and to debug. If you'd like to read about it,\
    \ look up Regular Expressions in Ruby\n<code>", "    words=[]\n    count=0\n \
    \   for letter in txt\n        if letter==' '\n            words.append(letter)\n\
    \            count+=1\n        else \n            words.append(count) \n     \
    \       count=0 \n            words.append(letter)\n    words.append(count)\n\
    \    return words\n</cell>\n<cell>", "  if txt.empty?\n    0\n  else\n    txt.downcase.split(\"\
    \ \").collect do |word| \n      word.include?(\" \") ? word.count : word.count(\"\
    ,\").to_i\n    end.max \n  end\nend\n</code>\n<|/ a |>\n<| c |>\nI think it would\
    \ be better to use the method `split` for the first part than splitting and counting\
    \ afterwards.\n<|/ c |>\n<| c |>\nThis would be a good answer if it showed how\
    \ the code was actually correct.  It looks like the original code doesn't actually\
    \ do what it says it does.  What are you trying to do, exactly?\n<|/ c |>\n<|\
    \ c |>\nThe original code doesn't do what it says it does, but that's not what\
    \ was asked - how would you do this if you wanted to split at commas?  What would\
    \ the count be?\n<|/ c |>\n<| c |>\nYou would have to change the line `txt.downcase.split(\"\
    \ \").collect do |word|` to `txt.downcase.split(\", \").collect do |word|` - see\
    \ my edit. The problem is that `txt.downcase.split(\" \")` splits `txt` into words\
    \ at all spaces, where `txt.downcase.split(\", \")` splits it at just commas -\
    \ the code above is correct, as the question asks, it's just incomplete.\n<|/\
    \ c |>\n<| c |>\nI apologize if I was not clear, but I believe that is my problem\
    \ - when I asked for the count, I meant exactly what the code does already, I\
    \ just wanted the method to return the number of letters that occurred with an\
    \ even order (alphabetically).\n<|/ c |>\n<| a tags=ruby,string |>\nTo count the\
    \ frequency of words using Ruby 1.9:\n<code>\ntxt = \"This is the first sentence.\
    \ Second sentence.\"\narr = txt.split # => [\"This\", \"is\", \"the\", \"first\"\
    , \"sentence.\", \"Second\", \"sentence.\"]\narr.group_by { |x| x.split } # =>\
    \ {\"This\"=>[\"This\"], \"is\"=>[\"is\"], \"the\"=>[\"the\"], \"first\"=>[\"\
    first\", \"sentence.\"], \"Second\"=>[\"Second\", \"sentence.\"]} \narr.group_by\
    \ { |x| x.split }.map { |k, v| v.count }.inject(:+) # => 3\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nI would do the following:\n<code>\nrequire 'strscan'\ntxt = \"\
    This is the first sentence. Second sentence. Third sentence.\"\ncount = 0\n",
  "  return txt.split(\" \") if txt.include?(\" \") || txt.include?(\",\") || txt.include?(\"\
    \\r\") || txt.include?(\"\\n\") \n  txt.split(\"\").each_with_index.map{ |c, i|\
    \ c.downcase if c !~ /[a-z]/i && c.downcase !~ /[a-z]/i }.count\nend\nputs split_words(\"\
    hello, world!\")\nputs split_words(\"a, bcdef\")\nputs split_words(\"a bcdef\"\
    )\nputs split_words(\"abcde\")\nputs split_words(\"abcde,f\")\nputs split_words(\"\
    a  b   cde,f\")\nputs split_words(\"a b cde,f\")\nputs split_words(\"ab,cd,ef,\"\
    )\nputs split_words(\"a,bcdef\")\nputs split_words(\"a,bcdef,\")\nputs split_words(\"\
    a,bcdef,ghijk\")\nputs split_words(\"a,bcdef,ghijk,\")\nputs split_words(\"abcde\"\
    )\nputs split_words(\"abcdef\")\nputs split_words(\"abcde fghijklmnopqr\")\nputs\
    \ split_words(\"abcde fghijklmnopqr,\")\nputs split_words(\"abcde fghijklmnopqr,\
    \ \")\nputs split_words(\"abc def\")\nputs split_words(\"abc,def\")\nputs split_words(\"\
    abc, def\")\nputs split_words(\"abc,def,ghij\")\nputs split_words(\"abc, def,ghij,\"\
    )\nputs split_words(\"abc, def, ghij,\")\nputs split_words(\"abc def,ghijklmnopqr\"\
    )\nputs split_words(\"abc def,ghijklmnopqr,\")\nputs split_words(\"abc def,ghijklmnopqr,\
    \ \")\nputs split_words(\"abc, def,ghijklmnopqr,\")\nputs split_words(\"abc def,ghijklmnopqr,\"\
    )\nputs split_words(\"abc, def, ghij,\")\nputs split_words(\"abc, def, ghijk,\"\
    )\nputs split_words(\"abc def,ghij,\")\nputs split_words(\"abc  def, ghijklmnopqr\"\
    )", "\twords = txt.split(\" \")\n\tif words.size == 0 then\n\t\twords = txt.split(\"\
    ,\")\n\t\tif words.size == 0 then\n\t\t\twords = txt.split(\"-\")\n\t\t\tif words.size\
    \ == 0 then\n\t\t\t\twords = txt.split(\"+\")\n\t\t\t\tif words.size == 0 then\n\
    \t\t\t\t\twords = txt.split(\"&\")\n\t\t\t\t\tif words.size == 0 then\n\t\t\t\t\
    \t\twords = txt.split(\"\\\\\")\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn words\nend", "  return txt.split(' ')\nend", "  words = txt.split(//)\n\
    \  word_list = []\n  if words.length > 0\n    word_list = words.split(//)\n  \
    \  word_list.each do |word|\n      word.downcase!\n    end\n    word_list\n  else\n\
    \    word_list\n  end\nend", "  # Write your code here\n  \n  splitted_words =\
    \ []\n  \n  words_in_txt = txt.split(\" \")\n  \n  for word in words_in_txt:\n\
    \    splitted_words.append(word.split(\",\"))\n  \n  if len(splitted_words) ==\
    \ 1:\n    return splitted_words[0]\n  elif len(splitted_words) == 0:\n    return\
    \ len(txt.lower())\n  \n  \n  sorted_words = sorted(splitted_words[0])\n  \n \
    \ num_letters = 0\n  \n  for word in splitted_words[1:]:\n    if sorted_words\
    \ == word:\n      num_letters += 1\n    sorted_words = sorted(word)\n    \n  return\
    \ num_letters"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
