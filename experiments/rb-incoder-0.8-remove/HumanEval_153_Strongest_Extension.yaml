name: HumanEval_153_Strongest_Extension
language: rb
prompt: "# You will be given the name of a class (a string) and a list of extensions.\n\
  # The extensions are to be used to load additional classes to the class. The\n#\
  \ strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  # letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n# in the extension's name, the strength is given by the fraction CAP - SM. \n\
  # You should find the strongest extension and return a string in this \n# format:\
  \ ClassName.StrongestExtensionName.\n# If there are two or more extensions with\
  \ the same strength, you should\n# choose the one that comes first in the list.\n\
  # For example, if you are given \"Slices\" as the class and a list of the\n# extensions:\
  \ ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n# return 'Slices.SErviNGSliCes'\
  \ since 'SErviNGSliCes' is the strongest extension \n# (its strength is -1).\n#\
  \ Example:\ndef Strongest_Extension(class_name, extensions)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_Strongest_Extension\n\
  \    candidate = method(:Strongest_Extension)\n    assert_equal(\"Watashi.eIGHt8OKe\"\
  , candidate.call(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]))\n    assert_equal(\"\
  Boku123.YEs.WeCaNe\", candidate.call(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\"\
  , \"32145tggg\"]))\n    assert_equal(\"__YESIMHERE.NuLl__\", candidate.call(\"__YESIMHERE\"\
  , [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]))\n\
  \    assert_equal(\"K.TAR\", candidate.call(\"K\", [\"Ta\", \"TAR\", \"t234An\"\
  , \"cosSo\"]))\n    assert_equal(\"__HAHA.123\", candidate.call(\"__HAHA\", [\"\
  Tab\", \"123\", \"781345\", \"-_-\"]))\n    assert_equal(\"YameRore.okIWILL123\"\
  , candidate.call(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
  , \"-_-\"]))\n    assert_equal(\"finNNalLLly.WoW\", candidate.call(\"finNNalLLly\"\
  , [\"Die\", \"NowW\", \"Wow\", \"WoW\"]))\n    assert_equal(\"_.Bb\", candidate.call(\"\
  _\", [\"Bb\", \"91245\"]))\n    assert_equal(\"Sp.671235\", candidate.call(\"Sp\"\
  , [\"671235\", \"Bb\"]))\n  end\nend\n"
completions: ["  extensions_array = extensions.to_a\n  strongest_extension = nil\n\
    \  extensions_array.each do |extension|\n    extension_name = extension.downcase\n\
    \    extension_number = extension_name.chars.count\n    if extension_number >\
    \ 0 && extension_number < 5\n      extension_number = extension_number.to_i\n\
    \      strongest_extension = class_name + '.' + extension_name + extensions_array[extensions.index(extension)\
    \ + 1]\n      break\n    end\n  end\n  strongest_extension\nend", "    # Write\
    \ your code here.\n    extension_set = extension_set = Set()\n    for i in extensions:\n\
    \        extension_set.add(i.upper())", "    className = class_name.to_s.upcase\n\
    \    extensions.sort.reverse!\n    extensions.each do |extension|\n        splitted\
    \ = extension.to_s.downcase.split(//)\n        strength = -1\n        splitted.each\
    \ do |char|\n            if char.upcase > char.downcase\n                strength\
    \ += 1\n            end\n        end\n        if strength > 0\n            return\
    \ String.new(\"#{className}.#{extension}\") if strength == className.upcase.length\n\
    \        end\n    end\nend\n</cell>\n<code language=julia-1.4>", "  best_strength\
    \ = -1\n  best_ext_name = nil\n  extensions.each do |extension|\n    ext_cap =\
    \ extension.upcase.count(\"A\")\n    ext_sm = extension.downcase.count(\"a\")\n\
    \    strength = ext_cap - ext_sm\n    if strength > best_strength\n      best_strength\
    \ = strength\n      best_ext_name = extension\n    end\n  end\n  return class_name.concat(best_ext_name)\n\
    end", "    extensions_length = len(extensions)\n    strongest = extensions_length\n\
    \    lowest_index = -1\n    lowest_index = lowest_index + 1 \n    \n    #\n  \
    \  # SOLUTION GOES HERE\n    #\n    # Write code here\n    \n    \n    return\
    \ class_name+\".\"+extensions[lowest_index]\nend", "    extension_count = 0\n\
    \    extension_strength = 0\n    classname = class_name\n    extension_strengths\
    \ = [0] * len(extensions)\n    for extension in extensions\n        extension_count\
    \ += 1\n        extension_strength = ord(extension) - ord('A')\n        extension_strengths[extension_count]\
    \ = extension_strength\n    end\n    max = extension_strengths.max\n    strongest_extension\
    \ = extension_strengths[max]\n    strongest_extension_classname = classname +\
    \ \".\" + strongest_extension\n    return strongest_extension_classname\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby,algorithm,sorting |>\nIf one wants\
    \ an answer that works regardless of the language used, this might help:\n<code>",
  "  extension_count = 0\n  strongest_extension = -1\n  \n  for extension in extensions\n\
    \    if extension_count > strongest_extension\n      if extension_count > strongest_extension\n\
    \        strongest_extension = extension_count\n      else\n        strongest_extension\
    \ = extension_count\n    end\n    extension_count = extension_count + 1\n  end\n\
    \  \n  return class_name + Strongest_Extension_Name(class_name, strongest_extension)\n\
    end", "  # Write your code here.\nend", "  \n  # TODO: Write your code here.\n\
    \  \nend", end, "  best_extension = nil\n  best_strength = -1\n  best_count =\
    \ 0\n  best_index = nil\n  \n  extensions.each_with_index do |extension, index|\n\
    \    strength = class_name.send(:class_name_strength, extension)\n    \n    if\
    \ strength > best_strength\n      best_extension = extension\n      best_strength\
    \ = strength\n      best_count = index\n    end\n  end", "\tn = name.length\n\t\
    s.clear", "    extension_strengths = Array.new\n    for extension in extensions\n\
    \        extension_strengths[extensions.index(extension)] = (extension.match(/[A-Z]/).to_i\
    \ - extension.match(/[a-z]/).to_i) / extension.match(/[A-Z]/).to_i)\n    end\n\
    \    extension_strengths = extension_strengths.sort{|a,b| b[1]<=>a[1]}\n    extension_strengths.reverse!\n\
    \    extension_strengths[0][0] == -1 ? \"NA\" : extension_strengths[0][0] > extension_strengths.last()[0]\
    \ ? \"#{class_name}.#{extension_strengths.last()[0]}\" : \"#{class_name}.#{extension_strengths.last()[0]}\"\
    \nend", "  extensions_counter = Hash.new()\n  \n  for extension in extensions\n\
    \    extensions_counter[extension] += 1\n  end\n  \n  strongest_extension_strength\
    \ = -1\n  \n  extensions.each do |extension|\n    strongest_extension_strength\
    \ += extensions_counter[extension]\n  end\n  \n  return class_name.constantize.const_get(class_name).name.tr('A-Z',\
    \ 'a-z')\nend\n</cell>\n<cell>", "  str.split.map do |extension| \n    if extension.downcase.split(//)-extension.split(//).map{|s|\
    \ s.to_i}.max == 0 \n      class_name.gsub(\"Slices\",\"\").gsub(\"Extensions\"\
    ,\"\").gsub(\" \",\"\").gsub(\"s\",\"\")+\"Extension\"+extension.gsub(\"s\",\"\
    \").to_s.capitalize\n    else \n      class_name.gsub(\"Slices\",\"\").gsub(\"\
    Extensions\",\"\").gsub(\" \",\"\").gsub(\"s\",\"\")+\"Extension\"+extension.gsub(\"\
    s\",\"\").to_s.capitalize\n    end\n  end\nend", "  extension_strength_sum = -1\n\
    \  \n  extension_strength_sum = extension_strength_sum + extensions.inject(0){\
    \ |sum, extension| \n    sum = sum + extension_strength_strength(extension)\n\
    \  }", "  extension_count = Hash.new(0)\n  extensions.each do |extension|\n  \
    \  extension_count[extension.upcase] += 1\n  end\n  highest_strength = extension_count.values.max\n\
    \  extensions.each do |extension|\n    if extension_count[extension.upcase] >=\
    \ highest_strength\n      return class_name + \".\" + extension.upcase\n    end\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nWhat would happen if the same\
    \ extension appears multiple times in the list? The first would be selected.\n\
    <|/ c |>\n<| c |>\nI suppose the OP would have to clarify that requirement in\
    \ the question.\n<|/ c |>\n<| a tags=ruby dscore=1 |>\nThe first thing I would\
    \ do is create a hash with counts of each extension. Once you have the hash, you\
    \ can take the highest one by doing the following:\n<code>\nhash = [{abc: 1},\
    \ {def: 2}]\nhash.max_by { |k,v| v[1] }", "  extension_strongest = nil\n  \n \
    \ strongest_class_name = class_name.downcase\n  strongest_extensions = extensions.sort\n\
    \  \n  # Go through extensions until one matches the strongest class name\n  until\
    \ strongest_extensions.any? { |e| e.include?(strongest_class_name) }\n    extension_strongest\
    \ = extension_strongest || \"None\"\n  end\n  \n  # If no extensions match the\
    \ class name, default to \"\"\n  extension_strongest = extension_strongest ||\
    \ \"\"\n  \n  # Return the extension strongest name\n  extension_strongest\nend",
  "  # write your code here\nend\n</pre>\n<pre>", "  cap_strength = extension_strength(class_name,\
    \ extensions).downcase\n  cap_strength = cap_strength.split.length\n  cap_strength\
    \ = cap_strength.to_f\n  cap_strength /= cap_strength.to_i\n  cap_strength = cap_strength.ceil\n\
    \  cap_strength = \"#{class_name}.#{extensions[cap_strength.to_i - 1]}\"\n  return\
    \ cap_strength if cap_strength > 0\n  extension_order = extension_strength(class_name,\
    \ extensions).downcase.split.reverse\n  cap_strength = extension_order[cap_strength.to_i\
    \ - 1]\n  cap_strength = \"#{class_name}.#{cap_strength}\"\n  return cap_strength\
    \ if cap_strength > 0\n  extension_order.detect{ |x| extension_strength(x, extensions)\
    \ == cap_strength }\nend", "  s = \"\"\n  max = extensions.length\n  i = 0\n \
    \ while i < max\n    extension = extensions[i]\n    cap = extension.count(\"A\"\
    )\n    sm = extension.count(\"a\")\n    ext = cap - sm\n    if ext > 0\n     \
    \ break\n    i += 1\n  end\n  if ext.zero? then ext = \"\" end\n  ext = extension.downcase\n\
    \  \n  s = class_name + ext\n  \n  max = extensions.length\n  i = 0\n  while i\
    \ < max\n    extension = extensions[i]\n    cap = extension.count(\"A\")\n   \
    \ sm = extension.count(\"a\")\n    ext = cap - sm\n    if ext > 0\n      break\n\
    \    i += 1\n  end\n  if ext.zero? then ext = \"\" end\n  ext = extension.downcase\n\
    \  \n  s = class_name + ext + \"S\"\n  \n  max = extensions.length\n  i = 0\n\
    \  while i < max\n    extension = extensions[i]\n    cap = extension.count(\"\
    A\")\n    sm = extension.count(\"a\")\n    ext = cap - sm\n    if ext > 0\n  \
    \    break\n    i += 1\n  end\n  if ext.zero? then ext = \"\" end\n  ext = extension.downcase\n\
    \  \n  s = class_name + ext + \"SE\"\n  \n  max = extensions.length\n  i = 0\n\
    \  while i < max\n    extension = extensions[i]\n    cap = extension.count(\"\
    A\")\n    sm = extension.count(\"a\")\n    ext = cap - sm\n    if ext > 0\n  \
    \    break\n    i += 1\n  end\n  if ext.zero? then ext = \"\" end\n  ext = extension.downcase\n\
    \  \n  s = class_name + ext + \"SED\"\n  \n  max = extensions.length\n  i = 0\n\
    \  while i < max\n    extension = extensions[i]\n    cap = extension.count(\"\
    A\")\n    sm = extension.count(\"a\")\n    ext = cap - sm\n    if ext > 0\n  \
    \    break\n    i += 1\n  end\n  if ext.zero? then ext = \"\" end\n  ext = extension.downcase\n\
    \  \n  s = class_name + ext + \"SED\"\n  \n  max = extensions.length\n  i = 0\n\
    \  while i < max\n    extension = extensions[i]\n    cap = extension.count(\"\
    A\")\n    sm = extension.count(\"a\")\n    ext = cap - sm\n    if ext > 0\n  \
    \    break\n    i += 1\n  end\n  if ext.zero? then ext = \"\" end\n  ext = extension.downcase\n\
    \  \n  s = class_name + ", "  highest_strongest = 0\n  extensions_with_strength\
    \ = []\n  \n  # Sort the list by strength\n  extensions.sort_by! { |e| e.to_s.split(//).map\
    \ { |c| c.upcase.rindex(c.downcase) + 1 }.max}\n  \n  # Now the list is sorted\
    \ by strength, first is the highest strength, \n  # so just use first element\n\
    \  highest_strongest = extensions.first\n  \n  # Now find extension with the highest\
    \ strength in the list\n  extensions_with_strength = extensions.find {|e| e.to_s.split(//).map\
    \ { |c| c.upcase.rindex(c.downcase) + 1 }.max == highest_strongest.to_i}\n  \n\
    \  return highest_strongest.class.to_s + \".\" + extensions_with_strength.first.class.to_s\
    \ + \"_\" + extensions_with_strength.first.name\nend", "  extension = extensions[0]\n\
    \  strength = -1 \n  \n  # Write your code here.\n  strength = 0\n  extension.each\
    \ do |e|\n    if e.downcase == class_name\n      strength += 1\n    end\n  end\n\
    \  \n  strength / (extensions.length - 1).ceil\nend", "  extensions_with_same_strength\
    \ = extensions.group_by do |x| \n    x.first.size\n  end", "  highest_strength\
    \ = -1\n  highest_extension = \"\"\n  highest_extension_class = \"\"", "    #\
    \ code here\nend", "  max_strength = -1\n  max_strength_extension = nil\n  \n\
    \  extensions.each do |extension|\n    extension_parts = extension.split('.')\n\
    \    \n    strength = class_name.count(extension_parts[0].upcase) - class_name.count(extension_parts[1].downcase)\n\
    \    \n    if strength > max_strength\n      max_strength = strength\n      max_strength_extension\
    \ = extension\n    end\n  end\n  \n  return max_strength_extension\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby |>\n<| c |>\nI dont know why but this doesnt work for\
    \ 'Slices'. It returns 'SlicesSlices' instead of 'Slices'\n<|/ c |>\n<| c |>\n\
    Ok, I see where I went wrong. The \"Slices\" was the name of a class. So I modified\
    \ it to return the extension of 'Slices' class instead of just \"Slices\". Thanks!\n\
    <|/ c |>\n<| c |>\n: Glad to have helped, and don't forget to upvote an answer\
    \ if it helped you.\n<|/ c |>\n<| a dscore=0 |>\nThis works on Ruby 2.5.3:\n<code>",
  "    \nend", "  strongest_extension = extensions[0]\n  extensions.each {|extension|\
    \ strongest_extension = \n                     extension if extension.include?(strongest_extension)\
    \ }\n  strongest_extension\nend", "    # Write your code here.\n    return ''\n\
    </code>\nThis is the test cases that you will run for the above function\n<code>\n\
    Test.assert_equals(Strongest_Extension('Slice', ['SErviNGSliCes', 'Cheese', 'StuFfed']),\
    \ \n'Slices.SErviNGSliCes')\nTest.assert_equals(Strongest_Extension('Noise', ['ACerviNGSliCes',\
    \ 'ChiPing','ToBeRemoved']), \n'Noise.ACerviNGSliCes')\nTest.assert_equals(Strongest_Extension('Slice',\
    \ ['SErviNGSliCes', 'Cheese', 'StuFfed', 'ToBeRemoved']), \n'Slices.SErviNGSliCes')\n\
    Test.assert_equals(Strongest_Extension('Slice', ['SErviNGSliCes', 'Cheese', 'StuFfed',\
    \ 'ToBeRemoved', 'ToBeRemoved']), \n'Slices.SErviNGSliCes')\nTest.assert_equals(Strongest_Extension('Slice',\
    \ ['SErviNGSliCes', 'Cheese', 'StuFfed', 'ToBeRemoved', 'ToBeRemoved', 'Cheese']),\
    \ \n'Slices.SErviNGSliCes')\nTest.assert_equals(Strongest_Extension('Noise', ['ACerviNGSliCes',\
    \ 'ChiPing', 'ToBeRemoved']), \n'Noise.ACerviNGSliCes')\nTest.assert_equals(Strongest_Extension('Noise',\
    \ ['ACerviNGSliCes', 'ChiPing','ToBeRemoved']), \n'Noise.ACerviNGSliCes')\nTest.assert_equals(Strongest_Extension('Noise',\
    \ ['ACerviNGSliCes', 'ChiPing','ToBeRemoved', 'Cheese']), \n'Noise.ACerviNGSliCes')\n\
    Test.assert_equals(Strongest_Extension('Noise', ['ACerviNGSliCes', 'ChiPing','ToBeRemoved',\
    \ 'Cheese', 'StuFfed']), \n'Noise.ACerviNGSliCes')\nTest.assert_equals(Strongest_Extension('Noise',\
    \ ['ACerviNGSliCes', 'ChiPing','ToBeRemoved', 'Cheese', 'StuFfed', 'ToBeRemoved']),\
    \ \n'Noise.ACerviNGSliCes')\nTest.assert_equals(Strongest_Extension('Noise', ['ACerviNGSliCes',\
    \ 'ChiPing','To", '  sorted_extensions = extensions # Make a copy of extensions
    so that extensions is unmodified.', "    # Initialize min to be the first extension.\n\
    \    min = 0\n    # Initialize max to be the second extension.\n    max = 0\n\
    \    # Loop through all the extensions given and find their \n    # strength (number\
    \ of uppercase letters - number of lowercase letters).\n    for extension in extensions\n\
    \        cap = class_name.index(extension.upcase)\n        sm = class_name.index(extension.downcase)\n\
    \        strength = cap - sm\n        # If the extension's strength is less than\
    \ the minimum, then\n        # it is the minimum extension.\n        if strength\
    \ < min\n            min = strength\n        # If the extension's strength is\
    \ more than the maximum, then\n        # it is the maximum extension.\n      \
    \  if strength > max\n            max = strength\n    end\n    # Return the extension\
    \ with the lowest strength (i.e. the one with\n    # lowest number of uppercase\
    \ letters - lowest number of lowercase letters).\n    return class_name[min]\n\
    end", '  extension_strengths = []', "\tstrongest_extension = ''\n\tstrongest_extension_strength\
    \ = -1\n\t\n\textensions_hash = Hash.new\n\textensions_hash.update(extensions.join(''))",
  "  strength = 0\n  extension_class = class_name \n  extension = extensions[0]\n\
    \  \n  for i in range(len(extensions)):\n    if extension_class.capitalize.index(extensions[i].capitalize)\
    \ != -1\n    then\n      strength = extensions[i].capitalize.index(extensions[i].capitalize)\n\
    \      extension_class = extensions[i]\n      break\n    end\n  end\n  \n  return\
    \ class_name.capitalize + extension.capitalize(strength)\nend", "  # Write your\
    \ code here.\n  extensions.sort.inject(\"\", lambda x, y: x + ((class_name.upcase.length\
    \ - y.downcase.length) * \"#{y}\"))\nend", "    return extensions[0]\nend\n</code>\n\
    <|/ a tags=ruby,algorithm,string |>\n<| a dscore=0 |>\nHere's another solution,\
    \ similar to Amit Singh's, using Array#index as hash. \n<code>", "  extensions.sort!{|a,b|\
    \ a.to_s.length <=> b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each\
    \ {|e| e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length\
    \ <=> b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.sort!{|a,b| a.to_s.length <=>\
    \ b.to_s.length}\n  extensions.each {|e| e.downcase!}\n  extensions.each {|e|\
    \ e.delete!('I') if e.index('I')}\n  extensions.", "    # Write your code here.\n\
    \    ext_name_hash = {}\n    ext_name_hash[''] = -1\n    ext_name_hash['Slice']\
    \ = 0\n    ext_name_hash['Slices'] = 1\n    ext_name_hash['SErviNGSliCes'] = 1\n\
    \    ext_name_hash['Cheese'] = 1\n    ext_name_hash['StuFfed'] = 1\n    ext_name_hash['SErviNGSliCes']\
    \ = 3\n    ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed'] = 2\n   \
    \ ext_name_hash['SErviNGSliCes'] = 4\n    ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed']\
    \ = 2\n    ext_name_hash['SErviNGSliCes'] = 5\n    ext_name_hash['Cheese'] = 2\n\
    \    ext_name_hash['StuFfed'] = 2\n    ext_name_hash['SErviNGSliCes'] = 6\n  \
    \  ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed'] = 2\n    ext_name_hash['SErviNGSliCes']\
    \ = 7\n    ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed'] = 2\n   \
    \ ext_name_hash['SErviNGSliCes'] = 8\n    ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed']\
    \ = 2\n    ext_name_hash['SErviNGSliCes'] = 9\n    ext_name_hash['Cheese'] = 2\n\
    \    ext_name_hash['StuFfed'] = 2\n    ext_name_hash['SErviNGSliCes'] = 10\n \
    \   ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed'] = 2\n    ext_name_hash['SErviNGSliCes']\
    \ = 11\n    ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed'] = 2\n  \
    \  ext_name_hash['SErviNGSliCes'] = 12\n    ext_name_hash['Cheese'] = 2\n    ext_name_hash['StuFfed']\
    \ = 2\n    ext_name_hash['SErviNGSliCes'] = 13\n    ext_name_hash['Cheese'] =\
    \ 2\n    ext_name_hash['StuFfed'] = 2\n    ext_name_hash['SErviNGSliCes'] = 14\n\
    \    ext_name_hash['Cheese'] = 2\n    ext_name_hash['", "  strongest_extension\
    \ = \"\"\n  extensions.each do |extension|\n    strength = CAP - extension.downcase.rindex('a')\n\
    \    if strength < 0\n      extensions.delete(extension)\n    else\n      strongest_extension\
    \ = class_name+\".\"+extension[strength..-1]\n    end\n  end\n  return strongest_extension\
    \ if strongest_extension.present?\nend", "    \n    strongest_extension = \"\"\
    \n    \n    extensions.each do |extension|\n        strength = extension[0].downcase.length.to_f\
    \ / (extension[0].downcase.length.to_f + extension[1].downcase.length.to_f)\n\
    \        \n        if strength > strongest_extension.length\n            strongest_extension\
    \ = extension\n        end\n    end\n    \n    return strongest_extension\nend",
  "  best_extension = -1\n  best_strongest_extension = class_name\n  best_extension_strength\
    \ = 0", "  # We will be storing the strongest extension name in a variable \n\
    \  # (we'll call it 'ext'). \n  ext = ''\n  # We will iterate through the list\
    \ of extensions in the argument\n  # (we'll call it 'exts'). \n  exts = extensions\
    \ \n  # We will iterate through the list of classes in the argument\n  # (we'll\
    \ call it 'className'). \n  classNames = class_name \n  # We will iterate through\
    \ the list of extensions in the argument\n  # (we'll call it 'extension'). \n\
    \  extensions = className \n  # We will iterate through the list of classes in\
    \ the argument\n  # (we'll call it 'classNames'). \n  classNames = className \n\
    \  # We will iterate through the list of extensions in the argument\n  # (we'll\
    \ call it 'extensions'). \n  extensions = className\n  # We will iterate through\
    \ the list of extensions in the argument\n  # (we'll call it 'className'). \n\
    \  classNames = className \n  # We will iterate through the list of extensions\
    \ in the argument\n  # (we'll call it 'extension'). \n  extensions = classNames\
    \ \n  # We will iterate through the list of extensions in the argument\n  # (we'll\
    \ call it 'extensions'). \n  extensions = className \n  # We will iterate through\
    \ the list of extensions in the argument\n  # (we'll call it 'extensions'). \n\
    \  extensions = classNames \n  # We will iterate through the list of extensions\
    \ in the argument\n  # (we'll call it 'extensions'). \n  extensions = className\
    \ \n  # We will iterate through the list of extensions in the argument\n  # (we'll\
    \ call it 'extensions'). \n  extensions = className \n  # We will iterate through\
    \ the list of extensions in the argument\n  # (we'll call it 'extensions'). \n\
    \  extensions = className \n  # We will iterate through the list of extensions\
    \ in the argument\n  # (we'll call it 'extensions'). \n  extensions = className\
    \ \n  # We will iterate through the list of extensions in the argument\n  # (we'll\
    \ call it 'extensions'). \n  extensions = className \n  # We will iterate through\
    \ the list of extensions in the argument\n  # (we'll call it 'extensions'). \n\
    \  extensions = className \n  # We will iterate through the list of extensions\
    \ in the argument\n  # (we'll call it 'extensions'). \n  extensions = className\
    \ \n  # We will iterate through the list of extensions in the argument\n  # (we'll\
    \ call it 'extensions'). \n  extensions = className \n  # We will iterate through\
    \ the list of extensions in the argument\n  # (we'll call it 'extensions'). \n\
    \  extensions = className \n  # We will iterate through the list of extensions\
    \ in the argument\n  # (we'll call it 'extensions'). \n  extensions = className\
    \ \n  # We will iterate through the list of ", "  name_hash = Hash_Extension(class_name,\
    \ extensions)\n  max_strength = find_max_extension(name_hash)\n  return \"#{class_name}.#{max_strength}\"\
    \nend", '    strength = nil', "  \n  # Write your code here.\n  \n  extension_count\
    \ = extensions.size\n  \n  index_of_strongest_extension = nil\n  \n  index_of_strongest_extension\
    \ = extension_count.to_s.each_char.map { |x| x.ord }.min_by { |i| extensions[i].name.gsub(/[A-Z]/,\
    \ '')[0].ord }", "  extensions_sorted = extensions.sort!\n  extensions_sorted.reverse!\n\
    \  extensions_sorted.first\nend", "  strongest_extension = nil\n  extensions.each\
    \ do |extension|\n    index = class_name.index(extension)\n    index = index -\
    \ 1 if index\n    if index > 0\n      strength = class_name.count(\"#{extension}\"\
    )\n      if strength < strongest_extension.count(\"#{extension}\")\n        strongest_extension\
    \ = \"#{\"#{class_name}\" if index == 0}\"\n      end\n    end\n  end\n  return\
    \ strongest_extension\nend", "\textension_strength = Array.new\n\textension_strength.fill(-1)\n\
    \t\n\textensions.each do |extension|\n\t\tcapital_letters = extension.to_s.split('').select\
    \ {|s| s.match(/[A-Z]/) }.size\n\t\tlower_letters = extension.to_s.split('').select\
    \ {|s| s.match(/[a-z]/) }.size\n\t\textension_strength[capital_letters - lower_letters]\
    \ = capital_letters - lower_letters + 1\n\tend\n\t\n\textension_strength.sort_by\
    \ { |value, index| -value }.reverse.first\nend", "\textensions = extensions.sort!\n\
    \textensions.each do |ext|\n\t\tidx = ext.index(class_name)\n\t\tif idx >= 0 then\n\
    \t\t\tbreak\n\t\telse\n\t\t\tidx = -1\n\t\tend\n\tend\n\tidx = idx+1 if idx >=\
    \ 0\n\tclass_name = class_name[idx..-1]\n\treturn class_name.classify + \".\"\
    \ + extensions.last\nend", "  extension_strength_hash = {}\n  extension_order\
    \ = []\n  \n  extension_order = extension_order.sort.reverse\n  \n  extension_order.each\
    \ do |ext|\n    ext_name = ext.downcase.gsub(/[a-z]/, '')\n    ext_strength =\
    \ ext_name[0].ord.to_f - (ext_name[0].ord.to_f - ext_name[1].ord.to_f)/2\n   \
    \ \n    extension_strength_hash[ext_name] = ext_strength\n  end\n  \n  extension_strength_hash[class_name]\
    \ = -1\n  \n  extension_strength_hash.each do |ext, strength|\n    if strength\
    \ > extension_strength_hash[class_name]\n      extension_strength_hash[class_name]\
    \ = strength\n    end\n  end\n  \n  extension_strength_hash[class_name].to_s.gsub(/[^0-9A-Za-z]/,\
    \ '')\nend", "  # Write your code here\n  highest_strength = -1\n  strongest_extension\
    \ = None\n  for extension in extensions\n    cap = extension.index(extension.upcase).to_i\n\
    \    sm = extension.index(extension.downcase).to_i\n    strength = (cap - sm).to_f\n\
    \    if strength > highest_strength\n      highest_strength = strength\n     \
    \ strongest_extension = extension\n    end\n  end\n  return class_name.constantize.const_get(strongest_extension)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nCan you please explain why you are finding the\
    \ highest and lowest number?\n<|/ c |>\n<| c |>\nSure, I'll add more explanation\
    \ to the answer.\n<|/ c |>\n<| c |>\nThanks, I'll check it out!\n<|/ c |>\n<|\
    \ c |>\nGreat answer! The only problem I have is that it seems the solution only\
    \ works on classes without inheritance.\n<|/ c |>\n<| a |>\nYou could use regular\
    \ expressions to extract the name of the class and add it to your array, and remove\
    \ the first and last character from the string. \n<code>", "    extension =  -1\n\
    \    strength = -1\n    extensions.each{|e|\n        sc = e.to_s.downcase.split(//).map(&:upcase).count(\"\
    A\") - e.to_s.downcase.split(//).map(&:upcase).count(\"a\")\n        if(extension\
    \ > sc)\n            extension = sc\n            strength = sc\n        end\n\
    \    }\n    class_name+\".\"+extension.to_s.downcase\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  extensions_length = length(extensions)\n\
    \  extensions_length.times do |i|\n    extensions_names_length = length(extensions[i].name)\n\
    \    extensions_names_length.times do |j|\n      name_strength = extensions[i].name[j].upcase.count\
    \ - extensions[i].name[j].downcase.count\n      name_strength = name_strength.abs\
    \ / (name_strength.abs - extensions_names_length.abs)\n      name_strength = name_strength.ceil\n\
    \      if name_strength > 0\n        return class_name + extensions[i].name +\
    \ \".\" + extensions[i].name.split('.')[name_strength.floor].join\n      end\n\
    \    end\n  end\n  return class_name\nend", "\tstrongest = extensions[0]\n\tcount\
    \ = -1\n\t\n\ti = 1\n\twhile i <= length(extensions)\n\t\t\n\t\textension = extensions[i]\n\
    \t\t\n\t\tcount = count\n\t\t\n\t\ti = i + 1\n\t\t\n\t\tif count == 0 then\n\t\
    \t\tbreak\n\t\telse\n\t\t\tif strongest.include?(extension) then\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\t\t\n\tend\n\t\n\treturn class_name .. '.' .. strongest ..\
    \ 'Extension'\nend", "  extensions_hash = Hash.new(0)\n  extensions_hash.update(extensions)\n\
    \  return class_name.gsub(/([A-Z])/, '\\1') + \n    extensions_hash.min_by { |k,\
    \ v| v.last }[0]\nend", "\textensions = extensions[1..-1]\n\tmax_strength = -1\n\
    \tmax_extension = \"\"\n\tmax_extension_strength = -1", "  sorted_extensions =\
    \ extensions.sort{|a, b| b.length<a.length ? 1 : -1}\n  strongest = sorted_extensions[0]\n\
    \  extension = sorted_extensions.shift\n  extension.each do |extension_name|\n\
    \    index = class_name.index(extension_name)\n    strongest = class_name.sub(extension_name,\
    \ index)\n  end\n  strongest\nend", "    extension_count = EnumerableUtils.sum(extensions).to_i\n\
    \    extension_count.times do |count|\n        letters = EnumerableUtils.partition(extensions,\
    \ count).map(&:first)\n        letters.count { |letter| letter.upcase.size > letter.downcase.size\
    \ }\n    end\nend", "  best_extension, best_strength = 0, 0\n  classes.each do\
    \ |class|\n    extension_strength = classes[class_name].find_extension_strength(extensions)\n\
    \    \n    if extension_strength > best_strength\n      best_extension = extension_strength\n\
    \      best_strength = extension_strength\n    end\n  end\n  return class_name\
    \ + best_extension\nend", "  extension_count = {}\n  extension_count.update(zip(extensions[0..-1],\
    \ [0]+extension_count))\n  extension_count.update(zip(extensions[-1..-1], [0]*len(extensions)))",
  "  extensions_strength = {}\n  extensions.each do |e|\n    extensions_strength[e]\
    \ = get_extension_strength(e)\n  end\n  sorted_extensions = extensions_strength.sort\
    \ do |a, b|\n    a[1] <=> b[1]\n  end\n  return class_name if sorted_extensions.size\
    \ == 1\n  return sorted_extensions.first[0] if sorted_extensions.size == 2\n \
    \ sorted_extensions.first[0].to_s + sorted_extensions.last[0]\nend", "  \n  extensions_count\
    \ = extensions.length\n  strongest_ext = \"\"\n  \n  \n  # Find the strongest\
    \ extension.\n  \n  for ext in extensions.sort{|a, b| b.to_s.split(//).join.to_f}\n\
    \    if ext.length != 0\n      ext_strength = ext.split(//).join.to_f\n      break\
    \ if ext_strength == -1\n    end\n  end\n  \n  \n  # Return the string in the\
    \ right format.\n  \n  strongest_ext += class_name + \".\"\n  strongest_ext +=\
    \ extensions[extensions_count-1]\n  strongest_ext += \".\"\n  strongest_ext +=\
    \ extensions[extensions_count - 1].capitalize\n  \n  strongest_ext\n  \nend\n\
    </cell>\n<code language=julia-0.4>", "  extensions_sorted = extensions.sort {|a,\
    \ b| b[1] <=> a[1] }\n  extensions_sorted = [extensions_sorted.first] if extensions_sorted.size\
    \ > 1\n  extensions_sorted.first[0]\nend", "  raise \"Not implemented\"\nend",
  "\textension_strengths = {}\n\textensions.each do |e|\n\t\textension_strengths[e]\
    \ = class_name.count(e) -\n\t\t\t\t\t\t\t\t  class_name.count(e.upcase) -\n\t\t\
    \t\t\t\t\t\t  class_name.count(e.downcase)\n\tend\n\textension_strengths.keys.sort!.first\n\
    end", "  extensions = extensions.to_a\n  extensions = extensions.sort { |x,y|\
    \ x.to_i.abs - y.to_i.abs}\n  extensions.map { |ext| class_name + '.' + ext }.sort.last\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  # Your code here\nend",
  '    extension_strengths = []', "  return nil if extensions.nil?\n  extensions.map\
    \ { |e| e.downcase }.sort.last.capitalize +\n    extensions[extensions.index(extensions.sort.last)]\n\
    end", "  # TODO: Write your code here\n  strength = -1 \n  best_extension = \"\
    \"\n  class_found = 0\n  for extension in extensions\n    if class_found.to_s\
    \ == \"True\" \n      best_extension = extension\n      break\n    else\n    \
    \  if class_found.to_s == 'False'\n        if class_name.to_s.upcase == extension.to_s.upcase\
    \ \n          strength += 1\n        else\n          strength -= 1\n        end\n\
    \      end\n    end\n  end\n  return best_extension\nend\n</cell>\n<code language=conda-env-Anaconda3-py>",
  "    array = extensions.split # Splitting the extension list into an array\n   \
    \ array.each do |e|\n        name = e.split # Splitting the extension name into\
    \ an array\n        size = name.count{ |x| x.upcase == x } # Counting the number\
    \ of uppercase letters\n        size.to_f / name.size # Calculating the strength\n\
    \    end.max_by { |x| x } # Finding the strongest extension\nend\n</code>\n<|/\
    \ a |>\n<| a dscore=0 |>\nHere's how I solved it (Python), using sorted, list\
    \ comprehension and sorted functions:\n<code>", "    \n    # Write your code here.\n\
    \    strength=0\n    for extension in extensions:\n        cap=extension[0].upper()\n\
    \        sm=extension[0].lower()\n        strength+=(cap-sm)\n    return class_name\
    \ + \".\" + extensions[strength].lower()\n</cell>\n<cell>", "  return [extension[0]\
    \ for extension in extensions.sort_by {|e| -e[1].to_s.downcase.count - e[1].to_s.downcase.scan(/[a-z]/).count}].\n\
    \      sort_by {|e| -e[1].to_s.downcase.count - e[1].to_s.downcase.scan(/[a-z]/).count}.\n\
    \      first[1].to_s.downcase.scan(/[a-z]/).count\nend", "  extension_strengths\
    \ = {}\n  extensions.each do |ext|\n    cap = ext.split(\".\").collect(&:upcase).inject(0)\
    \ do |sum,letter|\n      sum + letter.to_i.abs\n    end\n    sm = ext.split(\"\
    .\").collect(&:downcase).inject(0) do |sum,letter|\n      sum + letter.to_i.abs\n\
    \    end\n    extension_strengths[ext] = cap - sm \n  end\n  \n  max = extension_strengths.values.max\n\
    \  if extension_strengths[class_name]\n    return class_name.to_s + \".\" + max.to_s.upcase\
    \ \n  elsif extension_strengths[class_name]\n    return class_name.to_s + \".\"\
    \ + max.to_s.downcase \n  else\n    return nil\n  end\nend", "  best_strength\
    \ = -1\n  best_name = ''\n  extension_parts = class_name.to_s.split('').map{|i|\
    \ i.upcase}\n  extensions.each do |extension|\n    strength = extension_parts.size\
    \ - extension.to_s.split('').size\n    if best_strength == -1 || strength > best_strength\n\
    \      best_strength = strength\n      best_name = extension\n    end\n  end\n\
    \  return class_name.to_s + '.' + best_name.to_s\nend", "  class_name = class_name.dup\n\
    \  extensions.sort!\n  extensions.length.times do |i|\n    extension = extensions[i]\n\
    \    extension = extension.dup\n    extension.gsub!(/[0-9]/, '')\n    if class_name\
    \ =~ /^#{extension}/\n      return class_name\n    end\n    class_name = class_name\
    \ + \"_#{extension}\"\n  end\n  class_name\nend", "  extension_strengths = []\n\
    \  # TODO: Write a function that returns the strongest extension of a class.\n\
    \  raise \"not implemented\"\nend", "\tresult = ''\n\tnumber_of_uppercase = 0\n\
    \tnumber_of_lowercase = 0\n\tnumber_of_chars = 0\n\t\n\tfor extension in extensions\n\
    \t\tchars_in_extension = 0\n\t\t\n\t\tnumber_of_chars += extension.length\n\t\t\
    number_of_uppercase += extension.count(\"A\")\n\t\tnumber_of_lowercase += extension.count(\"\
    a\")\n\t\tnumber_of_chars += extension.count(\"0\")\n\t\tnumber_of_chars += extension.count(\"\
    Z\")\n\t\tnumber_of_chars += extension.count(\"z\")\n\t\t\n\t\tchars_in_extension\
    \ = extension.length\n\t\t\n\t\tif number_of_chars > number_of_uppercase or number_of_chars\
    \ > number_of_lowercase\n\t\t    result = extension\n\t\tend\n\tend\n\t\n\treturn\
    \ result\nend", "\t\n\t#\n\t# BEGIN YOUR CODE HERE\n\t\n\t# END YOUR CODE\nend",
  "  extension_names = extensions.map{|e| e.to_s}\n  extension_names.sort!\n  extension_names.last(2).each\
    \ do |e_name|\n    unless extension_names.include?(e_name)\n      extension_names.delete(e_name)\n\
    \    end\n  end\n  extension_names.reverse.each do |e_name|\n    class_name +=\
    \ \".\" + e_name\n  end\n  return class_name\nend\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for the help! I will try to implement this and let you know if I have\
    \ any problems.\n<|/ c |>\n<| c |>\nThis is pretty much exactly what I ended up\
    \ doing, but using your example. Thanks again.\n<|/ c |>\n<| c |>\nNo problem.\
    \ Glad I could be of any help.\n<|/ c |>\n<| a dscore=0 |>\nOk, so I ended up\
    \ doing this and it's working great now. Thanks to everyone who helped me out.\n\
    <code>", "  # TODO: Write your code here\nend", "  strongest_extension = nil\n\
    \  \n  extensions.each do |extension|\n    if extension.include?(class_name.upcase)\n\
    \      strongest_extension = extension\n    end\n  end\n  \n  return strongest_extension\n\
    end", "    \n    #return \"Strongest\"\n    \n    \n    return extensions[0]\n\
    \    \n    ", "  extension_strength = extension_strength_calculator(extensions)\n\
    \  strongest_extension = extension_strength_sorting_algorithm(extension_strength)\n\
    \  return class_name + strongest_extension\nend", "  case extensions.length\n\
    \  when 0\n    raise 'List cannot be empty'\n  when 1\n    return class_name +\
    \ extensions[0]\n  else\n    smallest = extensions[0]\n    \n    extensions.each\
    \ do |extension|\n      case extension.length\n      when 0\n        raise 'Extension\
    \ cannot be empty'\n      when 1\n        if extension[0].upcase == extension[1].upcase\n\
    \          smallest = extension\n        end\n      else\n        if extension[0].upcase\
    \ == extension[1].upcase &&\n           extension[0].downcase == extension[1].downcase\n\
    \          smallest = extension\n        end\n      end\n    end\n    \n    \"\
    #{class_name}.#{smallest}\"\n  end\nend\n</code>\nThis solution is much more simple\
    \ and cleaner than your version.\nI tested it on repl.it\n<|/ a tags=ruby,string,algorithm\
    \ |>\n<| c |>\nI didn't test the code on repl.it, but this looks good enough to\
    \ me.\n<|/ c |>\n<| c |>\n, Thanks for your answer but when I tried this on repl.it\
    \ it gave me the wrong answer. for example, `Strongest_Extension('ABCD', ['A','B'])\
    \ => 'ABC'`\n<|/ c |>\n<| c |>\nI used the example you gave in your comment: `Strongest_Extension('ABCD',\
    \ ['A','B']) => 'ABC'`, so I guess that is not what you want\n<|/ c |>\n<| c |>\n\
    , your answer did work. Thanks.\n<|/ c |>\n<| a dscore=1 |>\nTry this:\n<code>",
  "  new_extensions = extensions.sort_by { |e| -e.rpartition('').count }\n  new_extensions.first\n\
    end\n</code>\n<|/ a |>\n<| a tags=algorithm,ruby,string |>\nI came up with this\
    \ in Ruby, should work, maybe it will help someone.\n<code>", " \n  strength =\
    \ extensions.length\n  extension = nil\n  \n  extensions.each do |e|\n    strength\
    \ -= e.downcase.count(e) * e.downcase.count(e.upcase)\n    if strength == 0\n\
    \      extension = e\n      break\n    end\n  end\n  return \"#{class_name}.#{extension}\"\
    \nend", "  strongest = extensions[0..extensions.length-1]\n  extensions.each do\
    \ |extension|\n    if extension.include?(class_name[0].downcase)\n      strongest\
    \ = extension if extension.include?(class_name[0].downcase)\n    end\n  end\n\
    \  strongest\nend", "  extension_strength = {}\n  class_strength = extension_strength.fetch(class_name.downcase,\
    \ 0)\n  extensions.each { |extension|\n    extension_strength[extension.downcase]\
    \ = extension_strength.fetch(extension.downcase, 0) + 1.downcase == extension.downcase\n\
    \  }\n  extension_strength.each { |ext, strength| \n    if strength > class_strength\n\
    \      return ext \n    end\n  }\nend", "\textension_map = {}\n\textension_strength\
    \ = []\n\t\n\tfor ext in extensions do\n\t\text_cap = ext_cap = string.upcase(ext)\n\
    \t\text_sm = ext_sm = string.lower(ext)\n\t\t\n\t\tstrength = ext_cap - ext_sm\n\
    \t\t\n\t\textension_map[ext] = strength\n\t\textension_strength.push(strength)\n\
    \t\n\textension_strength.sort!\n\t\n\tif extension_strength[0] == extension_strength[1]\n\
    \tthen\n\t\treturn extension_map[extension_strength[0]]\n\telse\n\t\textension_map.each\
    \ { |key, value| \n\t\t\tif value == extension_strength[0]\n\t\t\tthen\n\t\t\t\
    \treturn key\n\t\t\tend\n\t\t}\n\tend\nend", "\textension =[i for i in extensions\
    \ if i <> class_name]\n\treturn class_name + extensions[0][extensions[0].index(extensions[0])\
    \ - extension.index(extensions[0])]\nend\n</pre>", "  extensions.sort.each_with_index\
    \ do |e, i|\n    if e.downcase.size == e.upcase.size && e.upcase.size > 0\n  \
    \    strength = e.downcase.length - e.upcase.length\n    else\n      strength\
    \ = -1\n    end\n    if strength > 0\n      if i == 0\n        return class_name.to_s\
    \ + e.to_s\n      else\n        if class_name.downcase == e.downcase\n       \
    \   return class_name.to_s + e.to_s\n        else\n          return class_name.to_s\
    \ + e.to_s.capitalize\n        end\n      end\n    end\n  end\nend", "  strongest_extension\
    \ = nil\n  extensions.each do |extension|\n    extension_class = nil\n    class_name.split('').each\
    \ do |char|\n      if class_name.index(char) == 0 \n        extension_class =\
    \ extension\n      end\n    end\n    if extension_class != nil\n      if strongest_extension\
    \ == nil \n        strongest_extension = extension\n      else\n        if strongest_extension.strength\
    \ < extension.strength \n          strongest_extension = extension\n        end\n\
    \      end\n    end\n  end\n  return strongest_extension\nend", "    # Your code\
    \ here\n    \n    return \"\"\nend\n</cell>\n<text>\nThe next function should\
    \ return a list of strings representing the extensions that\nare not already included\
    \ in the provided extensions list.\nThe function should return the empty list\
    \ if all extensions are already included\nin the provided extensions list.\nYou\
    \ will probably need to use Arrays to do this.\nThe function should return a list\
    \ of string objects.", "  extension_strengths = {}\n  extensions.each do |extension|\n\
    \    extension_strengths[extension.to_s] = extension.count(\"A\") - extension.count(\"\
    a\")\n  end\n  extension_strengths.max_by {|k, v| -v}\nend", "  \n  # Your code\
    \ here\n  \nend\n</code></pre>\n</div>", "  extension_strengths = Hash.new(0)\n\
    \  extensions.each do |ext|\n    extension_strengths[ext] += class_name.count(ext.upcase)\
    \ - class_name.count(ext.downcase)\n  end\n  extension_strengths.sort.last ||\
    \ 'NoSuchClass'\nend\n</code>\n(Note: This code is a bit rough and ready, but\
    \ you'll get the idea.)\n<|/ a |>\n<| c |>\nIt doesn't seem to be working on the\
    \ example I provided. Maybe I did not understand your example? I changed the name\
    \ of the extension to \"Slices.SErviNGSliCes\". Does it matter if the extension\
    \ is \"Slices.Cess\"?\n<|/ c |>\n<| c |>\nNo, it doesn't matter what the extension\
    \ is. You have to make sure that you give it a complete class name including the\
    \ package. If you are using another package (which you probably should), you just\
    \ have to replace \"Slices\" with the package name in your extension names.\n\
    <|/ c |>\n<| c |>\nSorry for the delay in responding. I've changed my code a little\
    \ bit so that it can handle other packages, such as 'RubySlices'. It seems to\
    \ work now, but I'm not sure. I don't know what the 'S' in 'Slices' means.\n<|/\
    \ c |>\n<| a dscore=1 tags=ruby |>\nHere's how I did it.\n<code>", "  extensions\
    \ = extensions.sort\n  index = 0\n  max_score = 0\n  strongest_extension = ''\n\
    \  while index < extensions.count\n    extension = extensions[index]\n    extension_index\
    \ = extension.index(extension.downcase)\n    extension_score = extension.length\
    \ - extension_index\n    if extension_score > max_score\n      max_score = extension_score\n\
    \      strongest_extension = extension\n    index += 1\n  class_name_with_strongest\
    \ = class_name + strongest_extension\n  return class_name_with_strongest\nend",
  "  highest_strength = nil\n  highest_strength_extension = nil", "  \n  extension_strengths\
    \ = []", "  best_extension = 0\n  best_extension_strength = 0\n  extensions.each\
    \ do |extension|\n    strength = extension.count(class_name[0].upcase) - extension.count(class_name[0].downcase)\n\
    \    if strength > best_extension_strength\n      best_extension_strength = strength\n\
    \      best_extension = extension\n    end\n  end\n  return class_name + best_extension\n\
    end", "    extensions_counter = Hash.new(0)\n    \n    # Your code goes here!\n\
    \    \n    return nil\nend\n</cell>\n<code language=conda-root-py>", "  result\
    \ = ''\n  sorted_extensions = extension_sort(extensions)\n  extensions.each_index\
    \ { |i| result << \"#{class_name}.#{sorted_extensions[i]}\" }\n  return result\n\
    end", "  # Your code here\n  max_strength = -1\n  max_extension = \"\"\n  extensions_map\
    \ = Hash.new(0)\n  extensions.each do |extension|\n    extensions_map[extension]\
    \ += 1\n  end\n  extensions_map.each do |extension, count|\n    if count == max_strength\n\
    \      max_extension = extension\n    end\n  end\n  class_name.constantize.const_get(max_extension)\n\
    end", "    extensions_count = extension_count = Hash.new(0)\n    extensions_count.update\
    \ extensions.collect{|e| e.downcase.chars.inject(0){|acc, x| acc + x.to_i } ;\
    \ [e.downcase, extensions_count[e.downcase] ]}\n    extensions_count.max_by{|key,\
    \ value| value }.last.first\nend\n</cell>\n<cell>\nputs Strongest_Extension('Slices',\
    \ ['SErviNGSliCes', 'Cheese', 'StuFfed'])\n</cell>\n<text>\nSolution:\nTime Complexity\
    \ \nThe time complexity of the algorithm is $\\mathcal{O}(n)$, where $n$ is the\
    \ number of characters in class_name, and the number of extensions in the list.",
  "  highest_strength = -1\n  strongest_ext = []\n  extension_strength = extension_class_strength(class_name,\
    \ extensions)\n  \n  if highest_strength == -1\n    puts class_name\n    puts\
    \ extension_strength\n  end\n  \n  highest_strength.each do |ext, strongest|\n\
    \    if strongest > extension_strength\n      strongest_ext = ext\n      extension_strength\
    \ = strongest\n    end\n  end\n  \n  if highest_strength == -1\n    puts \"No\
    \ strongest extension\"\n  else\n    puts class_name\n    puts strongest_ext\n\
    \  end\nend", "    extentions_sorted = extensions.sort { |a, b| b.length - a.length\
    \ }\n    strength = extentions_sorted.first[0].length.to_f\n    return class_name\
    \ + extentions_sorted.last[0] + \".\" * ( strength - extentions_sorted.last[0].length.to_f\
    \ )\nend\n</code>\nMy solution would be the following:\n<code>", "  strongest_extension\
    \ = None\n  \n  # Your code goes here \n  strongest_extension = nil\n  return\
    \ strongest_extension\nend\n</cell>\n<code language=julia-1.0>\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"SErviNGSliCes\"]) == \"Slices.SErviNGSliCes\" );\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"Cheese\", \"StuFfed\"]) == \"Slices.Cheese\" );\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"StuFfed\"]) == \"Slices.StuFfed\" );\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"Eggs\", \"Cheese\"]) == \"Slices.Eggs\" );\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"Eggs\", \"StuFfed\"]) == \"Slices.StuFfed\" );\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"Eggs\"]) == \"Slices.Eggs\" );\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"Cheese\", \"StuFfed\", \"Eggs\"]) == \"Slices.StuFfed\" );\n@assert\
    \ solution(Strongest_Extension(\"Slices\", [\"Cheese\", \"StuFfed\", \"Eggs\"\
    ]) == \"Slices.Eggs\" );\n@assert solution(Strongest_Extension(\"Slices\", [\"\
    SErviNGSliCes\", \"Cheese\", \"StuFfed\"]) == \"Slices.StuFfed\" );\n@assert solution(Strongest_Extension(\"\
    Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\", \"Eggs\"]) == \"Slices.Eggs\"\
    \ );\n@assert solution(Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"\
    Cheese\", \"StuFfed\", \"Eggs\"]) == \"Slices.StuFfed\" );\n</cell>\n<text>\n\
    4.3. Hamming Distance\nA very important property of strings is that they can be\
    \ transformed into another string. For example, we can transform \"abcd\" into\
    \ \"eabce\" using the Hamming Distance: $Distance('eabce', 'abcd')$.", "    str_ext\
    \ = ''\n    str_ext_list = {}\n    \n    sorted_list = extensions.sort{|a, b|\
    \ b.to_s.downcase <=> a.to_s.downcase }\n    \n    sorted_list.each do |ext|\n\
    \        str_ext_list[ext] = sorted_list.index(ext)\n    end\n    \n    sorted_list.each\
    \ do |ext|\n        cap = ext.downcase.count('a')\n        sm = ext.downcase.count('b')\n\
    \        \n        if str_ext_list[ext] == sorted_list.index(ext)\n          \
    \  str_ext += '.' + ext \n        elsif (cap - sm) == str_ext_list[ext]\n    \
    \        str_ext += '.' + ext\n        end\n    end\n    \n    str_ext[1..-1]\n\
    end", "    \n    \n    # Write your solution here.\n    \nend", "\t\nend", " \
    \ best_extension = {}\n  best_extension_strength = -1\n  best_extension_name =\
    \ \"\"\n  best_extension_class_name = \"\"\n  best_extension_extension = \"\"\n\
    \  best_extension_weight = 0\n  \n  extensions_array = extensions.map{|e| e.capitalize.upcase}.sort.uniq.map{|e|\
    \ e.length}\n  extensions_array.each do |e|\n    e.each_with_index do |char, i|\n\
    \      char_class = class_name[0,char]\n      weight = i if char_class == class_name\n\
    \      \n      if best_extension_strength > 0\n        best_extension_strength\
    \ = best_extension_strength if best_extension_strength > weight || best_extension_strength\
    \ == 0\n      elsif best_extension_strength < 0\n        best_extension_strength\
    \ = weight if best_extension_strength < weight || best_extension_strength == 0\n\
    \      elsif best_extension_strength == 0\n        best_extension_strength = weight\n\
    \      end\n      \n      if best_extension_name && best_extension_class_name\
    \ && best_extension_extension && best_extension_strength\n        best_extension_weight\
    \ = best_extension_strength if best_extension_strength > best_extension_weight\n\
    \        best_extension_name = best_extension_name if best_extension_strength\
    \ > best_extension_name.length\n        best_extension_class_name = best_extension_class_name\
    \ if best_extension_strength > best_extension_class_name.length\n        best_extension_extension\
    \ = best_extension_extension if best_extension_strength > best_extension_extension.length\n\
    \        best_extension_weight = best_extension_weight if best_extension_strength\
    \ > best_extension_weight\n      end\n    end\n  end\n  \n  if best_extension_name\
    \ && best_extension_class_name && best_extension_extension && best_extension_strength\n\
    \    return best_extension_class_name + best_extension_name + best_extension_extension\
    \ + best_extension_strength.to_s\n  end\n  \n  return \"\"\nend", "  extension_array\
    \ = extensions.to_a\n  extension_array.sort!\n  \n  strongest_extension = nil\n\
    \  extension_array.each do |extension|\n    if extension.start_with?(class_name)\n\
    \      strongest_extension = extension\n      break\n    end\n  end\n  \n  unless\
    \ strongest_extension.nil?\n    class_name_idx = class_name.index(strongest_extension)\n\
    \    class_name = class_name[0...class_name_idx]\n    strongest_extension = strongest_extension[class_name_idx\
    \ + class_name.length..-1]\n  end\n  \n  return strongest_extension\nend", " \
    \   extensions_sorted = extensions.sort\n    if extensions_sorted == nil\n   \
    \     return \"No extension\"\n    else\n        sorted_extensions = extensions_sorted.sort\n\
    \        if sorted_extensions.size == 1\n            return \"#{class_name.to_s.capitalize}#{sorted_extensions[0].capitalize}\"\
    \n        elsif sorted_extensions.size == 2\n            a, b = sorted_extensions\n\
    \            if a == \"ABC\"\n                return \"#{class_name.to_s.capitalize}#{b.capitalize}\"\
    \n            elsif b == \"ABC\"\n                return \"#{class_name.to_s.capitalize}#{a.capitalize}\"\
    \n            end\n        elsif sorted_extensions.size > 2\n            a, b\
    \ = sorted_extensions\n            c, d = sorted_extensions.sort\n           \
    \ if a == \"ABC\"\n                if b == \"ABC\"\n                    return\
    \ \"#{class_name.to_s.capitalize}#{c.capitalize}#{d.capitalize}\"\n          \
    \      elsif b != \"DEF\"\n                    return \"#{class_name.to_s.capitalize}#{d.capitalize}#{c.capitalize}\"\
    \n                end\n            elsif b == \"ABC\"\n                if a !=\
    \ \"DEF\"\n                    return \"#{class_name.to_s.capitalize}#{d.capitalize}#{c.capitalize}\"\
    \n                end\n            end\n        end\n    end\nend\n</cell>\n<cell>",
  "  best_extension = nil\n  best_strength = -1", "  return StrongestExtension(class_name,\
    \ extensions)\nend\n</cell>\n<code language=julia-1.0>", "  return nil\nend",
  "  extensions_sorted = extensions.sort_by { |e| e.length }.reverse\n  extensions_sorted.each\
    \ do |e|\n    return class_name + e[0] if e.length > 0\n  end\n  raise \"No extensions\
    \ found\"\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer. How do you\
    \ get from the input `Slices` to `Slices.SErviNGSliCes` ? `Slices` seems to be\
    \ hardcoded.\n<|/ c |>\n<| c |>\nI added an explanation to my answer to make you\
    \ understand how it works. Hope it's clear enough.\n<|/ c |>\n<| c |>\nThanks\
    \ for the edit. I think it does the job. However I do not understand what is the\
    \ last `return \"No extensions found\"` for. I tried removing it, but I got the\
    \ same result.\n<|/ c |>\n<| c |>\nIt's there to return an error if the array\
    \ is empty.\n<|/ c |>\n<| a dscore=1 |>\nI hope this helps someone. I used the\
    \ excellent answers to come up with a recursive solution.\n<code>", "  str.split\n\
    \  str.capitalize\n  str.count\n  (str.count.to_f) / extensions.length.to_f\n\
    \  max_extension = extensions.max.inject(0){ |max_count, ext|\n    (ext.capitalize.split.count.to_f)\
    \ / max_count.to_f\n  }\n  extensions[extensions.index(max_extension)].to_s.sub('?',\
    \ '.') + \"?\" + class_name.split('::').last\nend", "  extension_strengths = []\n\
    \  \n  # TODO: Write a function that counts how many times a given extension occurs\n\
    \  # in the list of extensions. Each extension should be treated as an atomic\
    \ \n  # object in your program.", "\tstrongest_extension = \"\"\n\tsorted_extensions\
    \ = extensions.sort_by { |extension| extension.strongest_extension }.reverse\n\
    \tsorted_extensions.each do |extension|\n\t\tstrongest_extension = extension.name\
    \ + \".\" + strongest_extension if extension.strongest_extension < strongest_extension.length\n\
    \tend\n\treturn strongest_extension.chop if strongest_extension.empty?\n\tstrongest_extension.sub!(/^.+\\\
    ./, '')\n\treturn strongest_extension\nend", "  extensions_sorted = extension_sort(extensions)\n\
    \  strongest_extension = nil\n  extensions.each do |e|\n    score = count_capital_letters(e)\
    \ - count_capital_letters(class_name)\n    if score > strongest_extension\n  \
    \    strongest_extension = e\n    end\n  end\n  return strongest_extension\nend",
  "  \n  # Return a string that has the following format:\n  # ClassNameStrongestExtensionName\n\
    \  \n  # The input parameters are:\n  # class_name: The class name of the object\
    \ whose extension is to be determined.\n  # extensions: The list of extensions\
    \ to that class of the object whose extension is to be determined.\n  \n  # Example:\
    \ If the class_name is 'Slices' and \n  # the extensions are ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then\n  # the output should be 'Slices.SErviNGSliCes'\n\
    \  \n  # Note: \n  # class_name can only have characters 'A' to 'Z' and '_'.\n\
    \  # extensions has only strings.", "  class_name.to_s.tr(class_name.to_s.rindex('C'),\
    \ '').\n      tr(class_name.to_s.rindex('C'), '') - extensions.count * 'C'.\n\
    \      tr(class_name.to_s.rindex('C'), '')\nend\n</code>\nYou can then do some\
    \ basic error handling:\n<code>\nbegin\n  puts \"The strongest extension is #{Strongest_Extension(\n\
    \    :Slices, ['SErviNGSliCes', 'Cheese', 'StuFfed']\n  )}\".inspect\nrescue =>\
    \ e\n  puts \"#{e.message}\"\nend\n</code>\nIf you run the above code then you\
    \ should see:\n<code>\nThe strongest extension is Slices.SErviNGSliCes\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nthanks for your answer. I'm just confused how to implement\
    \ the code. would you mind help me to figure it out? Thanks.\n<|/ c |>\n<| c |>\n\
    I have added some example code which demonstrates one way of implementing the\
    \ above method. Try it out and let me know if you have any further questions.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<code>", "  extensions.sort.reverse!\n\
    \  strength = extensions[0].length\n  extensions.each do |extension|\n    if extension.length\
    \ != strength\n      strength = extension.length\n    end\n  end\n  \"#{class_name}.#{extensions.join('.')}.#{strength}\"\
    \nend", "  # Your code here\nend\n</cell>\n<cell>", "  # Your code here.\nend\n\
    </pre>", "    return ''\nend", "    sorted_extensions = extensions.sort\n    (strongest_extension,\
    \ i) = sorted_extensions.find{ |e| e.include?(class_name) }\n    return strongest_extension\n\
    end", "  extension_strengths = {}\n  extensions.each do |e|\n    i = e.index(class_name[0])\n\
    \    extension_strengths[e] = i\n  end\n  \n  sorted_keys = extension_strengths.keys\n\
    \  sorted_keys.sort! { |a, b| extension_strengths[a] < extension_strengths[b]\
    \ ? -1 : (extension_strengths[a] > extension_strengths[b] ? 1 : 0) }\n  \n  if\
    \ sorted_keys.size == 1\n    return sorted_keys.first\n  else\n    return sorted_keys.sort.join('.')\
    \ + \"#\" + class_name.join\n  end\nend", "  extensions_count = extensions.count{|e|\
    \ e.size }\n  extensions_count = extensions_count.to_f if extensions_count >=\
    \ 1\n  extensions_count.ceil", "\textension ||= []\n\tstrongest = -1\n\textension.each\
    \ do |ext|\n\t\tif ext.downcase == class_name.downcase.chars.map { |c| c.upcase\
    \ }.join\n\t\tthen strongest = ext\n\t\tbreak\n\t\tend\n\tend\n\treturn class_name+\"\
    .\"+strongest\nend\nputs Strongest_Extension(\"Slices\", [\"SErviNGSliCes\",\"\
    Cheese\",\"StuFfed\"]).inspect ", "\textensions_sorted = extensions.sort { |x,\
    \ y| x.to_s.upcase <=> y.to_s.upcase }\n\textensions.sort.reverse.last\nend",
  "    str_extension = nil\n    sorted_extensions = extensions.sort\n    \n    sorted_extensions.each\
    \ do |extension|\n        str_extension = extension.gsub(/\\W/, '').downcase\n\
    \        break if str_extension == class_name.downcase\n    end\n    \n    str_extension\
    \ = str_extension.split('').zip(sorted_extensions).find { |e| e[0] <=> e[1]}.last\n\
    \    \n    \"#{class_name}##{str_extension}\"\nend\n</cell>\n<cell>", "    extensions\
    \ = extensions.sort # Sort the list first before finding the strongest extension.\n\
    \    strongest = extensions[0] # Initialize the strongest extension.\n    \n \
    \   # If the list contains only one extension just return the name of the\n  \
    \  # extension without its extension name.\n    unless extensions.count > 1\n\
    \      extension = extensions[0]\n      return extension\n    end\n    \n    #\
    \ Iterate through all the extensions, find the strongest one by \n    # comparing\
    \ their strengths and return it.\n    extensions.each do |extension|\n      strongest\
    \ = extension if extension.strength > strongest.strength\n    end\n    \n    #\
    \ Return the final extension's name without its extension name.\n    strongest.extension\n\
    \  end", "    # Write your code here.\n    array = extensions[1..-1].map {|x|\
    \ x.downcase}\n    strength = array.count(array.min) / array.count\n    extension\
    \ = array.min == array.max ? nil : array.min\n    extension = extension.slice(0,1).concat(\"\
    _\").concat(extension.slice(1))\n    return \"#{class_name}#{extension}#{strongest_extension_suffix(class_name,\
    \ extension, strength)}\"\nend", "\textension_strengths = []\n\tclass_name_parts\
    \ = class_name.split(':')\n\tfor i in range(len(extensions)):\n\t\textension_parts\
    \ = extensions[i].split('-')\n\t\textension_strengths.append(len(extension_parts))\n\
    \t\t\n\textension_strengths = extensions.map(&:length).uniq.sort\n\tstrongest_extension\
    \ = nil\n\textension_strengths.each do |strength|\n\t\textension_parts.each {\
    \ |extension| \n\t\t\tif strength == extension.length\n\t\t\t\tstrongest_extension\
    \ = \"#{class_name_parts[-1]}.#{extension}\"\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\
    \tend\n\treturn strongest_extension\nend", "  return nil unless extensions.is_a?\
    \ Array\n  extensions.sort.find { |e| e.include? class_name.upcase }\nend", " \
    \ # Write your code here.\n  max_strength = float(\"-inf\")\n  strongest_extension\
    \ = \"\"\n  extensions.each do |extension|\n    extension = extension.to_s.downcase\n\
    \    strength = class_name.length.to_f / extension.length.to_f\n    strength =\
    \ strength.to_i\n    if strength > max_strength\n      max_strength = strength\n\
    \      strongest_extension = extension\n    end\n  end\n  return strongest_extension\n\
    end", "  extensions.sort!\n  strongest_extension = extensions[-2]\n  extensions.shift\n\
    \  extensions.each do |extension|\n    extension_strength = extension.downcase.count(\"\
    a\"..\"z\").to_f - extension.downcase.count(\"A\"..\"Z\").to_f\n    strongest_extension\
    \ = extension if extension_strength > strongest_extension.downcase.count(\"a\"\
    ..\"z\").to_f - strongest_extension.downcase.count(\"A\"..\"Z\").to_f\n  end\n\
    \  return class_name + strongest_extension\nend", "  strongest = -1\n  extension\
    \ = nil\n  extensions.each do |extension|\n    strength = extension.split(//).count\
    \ { |char| char.isupper}\n    if strength > strongest\n      strongest = strength\n\
    \      extension = extension\n    end\n  end\n  return class_name + '.' + extension\n\
    end", "    extensions_with_strength = extensions.sort_by{|extension| extension.capitalize.to_i}.uniq\n\
    \    if extensions_with_strength.length == 0\n        raise ArgumentError.new(\"\
    You must provide at least one extension to the class '#{class_name}'.\")\n   \
    \ end\n    extensions_with_strength.each do |extension|\n        strength = extension.capitalization.to_i\
    \ - extension.capitalization.to_i.downcase\n        next unless strength >= 0\n\
    \        return class_name.to_s + \".#{extension}\"\n    end\n    raise ArgumentError.new(\"\
    The class '#{class_name}' does not have an extension that is strongest.\")\nend",
  "  extension_count = extensions.length\n  best_extension = -1\n  best_count = 0\n\
    \  best_extension = ''\n  best_extension_count = ''\n  strongest_count = 0\n \
    \ strongest_extension = ''\n  strongest_extension_count = ''\n  strongest_strength\
    \ = -1\n  strongest_extension_strength = ''\n  strongest_strength_extension =\
    \ ''\n  strongest_strength_extension_count = ''\n  strongest_extension_strength\
    \ = ''\n  strongest_extension_strength_count = ''\n  extension_strength = 0",
  "    return nil\nend", "\textension_count = extensions.size\n\textension_strengths\
    \ = []\n\t\n\textension_strengths << 0 unless extension_count > 0\n\textension_strengths\
    \ << 1 unless extension_count == 1\n\textension_strengths << 2 unless extension_count\
    \ == 2\n\textension_strengths << 3 unless extension_count == 3\n\textension_strengths\
    \ << 4 unless extension_count == 4\n\textension_strengths << 5 unless extension_count\
    \ == 5\n\t\n\textension_strengths.each_with_index do |strength, index|\n\t\textension_name\
    \ = extensions[index]\n\t\t\n\t\tcapitalized_extension_name = extension_name\n\
    \t\tcapitalized_extension_name = capitalized_extension_name.capitalize\n\t\t\n\
    \t\textension_count = class_name.size\n\t\tclass_name = class_name.downcase\n\t\
    \tclass_name = class_name.gsub(/[^A-Z]/, \"\") # Removes non-upper case letters\n\
    \t\tclass_name = class_name.gsub(/[^a-z]/, \"_\") # Replaces non-lower case letters\
    \ with _\n\t\t\n\t\tcapitalized_class_name = class_name\n\t\tcapitalized_class_name\
    \ = capitalized_class_name.capitalize\n\t\t\n\t\tclass_name_components = class_name.split(\"\
    _\") # Split into array\n\t\t\n\t\textension_name_components = extension_name.split(\"\
    _\") # Split into array\n\t\t\n\t\tclass_name_components.each_with_index do |component_name,\
    \ component_index|\n\t\t\textension_name_components.each_with_index do |extension_name,\
    \ extension_index|\n\t\t\t\tif component_name == extension_name_components[extension_index]\
    \ and class_name_components[component_index] == extension_name_components[extension_index]\
    \ or component_name == extension_name_components[extension_index] and class_name_components[component_index].length\
    \ < extension_name_components[extension_index] or component_name == extension_name_components[extension_index].capitalize\
    \ && class_name_components[component_index].capitalize == extension_name_components[extension_index].capitalize\n\
    \t\t\t\t\tcomponent_name_components = component_name.split(\"_\") # Split into\
    \ array\n\t\t\t\t\textension_name_components = extension_name.split(\"_\") # Split\
    \ into array\n\t\t\t\t\t\n\t\t\t\t\tif component_name_components.include? extension_name_components[extension_index]\
    \ and class_name_components[component_index] == extension_name_components[extension_index]\
    \ or component_name_components.include? extension_name_components[extension_index]\
    \ and class_name_components[component_index].length < extension_name_components[extension_index]\
    \ or component_name_components.include? extension_name_components[extension_index].capitalize\
    \ && class_name_components[component_index].capitalize == extension_name_components[extension_index].capitalize\n\
    \t\t\t\t\t\textension_strengths[index] = strength\n\t\t\t\t\tend\n\t\t\t\tend\n\
    \t\t\tend\n\t\tend\n\t", "    \n    extensions_length = extensions.length\n  \
    \  \n    extensions_with_strength = []\n    \n    extensions_with_strength = Array.new(extensions_length)\n\
    \    \n    extensions_with_strength.each do |extension|\n        \n        extension_with_strength\
    \ = class_name.gsub(/./){|letter|\n            letter = letter.upcase\n      \
    \      extension.indexof(letter)\n        }\n        \n        if extension_with_strength\
    \ != -1\n            extensions_with_strength[extensions_with_strength.index(extension)]\
    \ = extension_with_strength\n        end\n    end\n    \n    extensions_with_strength.sort!\n\
    \    \n    if extensions_with_strength.length == 1\n        return extensions_with_strength[0]\n\
    \    end\n    \n    extension_with_strength = extensions_with_strength[0]\n  \
    \  \n    extensions_with_strength.each do |extension|\n        if extension_with_strength\
    \ > extension\n            extension_with_strength = extension\n        end\n\
    \    end\n    \n    extension_with_strength\nend\n</pre>\n<p>\_</p>\n<p>\_</p>\n\
    <h1 id=\"question-4\">Question 4</h1>\n<p>\_</p>\n<p>Create a program that finds\
    \ the longest word in a given line of input (given as a string).\n\_\nThe line\
    \ consists of several words separated by spaces. Return the longest word in the\
    \ line.\n\_\nIf there is no word in the line return nil.\n\_\nIf there is a word\
    \ in the line but the longest word is longer than the one being tested, return\
    \ that word.\n\_\nFor each word in the line return its index in the line.</p>\n\
    <p>\_</p>\n<p>\_</p>\n<pre class=\"ruby\"><code>def longest_word(line)\n    \n\
    \    longest_word_length = nil\n    \n    words = line.split\n    \n    words.each\
    \ do |word|\n        \n        if !longest_word_length || longest_word_length\
    \ > word.length\n            longest_word_length = word.length\n        end\n\
    \    end\n    \n    longest_word\nend", "  strongest = nil\n  extensions.each\
    \ do |extension|\n    score = extension.count(class_name) - extension.count(extension.upcase)\n\
    \    next if score == 0\n    next if score == 1\n    next if score > 1\n    strongest\
    \ = extension if score > strongest.count \n  end\n  return strongest\nend\n</code>\n\
    This should work fine.\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nHi Andrey, can you\
    \ please explain the method Strongest_Extension in detail. I'm a noob in Ruby.\n\
    <|/ c |>\n<| c |>\nWhat is \"extension.count(extension.upcase)\". How does this\
    \ work?\n<|/ c |>\n<| c |>\nThat part just counts how many uppercase letters there\
    \ are in the extension and compares it to the number of lowercase letters in the\
    \ extension. For example, if the extension is \"SErviNGSliCes\", then the uppercase\
    \ letters are \"S\" and lowercase letters are \"ErviNGSliCes\", so \"ErviNGSliCes\"\
    .count will return \"3\" and (extension.upcase).count will return \"9\".\n<|/\
    \ c |>\n<| a dscore=1 |>\nRuby 2.5 Solution\n<code>", "    extensions_count =\
    \ extensions.size\n    extensions.sort!", "  return nil\nend\n</cell>\n<code language=julia-1.5>",
  end, "  # Your code here\nend", "    \n    # You need to write code here that finds\
    \ the strongest extension. \n    # Once you find the strongest extension, you\
    \ should return it with the \n    # following format: ClassName.StrongestExtensionName.\n\
    \    \n    return \"\"\n</cell>\n<cell>", "    \n    extension_set = []\n    extension_set\
    \ = extensions.map {|x| x[/([A-Z])(?!\\1)/]}\n    extension_set.uniq.sort", " \
    \ # Write your code here.\n  extension_count = extensions.length\n  extension_sum\
    \ = extensions.inject(0) do |sum, e|\n    sum = sum + e.to_s.upcase.length\n \
    \ end\n  extension_avg = (extension_sum / extension_count).round\n  extension_avg.zero?\
    \ ? nil : class_name + '.' + extensions.min_by { |e| -e.to_s.upcase.length }.to_s.downcase\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nWow. Thanks for this. I didn't\
    \ realize you could pass an array to a method like that. One of the problems I've\
    \ come across is with the .inject method. I'm trying to understand it, but I don't\
    \ know what it does yet. Can you give me an example of this method being used?\n\
    <|/ c |>\n<| c |>\nThis method is used to create your own version of inject that\
    \ can operate on anything that implements `Enumerable` such as an array. For example,\
    \ `[1,2,3].inject(0) do |sum, a| sum += a; sum * 2` returns `6`. That's because\
    \ it's like `[1,2,3].inject(0) {|sum, a| sum += a; sum * 2}`\n<|/ c |>\n<| c |>\n\
    Okay, but can you give me an example of what the .inject method does in general?\n\
    <|/ c |>\n<| c |>\nI just added an explanation for that method in the question.\n\
    <|/ c |>\n<| c |>\nThanks. That's a really clear explanation. One thing I'm confused\
    \ about is the `@count.zero? ? nil : class_name + '.' + extensions.min_by { |e|\
    \ -e.to_s.upcase.length }.to_s.downcase` part. What is the purpose of the \"?:\"\
    \ operator?\n<|/ c |>\n<| a tags=ruby |>\nThis is a slight variation on Benjamin's\
    \ solution.  Instead of using an array, I've used a Hash to store the class names\
    \ and strengths.  I've also added a method to determine if two names are equal\
    \ by their classname and strength.  I've also made sure that there is only one\
    \ match for a given classname and strength pair.  \nThe code is not as elegant\
    \ as Benjamin's code, but I think it's easier to read and it does give the correct\
    \ answer.\n<code>", "  extension_strength = extensions.length\n  extensions.each\
    \ do |ext|\n    if ext.to_s.downcase.gsub(/./, \"\").split('').sort.join('') =~\
    \ /[A-Z]/\n      extension_strength *= (ext.to_s.downcase.gsub(/./, \"\").split('').sort.join('').length\
    \ - ext.to_s.downcase.gsub(/./, \"\").split('').sort.join('').gsub(/[A-Z]/, '0').length)\n\
    \    end\n  end\n  return class_name.to_s + \".\" + extensions[extension_strength].to_s\n\
    end", "  # Initialize the strongest extension\n  strongest_extension = []", " \
    \ extensions_map = Hash.new\n  extensions.each do |extension|\n    extensions_map[extension.downcase]\
    \ += 1\n  end\n  highest_strength = extensions_map.max_by { |k, v| v }\n  highest_strength[highest_strength.last.split('').max]\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI love how you just fixed your answer.\
    \ Thanks for giving me so many ideas on how to go about this.\n<|/ c |>\n<| c\
    \ |>\nOk, I now understand why some people don't like answering homework. But\
    \ why am I being downvoted? If my answer is not good, tell me why, and I'll fix\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\nA possible solution:\n<code>", "  # TODO: Write\
    \ your code here.\nend", "  max_strength = -1\n  best_name = \"\"\n  best_extension\
    \ = \"\"\n  extensions.each do |extension|\n    strength = class_name.split(extension).length\
    \ - 1\n    if strength > max_strength\n      max_strength = strength\n      best_name\
    \ = class_name\n      best_extension = extension\n    end\n  end\n  return \"\
    #{best_name}.#{best_extension}\"\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ a dscore=0 |>\nYou can use the class of the object you're trying to sort by.\
    \ For example:\n<code>", "  max_strength = -1\n  max_extension = None\n  i = 0\n\
    \  while i < extensions.size do\n    length = extensions[i].to_s.size\n    extension\
    \ = extensions[i].to_s.downcase\n    cap = extension[0].upcase.length\n    sm\
    \ = extension[1].downcase.length\n    strength = cap - sm\n    if strength > max_strength\
    \ then\n      max_strength = strength\n      max_extension = extensions[i]\n \
    \   end\n    i += 1\n  end\n  return class_name + \"_\" + max_extension.to_s.downcase\n\
    end\nputs Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\", \"StuFfed\"\
    ])", "    \n    if class_name == '' or extensions == []\n       return ''\n  \
    \     \n    cap_counter = 0\n    stren_counter = -1\n    \n    for ext in extensions:\n\
    \        if ext.count('C') - ext.count('S') == cap_counter:\n            stren_counter\
    \ = cap_counter\n            cap_counter = 0\n        elif ext.count('C') - ext.count('S')\
    \ < cap_counter:\n            stren_counter = cap_counter\n            cap_counter\
    \ = ext.count('C') - ext.count('S')\n        else:\n            stren_counter\
    \ = ext.count('S') - ext.count('C')\n            cap_counter = ext.count('C')\
    \ - ext.count('S')\n        \n    if cap_counter > stren_counter:\n        return\
    \ class_name + '.' + extensions[cap_counter]\n    else:\n        return class_name\
    \ + '.' + extensions[stren_counter]\n    \n</cell>\n<cell>", "    extension_strengths\
    \ = {}\n    class_name = class_name.split('.').last\n    class_name = class_name.split('.').first\n\
    \    \n    extensions.each do |extension|\n        extension_parts = extension.split('.')\n\
    \        extension_parts.reverse!\n        extension_strength = extension_strengths[extension_parts[0]]\
    \ ||= 0\n        extension_strength += extension_parts[extension_parts.size -\
    \ 1] - extension_parts[0]\n    end\n    \n    sorted_extension_strength = extensions.sort{|a,b|\
    \ extension_strengths[b] - extension_strengths[a]}\n    \n    if extension_strengths[class_name].nonzero?\n\
    \        return class_name + '' + sorted_extension_strength[extension_strengths[class_name].nonzero_index]\n\
    \    end\n    \n    \n    return class_name + '' + sorted_extension_strength[0]\n\
    end", "  extension_strength = nil\n  max_extension_strength = nil\n  extension_for_class\
    \ = nil\n  \n  classes.each do |classname|\n    classname_extensions = nil\n \
    \   \n    classname.split('.').each do |class_extension|\n      classname_extensions\
    \ = classname_extensions + class_extension.split('').map{|c| c.upcase - c.downcase}.compact.uniq.sort.reverse\n\
    \    end\n    \n    classname_extensions << ''\n    classname_extensions = classname_extensions.reverse\n\
    \    \n    extensions_without_extension_strength.each do |e|\n      es = e.split('.').map{|c|\
    \ c.upcase - c.downcase}.compact.uniq.sort.reverse\n      \n      if e.include?('.')\
    \ && es.include?('')\n        classname_extensions = classname_extensions + e.split('.').reverse\n\
    \      end\n    end\n    \n    if extension_strength.nil?\n      extension_strength\
    \ = classname_extensions.map{|e| e.split('').map{|c| c.upcase - c.downcase}.compact.uniq.sort.reverse}.reduce(:+).to_f\n\
    \    end\n    \n    if classname_extensions.any? {|e| e.include?('.') && e.include?('')\
    \ }\n      extension_strength = extension_strength.max\n    end\n    \n    if\
    \ classname_extensions.any? {|e| e.include?('.') && !e.include?('') }\n      classname_extensions.each\
    \ do |class_extension|\n        classname_extension = class_extension.split('.').map{|c|\
    \ c.upcase - c.downcase}.compact.uniq.sort.reverse\n        \n        if extension_strength.nil?\n\
    \          extension_strength = classname_extension.reduce(:+).to_f\n        end\n\
    \        \n        if extension_strength == classname_extension.reduce(:+)\n \
    \         extension_for_class = class_extension\n        end\n      end\n    end\n\
    \    \n    if max_extension_strength.nil?\n      max_extension_strength = extension_strength\n\
    \    end\n    \n    if extension_strength == max_extension_strength\n      extension_for_class\
    \ = extension_for_class\n    end\n  end\n  \n  if extension_for_class.nil?\n \
    \   return nil\n  end\n  \n  return class_name + '.' + extension_for_class\nend",
  "\t# Your code here\nend\n</cell>\n<code language=julia-1.5>", "  extension_set\
    \ = HashSet<String>.new\n  extension_set.add 'SErviNGSliCes'\n  extension_set.add\
    \ 'Cheese'\n  extension_set.add 'StuFfed'", "    return class_name.gsub(/([A-Z]+)/,\
    \ \"#{$1.upcase}\").\n                gsub(/([a-z]+)/, \"#{$1.downcase}\").\n\
    \                sub(\"#{class_name}\", \"#{class_name.gsub(/[A-Z]/, \"\")}#{$1.gsub(/[a-z]/,\
    \ \"\")}\").\n                gsub(/([A-Za-z]+)/) { |ext| extensions.find { |e|\
    \ e.include?(ext) } }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThat's a great\
    \ contribution.  I used the Ruby version and it works.  The challenge is to refactor\
    \ it so it can be reused.\n<|/ c |>\n<| c |>\nSorry, I misunderstood your question.\
    \ The problem with your solution is that it assumes there are no duplicates in\
    \ the extensions list, and doesn't take into account that case matters. \"Slices\"\
    \ might be the extension for \"Sliced\" and the extensions are unsorted but \"\
    Slices\" is more likely to be the extension for \"Sliced\" than \"Slice\".\n<|/\
    \ c |>\n<| c |>\nThe question does not say anything about case matters. I see\
    \ your point and agree that my solution has problems here in general. The challenge\
    \ is to refactor it so it can be reused.\n<|/ c |>\n<| c |>\nYeah I guess I misinterpreted\
    \ the requirements.  But I like your solution and I'm sure it would work if we\
    \ modified it slightly to remove the requirement for no duplicates.  I'll post\
    \ my updated code.\n<|/ c |>\n<| c |>\nOk, I have updated my answer. The only\
    \ thing that should be modified is the regex for extensions. If you have any questions,\
    \ let me know in the comments. Thanks!\n<|/ c |>\n<| a tags=string,ruby dscore=1\
    \ |>\n<code>", "  case extensions.length\n  when 0 \n    class_name\n  when 1\n\
    \    class_name+\".\"+extensions[0]\n  else\n    class_name+\".\"+extensions.sort_by\
    \ {|e| -e.count}.first\n  end\nend", "  best_extension = -1\n  best_extension_strength\
    \ = -1\n  best_extension_name = \"\"\n  \n  extension_names = extensions.collect\
    \ { |e| e.downcase }\n  \n  extension_names.each do |extension_name|\n    extension\
    \ = class_name.constantize\n    extension_strength = extension.send(:extension_strength)\n\
    \    \n    if extension_strength >= best_extension_strength\n      best_extension_strength\
    \ = extension_strength\n      best_extension = extension\n      best_extension_name\
    \ = extension_name\n    end\n  end\n  \n  if best_extension_strength >= 0\n  \
    \  return best_extension_name\n  end\n  \n  return \"\"\nend\n</cell>\n<text>\n\
    5. Test your code by running the following cell to check if the result matches\
    \ the expected result.", "  exts = []\n  extensions_count = extensions.length\n\
    \  letters_count = class_name.count(\"A\") + class_name.count(\"B\") + class_name.count(\"\
    C\")\n  extensions_count += letters_count - class_name.count(\"A\") - class_name.count(\"\
    B\") - class_name.count(\"C\")", "  strongest_extension = nil\n  extensions.each\
    \ do |extension|\n    number_of_uppercase_letters = extension.index(extension.upcase)\n\
    \    number_of_lowercase_letters = extension.index(extension.downcase)\n    number_of_letters\
    \ = number_of_uppercase_letters + number_of_lowercase_letters\n    strength =\
    \ number_of_letters / extension.length\n    if strongest_extension.nil? || strength\
    \ > strongest_extension.strength\n      strongest_extension = { :extension =>\
    \ extension, :strength => strength }\n    end\n  end\n  return \"#{class_name.capitalize}#{strongest_extension[:extension]}\"\
    \nend", "  # Your code here\nend", "  sorted_extensions = extensions.sort\n  first_extension\
    \ = sorted_extensions[0]\n  strength = first_extension.chars.count - first_extension.downcase.chars.count\n\
    \  return class_name + \".\" + first_extension.downcase.chars.count.to_s + \n\
    \         sorted_extensions.map { |e| e.downcase.chars.count }.max \nend", " \
    \   count = 0\n    max = 0\n    extension = nil\n    extension_class = nil\n \
    \   \n    classes.each do |c| \n        if c.name.include?(class_name)\n     \
    \       if extensions.count > max then\n                max = extensions.count\n\
    \                extension = extensions.max\n                extension_class =\
    \ c\n            end\n        end\n    end\n    \n    extension_class.name + \"\
    .\" + extension.name\nend\n</code>\n<|/ a dscore=1 tags=ruby,algorithm,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\n<code>", "    \n    extensions_set = extensions.sort {|x,y|\
    \ x.to_s.downcase <=> y.to_s.downcase}\n    \n    extensions_set.each do |extension|\n\
    \        \n        class_name_string = class_name.to_s.gsub(\"::\", \".\")\n \
    \       extension_string = extension.to_s.gsub(\"::\", \".\")\n        \n    \
    \    extension_class = load_class(extension_string)\n        \n        strength\
    \ = extension_class.strength\n        \n        if strength >= 0\n           \
    \ \n            if strength > class_name_string.split(\".\").inject(0) {|s,e|\
    \ s + e.size}\n                return \"#{class_name}.#{extension}\"\n       \
    \     end\n            \n            return extension\n            \n        end\n\
    \        \n    end\n    \n    return nil\nend\n</code>\n<|/ a tags=ruby,string,arrays,methods\
    \ |>\n<| c |>\nNice answer! I like the elegance of `gsub`. I was just trying to\
    \ figure it out myself and was having trouble getting my head around your solution.\
    \ Thanks for taking the time to write it.\n<|/ c |>\n<| c |>\nThanks! I added\
    \ some comments, hope it helps.\n<|/ c |>\n<| c |>\nIt does, thank you. I realized\
    \ I hadn't written the method for the case where the extension is already in the\
    \ class name, so I added it to my solution. :)\n<|/ c |>\n<| c |>\nWow, that's\
    \ awesome and thank you for taking the time to write it all out. I understand\
    \ it better now and your solution makes sense to me. Thanks again\n<|/ c |>\n\
    <| c |>\nThis is great. Would it be possible to add the case where you have 2\
    \ extensions with the same strength?\n<|/ c |>\n<| a dscore=0 tags=ruby,string,arrays,methods\
    \ |>\nHere's an example which might help you understand what you're doing. \n\
    <code>\nmodule Foo\n    def self.bar\n        'foo'\n    end\nend", "  str.split(class_name).reduce(&:+).reverse.compact.sort_by\
    \ {|x| x.to_s.length}.last.downcase + extensions[-1*extensions.size].to_s\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThe code above is slightly incorrect. `Strongest_Extension`\
    \ does not take a list of extensions but only a single string. Changing it to\
    \ `def Strongest_Extension(class_name, extension_string)` fixes it but also the\
    \ rest of the code is incorrect. `str` is the name of the string module. Don't\
    \ use it as a variable name, it breaks the code.\n<|/ c |>\n<| a dscore=0 |>\n\
    My solution is similar to the answer given by Amit Joki\n<code>", "    extension_count\
    \ = {}\n    for extension in extensions\n        extension_count[extension.downcase(ext)]\
    \ ||= 0\n        extension_count[extension.downcase(ext)] += 1\n    \n    sorted_extension_count\
    \ = extension_count.sort_by { |e, count| -count }", "    return nil\nend\n</code>\n\
    <|/ q dscore=0 |>\n<| c |>\nCould you explain what this means?  `'a' < 'A'`\n\
    <|/ c |>\n<| c |>\n`'a' < 'A'` is true\n<|/ c |>\n<| c |>\nAh, I see.  Well, if\
    \ you want `'a' < 'A'` to be false, why would you compare `'a'` and `'A'`?\n<|/\
    \ c |>\n<| c |>\nBecause a is an extension of A.\n<|/ c |>\n<| c |>\nThe extensions\
    \ list is supposed to contain class names.  I guess it's supposed to contain lowercase\
    \ letters?\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  extensions = extensions.sort\n\
    \  extensions.reverse\n  extensions = extensions.map do |e|\n    e = e.downcase\
    \ \n    index = e.index('c')\n    if index\n      e.gsub!('c', '').length\n  \
    \  end\n    e\n  end\n  result = \"\"\n  extensions.each do |e|\n    if result\
    \ != \"\"\n      result << \".#{e}\"\n    else\n      result << \".#{e}\"\n  \
    \  end\n  end\n  result = class_name.split(\"::\").last + \".\" + result\n  return\
    \ result\nend", "  return nil if extensions.empty?\n  extension_strengths = [extension.split(\"\
    -\")[0].to_i \\\n                          for extension in extensions]\n  max_index\
    \ = extension_strengths.index(extensions.max)\n  return class_name.constantize\
    \ \\\n           + \".\" + extensions[max_index].split(\"-\")[1].to_s\nend", '  extensions_count
    = extensions.count', "  # Initialize an empty list to store the strongest extension.\n\
    \  strongest_extension = []", "  extension_strengths = []\n  for i in 0..(length(extensions)\
    \ - 1)\n    extension_strengths << getExtensionStrength(class_name, extensions[i])\n\
    \  end\n  extension_strengths.sort { |a, b| b <=> a }[0...-1].join(\".\").to_s\n\
    end", "  \n  new_extensions = []", "  return nil\nend", "\tstrongest = nil\n\t\
    extensions.each do |extension|\n\t\tstrength = class_name.to_s.gsub(extension.upcase,\
    \ \"\").length\n\t\tif strength > strongest\n\t\t\tstrongest = extension\n\t\t\
    end\n\tend\n\treturn strongest.downcase\nend\n</cell>\n<text>\nProblem 3", " \
    \ # Write your code here\n  extensions = extensions.sort.map {|x| x.downcase }\n\
    \  extensions.reverse!\n  index = -1\n  while extensions.length != 0 do\n    index\
    \ = (index + 1) % extensions.length\n    extension = extensions[index]\n    extensions.delete_at(index)\n\
    \    index = -1\n    if extension == class_name then return class_name + '.' +\
    \ extension\n  end\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| a tags=ruby,string,regex\
    \ |>\nYou probably want to use gsub with positive lookahead assertion:\n<code>\n\
    \"HelloWorld\".gsub(/(?!([A-Z])\\1)/, '')\n</code>\nThis matches every character\
    \ which is not followed by the character immediately preceding it (\\1).\nThis\
    \ means all uppercase letters followed by another uppercase letter, which is equivalent\
    \ to [^A-Z]. \nIt then replaces it with an empty string and returns the result.\n\
    <|/ a dscore=1 |>\n<| c |>\nThat is pretty nice, I was just about to post a similar\
    \ answer with `gsub!` but you beat me to it.\n<|/ c |>\n<| c |>\nYour answer is\
    \ nice, but it will not work with this example input: `\"HelloWorld\"` - it only\
    \ returns `\"\"` instead of `\"HelloWorld\"`. Also, the solution should be made\
    \ more robust by matching the last capital letter, which may be `[a-z]` or `[A-Za-z]`.\n\
    <|/ c |>\n<| c |>\nAh yes, I see what you mean. I'm not sure what my solution\
    \ could do to that\n<|/ c |>\n<| c |>\nYour code doesn't match the example input\
    \ `\"HelloWorld\"`, because of `[a-z]` and `[A-Za-z]`. Your code also doesn't\
    \ work when `\"HelloWorld\"` is the first letter of the string. So, your code\
    \ doesn't work at all when `\"HelloWorld\"` is the first letter of the string.\
    \ I suggest you edit your answer to match the given example.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI suggest you use regular expressions to extract the lowercase characters\
    \ which follow an uppercase character, and replace those characters with an empty\
    \ string before finding the longest extension.\n<code>", "  # Write your code\
    \ here\n  class_name = class_name.to_s\n  extensions = extensions.map(&:to_s)\n\
    \  extensions.each do |e|\n    begin\n      class_name.constantize.send(:included_modules).each\
    \ do |m|\n        next if m == e\n        if m.to_s.size == e.to_s.size\n    \
    \      break\n        end\n      end\n    rescue NameError => e\n      puts \"\
    #{class_name}.#{e} not found.\"\n      next\n    end\n  end\n  \n  extensions.sort.reverse.first\
    \ \nend", "  extensions_hash = {}\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  name_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_hash = HashExtension(extensions_hash)\n\
    \  extensions_hash = HashExtension(extensions_hash)\n  extensions_", "  strongest_extension\
    \ = nil\n  extensions.each do |extension|\n    extension_class = extension.split('_').join('')\n\
    \    extension_class = (extension_class.upcase).chars.map { |c| c.to_s.upcase\
    \ }.join\n    extension_class_strength = (class_name.split(' ').length - extension_class.split('\
    \ ').length - 1)\n    extension_class_strength = extension_class_strength.to_f\
    \ / extension_class.split(' ').size\n    if extension_class_strength > strongest_extension\n\
    \      strongest_extension = extension\n    end\n  end\n  return strongest_extension\n\
    end\n</cell>\n<cell>", "  result = []\n  strongest_extension = nil\n  extensions.each\
    \ do |extension|\n    strength = extension.rindex(class_name) - extension.rindex(class_name.downcase)\n\
    \    if strength > strongest_extension.strength\n      strongest_extension = extension\n\
    \    end\n  end\n  result.unshift(strongest_extension) if strongest_extension\n\
    \  result.join('.')\nend\n</code>\nThe code above works as expected. For example:\n\
    <code>\nputs Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", 'Cheese', 'StuFfed'])",
  "  str_extensions = extensions.select { |ext| ext.capitalize == ext.downcase }\n\
    \  str_extensions.sort.last\nend", "    extensions.sort.each do |ext|\n      \
    \  next if ext.match(/[A-Z]/)\n        next if ext.match(/[a-z]/)\n        str\
    \ = ext.to_s.gsub(/[A-Z]/){|s| s.upcase - s.downcase }.gsub(/[a-z]/){|s| s.downcase\
    \ - s.upcase }\n        if str == class_name\n            return class_name\n\
    \        end\n    end\n    return class_name \nend", "  extensions_sorted = extensions.sort\n\
    \  extensions_sorted.map! { |x| x.capitalize }\n  extensions_sorted.map! { |x|\
    \ x.downcase }\n  extensions_sorted.map! { |x| x.gsub(/[A-Z]/, \"\") }\n  extensions_sorted.map!\
    \ { |x| x.gsub(/[a-z]/, \"\") }\n  extensions_sorted.map! { |x| x.gsub(/[0-9]/,\
    \ \"\") }\n  extensions_sorted.map! { |x| x.gsub(/[^A-Za-z]/, \"\") }\n  extensions_sorted.map!\
    \ { |x| x.gsub(/[^0-9A-Za-z]/, \"\") }\n  extensions_sorted.map! { |x| x.gsub(/[[:space:]]/,\
    \ \"\") }", "    # @return a string\n    \n    upper_class_name = upper_case_first_letter(class_name)\n\
    \    upper_extensions = upper_case_first_letter(extensions).split(', ')\n    upper_extensions_str\
    \ = upper_extensions.join('.')", "  strongest = nil\n  extension_count = extensions.length\n\
    \  extensions.each_with_index do |e, i|\n    next unless e.start_with?(class_name.upcase)\n\
    \    strength = class_name.size-e.downcase.size\n    extension_count = i\n   \
    \ strongest = e if strength < 0\n  end\n  return strongest\nend", "    \n    #\
    \ Your code here\n    \n    return \"\"\n</code>\nSample Test Cases:\n<code>",
  "  strongest_extension = nil\n  extensions.each_index do |i|\n    extension = extensions[i]\n\
    \    if (i == 0)\n      strongest_extension = extension\n    else\n      extension_class\
    \ = extension.slice(0, extension.length-1)\n      if (extension_class == class_name)\n\
    \        strongest_extension = extension\n      end\n    end\n  end\n  strongest_extension\n\
    end\n</textarea></form>", "\tmin_strength = extensions[0]\n\tmin_strength_index\
    \ = -1\n\tmin_extension = extensions[0]\n\tfor i in range(len(extensions))\n\t\
    \textension_name = extensions[i]\n\t\textension_length = len(extension_name)\n\
    \t\textension_cap = extension_capitalized(extension_name)\n\t\textension_sm  =\
    \ extension_small(extension_name)\n\t\textension_score = extension_length - extension_cap\
    \ - extension_sm\n\t\tif (extension_score > min_strength)\n\t\t\tmin_strength\
    \ = extension_score\n\t\t\tmin_extension = extension_name\n\t\t\tmin_strength_index\
    \ = i\n\treturn min_extension, min_strength_index\nend\n</cell>\n<code language=julia-0.5>",
  "  extensions.sort.reverse\n  extensions.each { |e| e.split('').each_with_index\
    \ { |c, i| \n    if c == c.upcase - c.downcase\n      return class_name.upcase\
    \ + e.split('')[0, i+1].downcase \n    end }\n  }\n  return class_name\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
