name: HumanEval_65_circular_shift
language: rb
prompt: "# Circular shift the digits of the integer x, shift the digits right by shift\n\
  # and return the result as a string.\n# If shift > number of digits, return digits\
  \ reversed.\ndef circular_shift(x, shift)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_circular_shift\n\
  \    candidate = method(:circular_shift)\n    assert_equal(\"001\", candidate.call(100,\
  \ 2))\n    assert_equal(\"12\", candidate.call(12, 2))\n    assert_equal(\"79\"\
  , candidate.call(97, 8))\n    assert_equal(\"21\", candidate.call(12, 1))\n    assert_equal(\"\
  11\", candidate.call(11, 101))\n  end\nend\n"
completions: ["  # Shift right if x is negative, shift left if x is positive\n  sign\
    \ = (x < 0) ^ (x > 0)\n  x <<= shift\n  x >>= shift\n  return x if sign == (x\
    \ & 1) ^ sign else x ^ 0xFFFFFFFF\nend", "  x.to_s.reverse.chars.each_slice(shift).to_a.reverse.join\n\
    end", "    return x.gsub(/..\\z/, '') * ('0' * (shift + 1)).split(//).reverse.join\n\
    end", "  if shift == 0\n    return x\n  end\n  shift_digits = shift.to_s.reverse\n\
    \  if shift_digits == \"0\"\n    return x\n  end\n  shift_digits += \"\"\n  digits\
    \ = x.to_s.reverse\n  shift_digits = shift_digits.reverse\n  shift_digits += \"\
    0\" * (shift - shift_digits.length)\n  digits.slice!(0, shift_digits.length) <<\
    \ shift_digits\n  digits.reverse!\n  digits = digits.reverse\n  return digits\n\
    end\n</cell>\n<code language=julia-0.6>\ncircular_shift(10, 1)\n</cell>\n<code\
    \ language=julia-0.6>\ncircular_shift(101, 1)\n</cell>\n<code language=julia-0.6>\n\
    circular_shift(101, 0)\n</cell>\n<code language=julia-0.6>\ncircular_shift(10,\
    \ -1)\n</cell>\n<code language=julia-0.6>\ncircular_shift(-1, 10)\n</cell>\n<code\
    \ language=julia-0.6>\ncircular_shift(-1, 0)\n</cell>\n<code language=julia-0.6>",
  "  return x.to_s.reverse[shift].to_s\nend", "  str = \"\"\n  while x > 0\n    digit\
    \ = x % 10\n    x = x / 10\n    str = sprintf(\"%d%s%d\",digit,str,digit)\n  end\n\
    \  str.slice!(0...shift)\n  return str\nend", "  if x > 9\n    shift, x = x, shift\n\
    \    x.slice!(0, shift)\n    x.reverse!\n  end\n  x\nend\n</code>\nExample:\n\
    <code>", "    digits = x.to_s.split(//)\n    digits.reverse[0...shift]\n    digits.reverse\n\
    end", "    if shift == 0\n        return x\n    digits = x.to_s.reverse\n    digits.reverse!\n\
    \    while shift > digits.length\n        digits = digits.reverse!\n        shift\
    \ -= 1\n    return digits.reverse!\nend", "    digits = x.to_s.reverse.gsub(/(\\\
    d{#{shift}}(?=\\d)|\\d{#{shift-1}})/, '\\1').to_i\n    digits = (digits/10).ceil\n\
    \    shift = shift.to_i\n    (digits / shift).times do |i|\n      x = x * 10\n\
    \      x = x.succ\n    end\n    x\nend", "  x.slice!(0..shift)\n  (0...x.size).reverse!\n\
    \  x\nend\n</code>\n<|/ a |>\n<| c |>\nThe solution above doesn't seem to work\
    \ when shift is greater than the number of digits: in `circular_shift(100000000000000000,\
    \ 6)` it returns `100000000000000001` rather than `100000000000000000`\n<|/ c\
    \ |>\n<| a tags=string,ruby,arrays,split dscore=4 |>\n<code>", "  \n  # if shift\
    \ > length, return digits reversed\n  return x.reverse[0..shift].join if shift\
    \ > x.length else x.reverse[0..shift].join.reverse\nend", "    digits = x.to_s.chars\n\
    \    digits.reverse!\n    digits[0...shift] = digits.delete_at(shift)\n    digits\
    \ = digits.join\nend", "  str = x.to_s\n  n = x.to_s.length\n  newstr = ''\n \
    \ for i in 0...n\n    shift = (n + shift - 1) % n\n    newstr += str[n-1-i]\n\
    \  end\n  puts newstr\nend", "  x.zero? ? \"\" : x.to_s.reverse[0...shift] + x.to_s.reverse[shift...]\n\
    end\n</code>\nYou can use the above methods with to_i, to_f, to_s and to_r\n<code>\n\
    > x = 1234567890.to_i\n1234567890\n> x.circular_shift(3)\n\"23456789\"\n> x =\
    \ 1.234.to_f\n1.234\n> x.circular_shift(3)\n\"1.235\"\n> x = 1.234.to_r\n1.234\n\
    > x.circular_shift(3)\n\"1.235\"\n> x = 1.234.to_s\n\"1.234\"\n> x.circular_shift(3)\n\
    \"1.235\"\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for providing me with more\
    \ information. I'm going to use your suggestions and try to implement this into\
    \ my code. I'll let you know how I do\n<|/ c |>\n<| c |>\nThanks so much! This\
    \ is really helpful and works great. I would like to ask a follow up question:\
    \ what would be the best way to go about implementing this in ruby? I'm going\
    \ to be using Ruby 2.7 and I believe that includes some changes made to String.\
    \ Do I need to make a new class and use inheritance to accomplish this?\n<|/ c\
    \ |>\n<| c |>\nThe above solution will work. As I pointed out in the answer, you\
    \ cannot write `+` on strings in Ruby 2.7. You will need to define a new method\
    \ on `String` that will concatenate the two strings as you need. You don't need\
    \ to make any changes to the existing `+` method of `String`. You can write methods\
    \ like `circular_shift` on `String` just like any other method in Ruby.\n<|/ c\
    \ |>\n<| c |>\nIf you have problems implementing it, I'd suggest you ask a new\
    \ question showing what you've tried, and ask for help with specific problem you're\
    \ facing.\n<|/ c |>\n<| c |>\nI'll keep that in mind. Thank you!\n<|/ c |>\n<|\
    \ a |>\n<code>", "  str = ''\n  \n  (1..shift).each do |s|\n    str = s if (x\
    \ >> s).zero?\n  end\n  \n  str.reverse\nend", "  if shift > x.length\n    shift\
    \ = x.length\n  end\n  result = ''\n  while shift > 0\n    digit = x % 10\n  \
    \  x = x / 10\n    digit = digit.to_s + digit.divmod(10).last.to_s\n    result\
    \ = digit.insert(0, result)\n    shift -= 1\n  end\n  if shift < x.length\n  \
    \  result = x.digits.reverse.join.insert(0, result)\n  end\n  result\nend\n</code>\n\
    Here's an example of how it works:\n<code>\nx = 123.456\nputs circular_shift(x,\
    \ 2)", "  # Keep a copy of the input int\n  x = x.to_i\n  result = ''\n  # Do\
    \ a circular, right shift, of the original integer\n  while x > 0\n    digit =\
    \ x % 10\n    x = x / 10\n    result += (digit * shift)\n  end\n  return result.reverse\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\nIn Ruby 1.9.3 you can do this:\n\
    <code>\n\"10223\".scan(/\\d/).collect {|n| n}.reverse\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nA good answer should include an explanation.\n<|/ c |>\n<| c |>\n\
    Sorry, I realized I thought this was more a way to get rid of non-digit characters,\
    \ as opposed to returning a reversed string.  My bad.  I suppose I should delete\
    \ this answer...\n<|/ c |>\n<| a |>\nI like solution, just to play with Ruby internals\n\
    <code>", "    if shift > x.length\n        shift - x.length\n    end \n    return\
    \ x.to_s.reverse[shift]\nend\n</code>\nThe method circular_shift will return the\
    \ string of the digit of the integer x shifted to the right by a number of places\
    \ (which can be a positive number or zero).\nThe method shift_digits will return\
    \ the string of the digit of the integer x shifted to the left by a number of\
    \ places (which can be a positive number or zero).\n<code>\nshift_digits(5, 0)",
  "  shift = shift or 0\n  return x[shift..x.length].join\nend", "  result = \"\"\n\
    \  i = shift\n  while i >= 0 do\n    digit = x % 10\n    result << digit\n   \
    \ x /= 10\n    i -= 1\n  end\n  if shift < 0 then\n    result = reverse(result.reverse)\n\
    \  end\n  return result\nend", "  ret = \"\"\n  xs = x.to_s\n  if xs <= shift\n\
    \    return ret\n  digits = xs.to_i.abs\n  while digits.length > shift\n    digits\
    \ = digits.reverse.slice(shift, digits.length)\n    shift = shift - digits.length\n\
    \  end\n  return digits.reverse\nend\n</pre>\n</div>", "  x = x.to_s\n  x.slice!(0,\
    \ shift).reverse!\n  x\nend\n</code>\nAnd here is the solution I came up with\
    \ thanks to Karnak and his post (http://gist.github.com/2237173):\n<code>", " \
    \ x = x.to_i\n  return x.to_s.reverse.gsub(x) { |c| c.to_i(10).to_s(shift) }\n\
    end\n</code>\nNow let's test this:\n<code>\n>> circular = CircularShift.new\n\
    >> circular.shift('abcd', 1)\n=> \"bcde\"\n>> circular.shift('abcd', 2)\n=> \"\
    bdc\"\n>> circular.shift('abcd', 3)\n=> \"abcd\"\n>> circular.shift('abcd', 4)\n\
    => \"abc\"\n>> circular.shift('abcd', 5)\n=> \"abc\"\n>> circular.shift('abcd',\
    \ 6)\n=> \"abcd\"\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis is awesome!\
    \ Thanks for taking the time to write this out! One thing I wasn't sure on is\
    \ how this would work if I needed to shift it by more than just 1. Would I need\
    \ to have it loop through and shift it multiple times each time until the length\
    \ of the string is reached? Also, how does it handle negative numbers? This was\
    \ a great response though!\n<|/ c |>\n<| c |>\n: I don't think you'll need looping.\
    \ You can simply do `circular.shift('abcd', 10)`, for example. Negative numbers\
    \ will also work. I'm going to edit my answer to include a test case for negative\
    \ numbers. As for the shift by more than 1, you can do `circular.shift('abcd',\
    \ 8)`.\n<|/ c |>\n<| a tags=ruby,string |>\nOne more approach:\n<code>\n'abc'.rjust(-2,\
    \ 'a').slice!(-2, 2)", "  # Convert x to a string\n  s = x.to_s\n  # Return the\
    \ shift digits reversed\n  s[0..-shift]\nend\n</cell>\n<code language=julia-1.6>",
  "  x >> shift % x.to_s.length\nend", "  str = x.to_s\n  str.slice!(0, shift)\n \
    \ str.slice!(0, str.size - shift)\n  str.reverse!\n  str\nend", "  return x.to_s.reverse[shift]\n\
    end", "  if x >= 10**shift then return nil\n  local s = math.ceil(x/10**shift)\n\
    \  return string.format('%.%d', x/10^(shift-1))..string.format('%.%d', x)..string.format('%.%d',\
    \ s)\nend", "  x.slice!(0, shift)\n  x.reverse! if shift > x.length\n  x\nend",
  "  x -= 1\n  digits = []\n  while x > shift\n    digits.push(x % 10)\n    x /= 10\n\
    \  end\n  digits.reverse!\n  return digits.join\nend", "  digits = x.digits.reverse\n\
    \  return if shift.zero?\n  digits.reverse.each_cons(2).zip(digits).map{|a, b|\
    \ b + (shift - a.length).abs} + digits.reverse\nend\n</code>\nFor a large number,\
    \ this method can be an improvement over the previous one.\n<|/ a dscore=5 |>\n\
    <| a dscore=5 |>\nI used the code from and modified it to add zero padding in\
    \ the end of the number, if needed (instead of padding in the front of the number\
    \ like in other solutions)\n<code>", "    digits = x.to_s.chars.to_a\n    digits.reverse!\n\
    \    digits.reverse! if shift > digits.length\n    digits.reverse! if shift <\
    \ digits.length\n    digits.reverse! if shift < 0 && shift > digits.length\n \
    \   digits.reverse! if shift > 0 && shift < digits.length", "  xs = []\n  if x\
    \ > 0\n    xs << (x/10)\n    xs << (x%10)\n    x.times do |i|\n      xs << ((i/10)*10)\n\
    \      xs << ((i%10)*10)\n    end\n  end\n  xs.reverse!\n  xs.join\nend\n</code>\n\
    <|/ a dscore=4 tags=ruby,algorithm |>\n<| c |>\nAhhh. Thanks for that. The problem\
    \ is that I want to find the number of shifts and then get the number of digits.\
    \ I thought about it some more and I edited my question with a more detailed example\
    \ and hopefully that will shed some light. Your solution was very close, though.\n\
    <|/ c |>\n<| c |>\nNice answer. Can you explain how you arrived at these conclusions?\
    \ `shift >= digits` doesn't seem obvious to me. Why do we do `shift >= digits/2`\
    \ (half of the digits)? I understand that `shift % 2` might lead to negative results.\
    \ What about `shift % 10`? I understand that `shift / 10` might result in `0`\
    \ if the input is zero. How do you arrive at these conclusions?\n<|/ c |>\n<|\
    \ c |>\nI did it backwards. I used the fact that the number of digits is always\
    \ equal to the number of digits.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  shift\
    \ = shift % x.length\n  x << shift\n  (-shift).times { x >>= 1 }\n  x.to_s\nend\n\
    </code>\nA little benchmarking shows that this is about 30% faster (for the naive\
    \ implementation) for larger shifts:\n<code>\nrequire 'time'", "  if x < 1\n \
    \   return 0\n  \n  if shift < 0\n    x = x.abs\n    shift = -shift\n  end\n \
    \ \n  digits = x.to_s.reverse.gsub(/(.{#{shift}})/, \"\\\\1\".reverse)\n  \n \
    \ digits.empty? ? 0 : \"#{digits}1\"\nend", "    digits_reversed = ''\n    i =\
    \ shift\n    while i > 0 do\n        digits_reversed = digits_reversed + x[i]\n\
    \        i = i - 1\n    end\n    return digits_reversed\nend", "  if shift > x.length\n\
    \    x.reverse!\n    shift = (x.length - 1) - shift\n  end\n  x.reverse!\n  x.chars.each\
    \ { |c| c.rotate(shift) }\n  x = x.join\n  return x unless x.length > 2\n  x.reverse!\n\
    end\n</code>\nand \n<code>", "  return x.reverse[shift...x.size].reverse\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nWhile your solution is more elegant, I believe\
    \ it has the disadvantage of having to convert the number to an array.\n<|/ c\
    \ |>\n<| c |>\nYes, you are right. There should be a better way. I am not that\
    \ experienced in ruby yet so I thought it would be easier to just post the solution\
    \ in ruby. If someone knows, I would appreciate it!\n<|/ c |>\n<| a tags=algorithm,ruby,arrays\
    \ |>\nHere's another way to do it, in Ruby:\n<code>\nx = 1111 # => 111\n(x & -x).reverse.split(//).reverse\
    \ # => [\"1\", \"1\", \"1\", \"1\", \"1\"]\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,ruby,arrays\
    \ |>\nA variation on what has already been said:\n<code>\ndigits = 3.digits\n\
    p digits.map { |i| digits[0..(digits.length - i)].inject(&:+) }", "  result =\
    \ []\n  len = x.length\n  if len > shift\n    len -= 1\n  for i in 0...len\n \
    \   digit = x[len-i-1]\n    result << digit\n  end if len > shift\n  return result.reverse\n\
    end", "  shift = shift % x.length\n  result =\n  result.concat(x.slice(shift,\
    \ x.length))\n  \n  if shift > x.length\n    result.concat(x.slice(0,shift))\n\
    \  end\n  \n  result\nend", "  res = []\n  if shift > x.length\n    shift -= 1\n\
    \  for i in 0..x.length\n    res << x[i]\n    res << x.slice(i+shift, i+2*shift)\n\
    \    res << x.slice(i+2*shift, i+shift)\n  end\n  res.reverse!\n  return res\n\
    end", "    digits = x.to_s\n    digits[0...shift-1].join + digits[shift..-1].reverse\n\
    end\n</code>\nAnd the same goes for other operations like addition, subtraction,\
    \ multiplication, division and modulo.\nBut a little differently you might want\
    \ to use Ruby's BigInteger class instead:\n<code>", "  digits = x.digits.reverse.slice(shift,\
    \ -1)\n  digits.reverse!\n  digits.join\nend", "  if x >= 10\n    x.slice!(0,\
    \ -shift).reverse!\n  end\n  return x\nend", "  return x.reverse[shift - x.length\
    \ % shift]\nend", "  digits = x.to_s(10).reverse\n  return digits.chars[shift..-shift]\n\
    end", "  return x.slice!(shift..-1) if shift < x.size\n  x.reverse! if shift >\
    \ x.size\n  x.slice!(0..shift)\nend\n</cell>\n<code language=julia-1.5>\ncircular_shift(42,\
    \ 3)\n</cell>\n<text>\nNow let's create another function that can perform the\
    \ actual calculation. We'll call this calc_shift_digits and it takes a BigInt\
    \ as the first argument and an Integer as the second.", "  if x < 10\n    return\
    \ x.to_s\n  shift = shift % x.length\n  return x.reverse.insert(0, x.digit(x.length)\
    \ - x.digit(shift)).join\nend", "  digits = x.to_s.reverse[shift].reverse\n  x.to_s[shift]++\
    \ if shift <= x.to_s.length\n  else digits\nend\n</code>\nThis solution is less\
    \ efficient but a little shorter.\n<|/ a |>\n<| c |>\nYou have a typo in your\
    \ answer. `shift.to_s.length` should be `shift<x.length`.\n<|/ c |>\n<| c |>\n\
    : Thanks. Fixed.\n<|/ c |>\n<| a dscore=2 |>\nUsing regex and array methods:\n\
    <code>\n def rotate x\n    x.to_s.scan(/\\d+|\\D/).map { |e| (e = e.to_i; x[x.length\
    \ - e]).to_s }.join(\"\")\n  end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nIt also\
    \ works with non-digits. `rotate('abc')` returns `'bca'` instead of `'abc'`.\n\
    <|/ c |>\n<| a tags=ruby |>\nAnother way to do it, using Regexp\n<code>", "  len\
    \ = (x.length > shift.length) ? x.length : shift.length\n  ret = x.dup.slice\n\
    \  (0..length).step(shift) { |i| ret.insert(i,ret.shift) }\n  ret.join(\"\")\n\
    end\n</code>\nand now we have the code\n<code>", "  res = []\n  i = shift\n  while\
    \ i >= 0\n    res << x % 10\n    x /= 10\n    i -= 1\n  end\n  res.reverse!\n\
    \  return res.join\nend", "  xs = x.to_s.reverse.gsub(/1..(?=\\d)/, '..\\1')\n\
    \  xs.gsub!(/(..)\\1(..)/, '\\2\\1')\n  xs.gsub!(/..\\1/, shift)\n  xs.reverse\n\
    end", "  x.to_s.split('').rotate(shift).join\nend", "  if shift > x.length\n \
    \   x\n  else\n    x.slice!(shift - 1) + (x.last - x.first).reverse\n  end\nend",
  "  if shift > x.length\n    return x.reverse\n  x_copy = x.clone\n  x_copy.insert(shift,\
    \ nil)\n  return x_copy.reverse\nend\n</code>\n<|/ a tags=ruby,arrays,multidimensional-array\
    \ |>\n<| a dscore=0 |>\nHere's a way that works with an array of arrays:\n<code>",
  "  if shift > x.length\n    # return digits in reverse order\n    x.reverse\n  end\n\
    \  x[0, shift % x.length] = x.slice!(0, shift % x.length) + x.slice!(shift % x.length)\n\
    \  x[0, shift] = ''\n  x\nend", "  shift = shift % x.size\n  x.slice!(0, shift)\
    \ if shift > 0\n  x.slice!(shift, x.size) if shift < x.size\n  x.to_s\nend", " \
    \ if shift > x.length\n    x.reverse!\n  end\n  return x + x.chars[0..length-shift-1]\n\
    end", "  x.slice!(0, shift % x.size)\n  x[shift % x.size]\nend", "  if shift >\
    \ x.length\n    shift -= 1\n  digits = x.to_s.split(\"\").reverse\n  shifted_digits\
    \ = digits.reverse.shift(shift).reverse\n  string = \"\"\n  digits.each_index\
    \ do |i|\n    string << shifted_digits[i]\n  end\n  return string\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis is almost correct, but you should use `shifted_digits\
    \ = digits.reverse.shift(shift).reverse` in the loop.\n<|/ c |>\n<| c |>\nThanks,\
    \ I corrected it. I forgot that I had to reverse digits twice\n<|/ c |>\n<| a\
    \ dscore=0 tags=ruby,arrays,string,ruby-on-rails |>\nIf x is your number, and\
    \ shift is the number of digits to shift, try this:\n<code>", "  digits = x.to_s\n\
    \  digits = digits.reverse\n  digits.slice!(0, shift)\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n  digits.reverse!\n\
    \  ", "\tdigits = []\n\tremainders = []\n\tshift_count = 0\n\tdigit, = x\n\twhile\
    \ shift > shift_count:\n\t\tdigits.insert(0, digit)\n\t\tremainders.insert(0,\
    \ digit % 10)\n\t\tdigit, = divmod(digit, 10)\n\t\tshift_count += 1\n\tdigits.insert(0,\
    \ remainders.pop())\n\treturn ''.join(map(str, digits))\nend", "  digits = x.to_s.split(//)\n\
    \  digits.reverse!", "  result = ''\n  while shift > 0 do\n    digit = x % 10\n\
    \    result = digit.to_s + result\n    x = x // 10\n    shift -= 1\n  end\n  digit\
    \ = x % 10\n  result = digit.to_s + result\n  result.reverse\nend", "  x.to_s.split(//).rotate(shift).join\n\
    end", "  shift.downto(0) do |shift|\n    s = x.slice(-shift, -1 * shift)\n   \
    \ x = x.slice(-shift)\n    x = s + x\n  end\n  x\nend", "  return x.to_s.ljust(shift,\
    \ \"0\") + x.to_s.rjust(-shift, \"0\")\nend", "  x.slice!(0, shift)\n  x.reverse!\n\
    \  x\nend", "  if x.to_s.length >= shift.to_s.length\n    x << shift\n    x.reverse!\n\
    \  end\nend\n</code>\n<code>\ncircular_shift(1, 2)\n  #=> [3, 2, 1, 0] \ncircular_shift(1,\
    \ 0)\n  #=> [1, 1, 1] \ncircular_shift(1, 7)\n  #=> [7, 6] \n</code>\n<code>\n\
    circular_shift(5, 3)\n  #=> [3, 2, 1, 0, 0, 0, 0, 0] \n</code>\nHere are some\
    \ alternative solutions.\n<code>", "  str = \"\"\n  while x.to_s.length < shift\n\
    \    str += x.to_s\n    x = x.to_s + \"0\"\n  end", "  new_digits = []\n  for\
    \ i in x\n    new_digits << shift\n    new_digits += i.to_s.chars.reverse.chars\n\
    \    shift -= digits.length(i)\n  end\n  new_digits.reverse\nend\n</pre>\n</div>",
  "  n = 0\n  r = \"\"\n  while (shift >= 0)\n    n += x\n    r = n.to_s(10).rjust(shift,\
    \ r)\n    shift -= n.size\n  end\n  return r.reverse\nend", "  if x < 10\n   \
    \ x.digits.reverse! if shift > x.digits.size\n    x.digits << shift\n    x.digits.reverse!\
    \ if shift > x.digits.size\n    x.to_s\n  else\n    x.digits.reverse! if shift\
    \ > x.digits.size\n    x.digits >> shift\n    x.digits.reverse! if shift > x.digits.size\n\
    \    x.to_s\n  end\nend", "  # Write your code here.\n  shift.times do\n    x.divmod\n\
    \    x.reverse!\n  end\n  x.to_s\nend", "  digits = x.to_s.chars\n  digits.rotate!(shift)\n\
    \  digits.reverse!\n  digits.join\nend", "  return x.reverse[shift].reverse.chop\n\
    end", "  return x.to_s.chars.circular_shift(shift).to_s\nend", "  result = \"\"\
    \n  while x != 0\n    if x % 10 == shift % 10\n      result += x.to_s\n      x\
    \ /= 10\n      shift /= 10\n    else\n      result += x.to_s[0..shift-1].reverse\n\
    \      x /= 10\n      shift /= 10\n    end\n  end\n  return result.reverse\nend",
  '  new_digits = (0...shift)', "  if shift > x.length\n    x.reverse!\n    shift\
    \ = (x.length - shift)\n  end", "  if shift < 0\n    x, shift = shift, -x\n  digits\
    \ = x.digits.reverse\n  digits[shift...] = []\n  x.digits = digits\n  x.format!\n\
    end", "  return x.digits.reverse.insert(0, x.digits.shift).reverse.join(\"\")\n\
    end", "  digits = x.digits.reverse\n  digits[0...shift] = digits.slice(shift,\
    \ shift+x.digits.length)\n  digits.join(\"\").reverse\nend\n</code>\nAnd now the\
    \ code:\n<code>", "  if shift > x.length\n    shift = x.length - shift\n  end\n\
    \  return x.to_s.reverse.chars.first(shift).join\nend", "  x = x.to_s\n  shift\
    \ %= x.size\n  return x.reverse[shift..-1] + x.reverse[0...shift]\nend", "  return\
    \ x.to_s.reverse[shift]\nend", "  return x if shift <= 0 \n  return x.to_s.split(//).reverse.join(//).split(//).reverse.join(//)[0..-shift]\n\
    end", "  x = '' + x\n  if shift > x.length\n    shift.times{x << '1'}\n    x.reverse!\n\
    \  else\n    x[shift..-1].reverse!\n  end\n  x\nend", "    digits = x.digits\n\
    \    digits[shift] = (digits[shift] - 1) % (10 ** shift)\n    return Bignum(digits).to_s\n\
    end\n</code>\nAnd this works great for a shift > 9:\n<code>\nirb> Bignum.new(\"\
    1234567890\").shifted_by(3)\n=> #<Bignum:0x00000002bfb2d0>\nirb> Bignum.new(\"\
    1234567890\").shifted_by(-10)\n=> #<Bignum:0x00000002bfb1d0>\n</code>\nBut when\
    \ I try to shift by a number > 9, I get a RangeError:\n<code>\nirb> Bignum.new(\"\
    1234567890\").shifted_by(15)\nRangeError: digit range is 9..99\n</code>\nI guess\
    \ this is because I can't have a large enough digits, because shifting by 15 means\
    \ shifting by 8 or 9 digits (and there are too many digits to store in Bignum).\n\
    But what if I wanted to shift by a number > 100?  I can't do that with the current\
    \ Bignum library. My solution would be to use an array of digits, where each element\
    \ of the array represents a digit, and use the digit index to reference the appropriate\
    \ digit in the array. E.g., shifting by 100 (shifted by 100) would just add a\
    \ new element to the array, and reference the 100th element in the array. This\
    \ would work fine with any shift > 9, but the digit index would overflow (i.e.\
    \ if shifting the digits by 100 means shifting by 99 digits, you would get an\
    \ overflow).\nAnd now the problem: how to get around this problem? \nA good solution\
    \ would use an array of the digits, where each element of the array represents\
    \ a digit, and use a circular shift to shift the digits of the array. This would\
    \ mean the digit index is the circular shift amount, rather than an index of a\
    \ digit, and there is no overflow (i.e. the digit index wraps around at 99 digits).\n\
    But I can't figure out how to get around this problem. Here's my attempt:\n<code>",
  "  x_str = x.to_s\n  x_str.reverse\n  n_str = x_str.slice(0, shift) + x_str.slice(shift,\
    \ x_str.size)\n  n_str.to_s\nend\n</code>\nThis can be done in Ruby as well:\n\
    <code>", "    digits = x.to_s(2)\n    result = \"\"\n    \n    length = digits.count(\"\
    0\")\n    \n    while shift > length\n        digits = digits.reverse!\n     \
    \   shift -= length\n        length = digits.count(\"0\")\n    end\n    \n   \
    \ digits.reverse!\n    digits.slice!(0, shift)\n    \n    result.concat!(digits.reverse!)\n\
    \    \n    result\nend\n</code>\nThis returns the same result as the example given\
    \ in the question. Some notes:", "  digits = x.to_s.reverse.split(//)\n  digits.reverse!\n\
    \  digits.reverse!\n  digits[shift..-1] + digits.join(//)\nend\n</code>\n<|/ a\
    \ tags=ruby,string,algorithm dscore=0 |>\n<| a tags=ruby,string,algorithm |>\n\
    You could use a combination of String#split and Array#shift.\n<code>\nx = \"123456\"\
    \nx.split(//).shift(4)", "  return x.reverse.chars.to_a.reverse.slice(shift, x.size).join\n\
    end\n</code>\nExample:\n<code>\n2.2.0 :001 > shift_str = \"hello world\"\n =>\
    \ \"hello world\" \n2.2.0 :002 > shift_str\n => \"worldhell\" \n2.2.0 :003 > shift_str.circular_shift(2)\n\
    \ => \"lleoworld\" \n2.2.0 :004 > shift_str.circular_shift(3)\n => \"lleowooorld\"\
    \ \n2.2.0 :005 > shift_str.circular_shift(4)\n => \"lleowooorldd\" \n2.2.0 :006\
    \ > shift_str.circular_shift(10)\n => \"lleowooorlddddbba\" \n2.2.0 :007 > shift_str.circular_shift(10)\n\
    \ => \"lleowooorlddddbba\" \n2.2.0 :008 > shift_str.circular_shift(100)\n => \"\
    lleowooorlddddbba\" \n2.2.0 :009 > shift_str.circular_shift(10000000000000000000000)\n\
    \ => \"lleowooorlddddbba\" \n2.2.0 :010 > shift_str.circular_shift(100000000000000000000000)\n\
    \ => \"lleowooorlddddbbba\" \n2.2.0 :011 > shift_str.circular_shift(100000000000000000000000..100)\n\
    \ => \"lleowooorlddddbbba\" \n2.2.0 :012 > shift_str.circular_shift(100000000000000000000000..100).size\n\
    \ => 101 \n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>",
  "\tdigits = x.to_s.split(\"\").reverse\n\tdigits.each_with_index do |d, i|\n\t\t\
    if i >= shift\n\t\t\tdigits[i] = d\n\t\telse\n\t\t\tdigits[i] = \"#{digits[i]}#{digits[i\
    \ - shift]}\"\n\t\tend\n\tend\n\tdigits.reverse.join\nend", "  result = x.to_s\n\
    \  result.sub!(/.$/, \"\") if shift > result.length\n  shift % result.length.to_s\
    \ + result.slice!(0, shift)\nend", "  digits = x.to_s.chars.reverse.each_char.reduce(:<<)\n\
    \  digits.slice!(0, shift % digits.length)\n  digits.reverse!\n  digits.join(\"\
    \")\nend", "  return x.to_s.reverse.slice(1..-shift)\nend\n</code>\nHere's an\
    \ example showing how to use these methods:\n<code>", "  if x > 0\n    shifted_digits\
    \ = x.digits.slice!(-1 * (shift - 1))\n    shifted_digits = shifted_digits.reverse.map\
    \ {|digit|\n      shifted_digits[shifted_digits.index(digit) + shift..-1].join.to_i\n\
    \    }.join.to_s(10)\n  else\n    shifted_digits = x.digits.reverse.map {|digit|\n\
    \      digit.to_s(10)\n    }.join.to_s(10)\n  end\nend\n</code>\nTo test the above\
    \ implementations, we first need to define the helper method:\n<code>", "  x =\
    \ x.to_i\n  digits_reversed = digits.reverse\n  circular_shift_number = x\n  shifted_digits_reversed\
    \ = digits_reversed\n  while shift > digits.length\n    shift -= 1\n    circular_shift_number\
    \ = circular_shift_number >> shift.to_i\n    shifted_digits_reversed = digits_reversed.reverse\n\
    \  end\n  shifted_digits_reversed.join(\"\")\nend", "  shift = (shift < 0) ? shift\
    \ : -shift\n  digits = x.to_s.split(//)\n  digits.reverse!\n  digits.map! {|digit|\
    \ digit.rjust(shift).chr }\n  digits.join(//)\nend", "  x.slice!(0, shift)\n \
    \ x + (shift < x.length ? x.chars.reverse[0..-shift] : \"\")\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby dscore=2 |>\nHow about a little bit of recursion:\n<code>",
  "    digits = x.digits.reverse\n    digits.reverse! if shift > digits.length\n \
    \   digits.join(\"\") << shift\nend\n</code>\nThe algorithm is fairly straightforward.\
    \ Here's an explanation of what it does:\nFirst it breaks up the integer into\
    \ its digits. That turns the integer into an array where each entry in the array\
    \ is the value of the digit. For example:\n<code>\n x = 123456789\n x.digits\n\
    \ #=> [4, 5, 6, 7, 8, 9, 1, 2, 3, 0]\n</code>\nThen, since we want to shift them\
    \ right, we'll need to reverse the order of the digits. So we call reverse on\
    \ it:\n<code>\n x.digits.reverse\n #=> [9, 2, 5, 7, 4, 5, 6, 3, 1, 8, 0]\n</code>\n\
    Then we just need to join them back together and add in the shift amount:\n<code>\n\
    \ x.digits.reverse.join(\"\") << shift\n #=> \"922355674\" \n</code>\nFinally,\
    \ we can reverse the digits back into the integer with the new value by calling\
    \ reverse on the resulting string:\n<code>\n \"922355674\".reverse\n #=> 123456789\
    \ \n</code>\n<|/ a tags=algorithm,ruby,ruby-on-rails |>\n<| c |>\nWhy would you\
    \ use reverse when you could just use join?  Why bother converting it to an array?\n\
    <|/ c |>\n<| c |>\nI suppose you're right. `join` would be a little simpler. I'll\
    \ edit my answer.\n<|/ c |>\n<| c |>\nAs a professional developer, I always try\
    \ to think of the first version as being more clear and expressive than the second.\n\
    <|/ c |>\n<| c |>\nI like it, but I think it could be simplified to `x.digits.reverse.join(\"\
    \") << shift`.\n<|/ c |>\n<| c |>\n: Yes, that's also a good suggestion. I've\
    \ edited the answer.\n<|/ c |>\n<| a |>\nYou can do:\n<code>", "  return x.to_s.reverse.gsub(\"\
    (\\\\d+)\",\n    \"\\\\1#{('0' * shift).gsub(/^(\\d{1})$/, \"\\\\1\").reverse}\"\
    )\nend", "  n = x.to_s.length\n  if shift > n\n    shift = n\n  x << shift >>\
    \ shift\n  x.to_s\nend\n</code>\nExample:\n<code>\n> x = 2**80\n> x.to_s\n=> \"\
    9223372036854775808\"\n> circular_shift(x, 2)\n=> \"80000000000000000000000000000000000000000000000000000000000\"\
    \n> circular_shift(x, -2)\n=> \"0000000000000000000000000000000000000000000000000000000000008\"\
    \n</code>\nIn your case:\n<code>", "  if shift > string_length(x)\n    return\
    \ reverse(x)\n  else\n    digits = ''\n    while shift > 0 do\n      digits =\
    \ digits(x) + digits\n      shift -= 1\n    end\n    while shift < string_length(x)\
    \ do\n      digits = digits(x) + digits\n      shift += 1\n    end\n    return\
    \ digits\n  end\nend", "  digits = x.to_s.chars.to_a\n  digits.unshift(digits.shift)\n\
    \  digits.join(\"\")\nend", "  string = \"\"\n  \n  while x > 0\n    digit = x\
    \ % 10\n    string += digit.to_s\n    x = x / 10 \n  end\n  \n  string = string.chars.reverse\n\
    \  \n  string.each_char do |char|\n    if char != 0 && shift >= char.length\n\
    \      puts char\n      return\n    end\n    shift -= 1\n  end\nend", "  if shift\
    \ > x.length\n    x.reverse!\n    shift-=x.length\n  end\n  \n  if shift <= 0\n\
    \    x\n  else\n    x.reverse!\n    x.slice!(-shift)\n    x.reverse!\n  end\n\
    end", "  x.slice!(0, shift)\n  x.reverse! if shift > x.length\n  x\nend", "  digits\
    \ = x.to_s.reverse.split('')\n  digits.fill('')\n  digits = digits[shift..-1]\
    \ + digits.first + digits.last\n  digits.reverse!\n  return digits.join('')\n\
    end", "  shift = shift.abs\n  if shift > x.length\n    x.slice!(0...shift)\n \
    \ else\n    x.slice!(0...shift)\n  end\n  x\nend\n</code>\nYou can call this as\n\
    <code>\ncircular_shift(132, 4)", "  result = \"\"\n  digits_left = x.size\n  digits_right\
    \ = shift", "  return x.to_s.reverse[shift]\nend\n</code>\nAnd here's a test case:\n\
    <code>\n2.2.2 :001 > string = \"123\"\n => \"123\" \n2.2.2 :002 > string.to_int\n\
    \ => 123 \n2.2.2 :003 > string.to_i\n => 123 \n2.2.2 :004 > string.to_int\n =>\
    \ 123 \n2.2.2 :005 > string.to_i\n => 123 \n2.2.2 :006 > string.to_int\n => 123\
    \ \n2.2.2 :007 > string.to_i\n => 123 \n2.2.2 :008 > string.to_int\n => 123 \n\
    2.2.2 :009 > string.to_i\n => 123 \n2.2.2 :010 > string.to_int\n => 123 \n2.2.2\
    \ :011 > string.to_i\n => 123 \n2.2.2 :012 > string.to_int\n => 123 \n2.2.2 :013\
    \ > string.to_i\n => 123 \n2.2.2 :014 > string.to_int\n => 123 \n2.2.2 :015 >\
    \ string.to_i\n => 123 \n2.2.2 :016 > string.to_int\n => 123 \n2.2.2 :017 > string.to_i\n\
    \ => 123 \n2.2.2 :018 > string.to_int\n => 123 \n2.2.2 :019 > string.to_i\n =>\
    \ 123 \n2.2.2 :020 > string.to_int\n => 123 \n2.2.2 :021 > string.to_i\n => 123\
    \ \n2.2.2 :022 > string.to_int\n => 123 \n2.2.2 :023 > string.to_i\n => 123 \n\
    2.2.2 :024 > string.to_int\n => 123 \n2.2.2 :025 > string.to_i\n => 123 \n2.2.2\
    \ :026 > string.to_int\n => 123 \n2.2.2 :027 > string.to_i\n => 123 \n2.2.2 :028\
    \ > string.to_int\n => 123 \n2.2.2 :029 > string.to_i\n => 123 \n2.2.2 :030 >\
    \ string.to_int\n => 123 \n2.2.2 :031 > string.to_i\n => 123 \n2.2.2 :032 > string.to_int\n\
    \ => 123 \n2.2.2 :033 > string.to_i\n => 123 \n2.2.2 :034 > string.to_int\n =>\
    \ 123 \n2.2.2 :035 > string.to_i\n => ", "  x = x.to_i\n  if shift > x.length\n\
    \    x\n  else\n    x.to_s(length: shift - x.length).reverse\n  end\nend", "\t\
    digits = x.to_s.split(//)\n\tdigits.reverse!\n\tdigits.each_with_index { |digit,\
    \ idx| digits[idx] = digit.chars.reverse.join }\n\tdigits.reverse!\n\tdigits.join(//)\n\
    end", "  x.reverse!\n  x.reverse! shift\n  x\nend", "  \n  return x.to_s.reverse.gsub(/.{#{shift}}/)\
    \ {|m| m[0, shift] }.reverse\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| a tags=ruby,ruby-on-rails |>\nFor a more dynamic approach, that handles strings\
    \ containing numbers, and numbers between 1 and 999.\n<code>", "  if x <0\n  \
    \  x.abs\n  else\n    x.to_s.split('').circular_shift(shift).join\n  end\nend",
  "  shift = shift % x.length\n  if shift == 0\n    return x\n  a = x.clone\n  a.slice!(0,\
    \ x.length)\n  a.slice!(0, shift)\n  a.push(0)\n  return a.join\nend", "  x.slice!(0,\
    \ shift)\n  x.reverse!\n  x.reverse!\n  x.slice!(0, shift)\n  x.reverse!\n  return\
    \ x\nend", "    digits = x.to_s\n    digits[shift - 1] = (digits[shift - 1] *\
    \ 10 + digits[shift]).to_i\n    return digits.reverse\nend", "  if x < 0\n   \
    \ return x.abs\n  x = x.to_s\n  digits = x.to_s\n  if shift > x.length\n    shift\
    \ = x.length\n  end\n  digits.reverse\n  digits.slice!(0, shift)\n  return digits.reverse\n\
    end", "  if shift > length(x)\n    return reverse(x, shift)\n  else\n    digit\
    \ = x.to_s.rjust(length(x))\n    return digit[(0...shift).to_a.reverse.join +\
    \ digit[0...shift]].to_s\n  end\nend", "  digits.reverse!\n  digits[shift..-1]\
    \ += digits\n  digits.reverse!\n  digits.join\nend", "  # Initialize the string\n\
    \  string = ''\n  # Iterate through each digit in x\n  for i in x\n    # Increment\
    \ the string with x shifted right shift\n    string += i.to_s.chars.reverse[shift]\n\
    \  end\n  # Return string\n  return string\nend", "  digits = x.to_s(10).reverse.split(//)\n\
    \  digits.each_index do |i|\n    digits[i] = digits[i].to_s.rjust(shift, '0')\n\
    \  end\n  return digits.reverse.join\nend", "  result = \"\"\n  for i in 0..shift\
    \ - 1\n    result << x[i]\n  end\n  if shift > x.length\n    for i in 0..x.length\
    \ - 1\n      result << x[0]\n    end\n  end\n  return result\nend", "  x.to_i.to_s.reverse.chars.reverse[0...shift].join\n\
    end", "  return x.to_s.reverse[shift..(x.to_s.reverse.length - shift)].to_s\n\
    end", "    x.to_s.split(\"\").reverse.each_cons(shift).map(&:join).join\nend\n\
    </code>\nCircular shift method can be easily extended if needed, for example,\
    \ adding more shift digits at the right end. The method accepts integers only\
    \ for shifting digits so you cannot use it with a BigDecimal and it will fail\
    \ on negative numbers if used.\nAnother possible solution that works on BigDecimal\
    \ values but is more complicated is using BigDecimal#succ and BigDecimal#prec\
    \ methods which returns BigDecimal values when used with BigDecimal arguments.\
    \ With these methods we can subtract one BigDecimal from another and get the number\
    \ of digits left when adding or subtracting them.\n<code>", "  if x < 0\n    return\
    \ -1\n  shift_digits = shift.zero? # Shift digits left\n  else\n    shift_digits\
    \ = shift.zero? # Shift digits right\n  end\n  digits = x.to_s.reverse.split(\"\
    \") # Get digits from right to left\n  digits_count = digits.length\n  digits_count\
    \ = shift_digits ? digits_count + shift_digits : digits_count\n  digits_count\
    \ = (digits_count % 16).zero? ? digits_count : digits_count + 16\n  digits = digits[0...digits_count]\
    \ # Circular shift the digits\n  digits_count = digits_count.zero? ? digits.length\
    \ : digits_count\n  digits = digits[0...digits_count] # Circular shift the digits\
    \ back\n  digits_count = digits_count.zero? ? digits.length : digits_count\n \
    \ digits.reverse!\n  digits.join(\"\") # Reverse the digits from right to left\n\
    end\n</code>\nAnd here are some tests to prove the functionality\n<code>", " \
    \ return x.reverse.gsub(/([0-9]+)\\z/) { $1 << shift }.reverse\nend\n</code>\n\
    Example:\n<code>\n2.4.1 :007 > circular_string(123456789, 2)\n => \"2468913579\"\
    \n</code>\nThe method circular_string() is very similar to the Ruby function String#reverse.\
    \ As String#reverse does not modify the original string, we can use it safely.\n\
    <|/ a |>\n<| a dscore=0 |>\nI came across this problem, and while using \"reverse\"\
    \ is the best solution I came up with to solve this problem, I wanted to see if\
    \ there was a more concise solution out there.  Here is what I came up with:\n\
    <code>", "    digits = x.to_s.split(//)\n    result = \"\"\n    shifted_digits\
    \ = digits.reverse.each_slice(shift)\n    result = shifted_digits.join(\"\")\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nI should also mention this code is for\
    \ Ruby 1.8 and earlier.  Starting in Ruby 1.9, you can use `Enumerable#each_slice`\
    \ instead of `Array#chunk` to get a similar effect without an explicit `inject`.\
    \  It should be trivial for someone to convert this to Ruby 1.9 as well.\n<|/\
    \ c |>\n<| c |>\nWhat is the significance of the `//` in the split statement?\
    \  I see it [here](http://stackoverflow.com/questions/9393686/why-does-my-ruby-string-split-fail/9393765#9393765)\
    \ but I don't quite understand how that works.\n<|/ c |>\n<| c |>\n`split` takes\
    \ a regular expression (`//`) as its first argument.  `/` matches a single slash.\
    \  I suppose it could be `/.+?/` for a non-greedy match that includes everything\
    \ that comes before a slash.\n<|/ c |>\n<| c |>\nOh, that's a really good point.\
    \  I should have added a comment that `split` does not take a regular expression.\
    \  It takes an argument and that argument is an actual regular expression.  The\
    \ `split` method does return a regular expression object so `/` actually means\
    \ something else.\n<|/ c |>\n<| c |>\nI wouldn't call it a bad answer. Maybe you\
    \ should add some comments or explanation as to why this answer is the best. Just\
    \ because I'm curious.\n<|/ c |>\n<| a tags=ruby,string,algorithm dscore=2 |>\n\
    <code>", "    return x.to_s.reverse.chars.rotate(shift).join\nend", "  result\
    \ = ''\n  \n  while shift > 0\n    result = x.modulo(10**(shift)) + result\n \
    \   shift = shift - 1\n  end\n  \n  return result if x != 0\n  \n  result.reverse\n\
    end", "  len = (Math.log10(x) + shift).to_i\n  digits = x.to_s.chars.first(len).reverse\n\
    \  digits.reverse\nend", "    digits = x.digits\n    (shift <> 0) || (shift) =\
    \ (length(x) - 1)\n    shift = shift >= length(x) ? (length(x) - 1) : shift\n\
    \    result = []\n    (shift > 0) ? result.insert(0, digits.last) : result.unshift(digits.first)\n\
    \    shift = shift - length(x)\n    (shift <> 0) ? result.last.digits.unshift(digits.last)\
    \ : result.last.digits.unshift(digits.last.reverse)\n    return result\nend",
  "  if x < 0 \n    puts x\n    exit -1\n  end", "  num_digits = x.to_s.length\n \
    \ return x.to_s[0...(shift-num_digits)] + \\\n    x.to_s[shift...num_digits].reverse\n\
    end\n</code>\nThe algorithm above is relatively simple (it requires no extra memory,\
    \ or additional mathematical properties).  It could be improved by using more\
    \ digits of storage (for example, storing \"the least significant digits first\"\
    ), but it doesn't really need any more storage space.\n<code>", "  return x.reverse[shift]\
    \ if shift > x.length else x.reverse.insert(shift, x.reverse.first)\nend", " \
    \ x.slice!(0, shift + (shift % x.size || 0))\n  i = 1\n  x.each_char.with_index\
    \ do |char, index|\n    x.insert(index, char) if i > shift.abs\n    i += 1\n \
    \ end\n  x\nend", "    \n    if shift == 0 then\n        return x\n    end\n \
    \   \n    digits = []\n    remainder = x % 10\n    \n    # Add the digit to the\
    \ left of the shifted digit\n    digits.push(remainder)\n    x = x / 10\n    \n\
    \    # Circularly shift as long as there are digits to shift\n    until x < 10\n\
    \        \n        remainder = x % 10\n        digits.push(remainder)\n      \
    \  x = x / 10\n    end\n    \n    # Add the last digit to the shift\n    digits.push(x)\n\
    \    \n    digits.reverse\n    \n    return digits\nend", "  digits = x.to_s.reverse.to_i\n\
    \  shift ||= (digits.length + shift)\n  digits = digits.digits.slice!(0, shift)\n\
    \  digits = digits.digits.reverse.join\n  x.to_s(:digits => digits)\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby |>\n<| c |>\nYeah, but your example outputs 11 in\
    \ both cases, right? I don't think that's correct.\n<|/ c |>\n<| c |>\nHmmm...\
    \ it does work for me on the last example I provided, but maybe it only works\
    \ by chance.\n<|/ c |>\n<| c |>\nI edited my answer above to give an alternative\
    \ that doesn't use any methods which may or may not be available on every ruby\
    \ implementation.\n<|/ c |>\n<| a tags=ruby-on-rails,ruby |>\nYou can use the\
    \ shift method on a String:\n<code>\n\"1234\"[1..-1]\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nOh, I didn't know that. Thank you!\n<|/ c |>\n<| a tags=ruby-on-rails,ruby\
    \ |>\nJust wanted to add another way, not using any methods, which may or may\
    \ not be available on every ruby implementation:\n<code>\ns = \"1234\"\ns[0,s.length-s.count('1')\
    \ + 1]\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice trick, though I wouldn't call\
    \ it \"nice\". This can be done with a regular expression too: `s[/^\\d+$/,0]`.\n\
    <|/ c |>\n<| c |>\nI wouldn't consider it a \"nice\" trick, either. :-)  However,\
    \ I like it.  It seems like a more robust solution than mine.\n<|/ c |>\n<| a\
    \ dscore=1 |>\nUsing a regex:\n<code>\n>> \"1234\"[/^\\d+$/]\n=> \"12\"\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby |>\n<| a dscore=0 tags=ruby-on-rails,ruby |>\nI\
    \ think this would work\n<code>", "  return x.to_s.chars.circular_shift(shift).to_s\n\
    end", "  result = \"\"\n  \n  while shift > 0\n    digit = x % 10\n    result\
    \ = digit.to_s + result\n    x = x / 10\n    shift = shift - 1\n  end", "  result\
    \ = ''\n  while x\n    result = x.to_s + (result[-shift] || result)\n    x = x.to_i\
    \ >> shift\n  end\n  result.reverse\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Please don't forget to accept the answer that helped you the most.\n<|/ c |>\n\
    <| c |>\nThanks for the solution. It's working fine for small numbers.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nHere's a recursive implementation that works for numbers\
    \ up to a million\n<code>", "  x % 10 = (x % 10) - (x % 10 % shift) % shift\n\
    \  if x > 9\n    x /= 10\n    x % 10 = (x % 10) - (x % 10 % shift) % shift\n \
    \ end\n  x\nend", "  result = ''\n  while x > 0 do\n    digit = x % 10\n    result\
    \ = digit.to_s + result\n    x /= 10\n  end\n  result = result.to_s << shift if\
    \ shift > 0 && shift < result.length\n  return result\nend", "  result = ''\n\
    \  while shift > 0\n    digit = (x % 10) + 1\n    x = x // 10\n    digit = digit.to_s\
    \ << (shift - (digit.to_s.length - digit.to_s.length))\n    result += digit\n\
    \  end\n  return result + x.to_s[0...-shift]\nend", "  digits = x.to_s(0).reverse.split(//)\n\
    \  digits.map { |d| d.chars.circular_shift(shift).join }.reverse.join\nend", " \
    \ return x.chars.reverse_each.take_while { |n| n >= shift }.join\nend", "  str\
    \ = x.to_s\n  len = str.length\n  str.slice!(0, len - shift)\n  str + str.slice(len\
    \ - shift)\nend", "  x.slice!(0, shift)\n  x.reverse!\n  x.slice!(0, shift)\n\
    \  x\nend\n</code>\n<code>\n[[\"a\", \"b\"], [\"c\"]].map &:to_a", "  digits =\
    \ x.to_s.reverse\n  digits.slice!(0, shift)\n  digits.reverse!\n  digits + digits.reverse.slice!(shift)\n\
    end", "  x = [x.to_s(10).reverse][shift.to_i]\n  x.inject(\"\") { |str, x| str\
    \ << x}\nend", "  if shift > x.size\n    shift.times { x[-shift] = x[-shift].abs\
    \ }\n  else\n    shift.times { x.slice!(-shift) }\n    x\n  end\nend", "    shift\
    \ = shift % x.length\n    digits = x[0, shift]\n    rest = x[1..-1]\n    rest.concat(digits.reverse)\n\
    end", "  digits = x.to_s.reverse\n  digits = digits.gsub!(/([^0-9])(?=[0-9]|$)/,\
    \ '\\1').reverse\n  digits = digits.gsub(/(^|[^0-9])(?=[0-9])/, '\\1').reverse\n\
    \  digits = digits.gsub(/^0/, '1').reverse\n  digits = digits.gsub(/$/, '').reverse\n\
    \  digits.reverse.insert(0, digits.pop).reverse.join\nend", "  if shift == 0\n\
    \    x\n  else\n    div, rem = divmod(x, 10**(shift-1))\n    circular_shift(rem,\
    \ shift-1)\n  end\nend", "    digits = x.to_s.reverse\n    shift_digits = digits.each_char.with_index\
    \ do |digit, index|\n        (index + shift) % 10\n    end\n    digits.reverse.concat(shift_digits).join\n\
    end\n</code>\nNow let's have a look at the digits in each of the following cases:\n\
    <code>\nx = 123 \ncircular_shift(x, 1)\n  #=> \"103\"\ncircular_shift(x, 2)\n\
    \  #=> \"100\"\ncircular_shift(x, 3)\n  #=> \"121\"\ncircular_shift(x, 4)\n  #=>\
    \ \"123\"\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,algorithm dscore=2 |>\n\
    A solution from Ogden to Ruby 1.9.3:\n<code>", "  digits = []\n  x = x.to_s.split('').reverse.join\n\
    \  x.each_with_index do |digit, index|\n    digits.append(digits[(index-shift)\
    \ % digits.size].to_s)\n  end\n  return digits.reverse.join\nend\n</code>\nTest\
    \ cases:\n<code>\ncircular_shift('12345', 3) # => \"3412\"\ncircular_shift('12345',\
    \ 6) # => \"12345\"\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a |>\nHere's a\
    \ solution in Ruby:\n<code>", "  return x.to_s.length >= shift ? x[..-shift] +\
    \ (x[shift].to_s == '0' ? '' : x[shift].to_s) : x\nend", "  if shift > x.length\n\
    \    x.split(\"\").reverse.join\n  else\n    x.split(\"\").reverse.each_cons(shift).join\n\
    \  end\nend", "  return x.reverse.split(//, shift + 1).join(//).reverse\nend",
  "  return x.reverse.gsub(/.(?=\\d)/) { |s| (s.to_s.length < shift) ? s.to_s + s.to_s.reverse[1..-1]\
    \ : s }\nend\n</code>\n<|/ a tags=ruby,digit,binary dscore=2 |>\n<| a tags=ruby,digit,binary\
    \ |>\nThis works with any positive integer:\n<code>", "    digits = x.to_s\n \
    \   while shift > digits.length\n        digits = digits.reverse\n        shift\
    \ -= 1\n    return digits\nend\n</code>\nI figured out a way to get the number\
    \ of digits, I guess my last step would be to divide by the number of digits in\
    \ the string - but I'm unsure if that's possible. Also my attempts to get the\
    \ number of digits have failed so far.\n<|/ q |>\n<| c |>\nWhat are the constraints\
    \ on the input?  That is, what is the domain of the input?\n<|/ c |>\n<| c |>\n\
    The input is limited to integers greater than or equal to `1`, so anything above\
    \ `1` would throw an error. Sorry, I should have included that in the question.\
    \ I just edited it in.\n<|/ c |>\n<| c |>\n`digits = x.to_s` will give you a string\
    \ containing all the digits. You're going to have to split that up into an array\
    \ somehow. I'm not sure if you can do that without converting back to a string\n\
    <|/ c |>\n<| c |>\nHow about `x.to_s.each_char.map(&:to_i).reduce(:+)`? Or `x.to_s.each_char.map(&:to_i).reduce(:*)`.\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's one way:\n<code>\ndigits = x.to_s.split(//)\n\
    puts digits.length\n</code>\n<|/ a tags=ruby,string,arrays,digits |>\n<| c |>\n\
    `digits = x.to_s.split(//)` seems like a nice solution, but I keep getting an\
    \ error when testing it out: `x.to_s.split(//)` = `[\"\"]`\n<|/ c |>\n<| c |>\n\
    : What are you passing as `x`?\n<|/ c |>\n<| c |>\nI used the line `puts x.to_s.split(//)`\
    \ and it gave me `[\"\"]`. Do you know why?\n<|/ c |>\n<| c |>\nI used `puts x.to_s.split(//).length`\
    \ and it gave me `0`, so I'm guessing it's because there are whitespaces separating\
    \ the digits.\n<|/ c |>\n<| a dscore=2 tags=ruby,string,arrays,digits |>\nTry\
    \ this one:\n<code>\ndigits = x.to_s.split(//)\nputs digits.length\n</code>\n\
    <|/ a |>\n<| c |>\n`digits = x.to_s.split(//)` seems like a nice solution, but\
    \ I keep getting an error when testing it out", "  shift = shift - x.to_s.length\
    \ if shift > x.to_s.length \n  shift += x.to_s.length if shift < x.to_s.length\n\
    \  x.to_s.reverse.chars.take(shift).join\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ a dscore=1 |>\n<code>", "  return x.to_s.reverse[shift..(x.to_s.length)].to_s\n\
    end", "  digits = []\n  digits_i = 0\n  while x > 0 do\n    digits[digits_i] =\
    \ x % 10\n    digits_i += 1\n    x = x / 10\n  end\n  digits.reverse!\n  return\
    \ digits if shift > digits_i\n  digits.reverse!\n  digits.reverse! { |i| i - shift\
    \ }\n  digits.reverse!\nend", "  if shift > x.length\n    x = x.reverse\n  digits\
    \ = []\n  while x > 0\n    digits.push(x)\n    x = x >> shift\n  end\n  digits.reverse!\n\
    \  return digits.join(\"\")\nend\n</code>\nWe can also implement the function\
    \ \"digit-shift\" using a loop, which is much less efficient than using a recursive\
    \ function as shown above.\n<code>", "  shift % 2 == 0 ? x.reverse[0...shift].to_s\
    \ : x.reverse[shift...-1].to_s\nend\n</code>\n<|/ a |>\n<| a |>\nIn a similar\
    \ vein to user5746303's answer, but using a modulo to determine how many digits\
    \ to shift:\n<code>", "  # Your code here\n  result = \"\"\n  for i in x.to_s\n\
    \    result << i\n    result << shift(-1)\n  end\n  result.reverse!\n  return\
    \ result\nend", "  shift = shift || 1\n  if x >= 10\n    digits, x = x.divmod(10)\n\
    \    digits << shift if shift > 0\n    digits.reverse\n  end\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| a tags=ruby |>\n<code>", "  if shift > x.length\n    shift\
    \ = x.length\n  end\n  x.slice!(0, shift)\n  x.reverse!\n  x\nend", "  if shift\
    \ == 0\n    return x\n  shifted = x * 10\n  digits = shifted.to_s.reverse.split('')\n\
    \  digits.reverse!\n  digits.join('')\n  shifted = shifted.to_i\n  digits.zip(shifted).reduce(:+)\n\
    end", "  if x.zero?\n    \"\"\n  elsif shift > x.length\n    x.to_s.reverse\n\
    \  elsif shift < x.length\n    x.to_s.reverse[0...shift].concat( x.to_s.reverse[shift+1...x.length]\
    \ )\n  else\n    x.to_s.reverse[0...shift].concat( x.to_s.reverse[shift+1...x.length]\
    \ )\n  end\nend\n</code>\nTest cases:\n<code>\n>> circular_shift(0, 2)\n\"\"",
  "  if shift > x.length\n    x.reverse!\n  elsif shift < 0\n    raise ArgumentError.new(\"\
    shift must be a non-negative integer\")\n  elsif shift == x.length\n    return\
    \ x.reverse\n  else\n    return x.reverse[0...shift] + [x.reverse[shift]][0...x.length]\n\
    \  end\nend", "  # Write your code here.\n  x_digits = x.to_s.split(\"\")\n  x_digits.reverse!\n\
    \  shifted_digits = x_digits.take(shift) + x_digits.drop(shift)\n  return shifted_digits.join(\"\
    \")\nend", "  # initialize result to an empty string\n  result = \"\"", "  digits\
    \ = x.to_s(10).reverse\n  digits.reverse! if shift.positive?\n  digits.rotate!\
    \ shift\n  digits.reverse!\n  digits\nend", "  new_x = \"\"\n  shift = shift.abs\n\
    \  while x.to_s.length < shift\n    x <<= 1\n    x |= 1\n  while x.to_s.length\
    \ > shift\n    x >>= 1\n    x |= 1\n  new_x = x.to_s[0..(shift-1)]\n  new_x[1..-1]\n\
    end", "  string = \"\"\n  while shift > 0\n    digit = x % 10\n    string = digit*10+string\n\
    \    x = x // 10\n    shift -= 1\n  end\n  return string if x != 0\n  string.reverse\n\
    end", "  x = x.to_s\n  if shift == 0\n    return x + ''\n  else\n    return x.reverse[x.size\
    \ - shift..-1] + ''\n  end\nend", "  result = \"\"\n  \n  while shift > 0\n  \
    \  result += (x % 10).to_s\n    x /= 10\n    shift -= 1\n  end\n  \n  result.reverse\n\
    end", "  digits = x.to_s(10).split(//)\n  digits.reverse!\n  digits.take(shift).join(\"\
    \") + (shift > 0 ? digits[shift..-1] : \"\")\nend", "  x = x.to_s\n  return x.reverse.split(//).reverse.inject(\"\
    \") do |digits, digit|\n    digits = digits.reverse[digit, shift].chars.to_a\n\
    \    digits << digit\n    digits.reverse.join\n  end\nend", "  len = x.length\n\
    \  return len > shift ? x.reverse[0...shift]\n                  : x.reverse[0...len-shift].reverse\n\
    end", "  result = \"\"\n  n = (x % 10).to_s\n  while n > shift\n    result <<\
    \ n[-shift]\n    n << n[-shift]\n  end\n  result << n\n  result\nend\n</cell>\n\
    <code language=julia-0.5>\nshift_digits(3, 4)\n</cell>\n<code language=julia-0.5>\n\
    shift_digits(-9, 2)\n</cell>\n<code language=julia-0.5>\nshift_digits(1, 0)\n\
    </cell>\n<code language=julia-0.5>\nshift_digits(0, 0)\n</cell>\n<code language=julia-0.5>\n\
    shift_digits(6, 1)\n</cell>\n<code language=julia-0.5>\nshift_digits(-6, 1)\n\
    </cell>\n<code language=julia-0.5>\nshift_digits(127, 1)\n</cell>\n<code language=julia-0.5>\n\
    shift_digits(-127, 1)\n</cell>\n<code language=julia-0.5>\nshift_digits(127, 0)\n\
    </cell>\n<code language=julia-0.5>\nshift_digits(-127, 0)\n</cell>\n<code language=julia-0.5>\n\
    shift_digits(127, 2)\n</cell>\n<code language=julia-0.5>\nshift_digits(-127, 2)\n\
    </cell>\n<text>\nRecursive function with return value checking", "  return x.shift(shift).reverse.chars\n\
    end", "  return x[shift].to_s << x[shift..-1]\nend", "    digits = []\n    while\
    \ shift > 0 do\n        digits.push(x % 10)\n        x = x / 10\n        shift\
    \ -= 1\n    end\n    while shift > 0 do\n        digits.push(x % 10)\n       \
    \ x = x / 10\n        shift -= 1\n    end\n    return digits.reverse().join('')\n\
    end\n</code>\n<code>", "  # Your code here\n  digits = []\n  x.to_s.split(\"\"\
    ).each do |i|\n    digits = digits + i.to_i.to_s((shift.to_i + 1).to_i).split(\"\
    \").reverse\n  end\n  digits.join(\"\")\nend", "  digits = x.to_s(16).reverse.gsub(/../)\
    \ { |s| s.hex }\n  digits << shift >> shift\nend", "  shift = shift || 0\n  s\
    \ = x.to_s\n  s[shift..(s.length-1)] = s[(s.length-shift)..-1]\n  s.reverse!\n\
    end", "  x.to_s.reverse.slice!(0, shift).reverse\n  x.to_s\nend\n</code>\nNow\
    \ let's write some tests:\n<code>\nrequire \"minitest/autorun\"\nrequire \"pp\"",
  "    if shift > x.digits.length then\n        return x.reverse()\n    end\n    shift_digits\
    \ = x.digits[shift..(x.digits.length - 1)]\n    x.digits = x.digits.[0..(shift)]\
    \ + shift_digits + x.digits.[(shift + 1)]\nend", "    digits = x.to_s\n    digits.reverse!\n\
    \    digits << shift\n    digits.reverse!\n    digits.to_s\nend", "  if shift\
    \ > x.size\n    return x.to_s.reverse\n  else\n    zero = x.size - shift\n   \
    \ if shift > zero\n      return x.to_s[zero..-shift]\n    else\n      return x.to_s[zero..(x.size\
    \ - shift)]\n    end\n  end\nend", "    return ((x >> shift) + x << (32 - shift))\
    \ % (2 ** 32) * 10 ** shift\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
