name: HumanEval_33_sort_third
language: rb
prompt: "# This function takes a list l and returns a list l' such that\n# l' is identical\
  \ to l in the indicies that are not divisible by three, while its values at the\
  \ indicies that are divisible by three are equal\n# to the values of the corresponding\
  \ indicies of l, but sorted.\ndef sort_third(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_third\n\
  \    candidate = method(:sort_third)\n    assert_equal([2, 6, 3, 4, 8, 9, 5], candidate.call([5,\
  \ 6, 3, 4, 8, 9, 2]))\n    assert_equal([2, 8, 3, 4, 6, 9, 5], candidate.call([5,\
  \ 8, 3, 4, 6, 9, 2]))\n    assert_equal([2, 6, 9, 4, 8, 3, 5], candidate.call([5,\
  \ 6, 9, 4, 8, 3, 2]))\n    assert_equal([2, 6, 3, 4, 8, 9, 5, 1], candidate.call([5,\
  \ 6, 3, 4, 8, 9, 2, 1]))\n  end\nend\n"
completions: ["  n = l.length\n  l3 = (1..n).to_a\n  l3.each_with_index { |i,j|\n\
    \    if j % 3 == 0\n      l3[i] = j\n      l3[j] = j\n    end\n  }\n  return l3.sort\n\
    end", "  l3 = l[1..-1].map { |i| l[i..-1].select { |j| j % 3 != 0 }.sort }.flatten\n\
    \  l3 = [l3[0], l3[l3.size - 1], l3.last]\n  l3\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=arrays,ruby,sorting,grouping |>\n<code>\nrequire 'set'", "  l2\
    \ = [l.shift]\n  l.each do |i|\n    l2.push(l[i] if i % 3 == 0)\n  end\n  l2.push(l.pop)\n\
    \  l2\nend", "  l' =[]\n  for i in 0..(l.length-1)\n    if l[i] % 3 == 0 && l[i]\
    \ != 0 then\n      l' << i\n    end\n  end\n  for i in 0..(l.length-1)\n    if\
    \ l[i] % 3 == 1 && l[i] != 0 then\n      l' << i\n    end\n  end\n  for i in 0..(l.length-1)\n\
    \    if l[i] % 3 == 2 && l[i] != 0 then\n      l' << i\n    end\n  end\n  for\
    \ i in l'\n    l[i] = l[i] + 3\n  end\n  return l\nend", "  index = []\n  for\
    \ i in (0...l.length)\n    if i % 3 == 0\n      index.push(i)\n    end\n  end\n\
    \  \n  indexed_list = index\n  indexed_list.sort!\n  \n  for i in (0...index.length\
    \ - 1)\n    l[index[i]] = l[index[i + 1]]\n  end\n  \n  l\nend", "  len1 = l.length\n\
    \  len2 = len1\n  len3 = len1\n  len4 = len1", "  \n  #returns list of indexes\
    \ where l[i] != l[j] and l[i] < l[j]\n  l2 = []\n  \n  for i in (0..(l.length-1))\n\
    \    l2 << i\n  end\n  \n  for i in (0..(l.length-1))\n    for j in (0..(l.length-1))\n\
    \      \n      if l[i] != l[j] and l[i] < l[j] \n        l2[j] = nil\n       \
    \ break\n      end\n    end\n  end\n  \n  l2.sort\n  \n  return l2\nend", "  \
    \  l.each do |e|\n        l.delete_at(0)\n        l.insert(0,e)\n    end\n   \
    \ l\nend", "  l.each_with_index do |e, i|\n    if i%3 == 0\n      l.delete_at(i)\n\
    \    end\n  end\n  l\nend", "  l.each_with_index do |n,i|\n    next if n % 3 ==\
    \ 0\n    l[(i+1)..-1].sort_by {|n| n}.reverse\n  end\nend\n</code>\nAnd then you\
    \ can call it like so:\n<code>\nsort_third([1,2,4,3,6,7,2,1,0])\n</code>\nand\
    \ get this:\n<code>\n=> [1, 2, 2, 3, 1, 4, 6, 7, 0]\n</code>\nThe idea of the\
    \ code is to take each element of the list l, call it n, and to insert each element\
    \ into a new list l, whose indicies are divisible by three (n % 3 == 0). Since\
    \ this puts the list into descending order, we can simply take every other element\
    \ of the new list to place it before the number that was previously there. \n\
    If you were to run this code, you would get something like:\n<code>\n[7, 3, 2,\
    \ 1, 5, 4, 6]\n</code>\nAs you can see, this puts out the list with the indicies\
    \ that are divisible by three in descending order before the numbers that have\
    \ a 0 indicies. Since we are sorting descending order, we should have the numbers\
    \ printed out in the original order. I hope this helps.\n<|/ a tags=sorting,ruby,arrays\
    \ |>\n<| a tags=sorting,ruby,arrays |>\nJust to supplement the other answers,\
    \ I came up with a slightly different approach:\n<code>", "  l.map { |i| l[i]\
    \ % 3 == 0 ? [i, l[i]] : [i, l[i]] }.uniq.sort.map { |v| v[0] }\nend", "  return\
    \ l.sort_by {|i| i%3 == 0 || i%5 == 0} \nend", "  l.sort!\n  l.reduce(:+)\nend",
  "  l3 = [l[i] for i in indices(l, 3)]\n  l3.each do |t|\n    t.sort!\n  end\n  l3.flatten\n\
    end", "    l = l.sort_by { |x| x % 3 }\n    l.each_with_index { |x, i| l[i] =\
    \ l[i] }\nend\n</code>\nHere's your example data put into that format. Now all\
    \ we have to do is call this function on our data...\n<code>\ndata.each_with_index\
    \ do |row, i|\n    sort_third(row)\nend", "    # initialize empty list to hold\
    \ l with 3 as its last element added to it\n    sorted_third_list = []\n    #\
    \ initialize list that holds indicies in l that is divisible by three and that\
    \ are greater than the last element in l\n    three_indices = []\n    # initialize\
    \ indicies of l that is divisible by 3\n    divisible_by_three = []\n    # initialize\
    \ list that holds the value of indicies that are divisible by three\n    divisible_by_three_values\
    \ = []\n    # initialize list that holds the values of l that are not divisible\
    \ by three\n    other_values = []\n    # go through each element in l, check if\
    \ it is divisible by three, if it is divisible by three, then add the corresponding\
    \ indicies to three_indices\n    l.each do |value|\n        if value % 3 == 0\n\
    \            three_indices.push(value)\n        end\n    end\n    # go through\
    \ all indicies in l that are divisible by three\n    three_indices.each do |indicies|\n\
    \        # go through all indicies in l that are greater than the indicies in\
    \ three_indices and are divisible by three\n        indicies.upto(l.length - 1)\
    \ do |indicies2|\n            if indicies2 > indicies and l[indicies2] % 3 ==\
    \ 0\n                divisible_by_three.push(indicies2)\n                divisible_by_three_values.push(l[indicies2])\n\
    \            end\n        end\n    end\n    # go through all indicies in l that\
    \ are not divisible by three\n    divisible_by_three.each do |indicies3|\n   \
    \     # go through all indicies in l that are greater than the indicies in divisible_by_three\
    \ and are divisible by three\n        indicies3.upto(l.length - 1) do |indicies4|\n\
    \            if indicies4 > indicies3 and l[indicies4] % 3 != 0\n            \
    \    other_values.push(l[indicies4])\n            end\n        end\n    end\n\
    \    # sort other_values with other_values.sort, then append it to the end of\
    \ sorted_third_list\n    other_values.sort! do |a, b|\n        a <=> b\n    end\n\
    \    sorted_third_list.push other_values\nend\n</code>\nI then call this function\
    \ in my main function:\n<code>", "  l.each_with_index do |value, index|\n    if\
    \ index % 3 == 0\n      l[index + 3] ||= value\n      l[index + 2] = value\n \
    \   end\n  end\n  l\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you for trying\
    \ to help. Your code is correct, but I am not sure how to incorporate it into\
    \ my code. I tried to use your first function but couldn't get it to work. I will\
    \ post my code so you can see how I tried to incorporate it.\n<|/ c |>\n<| c |>\n\
    Sorry, I misread your question and thought you were talking about putting your\
    \ list into two lists (the one without the odd-numbered indices and the one with\
    \ the even-numbered indices) rather than sorting the list in-place.  I'll edit\
    \ the code above to demonstrate how you might use it.\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,list,sorting |>\nThis is what I came up with. It creates a new array\
    \ and uses each_slice to copy the elements between two indices into the new array,\
    \ then uses sort_by.\n<code>", "  third = [[nil,nil,nil] for i=0:(l.length/3)]\n\
    \  for i=0:(l.length/3)\n    third[i][0] = l[i][0]\n    third[i][1] = l[i][1]\n\
    \    third[i][2] = l[i][2]\n  end\n  third.sort_by! {|t| t}\n  return third\n\
    end", "    l.sort\n    l.each { |x| puts \"#{x},#{x.to_i}\" } # prints out all\
    \ elements and their indicies\n    puts \"---\"\n    # l' is the same as l, except\
    \ for those indicies with divisibility by three that are equal\n    l' = l.clone\n\
    \    l.each { |x| puts \"#{x},#{x.to_i}\" } # prints out all elements and their\
    \ indicies\n    puts \"---\"\n    # Now we find the indicies that are divisible\
    \ by three, and set those indicies to equal the indicies at the indicies that\
    \ are not divisible by three\n    l' .each_with_index do |x, i|\n        if x%3==0\
    \ then\n            l' [i] = i\n        end\n    end\n    l' # returns an array\
    \ of two elements, the indicies that are divisible by three, and the indicies\
    \ that are not divisible by three\nend\n</code>\nOutput:\n<code>\n4,4\n---\n4,4\n\
    ---\n5,5\n---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n---\n6,6\n---\n7,7\n\
    ---\n9,9\n---\n4,4\n---\n5,5\n---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n\
    ---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n---\n6,6\n---\n7,7\n---\n9,9\n\
    ---\n4,4\n---\n5,5\n---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n---\n6,6\n\
    ---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n\
    ---\n5,5\n---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n---\n6,6\n---\n7,7\n\
    ---\n9,9\n---\n4,4\n---\n5,5\n---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n\
    ---\n6,6\n---\n7,7\n---\n9,9\n---\n4,4\n---\n5,5\n---\n6,", "    l2.sort!\n  \
    \  l3 = []\n    l.each do |item|\n        if (item % 3 == 0)\n            l3.push(item)\n\
    \        else\n            l2.delete(item)\n        end\n    end\n    l2.each\
    \ do |item|\n        l3.push(item)\n    end\n    l3\nend", "  # Initialize a new\
    \ list to hold the new list\n  l2 = []\n  # Go through each element in the original\
    \ list\n  for i in l\n    # Only do stuff if the element is not divisible by three\n\
    \    if i % 3 != 0\n      # Add the element to the new list\n      l2 << i\n \
    \   else\n      # Go through the rest of the original list and find the smallest\
    \ value\n      lowest_index = nil\n      lowest_value = nil\n      for j in l\n\
    \        # Only do stuff if the element is divisible by three\n        if j %\
    \ 3 == 0\n          # Compare it to the current lowest value\n          value\
    \ = j\n          if !lowest_value\n            # Make the current lowest value\
    \ the value of the current element\n            lowest_value = value\n       \
    \     # Make the index of the current element the index of the current element\n\
    \            lowest_index = j\n          elsif lowest_value < value\n        \
    \    # Make the current lowest value the value of the current element\n      \
    \      lowest_value = value\n            # Make the index of the current element\
    \ the index of the current element\n            lowest_index = j\n          end\n\
    \        end\n      end\n      # If the new list is divisible by three and does\
    \ not contain the current smallest value, add the current element to the new list\n\
    \      if !lowest_value && l2.include?(i)\n        l2 << i\n      end\n      #\
    \ If the new list is divisible by three and contains the current smallest value,\
    \ add the current element to the new list\n      if lowest_value && l2.include?(i)\n\
    \        l2 << lowest_value\n      end\n    end\n  end\n  return l2\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI get the following error with your code: in `sort_third':\
    \ undefined method `each' for nil:NilClass (NoMethodError)\n<|/ c |>\n<| c |>\n\
    Oops, yeah, forgot that `sort` returns an array.\n<|/ c |>\n<| a tags=sorting,ruby\
    \ |>\nHere is a solution using partition (available since Ruby 2.4). It works\
    \ by partitioning the array into two halves based on the condition of the current\
    \ element. If the current element is a multiple of three, the second half is empty\
    \ and contains all the other elements, except those that are a multiple of three.\
    \ Otherwise, the second half contains all the elements that are multiples of three.\n\
    <code>", "  return l.sort.group_by(&:even?).map {|k,v| v.sort.map {|j| j.odd?\
    \ ? j : (j+2)}}\nend", "    l.each_with_index do |value, index|\n        if index\
    \ % 3 == 0\n            l[index] = value\n        end\n    end\n    l\nend", " \
    \ l.sort\n  n = l.size\n  (l.size / 3).times{ l.insert(l[n-1],l[n-1]) }\n  l\n\
    end", "  l3 = []\n  for i in l\n    if i % 3 == 0\n      l3 << i\n    end\n  end\n\
    \  l3.sort!\n  return l3\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\"`l' is\
    \ identical to l in the indicies that are not divisible by three, while its values\
    \ at the indicies that are divisible by three are equal\" -- this is just not\
    \ true. You need to add an extra step to sort the list.\n<|/ c |>\n<| c |>\nI\
    \ see that you are new to Stack Overflow. If this or any answer has solved your\
    \ question please consider [accepting it](http://meta.stackexchange.com/q/5234/179419)\
    \ by clicking the check-mark. This indicates to the wider community that you've\
    \ found a solution and gives some reputation to both the answerer and yourself.\
    \ There is no obligation to do this.\n<|/ c |>\n<| a dscore=1 |>\nA possible approach\
    \ using Enumerable#each_cons:\n<code>\n[1,2,3,4,5,6,7,8].each_cons(3).to_a.map(&:sort).map(&:join)",
  "\tl' =\n\tif l == []\n\t\tl'\n\telse\n\t\tl.sort\n\t\t[l[0], l[l[0] % 3].dup, \n\
    \t\t\tl[l[l[0] % 3] * 2].dup, \n\t\t\tl[l[l[0] % 3] * 2 + 1].dup].sort.reverse_each{|e|\
    \ e % 3 == 0}\n\t\tl'\n\tend\nend\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,5,1,8,3].sort.inspect)\nputs sort_third([2,5,1,8,3].sort.inspect)\n\
    puts sort_third([2,", "  l.sort!\n  l.each_with_index do |e, i|\n    next if i%3\
    \ == 0\n    l[i] = l[i]*i\n  end\n  l\nend", "  l3 = []\n  l.each do |l3|\n  \
    \  for i in 0..l.length\n      if (i % 3 == 0)\n        l3 << l[i]\n      end\n\
    \    end\n  end\n  return l3\nend\n</code>\n<|/ a tags=ruby,arrays,sorting dscore=0\
    \ |>\n<| c |>\nYour code is fine as far as I can see. However, you still do some\
    \ unnecessary calculations, for example `(0...l.length)` - this is exactly what\
    \ `each` does, so your code is equivalent to `l.each` - just shorter and less\
    \ readable. Also, `sort_by` returns a new array, so you don't need to return it\
    \ - just use it as it is.\n<|/ c |>\n<| c |>\nI agree with you. I will edit this\
    \ when I am back at my PC.\n<|/ c |>\n<| a |>\nThis should work using each_with_index.\n\
    <code>\narray1 = [3, 5, 3, 2]\narray2 = [1, 9, 0, 4]", "  l.each do |i|\n    j\
    \ = i - 1\n    while j > 0 and l[j] % 3 == 0\n      l[j], l[j - 1] = l[j - 1],\
    \ l[j]\n      j -= 1\n    end\n  end\n  l\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nGood job, but this doesn't answer the OP's question: _\"I do not want\
    \ to sort the array but I want to sort by the values after the first three indexes\
    \ of the array\"_\n<|/ c |>\n<| a tags=ruby |>\nYou could use Enumerable#sort_by\
    \ with a lambda. For example:\n<code>\narr = [\"1\", \"2\", \"3\", \"4\", \"5\"\
    , \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\
    \ \"16\", \"17\", \"18\", \"19\"]\narr.sort_by{|v| v if (v % 3) != 0}", "  l1\
    \ = l[1..-1]\n  l2 = l[1..-1]\n  l3 = l[1..-1]\n  l4 = l[1..-1]\n  l5 = l[1..-1]\n\
    \  l6 = l[1..-1]\n  l7 = l[1..-1]\n  l8 = l[1..-1]\n  l9 = l[1..-1]\n  l10 = l[1..-1]\n\
    \  l11 = l[1..-1]\n  l12 = l[1..-1]\n  l13 = l[1..-1]\n  l14 = l[1..-1]\n  l15\
    \ = l[1..-1]\n  l16 = l[1..-1]\n  l17 = l[1..-1]\n  l18 = l[1..-1]\n  l19 = l[1..-1]\n\
    \  l20 = l[1..-1]\n  l21 = l[1..-1]\n  l22 = l[1..-1]\n  l23 = l[1..-1]\n  l24\
    \ = l[1..-1]\n  l25 = l[1..-1]\n  l26 = l[1..-1]\n  l27 = l[1..-1]\n  l28 = l[1..-1]\n\
    \  l29 = l[1..-1]\n  l30 = l[1..-1]\n  l31 = l[1..-1]\n  l32 = l[1..-1]\n  l33\
    \ = l[1..-1]\n  l34 = l[1..-1]\n  l35 = l[1..-1]\n  l36 = l[1..-1]\n  l37 = l[1..-1]\n\
    \  l38 = l[1..-1]\n  l39 = l[1..-1]\n  l40 = l[1..-1]\n  l41 = l[1..-1]\n  l42\
    \ = l[1..-1]\n  l43 = l[1..-1]\n  l44 = l[1..-1]\n  l45 = l[1..-1]\n  l46 = l[1..-1]\n\
    \  l47 = l[1..-1]\n  l48 = l[1..-1]\n  l49 = l[1..-1]\n  l50 = l[1..-1]\n  l51\
    \ = l[1..-1]\n  l52 = l[1..-1]\n  l53 = ", "    l.sort!\n    l2 = l\n    i = 0\n\
    \    while(i < l.length )\n        idx = l.index( l[i], i + 1 )\n        if( idx\
    \ % 3 != 0 )\n            l2[i] = l[i]\n        end\n        i += 3\n    end\n\
    \    return l2\nend", "  l' =  []\n  l'.push(l[0])\n  l'.push(l[0])\n  l'.push(l[0])\n\
    \  for i in 1..(l.length-1)\n    three = l[i]+l[i+1]\n    three = three*3\n  \
    \  two = l[i]+l[i+1]\n    two = two*2\n    l'.push(three)\n    l'.push(two)\n\
    \  end\n  l'.push(nil)\n  l'.push(nil)\n  l'.push(nil)\n  return l'\nend", " \
    \ l.reduce(:+)\nend", "    l.sort.with_index do |el, i|\n        unless i % 3\
    \ == 0\n            l.delete_at(i)\n        elsif i % 3 == 1\n            l.insert(i,\
    \ l[i])\n        else\n            l.insert(i, l[i])\n        end\n    end\n \
    \   l\nend", "  l = l.sort\n  l[l/3] += 1\n  l\nend", "  l2 = l.clone\n  l2.sort!",
  "  third = l.select { |x| x % 3 == 0 }\n  third.each_with_index { |x, i| l[i] =\
    \ l[x] }\n  third.sort!\n  third\nend", "    l = l.sort {|a,b| b}\n    l.reject\
    \ {|a| a % 3 == 0}\nend", "    l.each_with_index do |el, i|\n        if i % 3\
    \ == 0\n            l[i] = l[i+1]\n        end\n    end\nend\n</code>\nTesting\
    \ the code:\n<code>\nsort_third((1, 2, 3, 4, 4, 5))", "  # Write your code here\n\
    \  third_indicies = []\n  thirds = []\n  for i in l\n    third_indicies << i if\
    \ i.modulo(3) == 0 \n  end\n  third_indicies.each do |i| \n    thirds << l[third_indicies.index(i)]\n\
    \  end\n  thirds\nend\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a |>\nI guess\
    \ something like this should be better:\n<code>", "    l.sort.with_index do |idx,\
    \ val|\n        if val % 3 == 0\n            l.insert idx, val\n        end\n\
    \    end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI appreciate that, but can\
    \ you explain to me how it works? It's quite difficult to understand what exactly\
    \ it's doing. I'm pretty new to programming and I'm not exactly sure how this\
    \ works.\n<|/ c |>\n<| c |>\nI edited my answer to add some explanation.  Does\
    \ that help?\n<|/ c |>\n<| c |>\nThanks for the explanation but I'm still not\
    \ understanding what is going on. I understand the sort_third method but I don't\
    \ really understand what the code is doing. I guess I'm just not understanding\
    \ what exactly is happening in the sort method, especially the part in the with_index\
    \ method in the sort_third method.\n<|/ c |>\n<| c |>\nI added some explanation.\
    \  Hope it helps!\n<|/ c |>\n<| c |>\nOh okay, it helps! I understand now! Thank\
    \ you so much!\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nHere's another way:\n<code>\n\
    l = [1, 6, 4, 2, 1, 7, 8, 9]", "    l.each do |i|\n        # Only if i divided\
    \ by three, do the sorting of l with its values\n        if (i % 3 == 0)\n   \
    \         l.delete_at(i)\n            l.insert(i, l.delete_at(i))\n          \
    \  l.insert(i, l.delete_at(i))\n            l.insert(i, l.delete_at(i))\n    \
    \    end\n    end\n    return l\nend\n</code>\n<|/ a |>\n<| c |>\nThis assumes\
    \ that the input array is already sorted.  If not, please post a sample of the\
    \ data as well.\n<|/ c |>\n<| c |>\n, that is the entire point of the OP in the\
    \ comments section.  They want to sort the array in three ways so I suggested\
    \ a way of doing it.\n<|/ c |>\n<| c |>\nWell, they didn't specify what they wanted\
    \ in terms that would help us.  They asked for three ways so that was the only\
    \ thing that came to mind.  I hope that is what they were after.\n<|/ c |>\n<|\
    \ c |>\n, no offense, but that doesn't make sense to me.  If the input is already\
    \ sorted, why are you sorting it three times?  If they're not sorted, why are\
    \ you sorting three times?  Also, are you sure you want to use 3 loops instead\
    \ of just one?  You don't seem to be making any use of any of the elements of\
    \ `l` other than counting them.\n<|/ c |>\n<| c |>\n, that would be a waste of\
    \ time and space.  The OP said that they want to sort it in three ways.  I suggested\
    \ three ways.  I am not going to waste time or space sorting it three times. \
    \ I am going to only use one loop.  And I am not going to use any elements of\
    \ the array other than counting the elements.\n<|/ c |>\n<| a dscore=1 |>\nThis\
    \ is a little simpler version of Praveen's solution.  It uses only a single loop\
    \ to count the number of values that are divisible by three, and uses those to\
    \ create a list of 3 sets of indices.  It then sorts the three sets according\
    \ to the number of values within each set using sort_by, which sorts an array\
    \ in descending order.\n<code>", "  l2 = l.clone\n  for i in 0..(l.length-1)\n\
    \    if l[i].zero?\n      l2.delete_at(i)\n    else\n      l2.delete_at(i)\n \
    \     l2.delete_at(i+1)\n    end\n  end\n  for i in 0..(l.length-1)\n    if l2.length\
    \ != l.length\n      l = l.clone\n      l2 = l2.clone\n    end\n    l.delete_at(i+1)\n\
    \    l.delete_at(i)\n    l.insert(i, l2.delete_at(i))\n  end\n  l\nend", "  l.each_with_index.inject([])\
    \ do |l,(l, i)|\n    if i % 3 == 0 && l.include?(i)\n      l << i\n    elsif i\
    \ % 3 != 0 && l.include?(i)\n      l << i << l.index(i)\n    end\n    l\n  end\n\
    end", "  l2 = l.dup\n  l2.shuffle!\n  l2.slice!(0,3)\n  l2.uniq!\n  l2.sort_by!{|a|\
    \ l2.index(a)}\nend\n</code>\n<|/ a tags=ruby,sorting,algorithm,arrays dscore=0\
    \ |>\n<| a tags=ruby,sorting,algorithm,arrays |>\nI would do it like this:\n<code>",
  "  # return l if the length of the list is 1\n  l.length ==1 || return l\n  # if\
    \ the first element of the list is an even number then that means its third index\
    \ is also an even number\n  # so remove the first element\n  even = l.delete_at(0)\n\
    \  # initialize a variable 'k' as an integer equal to 0\n  k = 0\n  # initialize\
    \ a variable 'l3' as a list equal to that of the list l\n  l3 = even.dup\n  #\
    \ while k < 3\n  while k < even.length\n    # for each element of the list l3\
    \ that is not divisible by 3 increment k\n    # while k < 3\n    while k <even.length\n\
    \      # for each element in l that is not divisible by 3 increment k\n      while\
    \ k < even.length\n        # if l3[k] % 3 != 0 then l3[k] = l3[k]+1\n        if\
    \ even[k].modulo_three!=0\n          # increment k\n          k = k + 1\n    \
    \    end\n      end\n      # decrement k\n      k = k - 1\n    end\n    # add\
    \ the third element to the list l3\n    l3 << even[k]\n    # increment k\n   \
    \ k = k + 1\n  end\n  # return l3\n  return l3\nend", "  a = []\n  i = 0\n  while\
    \ i < l.size\n    index = i\n    i = i+1\n    if l[i] % 3 == 0 && i != l.size\n\
    \      while l[index] % 3 != 0\n        index = index + 1\n      end\n      a.push(l[i],\
    \ l[index])\n    end\n  end\n  a\nend", "  l2 = []\n  for i in l\n    if i % 3\
    \ == 0\n      l2.push(l[i])\n    else\n      l2.push(i)\n  end\n  sorted = l2.sort\n\
    \  return sorted\nend", "  l.map! {|x| x.to_i}\n  sorted = l.sort\n  l.map! {|x|\
    \ x.to_i}\n  index = 0\n  l.each_with_index {|x, i| l[i] = l[i].to_i + x}\n  sorted\
    \ = sorted.map! {|x| x.to_i}\n  index = 0\n  sorted.each_with_index {|x, i| l[i]\
    \ = l[i].to_i + x}\n  l\nend", "  result = []\n  l.each_with_index do |n,i|\n\
    \    if n%3 == 0\n      result << n\n      result << l[i]\n    end\n  end\n  result\n\
    end", "  l3 = []\n  l4 = []\n  for i in (0...(l.length-1))\n    l4 << l[i]\n \
    \ end\n  l4.sort!\n  for i in (0...(l.length-1))\n    if l[i] % 3 == 0 && l[i]\
    \ != l[i+1]\n      l3 << l[i]\n    end\n  end\n  l3.sort!\n  l3.zip(l4)\nend",
  "  n = 0\n  while n < l.length\n    begin\n      l[n], l[n+1] = l[n+1], l[n]\n \
    \     n += 1\n    end until n % 3 == 0\n  end\n  l\nend", "  third_index = []\n\
    \  \n  for index in 0...l.length-1\n    if l[index] % 3 == 0\n      third_index\
    \ << index\n    end\n  end", "  l.each_with_index.map do |a, i|\n    if i % 3\
    \ == 0\n      a\n    else\n      l[i] = l[i + 1]\n      l[i + 1]\n    end\n  end.sort\n\
    end", "  # Define an empty list called third.\n  third = []", "  l2 = []\n  l2.concat(l.dup)\n\
    \  \n  l2.sort_by!{|e| e % 3 }\n  l2.uniq!\n  l2.sort\nend", "  l.map! { |x| x.to_i\
    \ }\n  indicies = l.select { |x| x.to_i % 3 == 0 }\n  indicies.sort.map! { |x|\
    \ indicies.index(x) }\n  indicies.each { |x| l[indicies[x]] = l[x] }\n  l\nend",
  "    middle_index = l.length / 2\n    first_half = l[0...middle_index]\n    second_half\
    \ = l[middle_index..-1]\n    l' = first_half + second_half\n    index_of_third_value\
    \ = 0\n    index_of_third_value_after_first_half = 0\n    index_of_third_value_after_second_half\
    \ = 0\n    index_of_third_value_after_first_half_plus_one = middle_index\n   \
    \ index_of_third_value_after_second_half_plus_one = middle_index\n    while index_of_third_value\
    \ < first_half.length\n        if l'[index_of_third_value] == l[0]\n         \
    \   index_of_third_value += 1\n            continue\n        else\n          \
    \  index_of_third_value = index_of_third_value_after_first_half + first_half.length\n\
    \            break\n    end\n    while index_of_third_value < second_half.length\n\
    \        if l'[index_of_third_value] == l[middle_index]\n            index_of_third_value\
    \ += 1\n            continue\n        else\n            index_of_third_value =\
    \ index_of_third_value_after_second_half + second_half.length\n            break\n\
    \    end\n    while index_of_third_value < first_half.length + second_half.length\n\
    \        if l'[index_of_third_value] == l[first_half.length + second_half.length\
    \ + 1]\n            index_of_third_value += 1\n            continue\n        else\n\
    \            index_of_third_value = index_of_third_value_after_first_half_plus_one\
    \ + first_half.length\n            break\n        end\n    end\n    while index_of_third_value\
    \ < second_half.length + first_half.length\n        if l'[index_of_third_value]\
    \ == l[second_half.length + first_half.length + 1]\n            index_of_third_value\
    \ += 1\n            continue\n        else\n            index_of_third_value =\
    \ index_of_third_value_after_second_half_plus_one + second_half.length\n     \
    \       break\n        end\n    end\n    while index_of_third_value < l.length\n\
    \        if l'[index_of_third_value] == l[0]\n            index_of_third_value\
    \ += 1\n            continue\n        else\n            index_of_third_value =\
    \ index_of_third_value_after_first_half + first_half.length\n            break\n\
    \        end\n    end\n    while index_of_third_value < l.length + second_half.length\n\
    \        if l'[index_of_third_value] == l[l.length + second_half.length + 1]\n\
    \            index_of_third_value += 1\n            continue\n        else\n \
    \           index_of_third_value = index_of_third_value_after_second_half_plus_one\
    \ + second_half.length\n            break\n        end\n    end\n    while index_of_third_value\
    \ < l.length + first_half.length + second_half.length\n        if l'[index_of_third_value]\
    \ == l[l.length + first_half.", "  l2 = []\n  l2.map! do |e|\n    if e.odd?\n\
    \      l2.push (e+1)\n    else\n      l2.push(e)\n    end\n  end\n  l2.sort! #Sort\
    \ l2 in place\n  l2.map! do |e|\n    if e % 3 == 0\n      e\n    else\n      e+1\n\
    \    end\n  end\n  l2\nend", "  l = [3, *l]\n  l.sort!\n  l = [l[0], *l]\nend",
  "  # create an array of all the indicies of the list\n  indicies = (0...l.length).to_a\n\
    \  # create an array with two empty lists\n  indicies_and_values = [[], []]\n\
    \  # loop through the indicies of the list\n  indicies.each do |i|\n    # if i\
    \ is not divisible by three, copy the indicies and values from the list at i\n\
    \    if i % 3 != 0\n      indicies_and_values[0].push(indicies[i])\n      indicies_and_values[1].push(l[i])\n\
    \    # if i is divisible by three, copy the indicies and values from the list\
    \ at i\n    else\n      indicies_and_values[0].push(indicies[i])\n      indicies_and_values[1].push(l[i])\n\
    \      # if the indicies are already equal, continue\n      if indicies_and_values[0].include?(indicies[i])\n\
    \        indicies_and_values[0].shift\n        indicies_and_values[1].shift\n\
    \      end\n    end\n  end\n  # return the indicies and values array\n  return\
    \ indicies_and_values\nend", "  sorted_l = []\n  \n  for i in 0...l.count-1\n\
    \    if l[i] % 3 == 0\n      sorted_l.push l[i]\n    end\n  end\n  \n  for i in\
    \ 0...l.count-1\n    if l[i] % 3 == 0\n      sorted_l.push l[i]\n    end\n  end\n\
    \  \n  for i in 0...l.count-1\n    if l[i] % 3 != 0\n      sorted_l.push l[i]\n\
    \    end\n  end\n  \n  return sorted_l\nend", "  l.map! {|x| x.even? ? x[1..-1].to_i\
    \ : x[1..-1].to_i} # sort by even indicies and then sort by even values within\
    \ the indicies\n  l.sort_by! { |x| x[1..-1].to_i }\n  l\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nHmm, I don't think this answers my question or my question is not\
    \ clear. Can you rephrase?\n<|/ c |>\n<| c |>\nYes, I understood what you mean\
    \ now, thanks.  I'm working on it.\n<|/ c |>\n<| c |>\nIt should work now.  It\
    \ should be much faster.  Let me know how it goes.\n<|/ c |>\n<| c |>\nI thought\
    \ my original method would have worked, but I was wrong.  I updated my answer\
    \ to include a solution that I think will work.\n<|/ c |>\n<| c |>\nI still get\
    \ errors with the code you gave me. My list has about 700 values in it. I am now\
    \ getting \"no block given (yield)\"\n<|/ c |>\n<| a dscore=0 |>\nFor a list like\n\
    <code>\na = [\"01234\", \"12334\", \"23423\", \"2345\", \"4534\"]\n</code>\nto\
    \ become this\n<code>\na = [[\"01234\",\"12334\"], [\"23423\",\"2345\"], [\"4534\"\
    ]]\n</code>\nyou can do this\n<code>\na.reduce([]) do |ary, string|\n  ary.unshift(string.split('').reverse)\n\
    end\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm |>\nThis\
    \ works:\n<code>\na = [\"01234\", \"12334\", \"23423\", \"2345\", \"4534\"]\n\
    a.map{|i| i.scan(/(?<=[0-9])(?=[0-9])/).map{|s| s.reverse}}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\n`a.map {|i| i.scan(/(?<=[0-9])(?=[0-9])/).map {|s| s.reverse}}`\
    \ works too, if you reverse `s` first so you end up with `s.reverse.reverse`\n\
    <|/ c |>\n<| a tags=ruby,algorithm |>\nAnother approach:\n<code>\na = [\"01234\"\
    , \"12334\", \"23423\", \"2345\", \"4534\"]", "  l.each_with_index do |i, index|\n\
    \    next if i == 0 || i % 3 == 0\n    l.delete_at(index) unless i % 3 == 0\n\
    \  end\n  l.sort!\n  l\nend", "  l'.sort.each_with_index do |value,index|\n  \
    \  l[index] = value if index % 3 == 0\n  end\n  l'\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI understand what you are saying, but this seems like it would\
    \ just be more work than just sorting it in place and skipping the sorting step\
    \ altogether.\n<|/ c |>\n<| c |>\nI think you are right. But you were on the right\
    \ track. I didn't know Ruby could modify array elements while iterating over them.\
    \ I found an example [here](http://stackoverflow.com/questions/10671768/how-to-modify-arrays-while-iterating-over-them-in-ruby).\
    \ Ruby's docs also state that you can modify an array while iterating over it.\
    \ Does this mean that you could use this method to sort the array in place without\
    \ rewriting the entire array in place by using a temporary variable?\n<|/ c |>\n\
    <| c |>\nYes, I see that my example was incorrect and have edited my answer to\
    \ correct it. I am sorry for the confusion, my original answer was written without\
    \ thinking about the fact that Ruby can modify array elements while iterating\
    \ over them, and that your answer implied that Ruby couldn't. I would have thought\
    \ that modifying elements of an array while iterating over it would be a pretty\
    \ common task in many languages.\n<|/ c |>\n<| c |>\nThis answer does indeed modify\
    \ array elements while iterating over them. As far as I know, that's one of the\
    \ most used operations in Ruby.\n<|/ c |>\n<| c |>\n: yes, modifying the elements\
    \ of an array while iterating over it is a very common task. Ruby is one of those\
    \ languages that has it very often, since it is the standard language for almost\
    \ everything in programming. However, it has a few quirks in its array handling\
    \ that is often problematic when using Ruby as a replacement for most other languages,\
    \ and I guess that's what made this answer pop in first in search results. Your\
    \ answer is clearly superior for most people.\n<|/ c |>\n<| a |>\nI really like\
    \ Ruby's Array class, but I also wanted to keep my own version around for educational\
    \ purposes:\n<code>", "    l.each_with_index do |e1, i1|\n        l.each_with_index\
    \ do |e2, i2|\n            if ((i1 % 3 == 0) && (i2 % 3 == 0)) then\n        \
    \        l[i1] = e1.dup\n                l[i2] = e2.dup\n            end\n   \
    \     end\n    end\nend", "  l = l.dup\n  l.sort do |x, y|\n    divisible_by_three\
    \ = (x % 3 == 0 && y % 3 == 0) || (y % 3 == 0 && x % 3 == 0)\n    divisible_by_three_y\
    \ = (y % 3 == 0 && x % 3 == 0) || (x % 3 == 0 && y % 3 == 0)\n    if divisible_by_three_y\n\
    \      -1\n    elsif divisible_by_three\n      0\n    else\n      1\n    end\n\
    \  end\nend", "  l.sort{|a,b| b if a % 3 != 0 && a % 3 != 1 } \nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhile `sort` is convenient, I think your method has\
    \ a `O(nlogn)` runtime where `O(n)` would be better.\n<|/ c |>\n<| c |>\nThanks,\
    \ you were right, my answer was not optimal. I updated my answer.\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\nA quick and dirty way to do it, assuming you know the\
    \ index position you want to sort by:\n<code>\na = [3, 7, 2, 3, 1, 7, 1, 5, 9,\
    \ 3]\na.each_with_index.sort {|x,y| x.eql?(y) ? (x[a.index(y)]<=>y[xa.index(y)])\
    \ : y<=>x}.map{|x| x.last}\n=> [1, 5, 9, 3, 7, 3, 2, 3, 1]\n</code>\nTo make it\
    \ more robust, you could use the following method, which checks if the value at\
    \ index y is equal to the value at index x:\n<code>", "    puts \"#{l}\"\n   \
    \ puts \"#{l} is #{l.length}\"\n    puts \"#{l} is #{l}\"\n    # print \"#{l}\
    \ is #{l.length}\"\n    puts \"\"\n    # puts \"#{l.inspect}\"\n    # puts \"\
    #{l.length}\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n  \
    \  puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\n\
    \    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\
    \n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n\
    \    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\
    \n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\
    \n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n\
    \    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\
    \n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\
    \n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n\
    \    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\
    \n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\
    \n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n\
    \    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\
    \n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\
    \n    puts \"\"\n    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n\
    \    puts \"#{l}\"\n    puts \"#{l.length}\"\n    puts \"\"\n    puts \"#{l}\"\
    \n    puts \"", "  l.each_with_index do |x, i|\n    if i % 3 == 0\n      l.delete_at(i)\n\
    \    else\n      l[i] = x\n    end\n  end\n  l\nend", "  result = []\n  l.each_with_index\
    \ do |el, i|\n    if (i % 3 == 0)\n      result.push(el)\n    else\n      result[i]\
    \ << el\n    end\n  end\n  result\nend\n</code>\nSo the test looks like\n<code>\n\
    l = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\np sort_third(l)\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nI like your use of inject. Very nice.\n<|/ c |>\n<| c |>\nGreat\
    \ answer, but could you explain the use of 'sort' here?\n<|/ c |>\n<| c |>\n`inject`\
    \ takes a \"memo\" variable, and each time the block returns a value, it \"memoizes\"\
    \ the result into the memo. The `sort` method makes sure that the memo contains\
    \ the elements sorted, and that they are in the same order as the original array.\
    \ `each_with_index` takes both the array and the memo, and returns the element\
    \ and the index as an array. This array is then used to modify the memo by modifying\
    \ the values at the indicies that are divisible by three to include the corresponding\
    \ elements in the original array.\n<|/ c |>\n<| c |>\nThis code looks great, but\
    \ I see a problem when I run it. It's sorting 'g' to the last position and 'f'\
    \ to the last position. Also, it prints out every letter twice.\n<|/ c |>\n<|\
    \ c |>\nOops, sorry about that. `each_with_index` takes both the array and the\
    \ memo, and returns the element and the index as an array. By swapping those two\
    \ things, I was able to get the sort working. I also removed the `inject` method\
    \ and used `each_with_index` instead, which should be cleaner.\n<|/ c |>\n<| a\
    \ |>\nOne more way to do it\n<code>", "  l2 = []\n  l3 = []\n  l4 = []\n  \n \
    \ for i in l\n    l2 << i\n  end\n  l2.uniq.sort!\n  \n  for i in l2\n    l3 <<\
    \ i\n  end\n  l3.uniq.sort!\n  \n  for i in l3\n    l4 << i\n  end\n  l4.uniq.sort!",
  "  l'.sort! # sort by the values of the indices that are divisible by three\n  l''.each\
    \ {|i| l''[i] = l[i]%3 if i.odd? }\n  l''\nend", "    \n    # Write your code\
    \ here\n    lenght = l.length\n    \n    # Step 1: Get an array l1' that contains\
    \ the indicies of the elements of l, but unsorted\n    \n    \n    \n    # Step\
    \ 2: Get an array l2 that contains the indicies of the elements of l, but unsorted\n\
    \    \n    \n    # Step 3: Get an array l3 that contains the indicies of the elements\
    \ of l, but unsorted\n    \n    \n    # Step 4: Sort l3\n    \n    \n    # Step\
    \ 5: Reverse l3, and append it to l1'\n    \n    \n    # Step 6: Reverse l1, and\
    \ append it to l'\n    \n    \n    # Step 7: Return l\nend\n</code>\nTests\n<code>\n\
    test_sorting_a = [8, 1, 3, 5, 2, 6, 4]\nassert_equals(sort_third(test_sorting_a),\
    \ [1, 3, 8, 5, 6, 2, 4])\nassert_equals(sort_third(test_sorting_a), [1, 3, 8,\
    \ 5, 6, 2, 4])", "  l1 = []\n  l2 = []\n  \n  l.each do | value |\n    if value\
    \ % 3 != 0\n      l1.push(value)\n    else\n      l2.push(value)\n    end\n  end\n\
    \  \n  l1.each do | value |\n    l1.insert(l1.find_index(value), value)\n    l1.delete(value)\n\
    \  end\n  \n  l2.each do | value |\n    l2.insert(l2.find_index(value), value)\n\
    \    l2.delete(value)\n  end\n  \n  l1 + l2\nend\n  ", "  lt = l.dup\n  lt.sort\n\
    \  l.clear\n  l.push(*lt[0..-1])\n  l.push(*lt[1..-1])\n  l.push(*lt[2..-1])\n\
    end", "    l.each_with_index do |e, i|\n        if i > (l - 3) % 3 && i < (l -\
    \ 3) % 3\n            l.insert(i, l)\n        end\n    end\n    return l\nend\n\
    </code>\n<|/ a |>\n<| a |>\nI'm pretty sure this is O(n^2), but I'd like to see\
    \ other answers with better complexity. \n<code>", "  third_indicies = indicies_of_divisible(l)\n\
    \  third_indicies.each_with_index do |x,i|\n    l[x] = nil\n  end\n  third_indicies.each\
    \ do |x|\n    l.sort_by { |y| y[x] }\n  end\nend", "  l2 = []\n  l.each do |i|\n\
    \    if i.is_a? Array\n      i2 = sort_third(i)\n      l2.push(i2)\n    else\n\
    \      if i.modulo(3) == 0\n        l2.push(i)\n      end\n    end\n  end\n  l2.each\
    \ do |i|\n    if i.is_a? Array\n      i2 = sort_third(i)\n      l2.push(i2)\n\
    \    end\n  end\n  return l2\nend", "  result = []\n  index = 0\n  while index\
    \ < l.length\n    if (l[index] % 3 == 0)\n      result.push(l[index])\n      index\
    \ += 1\n    else\n      while index >= 0\n        index += 1\n        if (l[index]\
    \ % 3 == 0)\n          result.push(l[index])\n          break\n      end\n   \
    \ end\n  end\n  return result\nend", "    l = l.sort\n    i = 0\n    while i <\
    \ l.length\n        if i % 3 == 0\n            l[i] = l[i] + l[i]\n        end\n\
    \        i += 1\n    end\n    return l\nend", "  l' =  []\n  l = l.sort\n  l.each_with_index\
    \ {|e,i| l' << [e.clone,i] if i % 3 == 0}\n  l'.sort.flatten\nend", "    l.each_with_index\
    \ {|a,i|\n        if i % 3 == 0\n            l.delete_at(i)\n            l.insert(i,\
    \ a) \n        end\n    }\n    return l \nend\n</code>\nUsing these functions,\
    \ we get the desired result for the sorted list [1,2,3,7,8,9,10,12,13,14,15,16,17,18]:\n\
    <code>\n[1,2,3,4,7,8,9,10,12,13,14,15,16,17,18]\n</code>\nNow for the second list:\n\
    <code>\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n</code>\nThe code is the\
    \ same\n<code>\nsort_third(list)\n</code>\n<|/ a tags=ruby,sorting,arrays dscore=2\
    \ |>\n<| c |>\nI'm confused why you think he needs any sorting here.\n<|/ c |>\n\
    <| c |>\nThe OP says _\"the indicies that are not divisible by three, while their\
    \ values at the indicies that are divisible by three are equal\"_\n<|/ c |>\n\
    <| c |>\nYes, that's what I thought as well. Just wanted to make sure there was\
    \ an explicit mention that he wanted to do something like that. Just wanted to\
    \ point out the possibility.\n<|/ c |>\n<| c |>\nThanks for your answer, but this\
    \ does not sort the second list. The first list should be sorted, but the second\
    \ list should not.\n<|/ c |>\n<| c |>\nThe OP said _\"...while their values at\
    \ the indicies that are divisible by three are equal\"_\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby,sorting,arrays |>\n<code>", "    l = l + [0]*(len(l)-1)\n    l[l.index(l[l.index(0)])\
    \ % 3] = l[l.index(l[l.index(0)]) % 3] + l[l.index(l[l.index(1)]) % 3]\n    l[l.index(l[l.index(0)])\
    \ % 3] = l[l.index(l[l.index(0)]) % 3] + (l[l.index(l[l.index(1)]) % 3] + l[l.index(l[l.index(0)])\
    \ % 3])\n    l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)]) % 3] + (l[l.index(l[l.index(1)])\
    \ % 3] + l[l.index(l[l.index(2)]) % 3])\n    l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)])\
    \ % 3] + (l[l.index(l[l.index(1)]) % 3] + l[l.index(l[l.index(2)]) % 3])\n   \
    \ l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)]) % 3] + (l[l.index(l[l.index(1)])\
    \ % 3] + l[l.index(l[l.index(3)]) % 3])\n    l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)])\
    \ % 3] + (l[l.index(l[l.index(3)]) % 3] + l[l.index(l[l.index(1)]) % 3])\n   \
    \ l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)]) % 3] + (l[l.index(l[l.index(3)])\
    \ % 3] + l[l.index(l[l.index(2)]) % 3])\n    l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)])\
    \ % 3] + (l[l.index(l[l.index(3)]) % 3] + l[l.index(l[l.index(2)]) % 3])\n   \
    \ l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)]) % 3] + (l[l.index(l[l.index(3)])\
    \ % 3] + l[l.index(l[l.index(3)]) % 3])\n    l[l.index(l[l.index(0)]) % 3] = l[l.index(l[l.index(0)])\
    \ % 3] + (l[l.index(l[l.index(3)]) % 3] + l[l.index(l[l.index(2)]) % 3])\n   \
    \ l[l.index(l", "    l.sort\n    l.each_with_index do |_, index|\n        l[index]\
    \ = (l[index] % 3) == 0 ? l[index] : l[index].next\n    end\n    l.sort\nend",
  "  l.each_with_index do |e,i|\n    if i % 3 == 0\n      l[i] = l.delete_at(i)\n\
    \    end\n  end\n  l\nend\n</code>\nNow we get the desired output, namely the\
    \ sorted list:\n<code>\n[3, 5, 7, 8, 1, 2, 4, 6, 9, 11]\n</code>\n<|/ a |>\n<|\
    \ c |>\n`sort_by { |x| x % 3 }` does not sort by divisibility by 3, but by an\
    \ anonymous block that returns the remainder of dividing `x` by 3. So it doesn't\
    \ work when you want to sort by divisibility by three. BTW, you don't need to\
    \ write `l.each_with_index { |e| ... }` since `each_with_index` takes an argument\
    \ `&block` that is automatically applied to each element in the array.\n<|/ c\
    \ |>\n<| c |>\nMy bad, I didn't realize that OP wanted to sort by divisibility\
    \ by three.\n<|/ c |>\n<| c |>\nYes, I just noticed that too. Thanks for your\
    \ answer.\n<|/ c |>\n<| c |>\nI added a solution for sorting the list by divisibility\
    \ by three.\n<|/ c |>\n<| c |>\nYour `sort_third` function can be written in a\
    \ simpler way as `sort_by(&:itself).partition(&:odd?).map(&:sort)`. Avoids the\
    \ need for explicitly sorting the `l` array in the block\n<|/ c |>\n<| a tags=ruby,sorting\
    \ |>\nIf by divisible by three you mean an even number (and not a multiple of\
    \ three), then you can do this with a single sort, which does an efficient sort\
    \ based on the modulus of the index and the element value.  You need sort so that\
    \ the same element has equal values with the same modulus (so the order is maintained).\n\
    The modulus is given by the remainder of dividing the index by 3.  If the index\
    \ is even, its remainder is 0, and if it is odd, its remainder is 1.\n<code>\n\
    a = [3, 6, 5, 7, 8, 1, 2, 4, 9, 11]\na.sort{ |x,y| a[x] % 3 == a[y] % 3 }", " \
    \ \n  \n  for i in [1..l.size]\n    # find the index of the corresponding indicies\
    \ of l that are divisible by three\n    divisible = l[i..l.size].select{|x| x\
    \ % 3 == 0}.to_a\n    \n    # if there are no corresponding indicies of l that\
    \ are divisible by three, then that indicies is removed from the list\n    if\
    \ divisible.size == 0\n      l.remove(i)\n    else\n      \n      # take the values\
    \ at the indicies of l that are divisible by three\n      three_three = divisible.sort\n\
    \      # if the value of the indicies of l that are divisible by three is not\
    \ equal to the indicies of the indicies of l\n      #  whose values are divisible\
    \ by three in that order, then that indicies is removed from the list\n      if\
    \ three_three.size != divisible.size\n        l.remove(i)\n      else\n      \
    \  l[i] = three_three\n      end\n    end\n  end\n  \n  return l\nend", "  new_list\
    \ = []\n  i = 0\n  while i < l.length\n    if (i % 3 == 0)\n      new_list <<\
    \ l[i]\n      i += 1\n    elsif (i%3 != 0)\n      new_list << l[i]\n      i +=\
    \ 1\n    end\n  end\n  return new_list\nend", "  l.sort!\n  l.reject!{|x| x%3==0}\n\
    \  l\nend\n</code>\nThis works well, except for sorting an array containing strings\
    \ (e.g., \"A\", \"B\", \"C\").  To fix this, I added the following code to the\
    \ end of the sort_third function:\n<code>\n  return l.map!{|x| x.chars}.sort\n\
    </code>\n<|/ a dscore=0 tags=sorting,ruby |>\n<| a |>\nJust for the sake of fun,\
    \ here is a way which does not modify the original array:\n<code>", "  l' =  sort_third3(l)\n\
    \  l' =  l' & sort_third3((l.length-3).times.map{|i| l[i*3] })\n  l' =  l' & sort_third3((l.length-2).times.map{|i|\
    \ l[i*3] })\n  l' =  l' & sort_third3((l.length-1).times.map{|i| l[i*3] })\n \
    \ l' =  l' & sort_third3(l.times.map{|i| l[i*3] })\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-3).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-2).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-1).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-2).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-3).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-1).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-1).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-2).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-3).times.map{|i| l[i*3] }\n  l' =  l' & sort_third3(l.times.map{|i|\
    \ l[i*3] }) | (l.length-2).times.map{|i| l[i*3] }\n  ", "  l2 = []\n  for i in\
    \ l\n    if i.odd?\n      l2.push(i)\n    end\n  end\n  return l2\nend", "  l1\
    \ = []\n  l2 = []\n  l3 = []\n  for i in l\n    if i % 3 == 0\n      l3.push(i)\n\
    \    elsif i % 3 == 1\n      l2.push(i)\n    elsif i % 3 == 2\n      l1.push(i)\n\
    \    end\n  end\n  l3.concat(l1)\n  l3.concat(l2)\n  l1\nend", "  l3 = []\n  indicies\
    \ = l.select{ |i| i%3==0 }\n  indicies.each do |i|\n    i2 = l.select{ |j| j%3==0\
    \ && j!=i }\n    l3.push(i2)\n  end\n  l3.flatten!\n  l3.sort!{ |i,j| i<=j }\n\
    \  l3\nend", "  l1=[]\n  l2=[]\n  for x in l\n    if (x%3==0)\n      l2.append(x)\n\
    \    else\n      l1.append(x)\n  end\n  return l1+l2\nend", "    # l is the list\
    \ you want to sort\n    # l will have the values you want to sort\n    # l' is\
    \ the list that will have the sorted values\n    lp = [] # will store the indicies\
    \ for which l[i] and l[i+1] differ by more than three orders of magnitude\n  \
    \  # lp will contain the indicies for which l[i] and l[i+1] differ by more than\
    \ three orders of magnitude\n    # since this loop starts with i = 0\n    i =\
    \ 0\n    while i <= len(l) - 2:\n        # If l[i] and l[i+1] differ by more than\
    \ three orders of magnitude\n        if l[i] != l[i+1] and math.fabs(l[i] - l[i+1])\
    \ > 3:\n            # Append the indicies for which l[i] and l[i+1] differ by\
    \ more than three orders of magnitude\n            lp.append(i)\n            #\
    \ Set the current index to point to l[i+1]\n            i = i + 1\n        # If\
    \ l[i] and l[i+1] are equal by more than three orders of magnitude\n        elif\
    \ l[i] == l[i+1]:\n            # Set the current index to point to l[i]\n    \
    \        i = i + 1\n        # If the indicies differ by more than three orders\
    \ of magnitude and l[i] and l[i+1] are still equal\n        else:\n          \
    \  # Append l[i]\n            lp.append(l[i])\n            # Set the current index\
    \ to point to l[i+1]\n            i = i + 1\n    # Append l[i] at the end\n  \
    \  lp.append(i)\n    return lp", "    lsorted = []\n    lsorted = l[0..(l.length/3)-1]\n\
    \    lsorted = [lsorted[1], lsorted[2], lsorted[0]]\n    return lsorted\nend",
  "  l3 = []\n  l3.concat l.dup.select{ |i| i.modulo(3) == 0 }\n  l3.sort!\n  l3.concat\
    \ l.dup.select{ |i| i.modulo(3) != 0 }\n  return l3\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nI believe that Ruby has a couple of methods that will\
    \ help with this.\nIf you know the value will always be an integer, you could\
    \ use to_i to convert your strings into integers first, e.g. \"12\".to_i. \nYou\
    \ could also do to_i and %3 together, which gives you your remainder when dividing\
    \ the numbers.\n<|/ a tags=arrays,ruby |>\n<| a dscore=0 tags=arrays,ruby |>\n\
    <code>\narr = [1,2,3,\"a\",\"b\",2,3,\"c\",\"d\",2,\"e\",\"f\"]", "  l' =  l\n\
    \  l' .delete_if {|x| (x % 3 == 0)}\n  l' .sort!\n  return l'\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThe first part of this answer doesn't work.  Try running\
    \ `sort_third` on `[1,2,3]`.\n<|/ c |>\n<| c |>\nThanks, I added the missing `[]`\
    \ in the answer and it works. But this doesn't answer the question, which was\
    \ that OP was trying to implement his own version of `sort_third`. It's a good\
    \ answer, but it doesn't answer the question as stated.\n<|/ c |>\n<| c |>\nI\
    \ guess that was the problem in the first place.  The OP wants to sort, not just\
    \ remove values that aren't divisible by 3.\n<|/ c |>\n<| a |>\nFor a Ruby ninja,\
    \ here's a recursive solution, just for fun:\n<code>", "  new_list = []\n  for\
    \ i in 0..l.length\n    if i % 3 == 0\n      new_list << l[i]\n    else\n    \
    \  new_list << l[i - 1]\n    end\n  end\n  new_list\nend", "  l2 = []\n  for i\
    \ in l\n    i2 = i.dup\n    i2[-1] = 1\n    if i.last == 1\n      i2[0] = 2\n\
    \      i2 << i.first\n    else\n      i2 = [i2.first, i2.last].join\n    end\n\
    \    l2 << i2\n  end\n  l2.sort\nend", "    # sort l by last name\n    l.sort_by\
    \ { |a| a[2] }", "  l.sort!\n  l.each_with_index do |e, index|\n    even = index\n\
    \    odd = even\n    l.each { |e| odd += 1 if e % 3 == 0 }\n    l.delete_at(index)\n\
    \    l.insert(index, even, odd)\n  end\n  l\nend\n</code>\nThis code passes your\
    \ test cases:\n<code>\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"\
    ,\"10\",\"11\",\"12\"].sort.should == sort_third([\"1\",\"2\",\"3\",\"4\",\"5\"\
    ,\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"])\n[\"1\",\"2\",\"3\",\"4\",\"5\"\
    ,\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"].sort.should == sort_third([\"12\"\
    ,\"11\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"])\n[\"1\"\
    ,\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"].sort.should\
    \ == sort_third([\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"\
    ,\"11\",\"12\"])\n</code>\nThis code does not pass your test cases:\n<code>\n\
    [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"].sort.should\
    \ == sort_third([\"12\",\"11\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\"\
    ,\"2\",\"1\"])\n</code>\nIt fails:\n<code>\n[\"12\",\"11\",\"10\",\"9\",\"8\"\
    ,\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"].sort.should == sort_third([\"1\",\"\
    2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"])\n</code>\n\
    This code passes your test cases:\n<code>\n[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"\
    ,\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"].sort.should == sort_third([\"12\",\"\
    11\",\"10\",\"9\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"])\n</code>\n\
    This code does not pass your test cases:\n<code>\n[\"1\",\"2\",\"3\",\"4\",\"\
    5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"].sort.should == sort_third([\"\
    1\",\"2\",\"3\",\"4", "  l1 = []\n  l2 = []\n  for i in 0..(l[0].length-1) # go\
    \ through the indicies 0 to the length of l\n    if i % 3 == 0\n      l1.push(l[i])\n\
    \    else\n      l2.push(l[i])\n  end\n  l1 = l1.sort\n  l2 = l2.sort\n  for i\
    \ in 0..(l1.length-1)\n    l2[i] = l1[i]\n  end\n  l2.push(nil)\n  return l2\n\
    end", "  l3 = []\n  for i in l \n  if i%3 == 0\n    l3 << i\n  end\n  l3.sort\n\
    \  l3\nend", "  # We define an array to hold the indices that we want to sort\
    \ by\n  sort_by = Array.new()\n  # We define an array to hold the indices that\
    \ we will place in our new list\n  new_indices = Array.new()\n  # We now loop\
    \ through the list until we find that some indicies have divisible by three\n\
    \  l.each_with_index do |value, index|\n    # If an indicies has divisible by\
    \ three, we want to keep the indicies that are not divisible by three and move\
    \ them to the end of our new list\n    # We do this by putting them in sort_by\
    \ and appending them to new_indices array\n    if index % 3 == 0 && index % 3\
    \ != index\n      sort_by << index\n      new_indices << index\n    end\n  end\n\
    \  # We now have two arrays sort_by and new_indices sorted such that their indicies\
    \ are divisible by three and unsorted indicies are kept in new_indices.\n  # We\
    \ now sort our list by the indicies of sort_by and use the new_indices array to\
    \ move the items in our original list where they have divisible by three to the\
    \ end\n  l[sort_by] = l[new_indices]\nend", "  l3 = l.map{|x| [x, x%3]}\n  l3.sort_by{|x|\
    \ x[1]}\nend", "  l1=l.sort\n  l1[0]\n  l1[1]\n  l1[2]\n  l1[3].sort\n  l\nend",
  "    l.each_with_index do |x,i|\n        if i%3 == 0\n            l.delete_at(i)\n\
    \        else\n            l.insert(i,x)\n        end\n    end\n    l\nend", " \
    \   l.sort!\n    l.each_with_index { |e, i| l[i] = e if i%3 == 0 }\nend\n</code>\n\
    And then \n<code>\nsort_third(array_of_lists)\n</code>\nwould give me the final\
    \ sorted array_of_lists.\n<|/ a |>\n<| c |>\nThis is very clever. I love it :)\
    \ But you should probably make `sort_third` return `l` rather than `l` alone,\
    \ because `array_of_lists` will be unchanged if that method does not change it.\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. Good catch. I've modified the\
    \ code accordingly.\n<|/ c |>\n<| c |>\nI love the sort idiom. Thank you\n<|/\
    \ c |>\n<| a tags=sorting,ruby dscore=2 |>\nUse Enumerable#sort_by:\n<code>\n\
    sorted_array = array.sort_by { |x| -x.first.length }\n</code>\nThis sorts the\
    \ array by length of the first element, decreasing, so the longest strings will\
    \ go at the top.\n<|/ a |>\n<| c |>\nThis worked great. I had to adjust the minus\
    \ sign to negative length so that they would sort from largest length to smallest.\n\
    <|/ c |>\n<| a tags=sorting,ruby |>\n<code>\nmy_array.sort_by { |x| -x.length\
    \ }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThat would work, but I don't think this\
    \ is what he wants. He wants to sort the array by the length of the first element\
    \ of each subarray.\n<|/ c |>\n<| a dscore=1 |>\n<code>\na = [\n    [1,2,3],\n\
    \    [10,20,30],\n    [11,21,31],\n    [1,2,3],\n    [11,21,31],\n    [1,2,3],\n\
    \    [11,21,31]\n]", "  l2 = []\n  l3 = []\n  l4 = []", "    l'=[]\n    for i\
    \ in l\n        if i%3!=0 then l'=[l[i] | l'] else l'=[l[i] | l'| [l[i-1]]]\n\
    \    end\n    return l'\nend", "  # initialize an empty list to contain all the\
    \ indicies that are divisible by three\n  l3_indices = []\n  # iterate through\
    \ all the indicies of l\n  for i in l\n    # if the current indice is divisible\
    \ by three, append it to the list\n    if i % 3\n      l3_indices << i\n  # sort\
    \ l3_indices, putting its elements in order\n  l3_indices.sort!\n  # initialize\
    \ an empty list to contain the unique indicies in l\n  l3_unique_indices = []\n\
    \  # iterate through the indices in l3_indices and append them to l3_unique_indices\n\
    \  for i in l3_indices\n    if i not in l3_unique_indices\n      l3_unique_indices\
    \ << i\n  # initialize an empty list to contain the values of l\n  l3_vals = []\n\
    \  # iterate through all the indicies of l\n  for i in l\n    # if the current\
    \ indice is divisible by three and is not in l3_unique_indices,\n    # append\
    \ the value of i to the list\n    if i % 3 == 0 and i not in l3_unique_indices\n\
    \      l3_vals << i\n  # initialize an empty list to contain the indicies in l\n\
    \  l3_indices = []\n  # iterate through all the indicies of l\n  for i in l\n\
    \    # if the current indice is divisible by three, append it to the list\n  \
    \  if i % 3 != 0\n      l3_indices << i\n  # initialize an empty list to contain\
    \ the indicies in l\n  l3_indices = []\n  # iterate through all the indicies in\
    \ l3_indices and append them to l3_unique_indices\n  for i in l3_indices\n   \
    \ if i not in l3_unique_indices\n      l3_unique_indices << i\n  # initialize\
    \ an empty list to contain the indicies in l\n  l3_indices = []\n  # iterate through\
    \ all the indicies in l3_unique_indices and append them to l3_indices\n  for i\
    \ in l3_unique_indices\n    if i not in l3_indices\n      l3_indices << i\n  #\
    \ return the list l' in the form [l3_vals[i], l3_vals[l3_unique_indices[i]], l3_vals[l3_indices[i]]]\n\
    \  return [l3_vals[i], l3_vals[l3_unique_indices[i]], l3_vals[l3_indices[i]]]\n\
    end", "  l.sort!\n  l2 = []\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n  l2.unshift(l[0])\n\
    \  l2.unshift(l", "    l.map! {|x| x == 3 ? x : nil}\n    l.sort.map! {|x| x ==\
    \ 3 ? x : nil}\nend", "  third = l[l.length % 3]\n  index = l[l.length % 3]\n\
    \  third.times { |x| l[index] = l[index] % 3 }\n  l\nend", "  \n  third = l[3]\n\
    \  \n  l[3] = {}\n  \n  for i in l\n    if l[i] % 3 == 0\n      l3[i] = l[i]\n\
    \    else\n      l3[i] = l\n    end\n  end\n  \n  return l3\nend", "    l' = l.sort.to_a\n\
    \    l' << l' >> 3\n    l' << l' >> 6\n    l' << l' >> 9\n    l' << l' >> 12\n\
    \    return l\nend", "  l = l.sort\n  l[1..-1].each do |i|\n    if l[i] % 3 ==\
    \ 0\n      l[i-1] = l[i]\n    end\n  end\n  l\nend", "  l3 = []\n  l3.push(l[0])\n\
    \  for i in l\n    if l[0] % 3 == 0 && l[1] % 3 == 0 && l[2] % 3 == 0\n      l3.push(l[2])\n\
    \      l3.push(l[1])\n      l3.push(l[0])\n    else\n      l3.push(i)\n    end\n\
    \  end\n  return l3\nend\n</code>\n<|/ a tags=sorting,ruby,arrays dscore=0 |>\n\
    <| c |>\nThis is brilliant but I am running into an issue when trying to implement\
    \ the solution as is.\n<|/ c |>\n<| c |>\nWhat kind of error? Is it an error in\
    \ the program or in the definition? It seems to be working fine for me.\n<|/ c\
    \ |>\n<| c |>\nWhen I run the program in the command line I get an error\n<|/\
    \ c |>\n<| c |>\nSorry about that, I edited my question to add the error that\
    \ I get\n<|/ c |>\n<| c |>\nThat was exactly the error I got as well, I fixed\
    \ the error by changing the definition of `sort_third` to `sort_third(l)` instead.\
    \ There was a problem with the way you were passing `l` into your function.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  l.each_with_index do |elem,index|\n  \
    \  next if index < 3\n    indicies = index..(index-2)\n    indicies.each do |i|\n\
    \      if elem[i] == '*'\n        elem[i] = '*'\n        indicies.each do |j|\n\
    \          elem[j] = '#'\n        end\n      end\n    end\n  end\n  l\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n`[3,\"*\",\"*\"]` would become `['3','3','3']` while\
    \ OP asked for it to be `[3,\"*\",\"*\"]`\n<|/ c |>\n<| c |>\nThanks I misunderstood\
    \ the question.\n<|/ c |>\n<| a tags=ruby |>\nAssuming you meant [3,\"*\",\"*\"\
    ] to become [3,\"*\",\"*\"] and not [3,\"*\",\"*\"] to become [3,\"*\",\"*\"].\n\
    A simple method would be:\n<code>\n[3,\"*\",\"*\"].map! {|s| [s,s,s]} # => [3,\
    \ \"*\", \"*\"]\n</code>\n<|/ a dscore=2 |>\n<| a |>\nIt seems like the problem\
    \ you're having is that you're trying to get your hash values back in an arbitrary\
    \ order. To me that makes your hash values depend on their order in the array,\
    \ so I'd like to suggest a different approach: build your hash without *'s and\
    \ then replace them with *'s at the end when you call sort:\n<code>", "    third\
    \ = (l.each_with_index.group_by { |a,b| a % 3 }).values.map do |x|\n        x.each\
    \ { |a| a.sort! }\n        return x\n    end\n    third.flatten.uniq\nend\n</code>\n\
    The result is\n<code>\n[[\"a\", \"b\", \"c\"], [\"c\", \"d\", \"a\"], [\"d\",\
    \ \"b\", \"a\"], [\"a\", \"c\", \"d\"], [\"d\", \"c\", \"a\"]]\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a tags=ruby,sorting,arrays |>\n<code>\narr = [\"a\", \"c\",\
    \ \"d\", \"b\"]", "  \n  lcopy = l.clone\n  lcopy[0..l.size/3] = [l.sort[0..l.size/3],l.sort[2..l.size/3],l.sort[4..l.size/3]]\n\
    \  \n  lcopy.each_with_index do |elem,index|\n    if index % 3 == 0\n      elem.sort\n\
    \    end\n  end\n  \nend\n</code>\nOutput:\n<code>\n[\n    [0] [5, 7, 8, 9],\n\
    \    [1] [2, 3, 1, 4],\n    [2] [4, 5, 6, 7]\n]\n</code>\n<|/ a |>\n<| c |>\n\
    This code will give the error `RuntimeError: can't modify frozen Array` when I\
    \ try to use it on a frozen array. Do you know why this happens and how to fix\
    \ it?\n<|/ c |>\n<| c |>\nThanks, this does seem to work for me when I use an\
    \ example such as `[[5,6,7,8,9,4],[2,3,4,5,6,7],[4,5,6,7,8,9],[1,3,5,7,8,9]]`.\
    \ However, when I attempt to use this with actual code that sorts an array with\
    \ values between 5 and 99 I get a NoMethodError and I don't understand why. Could\
    \ you possibly take a look at my updated code?\n<|/ c |>\n<| c |>\nThe code you\
    \ posted was working fine for me in both Ruby 2.5.4 and Ruby 2.6.3. I didn't notice\
    \ any errors with your updated code. The problem seems to be that the array you\
    \ are trying to sort is actually a frozen array and you are running into issues\
    \ trying to sort frozen arrays. If you try converting your frozen array to a regular\
    \ array using `to_a` you should see that there are no issues sorting the array.\n\
    <|/ c |>\n<| c |>\nWhat do you mean by regular array? Do you mean `lcopy.to_a`?\
    \ Also, when running your code on actual arrays, the sort function doesn't seem\
    \ to run. I added `p sort_third(arr)` and this didn't print anything in the console.\n\
    <|/ c |>\n<| c |>\nSorry for the confusion. Yes, you would do `arr.to_a` instead\
    \ of `sort_third(arr)`.\n<|/ c |>\n<| a dscore=1 |>\nIf you use Ruby 2.6.3 (not\
    \ 2.5.4), this can work:\n<code>\nrequire 'set'", "  l3 = []\n  l3_indexes = []\n\
    \  l3.push(l[0])\n  l3_indexes.push(l[0])\n  l3.push(l[1])\n  l3_indexes.push(l[1])\n\
    \  l3.push(l[2])\n  l3_indexes.push(l[2])\n  l3.push(l[3])\n  l3_indexes.push(l[3])\n\
    \  l3.push(l[4])\n  l3_indexes.push(l[4])\n  l3.push(l[5])\n  l3_indexes.push(l[5])\n\
    \  l3.push(l[6])\n  l3_indexes.push(l[6])\n  l3.push(l[7])\n  l3_indexes.push(l[7])\n\
    \  l3.push(l[8])\n  l3_indexes.push(l[8])\n  l3.push(l[9])\n  l3_indexes.push(l[9])\n\
    \  l3.push(l[10])\n  l3_indexes.push(l[10])\n  l3.push(l[11])\n  l3_indexes.push(l[11])\n\
    \  l3.push(l[12])\n  l3_indexes.push(l[12])\n  l3.push(l[13])\n  l3_indexes.push(l[13])\n\
    \  l3.push(l[14])\n  l3_indexes.push(l[14])\n  l3.push(l[15])\n  l3_indexes.push(l[15])\n\
    \  l3.push(l[16])\n  l3_indexes.push(l[16])\n  l3.push(l[17])\n  l3_indexes.push(l[17])\n\
    \  l3.push(l[18])\n  l3_indexes.push(l[18])\n  l3.push(l[19])\n  l3_indexes.push(l[19])\n\
    \  l3.push(l[20])\n  l3_indexes.push(l[20])\n  l3.push(l[21])\n  l3_indexes.push(l[21])\n\
    \  l3.push(l[22])\n  l3_indexes.push(l[22])\n  l3.push(l[23])\n  l3_indexes.push(l[23])\n\
    \  l3.push(l[24])\n  l3_indexes.push(l[24])\n  l3.push(l[25])\n  l3_indexes.push(l[25])\n\
    \  l3.push(l[26])\n  l3_indexes.push(l", "  l[0]\nend", "  l.sort!\n  l.each_with_index\
    \ do |x, i|\n    if i % 3 == 0\n      l[i] = l[i]\n    end\n  end\n  l\nend",
  "  l.sort\n  l.reverse!\n  l[0..-2].each do |e|\n    if l[e] % 3 != 0\n      l[e]\
    \ = l[e] * (l[e] / 3)\n    end\n  end\n  l[0..-2] = l[0..-2].sort\n  l\nend",
  "  l = []\n  l.extend(l)\n  l.sort()\n  l.each_with_index do |l, index|\n    if\
    \ index % 3 == 0\n      l[index] = l.last\n      l[index] << index\n    end\n\
    \  end\nend", "  lt = l.to_a.sort\n  return l.to_a.map { |e| [e % 3 == 0, lt[e]]\
    \ }\nend\nputs sort_third([2,3,4])", "  l = l.sort\n  l[(l.index % 3).zero?] =\
    \ []\n  l\nend", "    three_index = -1\n    l.each do |i|\n        if i % 3 ==\
    \ 0\n            three_index = i\n            break\n        end\n    end\n  \
    \  three_index = -1\n    l.each do |i|\n        if i % 3 == 0\n            three_index\
    \ = i\n            break\n        end\n    end\n    three_index = -1\n    l.each\
    \ do |i|\n        if i % 3 == 0\n            three_index = i\n            break\n\
    \        end\n    end\n    three_index = -1\n    l.each do |i|\n        if i %\
    \ 3 == 0\n            three_index = i\n            break\n        end\n    end\n\
    \    l.delete_at(three_index)\n    return l\nend", "  l2 = l.clone\n  l2.map!{|i|\
    \ [i / 3, l[i]] if i.to_i.to_s % 3 == 1}\n  l2.sort!{|a, b| a.last <=> b.last\
    \ }\n  l2\nend", "  l1 = []\n  for i in l\n    if i % 3 == 0\n      l1.push(i)\n\
    \    else\n      break\n  for i in l1\n    l1.sort!\n  end\n  l1.map!{|e| l[e]}\n\
    end", "  l.map! {|x| x == x.to_i ? x.to_i : x.to_s}\n  l.reject! do |e|\n    l.index\
    \ e % 3 == 0\n  end\n  l.sort! {|x,y| x - y}\n  l\nend", "  l.map!{|i| i.modulo(3).zero?\
    \ ? (i - (3 - (i / 3))) : i}\n  l.sort!\n  l\nend\n</code>\nThen let's look at\
    \ the output from your example input:\n<code>\n[\n  [\n    [0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25],\n\
    \    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26]\n  ]\n]\n</code>\n<|/ a tags=ruby,arrays dscore=1 |>\n\
    <| c |>\nI suspect this doesn't work if `l` is an array of arrays. It doesn't\
    \ work on [this](https://repl.it/repls/IlluminatingAfropoeticalGhosts#main.rb).\n\
    <|/ c |>\n<| c |>\nThat works fine if those arrays are just single numbers and\
    \ there is only one value in each array.\n<|/ c |>\n<| c |>\nYou need `flatten`\
    \ to flatten the inner arrays before you can do `sort`.\n<|/ c |>\n<| c |>\nNo,\
    \ `sort_third` works fine on nested arrays. It's `sort_second_third` that doesn't\
    \ work for nested arrays.\n<|/ c |>\n<| c |>\nMy bad, I meant that `sort_second_third`\
    \ doesn't work on the example input.\n<|/ c |>\n<| a dscore=0 |>\nA recursive\
    \ solution could work.  Basically, you just need to sort the nested arrays first,\
    \ then apply the sort to the inner arrays.  \nThis solution doesn't require any\
    \ extra gems.\n<code>", "  l.map! {|e| e.to_i}\n  l.sort! {|a,b| a.odd? && b.odd?\
    \ ? a-b : 1}\n  l.map! {|e| e.odd? ? e.to_i : e}\nend", "  l2=[]\n  for i in range(len(l))\n\
    \    if ((i%3==0) and ((i%5==0)or l[i]!=l[i+1]))\n      l2.append(l[i])\n    \
    \  l2.append(l[i+1])\n      l2.append(l[i+2])\n      i+=1\n      i+=2\n    else\
    \ \n      l2.append(l[i])\n      i+=1\n  l3=[]\n  for i in range(len(l2))\n  \
    \  if ((i%3==0) and ((i%5==0)or l2[i]!=l2[i+1]))\n      l3.append(l2[i])\n   \
    \   l3.append(l2[i+1])\n      l3.append(l2[i+2])\n      i+=1\n      i+=2\n   \
    \ else \n      l3.append(l2[i])\n      i+=1\n  return l3\n</code>\n<|/ a |>\n\
    <| c |>\nI'm getting an out of bounds error on the first iteration on this line:\
    \ `if ((i%3==0) and ((i%5==0)or l[i]!=l[i+1]))`\n<|/ c |>\n<| c |>\nOops, I didn't\
    \ look at all the logic. I fixed it now.\n<|/ c |>\n<| a dscore=0 |>\nMy solution:\n\
    <code>", "  l' =  l.clone\n  l.map! {|a| a.to_i}\n  l' .sort_by {|a| a % 3}\n\
    \  l' .map! {|a| a % 3}.flatten\nend\n</cell>\n<cell>\nsort_third(l)\n</cell>\n\
    <cell>\nl = [\"12\", \"45\", \"76\", \"78\", \"90\", \"101\", \"12\", \"34\",\
    \ \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"\
    101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\"\
    , \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"\
    12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\"\
    , \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"\
    34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\"\
    , \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"\
    56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\"\
    , \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"\
    78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\"\
    , \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"\
    90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\"\
    , \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"\
    101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\"\
    , \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"\
    12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\"\
    , \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"\
    34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\"\
    , \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"\
    56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\"\
    , \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"\
    78\", \"90\", \"101\", \"12\", \"34\", \"56\", \"78\", \"90\", \"101\", \"12\"\
    , \"34\", \"56", "    three_divisible = []\n    index = 0\n    while index < l.length\n\
    \        if l[index] % 3 == 0\n            three_divisible.push(l[index])\n  \
    \          index += 1\n        else\n            three_divisible.push(l[index])\n\
    \            index += 1\n            while index < l.length\n                three_divisible.push(l[index])\n\
    \                index += 1\n        end\n    end\n    return three_divisible\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby |>\n<| a dscore=0 |>\nHere is a solution\
    \ which does not mutate the input array:\n<code>", "  l' =  l.clone\n  l'.map!\
    \ {|x| x.to_i}\n  l'.sort!\n  return l'.map {|x| l[x]}\nend", "  third = [0 for\
    \ i in range(l.size)]\n  third[0] = l[0]\n  third[1] = l[1]\n  third[2] = l[2]\n\
    \  third[3] = l[3]\n  third[4] = l[4]\n  third[5] = l[5]\n  third[6] = l[6]\n\
    \  third[7] = l[7]\n  third[8] = l[8]\n  third[9] = l[9]\n  third[10] = l[10]\n\
    \  third[11] = l[11]\n  third[12] = l[12]\n  third[13] = l[13]\n  third[14] =\
    \ l[14]\n  third[15] = l[15]\n  third[16] = l[16]\n  third[17] = l[17]\n  third[18]\
    \ = l[18]\n  third[19] = l[19]\n  third[20] = l[20]\n  third[21] = l[21]\n  third[22]\
    \ = l[22]\n  third[23] = l[23]\n  third[24] = l[24]\n  third[25] = l[25]\n  third[26]\
    \ = l[26]\n  third[27] = l[27]\n  third[28] = l[28]\n  third[29] = l[29]\n  third[30]\
    \ = l[30]\n  third[31] = l[31]\n  third[32] = l[32]\n  third[33] = l[33]\n  third[34]\
    \ = l[34]\n  third[35] = l[35]\n  third[36] = l[36]\n  third[37] = l[37]\n  third[38]\
    \ = l[38]\n  third[39] = l[39]\n  third[40] = l[40]\n  third[41] = l[41]\n  third[42]\
    \ = l[42]\n  third[43] = l[43]\n  third[44] = l[44]\n  third[45] = l[45]\n  third[46]\
    \ = l[46]\n  third[47] = l[47]\n  third[48] = l[48]\n  third[49] = l[49]\n  third[50]\
    \ = l[50]\n  third[51] = l[51]\n  third[52] = l[52]\n  third[", "  l.sort!\n \
    \ l[0].tap do |k|\n    l[l.index(k)].tap do |i|\n      l[ls.index(k)] = i\n  \
    \    l[l.index(k)].tap do |i|\n        l[ls.index(k)] = i\n        l[l.index(k)].tap\
    \ do |i|\n          l[ls.index(k)] = i\n          l[l.index(k)].tap do |i|\n \
    \           l[ls.index(k)] = i\n            l[l.index(k)].tap do |i|\n       \
    \       l[ls.index(k)] = i\n              l.sort!\n              l\n         \
    \   end\n          end\n        end\n      end\n    end\n  end\nend", "  l2=l.dup\n\
    \  l2.sort!\n  l2.each.with_index {|e,i| i%3==0 && l2.delete_at(i) if i%3==1}\n\
    \  l2.sort!\nend\n</code>\nThe output for the following:\n<code>\nl = [[\"a\"\
    , \"c\", \"b\"], [\"a\", \"b\", \"d\"], [\"b\", \"d\", \"a\"]]\nsort_third(l)",
  "    l'=[]\n    l'=l.sort\n    l'=l.each_index.with_index { |a,b| b % 3 != 0 }.map\
    \ { |x| l[x] }\n    l'\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=sorting,arrays,ruby\
    \ |>\nHere's a way I like to think about sorts in Ruby:\n<code>", "  l.map!{|x|\
    \ x%3 ? x%3 : x}\n  l.sort!\nend", "  l = l.sort\n  l.each_with_index do |l, index|\n\
    \    if index % 3 == 0\n      l[index] = l[index] / 3\n    else\n      l[index]\
    \ = l[index] / 3\n    end\n  end\n  l\nend", "  l1 = l.dup\n  l1.sort!\n  l1.each_with_index\
    \ do |e,i|\n    if (i % 3 == 0)\n      l1[i] = e.to_s\n    end\n  end\n  l1.sort!\n\
    \  l1\nend\n</code>\nThe output of the above program is:\n<code>\n[\"1\", \"2\"\
    , \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n[\"1\", \"2\", \"3\", \"4\"\
    , \"5\", \"6\", \"7\", \"8\", \"9\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\"\
    , \"7\", \"8\", \"9\"]\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 |>\n<code>\n\
    a = [1,2,3,4,5,6,7,8,9,10]\nputs a.partition.flatten\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\nHere is a simple way without using partition:\n<code>\na = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nb =   a.each_with_index.chunk {|x,i| i%3==0}\n\
    b.each_with_object({}){|(k,v),h| h[k]=v.map(&:first).sort}\n</code>\nWhich outputs:\n\
    <code>\n{1=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n 2=>[1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12],\n 3=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n 4=>[1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n 5=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n\
    \ 6=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n 7=>[1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10, 11, 12],\n 8=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n 9=>[1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11, 12],\n 10=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n\
    \ 11=>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n 12=>[1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12]}\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a dscore=1 |>\n<code>\n\
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]", "  l' =  l.sort\n  l' -= [0,0,0]\n\
    \  l'.each_index { |i|\n    if l[i] % 3 == 0 && l[i] != i && l[i] != l[i-1]\n\
    \      l[i-1] = l[i]\n    end\n  }\n  l\nend", "  l.reduce(:<<)\n  l.group_by{|i|i%3==0\
    \ ? i : nil}.map{|i,v| i%3==0 ? i : nil,v.reduce(:<<)}\nend\n</code>\n<|/ a |>\n\
    <| a |>\n<code>\n def three_decide(arr)\n      arr.inject([]) do |arr,x| \n  \
    \      if x % 3 == 0\n          arr.push(x) if arr.empty? \n          arr.uniq!\
    \ { |x| x }\n          arr <<  arr.sort\n        elsif arr.empty?\n          arr\
    \ << x\n        end\n        arr <<x\n        arr\n      end\n    end\n</code>\n\
    <|/ a tags=ruby,arrays dscore=1 |>\n<| a |>\nHere is my solution:\n<code>", " \
    \   l.sort\n    l.each_with_index { |item, index| \n        if index % 3 == 0\n\
    \            l[index / 3] = (l[index / 3]).push(item)\n        else\n        \
    \    l[index / 3] = item\n        end\n    }\nend", "  l3 = l.dup\n  l3.map!{|e|\
    \ [e, (e%3 == 0 ? e/3 : e)]}\n  l3.sort!{|a, b| a[0] <=> b[0]}\n  l3\nend", " \
    \ lt = l.sort\n  lt.each_with_index {|el, i|\n    if i%3 == 0 then lt[i] = i end\n\
    \  }\n  lt\nend", "    l.sort!\n    l.each_with_index do |x, i|\n        i -=\
    \ 1 if i % 3 == 0\n        l[i] = x\n    end\nend\n</code>\nHere are a few examples:\n\
    <code>\nsort_third([1,2,3,4,5,6,7,8])\n=> [6, 1, 2, 7, 3, 5, 8, 4]", "  l' =[]\n\
    \  for i in l\n    if i.div(3)==0\n      l' << i\n    else\n      l' << i\n  \
    \    l' << i.div(3)\n      l' << i.div(9).div(3)\n    end\n  end\n  l'.sort\n\
    end", "  l1 = []\n  for i in l \n    if (i%3 == 0)\n      l1.push(i)\n    else\n\
    \      l1.push(l[i])\n  end\n  l2 = []\n  for i in l1 \n    if (i%3 == 0)\n  \
    \    l2.push(i)\n    else\n      l2.push(l[i])\n    end\n  end\n  l2.sort!\n \
    \ return l2\nend", "  return l.sort.uniq{|e| e % 3 == 0}\nend", "  l.each do |index|\n\
    \    if index % 3 == 0\n      l[index] = index\n    end\n  end\n  l.sort!\n  return\
    \ l\nend", "  l2 = []\n  l3 = []\n  l.each do |i|\n    if i.modulo(3) == 0\n \
    \     l2 << i\n    else\n      l3 << i\n    end\n  end\n  l3 = sort_third(l3)\n\
    \  return l2.zip(l3).sort\nend", "  l.sort.each do |i|\n    temp = l[i]\n    l[i]\
    \ = l[i % 3]\n    l[i % 3] = temp\n  end\nend", "  l.sort!\n  l[(l[l.length/3..-1]).each\
    \ { |i| l.pop i if l[l.index(i)].even? }]\nend", "  n = l.length\n  l3 = (1..n).to_a\n\
    \  l3 = l3.group_by{ |i| i % 3 }.keys.flatten.sort\n  l3.each_with_index do |i,\
    \ indx|\n    l3[indx] = l[indx]\n  end\n  l3\nend", "  l3 = l.clone\n  l3.sort!\n\
    \  l3[0..-2] == l ? (l3[-2..-1] = l.sort, l3[0..-2]) : l3\nend", "  l' =  []\n\
    \  indicies = (0..l.length).to_a\n  indicies.each do |i|\n    unless i % 3 ==\
    \ 0 then\n      l' << l[i]\n    end\n  end\n  indicies.each do |i|\n    unless\
    \ i % 3 == 0 then\n      l[i] ||= l[i+1]\n    end\n  end\n  indicies.each do |i|\n\
    \    unless i % 3 == 0 then\n      l[i] ||= l[i-1]\n    end\n  end\n  l\nend",
  "  l'.sort!\n  l'.each do |i|\n    k = i + 2\n    while k < l.length\n      l[i]\
    \ = l[k]\n      k += 2\n    end\n  end\nend", "    l.sort! # sorts l\n    \n \
    \   i = 0 # the variable i is going to start off at the first index\n    while\
    \ i < l.length # as long as i is not equal to l.length (i.e. until we reach the\
    \ end of the array)\n        if l[i] % 3 != 0 # if the value of the ith index\
    \ of l is not equal to 0 (i.e. if the ith index isn't divisible by 3)\n      \
    \      l[(i + l.length)-1] = l[i] # swap the value at index i with the value at\
    \ index i.length\n            l.delete_at(i) # delete the current value at index\
    \ i (i.e. the value at index i.length which was swapped)\n            i += 1 #\
    \ move to the next index\n        else # if the value of the ith index of l is\
    \ equal to 0 (i.e. if the ith index is divisible by 3)\n            if l[i] !=\
    \ l[i-1] + 3 # if they aren't the same then swap the two values at index i and\
    \ the value at index i.length\n                l[i-1], l[i-1] + 3 = l[i], l[i]\n\
    \            i += 1 # move to the next index\n    end\nend", "  lt = []\n  for\
    \ i in 0...(l.length-1)\n    if l[i] % 3 != 0\n      lt << l[i]\n    end\n  end\n\
    \  lt.sort_by {|t| t.to_s}\nend", "  n = (l.size/3) * 3\n  l1 = l[1..n]\n  l2\
    \ = l[2..n]\n  l3 = l[3..n]\n  l4 = l[4..n]\n  return [l1[0], l2[0], l3[0], l4[0],\
    \ l1[1], l2[1], l3[1], l4[1], l1[2], l2[2], l3[2], l4[2]]\nend\n</code>\nThis\
    \ produces an array with the indicies that are divisible by three and the corresponding\
    \ values from l. Using those indicies, we sort the other indicies in decreasing\
    \ order and return the list of values from l. We use this function as follows:\n\
    <code>\nputs sort_third([1, 2, 3, 4, 5, 6, 7])\n</code>\nThe output is:\n<code>\n\
    [4, 5, 6, 1, 2, 3, 7]\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis can be done by\
    \ one array sort function call. See my answer.\n<|/ c |>\n<| a tags=ruby |>\n\
    You can use the method partition with a proc that returns 2 items in case that\
    \ element is not divisible by 3 and 1 item otherwise. For example\n<code>\na =\
    \ [1,2,3,4,5,6,7,8,9,10,11,12,13,14]\na.partition(&:odd?)\n  #=> [[1, 6], [2,\
    \ 7], [3, 8], [4, 9], [5, 10], [3, 11], [4, 12], [5, 13], [6, 14], [7, nil]]\n\
    </code>\nIf the elements need to be sorted then you can use the method sort_by\
    \ (which accepts a proc) like this\n<code>\na.sort_by(&:odd?).partition(&:odd?)\n\
    \  #=> [[1, 6], [2, 7], [3, 8], [4, 9], [5, 10], [3, 11], [4, 12], [5, 13], [6,\
    \ 14], [7, nil]]\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]",
  "  l'.sort!\n  i = 1\n  while i < l.length\n    nextI = i+3\n    if nextI == l.length\n\
    \      nextI = 1\n    end\n    while nextI < l.length\n      if l[i] < l[nextI]\n\
    \        l'[i] = l[i]\n        nextI = nextI + 1\n      end\n      nextI = nextI\
    \ + 1\n    end\n    i = nextI\n  end\n  l'.sort!\nend\nsort_third(lst)\n</code>\n\
    Which gives:\n<code>\n[[1, 5, 9], [2, 5], [3, 9, 10], [4, 8], [6, 4], [7], [8],\
    \ [9, 10], [10, 11], [12], [13, 14], [15]]\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    You can do this in a single pass, but it may be harder to understand:\n<code>",
  "  l.sort\n  l2 = []\n  indicies.each_with_index do |x, i|\n    if i % 3 == 0\n\
    \      l2 << l[i]\n    else\n      l2 << l[i]\n    end\n  end\n  l2\nend", " \
    \ l3 = l.dup\n  l3.sort_by! do |i|\n    (l3.index { |e| e % 3 == i }) ? i : -1\n\
    \  end\n  l3\nend\n</code>\nNow the code becomes much simpler.\n<code>", "  l.each_with_index\
    \ do |value, index|\n    divisible_by_three = index % 3 == 0\n    if divisible_by_three\n\
    \      l[index] = value\n    end\n  end\n  return l\nend", "  l2 = l.clone\n \
    \ l3 = []\n  l3.push(l[0].clone)\n  l3.push(l[1].clone)\n  l3.push(l[2].clone)\n\
    \  l.each { |x|\n    if (x.value % 3 == 0)\n      l2.pop\n      l2.push(x.clone)\n\
    \      l3.pop\n      l3.push(x.clone)\n    else\n      l3.push(x.clone)\n    end\n\
    \  }\n  l3\nend\n</code>\n<|/ a tags=arrays,sorting,ruby,algorithm |>\n<| a tags=arrays,sorting,ruby,algorithm\
    \ dscore=0 |>\nJust as a variation on what suggested, I implemented a generic\
    \ sorter that takes two arguments (the array to be sorted, and the comparator\
    \ function to be applied) which works on arrays of any type.  \n<code>", "  l2\
    \ = []\n  for i in 0..l.length-1\n    if l[i] % 3 == 0\n      l2.push(l[i])\n\
    \    else\n      l2.push(l[i..l[i].length-1].uniq.sort)\n    end\n  end\n  l2\n\
    end", "  return l.sort_by {|x| x % 3 == 0}\nend\n</code>\nTo test this, I wrote\
    \ a small test file:\n<code>\nl = [\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n\
    \  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\"\
    ,\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"\
    t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n]\n</code>\n\
    Here are the results given that sort_third is called (as you did in your question):\n\
    <code>\n>> sort_third(l)", "  l2 = []\n  l.each_with_index do |e, i|\n    if i\
    \ % 3 == 0\n      l2 << e unless e == l[i]\n    else\n      l2 << e\n    end\n\
    \  end\n  l2.sort\nend", "  l.each_with_index.sort_by(&:first).map do |indicies,\
    \ value|\n    indicies.zip(value * l[indicies.first])\n  end.flatten\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nHi Tim, sorry for the late reply. I'm going to try\
    \ your solution shortly. I'm still not entirely sure what you meant by \"but sorted\"\
    . I added a small example to the question to show what I'm looking for.\n<|/ c\
    \ |>\n<| c |>\nIt is not necessary to sort the indicies but to sort the values\
    \ associated with each of the indicies. I added a way to achieve that. The code\
    \ might look confusing, but I hope that makes sense.\n<|/ c |>\n<| c |>\nThat's\
    \ great Tim. That's exactly what I was looking for!\n<|/ c |>\n<| c |>\nGreat,\
    \ I'm glad I was able to help you out. I just updated my answer to include the\
    \ sort you mentioned in the comment and also a way to sort based on the value\
    \ associated with each of the indicies.\n<|/ c |>\n<| c |>\nThanks for updating\
    \ the answer! Just one question, why did you use `each_with_index.map(&:first)`\
    \ instead of `each_with_index.first`?\n<|/ c |>\n<| a |>\n<code>", "    \n   \
    \ # find indicies that are not divisible by three\n    left_over = []\n    count\
    \ = 0\n    for i in range(len(l))\n        if l[i] % 3 == 0\n            left_over.append(count)\n\
    \            count += 1\n        else \n            count += 1", "  l3 = l.dup\n\
    \  l3.sort!\n  l3[0...-1].zip(l[0...-1]).each{|a,b| a==b && a==1 ? l3.pop : l3.delete(b)}\n\
    \  l3\nend\n</code>\nExample:\n<code>\nsort_third([3,2,2,1,6,2,2,2,2,2,3,3])",
  "  return l.map { |i| l[i % 3] }\nend\n</code>\n<|/ a |>\n<| a dscore=1 tags=sorting,ruby,arrays\
    \ |>\nFirst off, let's have a look at this array:\n<code>\n [\"1\",\"2\",\"3\"\
    ,\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\"\
    ]\n</code>\nThis array is sorted as you need, by dividing the numbers 1,2, ...\
    \ by 3, giving you this array:\n<code>\n [\"1\", \"2\", \"3\", \"4\", \"5\", \"\
    6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\"]\n</code>\n\
    This array is sorted, but we do not care about the original numbers, we just want\
    \ a second array, that is the same as the first one, with the values divided by\
    \ 3, in the right order.\n<code>\n[\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"\
    7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\"].map{|s| s.to_i/3}\n\
    </code>\nThe final array we want, is the same as the first, but with only numbers\
    \ divided by 3 at the right place.\n<code>\n [\"0.1666666667\", \"0.1666666667\"\
    , \"0.3333333333\", \"0.5\", \"0.6\", \"0.8\", \"1\", \"1.3333333333\", \"1.3333333333\"\
    , \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"\
    , \"13\", \"14\", \"15\"]\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\narr =\
    \ [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"\
    ,\"13\",\"14\",\"15\"]\narr.each_with_index.group_by{|e,i| i % 3 }.values.map{|i|\
    \ i.sort_by{|e| e.to_f/3 }}\n</code>\n<|/ a tags=sorting,ruby,arrays |>\n<| c\
    \ |>\n`#each_with_index` could be replaced with `#each_slice`: `arr.each_slice(3).map{|a|\
    \ a.sort_by(&:to_f/3)}`\n<|/ c |>\n<| a |>\nHere's another approach:\n<code>\n\
    arr.each_slice(3).map { |e| e.sort_by(&:to_f/3) }\n</code>\nThis should work since\
    \ Array#sort_by will sort the element by the given block.\nEdit: This is basically\
    \ Andrey's answer, but with the difference that it is working with Enumerator\
    \ instead of Array. One may consider it as a ", "    l.sort!\n    new_l = []\n\
    \    index = 0\n    while index < l.length\n        if index % 3 == 0\n      \
    \      new_l << l[index]\n            index += 1\n        elsif index / 3 != 0\n\
    \            index = index / 3\n            new_l << l[index]\n            index\
    \ += 1\n        end\n    end\n    new_l\nend", "  l2 = []\n  l = l.sort\n  l.each_index\
    \ do |i|\n    if l[i] % 3 == 0\n      l2 << l[i]\n    end\n  end\n  l2\nend",
  "    l = l.sort\n    l.each_with_index do |x,i|\n        if i % 3 == 0\n       \
    \     l[i-1] = x\n        end\n    end\n    return l\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>", "  l = l.sort\n  l[3..-1].each_with_index\
    \ { |e| e[3..-1].each { |e| l[e].swap(e) } }\nend\n</code>\nLet's test our function:\n\
    <code>\narr = [1, 2, 3, 4, 5]\nsort_third(arr)\n  #=> [1, 2, 4, 3, 5]\n</code>\n\
    Now let's try a sample array:\n<code>\narr = [1, 2, 3, 4, 5]\nsort_third(arr)\n\
    \  #=> [1, 2, 4, 5, 3]\n</code>\nAnd another array:\n<code>\narr = [1, 2, 3, 4]\n\
    sort_third(arr)\n  #=> [1, 2, 3, 4]\n</code>\nAnd:\n<code>\narr = [1, 2, 3, 4,\
    \ 5]\nsort_third(arr)\n  #=> [1, 2, 3, 4, 5]\n</code>\nThis works because the\
    \ block form of Enumerable#sort performs an in-place sort, but the block form\
    \ of Array#sort sorts the entire array:\n<code>\narr = [1, 3, 4, 5]\narr =[1,\
    \ 3, 4, 5].sort\n  #=> [1, 3, 4, 5] \narr\n  #=> [1, 2, 3, 4, 5] \n</code>\nAs\
    \ discussed above, sort_third does not return anything, so sort_third(arr) evaluates\
    \ to nil instead. Since nil is falsey, the array is not sorted.\nAnother example:\n\
    <code>\narr = [1, 2, 3, 4, 5]\nsort_third(arr)\n  #=> [1, 2, 4, 5, 3]\n</code>\n\
    <|/ a dscore=0 tags=arrays,ruby |>\n<| c |>\nThanks for this detailed answer.\
    \ I will definitely look into your answer when I get some time. \nI thought of\
    \ another way. My solution was to remove all items that are divisible by three\
    \ and then sort. \nI guess this way will be more efficient. Do you think so?\n\
    <|/ c |>\n<| c |>\n: It is a good way to think about your problem. My solution\
    \ works only if you have no other constraints on your input array. For example,\
    \ I will update my answer to show my method if you do have other constraints on\
    \ your input array. BTW, Ruby arrays are always sorted, so the efficiency of this\
    \ method may not matter much.\n<|/ c |>\n<| a tags=arrays,ruby |>\nYou could use\
    \ Array#partition:\n<code>\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "    l = l.sort\n\
    \    l = l[-3..-1]\n    l.uniq\n    l.map { |e| e % 3 }.sort\nend\n</code>\nThis\
    \ doesn't seem very efficient, but it's easy to understand, and it will run faster\
    \ than your first version if there are fewer than 1000 elements in l.  It also\
    \ doesn't care if the values at the indicies aren't divisible by three - if you\
    \ only care about values that are divisible by three, just change l.map { |e|\
    \ e % 3 }.sort to l.uniq.sort.\n<|/ a dscore=0 |>\n<| c |>\nThe code `l = l.sort`\
    \ mutates the array. Better to return the new array `sort_third(l.uniq)` instead.\n\
    <|/ c |>\n<| c |>\nThank you for pointing out that the code mutates the array.\
    \  I've fixed the code, but I'll point out that `uniq` is only called on the last\
    \ line of the function `sort_third`.  As for efficiency, I think the code will\
    \ run faster if you replace the call to `sort` with `sort_third`, since `sort`\
    \ will have to sort multiple times over the array.  And `sort_third` will need\
    \ to sort 3 times over the array, so the total time for the function is still\
    \ quadratic in the number of elements in the array, and is still O(n^2) in the\
    \ total number of elements in the array.\n<|/ c |>\n<| a dscore=0 |>\nYou cannot\
    \ use sort on a hash and that is the problem. \nThe sort method will sort the\
    \ hash in a different order than the original hash. You want to sort the hash\
    \ in the same order that the original hash is sorted in. \nYou cannot sort a hash\
    \ in place. \nYou can however sort the hash before you insert it into an array\
    \ and then do the reverse when you are done with the array and print it.\n<code>\n\
    \ def sort_third(hash)\n  hash = (hash.to_a.reverse).sort_by{|k, v| v }\n  puts\
    \ hash.to_s\nend\n</code>\n<|/ a tags=ruby,sorting,hash |>\n<| c |>\nI do not\
    \ understand the downvote. OP clearly states he wants to sort the hash by its\
    \ values while maintaining the hash association. Sorting the hash in reverse is\
    \ not an issue. Sorting the hash by its values is what is causing the problem.\
    \ And the solution to sort a hash is `hash.sort` not `hash.sort!`\n<|/ c |>\n\
    <| c |>\nThe downvote may be because you've posted a solution that sorts by the\
    \ value of the hash.  Sorting by the hash key is not what OP ", "    l.sort!\n\
    \    l.each_with_index { |(val,index), i| l[index] = i if i % 3 == 0 }\n    l\n\
    end", "  l.sort\n  i = 0\n  while i < l.length - 1\n    if l[i] % 3 == 0\n   \
    \   l[i / 3] = l[i]\n      i += 1\n    else \n      l[i] = l[i + 1]\n      i +=\
    \ 1\n  end\n  return l\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like your\
    \ answer and I understand that it is probably the most elegant solution available.\
    \ I am not able to test this right now but when I do I'll certainly accept the\
    \ answer if it works.\n<|/ c |>\n<| c |>\nIt works! It even runs faster than my\
    \ original code. Thanks!\n<|/ c |>\n<| c |>\nYou are welcome!  Please up-vote\
    \ my answer if you found it helpful.\n<|/ c |>\n<| c |>\nI tried, but it didn't\
    \ work. Perhaps because my reputation is less than 15. Thanks anyway!\n<|/ c |>\n\
    <| c |>\nGlad I could help!\n<|/ c |>\n<| a dscore=1 |>\nAn approach is to sort\
    \ the array using Array#sort:\n<code>\na = %w(a b c d e f g h i j k l m n o p\
    \ q r s t u v w x y z)\na = sort_third(a) \np a", "  l2 = []\n  l3 = []\n  l4\
    \ = l[:]\n  l4.sort!\n  l4[0] = 0\n  l4[1] = 1\n  l4[2] = 2\n  l4[3] = 1\n  l4[4]\
    \ = 0\n  l4.each_index do |i|\n    l = l4\n    if i % 3 == 0\n      l3[i] = l[i]\n\
    \      l[i] = l[i]\n      l4[i] = l4[i]\n    else\n      l2[i] = l[i]\n      l[i]\
    \ = l[i]\n      l4[i] = l4[i]\n    end\n  end\n  return l3\nend", "  l3 = []\n\
    \  third = 0\n  l.each do |x|\n    third = x % 3\n    if third != 0\n      l3\
    \ << [x, l[third]]\n    end\n  end\n  l3.sort!\nend", "  l1 = []\n  l2 = []\n\
    \  l3 = []\n  for elem in l\n    l2 << elem\n  end\n  \n  while l2.size > 3\n\
    \    l1 << (l2.shift << 3)\n    l3 << (l2.shift << 6)\n  end\n  \n  return [*l1,\
    \ *l2, *l3]\nend", "    l = l.clone\n    i = 0\n    j = lsize-1\n    while i <\
    \ j\n        if l[i] % 3 == 0\n            tmp = l[i]\n            l[i] = l[j]\n\
    \            l[j] = tmp\n            i += 1\n            j -= 1\n        end\n\
    \    end\n    l\nend", "  l.sort! do |x,y|\n    if x % 3 == 0 && y % 3 == 0\n\
    \      x == y\n    else\n      x > y\n    end\n  end\n  return l\nend", "  l2\
    \ = []\n  for i in 0..length(l) - 1\n    val = l[i]\n    if i / 3 == 0\n     \
    \ l2.push(val)\n    else if val > l2[l / 3]\n      l2.push(val)\n    else\n  \
    \    l2.push(l2[l / 3])\n      l2.push(val)\n  end\n  return(l2)\nend", "  l2\
    \ = [x for x in l]\n  l2.sort\n  l2\nend\n  ", "  lprime = l.to_a\n  lprime.sort\n\
    \  lprimeprime = lprime.to_a\n  lprimeprime.sort\n  lprimeprimeprime = lprimeprime.to_a\n\
    \  lprimeprimeprime[0].map!{|i| lprimeprimeprime[(i+1)%lprimeprimeprime.size]}.join\n\
    end", "  lp = l - l.sort { |a, b| a[0] <=> b[0] }\n  lp += lp - lp.sort { |a,\
    \ b| a[1] <=> b[1] }\n  return lp - ((lp - lp).sort { |a, b| a[2] <=> b[2] })\n\
    end\n</code>\nI hope this helps.\n<|/ a dscore=0 |>\n<| c |>\nI tried to understand\
    \ what you've done. `sort_third` is sorting the array in three steps; it first\
    \ sorts it in ascending order by the first element, then sorts it again in descending\
    \ order by the second element, and finally, it sorts it again in ascending order\
    \ by the third element. This is because `sort_third` is sorting in ascending order\
    \ by the first element, then sorting again in ascending order by the second element,\
    \ then sorting again in ascending order by the third element, so it is sorted\
    \ by first element first, then second element and then the third element. If you\
    \ want to understand it better, just try it out. Try sorting `[1,2,5,6,7,8,9,10,11,12]`\
    \ and look at the resulting array.\n<|/ c |>\n<| c |>\nThe idea is that since\
    \ sorting in ascending order by the first element will sort the elements in ascending\
    \ order by the second element in the correct way, then sorting in ascending order\
    \ by the third element will sort the elements in the correct way (descending order\
    \ by the second element), then sorting in ascending order by the first element\
    \ will again be the same as sorting in descending order by the second element.\
    \ As you said \"it will sort it again in ascending order by the third element\"\
    , which is not true, because it will sort it in ascending order by the third element\
    \ and then sort it in descending order by the second element, which is the correct\
    \ way.\n<|/ c |>\n<| c |>\nI see you updated your answer with the code in your\
    \ comment. However, the comment is not very helpful. The problem is that it's\
    \ sorting by the first element first, then the second element, and then it's sorting\
    \ again by ascending order by the third element. For example, try `sort_third([1,2,5,6,7,8,9,10,11,12])`.\
    \ It will output `[11, 12, 9, 8, 7, 6, 5, 4, 3, 2, 1]`.\n<|/ c |>\n<| c |>\nSorry\
    \ I wrote it too fast, I didn't test it, I just read the comments, and I understood\
    \ what you were talking about. I'm going to try to write some tests to see if\
    \ I have any doubts about it...\n<|/ c |>\n<| c |>\nI updated my answer with the\
    \ test that I wrote (I didn't write all the tests because I wasn't sure about\
    \ the correctness of my code). If ", "\tout = []\n\t\n\tl.each_index do |i|\n\t\
    \tif i % 3 == 0\n\t\t\tout << l[i]\n\t\tend\n\tend\n\t\n\tout\nend\n</cell>\n\
    <cell>\nsort_third(l)\n</cell>\n<text>\nSorting Using a Function", "    l.sort{|a,b|\n\
    \        if (a%3 == 0 and a%5 != 0) or (a%3 == 0 and a%5 == 0)\n            if\
    \ b%3 == 0 and b%5 != 0 or (b%3 == 0 and b%5 == 0)\n                -1\n     \
    \       else\n                0\n            end\n        else\n            if\
    \ a%3 == 0 and b%3 == 0 or (a%3 == 0 and b%3 == 0) or (b%3 == 0 and a%3 == 0)\n\
    \                if a%5 == b%5\n                    0\n                else\n\
    \                    -1\n                end\n            else\n             \
    \   if a%5 > b%5\n                    -1\n                else\n             \
    \       1\n                end\n            end\n        end\n    }\nend", " \
    \ sorted = []\n  l.each_with_index do |value,index|\n    if index % 3 != 0\n \
    \     sorted << value\n    end\n  end\n  return sorted\nend", "  # sort l' so\
    \ that it goes through the indicies of l and their values that are divisible by\
    \ 3\n  l.each_with_index do |elem, index|\n    if index%3 == 0 then elem1 = elem;\
    \ elem2 = index\n    else elem1 = index; elem2 = elem\n    end = elem1 + 1\n \
    \   l.insert(elem2, elem1)\n  end\n  return l\nend\n</code>\nThis code does all\
    \ the following:\n<code>", "  l1 = []\n  l2 = []\n  count = 0\n  for i in 0..length(l)\n\
    \    if i % 3 == 0\n      l1 << l[count]\n      l2 << l[count]\n      count +=\
    \ 1\n    else\n      l1 << l[count]\n      l2 << l[count]\n      count += 1\n\
    \    end\n  end\n  l1.sort!\n  l2.sort!\n  l1.zip(l2).map{|x| x[0] <=> x[1]}\n\
    end\n</code>\nAs for the sorting by time, you could also use the Time.now method.\
    \ Just replace Time.now with the method you want (like Time.now.to_i, Time.now.to_s).\
    \ I used the to_i method because that works for me in both Ruby 1.8.7 and 1.9.2.\n\
    <|/ a tags=ruby dscore=1 |>\n<| c |>\nNice, I was also wondering how you can sort\
    \ an array without creating a new one - I wonder if that is possible, or is sorting\
    \ always creating a new array. I'll have to keep that in mind. Good work!\n<|/\
    \ c |>\n<| c |>\nHaving thought about it, it's true that sorting does not create\
    \ a new array. It modifies the array in-place.\n<|/ c |>\n<| a dscore=1 |>\nYou\
    \ could use a hash to store the frequencies of every item in your array, and use\
    \ that to sort the array based on the number of items that have been seen.\n<code>\n\
    array = [1, 2, 3, 4, 5, 6, 6, 6]", "  # l' is returned to allow for the possibility\
    \ that l has been changed during the function call, in this case sort_third returns\
    \ a list identical to l that has its values at indicies that are not divisible\
    \ by three sorted\n  l'.sort!\n  # the third indicies of the list l' are assigned\
    \ to the indicies that are not divisible by three\n  for i in 0..l'.length-1\n\
    \    if l'.at(i)%3 == 0\n      l'.at(i) = 0\n    else\n      l'.at(i) = l'.at(i)-1\n\
    \    end\n  end\n  return l'\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
