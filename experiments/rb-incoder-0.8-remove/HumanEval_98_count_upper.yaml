name: HumanEval_98_count_upper
language: rb
prompt: "# Given a string s, count the number of uppercase vowels in even indices.\n\
  # For example:\ndef count_upper(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_count_upper\n\
  \    candidate = method(:count_upper)\n    assert_equal(1, candidate.call(\"aBCdEf\"\
  ))\n    assert_equal(0, candidate.call(\"abcdefg\"))\n    assert_equal(0, candidate.call(\"\
  dBBE\"))\n    assert_equal(0, candidate.call(\"B\"))\n    assert_equal(1, candidate.call(\"\
  U\"))\n    assert_equal(0, candidate.call(\"\"))\n    assert_equal(2, candidate.call(\"\
  EEEE\"))\n  end\nend\n"
completions: ["  s.chars.each_with_index { |c,i| return i if c =~ /[AEIOU]/i }\n \
    \ nil\nend", "    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n\
    \    count = 0\n    i = 0\n    while i < len(s):\n        if s[i] in vowels:\n\
    \            if i % 2 == 0 and s[i].isupper():\n                count += 1\n \
    \           i += 1\n        else:\n            i += 1\n    return count\nprint(count_upper('Ramen'))",
  "    count = 0\n    for (i,c) in enumerate(s):\n        if c == 'A' or c == 'E'\
    \ or c == 'I' or c == 'O' or c == 'U':\n            if i % 2 == 0:\n         \
    \       count = count + 1\n    return count\nend\n</cell>\n<code language=julia-1.5>\n\
    count_upper(\"BACADAO\")\n</cell>\n<text>\nWrite a function to check if the provided\
    \ string is palindrome or not.", "    count = 0\n    for i in 0..s.length\n  \
    \      if s[i] = 'A' then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend", "  evens = 0.step(s, /[aeiou]/)\n  evens.inject(0) do\
    \ |count, e| count += (e.length % 2 == 0 ? 0 : 1) end\nend\ncount_upper(\"Hello,\
    \ world!\")\n  #=> 7\n</code>\nThe regular expression in the argument to step\
    \ determines what elements would be counted and what would be skipped. In the\
    \ regular expression /[aeiou]/ we define an alternation: either an vowel or a\
    \ consonant. To skip these elements, we use the zero-width lookahead assertion\
    \ (i.e. /(?=...).../).\nWe use Enumerable#inject to iterate over the elements\
    \ of evens, and count the number of even elements. We then return that number\
    \ as the final result.\n<|/ a dscore=2 |>\n<| c |>\nThe second method will fail\
    \ if you try it for strings containing more than 26 characters (because 26 is\
    \ not an even number). The first method will fail if you try it with strings containing\
    \ more than 26 characters (because 26 is not an even number).\n<|/ c |>\n<| c\
    \ |>\nThanks. I've fixed up the second method.\n<|/ c |>\n<| a tags=string,ruby,regex\
    \ |>\nTo count the vowels in a given string, you could use:\n<code>", "  count\
    \ = 0\n  s.each_index { |i| count += s[i].upcase } unless s.nil?\n  count\nend\n\
    </cell>\n<text>\nExercise 4: Count all uppercase vowels\nGiven a string s, count\
    \ the number of uppercase vowels in even indices.", "  return s.gsub(/[aeiouy]/,\
    \ '').length % 2 == 0\nend\n</pre>\n            </div>\n          </section>\n\
    \          <section>\n            <h3>The power of String#sub!</h3>\n        \
    \    <p>String#sub! modifies the original string. String#sub! returns a modified\
    \ string\n            on success, and raises an exception on failure:</p>\n  \
    \          <ul>\n              <li>if the substitution fails</li>\n          \
    \    <li>if the substitution returns a string longer than the original string</li>\n\
    \            </ul>\n            <p>If you don't want to modify a string in-place,\
    \ use String#gsub!.</p>\n            <p>String#sub! also has a third parameter\
    \ that is a regexp to match against the\n            original string. This enables\
    \ more powerful pattern-matching using the\n            String#match method:</p>\n\
    \            <ul>\n              <li>if there is no match or if the match fails</li>\n\
    \              <li>if the match is successful</li>\n              <li>if the match\
    \ is a string</li>\n            </ul>\n            <pre><code># Find all uppercase\
    \ vowels *except* the first, using String#sub!", "  s.chars.each.with_index.with_object(Hash.new(0)){|c,i|\
    \ c=='a' || c=='e' || c=='i' || c=='o' || c=='u'}\nend.inject{|i,j| i.merge!(j){|k,v|\
    \ v+=1}}\n  #=> {\"a\"=>1, \"e\"=>1, \"i\"=>1, \"o\"=>1, \"u\"=>3}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nNice use of inject to do the sum, and it uses a nice\
    \ trick with hashes. Thanks for sharing.\n<|/ c |>\n<| a tags=ruby,string,hash,arrays\
    \ |>\n<code>", "  s.chars.each_with_index do |c, i|\n    if (c > 'Z') && (i &\
    \ 1) == 0 then c end\n  end\nend\n</pre>", "  count = 0\n  (0...s.length).map\
    \ { |i|\n    (i / 2) == 0 ? count += 1 if s[i] >= 'A' && s[i] <= 'Z' : nil\n \
    \ }\n  count\nend", "  return s.upcases.length unless s.empty?\n  vowels = (0...s.length).select\
    \ { |i| s[i] =~ /[AEIOU]/i }\n  vowels.count { |i| i & 1 == 0 }\nend", "  return\
    \ s.scan(/[aeiou]/).length\nend", "  uppers = 0\n  for i in 0...s.length\n   \
    \ if s[i] >= 'A' && s[i] <= 'Z'\n      uppers += 1\n    end\n  end\n  uppers\n\
    end", "  s.chars.each_with_index.map { |c,i| if i % 2 == 0 && c =~ /[aeiou]/\n\
    \                               then c end\n                         }.count\n\
    end", "  count = 0\n  s.each_index {|i|\n    count += 1 unless s[i] == s[i]\n\
    \  }\n  count\nend", "  return s.chars.select { |c| c =~ /[AEIOUY]/i }.count\n\
    end", " count = 0\n # code here\nend", "  count = 0\n  i = 0\n  while i < s.length\n\
    \    if s[i] >= 'A' && s[i] <= 'Z'\n      count += 1 if (s[i] >= 'a' && s[i] <=\
    \ 'z')\n    end\n    i += 1\n  end\n  count\nend", "  s = s.downcase\n  count\
    \ = 0\n  (0..s.length).each do |i|\n    next if s[i].upcase == \"?\"\n    count\
    \ += 1 if s[i].upcase == \"A\" || s[i].upcase == \"E\"\n    count += 1 if s[i].upcase\
    \ == \"I\" || s[i].upcase == \"O\"\n    count += 1 if s[i].upcase == \"U\"\n \
    \ end\n  count\nend\nassert count_upper(\"GloVe.\") == 2, \"Vowels in even indices\
    \ should not be counted.\"\nassert count_upper(\"geeksforgeeks.org\") == 2, \"\
    Only one vowel in odd indices should be counted.\"", "    count = 0\n    for i\
    \ in 0..s.length-1\n        if s[i] =~ /[A-Z]/\n            count += 1\n     \
    \   end\n    end\n    return count\nend", "  return s.chars.each_with_index.with_object(Hash.new(0))\
    \ do |(char,i), h|\n    h[i] += char.upcase if i % 2 == 0\n  end\nend", "  s.length.times\
    \ { |i| return 0 if s[i].upcase == \"A\" } + 1\nend", "  result = 0\n  for i in\
    \ 0...s.length\n    result += (s[i].upcase == 'A' or s[i].upcase == 'E' or s[i].upcase\
    \ == 'I' or s[i].upcase == 'O' or s[i].upcase == 'U')\n  end\n  return result\n\
    end", "  count = 0\n  s.each_index do |i|\n    if s[i] = 'A'\n      count = count\
    \ + 1\n    end\n  end\n  count\nend", "  counts = Hash.new(0)\n  s.each_char do\
    \ |c|\n    if c == 'a'\n      counts[c] += 1\n    elsif c == 'e'\n      counts[c]\
    \ += 2\n    elsif c == 'i'\n      counts[c] += 3\n    elsif c == 'o'\n      counts[c]\
    \ += 4\n    elsif c == 'u'\n      counts[c] += 5\n    elsif c =~ /^[aeiou]/\n\
    \      counts[c] += 2\n    end\n  end\n  counts\nend\ncount_upper('Ruby') #=>\
    \ {\"u\"=>5, \"r\"=>5, \"b\"=>5, \"y\"=>5, \"v\"=>5, \"o\"=>5, \"d\"=>5, \"h\"\
    =>5, \"l\"=>5, \"s\"=>5, \"x\"=>5, \"m\"=>5}\n</cell>\n<cell>", "    s = s.downcase\n\
    \    s.each_char.with_index do |char, index|\n        if index % 2 == 0\n    \
    \        next if char.upcase == \"A\"\n            count = 0\n            char.downcase.scan(/[AEIOU]/)\
    \ do |char|\n                count += 1 if char == \"A\" || char == \"E\" || char\
    \ == \"I\" || char == \"O\" || char == \"U\"\n            end\n        end\n \
    \   end\nend", "    count = 0\n    s.each_char{|c| count += 1 if c == 'A' || c\
    \ == 'E' || c == 'I' || c == 'O' || c == 'U' }\n    count\nend\n</cell>\n<code\
    \ language=ruby-1.9.3-p448>\ncount_upper(\"aAaA\")\n</cell>\n<code language=ruby-1.9.3-p448>\n\
    count_upper(\"aab\")\n</cell>\n<code language=ruby-1.9.3-p448>\ncount_upper(\"\
    abbb\")\n</cell>\n<code language=ruby-1.9.3-p448>\ncount_upper(\"abbbccc\")\n\
    </cell>\n<code language=ruby-1.9.3-p448>\ncount_upper(\"The quick brown fox jumps\
    \ over the lazy dog\")\n</cell>\n<code language=ruby-1.9.3-p448>\ncount_upper(\"\
    The quick brown fox jumps over the lazy DOG\")\n</cell>\n<text>\nCounting characters\
    \ from file", "  count = [0 for _ in 0..(s.length/2)]\n  for i in 0..s.length/2\n\
    \    if s[i] == 'A'\n      count[i%2] += 1\n    end\n  end\n  count\nend", " \
    \ if s.length <= 0\n    0\n  else\n    if s.length % 2 == 1\n      0\n    else\n\
    \      count_upper(s[0..-2].to_s) + count_upper(s[-1..-1].to_s)\n    end\n  end\n\
    end\n</cell>\n<code language=julia-0.6>\ncount_upper(\"abcabcbbca\")\n</cell>\n\
    <code language=julia-0.6>\ncount_upper(\"abcabcbbca\", 2)\n</cell>\n<code language=julia-0.6>\n\
    count_upper(\"abcabcbbca\", 3)\n</cell>\n<text>\nWe have used the + operator above\
    \ to create a recursive function called count_upper. This function has two base\
    \ cases. If the length of the string is less than or equal to 0 then we return\
    \ the value of the function, which is 0, because there is no uppercase vowel in\
    \ the string.", "  s.each_char.with_index do |ch, i|\n    if (i % 2) == 0\n  \
    \    ch.upcase unless ch.eql?('a')\n    end\n  end\nend", "    count = 0\n   \
    \ i = 0\n    while i < s.length\n        if s[i] == ?\n            count += 1\n\
    \        i += 1\n    end\nend", "  result = 1\n  s.gsub(/[aeiou]/) do |char|\n\
    \    if char == 'a'\n      result += 1\n    end\n  end\n  result\nend", "  s.chars.each_with_index.inject([0,0])\
    \ do |(count, char)|\n    char == \"A\" ? (count[0] + 1, count[1]+1) : (count[0]+1,\
    \ count[1])\n  end\nend", "  count = 0\n  for i in 0...s.length\n    if s[i] ==\
    \ s[i].upcase\n      count += 1\n    end\n  end\n  count\nend", "  count = 0\n\
    \  i = 0\n  while i < s.length\n    if s[i].upcase?\n      count += 1\n      i\
    \ += 2\n    else\n      i += 1\n    end\n  end\n  count\nend\n</pre>\n</div>\n\
    <div class=\"paragraph\">\n<p>This is how you might implement it:</p>\n</div>\n\
    <div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"CodeRay highlight\"\
    ><code data-lang=\"clojure\">(<span class=\"keyword\">defn</span> <span class=\"\
    function\">count_upper</span> <span class=\"symbol\">^(</span>s <span class=\"\
    symbol\">)</span> <span class=\"symbol\">(</span>\n  <span class=\"symbol\">(</span>loop\
    \ [count <span class=\"integer\">0</span>]\n    (<span class=\"keyword\">let</span>\
    \ [start (<span class=\"keyword\">char</span> s) end  (<span class=\"keyword\"\
    >char</span> s <span class=\"integer\">1</span>)]\n      (<span class=\"keyword\"\
    >while</span> [start <span class=\"keyword\">not</span> end\n          (<span\
    \ class=\"keyword\">let</span> [newStart (<span class=\"keyword\">char</span>\
    \ start <span class=\"integer\">1</span>)]\n            (<span class=\"keyword\"\
    >if</span> newStart <span class=\"keyword\">not</span> <span class=\"symbol\"\
    >:&gt;</span> end <span class=\"symbol\">:&gt;</span> newStart)\n            (<span\
    \ class=\"keyword\">recur</span> [<span class=\"symbol\">:&gt;</span> newStart]))\n\
    \          (<span class=\"keyword\">let</span> [newEnd (<span class=\"keyword\"\
    >char</span> end <span class=\"integer\">1</span>)]\n            (<span class=\"\
    keyword\">if</span> newEnd <span class=\"keyword\">not</span> <span class=\"symbol\"\
    >:&gt;</span> end <span class=\"symbol\">:&gt;</span> newEnd)\n            (<span\
    \ class=\"keyword\">recur</span> [<span class=\"symbol\">:&gt;</span> newEnd]))]))\n\
    \    (<span class=\"keyword\">if</span> end <span class=\"keyword\">is</span>\
    \ start <span class=\"keyword\">and</span> count <span class=\"keyword\">is</span>\
    \ count <span class=\"keyword\">+</span> <span class=\"integer\">1</span>)\n \
    \   count\n  <span class=\"symbol\">:else</span>\n    count)))</code></pre>\n\
    </div>\n</div>\n<div class=\"paragraph\">\n<p>What if you wanted to return <em>two\
    \ values</em> from a function?  Think of\n<em>returning a pair</em> from a function:</p>\n\
    </div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"CodeRay\
    \ highlight\"><code data-lang=\"clojure\">(<span class=\"keyword\">defn</span>\
    \ <span class=\"function\">return-tuple?</span> [x]\n  (<span class=\"keyword\"\
    >and</span> (<span class=\"keyword\">instance?</span> <span class=\"predefined-constant\"\
    >ThreadLocal</span> <span class=\"symbol\">:p</span>) x))", "    vowels_count\
    \ = 0\n    for i in 0..length(s)\n        if s(i).upcase == s(i)\n           \
    \ vowels_count += 1 \n    end\n    return vowels_count\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI like where you're going, but I suspect that you could do it in\
    \ one line. I think this can be done in 3 lines of code (with a few exceptions)\
    \ but it's probably a lot more confusing for someone who has never seen a language\
    \ that uses `end` as part of an expression.\n<|/ c |>\n<| c |>\n- I think you\
    \ are missing a colon in `for i in 0..length(s)`. The code in your answer will\
    \ work, but `for i in 0..length(s): s(i).upcase == s(i)` will not.\n<|/ c |>\n\
    <| c |>\nI agree with the commenters above that using end/end statements in Ruby\
    \ code is rarely a good idea.  And your answer is pretty similar to mine, but\
    \ I believe it is slightly more efficient as you avoid a loop altogether.  However,\
    \ I agree with your assessment of my code being more confusing than it needs to\
    \ be.\n<|/ c |>\n<| c |>\n- I wasn't trying to be condescending. The more I learn\
    \ about Ruby, the more I agree that using end/end statements is bad practice and\
    \ should be avoided. I'm not convinced it's bad practice in my code either but\
    \ I could see using it in the case of for loops.\n<|/ c |>\n<| c |>\n: I think\
    \ you misread my comment.  I wasn't arguing that the use of end/end is bad practice.\
    \  I was commenting on the use of end/end statements in Ruby code.  I do agree\
    \ that the use of end/end is a code smell, so I do think it's worth explaining\
    \ why it is bad practice.  The only thing I really dislike about your code is\
    \ the lack of proper indentation that prevents someone from understanding your\
    \ intent and maintaining your code. :-)\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n\
    <code>", "  count = 0\n  s.each_index do |i|\n    if s[i] =~ /[AEIOU]/\n     \
    \ count += 1\n    end\n  end\n  count\nend", "    count = 0\n    i = 0\n    while\
    \ i < s.length\n        if s[i] >= 'a' && s[i] <= 'z'\n            count += 1\n\
    \        i += 1\n    return count\nend", "  even = s.scan(/./).select {|x| x =~\
    \ /./} \n  even.inject(0) {|sum, letter| sum += 1 if letter[0].upcase == 'A'}\
    \ \nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=ruby,string,regex |>\n\
    If you wanted to do it in one line, something like this would work:\n<code>\n\"\
    The quick brown fox jumped over the lazy dog\".scan(/[aeiouAEIOU]/i).inject(0)\
    \ { |sum, n| sum + 1 if n == \"A\"}\n</code>\n<|/ a |>\n<| a |>\nHow about this:\n\
    <code>", "  return s.size() - s.gsub(/(.)(?=(.)\\1)(?!\\2)/, \"\\1\\2\").length\n\
    end\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"aBB\")\n</cell>\n\
    <code language=julia-1.6>\n@time count_upper(\"aBB\")\n</cell>\n<code language=julia-1.6>",
  "  s = s.to_s\n  vowels = /[aeiou]/\n  s.chars.each_with_index do |v, i|\n    if\
    \ i % 2 == 0 && vowel =~ v\n      count << i\n    end\n  end\n  count\nend", " \
    \   count = 0\n    for i in 0..s.length - 1\n        if s[i] == s[i]\n       \
    \     count += 1 if i % 2 == 0 end\n        end\n    end\n    return count\nend\n\
    </cell>\n<code language=julia-1.0>\ncount_upper(\"RubberDuck\")\n</cell>\n<code\
    \ language=julia-1.0>\ncount_upper(\"RubberDuck\")\n</cell>\n<text>\nThe map()\
    \ function works like map() from other languages, but in this case it takes a\
    \ function and a vector of values, and applies the function to each element in\
    \ the vector.", "  return s.chars.select { |c| c =~ /[AEIOU]/i }.count\nend",
  "    even = s[0..-2]\n    odd = s[1..-1]\n    odd_ups = even.select { |i| i.upcase\
    \ }\n    even.each_char.count { |i| i.upcase } + odd_ups.count\nend\ncount_upper('hello')\n\
    \  #=> 5 \n</code>\nNote that:\n<code>\n\"hello\".each_char.count { |i| i.upcase\
    \ }\n  #=> 5\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis assumes the string contains\
    \ characters that will be counted. The problem states the string contains no non-ASCII\
    \ characters.\n<|/ c |>\n<| c |>\n: Thanks for the comment.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,regex |>\nHere is an efficient solution. Given a string s and a block,\
    \ this code searches the string s and returns the number of matches to the block.\
    \ First we find all matches to the block and then we count them:\n<code>", " \
    \   return s.scan(/[aeiou]/).size % 2 == 0\nend", "    return s.scan(/[aeiou]/).size\n\
    end", "  s.chars.each_with_index.inject(0) do |sum, (c, i)|\n    i && i % 2 ==\
    \ 0 && sum + 1 if c.upcase == c\n  end\nend", "  return s.size*s.chars.reject(&:odd?).count(&:upcase)\n\
    end", "    count = 0\n    for i in (0...s.length).step(2) do\n        if s[i]\
    \ =~ /[AEIOU]/\n            count += 1\n        end\n    end\n    count\nend",
  "  count = 0\n  s.each_char.with_index do |ch,i|\n    count += 1 if i % 2 == 0 &&\
    \ ch == \"a\"\n  end\n  count\nend", "  (0...s.length).select { |i| s[i].upcase\
    \ =~ /[AEIOUY]/i }.size\nend", "  s.scan(/[aeiouy]/)\nend", "  s.gsub!(/[^aeiouAEIOU]/,\
    \ '')\n  s.scan(/[aeiou]/)\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\n\
    I agree with the first part. I think you need to make the gsub line more succinct\
    \ though, as it's currently not matching the 'Y' or 'N' cases correctly. Something\
    \ like `s.gsub(/[^aeiouYN]/, '')` would do the trick (where Y and N are defined\
    \ as vowels in the question). Also, I'd probably suggest using a case statement\
    \ rather than a hash; something like `s.gsub(/[^aeiouyN]/).map {|s| s.upcase ==\
    \ 'y' ? \"YES\" : \"NO\" }`.\n<|/ c |>\n<| c |>\nThanks Daniel, you're right.\
    \ I edited my answer to reflect the suggestions.\n<|/ c |>\n<| c |>\nThanks for\
    \ the suggestions. I actually did try your method but kept getting a wrong argument\
    \ type error. I guess it might be a ruby version issue with map not being an available\
    \ method on strings. Also tried using map! but that didn't seem to be doing it\
    \ either.\n<|/ c |>\n<| c |>\nI see; I thought you were trying to call `count_upper()`\
    \ on something that is a `String`. The `String` class doesn't have a method named\
    \ `count_upper()`. The `String` class does have a method named `gsub()` that can\
    \ be used to manipulate `String` objects. I changed my answer to use that method.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  s.to_s.chars.each_with_index.inject(0)\
    \ do |acc, (el, i)|\n    if i % 2 == 0 && el == ?A\n      acc + el == ?A ? 1 :\
    \ 0\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI like Ahmed Zeeshan's\
    \ answer, but here is a more terse version that works just as well and doesn't\
    \ rely on #inject:\n<code>", "  count = 0\n  for i in 0...s.length\n    if s[i]\
    \ == 'A'\n      count += 1\n      if s[i] == 'E'\n        count += 1\n       \
    \ if s[i] == 'I'\n          count += 1\n          if s[i] == 'O'\n           \
    \ count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n            count += 1\n            count += 1\n            count\
    \ += 1\n            count += 1\n            count += 1\n            count += 1\n\
    \            count += 1\n            count += 1\n            count += 1\n    \
    \        count += 1\n            count += 1\n            count += 1\n        \
    \    count += 1\n", "  count = 0\n  s[0...].each do |c|\n    next unless c =~\
    \ /[aeiou]/\n    if c =~ /[ei]/\n      count += 1\n    end\n  end\n  count\nend",
  "  s = s[0...s.index('a')]\n  count = 0\n  for i in 0...s.length\n    if s[i] ==\
    \ 'a'\n      count += 1\n    end\n  end\n  return count\nend", "  return s.chars.each_with_index.inject(0){|sum,(v,\
    \ i)| sum+(i%2==0 ? v*2 : v*2+1) }\nend\nprint(count_upper(\"Ruby\"))", "  count\
    \ = 0\n  for i in 0...s.length-1\n    if s[i] >= 'A' && s[i] <= 'Z'\n      count\
    \ += 1\n    end\n  end\n  count\nend\n</cell>\n<cell>\ncount_upper(\"AAbbCC\"\
    )\n</cell>\n<cell>\ncount_upper(\"a\")\n</cell>\n<cell>\ncount_upper(\"Aa\")\n\
    </cell>\n<text>\nThe Ruby Programming Language", "    count = 0\n    for i in\
    \ 0...s.length\n        char = s[i]\n        if isupper(char) && i % 2 == 0\n\
    \            count += 1\n    return count\n</code>\nThe above two functions count\
    \ the vowels in even indices of s.\nIn the following function, I use the function\
    \ above to count the number of vowels in an input string. I use the following\
    \ function to do the check: if (isupper(char) && i % 2 == 0), where I check whether\
    \ the string character at index i is an uppercase vowel.\n<code>", "  return s.scan(/[AEIOU]/).count(0)\
    \ \nend", "    count = 0\n    i = 0\n    while i < s.length\n        el = s[i]\n\
    \        if el == ?U\n            count += 1\n            i += 1\n        end\n\
    \    end\n    count\nend\n</cell>\n<code language=julia-1.0>", "    vowels = \"\
    AEIOU\"\n    count = 0\n    for i in s.chars\n        if vowels.include?(i)\n\
    \            count += 1\n        end\n    end\n    return count\nend", "    count\
    \ = 0\n    # Iterate through each character in s\n    for i in 0...s.length\n\
    \        if s[i].upcase == true\n            count += 1\n    end", "  s.downcase!\
    \ #downcase to avoid counting upper case letters\n  (1..s.length).each do |i|\n\
    \    yield(i) if s[i,1]==='A' || s[i,1]==='a'\n  end\nend\ncount_upper(\"hello\"\
    ) do |i|\n  puts \"Counted #{s[i]}: #{s[i].length} uppercase vowels\"\nend", " \
    \ s = 0\n  for i in 0...s.length\n    ch = s[i]\n    if ch > 'z'\n      s += 0\n\
    \    elsif ch <= 'z'\n      s += 1\n    end\n  end\n  return s\nend", "  return\
    \ s.size*s.size/2\nend\n</cell>\n<cell>\ncount_upper(\"BEE\")\n</cell>\n<cell>\n\
    count_upper(\"ABBC\")\n</cell>\n<cell>\ncount_upper(\"abcd\")\n</cell>\n<cell>\n\
    count_upper(\"abBcD\")\n</cell>\n<text>\nGiven a string and an integer k, return\
    \ a string with at most k uppercase vowels.", "    count = 0\n    for i in (2..s.length-1)\n\
    \        count += s[i].upcase ? 1 : 0\n    return count\nend", "  count = 0\n\
    \  s.each_index do |i|\n    if s[i].upcase == 'A' || s[i].upcase == 'E' || s[i].upcase\
    \ == 'I'\n      count += 1\n    end\n  end\n  count\nend\n</pre>\n</div>\n<h3\
    \ id=\"ruby-operators\">Ruby Operators</h3>\n<p>Ruby has a set of different operators,\
    \ that each operates on something else (like numbers, strings, etc.) so Ruby has\
    \ a bunch of them that allow us to perform various mathematical operations or\
    \ to perform comparisons. Here's what some of them look like:</p>\n<pre>", " \
    \ s.length.times do |i|\n    if i.even?\n      s.slice(i,i).split('').count {\
    \ |char| char.upcase == 'A'} + \n        s.slice(i,i).split('').count { |char|\
    \ char.upcase == 'E'} +\n        s.slice(i,i).split('').count { |char| char.upcase\
    \ == 'I'} +\n        s.slice(i,i).split('').count { |char| char.upcase == 'O'}\
    \ +\n        s.slice(i,i).split('').count { |char| char.upcase == 'U'} \n    end\n\
    \  end\nend", "    count = 0\n    i = 0\n    while i < s.length\n        if s[i]\
    \ =~ /[AEIOU]/\n            count += 1\n        end\n        i += 1\n    end\n\
    \    return count\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the answer! It\
    \ was very helpful :-)\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  return\
    \ s.chars.partition {|c| c.upcase }.size\nend\n</pre>\n          </div>\n    \
    \    </div>\n        <div id=\"test-count-upper\" class=\"runnable\">\n      \
    \    <div class=\"method-header\">\n            <a href=\"#test-count-upper\"\
    \ class=\"method-signature\">\n              <span class=\"method-name\">count_upper</span><span\
    \ class=\"method-args\">()</span>\n            </a>\n          </div>\n      \
    \    <span class=\"method-description\">\n            \n              \n     \
    \         <p>\nGiven a string <code>s</code>, return the number of uppercase vowels\n\
    in even indices.\n</p>\n<p>\n</p>\n              \n              <h4>Arguments</h4>\n\
    \              \n              <ul class=\"method-arguments\">\n             \
    \ \n                <li class=\"method-arguments-item\">\n                  <strong>s</strong>\n\
    \                  \n                  \n                    <div class=\"method-parameters-table\"\
    >\n                      <h4>Parameters</h4>\n                      \n       \
    \               <ul class=\"method-parameters-list\">\n                      \
    \  \n                      </ul>\n                    </div>\n               \
    \   \n                  \n                  \n                  \n           \
    \     </li>\n              \n              </ul>\n              \n           \
    \   \n              <h4>Returns</h4>\n              \n              \n       \
    \       <div class=\"method-source-code\"\n              \n              >\n \
    \               <span class=\"method-name\">count_upper</span><span class=\"method-args\"\
    >()</span>\n              \n              \n              \n              <h4>See\
    \ Also</h4>\n              \n              \n              \n              \n\
    \              \n              \n              \n              \n            \
    \  \n              \n              \n              \n              \n        \
    \      \n              \n              \n              \n              \n    \
    \          \n              \n              \n              \n              \n\
    \              \n              \n              \n              \n            \
    \  \n              \n              \n              \n              \n        \
    \      \n              \n              \n              \n              \n    \
    \          \n              \n              \n              \n              \n\
    \              \n              \n              \n              \n            \
    \  \n              \n              \n              \n              \n        \
    \      \n              \n              \n              \n              \n    \
    \          \n              \n              \n              \n              \n\
    \              \n              \n              \n              \n            \
    \  \n              \n              \n              \n              \n        \
    \      \n              \n              \n              \n              \n    \
    \          \n              \n              \n              \n              \n\
    \              \n              \n              \n              \n            \
    \  \n              \n              \n              \n              \n        \
    \      \n              \n              \n              \n              \n    \
    \          \n              \n              \n              \n              \n\
    \              \n              \n              \n              \n            \
    \  \n              \n              \n              \n              \n        \
    \      \n              \n              \n              \n              \n    \
    \          \n              \n              \n              \n              \n\
    \              \n              \n              \n              \n            \
    \  \n              \n              \n              \n              \n        \
    \      \n              \n              \n              \n              \n    \
    \          \n              \n              \n", "    count = 0\n    for i in 0..s.length\
    \ - 1\n        if s[i].upcase == 'a'\n            count += 1\n    return count\n\
    end", "  return s.scan(/[aeiou]/).size\nend", "    vowels = %w{a e i o u}\n  \
    \  count = 0\n    vowels.each_with_index do |vowel, index|\n        if index&1\
    \ == 0 && vowel.upcase == vowel\n            count += 1\n        end\n    end\n\
    \    count\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for the answer, but\
    \ it doesn't actually answer my question. As I said, my question is about Ruby,\
    \ not Ruby on Rails, and I don't want to use Rails helpers. I'd prefer to figure\
    \ out how to do this in Ruby rather than using a Rails helper. But thanks for\
    \ looking into this.\n<|/ c |>\n<| c |>\nIf you're not using Rails, that's a separate\
    \ question and should be asked in a separate question.\n<|/ c |>\n<| c |>\nI appreciate\
    \ that, I'll ask it separately.\n<|/ c |>\n<| a dscore=0 |>\nI know this thread\
    \ is a little old, but here's a way that uses simple looping:\n<code>", "  if\
    \ s.length == 0\n    0\n  elsif s[0] == 'a'\n    1\n  elsif s[0] == 'e'\n    2\n\
    \  elsif s[0] == 'i'\n    3\n  elsif s[0] == 'o'\n    4\n  elsif s[0] == 'u'\n\
    \    5\n  else\n    0\n  end\nend", "    count = 0\n    for i in 0..(s.length\
    \ - 1)\n        if s[i] >= 'a' and s[i] <= 'z' then\n            if s[i + 1] >=\
    \ 'a' and s[i + 1] <= 'z' then\n                count = count + 1\n          \
    \  end\n        end\n    end\n    return count\nend", "    # code here\nend",
  "    count = 0\n    i = 0\n    while i < s.length do\n        if s[i].upcase ==\
    \ true then\n            count = count + 1\n        end\n        i = i + 1\n \
    \   end\n    return count\nend", "    count = 0\n    index = nil\n    s.length.times\
    \ do |i|\n        if s[i] == 'A'\n            if index\n                count\
    \ += 1\n            end\n            index = 0\n        elsif s[i] == 'E'\n  \
    \          if index\n                count += 1\n            end\n           \
    \ index = 0\n        elsif s[i] == 'I'\n            if index\n               \
    \ count += 1\n            end\n            index = 1\n        elsif s[i] == 'O'\n\
    \            if index\n                count += 1\n            end\n         \
    \   index = 2\n        elsif s[i] == 'U'\n            if index\n             \
    \   count += 1\n            end\n            index = 3\n        else\n       \
    \     index += 1\n        end\n    end\n    count\nend", "  s.gsub(/[aeiou]/i)\
    \ do |e|\n    s.index(e) % 2 == 0 ? 1 : 0\n  end\nend", "  counts = Hash.new(0)\n\
    \  s.chars.each do |char|\n    counts[char] ||= 0\n    counts[char] += 1 if char\
    \ == char.upcase\n  end\n  counts[char] ||= 0\n  counts[char]\nend", "  s.each_char.select\
    \ {|c| c =~ /[AEIOU]/}.count\nend\nprint(count_upper(\"abcde\"))", "  count =\
    \ 0\n  s.each_char.with_index { |c, i| \n    if (i.even?) && c == 'A'\n      count\
    \ += 1\n    end\n  }\n  count\nend\n</cell>\n<code language=julia-1.3>\ncount_upper(\"\
    hello\")\n</cell>\n<text>\nExercise: Write a function that computes the number\
    \ of uppercase letters in a string. Your function should assume that the string\
    \ is ASCII, that is, the only uppercase letters are lowercase letters.", "  count\
    \ = 0\n  s.each_index do |i|\n    if s[i] == s[i].upcase\n      count += 1\n \
    \   end\n  end\n  return count\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n\
    function count_upper(str) {\n    var vowels = str.match(/[aeiou]/g);\n    vowels\
    \ = vowels.replace(/a/g,'');\n    vowels = vowels.replace(/e/g,'');\n    vowels\
    \ = vowels.replace(/i/g,'');\n    vowels = vowels.replace(/o/g,'');\n    vowels\
    \ = vowels.replace(/u/g,'');\n    return vowels.length;\n}\nconsole.log(count_upper(\"\
    asdf\"));\nconsole.log(count_upper(\"ASDF\"));</code>\n<|/ a tags=ruby,string\
    \ dscore=0 |>\n<| a tags=ruby,string |>\n<code>", "    return s.count('a') + s.count('e')\
    \ + s.count('i') + s.count('o') + s.count('u')\nend", "  count = 0\n  for i in\
    \ 0..s.length do\n    if s[i] == 'a' or s[i] == 'e' or s[i] == 'i' or s[i] ==\
    \ 'o' or s[i] == 'u'\n      count += 1\n    end\n  end\n  count\nend", "    vowels=0\n\
    \    for i=2 to length(s) do\n        if s[i-2]='A'or s[i-2]='E'or s[i-2]='I'or\
    \ s[i-2]='O'or s[i-2]='U' then\n            vowels=vowels+1\n        end\n   \
    \ end\n    return vowels\nend", "    count_upper = 0\n    \n    index_of_even\
    \ = 0\n    index_of_odd = 1\n    \n    while index_of_even < s.length\n      \
    \  if s[index_of_even].upcase? && s[index_of_even] != \"I\"\n            count_upper\
    \ += 1\n            index_of_even += 2\n            index_of_odd += 2\n      \
    \  end\n        \n        index_of_even += 2\n        index_of_odd += 1\n    end\n\
    \    \n    index_of_even = 1\n    index_of_odd = 0\n    \n    while index_of_odd\
    \ < s.length\n        if s[index_of_even].upcase? && s[index_of_even] != \"I\"\
    \n            count_upper += 1\n            index_of_even += 1\n            index_of_odd\
    \ += 2\n        end\n        \n        index_of_even += 1\n        index_of_odd\
    \ += 1\n    end\n    \n    count_upper\nend", "  s.chars.each_with_index.inject(0)\
    \ do |sum, (c, i)|\n    sum + c =~ /A|E|I/\n  end\nend", "  s.upcase.gsub(/[aeiou]/,\
    \ '').length\nend\n</pre>\n</div>", "  return s.scan(/[A-Z]/).select { |s| s.odd?\
    \ }.length\nend", "  return s.chars.each.with_object(0) do |(char, count), i|\n\
    \    if i % 2 == 0 && char == char.upcase\n      count += 1\n    end\n  end\n\
    end\n</pre>\n</div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell\
    \ rendered\"><div class=\"prompt input_prompt\">\n</div>\n<div class=\"inner_cell\"\
    >\n<div class=\"text_cell_render border-box-sizing rendered_html\">\n<h2 id=\"\
    Finding-a-Subsequence-of-an-Array\">Finding a Subsequence of an Array<a class=\"\
    anchor-link\" href=\"#Finding-a-Subsequence-of-an-Array\">&#182;</a></h2><p>We'll\
    \ often want to know if a sequence contains a particular substring. For example,\
    \ <code>[\"do\", \"you\", \"see\", \"do\"]</code> contains <code>do</code>, but\
    \ <code>[\"do\", \"you\", \"see\", \"don't\"]</code> doesn't. We'll use a recursive\
    \ approach to solving this problem.</p>\n<p>Let's start with the base case: the\
    \ sequence is a subsequence of the string. For example, the string <code>\"do\"\
    </code> is a subsequence of the string <code>\"do\"</code> and <code>[\"do\",\
    \ \"you\", \"see\", \"do\"]</code>.</p>\n<p>In the base case, we need to check\
    \ if the last element in the string is a subsequence of the array. The recursive\
    \ case will come in the next section.</p>", "  s.scan(/[aeiou]/){ |x| x[0].upcase\
    \ }.size\nend", "  s.scan(/(.)(.)/).map(&:first).map.with_index { |vowel, i| vowel.upcase\
    \ ? 0 : 1 if i % 2 == 0 && vowel.upcase != i }.length\nend", "  count = 0\n  s.each_char\
    \ do |char|\n    char = char.ord if char.ascii_only? # non-ASCII chars become\
    \ ASCII\n    char = char.to_s(16) # char to hex\n    count += 1 if char.upcase\
    \ % 2 == 0\n  end\n  return count\nend\nprint count_upper(\"geeksforgeeks\") #\
    \ => 3\nputs count_upper(\"Python\") # => 6", "   count = 0\n   for i = 0 to s.length\
    \ - 1 step 2\n      if s[i] == 'A' or s[i] == 'E' or s[i] == 'I' or s[i] == 'O'\
    \ or s[i] == 'U'\n         count = count + 1\n   end\nend", "  s = 0\n  s.each_index\
    \ do |i|\n    if s[i,0] =~ /[AEIOU]/\n      s += 1 if s[i,0] =~ /[AEI]/\n    end\n\
    \  end\n  s\nend\nputs count_upper(\"The quick BROWN FOX JUMPS OVER THE LAZY DOG\"\
    )\nputs count_upper(\"The quick brown fox jumps over the lazy dog\")\nputs count_upper(\"\
    The quick BROWN FOX JUMPS OVER THE LAZY DOG\")\nputs count_upper(\"The quick brown\
    \ fox jumps over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps\
    \ over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the\
    \ lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the lazy dog\"\
    )\nputs count_upper(\"The quick brown fox jumps over the lazy dog\")\nputs count_upper(\"\
    The quick brown fox jumps over the lazy dog\")\nputs count_upper(\"The quick brown\
    \ fox jumps over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps\
    \ over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the\
    \ lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the lazy dog\"\
    )\nputs count_upper(\"The quick brown fox jumps over the lazy dog\")\nputs count_upper(\"\
    The quick brown fox jumps over the lazy dog\")\nputs count_upper(\"The quick brown\
    \ fox jumps over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps\
    \ over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the\
    \ lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the lazy dog\"\
    )\nputs count_upper(\"The quick brown fox jumps over the lazy dog\")\nputs count_upper(\"\
    The quick brown fox jumps over the lazy dog\")\nputs count_upper(\"The quick brown\
    \ fox jumps over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps\
    \ over the lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the\
    \ lazy dog\")\nputs count_upper(\"The quick brown fox jumps over the lazy dog",
  "  s, *remainder = s.split # ignore leading and trailing whitespace in s\n  even\
    \ = remainder.each_with_index.map { |x,i| i%2 != 0 }.inject(0) do |sum,v|\n  \
    \  sum + (v && v == 'a' ? 1 : 0)\n  end\nend\ncount_upper('abbbcdb') #=> 2\ncount_upper('abbbcbb')\
    \ #=> 0", "  s = 0\n  s.upcase! # force conversion\n  s.each_index { |i| s +=\
    \ 1 if s[i] == s[i].upcase }\n  s\nend\ncount_upper \"aeiou\"", "  s.each_char.with_object(Hash.new(0)){|c,\
    \ h| h[c] +=1}.\n  select {|k,v| k.upcase % 2 == 0}.size\nend", "  counter = 0\n\
    \  s.each_char.with_index { |c,i| if i.even? && c.upcase == \"A\" then counter\
    \ += 1 end }\n  counter\nend", "  s.each_index do |i|\n    if s[i] =~ /[aeiou]/\n\
    \      next if i % 2 == 0\n      count_upper s[i..-1]\n    end\n  end\n  s.count(\"\
    A\"..\"Z\")\nend", " count = 0\n i = 0\n while i < s.length\n  i += 1\n  if (s[i]\
    \ >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')\n   count += 1\n  end\n\
    \ end\n count\nend", "    count = 0\n    i = 0\n    while i < s.length\n     \
    \   if s[i].upcase == true\n            count = count + 1\n        i += 1\n  \
    \  end\n    return count\nend", "    return s.count { |c| c == 'A' || c == 'E'\
    \ || c == 'I'}\nend", "   count = 0\n   for i in 0..length(s-1)\n      if s[i]\
    \ < 'A' || s[i] > 'Z'\n         break\n      if s[i] > 'A' && s[i] < 'Z'\n   \
    \      count += 1\n      end\n   end\n   count\nend", "    count = 0\n    i =\
    \ 1\n    while i < s.length\n        upper = true\n        while i < (s.length\
    \ - 1) && s[i] > s[i]\n            upper = false\n            i += 1\n       \
    \ count += 1  if upper\n        i += 1\n    end\n    count\nend", "  s = s[0].downcase\n\
    \  count = 0.upto(0..length(s), 2).inject(0) {|sum, (i, j)| sum + s[i..j].to_i\
    \ == s[i].upcase ? 1 : 0}\nend", "  i = 0\n  count_upper = 0\n  while i < s.length\n\
    \    if s[i] == \"A\" || s[i] == \"E\" || s[i] == \"I\" || s[i] == \"O\" || s[i]\
    \ == \"U\"\n      count_upper += 1\n    i += 1\n  end\n  return count_upper\n\
    end", "    count = 0\n    index = 0\n    while index <= s.length - 2\n       \
    \ if s[index].upcase == s[index + 1].upcase\n            count+=1\n        index\
    \ += 1\n    return count\nend", "  count = 0\n  s.split('').each do |c|\n    if\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n      count += 1\n\
    \    end\n  end\n  count\nend", "  vowels = Hash.new(0)\n  (0...s.length).each\
    \ do |i|\n    case s[i]\n    when 'a', 'e', 'i', 'o', 'u'\n      vowels[i] +=\
    \ 1\n    end\n  end\n  vowels.reject{|k, v| k > v}\nend\nprint count_upper(ARGF.read).to_a.inspect\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nAh, I see. I didn't realize `Hash`\
    \ had a default value of 0. I thought it always had to have a default value. Thanks!\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=2 |>\nHere's a solution using inject:\n\
    <code>", "    # Initialize your counter here.\n    count = 0", "  if s.length\
    \ <= 0\n    return 0\n  even = 0\n  odd = 0\n  for i in 0..length\n    if s[i]\
    \ >= 'a' && s[i] <= 'z'\n      even += 1\n    elsif s[i] >= 'A' && s[i] <= 'Z'\n\
    \      odd += 1\n    end\n  end\n  return even + odd\nend", "  s.each_char.with_index\
    \ { |c,i| return i if c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\
    \ }\n  nil\nend", "    count = 0\n    i = s.length - 1\n    while i >= 0 and s[i]\
    \ >= 'A' && s[i] <= 'Z'\n        i -= 1\n    end\n    while i >= 0 and s[i] >=\
    \ 'a' && s[i] <= 'z'\n        i -= 1\n    end\n    i = s.length - 1\n    while\
    \ i >= 0 and s[i] >= '0' && s[i] <= '9'\n        i -= 1\n    end\n    while i\
    \ >= 0 and s[i] >= 'A' && s[i] <= 'Z'\n        count += 2\n        i -= 1\n  \
    \  end\n    while i >= 0 and s[i] >= 'a' && s[i] <= 'z'\n        count += 2\n\
    \        i -= 1\n    end\n    return count\nend", "  # +++your code here+++\n\
    end\n</pre>", "  s.downcase! # make sure s is a String object\n  (s[/[aeiou]/i]\
    \ * 1).count {|x| x.eql? 'A'}\nend", "  count = 0\n  s.each_char do |char|\n \
    \   if char.upcase == 'A'\n      count += 1\n    end\n  end\n  count\nend", " \
    \  s.count(\"AEIOU\")\nend", "  count = 0\n  for i in 0...s.length do\n    if\
    \ s[i] == 'a' or s[i] == 'e' or s[i] == 'i' or s[i] == 'o' or\n        s[i] ==\
    \ 'u'\n      count += 1\n    end\n  end\n  count\nend\nputs count_upper(\"abcde\"\
    )", "    s = s.downcase\n    count = 0\n    index = 0\n    while index < s.length\n\
    \        index += 1\n        if s[index].upcase == true\n            count +=\
    \ 1\n    return count\nend", "    count = 0\n    i = s.length\n    while i >=\
    \ 0 and s[i] >= 'A' and s[i] <= 'Z'\n        count = count + 1\n        i -= 1\n\
    \    return count\nend", "    count = 0\n    for i in (0...s.length-1)\n     \
    \   if s[i].upcase == s[i]\n            count += 1\n    end\n    return count\n\
    end", "  count = 0\n  s.each_char.with_index do |c| \n    if c == 'A' || c ==\
    \ 'E' || c == 'I'\n      count += 1\n    end\n  end\nend\ncount_upper(\"hi there\"\
    )\n  #=> 3\ncount_upper(\"Ahha\")\n  #=> 1\ncount_upper(\"abBac\")\n  #=> 2\n\
    count_upper(\"Hellho\")\n  #=> 4\ncount_upper(\"Oh oh oh\")\n  #=> 0\ncount_upper(\"\
    heLLo\")\n  #=> 4\ncount_upper(\"Yay\")\n  #=> 2\ncount_upper(\"AaA\")\n  #=>\
    \ 0\ncount_upper(\"aA\")\n  #=> nil\ncount_upper(\"\")\n  #=> nil\ncount_upper(\"\
    \ \")\n  #=> nil\ncount_upper(\"AA \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=>\
    \ nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\n\
    count_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"\
    AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \"\
    )\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=>\
    \ nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\n\
    count_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"\
    AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \"\
    )\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=>\
    \ nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\n\
    count_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"\
    AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \"\
    )\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=>\
    \ nil\ncount_upper(\"AA   \")\n  #=> nil\ncount_upper(\"AA   \")\n  #=> nil\n\
    count_upper(\"AA   \")\n  #", "  s = 0\n  s.upcase.to_s.length.times do |i|\n\
    \    s += 1 if s[0,i].upcase == \"a\"\n    s += 1 if s[0,i].upcase == \"e\"\n\
    \    s += 1 if s[0,i].upcase == \"i\"\n    s += 1 if s[0,i].upcase == \"o\"\n\
    \    s += 1 if s[0,i].upcase == \"u\"\n  end\n  s\nend\n</cell>\n<cell>\nputs\
    \ count_upper(\"abcdeeefghijklmnopqrstuvwxyz\")\nputs count_upper(\"aeiouy\")\n\
    </cell>\n<cell>", "  return s.each_char.with_index.reduce(0) {|i,x|\n    x.upcase\
    \ == i\n  }\nend", "    count = 0\n    for (i,c) in enumerate(s):\n        if\
    \ c == 'A' or c == 'a':\n            count += 1\n            if i%2 == 0 and s[i-1:i+2]\
    \ != 'AEIOUaeiou':\n                count += 1 \n    return count", "  return\
    \ s.each_char.count { |c| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c ==\
    \ 'U' }\nend", "  uppers = 0\n  (0...s.length).each do |i|\n    uppers += 1 if\
    \ s[i] == s[i].upcase\n  end\n  uppers\nend\n</code>\nThe second one is much easier,\
    \ we just need to loop through the string once:\n<code>", "    # Write your code\
    \ here.\n    count=0\n    for i in s[::2]:\n        if i==\"A\" or i==\"E\" or\
    \ i==\"I\" or i==\"O\" or i==\"U\":\n            count+=1\n    return count\n\
    print(count_upper(\"python\"))\nprint(count_upper(\"java\"))\n</cell>\n<cell>",
  "  s.scan(/[AEIOU]/)\nend\nprint count_upper(\"Hello World\")", "    count = 0\n\
    \    (0..length(s)) do |i|\n        char = s[i]\n        if char.upcase == 'A'\n\
    \            count += 1\n        end\n    end\n    count\nend", "  count = 0\n\
    \  s.each_index do |i|\n    if s[i] =~ /[AEIOU]/\n      if i % 2 == 0\n      \
    \  count += 1\n      end\n    end\n  end\n  count\nend", "  s.downcase!\n  s.each_char.with_index\
    \ { |c,i| return 1 if i % 2 == 0 and c == 'A' }\n  0\nend\nputs count_upper(\"\
    AABBCCDE\")", "    count = 0\n    i = 0\n    while i < s.length\n        curr_char\
    \ = s[i]\n        if curr_char == 'A'\n            count += 2\n            i +=\
    \ 1\n        else\n            count += 1\n            i += 1\n    end\n    count\n\
    end\n</cell>\n<code language=julia-1.5>\ncount_upper(\"AAAAbbbbAAAADDDD\")\n</cell>\n\
    <text>\n(Exercise) Write a function that returns the count of uppercase vowels\
    \ in all the words in the string s.", "    return s.count(\"A\")+s.count(\"E\"\
    )+s.count(\"I\")+s.count(\"O\")+s.count(\"U\")\nend", "  vowels.select { |vowel|\
    \ s[0...vowel.size] == 'aeiou' }.count\nend\n</pre>", "  return s.scan(/[aeiou]\\\
    z/).size\nend", "  s.each_char.with_index do |c, i|\n    next if i % 2 == 0\n\
    \    next if c != \"A\" && c != \"E\" && c != \"I\" && c != \"O\" && c != \"U\"\
    \n    next unless c == \"A\" || c == \"E\" || c == \"I\" || c == \"O\" || c ==\
    \ \"U\"\n    next if c.upcase != c\n    yield(c, i)\n  end\nend", "  # Return\
    \ the number of times you can see 'U' between any pair of vowels.\n  # You may\
    \ assume the string contains at least three characters.\n  count=0\n  for i in\
    \ 1..s.length-1\n    if s[i]=='A' || s[i]=='E' || s[i]=='I' || s[i]=='O' || s[i]=='U'\n\
    \      count += 1\n    end\n  end\n  return count\nend", "  s = s[0...-1] # remove\
    \ \"e\" from str\n  return s.chars.map(&:upcase).count(&:odd?)\nend\n</code>\n\
    And now we can easily count the number of uppercase vowels:\n<code>\n> count_upper(\"\
    ebb\")\n1\n</code>\n<|/ a tags=ruby |>\n<| a dscore=3 |>\nI came up with this:\n\
    <code>", "    count = 0\n    i = 0\n    while i < s.length\n        if s[i] =~\
    \ /[A-Z]/\n            count += 1\n            i += 2\n        else\n        \
    \    i += 1\n        end\n    end\n    count\nend", "    s.gsub!(/[^aeiou]/,'')\n\
    \    s.length.times do |i|\n        if s[i] =~ /[AEIOU]/\n            s[i] +=\
    \ 1\n        end\n    end\n    return s\nend", "  upper = 0\n  for i in 0 ...\
    \ s.length - 1 do\n    if s[i] == 'U' then upper += 1\n  end\n  return upper\n\
    end", "    count = 0.0\n    s.each_char.with_index do |char, i|\n        count\
    \ = count + 1 if char.upcase == char\n    end\n    count\nend\n</cell>\n<code\
    \ language=julia-1.4>\n@code_warntype count_upper(\"hello\")\n</cell>\n<text>\n\
    Challenge - Write a function that returns the length of the longest word in the\
    \ string s (after removing all non-letter characters).", "    count = 0\n    s.each_char\
    \ {|c| if c =~ /[aeiou]/ && c =~ /u/; count += 1; end}\n    count\nend\n</cell>\n\
    <code language=julia-0.4>", "  count = 0\n  for i in 0...s.length-1\n    if s[i]\
    \ == \"a\"\n      count += 1 unless s[i+1] == \"A\"\n    end\n  end\n  count\n\
    end", "  s.chars.each.with_index do |letter, index|\n    letter.upcase if index\
    \ % 2 == 0\n  end\nend", "  evens = []\n  i = 0\n  while i < s.length\n    if\
    \ s[i] != s[i + 1]\n      evens.push(s[i:i + 2])\n    end\n    i += 1\n  end\n\
    \  evens.count('AEIOU')\nend", "  count = 0\n  s.each_index do |i|\n    if s[i]\
    \ == s[i].upcase\n      count += 1\n    end\n  end\n  count\nend", "  s.length.times.reduce(0)\
    \ { |s, i| s + i.odd? ? 1 : 0 }\nend", "  s.to_s.scan(/[aeiou]/) do |s|\n    if\
    \ $even?\n      s.to_s.split('').reject(&:empty?).count('AEIOU')\n    end\n  end\n\
    end", "  s.chars.each_with_index { |c, i| return i if c == 'A' || c == 'E' ||\
    \ c == 'I' || c == 'O' || c == 'U' }\n  nil\nend\n</code>\nThe each_with_index\
    \ method iterates over each character in the string and gives the character and\
    \ the index. Since we're only interested in even indices, the return statement\
    \ is executed if the character is uppercase and the index is even. Otherwise the\
    \ method returns nil.\n<|/ a tags=ruby |>\n<| c |>\nHe said he wants the vowels\
    \ only when it is even, i.e. `'aeiou'` => `'i', 0`.\n<|/ c |>\n<| a dscore=0 tags=ruby\
    \ |>\nHere's a way to get the string containing the vowels from a string containing\
    \ only characters:\n<code>\ns = 'aeiou'\nvowels = s[/[aeiou]/]\n</code>\nvowels\
    \ will be the string containing the vowels of the string s. \nIf you want to count\
    \ the number of vowels use s.count instead of vowels.count.\n<|/ a |>\n<| c |>\n\
    `vowels.count` should be `s.count` (I think)\n<|/ c |>\n<| c |>\nOops. Thanks\
    \ for noticing it.\n<|/ c |>\n<| a dscore=0 |>\nMy solution:\n<code>", "  vowels\
    \ = %w[a e i o u]\n  s.each_char.with_index do |c,i|\n    if i % 2 == 0 then vowels.count\
    \ { |vowel| c == vowel } else false end\n  end\nend\n</cell>\n<cell>", "  count\
    \ = 0\n  for i in (0 .. s.length - 1).step(2) do\n    if s[i] == \"A\" or s[i]\
    \ == \"E\" or s[i] == \"I\" or s[i] == \"O\" or s[i] == \"U\" then\n      count\
    \ += 1\n    end\n  end\n  return count\nend", "    vowels = Hash.new(0)\n    vowels[s[/[aeiou]/]]\
    \ += 1\n    vowels[s[/[AEIOU]/]] += 1\n    vowels[s[/[^aeiou]/]] += 1\n    vowels[s[/[^AEIOU]/]]\
    \ += 1\n    return vowels\nend", "    # Write your code here.\n  end", "    s.scan(/(.)\\\
    1*/) { $1 % 2 == 0 }\nend", "    vowels = \"AEIOU\"\n    even_indexes = 0..s.size/2\
    \ #even indices\n    count = 0..s.size/2\n    even_indexes.each do |i|\n     \
    \ count += 1 if s[i].upcase == vowels[i] #count all vowels with even indices\n\
    \    end\n    count\nend\n</code>\n<code>\ncount_upper(\"The quick brown fox jumps\
    \ over the lazy dog\") #=> 6\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays dscore=1\
    \ |>\n<| a dscore=1 |>\nA more Rubyish solution would be to use regex to check\
    \ the string with something like:\n<code>\n\"The quick brown fox jumps over the\
    \ lazy dog\".match(/[aeiou]/i).count { |e| e == \"e\" } #=> 6\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails,arrays |>\n<| a |>\nHere is another one:\n<code>\na\
    \ = \"The quick brown fox jumps over the lazy dog\"\na.scan(/[aeiou]/).select\
    \ { |x| x.to_s.size == 1 }.count #=> 6\n</code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails,arrays\
    \ |>\n<| c |>\n`x.to_s` is redundant.\n<|/ c |>\n<| c |>\nYou're right, removed\
    \ it.\n<|/ c |>\n<| c |>\nThanks, I didn't know that.\n<|/ c |>\n<| c |>\nYour\
    \ solution does not work properly if the string has more than one uppercase vowel.\n\
    <|/ c |>\n<| c |>\nYeah, I realized that after I posted it.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is another solution:\n<code>\n\"The quick brown fox jumps over the\
    \ lazy dog\".scan(/[aeiou]/).map(&:first).count { |e| e.size == 1 }\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,arrays |>\n<| c |>\nThanks so much! And yes, it\
    \ works with more than one vowel.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays\
    \ dscore=0 |>\n<code>\nstr = \"The quick brown fox jumps over the lazy dog\"",
  "  # +++your code here+++\n  vowels = Set.new\n  s.each_char do |ch|\n    if vowels.include?\
    \ ch\n      vowels.delete ch\n    else\n      vowels.add ch\n    end\n  end\n\
    \  vowels.size\nend", "  n = 0\n  i = s.length - 1\n  while i > 0\n    if s[i-1]\
    \ == ?U\n      n += 1 if i % 2 == 0\n      i -= 1\n    end\n    i -= 1\n  end\n\
    \  n\nend", "  return s.size/2\nend", "  return s.length.times.with_object(Hash.new(0)){|i,h|\
    \ h[i..i+2] += 1 if s[i] =~ /[aeiou]/}\nend\n</cell>\n<code language=ruby-1.9.3-p448>\n\
    count_upper(\"hello\")\n</cell>\n<text>\nExercises", "    count = 0\n    for i\
    \ = 2..s.length\n        if s[i].upcase == s[i-1].upcase\n            count +=\
    \ 1\n    end\n    return count\nend", "  # +++your code here+++\n  return s\n\
    end", "  return s.upcase.length s.count(/[aeiou]/, 2) s.count(/[aeiou]/, 3)\n\
    end\n  ", "  return s.count(\"A\"..\"Z\") + (s.count(\"a\"..\"z\") - s.count(\"\
    A\"..\"Z\") * 2)\nend\n</code>\nWe can then solve your problem with this function\
    \ as:\n<code>\ncount_upper(\"geeksforgeeks\")", "    count = 0\n    s.chars.each_with_index\
    \ do |char, i|\n        if i % 2 == 0 and char == ?A\n            count += 1\n\
    \        end\n    end\n    count\nend", "    s.length\n    s.count{|c| c=='A'\
    \ || c=='E' || c=='I' || c=='O' || c=='U'}\nend\nputs count_upper('aabbcdd')\n\
    puts count_upper('aabbEdd')\nputs count_upper('aabbEeD')\nputs count_upper('aabbEeD')\n\
    puts count_upper('aabbEeD')", "  s.gsub(/[^aeiou]/) do |x|\n    ((0...2).find\
    \ {|i| (s[i..i].downcase == s[i..i].upcase) } || -1) + 1\n  end\nend", "    count\
    \ = 0\n    for x in s\n        if x==\"a\"\n            count+=1\n        if x==\"\
    e\"\n            count+=1\n        if x==\"i\"\n            count+=1\n       \
    \ if x==\"o\"\n            count+=1\n        if x==\"u\"\n            count+=1\n\
    \    return count", "    return s.scan(/[aeiou]/i).count(true) if s.is_a? String\n\
    \    return 0\nend", "    # Write your implementation here.\n    # raise NotImplementedError",
  "  even_indexes = []\n  for i in (0...s.length)\n    if s[i..].include?('AEIOU')\n\
    \      even_indexes << i\n    end\n  end\n  even_indexes.count\nend", "  count\
    \ = 0\n  s.downcase!\n  s.each_index { |i| count += s[i] =~ /[AEIOU]/i }\n  count\n\
    end\n</cell>\n<code language=julia-1.5>\ncount_upper(\"Julia\")\n</cell>\n<code\
    \ language=julia-1.5>\ncount_upper(\"Julia\") < count_upper(\"JuliaB\")\n</cell>\n\
    <code language=julia-1.5>\ncount_upper(\"julia\") < count_upper(\"juliaB\")\n\
    </cell>\n<code language=julia-1.5>\ncount_upper(\"Julia\") < count_upper(\"JuliaB\"\
    )\n</cell>\n<text>\nStrings use Unicode by default", "  result = 1\n  s.scan(/[aeiou]/){\
    \ |e| result += (e =~ /[aeiou]/i).zero? ? 0 : 1 * e }\n  return result\nend\n\
    puts count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"ahojahojahoja\")\
    \ #=> 0\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"ahojahojahoja\") #=> 0\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"ahojahojahoja\") #=> 0\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"ahojahojahoja\"\
    ) #=> 0\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"ahojahojahoja\") #=> 0\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\"\
    ) #=> 6\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"ahojahojahoja\"\
    ) #=> 0\nputs count_upper(\"AHOJAHOJAHOJ\") #=> 6\nputs count_upper(\"", "  s\
    \ = s.split('')\n  even = s.select.with_index{|_, i| i % 2 == 0 }\n  even.inject(0){|sum,\
    \ e| sum + e.to_s.length if e.to_s.upcase == 'A'}\nend", "   count = 0\n   for\
    \ i in (0...s.length)\n      count += s[i] == \"A\" || s[i] == \"E\" || s[i] ==\
    \ \"I\" || s[i] == \"O\" || s[i] == \"U\"\n   end\n   return count\nend\n</cell>\n\
    <cell>", "  if s.length < 2\n    return 0\n  a = s.chars.to_a\n  (0...s.length).each\
    \ do |i|\n    next if a[i] != 'A' || a[i+1] != 'A'\n    if i % 2 == 0\n      a[i]\
    \ = 'A'.ord\n      a[i+1] = 'A'.ord\n      a[i + 2] = 'A'.ord\n      a[i + 3]\
    \ = 'A'.ord\n    end\n  end\n  a.inject(0) do |sum, a|\n    sum + a\n  end\nend",
  "    vowels = 'AEIOUYaeiouy'\n    evens = [None] * len(s)\n    i = 0\n    while\
    \ i < len(s):\n        if s[i] in vowels:\n            evens[i : i + 2] = [s[i]]\n\
    \        i += 1\n    return sum(1 for x in evens if x is not None)", "    count\
    \ = 0\n    (0..s.length).each do |i|\n        next if s[i].upcase == '_'\n   \
    \     count += 1\n    end\n    return count\nend\nprint count_upper('rabbit loves\
    \ Python!')", "  count = 0\n  for i in 0...s.length\n    if s[i] =~ /[AEIOU]/i\n\
    \      count += 1\n    end\n  end\n  count\nend", "  return 0\nend", "    i =\
    \ 0\n    while i < s.length\n        if s[i] =~ /[AEIOU]/\n            i += 1\
    \ # increment i by 1\n        end\n        i += 1\n    end\n    \n    return i\n\
    end\n</cell>\n<code language=julia-1.0>\ncount_upper(\"ABcb\")\n</cell>\n<code\
    \ language=julia-1.0>\ncount_upper(\"abc\")\n</cell>\n<code language=julia-1.0>\n\
    count_upper(\"AaBc\")\n</cell>\n<text>\n4.5 String functions\nJulia's string type\
    \ provides many useful string operations.", "  return s.upcase.chars.count(&:even?)\n\
    end", "\ts.each_index {|i| s[i] <= 'z' ? return false : s[i].upcase }\n\ts.count('Z')\
    \ - (s.count('z') - 1)\nend", "    count = 0\n    for i in 0..length(s):\n   \
    \     if s[i] == ?\n            count += 1\n        end\n    end\n    return count\n\
    end\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"Hello\")\n</cell>\n\
    <code language=julia-1.6>\n@time count_upper(\"HellO\")\n</cell>\n<code language=julia-1.6>\n\
    @time count_upper(\"Hello\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"\
    HellO\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"Hello\")\n</cell>\n\
    <code language=julia-1.6>\n@time count_upper(\"HellO\")\n</cell>\n<code language=julia-1.6>\n\
    @time count_upper(\"Hello\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"\
    HellO\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"Hello\")\n</cell>\n\
    <code language=julia-1.6>\n@time count_upper(\"HellO\")\n</cell>\n<code language=julia-1.6>\n\
    @time count_upper(\"Hello\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"\
    HellO\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"Hello\")\n</cell>\n\
    <code language=julia-1.6>\n@time count_upper(\"HellO\")\n</cell>\n<code language=julia-1.6>\n\
    @time count_upper(\"Hello\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"\
    HellO\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"Hello\")\n</cell>\n\
    <code language=julia-1.6>\n@time count_upper(\"HellO\")\n</cell>\n<code language=julia-1.6>\n\
    @time count_upper(\"Hello\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"\
    HellO\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"Hello\")\n</cell>\n\
    <code language=julia-1.6>\n@time count_upper(\"HellO\")\n</cell>\n<code language=julia-1.6>\n\
    @time count_upper(\"Hello\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"\
    HellO\")\n</cell>\n<code language=julia-1.6>\n@time count_upper(\"Hello\")\n</cell>\n\
    <code language=julia-1.6>\n@time ", "    count = 0\n    for i in range(len(s)/2)\n\
    \        if s[i].upcase == s[i].downcase\n            count += 1\n    return count\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't handle the case where the string is length\
    \ 0\n<|/ c |>\n<| c |>\nAh thank you for that. Yes I guess I didn't account for\
    \ the empty string. I'll update my answer.\n<|/ c |>\n<| c |>\nI fixed a typo.\
    \ I missed a bracket. Can you check now?\n<|/ c |>\n<| a tags=ruby dscore=0 |>\n\
    The previous answers use upcase and downcase. But what if the string contains\
    \ Unicode characters? For example, a Japanese string. Or perhaps an emoji? In\
    \ such cases the upcase or downcase would not return the correct result. I would\
    \ like to have something more generic. \n<code>", "    count = 0\n    s.each_char\
    \ do |c|\n        count += 1 if c == c.upcase\n    end\n    count\nend", "   \
    \ count = 0\n    for i in 0...s.length\n        if s[i] == 'A' || s[i] == 'E'\
    \ || s[i] == 'I'\n            count += 1 \n    return count\n</code>\n<|/ a tags=python,ruby\
    \ |>\n<| c |>\nHow does this answer \"count the number of uppercase vowels in\
    \ even indices.\"?\n<|/ c |>\n<| c |>\nBecause it counts them in even indices\
    \ starting from zero and counts the number of uppercase vowels.\n<|/ c |>\n<|\
    \ c |>\nThe question specifically says: \"The function must count the number of\
    \ uppercase vowels in even indices in the string...\"\n<|/ c |>\n<| c |>\nI see.\
    \ Didn't realize it was a vowel counting problem. Sorry.\n<|/ c |>\n<| a dscore=1\
    \ |>\nYou could try this in Ruby with Enumerable:\n<code>\nstr = 'abBcCdDe'\n\
    str.chars.map{|c| c}.uniq.count { |c| c == 'A' || c == 'E' || c == 'I'}\n</code>\n\
    This returns:\n<code>\n4\n</code>\n<|/ a tags=python,ruby |>\n<| c |>\nYour code\
    \ does not count the number of uppercase vowels in even indices. It counts them\
    \ in even indices starting from zero and counts the number of uppercase vowels.\n\
    <|/ c |>\n<| c |>\nAh I see, thanks for pointing that out! I didn't realize the\
    \ \"even\" part was part of the problem.\n<|/ c |>\n<| a tags=python,ruby |>\n\
    In Ruby 1.9\n<code>\ns = 'abBcCdDe'\ns.split(//).uniq.reduce(0){|n,s| n+=s.count(\"\
    AEIOUaeiou\")}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNotice that this will return\
    \ 1 for \"aeiou\", not zero, since `'aeiou'.count('a') == 1, 'aeiou'.count('e')\
    \ == 1, 'aeiou'.count('i') == 1, 'aeiou'.count('o') == 1, 'aeiou'.count('u') ==\
    \ 1`\n<|/ c |>\n<| c |>\nSorry, I missed that in the question. Thanks for pointing\
    \ out the error and for the answer!\n<|/ c |>\n<| a dscore=0 |>\nPython:\n<code>\n\
    s = \"abBcCdDe\"\nprint sum([1 if 'A' in s[i] or s[i] == 'E' or s[i] == 'I' else\
    \ 0 for i in ", "  count = 0\n  for i in 0...s.length-1\n    if s[i] == \"A\"\
    \ || s[i] == \"E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\"\n      count\
    \ += 1\n    end\n  end\n  count\nend\n</cell>\n<cell>\ncount_upper(\"hello\")\n\
    </cell>\n<cell>\ncount_upper(\"hELLO\")\n</cell>\n<cell>\ncount_upper(\"hEllO\"\
    )\n</cell>\n<cell>\ncount_upper(\"heLlo\")\n</cell>\n<text>\nWrite a method that\
    \ checks whether all characters in a string are lowercase letters.", "    s =\
    \ s.upcase\n    counts = Hash.new(0)\n    s.each_char {|c| counts[c] += 1 if c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' }\n    counts['A']\n\
    end\n</cell>\n<code language=julia-1.0>\ncount_upper(\"BACD\")\n</cell>\n<code\
    \ language=julia-1.0>", "  # +++ TODO +++\nend", "  s.split.map do |char|\n  \
    \  if char == char.upcase\n      char.count(\"a\") % 2 == 0 ? char.upcase : nil\n\
    \    end\n  end.reduce(:+)\nend", "    even = []\n    index = 0\n    vowels =\
    \ \"AEIOU\"\n    while index < s.length\n        char = s[index]\n        if char\
    \ =~ /[aeiou]/\n            if $even.include?(char)\n                even += [index]\n\
    \            else\n                even += [$char]\n            end\n        end\n\
    \        index += 1\n    end\n    even_count = even.length\n    uppercase_vowels\
    \ = 0\n    for index in even\n        uppercase_vowels += $vowels.count($vowels.slice(index,\
    \ index + 1))\n    end\n    uppercase_vowels *= even_count\n    return uppercase_vowels\n\
    end", "    count = 0\n    i = 0\n    while i < s.length\n        if s[i] == ?\n\
    \            count += 1\n            i += 2\n        end\n        i += 1\n   \
    \ end\n    return count\nend", "    count = 0\n    (0...s.length).each do |i|\n\
    \        if s[i] == \"A\" or s[i] == \"E\" or s[i] == \"I\" or s[i] == \"O\" or\
    \ s[i] == \"U\"\n            count += 1\n        end\n    end\n    return count\n\
    end\n</code>\nThe last part is quite easy, we just need to test if s[i] == \"\
    A\" or s[i] == \"E\" or s[i] == \"I\" or s[i] == \"O\" or s[i] == \"U\".\n<|/\
    \ a |>\n<| a tags=ruby |>\n<code>", "    count = 0\n    for i in 0...s.length\n\
    \        if (s[i] =~ /[AEIOU]/)\n            count += 1\n    end\n    return count\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
