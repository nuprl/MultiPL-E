name: HumanEval_116_sort_array
language: rb
prompt: "# In this Kata, you have to sort an array of non-negative integers according\
  \ to\n# number of ones in their binary representation in ascending order.\n# For\
  \ similar number of ones, sort based on decimal value.\n# It must be implemented\
  \ like this:\ndef sort_array(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n\
  \    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1,\
  \ 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3,\
  \ -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n\
  \    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5,\
  \ 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32,\
  \ 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2,\
  \ 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8,\
  \ 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"
completions: ["  arr.sort! do |x,y|\n    if x == 0\n      y\n    elsif y == 0\n  \
    \    x\n    elsif (x & y) > 0\n      x - y\n    elsif (x & y) < 0\n      y - x\n\
    \    else\n      y - x\n    end\n  end\nend", "  sorted = []\n  n = arr.length\n\
    \  max_ones = arr.max\n  min_ones = arr.min\n  while max_ones - min_ones > 0\n\
    \    sorted = sorted + [max_ones] * max_ones\n    sorted = sorted + [min_ones]\
    \ * (max_ones - min_ones)\n    sorted = sorted.sort\n    max_ones -= 1\n    min_ones\
    \ -= 1\n  return sorted + [min_ones] * (max_ones - min_ones)\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,sorting |>\nAnother way to think about it is the following\
    \ (also assuming the number are integers less than 2,147,483,647):\n<code>", " \
    \ # implement here\nend", "  return arr.sort{|a, b| [b, a] <=> [a, b]}.map{|x|\
    \ -x.to_i}\nend\n</cell>\n<cell>", "  # Write your code here.\nend", "  ones =\
    \ arr.count(1)\n  decimal = arr.map(&:to_i).inject(0) {|sum,x| sum + x}\n  sorted\
    \ = arr.sort_by do |x|\n    (-x).abs == x ? 1 : (x.to_i * 100).to_i < decimal\
    \ ? -1 : -1\n  end\n  sorted.map(&:to_i)\nend", "  # arr will be an array of integers.\n\
    \  # If there is no non-negative integer in array, return nil.\n  # Otherwise,\
    \ sort arr according to number of ones in its binary representation.\nend", " \
    \   return arr\nend", "  arr.sort!\nend\n</pre>\n          </li>\n        </ol>\n\
    \        <h2><a id=\"bonus\" href=\"#bonus\" class=\"section-anchor\"></a>Bonus</h2>\n\
    \        <p>Now you can solve this Kata and create your first Ruby programs.</p>\n\
    \        <p>The next Kata will provide an example of how you can solve this problem\n\
    \        using Ruby.</p>\n        <ol class=\"round\">\n          <li>\n     \
    \       <p>\n              Create an application that can read user inputs and\
    \ convert it to\n              a binary string. For example, if the user enters\
    \ \"111\", then the\n              application should output \"111\".\n      \
    \      </p>\n            <p>\n              Next, sort an array to find the largest\
    \ number of ones in the binary\n              representation of each element.\
    \ For example, if the input array is\n              [4, 2, 1, 10], then the output\
    \ should be [4, 2, 10, 1].\n            </p>\n            <p>\n              Finally,\
    \ sort the largest number of ones elements based on their\n              binary\
    \ values. For example, if the input array is [4, 2, 10, 1],\n              then\
    \ the output array should be [1, 2, 4, 10].\n            </p>\n          </li>\n\
    \        </ol>\n      </div>\n    </section>", "  arr.sort.with_index { |x,i|\
    \ \n    case x.to_s(2)\n    when \"011\" then 1\n    when \"110\" then 2\n   \
    \ when \"101\" then 3\n    when \"010\" then 4\n    when \"001\" then 5\n    when\
    \ \"000\" then 6\n    else x\n    end\n  }\nend", "  arr.sort.with_index do |i,\
    \ idx|\n    ones = bin(i)\n    if ones.length < idx\n      [ones.length, idx]\n\
    \    else\n      [idx, ones.length]\n    end\n  end\nend", end, "  # your implementation\n\
    end", "  arr.sort do |x, y|\n    i = x\n    j = y\n    while i != 0\n      i -=\
    \ 1\n      j -= 1\n      cmp = arr[i].to_s(2)\n      cmp.gsub!(/[^1-9]+/, '0')\n\
    \      cmp.gsub!('11', '1')\n      cmp.gsub!('1', '0')\n      if cmp != arr[j].to_s(2)\n\
    \        cmp = cmp.to_i\n        if cmp < arr[j].to_i\n          return -1\n \
    \       elsif cmp > arr[j].to_i\n          return 1\n        end\n      end\n\
    \    end\n    0\n  end\nend", end, "  return if arr.empty?\n  arr.sort do |x,\
    \ y|\n    if x > y\n      1\n    elsif x < y\n      -1\n    else # x === y\n \
    \     x.to_s.reverse.to_i(2).to_f\n    end\n  end\nend", end, "  n = arr.size\n\
    \  return n if n == 0 else {\n    ones = arr.select {|x| x % 2 == 0 }.size\n \
    \   if ones == 0 then arr.sort\n    else arr.sort_by {|x| -x.divmod(ones).last\
    \ }.sort\n  }\nend\n</code>\n<|/ a tags=arrays,ruby,sorting |>\n<| c |>\nThis\
    \ was my solution, too. But you beat me to it by seconds. :)\n<|/ c |>\n<| c |>\n\
    Nice, that worked! I appreciate the help. I learned a lot about Ruby thanks to\
    \ your help.\n<|/ c |>\n<| a dscore=2 |>\nYou can use a hash like so: \n<code>\n\
    input = [\n  [11, 22, 3],\n  [9, 10, 11],\n  [2, 4, 5],\n  [4, 8, 0],\n  [0, 4,\
    \ 9]\n]", "  # TODO: Your code goes here\nend", "  binarized_array = []\n  decimals\
    \ = []", "  # Your code here\nend", '    # Write your code here', '  # Implement
    your code here', "  arr.sort\nend", "    arr.sort.reverse!\n    arr.to_s.split('').map(&:to_i).sort.each\
    \ do |num|\n        puts \"#{ num }, #{((num*2)%10 + (num*2%10)%10)}\"\n    end\n\
    end", "  arr.sort.reverse\nend", "  new_array = []\n  arr.each do |i|\n    new_array\
    \ << {i: i, count: i.to_s.split('').count(1) / 2}\n  end\n  new_array.sort_by!\
    \ { |r| r.count }.reverse\n  new_array.sort_by! { |r| r.i}\n  new_array.map {\
    \ |r| r.i}\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, I never thought that way.\
    \ It's so much simpler than mine. Good job.\n<|/ c |>\n<| c |>\nThis is brilliant.\
    \ Thanks for sharing.\n<|/ c |>\n<| a dscore=4 tags=sorting,ruby,arrays |>\nThis\
    \ is probably easiest with Array#sort, although you can also do it with Array#sort_by:\n\
    <code>\na = [1, 4, 3, 2, 0]\na.sort_by { |e| a.count(e) }.reverse", "  arr.sort!\n\
    \  return arr\nend", "    return arr\nend\n</cell>\n<code language=julia-1.0>\n\
    arr = [1, -10, 1, 0, 0, 0, 1, 0, 0, 0, 0]\n</cell>\n<code language=julia-1.0>\n\
    sort_array(arr)\n</cell>\n<text>\nExercise 9: Sum all numbers from 0 to 10", " \
    \   arr\nend", "  arr.sort!\n  for i in 0...arr.length-1\n    if arr[i] == 1\n\
    \      arr[i] = 2\n      break\n    elsif arr[i] < 2\n      arr[i] -= 1\n    \
    \  break\n    end\n  end\n  arr\nend", "    counts = [0]*len(arr)\n    sums =\
    \ [0]*len(arr)\n    \n    # Count number of 1\n    for val in arr:\n        if\
    \ val ==1:\n            counts[val-1] += 1\n            sums[val-1] += val\n \
    \   \n    # Sort the array based on the count of ones\n    counts_sorted = sorted(counts,\
    \ key=int)\n    \n    counts_sorted.reverse()\n    \n    # Sort the array based\
    \ on the sums\n    sum_sorted = sorted(sums, key=int)\n    \n    sum_sorted.reverse()\n\
    \    \n    return counts_sorted + sum_sorted\n    ", end, '  # your solution',
  "    arr.sort_by { |e| [-e, e].count }\nend", "  arr.sort.with_index { |n, i| n\
    \ < 0 ? -i : i }\nend\n</cell>\n<text>\nTest", end, "  if arr.length == 0\n  \
    \  []\n  elsif arr.length == 1\n    arr.sort\n  else\n    bits_array = dec(arr,\
    \ arr.length)\n    arr.each { |i| arr[i] = i if bits_array[i] == 1 }\n    arr.sort\n\
    \  end\nend", '  return arr if arr.length == 0', "  arr2 = []\n  arr.each do |i|\n\
    \    binary = i.to_s(2)\n    ones_count = binary.count('1')\n    decimal =  ones_count.to_f/len(binary)\n\
    \    arr2 << [ones_count, decimal]\n  end\n  arr2.sort!{|x, y| y[1]<=>x[1]}\n\
    \  arr2.map{|i| i[0]}\nend\n</code>\n<|/ a |>\n<| c |>\nHi, thanks for your answer.\
    \ Your solution does return an array of decimal values but the decimal numbers\
    \ are in the wrong order.\n<|/ c |>\n<| c |>\nHi, I've updated my answer to include\
    \ a solution to sort based on decimal numbers. Please check if this solution works\
    \ for you.\n<|/ c |>\n<| c |>\nHi, thanks for your answer. I am getting an error\
    \ when running the code: **NoMethodError: undefined method `sort!' for #<Array:0x9c1b920>**\n\
    <|/ c |>\n<| c |>\nI suspect that your array is not of integers but of strings.\
    \ Please confirm if that's the case and also add the exact code you are using.\n\
    <|/ c |>\n<| c |>\nHi, I changed the code a bit and it works! But I am still looking\
    \ for a more concise way of doing it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \   array.sort...\nend", "  arr.sort!\n  arr.map.with_index { |e, i| arr[i] }\n\
    end\n</code>\nAnd then implement the rest of the Kata.\nEDIT: Here is an updated\
    \ version of my code with a few more tests:\n<code>", "    return arr.sort {|x,\
    \ y| x.to_s(2).size <=> y.to_s(2).size }\nend", "  n = 0\n  res = []\n  while\
    \ arr.size > 0\n    if arr[n] == 1\n      res.push(arr[n])\n      n += 1\n   \
    \ end\n    if n == arr.size\n      arr = arr.dup\n      arr.shift\n      n -=\
    \ 1\n    end\n  end\n  res\nend", "  if arr.length < 2 then\n    return arr\n\
    \  end\n  local arr = arr[1]\n  local start = 1\n  local end = 0\n  local result\n\
    \  while start < arr.length do\n    end = start + 2\n    local tmp = arr[1]\n\
    \    for i = start, end do\n      tmp ^= arr[i]\n      end\n    tmp = tmp ^ arr[1]\n\
    \    arr[end] = tmp\n    start = end + 1\n    result[start] = arr[start] or 0\n\
    \  end\n  result[1] = arr[end]\n  return result\nend\n</cell>\n<code language=julia-1.0>",
  "    arr.sort!\nend", "    return []\nend", "  return arr.sort { |a, b| a.to_s(2).reverse.to_i(2)\
    \ <=> b.to_s(2).reverse.to_i(2) }\nend\n</cell>\n<cell>\nsort_array([3, 2, 4,\
    \ 1]).should == [1, 2, 3, 4]\n</cell>\n<cell>", "end\n</cell>\n<cell>", "    #\
    \ Your code here\n    raise NotImplementedError\nend", "  arr.sort! do |i|\n \
    \   if i != 0\n      ones_count = 0\n      dec = 0\n      while i > 0\n      \
    \  ones_count += i & 1\n        dec += i >> 1\n        i >>= 1\n      end\n  \
    \    if ones_count > 0\n        dec\n      else\n        0\n      end\n    else\n\
    \      0\n    end\n  end\nend", "  one_count = arr.count(1)\n  two_count = arr.count(2)\n\
    \  three_count = arr.count(3)\n  four_count = arr.count(4)\n  five_count = arr.count(5)\n\
    \  six_count = arr.count(6)\n  seven_count = arr.count(7)\n  eight_count = arr.count(8)\n\
    \  nine_count = arr.count(9)", "    arr.sort.map {|x| x.to_s(2).count(\"1\") }.reverse.sort\
    \ {|a, b| a.to_i <=> b.to_i }\nend\n</code>\n<|/ a |>\n<| c |>\nI did a little\
    \ bit of optimization: `.map {|x| x.to_s(2).count(\"1\") }.reverse.sort` replaced\
    \ with `.map {|x| x.to_s(2).count(\"1\") }.max` since count will return 0 for\
    \ any zero value.\n<|/ c |>\n<| c |>\nAnother optimization would be to move the\
    \ `count` statement out of the map block to avoid the creation of the temporary\
    \ array.\n<|/ c |>\n<| c |>\nOk, great. I'm glad to hear that these were helpful!\
    \ I also updated my answer to include a couple of other things.\n<|/ c |>\n<|\
    \ c |>\nThe \"optimization\" mentioned above is exactly what I had done. Thanks\
    \ again for your help :) I never thought of using count!\n<|/ c |>\n<| a dscore=3\
    \ tags=ruby |>\nHere is another solution, that doesn't use any loops:\n<code>",
  "  # your code goes here\nend", "    sorted = []\n    bins = []\n    ones = []",
  "  arr.sort.with_index do |n,i|\n    idx = i * (1 / 2).ceil\n    idx = idx if n.zero?\n\
    \    [(-idx if n > 0) + n, i]\n  end\nend", "    arr.sort!\nend", "    arr.sort!\n\
    \    arr.each_index do |i|\n        arr[i] = arr[i].zero? ? 0 : arr[i]\n    end\n\
    \    return arr\nend", "  arr.sort! { |a, b| a <=> b }\n  arr.map { |e| [e - 1]\
    \ }\nend", '  arr.sort!', "  arr.sort { |a, b| a.zero? || b.zero? ? b.nonzero?\
    \ <=> a.nonzero? : a.to_s.reverse <=> b.to_s.reverse }\nend", "    return []\n\
    end", '  size = arr.length', "    # write your logic here\n    # return result\n\
    end", "  # your code here\nend", end, "  # Your code here\nend\n</cell>\n<cell>\n\
    arr = [0,10,2,4,3,2,4,1,7,9,2]\n</cell>\n<cell>\nsort_array(arr)\n</cell>\n<cell>",
  "    # Write your code here.\nend", end, "  arr.sort\nend", "    # ...\nend", '  new_arr
    = []', "  p =arr.length\n  m = Array.new(p, 0)\n  arr.each do |x|\n    m += [x].to_s(2).count(\"\
    1\")\n  end\n  m.sort!\n  m = m.map {|x| x.to_i }\n  p.times do |i|\n    if m[i]\
    \ > m[i + 1]\n      arr[i] = m[i]\n    end\n  end\nend", "  arr.sort!\n  arr\n\
    end\n</pre>\n            </div>\n          \n          \n          \n        \
    \  \n          \n            \n            <div class=\"sourcecode\">\n      \
    \        \n              <p class=\"source-link\">\n                Source: \n\
    \                <a href=\"javascript:toggleSource('method-i-sort_array_source')\"\
    \ id=\"l_method-i-sort_array_source\">show</a>\n                \n           \
    \   </p>\n              <div id=\"method-i-sort_array_source\" class=\"dyn-source\"\
    >\n                <pre><span class=\"ruby-comment\"># File /usr/local/rvm/gems/ruby-2.0.0-p0/gems/activesupport-4.0.0/lib/active_support/core_ext/array.rb,\
    \ line 684</span>\n<span class=\"ruby-keyword\">def</span> <span class=\"ruby-keyword\
    \ ruby-title\">sort_array</span>(<span class=\"ruby-identifier\">arr</span>)\n\
    \  <span class=\"ruby-identifier\">a</span> = <span class=\"ruby-keyword\">if</span>\
    \ <span class=\"ruby-identifier\">is_a?</span>(<span class=\"ruby-constant\">Array</span>)\n\
    \    <span class=\"ruby-identifier\">arr</span>\n  <span class=\"ruby-keyword\"\
    >else</span>\n    <span class=\"ruby-constant\">Array</span>.<span class=\"ruby-identifier\"\
    >wrap</span>(<span class=\"ruby-identifier\">arr</span>)\n  <span class=\"ruby-keyword\"\
    >end</span>\n  <span class=\"ruby-identifier\">a</span>.<span class=\"ruby-identifier\"\
    >sort_by!</span> <span class=\"ruby-keyword\">do</span> <span class=\"ruby-operator\"\
    >|</span><span class=\"ruby-identifier\">e</span><span class=\"ruby-operator\"\
    >|</span> <span class=\"ruby-identifier\">e</span>.<span class=\"ruby-identifier\"\
    >zero?</span>\n  <span class=\"ruby-keyword\">end</span>", "    arr.sort!\nend",
  "  arr.sort!\nend\n```", "  arr.sort! do |x, &b| b[x, 1] <=> b[x-1, 1]\n  # ...\n\
    end", "  n = arr.size\n  result = []\n  max_count = 0\n  min_val = float(\"Inf\"\
    )\n  max_val = float(\"-Inf\")\n  for i in 0..n - 1\n    ones = bin(arr[i])\n\
    \    ones = ones[0..8]\n    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n\
    \    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones\
    \ = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n\
    \    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones\
    \ = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n\
    \    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones\
    \ = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n\
    \    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones\
    \ = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n\
    \    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones\
    \ = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n\
    \    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones\
    \ = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n\
    \    ones = ones[0..(ones.size-1)]\n    ones = ones[0..(ones.size-1)]\n    ones\
    \ = ones[0..(ones.size-1)]\n    ones = one", "    arr.sort_by { |v| v & 1 ? v.to_i(2)\
    \ : v.to_i(10) }\nend", "  arr.sort!\n  \n  # find ones by finding length of binarized\
    \ array\n  ones = arr.map { |i| i.to_s.scan(/1{1}/).count }\n  ones = ones.uniq\n\
    \  \n  # sort by binary string\n  ones = ones.map { |i| i.scan(/../).join }\n\
    \  ones = ones.map { |i| i.scan(/(.)\\1*/).join.to_f }\n  \n  # sort by decimal\
    \ number\n  ones = ones.map { |i| i.to_f }\n  \n  ones = ones.sort_by { |i| i\
    \ }\n  \n  ones\nend", "  # write your code here\nend\n</cell>\n<text>\nThe main\
    \ challenge of this Kata is that you will have to deal with really large numbers,\
    \ like $5000000 $ , which is too big to fit in your memory. There are multiple\
    \ approaches to deal with such cases:", "    ones = arr.count(1)\n    arr = arr.sort\n\
    \    arr.last = (ones, arr)[ones > arr.last][1]\n    return arr\nend\n</code>\n\
    <|/ a tags=ruby,algorithm,sorting,arrays |>\n<| c |>\nNice. Very clever. Thanks.\n\
    <|/ c |>\n<| a |>\nMy solution uses only arrays, no recursion nor external helpers.\
    \ I believe this solution could be improved in terms of performance.\n<code>",
  "  arr.sort_by! { |x| x.to_s(2).count(\"1\") }\n  arr.sort_by! { |x| x.to_s.reverse\
    \ }\n  arr\nend", "  arr.sort!\nend", "    sorted = []\n    while arr.length >\
    \ 0\n        if arr[0] % 2 == 0\n            sorted.push(arr.pop(0))\n       \
    \ else\n            sorted.push(arr.pop(0))\n    end\n    sorted.reverse!\n  \
    \  return sorted\nend\n</code>\nYour answer will be in the sorted array.\n<|/\
    \ a tags=sorting,ruby,kata dscore=1 |>\n<| a tags=sorting,ruby,kata |>\nYou can\
    \ try this as well, for sorted arrays:\n<code>", "  return arr\nend", "  arr.sort!{|a,\
    \ b| -b.length}\n  return arr\nend", "    arr.sort!\n    arr.map! { |x| x == 0\
    \ ? 0 : 1; x }\nend", "  arr.sort.each do |el|\n    next if el == 0\n    arr.index(el)\n\
    \  end\nend", "  ones = arr.count.select.{|i| i.zero?}.to_i\n  arr.sort { |a,\
    \ b| b.to_s.reverse.to_i <=> a.to_s.reverse.to_i }\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nI didn't say it wasn't possible - I said it wasn't easy and I haven't\
    \ found a way to do it.  Also, your solution is very expensive - you are converting\
    \ from binary to decimal.  Why not just use the binary representation?  Also,\
    \ your solution is in Ruby, not PHP.  Not sure if that's really a solution to\
    \ anything.\n<|/ c |>\n<| c |>\nHmm, you're right, I didn't see that you were\
    \ talking about Ruby. And you say \"converting from binary to decimal\". Do you\
    \ mean converting from binary to integer? If so, this is not easy to do with PHP\
    \ or any other language, because PHP cannot parse binary numbers by itself. It\
    \ needs some libraries or extensions. But Ruby does have a built-in method for\
    \ that: `to_i`.\n<|/ c |>\n<| c |>\nI meant that you are converting from binary\
    \ to decimal, where we could have a variable number of binary digits per number.\
    \  I didn't say it was easy.  It's not that hard, as long as you don't need it\
    \ very often.  But of course it's not that efficient and doesn't really work if\
    \ the numbers are huge.  It will cause a stack overflow if run on large numbers.\n\
    <|/ c |>\n<| c |>\nOf course you can convert from binary to decimal with PHP -\
    \ it can read binary numbers just fine.  The problem is that PHP doesn't have\
    \ a built-in function for converting binary to decimal (well, it's really easy\
    \ to convert to decimal, just as easy in PHP), so you have to do it with string\
    \ manipulation and string functions.\n<|/ c |>\n<| c |>\nIn fact, you can convert\
    \ binary to decimal with PHP - it is in the docs: http://www.php.net/manual/en/function.base-convert.php\n\
    <|/ c |>\n<| a |>\nI actually solved this problem by converting the string into\
    \ a binary string and then looping through the digits converting each one to a\
    \ decimal number (in reverse) and adding it to a total until there are no more\
    \ digits left.\n<|/ a tags=php,sorting dscore=3 |>\n<| a dscore=2 |>\nI know this\
    \ is an old question, but I wanted to post my answer, because I wanted to share\
    \ my working solution. It doesn't use PHP's native sorting methods (as far as\
    \ I can see) but a little bit of string manipulation and a little bit of binary\
    \ arithmetic did the trick for me.\nHere is the solution I came up with after\
    \ try", "  return nil\nend", "  ones = arr.select { |x| x.zero? }\n  tens = arr.select\
    \ { |x| x.zero? ? 0 : x.modulo(10).zero? }\n  hundreds = arr.select { |x| x.zero?\
    \ ? 0 : x.modulo(100).zero? }", "  return nil\nend", '    arr.sort!', "  arr.sort!\n\
    \  arr.each_with_index do |value, index|\n    if value.length == 1 && value[0]\
    \ >= 0\n      arr[index] = value[0]\n    end\n  end\nend", "  arr.sort! {|x,y|\
    \ x <=> y } if arr.is_a?(Array) # Sort in-place\n  arr.sort! {|x,y| x.to_s(2).count\
    \ '1' <=> y.to_s(2).count '1' } # Sort based on binary representation\n  arr.sort!\
    \ {|x,y| x.to_s(10).to_i <=> y.to_s(10).to_i } # Sort based on decimal value\n\
    end\n</code></pre>\n          </section>\n          <section>\n            <h3>Sorting</h3>\n\
    \            <pre><code>", "  # sort based on decimal value\n  sorted_arr = arr.sort\n\
    \  # sort based on number of ones in binary representation\n  sorted_arr.reverse.each_with_index\
    \ do |item, index|\n    sorted_arr[index] = item if item\n  end\n  return sorted_arr\n\
    end", "  raise NotImplementedError\nend", "    return nil\nend", "  arr.sort!\
    \ { |a, b| count_ones_in_binary(a).cmp(count_ones_in_binary(b)) }\n  arr\nend",
  "  arr.sort {|x, y| compare_ones(x, y) }\nend", "    sorted.clear()\n    sorted\
    \ = arr.sort.sort{|a, b| a <=> b}\n    sorted.reverse\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nSorry but your solution isn't what I was looking for, I don't care\
    \ about sort order, I just need to sort based on number of 1s\n<|/ c |>\n<| c\
    \ |>\nI updated my answer with a new solution, should work like that.\n<|/ c |>\n\
    <| a tags=algorithm,ruby |>\n<code>", '    arr.sort!', "    sort = Array.new\n\
    \    i = 0\n    while i < arr.length\n        count = 0\n        j = i + 1\n \
    \       while j < arr.length\n            count += arr[j]\n            j += 1\n\
    \        end\n        sort.push(count) if count == 1\n        i += 1\n    end\n\
    \    sort.sort\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 |>\nI assume you\
    \ want to sort the array of numbers according to their binary representation.\n\
    The first idea to do this would be to convert each number to its binary representation\
    \ and sort this array. \nFor example if we have [6,2,7,3,6,8,1,4,7,5] then the\
    \ binary representation for each number would be\n<code>\n[6,2,7,3,6,8,1,4,7,5,0,0,0]\n\
    </code>\nand then we can sort this array, because we would get\n<code>\n[0,0,0,1,0,0,0,1,0,0,0,1]\n\
    </code>\nThen we need to convert back to an integer and put it into an array with\
    \ each digit separated by commas.\nSo if we have [0,0,0,1,0,0,0,1,0,0,0,1] the\
    \ binary representation would be\n<code>\n[0,0,0,0,0,1,0,0,0,1]\n</code>\nThen\
    \ we can sort this array as we did before. \nThe final result would be\n<code>\n\
    [6,2,7,3,6,8,1,4,7,5,0,0,0]\n</code>\nHere is the implementation of this idea\n\
    <code>", "  arr.sort!\n  return arr\nend", "  # Your code goes here\nend", " \
    \ # Your code here\nend\n</cell>\n<code language=julia-1.0>", end, "    sorted\
    \ = []\n    sorted = arr.select { |x| x.to_s.count(\"1\") < x.to_s.count(\"0\"\
    ) }.sort { |a, b| \n        b.to_s.count(\"1\").to_f <=> a.to_s.count(\"1\").to_f\n\
    \    }", "    arr.sort\nend", end, "  if arr.size < 3\n    return arr\n  end\n\
    \  ones = arr.each_with_index.reduce(0) { |sum, (n, i)| sum + n if n }\n  ones\
    \ = arr.each_with_index.reduce(0) { |sum, (n, i)| sum + n / 2.0 if n > 1 }\n \
    \ arr.sort.map { |n| [ones, n] }.sort_by { |n| n[0] }.reverse\nend", "  arr.sort\
    \ {|x, y| (x & y) || x.to_i == y.to_i}\nend", "  ones = arr.select {|x| x == 1}.count\n\
    \  ones.sort! { |x,y| x > y ? 1 : -1 }\n  arr - ones\nend", "  # your implementation\n\
    end", "  # Write your code here\nend", "    # your code here\nend\n</cell>\n<cell>\n\
    sort_array([1, 1, 1, 0, 1, 0, 1])\n</cell>\n<cell>", "  arr.sort {|a, b| a <=>\
    \ b } # <=> = <=> is ruby's operator for sorting\nend", "  sorted = []\n  ones\
    \ = 0\n  i = 0\n  while i < arr.length\n    if arr[i] > 1\n      ones += 1\n \
    \     i += 1\n    else\n      i += 1\n    end\n  end\n  sorted.push [ones, arr.sort]\n\
    \  sorted.flatten.sort! do |a, b|\n    if a[0] < b[0]\n      1\n    elsif a[0]\
    \ > b[0]\n      -1\n    else\n      a[1] <=> b[1]\n    end\n  end\nend\n</cell>\n\
    <cell>\na = [1, 1, 0, 0, 1]\nsort_array(a)\n</cell>\n<text>\n5. Binary Search\n\
    You are given an array arr of n integers and a number k. Implement a function\
    \ that, given a target number x, find k elements in the array such that their\
    \ binary representation contains x.", "  arr.sort{|a, b| a == b ? 0 : a.to_s(2).count('1')\
    \ - b.to_s(2).count('1')}\nend", "    arr.sort!\nend", "  arr = arr.reverse\n\
    \  arr.each do |x|\n    if x % 2 == 0\n      break\n    end\n    i = 5\n    while\
    \ i >= 0\n      x = x / (2 * 5) + 5\n      i--\n    end\n  end\n  arr.reverse\n\
    end", "  arr.sort { |a, b| binary_sort_helper(a, b, arr) }\nend", "    arr.sort.reverse!\n\
    \    arr.sort! {|a, b| a.zero? && b.zero? ? -1 : (a.to_s(2).count(\"1\") > b.to_s(2).count(\"\
    1\") ? 1 : 0)}\nend", '# Write your solution below:', "  arr.sort { |a, b| -(b\
    \ & a) }\nend", "    # Your code here\nend\n</cell>\n<code language=julia-0.6>\n\
    using BenchmarkTools", "  # Your code goes here\nend", "  arr.sort! do |a,b|\n\
    \    if a > b then\n      1\n    elsif a == b then\n      0\n    else\n      a\
    \ <=> b\n    end\n  end\nend", "    return arr.sort {|a, b| b <=> a}\nend\n</code>\n\
    I wrote the test cases for this Kata using RSpec:\n<code>\ndescribe \"sort_array\"\
    \ do\n    context \"given an array of integers\" do\n        it \"should sort\
    \ ascending if number of ones in binary representation is same\" do\n        \
    \    arr = [100, 2, 1, 1, 1000000000]\n            expect( sort_array(arr) ).to\
    \ eq([100, 1, 1, 1000000000, 2])\n        end\n        it \"should sort descending\
    \ if number of ones in binary representation is same\" do\n            arr = [100,\
    \ 2, 1, 1, 1000000000]\n            expect( sort_array(arr.reverse) ).to eq([2,\
    \ 1, 1, 1000000000, 100])\n        end\n        it \"should sort ascending if\
    \ number of ones in binary representation is different\" do\n            arr =\
    \ [100, 2, 1, 1, 1000000000]\n            expect( sort_array(arr.reverse) ).to\
    \ eq([100, 2, 1, 1, 1000000000])\n        end\n        it \"should sort descending\
    \ if number of ones in binary representation is different\" do\n            arr\
    \ = [100, 2, 1, 1, 1000000000]\n            expect( sort_array(arr.reverse.reverse)\
    \ ).to eq([2, 1, 1, 1000000000])\n        end\n    end\n    context \"given an\
    \ array of non-negative integers\" do\n        it \"should sort ascending if number\
    \ of ones in binary representation is same\" do\n            arr = [100, 2, 1,\
    \ 1, 1000000000]\n            expect( sort_array(arr) ).to eq([100, 2, 1, 1, 1000000000])\n\
    \        end\n        it \"should sort descending if number of ones in binary\
    \ representation is same\" do\n            arr = [100, 2, 1, 1, 1000000000]\n\
    \            expect( sort_array(arr.reverse) ).to eq([100, 2, 1, 1, 1000000000])\n\
    \        end\n        it \"should sort ascending if number of ones in binary representation\
    \ is different\" do\n            arr = [100, 2, 1, 1, 1000000000]\n          \
    \  expect( sort_array(arr.reverse) ).to eq([100, 2, 1, 1, 1000000000])\n     \
    \   end\n        it \"should sort descending if number of ones in binary representation\
    \ is different\" do\n            arr = [100, 2, 1, 1, 1000000000]\n          \
    \  expect( sort_array(arr.reverse.reverse) ).to eq([100, 2, 1, 1, 1000000000])\n\
    \        end\n    end\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nCould\
    \ you please tell me how to run this kata in HackerRank ?\n<|/ c |>\n<| a dscore=3\
    \ |>\nI wanted to give my own answer to ", "  arr.sort!\n  arr.map { |i| i / 10.to_i\
    \ }.sort.reverse\nend", "  arr.sort! # use Ruby's inbuilt sort method\n  # sort\
    \ according to number of 1's\n  arr.sort_by { |i| i.to_s(2).count(\"1\") } \n\
    \  # sort according to decimal value\n  # since we have sorted according to number\
    \ of 1's, we know that\n  # after sorting the decimal value is already sorted.\n\
    \  arr.sort_by { |i| i.to_i }\nend", "  arr.sort! do |a,b|\n    count_one_bin(binary(a))\
    \ <=> count_one_bin(binary(b)) # <=> for descending\n    a.to_i <=> b.to_i\n \
    \ end\nend", "  arr.sort do |x, y|\n    if x.zero? then 0\n    elsif y == 1 then\
    \ 1\n    elsif y == 0 then -1\n    else ((x & y) / 2).abs\n    end\n  end\nend",
  "    arr.sort! { |a, b| a.to_s(2).size <=> b.to_s(2).size }\n    arr.sort! { |a,\
    \ b| a.to_i <=> b.to_i }\n    arr\nend", "  arr.sort.with_index do |e, i|\n  \
    \  arr[i].zero? ? i : i.to_s.reverse.ord.chars.map(&:to_i).inject(0) {|sum, x|\
    \ sum + x }\n  end\nend", "  arr.sort! { |i1, i2| i1.to_s(2).count + i2.to_s(2).count\
    \ }\nend", "  # Your code here\nend\n</cell>\n<code language=julia-1.0>", "  #\
    \ do your implementation\nend", "    arr.sort!\nend", end, "  # Your code goes\
    \ here\nend", "  if arr.empty?\n    return arr\n  end\n  one_cnt = arr.count(1)\n\
    \  dec = arr.inject(0) {|sum, el| sum + el}\n  dec = dec.to_f / one_cnt\n  dec\
    \ = dec.round(2)\n  arr.sort_by { |el| [el]*one_cnt }\nend\n```\n- When you get\
    \ the result below, can you guess the problem with the code?\n- If you think your\
    \ solution is correct, try adding tests to verify it. Feel free to add tests for\
    \ any scenario you think might be interesting.\n```\n$ ruby solution_for_05.rb\n\
    [1, 1, 2, 3]\n```\n- Congratulations! You have learned the basics of Ruby!\n-\
    \ Now that you've learned Ruby, we recommend that you take a look at\nour [Ruby\
    \ Tour](http://rubymonk.com/learning/tour/) and the [Ruby Language Guide](http://ruby-doc.org/docs/ProgrammingRuby/index.html).\n\
    - If you have any questions, please contact us at [your company](https://app.codingblocks.com).\n\
    - Be sure to check out our [Ruby Quizzes](http://rubyquiz.com/quiz/).\n- Make\
    \ sure to check out our [Kata](/kata/) page. Check out the Kata before you start\
    \ coding. Kata will tell you what questions to ask and how to answer the questions.\
    \ We'll only do Kata if we can't get the problem solved, which means if you still\
    \ have questions about our Kata, just come here to ask.\n- If you'd like to learn\
    \ more, visit [the documentation](http://ruby-doc.org/docs/ProgrammingRuby/).\n\
    - If you want to become a Ruby programmer, try out [Online Judges](http://ruby-challonge.com/online_judges/).\n\
    - If you enjoy Ruby, check out our [Ruby Camp](http://ruby-challonge.com/camp/).\n\
    - To see a list of available language features, visit [the documentation](http://ruby-doc.org/docs/ProgrammingRuby/language.html).",
  "    # Your code here\nend", "    arr.sort\n    return arr", '    arr.sort!', " \
    \ arr <<= 1\n  arr.sort\nend", "    arr = arr.sort.reverse\n    arr.each do |i|\n\
    \        if i =~ /^1/\n            arr.remove(i)\n        elsif i =~ /^0/\n  \
    \          arr.remove(i)\n        elsif i.to_s(2) =~ /(0+)/\n            arr.remove(i)\n\
    \        else\n        end\n    end\n    return arr\nend", "  arr.sort\nend",
  "    arr.sort! {|a, b| a <=> b }\nend", "  arr.sort.with_index { |x,i| x <= arr[i+1]\
    \ ? -1 : i+1 }\nend", "end\n</cell>\n<cell>\narr = [1, 6, 3, 5, 10, 6, 8, 4, 9,\
    \ 10, 2, 5, 7, 10, 11, 11, 9, 12, 13, 6, 13, 14, 15]\n</cell>\n<cell>\nsort_array(arr)\n\
    </cell>\n<cell>", "    arr.sort!\n    return arr\nend", "  return arr\nend", " \
    \ ones = arr.map { |n| n.to_s(2) }.count('1')\n  decimal = arr.map { |n| n.to_i(2)\
    \ }.max\n  ones, decimal\nend", '  # write your code here', end, "  arr.sort {\
    \ |a,b| a <=> b }\nend", "  if arr.empty?\n    return arr\n  end\n  arr = arr.sort{|a,b|\
    \ a==b ? 0 : a <=> b}\n  binary_ones = arr.map { |i| i.to_s(2).size }\n  binary_ones\
    \ = binary_ones.zip(binary_ones).flatten.sort_by{|a,b| a.to_i}\n  decimal_ones\
    \ = binary_ones.map {|i| binary_ones.index(i) + 1}\n  decimal_ones = decimal_ones\
    \ + binary_ones\n  decimal_ones.sort!\n  return arr.map { |i| decimal_ones.index\
    \ i }\nend\n</pre>\n</div></div><br><br><hr><br>\n<table border=\"0\" width=\"\
    100%\" cellpadding=\"0\" cellspacing=\"0\">\n  <tbody><tr><td bgcolor=\"#e4f0f8\"\
    ><pre class=\"prettyprint lang-js\">require 'benchmark'\nrequire 'set'", "   \
    \ # Write your code here\nend", '# Your code here', '  result = []', "    return\
    \ arr\nend\n</cell>\n<cell>\n%load -r 102 -k -o - \"../solutions/katas/01.sort-array/sort_array.rb\"\
    \n</cell>\n<text>\nExercise 03: Count how many ones are present in binary representation\
    \ of numbers between 10 and 200 in ascending order.", "    arr.sort\nend", " \
    \ # TODO: sort arr in ascending order\nend", "  return []\nend\n</cell>\n<code\
    \ language=julia-0.4>", "    arr.sort!\nend\nassert(arr.sort == sort_array(arr))",
  "    one_count = arr.count(1)\n    arr.sort!\n    arr.each_with_index do |num, i|\n\
    \      ones = one_count - i\n      ones = 0 if ones < 0\n      ones = 0 if ones\
    \ == 0\n      arr[i] = ones + num\n    end\n    arr\nend", "  return arr\nend",
  "    # Your code here\nend", "  # Your code goes here\nend", "    arr.sort!\n  \
    \  count = 0\n    for i in arr\n        count += 1 if i.to_s(2).count == '0' else\
    \ 0\n    arr.reverse!\n    arr.sort!\n    arr = arr.reverse!\nend", "  \nend\n\
    </cell>\n<cell>", "    sorted = []\n    sorted = arr.sort{ |a, b| b <=> a }\n\
    \    sorted.reverse!\n    sorted.each_with_index{ |e, i| arr[i] = arr[i].to_i\
    \ }\n    sorted\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nYou sir, are awesome.\
    \ Thanks for saving my project and time.\n<|/ c |>\n<| a tags=sorting,ruby dscore=2\
    \ |>\n<code>\narr = [0,1,1,0,1,1,1]\n</code>\nI wrote a very simple and elegant\
    \ solution\n<code>\narr.sort_by { |i| arr.count(i) / arr.count(0) * -1 }.reverse\n\
    </code>\n<|/ a |>\n<| a tags=sorting,ruby dscore=1 |>\nHere's my take:\n<code>\n\
    a = [1,0,1,1,0,0,0]\na = a.map {|n| [a.count(n),n]}\na.sort!.sort!.map(&:last).reverse\n\
    a\n</code>\nAnd here's the solution with a little bit of extra explanation\n<code>\n\
    a = [1,0,1,1,0,0,0]\na = a.map {|n| [a.count(n),n]}", "  sorted_arr = arr\n  ones\
    \ = []\n  for i in arr\n    one = !!i\n    ones.push(one)\n  end\n  ones_count\
    \ = ones.length", "    arr.sort!\n    arr.each do |i|\n        if i.to_s.count\
    \ == '1'\n            arr.sort!{|a, b| b.to_s.to_i < a.to_s.to_i }\n        end\n\
    \    end\n    arr\nend\n</cell>\n<cell>", end, "  arr.sort!\n  max_val = (2**arr.length)-1\n\
    \  arr.each do |x|\n    if x > max_val\n      arr.delete(max_val)\n    end\n \
    \ end\n  arr\nend", "    # Your code here\nend", "    # Your code here\n    #\
    \ return sorted array", "    # ...\nend", "  # Your code here\n  return arr\n\
    end", "  if arr.length == 1\n    arr\n  else\n    # Find number of ones \n   \
    \ ones_count = binary_to_decimal(arr.join)\n    ones = arr.select {|v| v == 1}\n\
    \    ones_count.sort {|a, b| b - a}\n    ones_count.map{|v| v == 1 ? ones[v] :\
    \ v}\n  end\nend", "    # Write your code here\nend\n</cell>\n<cell>", "  arr.sort\
    \ do |x,y|\n    if x == 0\n      0\n    elsif y == 0\n      -1\n    else\n   \
    \   (x == 1 ? -1 : y-x) * 256\n    end\n  end\nend", "    return arr\nend", " \
    \ arr.sort! do |a, b|\n    if a.to_s(2).count(\"1\") > b.to_s(2).count(\"1\")\n\
    \      a\n    else\n      b\n    end\n  end\nend", "  return nil unless arr\n\
    \  # Hint: Use enumerable.\n  # Hint: Use counting sort.\n  arr.sort_by {|i| arr[i].count(1)\
    \ / arr.length}.reverse\nend", "  # TODO: implement this function\nend", "   \
    \ return arr\nend", "  arr.sort! do |a,b|\n    if a.zero? && b.zero?\n      -1\n\
    \    elsif a.zero? && !b.zero?\n      1\n    elsif !a.zero? && b.zero?\n     \
    \ -1\n    else\n      (a.to_s(2).count(\"1\") <=> b.to_s(2).count(\"1\")) * a.to_i(10).to_s\
    \ + b.to_i(10).to_s\n    end\n  end\nend\n</pre>\n            </div>\n       \
    \   </div>\n        </div>\n      </main>\n    </div>\n    <footer class=\"footer\"\
    >\n      <div class=\"content has-text-centered\">\n        <p>\n          Documentation\
    \ generated by\n          <a href=\"https://github.com/jsdoc3/jsdoc\">JSDoc 3.6.5</a>\n\
    \        </p>\n        <p class=\"sidebar-created-by\">\n          <a href=\"\
    https://github.com/SoftwareBrothers/better-docs\" target=\"_blank\">BetterDocs\
    \ theme</a> for\n          <a href=\"https://softwarebrothers.co\" target=\"_blank\"\
    \ rel=\"noopener\">SoftwareBrothers - JavaScript Development Agency</a>\n    \
    \    </p>\n      </div>\n    </footer>\n    <script>\n      betterScroll.init({\n\
    \        scrollingSpeed: 1000,\n        autoScrolling: true,\n        wheelSpeed:\
    \ 10,\n        swipeEasing: true,\n        stopPropagation: false,\n        minScrollbarLength:\
    \ 40,\n      });\n    </script>\n    <script src=\"scripts/app.min.js\"></script>\n\
    \    <script>\n      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n\
    \      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n\
    \      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n\
    \      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');",
  "  return nil\nend", end, "  # Your code goes here\n  arr.sort!\n  \n  # Example\
    \ Input:\n  # arr = [7,2,0,4,5,1,3]\n  # Output:\n  # [0,0,1,1,2,3,4]\nend", " \
    \   arr.sort.sort_by! { |x| x == \"0\" ? 0 : 1 }\n    arr\nend", "    arr.sort!\n\
    end\n<|/ file source=github |>\n<| c |>\n`sort_array([\"11\",\"10\",\"01\",\"\
    00\"])` => `\"11\", \"01\", \"10\", \"00\"`\n<|/ c |>\n<| c |>\n`sort_array([\"\
    11\",\"10\",\"01\",\"00\"])` => `\"11\", \"01\", \"10\", \"00\"`\n<|/ c |>\n<|\
    \ a dscore=1 tags=sorting,ruby |>\n<code>", "  arr.sort!\nend", "  arr.sort\n\
    end", "  # Your code here\nend", "  # your code\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
