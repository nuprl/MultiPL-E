name: HumanEval_37_sort_even
language: rb
prompt: "# This function takes a list l and returns a list l' such that\n# l' is identical\
  \ to l in the odd indicies, while its values at the even indicies are equal\n# to\
  \ the values of the even indicies of l, but sorted.\ndef sort_even(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_even\n\
  \    candidate = method(:sort_even)\n    assert_equal([1, 2, 3], candidate.call([1,\
  \ 2, 3]))\n    assert_equal([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123], candidate.call([5,\
  \ 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([-12, 8, 3, 4, 5, 2, 12,\
  \ 11, 23, -10], candidate.call([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n  end\n\
  end\n"
completions: ["  even = l.map.with_index { |e,i| [(i+1) % 2, e] }\n  even.sort\nend",
  "    l.each do |e|\n        l.delete_at(l.index(e))\n    end\n    l.sort!\n    l\n\
    end", "    sorted = []\n    even = []\n    odd = []\n    \n    for value in l\n\
    \        if value.odd?\n            odd << value\n        else\n            even\
    \ << value\n        end\n    end\n    \n    sorted = odd + even.sort\n    \n \
    \   sorted = sort_even(sorted)\n    \n    sorted\nend", "    \n    # Sort the\
    \ even indicies of list l\n    l.sort.with_index{|i, x| x % 2 == 0}\nend\n   \
    \     ", "  l' =\n    l.dup.\n    sort {|a,b| (a % 2) <=> (b % 2)}.\n    map {|a|\
    \ a % 2}.\n    map {|a| a.to_i}.\n    sort_by {|a| a}\nend\n</code>\n<|/ a tags=ruby,sorting,algorithm,arrays\
    \ |>\n<| a tags=ruby,sorting,algorithm,arrays dscore=1 |>\nI wrote this simple\
    \ code in C since I already have a working Ruby script that generates the input\
    \ data in the format I require, so it might help somebody else in similar situation:\n\
    <code>", "  l.sort_by!\n  l = l.zip(0..l.size).map { |e,f| f.even? ? e : f.first\
    \ }\n  l.inject([]) { |a,b| a.concat(b) }\nend", "  l.sort_by {|x| x.to_i}\n \
    \ l\nend", "  evens = l.select { |e| e % 2 == 0 }\n  evens.sort.zip(evens).map\
    \ { |x, y| x.merge(y) }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is very\
    \ helpful! I used your solution to get the desired output for sorting odd elements\
    \ to sort even elements as I needed. Thanks!\n<|/ c |>\n<| a |>\nThe answer is\
    \ that you're not supposed to be sorting an array of tuples, as such:\n<code>\n\
    l = [(2, 3), (3, 2), (3, 1)]\nl.sort {|x, y| x[0].compare(y[0])}\n</code>\nThe\
    \ output of this is \n<code>\n[(1, 3), (2, 2), (3, 1)]\n</code>\nThe solution\
    \ is to use the sort_by method instead. So in your case it would look something\
    \ like this:\n<code>\nl = [(2, 3), (3, 2), (3, 1)]\nl.sort_by {|e| e[0]}\n</code>\n\
    This gives the output of\n<code>\n[(1, 3), (3, 2), (2, 3)]\n</code>\n<|/ a dscore=2\
    \ tags=ruby |>\n<| a tags=ruby dscore=0 |>\nWhat about this solution?\n<code>\n\
    a = [(2, 3), (3, 2), (3, 1)]\na.sort_by {|e| e[0]}.map {|e| e[1]}\n</code>\n<|/\
    \ a |>\n<| a |>\nI was having a hard time understanding the issue so i wrote some\
    \ code to help you understand how sorting by different criteria works:\n<code>",
  "  # Sort the array in the odd indicies\n  l = l.sort_by {|i| i % 2}\n  # Make sure\
    \ the even indicies are equal to the odd indicies\n  l.each(&:swap)\n  # Sort\
    \ the array in the even indicies\n  l = l.sort_by {|i| i % 2}\n  # Return the\
    \ sorted array\n  l\nend", "  even_indexes = []\n  odd_indexes = []\n  even_index\
    \ = 0\n  odd_index = 1\n  \n  # Sort the even indicies first\n  even_indexes.push(even_index)\n\
    \  odd_indexes.push(odd_index)\n  \n  # Find the next even and odd index\n  while\
    \ even_index < l.length\n    if l[even_index] == l[odd_index]\n      even_index\
    \ += 1\n      odd_index += 1\n    else \n      even_indexes.push(even_index)\n\
    \      odd_indexes.push(odd_index)\n      even_index += 1\n      odd_index +=\
    \ 1\n      \n  # Now the even indicies are sorted\n  even_indexes.reverse\n  odd_indexes.reverse\n\
    \  \n  # Sort the odd indicies\n  l.each_with_index do |e,i|\n    if i in odd_indexes\n\
    \      l.delete(e)\n      l.insert(i, l[e])\n    end\n  end\n  \n  # Return the\
    \ list l\n  l\nend\n</code>\nThis implementation is definitely not the best, but\
    \ it works fine. Let me know how it works out for you.\n<|/ a tags=sorting,ruby,arrays,multidimensional-array\
    \ dscore=0 |>\n<| c |>\nThat was an interesting solution.  Although I'm not sure\
    \ if it's going to work for my particular problem.  I'm trying to get the second\
    \ list to sort the same way as the first. I'm not sure how to do that using your\
    \ algorithm.\n<|/ c |>\n<| c |>\nThanks for your help.  I did actually write my\
    \ own solution, but I was hoping there was a one liner solution.\n<|/ c |>\n<|\
    \ c |>\n, if you find an answer to your question, please post it and accept it\
    \ by clicking the checkmark next to it.\n<|/ c |>\n<| a tags=sorting,ruby,arrays,multidimensional-array\
    \ dscore=0 |>\nI thought I would share my solution too.\n<code>", "  even = l.take(l.length/2+1)\n\
    \  even.zip(even.drop(1)).sort!.tap {|x| x.push(x.pop)} \n  even\nend\n</cell>\n\
    <code language=ruby-1.9.3-p448>\nx = [1,2,3,1,5,6,2,4,7,9,5,3]\nputs x.inspect\n\
    sort_even(x)\nputs x.inspect\n</cell>\n<code language=ruby-1.9.3-p448>", "   \
    \ even = even_indicies(l)\n    even.zip(l).sort.to_a\nend", "  l1 = []\n  l2 =\
    \ []\n  for i in l\n    if i % 2 == 0\n      l2.push i\n    else\n      l1.push\
    \ i\n  end\n  l1.sort { |a, b| b <=> a }\n  l2.concat l1\nend\n</code>\nAnd a\
    \ test script:\n<code>", "  if l.length < 2 then return l\n  result = []\n  for\
    \ i in 0...l.length-1 do\n    idx = i % 2\n    if idx == 0 then\n      result.push\
    \ l[i]\n    else\n      result.push l[idx]\n    end\n  end\n  return result\n\
    end", "  l1 = l.dup\n  l1.delete_if {|x| l.index(x)%2 == 1}\n  l1.sort_by! {|x|\
    \ l.index(x)}\n  return l1\nend", "  even = l.select { |i| i.odd? }\n  even.map!\
    \ { |x| x[0] }\n  even.sort.uniq!\n  even\nend\n</code>\nAnd here is an example\
    \ of its usage:\n<code>\nlist = (1..50).to_a\nsort_even(list)", "  even = []\n\
    \  odd = []\n  sort = []\n  count = 0\n  while count < l.length\n    odd << l.delete_at(count)\n\
    \    count += 1\n  end\n  while odd != []\n    even.delete_at(0)\n    sort.concat(odd.sort)\n\
    \    odd << even.delete_at(0)\n  end\n  return sort\nend", "    l' = l.dup\n \
    \   l'[0,0] = 0\n    for i in 1..l.size\n        if l'[i] == 0\n            l.insert\
    \ i, l'[i-2]\n            l.delete i-2, i-1\n        end\n    end\n    l\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby,ruby-on-rails,arrays |>\n<| a dscore=0 |>\n\
    You can do it with Ruby 1.9's Enumerable#sort_by.\n<code>\na = [0, 4, 3, 2, 1]\n\
    a.sort_by { |x| -x.odd? ? 0 : 1 }\n=> [1, 4, 3, 2, 0]\n</code>\n<|/ a tags=ruby,ruby-on-rails,arrays\
    \ |>\n<| c |>\nThank you very much for responding so quickly. I'm not very familiar\
    \ with Ruby 1.9's capabilities, but when I run your code, I get a syntax error.\
    \ I'll post my error message in my original post.\n<|/ c |>\n<| c |>\nSorry, I\
    \ forgot Ruby 1.9 doesn't allow the `return` keyword. See my updated answer.\n\
    <|/ c |>\n<| c |>\nThank you for the update. I believe that worked with my original\
    \ code, but I ran into another error that I will post in my original post.\n<|/\
    \ c |>\n<| a dscore=0 |>\nI guess this should work\n<code>\na = [0, 4, 3, 2, 1]\n\
    a.sort { |x,y| [x,y].sort.reverse.first }\n=> [1, 4, 3, 2, 0]\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails,arrays |>\n<| a dscore=0 tags=ruby,ruby-on-rails,arrays\
    \ |>\nI did something like this in Java, just thought I'd share in case you haven't\
    \ used Java for a while:\n<code>", "  l.sort.each_with_index {|el, index| index%2\
    \ == 0 ? l[index] = l[index+1] : l[index] = el}\n  return l\nend", "  even = l.dup\n\
    \  even.rotate!(0)\n  even.sort!\n  even.reverse!\n  even\nend", "  even = []\n\
    \  odd = []\n  for i in 1..l.size\n    even.push l[i]\n    odd << l[i]\n  end\n\
    \  even.push even.shift\n  even.push even.shift\n  even.push even.shift\n  odd.push\
    \ odd.shift\n  odd.push odd.shift\n  odd.push odd.shift\n  even.sort.reverse!\n\
    \  odd.sort.reverse!\n  return even.zip odd\nend\n</code>\nThe code above creates\
    \ a list of three elements: nil, 1 and 2. The first two elements are swapped and\
    \ then the last two is inserted at the end. After that the list is sorted in reverse\
    \ order. Now we can check the output!\n<code>\nirb(main):044:0> sort_even([1,2,3])\n\
    => [[1, 3, 2], [2, 3]]\nirb(main):045:0> sort_even([1,2,3])\n=> [[1, 3, 2], [2,\
    \ 3]]\n</code>\nAnd now we can compare this to your code:\n<code>\nirb(main):046:0>\
    \ sort_even([1,2,3])\n=> [[1, 3, 2], [2, 3]]\nirb(main):047:0> sort_even([1,2,3])\n\
    => [[1, 3, 2], [2, 3]]\n</code>\nNow you can see that the lists are identical\
    \ after sorting the even elements and before sorting the odd elements.\n<|/ a\
    \ tags=ruby dscore=0 |>\n<| c |>\nCan you comment your code? what does `even.zip\
    \ odd` do and why is this better than `even.rotate!`?\n<|/ c |>\n<| c |>\nI added\
    \ comments to the code. `even.zip odd` creates a new array of pairs from `even`\
    \ and from `odd` where each pair contains the even and odd elements from the respective\
    \ arrays. `even.rotate!` will just rotate the array by 90 degrees. `even.rotate!`\
    \ rotates the array by 90 degrees clockwise (by 90 degrees counter-clockwise is\
    \ `reverse!`). Thus, `even.rotate!` is better than `even.zip odd`.\n<|/ c |>\n\
    <| c |>\nThank you for the explanation. I understood it better that way. Btw,\
    \ I think `even.rotate!` does nothing for arrays smaller than size 3\n<|/ c |>\n\
    <| a dscore=0 |>\nYou were almost there.\n<code>", "  l.sort.each_with_index do\
    \ |pair, index|\n    if index % 2 == 0\n      l[index].swap(l[index / 2])\n  \
    \  end\n  end\n  l\nend\n</code>\nA function similar to the sort_even function\
    \ would be used for each of the other two conditions:\n<code>", "    l = l.clone\n\
    \    l.each_with_index do |e, i|\n        if i % 2 == 0\n            l[i] = l[i\
    \ + 1]\n        end\n    end\n    l\nend\n</code>\nNow we only need to implement\
    \ the function that sorts the list l so that it is sorted in the even indicies\
    \ while leaving all the other elements the same.\n<code>", "  # sort l in-place\
    \ while maintaining odd and even indicies.\n  odd = l.each_with_index.with_index\
    \ do |(ele,i),i|\n    if i % 2 == 0\n      ele\n    else\n      i\n    end\n \
    \ end\n  even = l.each_with_index.with_index do |(ele,i),i|\n    if i % 2 == 1\n\
    \      ele\n    else\n      i\n    end\n  end", "  l' =\n  if l.length == 0\n\
    \    l\n  else\n    l.slice!(0...(l.length / 2))\n    l = l.sort\n    l.slice!(0...(l.length\
    \ / 2)) if l.length > 0\n    l\n  end\nend", "  l' =  l.clone\n  even_indexes\
    \ = 0.step(l.length)\n  odd_indexes = odd_indexes.step(even_indexes.size)\n  even_indexes.each_with_index\
    \ do |index,even|\n    if even == 0\n      l'.insert(index, l[index])\n      l'.insert(even,\
    \ even)\n      l'.insert(even+1, l[index].clone)\n      l'.insert(even+2, l[index])\n\
    \      l'.insert(even+3, l[index].clone)\n    end\n  end\n  l'\nend", "  l2 =\
    \ []\n  index = 0\n  while index < l.length\n    if index % 2 == 0\n      l2 <<\
    \ l[index]\n      index += 1\n    else\n      index = index + 1\n    end\n  end\n\
    \  l2\nend", "  even = l.select { |x| x % 2 == 0 }\n  even.sort!\n  even\nend",
  "  even = l.to_a.select.with_index { |a,i| i % 2 == 1 }\n  odd = l.to_a.select.with_index\
    \ { |a,i| i % 2 == 0 }\n  even.zip( odd ).map { |eod| eod[0] + [eod[1]] }.flatten\n\
    end\n</code>\nand here it is in action:\n<code>\nl = [1, 3, 5, 4, 2, 6, 7]", " \
    \ evens = l.select { |x| x.modulo(2) == 0  }\n  odds  = l.select { |x| x.modulo(2)\
    \ != 0  }\n  evens.zip(odds)\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nI believe\
    \ that in Ruby >= 2.2 you can use the .sort_by method:\n<code>\na = [2, 5, 6,\
    \ 3, 9, 3, 8]\na.sort_by { |x| x % 2 }", "  even = []\n  odd = []\n  for i in\
    \ 0...l.length-1\n    even.push(l[i])\n  end\n  even.sort!\n  for i in 0...even.length-1\n\
    \    odd.push(even[i])\n  end\n  odd\nend\n</code>\nNow all you need to do is\
    \ call sort_even on the list of numbers you have, like this:\n<code>\nlist1 =\
    \ [4, 8, 5, 1, 9, 3, 7, 2, 6, 0, 10]\nlist2 = sort_even(list1)\nlist2 = sort_even(list2)\n\
    list1.sort.each_with_index do |n, i|\n  puts \"#{n} is at position #{i+1}\"\n\
    end", "  l.each do |i|\n    oddpos = i\n    evenpos = i\n    while (oddpos > 0\
    \ && l[oddpos] == l[evenpos])\n      evenpos -= 1\n    end\n    l[oddpos] = l[evenpos]\n\
    \  end\n  l\nend", "  even = []\n  odd = []\n  for i in 0..(l.length/2)-1\n  \
    \  even += l[i..i+2]\n    odd += l[i+2..i+4]\n  end\n  even.zip(odd)\nend", " \
    \   l' = nil\n    i = 0\n    loop do\n        break unless i = l.length\n    \
    \    j += 1\n        l'[i] = l[j]\n        i -= 1\n    end\n    l'\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 tags=arrays,ruby |>\nRuby's sort is stable, so it sorts\
    \ first by the first column then by the second column, and so on. So you could\
    \ do:\n<code>\narr = [\n  [4, 6],\n  [2, 5],\n  [2, 5],\n  [1, 5],\n  [2, 7],\n\
    \  [2, 7],\n  [1, 7],\n  [5, 4],\n  [2, 3]\n]", "  even = []\n  odd = []\n  even.push(*l.take_while\
    \ { |x| x % 2 == 0 })\n  odd.push(*l.take_while { |x| x % 2 != 0 })\n  sorted\
    \ = even.zip(odd).sort_by { |(a,b)| b}\n  sorted.flatten!\n  return sorted\nend",
  "  even = l[2..-1].map(&:to_i)\n  even.zip([l[0..-2].map(&:to_i), even]).each do\
    \ |(left, right)|\n    if left < right\n      left.upcase!\n    end\n  end\nend\n\
    </code>\nSo now if you run sort_even [5, 4, 1, 7, 3] in irb you will get:\n<code>\n\
    irb(main):001:0> sort_even [5, 4, 1, 7, 3]\n=> [5, 4, 1, 7, 3]\n</code>\nWhich\
    \ is identical to how sorted works on irb, except that it sorts strings in order\
    \ lexicographically instead of numerically and treats the strings differently.\
    \ \nHowever, if we change the value of each of the three elements of the input\
    \ list so that the values are in opposite order:\n<code>\nirb(main):002:0> sort_even\
    \ [5, 4, 3, 7, 1]\n=> [5, 4, 3, 7, 1]\n</code>\nThe above will work as expected\
    \ and sort those elements in ascending order when used with sorted with reverse:\
    \ true, since sorted will take each element's value and sort it with the other\
    \ values in l. This works because sort_even will always compare the even elements\
    \ with all the odd elements and when two elements compare equal, it will sort\
    \ the two elements based on the value of its odd indexes.\nIf you were to sort\
    \ a list using sort_even with reverse: true, you'd see the following:\n<code>\n\
    irb(main):001:0> sort_even [5, 4, 3, 7, 1].sorted.reverse\n=> [5, 4, 7, 3, 1]\n\
    </code>\nTo get the same behavior as sorted, you would need to use sort_even with\
    \ reverse: false and manually reverse the resulting array using Array.new.reverse_each.\n\
    As stated by others, you can easily use sort_even with multiple keys to sort your\
    \ list as such:\n<code>\nirb(main):006:0> sort_even [5, 4, 3, 7, 1].sort_by{|x|\
    \ x.to_i}.reverse\n=> [5, 4, 7, 3, 1]\n</code>\n<|/ a |>\n<| a |>\n<code>\na =\
    \ [1,2,5,3]", "  l2 = []\n  l2.push l[0]\n  for i in 1..l.length-1\n    l2.push\
    \ l[i]\n  end\n  for i in 0..(l2[0]-1).even? # find index of first element of\
    \ l2 that is not even\n    break\n  end\n  for i in 0..(l2[0]-1).even? # move\
    \ elements from l2 to l\n    l[(i+l2.length).even?] = l2[(i+l2.length).even?]\n\
    \    l2[i] = l2[i]\n  end\n  for i in 0..(l2[0]-1).even? # move the remaining\
    \ elements from l2 to l\n    l[l2.length] = l2[i]\n  end\n  return l\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nIf your array is small enough to fit into memory,\
    \ you can convert it to an array.sort by using the Array#sort method and supplying\
    \ it with your own comparison function that can compare values differently by\
    \ using the <=> operator.\n<code>\nmy_array.sort { |a,b| [a,b] <=> [b,a] }\n</code>\n\
    To convert your array to a sorted array, you can use the Array#[] method.\n<code>\n\
    sorted_array = my_array.reject { |e| e.odd? }\nsorted_array = my_array.sort {\
    \ |a,b| [a,b] <=> [b,a] }\n</code>\n<|/ a tags=ruby |>\n<| c |>\nHmmm, why does\
    \ it say it's too big to fit into memory?  I only have 1 gig of ram\n<|/ c |>\n\
    <| c |>\nBecause you're using an array.  If you convert it to an Array, the sort\
    \ will be fast because Ruby does not need to copy the entire array.\n<|/ c |>\n\
    <| c |>\nSorry - missed that you were converting to a sorted array. Will update\
    \ my answer.\n<|/ c |>\n<| c |>\nThis would not work when an item is duplicated,\
    \ though.\n<|/ c |>\n<| a tags=ruby dscore=0 |>\nIf you have very large arrays,\
    \ consider using the Array#sort method with an alternative comparison method.\
    \ The default comparison method for arrays is based on a lexicographic order,\
    \ so you can implement your own comparison method. The following example shows\
    \ how it can be done for arbitrarily large arrays:\n<code>", "  l.sort.with_index\
    \ { |e,i| i%2 == 1 ? i : i }\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\nA more\
    \ generic solution which allows arbitrary levels of nesting.\n<code>", "  l2 =\
    \ [0 for i in 0...(l.length/2)]\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0...l.length/2\n    l = l[i..(l.length-i)]\n\
    \    l2[i/2] = l[i/2]\n  end\n  for i in 0.", "\ti = 0\n\twhile i < l.length\n\
    \t\tl[i].even = true\n\t\ti += 1\n\tl = l.sort {|x, y| y.even? ? 0 : 1}\n\ti =\
    \ 0\n\twhile i < l.length\n\t\tl[i].even = false\n\t\ti += 1\n\tl = l.sort {|x,\
    \ y| y.even? ? 1 : 0}\n\ti = 0\n\twhile i < l.length\n\t\tl[i].even = false\n\t\
    \ti += 1\n\treturn l\nend", "  i = 0\n  lp = nil\n  while i < l.size\n    if (l[i]\
    \ % 2 == 0)\n      lp ||= []\n      lp << l[i]\n      i += 1\n    else\n     \
    \ l[i] = lp[i]\n      i += 1\n    end\n  end\n  l\nend", "  # Return an empty\
    \ list if the list is empty\n  return l if l.size == 0 ", "  l2 = []\n  even =\
    \ []\n  odd = []\n  i = 0\n  while i < l.length\n    if i % 2 == 0\n      even.push(l[i])\n\
    \      l2.push(even.sort)\n    else\n      odd.push(l[i])\n      l2.push(odd.sort)\n\
    \    end\n    i += 1\n  end\n  return l2\nend", "  sorted = []\n  i = 0\n  while\
    \ i < l.length\n    sorted.push l.at(i)\n    i += 1\n  end\n  i = 0\n  while i\
    \ < l.length\n    if i % 2 == 0\n      sorted.push l.at(i)\n      i += 1\n   \
    \ else\n      sorted.push l.at(i) + l.at(i + 1)\n      i += 1\n    end\n  end\n\
    \  sorted\nend", "  return l.sort do |a,b|\n    if a.odd? || b.odd?\n      a <=>\
    \ b\n    else\n      a <=> b\n    end\n  end\nend\n</code>\nThe code above sorts\
    \ l and returns the sorted list, but I've also put in a function that takes a\
    \ list and sorts it by comparing the values of all the even indicies of l to the\
    \ values of all the even indicies of l.\n<code>", "  # initialize a list to hold\
    \ our sorted values\n  ls = []", "    even = l[1..-1].sort\n    odd = even.map\
    \ { |x| x.odd? ? x : \"#{ x }\" }\n    even.map { |x| x.odd? ? x : \"#{ x }\"\
    \ }\nend", "  l.sort.each_with_index { |e, i| l[i] = l[i % 2] += e if i % 2 ==\
    \ 0 }\n  l\nend", "    even = l[1..-1]\n    odd = l[0..-2]\n    even.zip(odd).sort{|a,b|\
    \ a <=> b}\nend\n</code>\n<|/ a |>\n<| a |>\n<code>\na = [5, 1, 3, 8, 2, 6, 9,\
    \ 4, 7]\na.each_with_index.sort_by {|el, i| i}.last", "  sorted = l.dup\n  for\
    \ i in 0...(l.size - 1) / 2\n    sorted.sort! { |a, b| a[i ^ 1] => b[i ^ 1] }\n\
    \  end\n  return sorted\nend", "  l.sort!\n  l[1..-1].zip(l[1..-1]).map {|x, y|\
    \ x if y % 2 == 1} + l\nend", "    l.sort\n    evens = []\n    evens.concat l[0,1]\n\
    \    evens.concat l[0,2]\n    evens.concat l[1,0]\n    evens.concat l[1,2]\n \
    \   evens.concat l[2,0]\n    evens.concat l[2,1]\n    evens.concat l[2,2]\n  \
    \  evens\nend", "  odd_index = l.index(l[1])\n  even_index = l.index(l[2])\n \
    \ even_values = l[even_index:]\n  even_values.insert(0, l[1])\n  even_values.insert(0,\
    \ l[2])\n  even_values = even_values.sort\n  l[odd_index], l[even_index] = even_values,\
    \ l[odd_index] # Swap the even and odd values.\n  l\nend", "    l.sort!\n    l.reverse!\n\
    \    l = l[1..-1]\n    l.reverse!\n    l\nend", "    \n    # Sort the even indicies\
    \ in descending order (largest to smallest)\n    even = l.sort_by { |x| -x.to_i\
    \ }\n    \n    # Get the values of even indicies in ascending order (smallest\
    \ to largest)\n    even_values = even.values\n    \n    # Set the values of even\
    \ indicies in l' to equal\n    # the values of even indicies in even_values (and\
    \ sorted)\n    even.each { |x| l[x] = even_values.shift }\n    \n    # Return\
    \ the list l' with the odd indicies sorted\n    return even\nend", "  l2 = []\n\
    \  even_indexes = (0...l.length).step(2).to_a\n  odd_indexes = (0...l.length).step(2).to_a.map\
    \ { |i| i + 1 }\n  even_indexes.each do |i|\n    l2 << l[i] if odd_indexes.include?\
    \ i\n  end\n  l2.sort.concat(l.sort) if even_indexes.any?\nend", "  even = l.select\
    \ {|el| el % 2 == 0}\n  even.sort.reverse.zip(even).map(&:reverse).flatten.uniq\n\
    end", "  even = []\n  odd = []\n  l.each do |l|\n    odd << l\n  end\n  odd.each\
    \ do |l|\n    even.push( odd.index l )\n  end\n  even.each do |l|\n    even.delete(\
    \ l )\n  end\n  even.sort!\n  even\nend", "  # if there are no even indicies,\
    \ return l\n  if l.length == 0\n    l\n  else\n    # Sort the even indicies of\
    \ the list\n    # l.sort!\n    l = l.sort { |a, b| b.to_i < a.to_i }\n    # If\
    \ the original list had more even indicies than odd indicies,\n    # then fill\
    \ the original list with nils.\n    # l[0...-1].each { |x| l.unshift(nil) }\n\
    \    # Return l with the original odd indicies in the even positions\n    # and\
    \ nils in the even positions of the original list.\n    l\n  end\nend", "  even\
    \ = []\n  odd = []\n  odd_sorted = []\n  even.push(*l)\n  odd.push(*l)\n  while\
    \ even.length > 0\n    even.shift\n    odd.shift\n    even.each_with_index do\
    \ |e, i|\n      unless odd.include?(e)\n        odd.push(e)\n      else\n    \
    \    odd_sorted = odd_sorted << e\n      end\n    end\n    odd_sorted.each_with_index\
    \ do |odd, i|\n      unless even.include?(odd)\n        even.push(odd)\n     \
    \ else\n        odd_sorted = odd_sorted << odd\n      end\n    end\n    odd_sorted\
    \ = odd_sorted << odd.last\n  end\n  odd_sorted.reverse\nend", "  even = l.select\
    \ { |x| x.odd? }\n  odd = l.select { |x| x.even? }\n  even.zip(odd).map { |eod|\
    \ eod[0] + eod[1] }\nend", "  even = [l[i] for i in range(len(l)) if i % 2 ==\
    \ 0]\n  even.sort()\n  new_list = []\n  for i in range(len(even)):\n    new_list.append(even[i])\n\
    \  return new_list\nend", "  return l.sort {|a, b| b % 2 != 0 ? a : b}\nend\n\
    </code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails |>\n<| c |>\nthanks Rudy, but\
    \ i need to reorder my array in odd places as well. Do you know how to do that?\n\
    <|/ c |>\n<| c |>\nThe function I have posted does that.  `sort_odds` returns\
    \ a sorted version of the array where all odd indicies are sorted from lower to\
    \ higher and even indicies are sorted from higher to lower in the array.\n<|/\
    \ c |>\n<| c |>\nthanks again. but when I test it, i get following output: `[5,\
    \ 2, 3, 6, 4, 1, 7, 8]\n=> [5, 2, 3, 6, 4, 1, 7, 8]`\n<|/ c |>\n<| c |>\nAh I\
    \ see, you wanted it to be sorted.  Then use this: `[5, 2, 3, 6, 4, 1, 7, 8].sort\
    \ { |a, b| b % 2 != 0 ? a : b }`\n<|/ c |>\n<| c |>\nI edited my answer so that\
    \ the function returns an array rather than a sorted version of the array.\n<|/\
    \ c |>\n<| a |>\nRuby has two functions for this purpose:\n<code>\na = [5, 2,\
    \ 3, 6, 4, 1, 7, 8]\na.permutation(2).map(&:sort).flatten.uniq\n=> [5, 1, 6, 2,\
    \ 7, 3, 8, 4]", "\tlenght = l.length\n\teven = Array.new(lenght)\n\teven.fill(l)\n\
    \tfor i in 0...lenght-1\n\t\teven[i].each_with_index do |value,index|\n\t\t\t\
    if index%2 == 0\n\t\t\t\teven[i].swap(0,index)\n\t\t\t\teven[i].sort\n\t\t\t\t\
    even[i].swap(0,index)\n\t\t\tend\n\t\tend\n\tend\n\treturn even\nend\n</cell>\n\
    <text>\nExercise 2\nA function get_odd_even(l) takes a list l as argument. It\
    \ returns a list l' such that l' is identical to l in the odd indicies, while\
    \ its values at the even indicies are equal to the values of the even indicies\
    \ of l, but sorted.", "  l.sort_by { |x| x.odd? ? x.to_i : x }\nend", "    even\
    \ = l.select{|e| e.odd?}\n    even = even.sort.reverse\n    even.reverse!\n  \
    \  even.map!{|e| l.index(e)}.compact!.uniq!\n    even\nend", "  even = [nil]\n\
    \  odd  = [nil]\n  even.concat(l)", "  even_indices = []\n  odd_indices = []\n\
    \  l.each do |e|\n    if e%2 == 0\n      even_indices << e\n    else\n      odd_indices\
    \ << e\n    end\n  end\n  even_indices.sort!\n  even_indices.each do |e|\n   \
    \ odd_indices.delete(e)\n  end\n  odd_indices.each do |e|\n    even_indices.insert(e,e)\n\
    \  end\n  return even_indices\nend", "  l2 = []\n  even = even_indexes(l)\n  odd\
    \ = odd_indexes(l)\n  for index in even\n    l2 << l[index]\n  end\n  even.each_index\
    \ do |i|\n    l2[odd[i]] = l2[even[i]]\n  end\n  l2.sort\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nThanks for your reply. Yes, this was the thought that drove me\
    \ to solve this problem. I will post the code tomorrow morning.\n<|/ c |>\n<|\
    \ c |>\nSure thing, but if you want something that will work in any situation,\
    \ you should post your code in your question.\n<|/ c |>\n<| c |>\nActually, I\
    \ see now that you're using `sort_by` instead of `sort`.\n<|/ c |>\n<| c |>\n\
    I updated the post to show the updated code. Thanks for your help.\n<|/ c |>\n\
    <| c |>\nAh, I see now... I forgot about `sort`. Thanks.\n<|/ c |>\n<| a tags=ruby,arrays,sorting,ruby-on-rails\
    \ dscore=1 |>\n<code>", "  even = []\n  odd = []", "  a = [l[i] for i in 0...l.size-1]\n\
    \  b =  [i for i in 0...l.size-1]\n  a.zip(b).map { |x, y| y if x % 2 == 0 }.sort\n\
    end", "  l.map!{ |x| x.is_a?(Fixnum) ? x.to_s : x }\n  l.sort.map!{ |x| x.is_a?(Fixnum)\
    \ ? x.to_s : x }\n  l\nend", "  return l.sort.map { |i| i%2 == 0 ? i : i+1 }\n\
    end", "  even = []\n  odd = []\n  even.push(*l.take(l.length / 2))\n  even.push(*l.drop(l.length\
    \ / 2))\n  odd.push(*l.take(l.length / 2))\n  odd.push(*l.drop(l.length / 2))\n\
    \  return even.zip(odd).sort_by{|a,b| a}\nend", "  l2 = []\n  even = []\n  odd\
    \ = []\n  for i in 0 .. l.length/2\n    # even\n    if i%2==0\n      even << l[i]\n\
    \    else\n      # odd\n      odd << l[i]\n    end\n  end\n  l2 << even.sort\n\
    \  l2 << odd.sort\n  l2.flatten!\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank\
    \ you so much for you help! Just a quick question, what is the \"0\" meant in\
    \ this statement -> for i in 0..length/2?\n<|/ c |>\n<| c |>\n: it's part of the\
    \ syntax of a range; 0..length/2 will give you 0, then 1, then 2, then 3, and\
    \ so on, while length/2 will give you length/2 (which would yield 4, or length/2,\
    \ if you did `length = 15`), then length/2+1, then length/2+2, etc.\n<|/ c |>\n\
    <| c |>\nOhh okay, I thought length was a variable name so I thought it might\
    \ need to be a variable. Anyway thanks again for all your help.\n<|/ c |>\n<|\
    \ c |>\n: Length is indeed a variable, but its value is never used in your code;\
    \ so I removed it from the example. Also, note that this answer assumes you're\
    \ passing it a list; if you're passing it an array, it won't work and you'll need\
    \ to modify the code accordingly (`length` doesn't exist).\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby |>\nAnother way is to loop over an array using each and index to extract\
    \ the odd and even elements.\n<code>\na = [1,2,3,4,5,6,7,8,9]\nodd_even = a.each.with_index.select\
    \ { |e,i| i % 2 == 0 }\nodd_even # => [2,4,6,8]\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\nHere's a way that uses Array#partition which was introduced in Ruby 1.9.\n\
    <code>\n[1,2,3,4,5,6,7,8,9].partition { |x| x % 2 == 0 }", "  sorted = []\n  even\
    \ = l.take_while { |x| x.odd? }.sort\n  even.zip(even).take(l.size).each { |x,y|\
    \ sorted.concat([x,y]) }\n  sorted\nend\n</code>\n<|/ a |>\n<| c |>\nThanks this\
    \ is exactly what I was looking for. Great explanation as well. Sorry if I was\
    \ unclear in my question. Thanks again.\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    <code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\nb = a.partition{\
    \ |i| i%2 == 0 }\nc = b.shift\np [c, b.zip(b.shift)]", "    l = l.sort\n    return\
    \ l.reverse\nend", "  return l\nend", "  l2 = []\n  i = 0\n  while i < l.length\n\
    \    if i % 2 == 0\n      l2 << l[i]\n      i += 1\n    else\n      l2 << l[i-1]\n\
    \      i += 1\n    end\n  end\n  l2\nend", "  even = l.dup\n  even.shuffle\n \
    \ even.each_with_index { |x, i| even[i] = i }\n  even.compact!\n  even\nend",
  "  even = []\n  odd = []\n  for i in 0..l.length-1\n    if i%2 == 0\n      even\
    \ << l[i]\n    else\n      odd << l[i]\n    end\n  end\n  return even.concat(odd).sort!\n\
    end", "  even = l.select.with_index { |x, i| i.odd? }\n  even.sort.zip(even).flatten\n\
    end", "  l.each_with_index do |e, i|\n    l.delete_at i\n    l.insert i, e\n \
    \ end\nend", "  even = l[1..-1].sort.to_a\n  odd = l.sort.to_a\n  even.each_with_index\
    \ do |v, i|\n    odd[i] = v\n  end\n  odd + even\nend\n</code>\nThis returns a\
    \ list of the same length as the input list l and with every even indexed element\
    \ equal to its corresponding odd indexed element, sorted.\n<|/ a dscore=3 |>\n\
    <| a dscore=3 |>\nThe other answers here are good, but I thought it would be good\
    \ to point out that you can also solve this problem with each_cons.\n<code>",
  "  l2 = []\n  for i in 0..(l.length / 2)\n    l2.push(l[i])\n  end\n  for i in (0..l.length\
    \ - 1) / 2\n    l2.push(l[i])\n  end\n  return l2\nend", "  lsorted = []\n  i\
    \ = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n      lsorted.push([l[j],\
    \ l[i]])\n      j += 1\n    end\n    i += 1\n  end\n  lsorted.sort!\n  lsorted.map!\
    \ {|x| x[1]}\n  return lsorted\nend", "  l.sort.tap { |l| l.reverse! }\n  l ==\
    \ l.sort.reverse ? l : l.reverse\nend", "  l = [1,3,4]\n  l' =[1,3,4]\n  # l'\
    \ will be identical to the original list 'l' but with its values at the odd indicies\
    \ equal\n  # to the values at the even indicies of 'l' \n  for i in 1..(l.length-1)\n\
    \    if l[i] % 2 == 0\n      l'.insert(l[i].to_i, l[i].to_i+1)\n    else\n   \
    \   l'.insert(l[i].to_i, l[i].to_i-2)\n    end\n  end\n  l'\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a tags=arrays,ruby |>\n<code>\na = [2,4,7,6,5,3,0,9,1,8]\n\
    a.each_with_index.map { |v,i| i % 2 == 0 ? v : a.rindex(v)-1 }.compact\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=arrays,ruby dscore=0 |>\n<code>\narr = [2,4,7,6,5,3,0,9,1,8]",
  "  # Sort the list\n  sorted = sort_by_even_index(l)\n  # Go through the sorted\
    \ list and switch its values with the odd indicies values\n  odd_indicies = []\n\
    \  for i in sorted\n    odd_indicies << sorted[i.to_i]\n  end\n  odd_indicies\
    \ << sorted.last.to_i\n  # Return sorted list with even indicies switched\n  return\
    \ odd_indicies\nend", "  l1 = l\n  l2 = []\n  for i in 0 .. l.length-1\n    if\
    \ i.odd?\n      l2.push(l1.pop)\n    else\n      l2.push(l1.pop)\n      l2.push(l1.pop)\n\
    \      l2.push(l1.pop)\n    end\n  end\n  l\nend", "  l' = l.dup\n  l' -= l' %\
    \ 2 #remove odd indicies\n  l' += l' / 2 #duplicate values\n  l' -= l' / 2 #remove\
    \ duplicates\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n\
    \  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l'\
    \ / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate\
    \ values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n\
    \  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l'\
    \ / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate\
    \ values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n\
    \  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l'\
    \ / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate\
    \ values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n\
    \  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l'\
    \ / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate\
    \ values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n\
    \  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l'\
    \ / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate\
    \ values\n  l' += l' / 2 #duplicate values\n  l' += l' / 2 #duplicate values\n\
    \  l' += l' / 2 #duplicate values\n  l' += l' / 2 #", "  even = []\n  odd = []\n\
    \  for i in l\n    even.push(i)\n    odd << i\n  end\n  even.sort, odd.sort\n\
    end", "    even = Array.new(l.length/2) do |i|\n        l[2*i] \n    end\n   \
    \ odd = l.dup\n    even.zip(odd).sort.each do |e|\n        l[2*e[0]] = e[1]\n\
    \    end\n    l\nend", "  l.each_with_index { |elem, index| l[index] = elem if\
    \ index % 2 == 1 }\n  l.sort\nend", "  # sort the even indicies of l\n  l'.sort.each_with_index\
    \ do |val, i| \n    if i % 2 == 0\n      l'[i] = val\n    end\n  end\nend", " \
    \ even = []\n  odd = []\n  for i in 0..l.size-1\n    even += l[i].to_a\n    odd\
    \ += l[i].to_a[1..-1].to_a\n  end\n  [even, odd]\nend", "  even = []\n  odd =\
    \ []\n  for i in 0...(l.length-1)\n    if l[i] % 2 == 0\n      even << l[i]\n\
    \    else\n      odd << l[i]\n    end\n  end\n  even.sort!\n  odd.sort!\n  even.zip(odd).flatten!\n\
    \  even\nend", "    even = []\n    odd = []\n    for i in l\n        if i.odd?\n\
    \            even.push(i)\n        else\n            odd.push(i)\n    end\n  \
    \  even.concat(odd.sort_by{|x| x.even?}.map(&:first))\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,sorting |>\nHere's a solution that uses a block comparison:\n\
    <code>", "  l' =[]\n  odd_pos = 0\n  even_pos = 0\n  while even_pos < l.length\n\
    \    if l[even_pos] == l[odd_pos]\n      l'.push l[even_pos]\n      even_pos +=\
    \ 1\n      odd_pos += 1\n      even_pos += 1\n      odd_pos += 1\n      even_pos\
    \ += 1\n      odd_pos += 1\n      even_pos += 1\n    else # l[even_pos] < l[odd_pos]\n\
    \      l'.push l[even_pos]\n      even_pos += 1\n      odd_pos += 1\n      even_pos\
    \ += 1\n      odd_pos += 1\n      even_pos += 1\n      odd_pos += 1\n      even_pos\
    \ += 1\n      odd_pos += 1\n    end\n  end\n  l'.push l[odd_pos]\n  l' \nend",
  "  l1 = []\n  even_indices = []\n  odd_indices = []\n  for i in 0..length(l)\n \
    \   odd_indices << i\n  end\n  for i in 0..even_indices.length - 1\n    even_indices\
    \ << i\n  end\n  even_indices.sort do |a, b|\n    return 0 if a==b\n    return\
    \ a if a < b\n    return b\n  end\n  for i in 0..even_indices.length - 1\n   \
    \ odd_indices << i\n  end\n  for i in 0..odd_indices.length - 1\n    l1 << (l[odd_indices[i]]\
    \ << l[even_indices[i]])\n  end\n  l1\nend", "  even = l.select {|x| x % 2 ==\
    \ 0}\n  even.sort!\n  even.each_with_index {|x, i| l[i] = even[i] }\n  return\
    \ even\nend\n</code>\nTest:\n<code>\nsort_even [5,5,5,5,5,7,7,7,7,7,7]", "   \
    \ l1 = []\n    l2 = []\n    l = l.sort\n    l2 = []\n    \n    if l.length ==\
    \ 1 and l.first == nil\n        return nil\n    end\n    \n    for i in 0...l.length/2\n\
    \        l2 << l[i]\n    end\n    l1 = sort_even(l2)\n    \n    for i in 0...l.length/2\n\
    \        l2 << l[l.length-i-1]\n    end\n    l1 = sort_even(l2)\n    \n    for\
    \ i in 0...l.length/2\n        l2 << l[l.length-i-1]\n    end\n    l1 = sort_even(l2)\n\
    \    \n    for i in 0...l.length/2\n        l2 << l[i]\n    end\n    l1 = sort_even(l2)\n\
    \    \n    l2 = nil\n    for i in 0...l.length/2\n        l2 << l[i]\n    end\n\
    \    l1 = sort_even(l2)\n    \n    l2 = []\n    for i in 0...l.length/2\n    \
    \    l2 << l[i]\n    end\n    l1 = sort_even(l2)\n    \n    for i in 0...l.length/2\n\
    \        l2 << l[l.length-i-1]\n    end\n    l1 = sort_even(l2)\n    \n    for\
    \ i in 0...l.length/2\n        l2 << l[l.length-i-1]\n    end\n    l1 = sort_even(l2)\n\
    \    \n    l2 = []\n    for i in 0...l.length/2\n        l2 << l[i]\n    end\n\
    \    l1 = sort_even(l2)\n    \n    for i in 0...l.length/2\n        l2 << l[l.length-i-1]\n\
    \    end\n    l1 = sort_even(l2)\n    \n    l2 = []\n    for i in 0...l.length/2\n\
    \        l2 << l[i]\n    end\n    l1 = sort_even(l2)\n    \n    for i in 0...l.length/2\n\
    \        l2 << l[l.length-i-1]\n    end\n    l1 = sort_even(l2)\n    \n    l2\
    \ = []\n    for i in 0...l.length/2\n        l2 << l[i]\n    end\n    l1 = sort_even(l2)\n\
    \    \n    for i in 0...l.length/2\n        l2 << l[l.length-i-1]\n    end\n \
    \   l1 = sort_even(l2)\n    \n    l2 = []\n    for i in 0...l.length/2\n     \
    \   l2 << l[i]\n    end\n    l1 = sort_even(l2)\n    \n    for i in 0...l.length/2\n\
    \        l2 << l[l.length-i-1]\n    end\n    l1 = sort_even(l2)\n    \n    l2\
    \ = []\n    for i in 0...l.length/2\n        l2 << l[i]\n    end\n    l1 = sort_even(l2)\n\
    \    \n    for i in 0...l.length/2\n        l", "  l2 = []\n  for i in 0..length(l)\
    \ - 1\n    if i & 1 == 0\n      l2 << l[i]\n    else\n      l2 << l[i - 1] + l[i]\n\
    \    end\n  end\n  l2.sort\nend", "  n = l.length\n  l'.push(nil)\n  for i in\
    \ 0...n-1\n    if l[i] && l[i].odd?\n      l'.unshift(l[i])\n    else\n      l'.unshift(l[i])\
    \ if !l'.last\n      l'.pop\n    end\n  end\n  l'.sort_by!\nend\n</code>\n<|/\
    \ a tags=ruby,sorting |>\n<| c |>\nIt seems that the `sort_by!` method is being\
    \ deprecated. Any workaround for this?\n<|/ c |>\n<| c |>\n, `sort_by!` has been\
    \ deprecated in favour of `sort!` now. The latter does not have the `reverse`\
    \ parameter, but you can do `l.sort! { |x,y| x.odd? ? -y.odd? : -x.odd? }`.\n\
    <|/ c |>\n<| a |>\nI like's answer because it's simple and effective. However\
    \ I'd like to offer a different approach to solving this problem using a single\
    \ pass of the array.\n<code>", "  l2 = l.dup\n  l2.sort\n  l2.each_with_index\
    \ do |e, i|\n    l2[i] = l[i.even] if i % 2 == 0\n  end\n  l2\nend", "    even\
    \ = []\n    odd = []\n    odd.extend(l[:1]) # Add the first element\n    odd.extend(l[2:])\
    \ # Add the rest of the elements\n    even.extend(odd.pop(:even)) # Add the odd\
    \ indicies with corresponding values of even\n    even.extend(odd.pop(:even))\
    \ # Add the even indicies with corresponding values of even\n    even.extend(odd.pop(:even))\
    \ # Add the even indicies with corresponding values of even\n    even.extend(odd.pop(:even))\
    \ # Add the even indicies with corresponding values of even\n    return even +\
    \ odd\nend", "  if l.length == 0 || l[0].nil?\n    return l\n  end", "    even\
    \ = []\n    odd = []\n    sorted_even = []\n    sorted_odd = []\n    for i in\
    \ l\n        if i % 2 == 0\n            even.push(i)\n        else\n         \
    \   odd.push(i)\n            sorted_even.push(even.sort)\n            even = []\n\
    \        end\n    end\n    sorted_odd.push(odd.sort)\n    return sorted_odd\n\
    end", "  even = []\n  odd = []\n  for i in 0..(l.length-1) # iterate through all\
    \ elements of the list\n    if i % 2 == 0 then # if even\n      even << l[i]\n\
    \    else # if odd\n      odd << l[i]\n    end\n  end\n  even.sort! # sort even\n\
    \  odd.sort! # sort odd\n  l[0..l.length-2] += even # append even\n  l[0..l.length-1]\
    \ += odd # append odd\n  l\nend", "  even = l.clone\n  even.each_with_index do\
    \ |v,i|\n    next if i.odd?\n    even[i] = v\n  end\n  even\nend", "  return l.sort\
    \ { |a,b| b <=> a }\nend", "  l.each_with_index {|elem, i| i /= 2 if i % 2 ==\
    \ 1}\n  l.sort.each_with_index {|elem, i| l[i] = elem}\n  l\nend", "  even_inds\
    \ = []\n  odd_inds = []", "  l1 = l.clone\n  l1.shuffle\n  even = []\n  odd =\
    \ []\n  i = 0\n  while i < l1.length\n    even.push(l1[i])\n    i = i + 1\n  end\n\
    \  i = 0\n  while i < l1.length\n    if i % 2 == 0\n      even.push(l1[i])\n \
    \     i = i + 1\n    else\n      odd.push(l1[i])\n      i = i + 1\n    end\n \
    \ end\n  even.sort\n  odd.sort\n  even.concat(odd)\n  return even\nend", "  l.sort.each_with_index\
    \ do |e, i|\n    return l if i == 0\n    l[i-1] = e\n  end\nend", "  lsorted =\
    \ []\n  even = []\n  odd = []\n  for i in (0..l.length/2)\n    if i % 2 == 0\n\
    \      even.push l[i]\n    else\n      odd.push l[i]\n    end\n  end\n  even.each\
    \ do |value|\n    lsorted.push value\n  end\n  odd.each do |value|\n    lsorted.push\
    \ value\n  end\n  lsorted\nend", "    even_values = l[2..-1]\n    even_values.sort!\n\
    \    even_values\nend\n</cell>\n<text>\nFinally, let's try it out:", "  l.sort\
    \ { |x,y| x % 2 != 0 ? y : x }\nend", "  l.each do |i|\n    l.delete(i)\n    l.insert(i,\
    \ l[i])\n  end\n  l\nend", "  new_list=[]\n  new_list.concat!(l)\n  new_list.sort!{|x,y|\
    \ x % 2 == y % 2}\n  new_list.sort!{|x,y| x.to_i==y.to_i}\nend\n</code>\nThe first\
    \ line is basically the same as the code you posted, but I decided to split it\
    \ up into two lines for readability. new_list.sort!{|x,y| x % 2 == y % 2}\nis\
    \ basically saying \"sort this list based on the evenness of each item in that\
    \ list\". It's sorting it based not just on the evenness, but on the evenness\
    \ and a secondary sort, based on how long each item in the list is. I used the\
    \ modulo operator % to identify whether an even or odd number is being passed\
    \ in. It could also be written as \nnew_list.sort!{|x,y| (x % 2 == 0) ? (x.to_i\
    \ > y.to_i) : ((x.to_i < y.to_i) ? 1 : 0)}.\nThe second line is saying \"sort\
    \ this list based on the position of each item in that list\". It's sorting it\
    \ based not just on the position, but on the position and a secondary sort, based\
    \ on how long each item in the list is. I used the to_i method to convert the\
    \ strings to integers, as you mentioned in your comment. This could be shortened\
    \ to just using new_list.sort!{|x,y| x.to_i > y.to_i}.\n<|/ a tags=sorting,ruby,arrays,string\
    \ |>\n<| c |>\nThe final sort is sort of backwards, because you're sorting by\
    \ the length rather than the position. I think he wanted to sort them on the length,\
    \ so that all the even strings are at the start of the list.\n<|/ c |>\n<| c |>\n\
    You're right. I hadn't noticed the last line of the question was the reverse order.\
    \ Fixed now.\n<|/ c |>\n<| a |>\nI think you can do this with sort_by\n<code>\n\
    puts [\"aaaaa\",\"bbbbbbb\",\"ccccc\",\"dddddddd\"].sort_by{|a| a.chars.count{|c|\
    \ c.to_i}}.reverse\n</code>\n<|/ a dscore=1 tags=sorting,ruby,arrays,string |>\n\
    <| a dscore=0 |>\n<code>\narray = [\"aaaaa\",\"bbbbbbb\",\"ccccc\",\"dddddddd\"\
    ]", "  l.sort!\n  even_inds = []\n  odd_inds = []\n  while l.length > 0\n    ind\
    \ = l.length / 2\n    even_inds << ind if ind % 2 == 0\n    odd_inds << ind if\
    \ ind % 2 == 1\n    l.delete_at(ind)\n  end", "  n = 0\n  while n < l.length -\
    \ 1\n    k = l[n]\n    l[n] = l[n+1]\n    l[n+1] = k\n    n += 2\n  l\nend", " \
    \ l2 = []\n  odd = 0\n  even = 1\n  l = l.sort\n  l.each_with_index do |element,\
    \ index|\n    index % 2 ? l2.push(element) : l2[odd] = element\n    even = odd\
    \ = index\n  end\n  l2\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nIt's not quite\
    \ clear that that's what he wants. He says \"in the odd indicies\", but your solution\
    \ does not consider that ordering (it would still sort the even indicies), and\
    \ it does not use two passes over the list. In fact, your code runs O(n) extra\
    \ times.\n<|/ c |>\n<| c |>\nAh, I see... well, it was late and I was just being\
    \ cautious. But I see what you're saying, and I'll edit my response to reflect\
    \ that.\n<|/ c |>\n<| c |>\nI'm actually not even sure that would be O(n), but\
    \ I think you're right. My reasoning was that you're making the list two passes\
    \ over the list, and that would make it O(n^2). Thanks for making me re-think\
    \ it.\n<|/ c |>\n<| c |>\nThis is still O(n^2) (for big n) and is O(n) for small\
    \ n. I was originally thinking something along the lines of O(n log n), but I\
    \ think there's an easier way to make it O(n). You just need a comparison sort\
    \ that knows to compare two values when they are in that order.\n<|/ c |>\n<|\
    \ c |>\nActually, the code in the edit is correct, it's just that it's O(n^2)\
    \ because of the `push` calls in the loop. With two passes over the list, you\
    \ get an O(n) sort.\n<|/ c |>\n<| a |>\nJust to give a more concise version that\
    \ works:\n<code>", "  l2 = l.clone\n  l2.each_index { |i| l2.delete(i) }\n  l2.each_with_index\
    \ { |e, i| l2.insert(i, e) }\n  l2\nend\n</code>\nIt can be easily adapted to\
    \ use Enumerable#chunk:\n<code>", "  return l.sort.each_with_index do |item, index|\n\
    \    return item if index%2 == 1\n    l.delete_at(index)\n  end\nend", "  even\
    \ = []\n  odd = []\n  l.reverse!", "  return l.sort_by {|e| e%2 ? e : -1*e}\n\
    end", "  even = []\n  odd = []\n  \n  even.push l[0]\n  odd.push l[0]\n  \n  l.each\
    \ do |x|\n    next if even.length % 2\n    even.push x\n  end\n  \n  l.each do\
    \ |x|\n    next if odd.length % 2\n    odd.push x\n  end\n  \n  [even, odd]\n\
    end", "  l=l.sort\n  even_i=[]\n  odd_i=[]\n  \n  # The first odd indicies are\
    \ the indicies of l where the values in l are greater than the\n  # first odd\
    \ value in l\n  \n  for i in l.each_with_index\n    case i.odd?\n      when true\
    \ then even_i << i.first\n      when false then odd_i << i.first\n    end\n  end\n\
    \  \n  even_i.sort!\n  odd_i.sort!\n  \n  \n  l.map! {|x| x[even_i].zero? ? x[odd_i].first\
    \ : x[even_i]}\n  l\nend", "  even_indexes = (0...l.length)\n  even_values = even_indexes.collect\
    \ { l[$_] }", "  l2 = []\n  for i in l\n    if i % 2 == 0\n      l2 << l[i]\n\
    \    else\n      l2 << l[i] << l[i + 1]\n    end\n  end\n  l2\nend", "  even =\
    \ l[1..-1]\n  odd = l[0..-2]\n  return even.zip(odd).sort.reverse\nend", "  l'.sort!\n\
    \  for i in 0..(l'.size-1)\n    if i % 2 == 0\n      l'[i]\n    end\n  end\n \
    \ l'\nend", "  l = l.sort.reverse\n  return l[(1..l.length).step(2)].reverse\n\
    end", "  odd_even = l.dup\n  odd_even.each_with_index do |e, i|\n    if i % 2\
    \ == 0\n      odd_even.swap(i, i + 1)\n    end\n  end\n  return odd_even\nend\n\
    </code>\nIt works as follows (assuming the above methods are defined):\n<code>\n\
    sort_even(\n  [\n    :a_to_z_1,\n    :a_to_z_2,\n    :a_to_z_3,\n    :a_to_z_4,\n\
    \    :a_to_z_5,\n    :a_to_z_6,\n    :b_to_z_1,\n    :b_to_z_2,\n    :b_to_z_3,\n\
    \    :b_to_z_4,\n    :b_to_z_5,\n    :b_to_z_6,\n    :c_to_z_1,\n    :c_to_z_2,\n\
    \    :c_to_z_3,\n    :c_to_z_4,\n    :c_to_z_5,\n    :c_to_z_6,\n    :d_to_z_1,\n\
    \    :d_to_z_2,\n    :d_to_z_3,\n    :d_to_z_4,\n    :d_to_z_5,\n    :d_to_z_6,\n\
    \    :e_to_z_1,\n    :e_to_z_2,\n    :e_to_z_3,\n    :e_to_z_4,\n    :e_to_z_5,\n\
    \    :e_to_z_6,\n    :f_to_z_1,\n    :f_to_z_2,\n    :f_to_z_3,\n    :f_to_z_4,\n\
    \    :f_to_z_5,\n    :f_to_z_6,\n    :g_to_z_1,\n    :g_to_z_2,\n    :g_to_z_3,\n\
    \    :g_to_z_4,\n    :g_to_z_5,\n    :g_to_z_6,\n    :h_to_z_1,\n    :h_to_z_2,\n\
    \    :h_to_z_3,\n    :h_to_z_4,\n    :h_to_z_5,\n    :h_to_z_6,\n    :i_to_z_1,\n\
    \    :i_to_z_2,\n    :i_to_z_3,\n    :i_to_z_4,\n    :i_to_z_5,\n    :i_to_z_6,\n\
    \    :j_to_z_1,\n    :j_to_z_2,\n    :j_to_z_3,\n    :j_to_z_4,\n    :j_to_z_5,\n\
    \    :j_to_z_6,\n    :k_to_z_1,\n    :k_to_z_2,\n    :k_to_z_3,\n    :k_to_z_4,\n\
    \    :k_to_z_5,\n    :k_to_z_6,\n    :l_to_z_1,\n    :l_to_z_2,\n    :l_to_z_3,\n\
    \    :l_to_z_4,\n    :l_to_z_5,\n    :l_to_z_6,\n    :m_to_z_1,\n    :m_to_z_2,\n\
    \    :m_to_z_", "  sorted = []\n  l.each do |elem|\n    if elem.even?\n      sorted\
    \ << elem\n    else\n      index = sorted.index elem\n      sorted[index] = elem\
    \ if index < sorted.length-1\n    end\n  end\n  sorted\nend", "  even = [l[i]\
    \ for i in 0...l.length/2 if i % 2 == 0]\n  odd = [i for i in 0...l.length/2 if\
    \ i % 2 != 0]\n  odd.zip(even)\nend\n</code>\nNow you can do:\n<code>\nsort_even([1,\
    \ 2, 3, 4, 5])\n  #=> [[1, 1], [3, 3], [2, 4], [5, 5]]\n</code>\n<|/ a dscore=2\
    \ tags=ruby,arrays |>\n<| a |>\nThis can be done with #sort_by:\n<code>\na = [1,\
    \ 2, 3, 4, 5]\na.sort_by { |i| a.index(i) }\n</code>\nEdit: Thanks Baldrick for\
    \ comment: \n<code>\na = [1, 2, 3, 4, 5]\na.sort_by { |i| a.index(i).zero? ? i\
    \ : a.index(i).even? ? i : a.index(i).odd? ? i : a.index(i).zero? ? i : a.index(i).even?\
    \ ? i : a.index(i).odd? ? i : nil }\n</code>\n<|/ a dscore=2 tags=ruby,arrays\
    \ |>\n<| c |>\nThat's not what the OP is asking for though.\n<|/ c |>\n<| c |>\n\
    I agree; this doesn't solve the problem in the way the OP asks about.\n<|/ c |>\n\
    <| c |>\nThis has the downside of requiring an extra lookup of the list length\
    \ every time you do a sort. `a.sort_by { |i| a.index(i).zero? ? i : a.index(i).even?\
    \ ? i : a.index(i).odd? ? i : nil }` would solve that (but not the more complex\
    \ examples).\n<|/ c |>\n<| c |>\nThe complexity of this solution is O(n^2). There\
    \ are better solutions below that require a maximum of O(n).\n<|/ c |>\n<| c |>\n\
    , Yes you are right. However it is O(n) solution as well, just that we don't know\
    \ the maximum length list ahead of time. Since we are using index method which\
    \ is O(1), overall complexity should be O(n). However your solution is definitely\
    \ better.\n<|/ c |>\n<| a dscore=1 |>\nHere's a more general solution:\n<code>",
  "  l = l.clone\n  l' =\n  for i in 0 .. l.length / 2\n    l.push l[i] if i.odd?\n\
    \    l'.push l[i] if i.even?\n  end\n  l''\nend", "  l.each { |x| x[0...1] = (l[0...1].map\
    \ { |y| ([y, x] << 1) }.reduce(:<<)) }\n  l.sort\nend\n</code>\nNow you just need\
    \ to find the indices where any two adjacent values differ and sort them:\n<code>",
  "  even = l.dup\n  even.sort.each_with_index { |v, i| even[i] % 2 == 0 ? l << v\
    \ : l << v << i }\n  even\nend", "  even = []\n  odd = []\n  l.each_with_index\
    \ do |value, index|\n    if (index % 2 == 0)\n      even << value\n    else\n\
    \      odd << value\n    end\n  end\n  return even, odd\nend", "  even = l.dup\n\
    \  even.sort!\n  even.rotate!\n  even\nend", "    evens = l.select {|x| x % 2\
    \ == 1}\n    odds = l.select {|x| x % 2 == 0}\n    evens.zip(evens).flatten.sort\n\
    end", "  even = []\n  odd = []\n  i = 0\n  while i < l.length\n    if i % 2 ==\
    \ 0\n      even << l[i]\n    else\n      odd << l[i]\n    end\n    i += 1\n  end\n\
    \  even.sort!\n  odd.sort!\n  i = 0\n  while i < even.length\n    even[i] << even[i\
    \ + 1]\n    even.pop\n    i += 1\n  end\n  i = 0\n  while i < odd.length\n   \
    \ odd[i] << odd[i + 1]\n    odd.pop\n    i += 1\n  end\nend", "  l'.map! {|e|\
    \ l[e][2%l.length] }\n  l'.map! {|e| l[e][0] = [e].flatten }\n  l'.sort { |a,\
    \ b| b[0] - a[0] }\nend", "  l = []\n  odd = []\n  even = []\n  for i in 0..l.length-1\n\
    \    if i % 2 != 0\n      l << l[i]\n    else\n      odd << l[i]\n    end\n  end\n\
    \  for i in 0..l.length-1\n    if i % 2 == 0\n      even << l[i]\n    end\n  end\n\
    \  l << even\n  l << odd\n  l.sort.reverse!\n  l.flatten!\nend\n</code>\nI didn't\
    \ test the code, but this should work to sort an array.  You will need to change\
    \ the method and variable names to fit your code.  I hope this helps.\n<|/ a tags=sorting,ruby,arrays\
    \ |>\n<| a dscore=0 tags=sorting,ruby,arrays |>\nThis should do the trick:\n<code>\n\
    l = [1,3,5,7,7,5,3,1]\nl.uniq.sort.reverse\n</code>\n<|/ a |>\n<| c |>\nThis won't\
    \ do what he wants, see his comment on his question.\n<|/ c |>\n<| c |>\nI'm pretty\
    \ sure he wants the sort to rearrange the even indices first and the odd indices\
    \ second so that in the end the array has the even indices sorted and the odd\
    \ indices sorted.\n<|/ c |>\n<| c |>\nHe also wants the original list to be unchanged.\
    \ But I think the question is ambiguous.\n<|/ c |>\n<| c |>\nYes, that is exactly\
    \ what he wants.\n<|/ c |>\n<| c |>\nNo, that doesn't do it.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is an implementation which does what you ask.\n<code>", "    even =\
    \ []\n    odd  = []\n    even.concat(l)\n    odd.concat(l.slice(1..-1))\n    even.map!\
    \ { |x| odd.shift if x.even? }\n    even.sort_by!(&:itself)\n    even\nend", " \
    \ # If the list is empty, return an empty list\n  return l if l.is_a? Array and\
    \ l.empty?", "  l.each_with_index do |n,i|\n    l.insert(i,n)\n  end\n  l\nend",
  "  if l == nil || l.length < 2\n    return l\n  else\n    even = nil\n    odd =\
    \ nil\n    l.each do |e|\n      if e % 2 == 0\n        even << e\n      else\n\
    \        odd << e\n      end\n    end\n    even.sort.concat odd\n  end\nend",
  "    l.sort { |a,b| a%2 == b%2 ? 0 : (a%2 ? 1 : -1) }\nend", "  even = []\n  odd\
    \ = []\n  for i in 0..length(l) - 1 do\n    if i % 2 == 0 then\n      even <<\
    \ l[i]\n    else\n      odd << l[i]\n    end\n  end\n  even.extend(odd.reverse)\n\
    \  even\nend\n</code>\nTo get the number of \"even\" values in a list:\n<code>",
  "    l.sort.with_index { |e,i| (i % 2 == 0).tap { l.delete_at(i) } }\nend", "  l.each_with_index\
    \ do |e, i|\n    odd_i = i % 2\n    even = i\n    if odd_i == 0\n      even =\
    \ (even * -1) + even\n    end\n    if even == 0\n      l[even] = e\n    else\n\
    \      l[even] = e\n      l[odd_i] = e\n    end\n  end\n  return l\nend", "  l.sort!\n\
    \  l.each_index do |i|\n    evens = l[i..-1]\n    evens.sort!\n    l[i] = evens[evens.length-1]\n\
    \  end\n  l\nend", "  l2=l.clone\n  even_index=0\n  sorted_list=[]\n  while even_index<l.length\n\
    \    even_index+=1\n    sorted_list.push(*l.values_at(*l.indices.first(even_index)))\n\
    \    l2.delete_at(even_index)\n  end\n  l2.extend(sorted_list)\n  l2\nend\n</code>\n\
    Now we can take our example input list\n<code>\ninput = [5, 2, 8, 8, 3, 9, 1,\
    \ 4, 8, 6, 5, 2, 9]\n</code>\nand sort it like this\n<code>\nsort_even(input)",
  "  l.sort!\n  \n  odd_idx = l.length\n  even_len = l[odd_idx..-1].length\n  \n \
    \ # if the even indicies and odd indicies are the same, swap the values\n  # otherwise,\
    \ swap the indicies and sort the resulting list from the swap\n  return if odd_idx\
    \ == even_len\n  \n  l[odd_idx..-1].each { |e| l[odd_idx] = e }\n  \n  l.sort!\n\
    end\n</code>\nNote that this approach does not produce a new array - it just moves\
    \ the values from the even-index slots to the odd-index slots and then sorts the\
    \ list. In your test code you do this:\n<code>", "  even = []\n  odd = []\n  i\
    \ = 0\n  while (i < l.length)\n    if (i%2 == 0)\n      even.push l[i]\n    else\n\
    \      odd.push l[i]\n    i = i+1\n  end\n  even.sort!\n  odd.sort!\n  even.each\
    \ do |x|\n    odd.push x\n  end\n  return odd\nend", "  new_list = l.dup\n  new_list.reverse.each_with_index\
    \ do |x, i|\n    odd_i = i\n    new_list[odd_i] = new_list[odd_i].sort { |a, b|\
    \ b - a}\n    new_list.delete(odd_i)\n  end\n  return new_list\nend", "  sorted\
    \ = []\n  l.each do |i|\n    if i.odd?\n      sorted.push(i)\n      sorted\n \
    \   end\n  end\nend", "  even = []\n  odd = l\n  even.push( l[0] )\n  odd.shift(\
    \ 1, l )\n  even.push( l[0] )\n  odd.shift( 2, l )\n  even.push( l[0] )\n  odd.shift(\
    \ 3, l )\n  even.push( l[0] )\n  odd.shift( 4, l )\n  even.push( l[0] )\n  odd.shift(\
    \ 5, l )\n  even.push( l[0] )\n  odd.shift( 6, l )\n  even.push( l[0] )\n  odd.shift(\
    \ 7, l )\n  even.push( l[0] )\n  odd.shift( 8, l )\n  even.push( l[0] )\n  odd.shift(\
    \ 9, l )\n  even.push( l[0] )\n  odd.shift(10, l )\n  even.push( l[0] )\n  odd.shift(11,\
    \ l )\n  even.push( l[0] )\n  odd.shift(12, l )\n  even.push( l[0] )\n  odd.shift(13,\
    \ l )\n  even.push( l[0] )\n  odd.shift(14, l )\n  even.push( l[0] )\n  odd.shift(15,\
    \ l )\n  even.push( l[0] )\n  odd.shift(16, l )\n  even.push( l[0] )\n  odd.shift(17,\
    \ l )\n  even.push( l[0] )\n  odd.shift(18, l )\n  even.push( l[0] )\n  odd.shift(19,\
    \ l )\n  even.push( l[0] )\n  odd.shift(20, l )\n  even.push( l[0] )\n  odd.shift(21,\
    \ l )\n  even.push( l[0] )\n  odd.shift(22, l )\n  even.push( l[0] )\n  odd.shift(23,\
    \ l )\n  even.push( l[0] )\n  odd.shift(24, l )\n  even.push( l[0] )\n  odd.shift(25,\
    \ l )\n  even.push( l[0] )\n  odd.shift(26, l )\n  even.push( l[0] )\n  odd.shift(27,\
    \ l )\n  even.push( l[0] )\n  odd.shift(28, l )\n  even.push( l[0] )\n  odd.shift(29,\
    \ l )\n  ", "  even = []\n  odd = []\n  even_value = 0\n  odd_value = 0\n  for\
    \ i in 0..length(l) - 1 do\n    even_value = l[even_value]\n    odd_value = l[odd_value]\n\
    \    if odd_value > even_value\n      odd << even_value\n      even.delete_at(even.index(even_value))\n\
    \    else\n      even << odd_value\n      odd.delete_at(odd.index(odd_value))\n\
    \    end\n  end\n  even.concat(odd)\nend\n</code>\nI used the same approach for\
    \ the other sort functions too. I think the performance of this is O(n log n)\
    \ but I am not sure. \nHere are the outputs for your test data:\n<code>\n[\"B\"\
    ,\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"\
    B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n\
    [\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"\
    ]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"\
    C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\"\
    ,\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"\
    E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\"\
    ,\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"\
    A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\"\
    ,\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"\
    B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n\
    [\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E\",\"C\"\
    ]\n[\"B\",\"A\",\"E\",\"C\"]\n[\"B\",\"A\",\"E", "  l'.each do |e|\n    even_indexes.each\
    \ {|i| l'.delete(e) }\n    l'.insert(e.to_i, e.to_i)\n  end\nend", "    even =\
    \ l.dup\n    even.slice!(0,l.length/2).each_with_index { |v,i| even[i] = v.to_i\
    \ + v.to_i }\n    even.sort!\nend\n</code>\nWith these changes your code works\
    \ fine under Ruby 2.7.1.\n<|/ a dscore=1 |>\n<| c |>\nThanks for your help. I\
    \ appreciate it.\n<|/ c |>\n<| c |>\nIt appears you're right.  I added the result\
    \ to the OP.\n<|/ c |>\n<| c |>\nI appreciate your help. However, I still get\
    \ the same error with the code you provided. I'm using Ruby 2.6.3p62.\n<|/ c |>\n\
    <| c |>\nI tested it under Ruby 2.6.3 on my machine and the `sort_even` function\
    \ works fine.\n<|/ c |>\n<| c |>\nYes, I am using a Ruby version older than 2.7.\
    \  I'll try running that code on another computer with version 2.7.1\n<|/ c |>\n\
    <| a tags=ruby |>\nI'm running Ruby 2.6.3 on OSX 10.9.5\nI tested with two methods:\n\
    Method 1:\n<code>", "  l2 = []\n  l.each_with_index { |n,i| l2 << n if i % 2 ==\
    \ 0 }\n  l2.each_with_index { |n,i| l2.rotate! i if i % 2 == 1 }\n  return l2\
    \ if l2.empty?\n  l2.each_with_index { |n,i| l2.rotate! i }\nend", "  l.sort!\n\
    \  l.each_with_index do |e, i|\n    if i % 2 == 1\n      l[i] = l[i] if l[i] >\
    \ l[i + 1]\n      l[i + 1] = e if l[i] > l[i + 1]\n    end\n  end\n  l\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis code doesn't seem to produce the right\
    \ results when there are multiple 1s and 0s in the original list.  For example,\
    \ try sort_odd([3,2,1,0,1]).  I'm still trying to figure out why this doesn't\
    \ work.  It's probably because it's too clever for its own good; perhaps there's\
    \ a more straightforward way to do this that I'm missing.\n<|/ c |>\n<| c |>\n\
    I fixed my code by adding an extra variable `a` to each iteration. Your version\
    \ didn't work because `sort` moves the elements to the end of the list, so after\
    \ the first iteration `a` would equal `3`, and the second iteration would set\
    \ it to `0`, but `e` would not have been changed by the `sort` call. This version\
    \ works in my tests.\n<|/ c |>\n<| c |>\nI updated my answer to show how you could\
    \ use the same `a` variable I used in the previous version. Hope this helps!\n\
    <|/ c |>\n<| a tags=ruby |>\nHere's a way that doesn't involve sorting:\n<code>",
  "  l2 = []\n  for i in 0...(l.length % 2)\n    temp1 = l[i]\n    temp2 = l[(i+1)..-1].sort{|a,\
    \ b| a <=> b}\n    l2 << [temp1, temp2]\n  end\n  l2\nend", "    even = [l[i]\
    \ for i, v in enumerate(l) if i%2 == 0]\n    odd = [x for i, x in enumerate(l)\
    \ if i%2 != 0]\n    even.sort()\n    odd.sort()\n    sorted_odd = [x for i, x\
    \ in enumerate(l) if i%2 == 0]\n    sorted_even = [x for i, x in enumerate(l)\
    \ if i%2 == 1]\n    sorted_odd.extend(sorted_even)\n    sorted_odd.extend(even)\n\
    \    return sorted_odd\n</code>\nTo test this function, I made a small list with\
    \ random numbers between 0 and 9 (inclusive).\n<code>\nimport random\nrandom.seed(0)\n\
    l = list(random.sample(range(10), 10))\n</code>\nTo compare the lists with my\
    \ original function:\n<code>\nsort_even(l) == l\n</code>\nIt returns True - so\
    \ this function is working properly.\n<|/ a tags=sorting,python,list |>\n<| a\
    \ tags=sorting,python,list dscore=2 |>\nYou can use a variation of merge sort,\
    \ using heapq.merge.\nThis works because heapq.merge does a top-down merge sort.\n\
    <code>", "  odd = false\n  even = true\n  l'.each do |i|\n    if even\n      l'.insert(i,\
    \ l[i]) if odd \n      odd = false\n    else\n      l'.insert(i, l[i]) if odd\n\
    \      even = false\n    end\n  end\n  return l'.sort\nend", "  l.sort.tap do\
    \ |sorted_list|\n    # Iterate through each even index and put it in the even\
    \ place of the new list\n    sorted_list.each_with_index do |val, index|\n   \
    \   sorted_list[index] = val unless index % 2\n    end\n  end\nend\n</code>\n\
    This can be shortened with each_with_index but the function call here is more\
    \ clear.\n<|/ a dscore=0 |>\n<| a dscore=0 tags=sorting,arrays,ruby |>\n<code>\n\
    a = [1, 3, 5] #=> [1, 3, 5]\na.sort!\n</code>\n<|/ a |>\n<| a dscore=0 tags=sorting,arrays,ruby\
    \ |>\n<code>\na = [1, 3, 5]\na = a.each_with_index.map{|x,y| [y, x]}\na.sort!\n\
    </code>\n<|/ a |>\n<| a |>\n<code>\na = [1, 3, 5]\na.sort_by!(&:last).map(&:first)\n\
    </code>\n<|/ a dscore=0 tags=sorting,arrays,ruby |>\n<| c |>\nWhile this code\
    \ may answer the question, providing additional context regarding why and/or how\
    \ this code answers the question improves its long-term value.\n<|/ c |>\n<| c\
    \ |>\nWelcome to Stack Overflow. Code-only answers are discouraged. Please add\
    \ a brief description of how your code addresses the question. Also, please format\
    \ your code for readability. [See the help center on how to format code blocks.](https://stackoverflow.com/help/formatting)\n\
    <|/ c |>\n<| a |>\n<code>\narr = [1, 3, 5]\narr.sort_by!(&:last).map(&:first)\n\
    </code>\n<|/ a dscore=0 tags=sorting,arrays,ruby |>\n<| c |>\nThis one seems to\
    \ be the best (fastest) so far.\n<|/ c |>\n<| c |>\nHe asked for the fastest one.\
    \ Your answer doesn't give the fastest.\n<|/ c |>\n<| c |>\nHe was looking for\
    \ \"The fastest one\". He didn't say he wanted the fastest one. Your answer is\
    \ not fastest at all. You're just doing extra work.\n<|/ c |>\n<| c |>\nIt was\
    \ just a joke, I think the OP was looking for the fastest one :D\n<|/ c |>\n<|\
    \ c |>\nI think you had the wrong joke. Your answer would have been fastest ",
  "  l.reject { |val| val % 2 == 0 }.sort_by { |x| x.to_i }\nend\n</code>\nThen you\
    \ can do things like:\n<code>\nl = [1,4,2,10,5,3,15,8,20,13,12,16,23,18,25,31,30,26,28]\n\
    sorted_l = sort_even(l) # => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\
    \ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n</code>\n<|/ a\
    \ dscore=0 tags=sorting,ruby |>\n<| c |>\nHow does this work when the OP wants\
    \ to sort odd indicies while keeping the even indicies in their original order?\n\
    <|/ c |>\n<| c |>\nWhat do you mean? This sorts the odd indicies in their original\
    \ order. But they keep their original values at their even indices. So `l = [1,3,5,7,9,11]`\
    \ returns `[3, 5, 1, 7, 9, 11]`, which I think is what OP wants.\n<|/ c |>\n<|\
    \ c |>\nOh, I see. Sorry.\n<|/ c |>\n<| a |>\n<code>\narr = [1,4,2,10,5,3,15,8,20,13,12,16,23,18,25,31,30,26,28]\n\
    arr.group_by{|e| e%2}.values\n</code>\nThis gives\n<code>\n[[1, 4, 10, 15, 20,\
    \ 23, 28, 30], [2, 5, 12, 16, 18, 25, 31], [3, 8, 13, 19, 26]]\n</code>\n<|/ a\
    \ dscore=0 tags=sorting,ruby |>\n<| c |>\nThis does not preserve the original\
    \ ordering, though.\n<|/ c |>\n<| a tags=sorting,ruby dscore=0 |>\nHere you go:\n\
    <code>\nl = [1,4,2,10,5,3,15,8,20,13,12,16,23,18,25,31,30,26,28]", "  l.sort!\n\
    \  even_index = 0\n  odd_index = 1\n  new_l = []\n  while even_index < l.length\n\
    \    even_value = l[even_index]\n    odd_value = l[odd_index]\n    if even_index\
    \ % 2 != 0\n      new_l << even_value\n      even_index += 1\n    else\n     \
    \ new_l << odd_value\n      odd_index += 1\n    end\n  end\n  new_l\nend\n</code>\n\
    <|/ a tags=ruby,sorting |>\n<| a dscore=1 tags=ruby,sorting |>\n<code>", "   \
    \ sorted = []\n    l.each_with_index { |element, index| sorted.push((index/2).even?\
    \ ? element : sorted[index/2]) }\n    sorted\nend\n</code>\nSo to apply that sort\
    \ to your array of numbers, you can do this:\n<code>\np sort_even([5,4,3,1])",
  "  l.dup.tap {|a| a.zip(a[1..-1]).sort.each {|a,b| a.swap(b) } }\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nNice solution, although I wonder how\
    \ it performs compared to my solution.\n<|/ c |>\n<| c |>\nOk, I timed it (on\
    \ a list of 150,000 elements). It was faster than my solution and slightly slower\
    \ than the solutions proposed here. I wonder if that means it's more memory-efficient\
    \ since it doesn't create a whole new array. :)\n<|/ c |>\n<| c |>\nI believe\
    \ your solution is faster since it uses less memory, but it's still O(NlogN),\
    \ whereas mine is O(N). I can't say that mine is faster because it may depend\
    \ on how it's implemented.\n<|/ c |>\n<| c |>\nI edited my original answer to\
    \ show how I tested it. My version runs in 0.048s while your solution runs in\
    \ 0.016s. I'm not sure why yours is a little faster.\n<|/ c |>\n<| c |>\nIt's\
    \ probably because my code is much shorter and more compact than the other solutions\
    \ proposed by others. :)\n<|/ c |>\n<| a dscore=4 |>\nIf it's OK to have your\
    \ array be in ascending order, then (thanks to Peter Rudiak) you could do:\n<code>\n\
    a = [1,2,3,4,5,6,7,8,9,10,11,12]\n(0..a.length).select {|i| i % 2 == 0 }.sort.reverse\
    \ \n=> [2, 4, 6, 8, 10, 12, 1, 3, 5, 7, 9]\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis works only if you can guarantee that the array's values are\
    \ in ascending order. Otherwise you'll need to sort first using the `sort_by`\
    \ method.\n<|/ c |>\n<| c |>\nTrue. But it's quite easy to sort an array in ascending\
    \ order (just use `sort_by` instead of `sort`), so I believe it's OK for the OP.\n\
    <|/ c |>\n<| c |>\nThat's why I like your solution.\n<|/ c |>\n<| c |>\nYes, I\
    \ used `sort_by` just to show another way :)\n<|/ c |>\n<| c |>\nAnd yet you accepted\
    \ the other answer with much more upvotes! :)\n<|/ c |>\n<|", "    even = l[1..-1]\n\
    \    odd = l[2..-1]\n    odd.reverse!\n    even.zip(odd).map(&:reverse).flatten!\n\
    end", "  # find the size of l and store it in size\n  size = l.length\n  # create\
    \ an array that only contains the even indicies\n  even = []\n  # iterate over\
    \ all even indicies of l\n  for i in 0...size-1\n    # append the even indicies\
    \ into even\n    even << i\n  end\n  # create an array l' that only contains the\
    \ odd indicies\n  odd = []\n  # iterate over all odd indicies of l\n  for i in\
    \ even...size-1\n    # append the odd indicies into odd\n    odd << i\n  end\n\
    \  # iterate over all even indicies of l\n  for i in even...size-1\n    # append\
    \ the even indicies into l' and set it equal to l\n    l[i/2] = l[i/2]\n    #\
    \ append the even indicies into l' while setting the values of even indicies equal\
    \ to the\n    # values of odd indicies\n    l[i/2] = l[i/2] + l[(i+1)/2]\n  end\n\
    \  # iterate over all odd indicies of l\n  for i in odd...size-1\n    # append\
    \ the odd indicies into l' and set it equal to l\n    l[i/2] = l[i/2]\n    # append\
    \ the odd indicies into l' while setting the values of even indicies equal to\
    \ the\n    # values of odd indicies\n    l[i/2] = l[i/2] + l[(i+1)/2]\n  end\n\
    \  # return the list l with its even indicies equal to the values of the even\
    \ indicies\n  # of the list l, but sorted\n  return l\nend", "  even = []\n  odd\
    \ = []\n  odd_count = 1\n  for i in 0...l.size\n    even[i] = l[i]\n    odd[i]\
    \ = l[i]\n  end\n  for i in 0...l.size\n    if i % 2 != 0\n      odd_count -=\
    \ 1\n    end\n    odd_count += 1 if i % 2 == 0\n  end\n  for i in 0...odd_count\n\
    \    even[i] = odd[i]\n  end\nend", "  lp = l.dup\n  lp.each_with_index { |e,i|\
    \ lp << e if i % 2 == 0 }\n  lp.sort!\n  lp.reject!(&:nil?)\n  lp.uniq!\n  lp\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis is just an example of a simple\
    \ solution where a sort is needed, not a solution that addresses OP's problem\
    \ in general.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\nHere you go:\n<code>\n\
    l = [2, 5, 6, 8, 1, 4, 6]", "  # Sort the even-indicies first\n  even = l.sort.select\
    \ { |x| x.to_i & 1 == 0 }\n  # Then sort the odd indicies\n  odd = l.sort.select\
    \ { |x| x.to_i & 1 == 1 }\n  # Concatenate odd+even to make a sorted list out\
    \ of both\n  odd.concat([even])\nend", "  l'.sort!\n  even = l.select { |v| v.odd?\
    \ }\n  even.each_with_index { |v,i| l'.insert(i, v) } if even\n  l'.sort!\nend\n\
    </code>\nAnd now we're ready to make some test cases to check our solution:\n\
    <code>\nsort_even([]) # => []\nsort_even([1]) # => [1]\nsort_even([1,1]) # =>\
    \ [1,1]\nsort_even([2,1,1,2]) # => [2,1,2]\nsort_even([2,1,2,1]) # => [1,1,2]\n\
    sort_even([1,1,2,2]) # => [1,2,1]\nsort_even([1,2,1,2]) # => [2,1,1]\n</code>\n\
    <|/ a |>\n<| c |>\nOddly, this solution is so complex and confusing that it doesn't\
    \ even have a name - what are you using this for?\n<|/ c |>\n<| c |>\nTo be honest\
    \ I tried to find some example where the function fails, and this one worked pretty\
    \ well. I added a comment with my explanation of how it works.\n<|/ c |>\n<| c\
    \ |>\nThanks for taking the time to write a really nice answer! But it looks like\
    \ you're just copy-pasting the OP's own code. You're just adding some comments.\
    \ Would you mind explaining how you came up with that solution? I'm curious to\
    \ know how you came up with it.\n<|/ c |>\n<| c |>\nI'm sorry but I don't have\
    \ a copy of Haskell here and I don't know the name of the solution. So I wrote\
    \ it by myself. I wrote the function `sort_even` and I wrote the test cases myself.\
    \ I understand that this is probably not as good as the solution that is provided\
    \ on the Haskell wiki, but it was the first thing that came to my mind.\n<|/ c\
    \ |>\n<| c |>\nYou don't have to write it by yourself. This function is provided\
    \ on the Haskell Wiki just to show how it works, and to show that it works in\
    \ every case.\n<|/ c |>\n<| a dscore=1 |>\nI ran into a similar problem and came\
    \ up with a simple solution that seems to work well in some cases:\n<code>\n(sortWith\
    \ zip) xs ys = sortBy ((> 1).(`mod` 2)) $ zipWith zip xs ys\n</code>\nExample:\n\
    <code>\n> sortWith zip [3, 2, 1], [1, 4, 3]\n[3,2,1]\n> sortWith zip [3, 2, 1],\
    \ [1, 4, 3, 1]\n[3,2,1]\n", "    even = []\n    odd = []\n    l = l.sort\n   \
    \ for i in 1..l.size\n        if i.even?\n            even.push l[i]\n       \
    \ else\n            odd.push l[i]\n        end\n    end\n    even += odd\n   \
    \ even.sort\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not an answer, but just\
    \ a comment.\n<|/ c |>\n<| c |>\n: Please note that the comment is actually answering\
    \ the question of how to sort a list of numbers in ascending order according to\
    \ whether they are even or odd.\n<|/ c |>\n<| c |>\nI agree. But answers should\
    \ not be just comments, they should explain the answer to help future readers.\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=1 |>\nYou can try this:\n<code>\na = Array.new",
  "    even = []\n    odd = []\n    i = 0\n    while i < l.length\n        if l[i]\n\
    \            if i % 2 == 0\n                even.push(l[i])\n            else\n\
    \                odd.push(l[i])\n        end\n        i += 1\n    end\n    even.concat(odd)\n\
    end", "  even = l.map { |x| [x[1], x[0]] }\n  even.sort!\n  even.map { |x| x[1]\
    \ }\nend", "  l.each_with_index do |e, i|\n    even = i % 2\n    l = even.nil?\
    \ ? l : l.rotate! if even\n  end\n  l\nend", "  sorted = l.sort_by {|x| x % 2\
    \ == 0}\n  evens = sorted.select {|x| x % 2 == 1}\n  evens.zip(sorted.drop(evens.length))\n\
    end", "  l2 = []\n  l.each_with_index do |e,i|\n    even = (i % 2 == 0)\n    if\
    \ even\n      l2 << e\n    else\n      l2 << e\n      l2 << l[i-1]\n    end\n\
    \  end\n  l2\nend\n</code>\nAnd then to sort a collection of random numbers, do\
    \ this:\n<code>\nnumbers = [rand(10)..rand(10)].shuffle\nnumbers.sort_by_even_index\n\
    </code>\nSo for those of you who haven't seen these before:\neach_with_index produces\
    \ an enumerator that returns the elements of the collection as well as the index\
    \ of the element in turn.\n<|/ a tags=ruby,sorting |>\n<| c |>\nThank you for\
    \ the explanation and for the solution, this is really useful.\n<|/ c |>\n<| c\
    \ |>\nThanks, just for the sake of future reference, is there a way to implement\
    \ a selection sort using ruby? The code you provided seems to do selection sort\
    \ on even positions only\n<|/ c |>\n<| c |>\n, sure, you can do that, but you'd\
    \ want to swap two elements at odd indexes when swapping two elements at even\
    \ indexes. I'll edit the code to do that for you.\n<|/ c |>\n<| a tags=ruby,sorting\
    \ |>\nAs you were saying, Ruby's sort_by is designed for this, so you might want\
    \ to look at that first.\nIn your case though, there are 2 cases that you are\
    \ dealing with, 1 that is the case where the array is even, and another is the\
    \ case where it is odd. I would use sort_by with a block, and a little logic to\
    \ determine whether to sort on the even position or the odd position.\n<code>\n\
    l = [\"B\",\"A\",\"C\",\"D\",\"E\"]\nl.sort_by {|c| c.to_i}\n=> [\"A\", \"B\"\
    , \"C\", \"D\", \"E\"]\n</code>\nIf the array is even, your array is going to\
    \ be sorted based on the alphabetic order of the letters. So your array will be\
    \ sorted as:\n<code>\n[\"B\", \"A\"]\n</code>\nNow in the case where it is odd,\
    \ your array is going to be sorted based on the numerical order of the letters.\
    \ So your array will be sorted as:\n<code>\n[\"B\", \"D\", \"E\", \"A\"]\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nNice solution, thanks! However I'd like to compare\
    \ performance with other solutions.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l2\
    \ = l.dup\n  l.each_with_index do |v, i|\n    if i % 2\n      l2[i] = v\n    end\n\
    \  end\n  l2\nend", "  sorted = []\n  sorted = sorted.concat((l[0..0].reverse,l[1..2]))\n\
    \  sorted = sorted.concat((l[0..1].reverse,l[2..3]))\n  sorted = sorted.concat((l[0..2].reverse,l[3..4]))\n\
    \  sorted = sorted.concat((l[0..3].reverse,l[4..5]))\n  sorted = sorted.concat((l[0..4].sort.reverse,l[5..6]))\n\
    \  sorted = sorted.concat((l[0..5].sort.reverse,l[6..7]))\n  sorted = sorted.concat((l[0..6].sort.reverse,l[7..8]))\n\
    \  sorted = sorted.concat((l[0..7].sort.reverse,l[8..9]))\n  sorted = sorted.concat((l[0..8].sort.reverse,l[9..10]))\n\
    \  sorted = sorted.concat((l[0..9].sort.reverse,l[10..11]))\n  sorted = sorted.concat((l[0..10].sort.reverse,l[11..12]))\n\
    \  sorted = sorted.concat((l[0..11].sort.reverse,l[12..13]))\n  sorted = sorted.concat((l[0..12].sort.reverse,l[13..14]))\n\
    \  sorted = sorted.concat((l[0..13].sort.reverse,l[14..15]))\n  sorted = sorted.concat((l[0..14].sort.reverse,l[15..16]))\n\
    \  sorted = sorted.concat((l[0..15].sort.reverse,l[16..17]))\n  sorted = sorted.concat((l[0..16].sort.reverse,l[17..18]))\n\
    \  sorted = sorted.concat((l[0..17].sort.reverse,l[18..19]))\n  sorted = sorted.concat((l[0..18].sort.reverse,l[19..20]))\n\
    \  sorted = sorted.concat((l[0..19].sort.reverse,l[20..21]))\n  sorted = sorted.concat((l[0..20].sort.reverse,l[21..22]))\n\
    \  sorted = sorted.concat((l[0..20].sort.reverse,l[22..23]))\n  sorted = sorted.concat((l[0..20].sort.reverse,l[23..24]))\n\
    \  sorted = sorted.concat", "  l.each_with_index do |x, i| \n    if i % 2 == 0\n\
    \      l[i] = x.clone\n    else\n      l[i].each_with_index do |y, j| \n     \
    \   if j != 0 \n          if y > l[j - 1]\n            l[j] = y\n          end\n\
    \        end\n      end\n    end\n  end\nend\n</cell>\n<code language=julia-1.5>",
  "  l' =\n    Array.new", "  l = [*l]\n  sorted = l.sort.to_a\n  for i in 0...l.size\n\
    \    sorted[i] += 1\n    sorted[i + 1] -= 1\n  end\n  sorted.zip(l)\nend", " \
    \ l.map! do |e|\n    e % 2 ? e : e + 1\n  end\n  l.sort!\n  l\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a |>\n<code>\nar = [1,2,3,4,5,6,7,8,9,10]", "  l2\
    \ = []\n  evens = []\n  odds = []", "  l' =  []\n  l'.map! { |e| e%2 == 0 ? l\
    \ : e%2 == 1 ? l[e/2] : e%2 == 2 ? l[e/2] : e }\nend", "  return [l.sort_by {|x|\
    \ x.odd?} if l.length > 0]\nend", "  l1 = l.sort{|a,b| (a.to_i > b.to_i) ? (-1)\
    \ : 1}\n  l2 = l1.map {|e| [e, e].sort}.flatten\nend", "  l.sort!\n  l[0...-1].zip(l[1...-1]).sort.zip(l[2...]).sort.zip(l[3...]).sort.zip(l[4...]).sort\n\
    end", "  l2 = []\n  l.each_with_index do |value, index|\n    if index%2==0\n \
    \     l2.push value\n    else\n      l2.push (l[index/2].to_s).dup\n    end\n\
    \  end\n  l2\nend\n</cell>\n<cell>", "  even_indicies = l.each_with_index.map\
    \ { |(elem, index), e| index if index.odd? }\n  even_values = even_indicies.map\
    \ { |e| l.values_at(*e).sort }\n  even_values.flatten!\n  even_indicies.flatten!\n\
    \  even_values.map { |e| [e, *e] }.to_h\nend\n</code>\nExample:\n<code>\nsort_even(%w[a\
    \ b c b c a b])", "    evens = []\n    evens_values = []\n    odds = []\n    for\
    \ i in 0..l.length\n        if i % 2 == 0\n            evens << l[i]\n       \
    \     evens_values << l[i]\n        else\n            odds << l[i]\n        end\n\
    \    end\n    [evens, evens_values, odds]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
