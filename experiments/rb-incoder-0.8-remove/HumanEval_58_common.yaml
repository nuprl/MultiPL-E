name: HumanEval_58_common
language: rb
prompt: "# Return sorted unique common elements for two lists.\ndef common(l1, l2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n\
  \    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5,\
  \ 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3,\
  \ 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"
completions: ["  uniq = l1.to_a & l2.to_a\n  uniq.sort_by(&:last)\nend\n</code>\n\
    Output:\n<code>\np common(['Bob','Sally'], ['Mark','James'])", "    \n    # Find\
    \ intersection.\n    intersection = l1 & l2\n    \n    # Return sorted unique\
    \ elements.\n    sorted_common = sort(intersection)\n    \n    # Return list of\
    \ unique elements.\n    return sorted_common\nend", "  return (l1 & l2).to_a\n\
    end\n  ", "  # Get unique elements in either list.\n  u1 = l1.uniq.sort\n  u2\
    \ = l2.uniq.sort", "  u1 = Set.new(l1)\n  u2 = Set.new(l2)\n  u1.intersect(u2).to_a\n\
    end", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n\
    \  end\n  return nil\nend", "    arr = []\n    [arr, *rest] = [l1, *l2, arr]\n\
    \    arr.each_with_index do |e, i|\n        l1.delete(e)\n        l2.delete(e)\n\
    \        l2.shift if i == 0\n    end\n    l1 + l2\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays,mathematical-optimization,sorting\
    \ dscore=4 |>\n<| c |>\nThat was my first idea, too. It seems like the most efficient\
    \ way to do it, but it's slower than the naive solution I already have.\n<|/ c\
    \ |>\n<| c |>\n: Can you post your `naive` solution in an answer?\n<|/ c |>\n\
    <| c |>\nNo, I can't. Not yet, anyway.\n<|/ c |>\n<| c |>\n: I updated my answer\
    \ to show that my solution is faster than your solution. :)\n<|/ c |>\n<| c |>\n\
    : Thanks for your solution, I like it.\n<|/ c |>\n<| a dscore=4 tags=ruby,algorithm,arrays,mathematical-optimization,sorting\
    \ |>\nThis isn't a Ruby-specific question, so the solution won't be much help\
    \ to you -- but this problem is also an interesting one.  As I look into it further,\
    \ I think it may be possible to do better than O(N log N) complexity (as suggested\
    \ by other answers, at least, though a more efficient solution might be possible).\n\
    If you have two sets of numbers, and you want to get the intersection of them,\
    \ you can use the Kadane's algorithm (also known as the \"divide-and-conquer\"\
    \ algorithm) to find the \"median\" (the element in the middle of the two sets),\
    \ and then compare each of the other two sets to see if they share any elements\
    \ in the middle.  If they do, you just need to add one to the result and remove\
    \ the middle element (since it never compared to anything else), and start again\
    \ with each new middle element.\nSo the algorithm would look something like this:\
    \  \n<code>\nSet A and Set B\nSet A and B are initially empty\nRepeat until Set\
    \ A is empty:\n    Set M, the median of Set A and Set B\n    Set A and Set B both\
    \ have M somewhere in them\n    If the number of elements in Set A and Set B is\
    \ even:\n        Add 1 to result and remove M from Set A and Set B\n    If the\
    \ number of elements in Set A and Set B is odd:\n        Add 1 to result and remove\
    \ M from Set B\n    Set M has no elements in them at all\nRepeat until Set A is\
    \ empty\nReturn result", "  c = Set.new\n  (l1 << l2) - c\nend", "    common =\
    \ []\n    # loop through the first list \n    # and see if it exists in the second\
    \ list\n    # if it does append it to the common list\n    # if not add it to\
    \ the new unique common list\n    for i in l1\n        if i not in l2\n      \
    \      common.push(i)\n        end\n    end\n    common\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>\n  def common_elements(nums)\n    nums.sort.uniq\n  end\n\
    </code>\n<|/ a tags=arrays,ruby dscore=0 |>\n<| a dscore=0 tags=arrays,ruby |>\n\
    Ruby's Array#uniq method takes care of not allowing duplicates in the first place.\n\
    <|/ a |>\n<| a tags=arrays,ruby dscore=0 |>\nHere's a solution which takes only\
    \ O(n) time if your input array is sorted.\n<code>", "  if l1.length < l2.length\n\
    \    l1, l2 = l2, l1\n  set = Set\n  common = []\n  for i in l1.to_a\n    common.push(a.find\
    \ {|x| x.first == i })\n  end\n  for i in l2.to_a\n    common.push(a.find {|x|\
    \ x.first == i })\n  end\n  return common.sort_by{|x| x.last}\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhat is the point of `x.last` in `sort_by`? `sort_by` returns\
    \ an array already, so `sort_by{|x| x.last}` just returns `sort_by`, which has\
    \ nothing to do with the sorted list.\n<|/ c |>\n<| c |>\nGood point, sorry I\
    \ forgot to remove that line.\n<|/ c |>\n<| c |>\nI got this working in Ruby 1.8.7,\
    \ but in Ruby 1.9.2 the sort method isn't working. Any ideas?\n<|/ c |>\n<| c\
    \ |>\nYou might try `sort_by` instead of `sort` in Ruby 1.9.2 - it might not work\
    \ properly with hashes.\n<|/ c |>\n<| c |>\nIt looks like your `common` method\
    \ is not sorting correctly - the `sort_by{|x| x.last}` part is actually doing\
    \ a secondary sort on the first element of the array. Though I can't tell for\
    \ sure because you didn't provide a sample data set. It could be that you're missing\
    \ a couple of lines that I left out - it depends how you're calling `common`.\n\
    <|/ c |>\n<| a tags=ruby dscore=1 |>\nI wrote this as part of a ruby 1.8 gem which\
    \ can be found here: http://www.rubygems.org/gems/sort_common\nIt should be compatible\
    \ with 1.9.2\n<code>\nrequire 'set'", "  if l1.length != l2.length \n    puts\
    \ \"List lengths do not match\"\n    exit!\n  end", "  a = l1.to_a\n  b = l2.to_a\n\
    \  a.select! {|e| b.include? e }\n  b.select! {|e| a.include? e }\n  a\nend",
  "  result = []\n  common_list = []\n  l1.each do |element|\n    l2.each do |other_element|\n\
    \      if element == other_element\n        common_list << element\n      end\n\
    \    end\n  end\n  result = common_list\n  return result\nend", "  a = l1.sort\n\
    \  b = l2.sort\n  a.each do |e|\n    b.each do |f|\n      return e if e == f\n\
    \    end\n  end\nend\n</code>\nNow we call it :\n<code>\np common([1,2,3], [1,2,4])\n\
    </code>\nand we get :\n<code>\n[[3, 1], [4, 2]]\n</code>\n<|/ a |>\n<| c |>\n\
    The algorithm you propose doesn't work. It returns an empty array.\n<|/ c |>\n\
    <| c |>\n: Oops, my bad. I forgot the outer loop.\n<|/ c |>\n<| a dscore=2 tags=sorting,ruby,arrays\
    \ |>\n<code>\n[1,2,3,4,5,6,7].sort.uniq!\n</code>\n<|/ a |>\n<| a dscore=1 |>\n\
    Use uniq with a block:\n<code>\n[1,2,3,4,5,6,7,1].uniq {|a| a}\n</code>\n<|/ a\
    \ tags=sorting,ruby,arrays |>\n<| a tags=sorting,ruby,arrays |>\nUse sort_by with\
    \ uniq.\n<code>\n[1, 2, 3, 3, 4, 5].sort_by {|num| num}.uniq\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\n`sort_by` should be applied to `[1,2,3]` rather than `[1,2,3,4,5]`.\n\
    <|/ c |>\n<| c |>\n`[1,2,3].sort_by {|num| num}.uniq` does not work for me. The\
    \ code works in Rails console but not when used in a ruby file. What version of\
    \ rails are you using?\n<|/ c |>\n<| a tags=sorting,ruby,arrays |>\n<code>\narr\
    \ = [1,2,3,4,5,6,7]\nsorted_arr = arr.sort.uniq\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nWhile this code snippet may solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=sorting,ruby,arrays |>\n<code>\na = [1,2,3,4,5,6,7]\n\
    a.sort\np a.uniq!\n</code>\n<|/ a dscore=0 |>\n<| a tag", "  l1 = [l1] if l1.is_a?\
    \ Array\n  l2 = [l2] if l2.is_a? Array\n  l1.zip(l2).detect {|c| c[0] == c[1]\
    \ }[0]\nend", "  l1.sort.product(l2.sort).flatten\nend", "    l1.each do |elem1|\n\
    \        l2.each do |elem2|\n            return elem1 if elem1 == elem2\n    \
    \    end\n    end\nend", "  return Set.new(l1) & Set.new(l2)\nend\n</code>\nHere\
    \ is a demonstration:\n<code>\nirb(main):025:0> common([1, 2, 3], [4, 5, 6])\n\
    => Set<Integer>\nirb(main):026:0> common(Set.new([1, 2, 3]), Set.new([4, 5, 6]))\n\
    => Set<Integer>\n</code>\nNow we can write a method that does the same thing for\
    \ Arrays.\n<code>", "  l1 = l1.sort\n  l2 = l2.sort\n  l1.each {|e| l2.each {|e2|\
    \ return e if e == e2}}\nend\nputs common([\"apple\", \"banana\", \"cherry\",\
    \ \"donut\", \"apple\", \"apple\", \"orange\", \"lemon\", \"lime\"], [\"orange\"\
    , \"cherry\", \"apple\", \"banana\", \"cherry\"])", "  return (l1.to_set.to_a\
    \ - l2.to_set.to_a).to_a\nend\n</code>\nA much more efficient method would be\
    \ to turn the lists into sets and then subtract the sets:\n<code>", "  l1.zip(l2).to_a.flatten.uniq.sort\n\
    end", "  return l1 & l2\nend", "  l1.zip(l2).uniq.sort.to_a\nend\n</code>\nNow,\
    \ you can do this:\n<code>\ncommon([], [])", "  return Set.new([l1[i .. j] | i\
    \ <- l1.indices, j <- l2.indices]) & Set.new([l2[i .. j] | i <- l1.indices, j\
    \ <- l2.indices])\nend", "  if l1.size > l2.size\n    l1.size\n  else\n    l2.size\n\
    \  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      if e == f\n       \
    \ return e\n      end\n    end\n  end\n  return nil\nend\n</code>\n<|/ a |>\n\
    <| c |>\nIf I'm understanding this correctly it seems to me that `common` would\
    \ work better as `intersection` since it eliminates duplicates, rather than union.\
    \  Also, since the OP seems to have just two lists I used `each_with_index` instead\
    \ of `each` since it avoids multiple iterations.\n<|/ c |>\n<| c |>\nThat is a\
    \ good point. If you are trying to find all the common elements in two lists,\
    \ then the operation you are doing is intersection, not union. I will modify my\
    \ code accordingly. Thanks.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails-3,arrays,sorting\
    \ dscore=1 |>\nThe most general way I have found to do this is to create an array\
    \ of hashes and then sort by the count of each hash's keys. \n<code>", "  return\
    \ l1 & l2\nend", "  l1.sort.uniq.intersect(l2.sort.uniq).to_a\nend", "  l1 = l1..l2\n\
    \  l1.uniq\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nFor Ruby 1.9.2 it's better\
    \ to use `Array#to_set` instead of `#uniq`, because the latter returns an array\
    \ when called on array containing duplicates.\n<|/ c |>\n<| c |>\nThanks for mentioning\
    \ it. I tried both ways and it seems they both work. I've updated the answer.\n\
    <|/ c |>\n<| c |>\nThe last paragraph is probably the most important one. Though,\
    \ I am surprised that `to_set` and `uniq` both exist. Isn't `Array` the common\
    \ superclass?\n<|/ c |>\n<| c |>\n`Array#to_set` exists for backwards compatibility.\
    \ `#uniq` has been around since 1.9 (`Array` was introduced in `Array` was introduced\
    \ in `Enumerable`).\n<|/ c |>\n<| c |>\nIf you're looking for the most performant\
    \ way, this would be the way to go. \n`common = l1 & l2` works well if either\
    \ list has unique items.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "    common = []\n\
    \    until l1.empty? || l2.empty?\n        if l1.include?(l2.first)\n        \
    \    common << l1.first\n            l1.shift\n            l2.shift\n        else\n\
    \            common << l2.first\n            l2.shift\n        end\n    end\n\
    \    common\nend", "  l = l1.dup\n  l.merge(l2)\n  l.uniq { |e| l.count(e) }\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nIf `a` and `b` are long the method\
    \ will be much slower than `a.intersection(b)`.\n<|/ c |>\n<| c |>\n: not quite.\
    \ The intersection is implemented in C, while `a.intersection(b)` is implemented\
    \ in Ruby.\n<|/ c |>\n<| c |>\nAm I the only one who has problems with the accepted\
    \ answer?\n<|/ c |>\n<| a dscore=5 |>\n<code>\n[a, b].inject([]){|acc, e| acc\
    \ << e unless acc.include?(e)}.uniq\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI think\
    \ it's cleaner to define `include?` like this - `def include?(a) super || arr.index(a)\
    \ end`, so the reader won't think you're calling `include?` on an array.\n<|/\
    \ c |>\n<| a |>\nThe other answers are fine and functional, but I think I like\
    \ one that doesn't use .include or .index in the callback. That makes me nervous,\
    \ but it's definitely a tad neater:\n<code>\n[a, b].find { |e| b.index(e) == nil\
    \ }.dup\n</code>\n<|/ a dscore=4 tags=ruby |>\n<| c |>\nThis is definitely the\
    \ most elegant solution, because it avoids enumerating the contents of both arrays\
    \ more than once.\n<|/ c |>\n<| c |>\nThis answer is also nice, but `include?`\
    \ is not a good choice as it will loop through the array even after finding the\
    \ match.\n<|/ c |>\n<| a tags=ruby |>\n<code>\na.select{|e| !b.include?(e)}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nIt's shorter, but it doesn't return unique\
    \ elements, just common elements.\n<|/ c |>\n<| a dscore=3 tags=ruby |>\n<code>\n\
    a.select(&:include?) + b.reject(&:include?)\n</code>\n<|/ a |>\n<| c |>\n`b.reject(&:include?)`\
    \ seems a bit redundant to me.\n<|/ c |>\n<| c |>\n: Yes, it is. But I like the\
    \ symmetry of `a.select{|e| !b.include?(e)}`, because I can see that `include?` ",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend", "  set = Set.new\n  set.add!(l1) unless l1.nil? || l1.empty?\n \
    \ set.add!(l2) unless l2.nil? || l2.empty?\n  set.to_a\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nHow is this the accepted answer? This doesn't return a hash. And\
    \ the OP states he has a Ruby on Rails project and thus this solution won't work.\n\
    <|/ c |>\n<| a dscore=2 |>\nSince you're using Rails, you can use the ActiveSupport\
    \ library to do this in a nice clean and easy fashion:\n<code>\n> [1,2,2,3,3].enum_for(:intersection,\
    \ [:1,:2,:3,:4])\n=> [2, 3, 4]\n> [1,2,2,3,3].enum_for(:union, [:1,:2,:3,:4])\n\
    => [1, 2, 3, 4]\n> [1,2,2,3,3].enum_for(:symmetric_difference, [:1,:2,:3,:4])\n\
    => [3, 4]\n> [1,2,2,3,3].enum_for(:complement, [:1,:2,:3,:4])\n=> [1, 2]\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis is awesome because `enum_for`\
    \ will take an arbitrary number of arguments, so that it can work on an array\
    \ of arbitrary size instead of just two arrays...\n<|/ c |>\n<| a |>\nUsing Hash.new\
    \ and Hash#merge with Array#uniq\n<code>\na = [1, 2, 3, 3, 1, 2]\nb = [1, 2, 3,\
    \ 4]\nc = a.map{|e| [e, b.count(e)]}.inject(&:merge)", "  l1.sort { |a, b| b <=>\
    \ a }\n  l2.sort { |a, b| b <=> a }\n  l1.zip(l2)\n           .map { |a| a[0]\
    \ <=> a[1] }\n           .uniq\nend\n</code>\nAnd a final example that will display\
    \ a list of the common elements in two arrays:\n<code>", "    common = []\n  \
    \  return common\nend", "  l1.each do |el|\n    l2.each { |el2| return el if el\
    \ == el2 }\n  end\n  nil\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this\
    \ answer, but I don't think it works when there are more than 2 items in each\
    \ list. I thought about looping over each item in the lists, but I don't know\
    \ if that's better or worse than a recursive function call. I just thought it\
    \ would be better than doing the sorting/uniqing in the database.\n<|/ c |>\n\
    <| c |>\nYeah that would certainly be better to do client side. You'd just need\
    \ to have it keep track of which items have already been encountered and only\
    \ add them again if they don't already appear in the result list. It would definitely\
    \ be slower, though.\n<|/ c |>\n<| c |>\n: Yes, this can be done. You'd simply\
    \ have to keep track of all items you've seen so far, and only add them again\
    \ if they're not already in your list of unique items. I added this to the answer.\n\
    <|/ c |>\n<| a |>\nHere's another option that doesn't require any additional ruby\
    \ code. \n<code>", "  c1 = Set.new\n  c2 = Set.new", '  common = []', "  l1.zip(l2).find\
    \ { |e| e[0] != e[1] }\nend", "  l1.zip(l2).select { |e1, e2| e1 == e2 }.to_a\n\
    end", "\tcommon=[]\n\tfor i in l1\n\t\tif i not in common\n\t\t\tcommon.push(i)\n\
    \tfor i in l2\n\t\tif i not in common\n\t\t\tcommon.push(i)\n\treturn common\n\
    end", "  # Add list elements to the result if they don't already exist in the\n\
    \  # result list.\n  common = []\n  common = common.concat(l1) if l1.size < l2.size\
    \ || l1.size == l2.size && l1.size > 0\n  common = common.concat(l2) if l1.size\
    \ < l2.size || l1.size == l2.size && l2.size > 0\n  common = common.sort { |x,y|\
    \ x < y } if common.size > 0\n  return common\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,sorting\
    \ dscore=4 |>\n<| a dscore=2 |>\nAs you have already tried Array#sort!, it may\
    \ seem that Array#sort is more readable than Array#sort!, but there are subtle\
    \ differences. In particular, if your array has duplicate elements, then Array#sort\
    \ will remove duplicates, whereas Array#sort! will leave them in the original\
    \ order.\nFor my project, I prefer Array#sort! because I have already performed\
    \ an initial sort on an array. For example,\n<code>\narr = [5, 6, 2, 1]\narr.sort!\n\
    </code>\nSo I end up with:\n<code>\narr = [1, 2, 5, 6]\n</code>\nAs you can see,\
    \ the array has now been sorted in descending order.\n<|/ a tags=ruby,ruby-on-rails,sorting\
    \ |>\n<| c |>\nThanks buddy, this really helped me understand and learn the differences\
    \ between `Array#sort` and `Array#sort!`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,sorting\
    \ |>\nA very simple Ruby approach that does not require any methods to sort:\n\
    <code>\narray_to_sort.sort.join\n</code>\n<|/ a dscore=2 |>\n<| a dscore=0 |>\n\
    For me the most readable way is:\n<code>\narray = [ \"banana\", \"apple\", \"\
    banana\", \"orange\", \"banana\", \"apple\"]\narray.sort { |a, b| b == a ? 0 :\
    \ b <=> a }\n</code>\n<|/ a tags=ruby,ruby-on-rails,sorting |>\n<| c |>\nThis\
    \ will return the elements in the same order as they were received.\n<|/ c |>\n\
    <| c |>\nThe question asked for \"a natural sort order\".\n<|/ c |>\n<| c |>\n\
    The question asked for \"natural sort order\" but does not specify how they should\
    \ be ordered, which is what this answer does.\n<|/ c |>\n<| a tags=ruby,ruby-on-",
  '  common = []', "  a1 = l1.sort\n  a2 = l2.sort\n  result = a1.uniq.map { |item|\
    \ a2.detect { |j| j == item } or item }\n  result.sort.uniq\nend", "  common =\
    \ []\n  l1.each do |elem1|\n    l2.each do |elem2|\n      if elem1 == elem2\n\
    \        common << elem2\n        break\n      end\n    end\n  end\n  common\n\
    end", "  l1.uniq.sort.common(&:==).sort.uniq.compact\nend\n</code>\nOr you can\
    \ use Array#-:\n<code>", "  l1 = l1.sort\n  l2 = l2.sort\n  (l1 & l2) == l1 &\
    \ l2\nend", "    common = []\n    common_size = 0\n    i1, i2 = 0, 0\n    \n \
    \   while i1 < len(l1) and i2 < len(l2):\n        if l1[i1] == l2[i2]:\n     \
    \       common << l1[i1]\n            i1 += 1\n            i2 += 1\n         \
    \   common_size += 1\n            continue\n        if l1[i1] < l2[i2]:\n    \
    \        i1 += 1\n        else:\n            i2 += 1\n    \n    while i1 < len(l1):\n\
    \        common << l1[i1]\n        i1 += 1\n        common_size += 1\n    while\
    \ i2 < len(l2):\n        common << l2[i2]\n        i2 += 1\n        common_size\
    \ += 1", "  return l1 & l2\nend", "  a1 = []\n  b1 = []\n  a2 = []\n  b2 = []\n\
    \  a1.concat(l1)\n  b1.concat(l2)\n  a2.concat(l2)\n  b2.concat(l1)\n  a1.uniq!\n\
    \  b1.uniq!\n  a2.uniq!\n  b2.uniq!\n  a1.each{|el| a2.each{|el2| b2.each{|el2|\
    \ break if el == el2}}} \n  b1.each{|el| b2.each{|el2| break if el == el2}}\n\
    \  a1 & b2\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "    l1 = [l1]\
    \ if l1.is_a?(Array) else\n    l2 = [l2] if l2.is_a?(Array)\n    common = []\n\
    \    l1.each { |x| l2.each { |y| common << x if x == y } }\n    common.uniq!\n\
    \    common\nend\n</code>\nThe algorithm goes through each list once, storing\
    \ the common elements in a hash. Using Hash.new makes sure that the same objects\
    \ are put in multiple places.\n<|/ a tags=ruby |>\n<| a dscore=1 tags=ruby |>\n\
    Another solution that works faster than the other solutions proposed is this one:\n\
    <code>", "  intersection = l1 & l2\n  union = l1 | l2\n  common = intersection.select{|e|\
    \ e.present? }\n  common.sort { |e1, e2| e1 < e2 ? -1 : e1 > e2 ? 1 : 0}\nend",
  "  u1 = l1.to_a.uniq\n  u2 = l2.to_a.uniq\n  u1.select {|x| u2.include?(x)}\nend",
  "  l1 & l2\nend", "  l1.sort.uniq.map { |e| l2.find { |f2| f2.eql?(e) } }\nend\n\
    </code>\n<|/ a dscore=0 tags=ruby |>\n<| c |>\nYour code does not handle duplicates.\
    \ Also, `common?` could be a method on `Array`. `Array#common?` exists in ruby\
    \ 2.1.0 and up. http://ruby-doc.org/core-2.1.0/Array.html#method-i-common-3F\n\
    <|/ c |>\n<| c |>\nI thought about that, but I thought that would be irrelevant\
    \ since the OP said they wanted the most performant code.  I guess I assumed this\
    \ was an exercise in coding algorithms.\n<|/ c |>\n<| c |>\nI guess I was confused\
    \ about your use of `map`. Why do you use `map` instead of `collect`? Also, why\
    \ do you use `find` instead of `detect`?\n<|/ c |>\n<| c |>\n`map` and `collect`\
    \ are equivalent in terms of performance. `map` is used because `collect` returns\
    \ an array. Also, `find` and `detect` are equivalent. Both just return the found\
    \ element and stop iterating at the first match.\n<|/ c |>\n<| c |>\nYou cannot\
    \ use `collect` and `detect` like this, because `detect` will return the first\
    \ match.  `map` will create an array of the found values though.  `collect` will\
    \ return an array.  `find` and `detect` will return either a single element or\
    \ nil.\n<|/ c |>\n<| a tags=ruby |>\nThis is an old question but still pops up\
    \ on google search results. So I thought I should add my answer. \nAs per the\
    \ official documentation,", "  l1 = l1.to_a\n  l2 = l2.to_a\n  common = []\n \
    \ while l1.first != l2.first\n    common << l1.shift || l2.shift # || because\
    \ nil is false\n  end\n  common\nend", "  l1.each_with_object(l2) do |x, result|\n\
    \    result[x] if l2.include?(x)\n  end\nend", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      if x == y\n        l1.delete(x)\n      end\n    end\n  end\n \
    \ l1\nend", "  l1.each_with_object(Hash.new { |h,k| h[k] = [] }) do |e,h|\n  \
    \  l2.each { |f| h[e] << f }\n  end\n  .keys\n  .flat_map(&:to_a)\n  .map(&:sort)\n\
    end", "  set = Set.new\n  l1.each do |x|\n    l2.each do |y|\n      set << x if\
    \ x == y\n    end\n  end\n  set\nend", "  l1.each do |x|\n    l2.each do |y|\n\
    \      next if x == y\n      break\n    end\n    break\n  end\n  l1\nend", " \
    \ u1 = Set.new(l1)\n  u2 = Set.new(l2)\n  u1 & u2 # Returns common elements.\n\
    end", "    common = []\n    \n    # Iterate through both lists.\n    until l1.blank?\
    \ || l2.blank?\n        if l1.first == l2.first\n            common << l1.first\n\
    \            l1.shift\n            l2.shift\n        else\n            if l1.first\
    \ > l2.first\n                l1.shift\n            else\n                l2.shift\n\
    \            end\n        end\n    end\n    \n    # Return common elements.\n\
    \    common\nend", "  common = []\n  i1 = 0\n  i2 = 0\n  while i1 < l1.size &&\
    \ i2 < l2.size\n    if l1[i1] == l2[i2]\n      common << l1[i1]\n      i1 += 1\n\
    \      i2 += 1\n    elsif l1[i1] < l2[i2]\n      i1 += 1\n    elsif l1[i1] > l2[i2]\n\
    \      i2 += 1\n    else\n      i1 += 1\n      i2 += 1\n    end\n  end\n  common\n\
    end", "  r = []\n  l1.each do |i|\n    if l2.include? i\n      r << i\n      l2.delete_at(l2.index(i))\n\
    \    end\n  end\n  r\nend", "  l1.each { |elem1| l2.each { |elem2| return elem1\
    \ if elem1 == elem2 }}\nend", "    common = []\n    hash = Set.new\n    common.concat(l1).concat(l2)",
  "  common = []\n  (l1 & l2).each {|i| common << i}\n  common\nend", "  l1.each_with_object(Hash.new{|h,k|\
    \ h[k]=[]}) { |x,h|\n    x if l2&l1&l2&l1&l2 != x }\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,hash,arrays |>\n<| c |>\nThat's a very interesting solution! I'm going\
    \ to keep this in mind for next time, thank you!\n<|/ c |>\n<| a dscore=0 tags=ruby,hash,arrays\
    \ |>\nSince you asked for a solution without using enumerators, here is one:\n\
    <code>", "    common = []\n    common_count = 0\n    l1 = l1.to_a\n    l2 = l2.to_a\n\
    \    while common_count = common_count + 1\n        common += (l1[common_count]\
    \ == l2[common_count])\n    end\n    common\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ dscore=0 |>\n<| a tags=ruby,ruby-on-rails |>\nAnother way is to use:\n<code>\n\
    [a, b].uniq.map { |s| s.to_s }\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>\narr1 = [1,2,3,4,5]\narr2 = [5,6,7]", "  l1 = l1.sort { |x, y| y\
    \ <=> x }\n  l2 = l2.sort { |x, y| y <=> x }\n  l1.zip(l2).to_a.sort.map(&:first)\n\
    end", "    common=[]\n    # Loop through both lists in parallel\n    i = -1\n\
    \    j=-1\n    while i < l1.size and j < l2.size:\n        if l1[i]==l2[j]:\n\
    \            common << l1[i]\n            i += 1\n            j += 1\n       \
    \ # Stop looping when lists cros\n        i += 1\n        j += 1\n    return common",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    end", "  l1.sort.uniq.map { |x| l2.sort.uniq.detect { |y| x == y } }\nend", " \
    \ l1.sort!\n  l2.sort!\n  \n  res = []\n  \n  for i in 0...(l1.size - 1)\n   \
    \ \n    if l1[i] == l2[i]\n      res << l1[i]\n      break\n    end\n  end\n \
    \ \n  res\nend", "  l1.uniq(&:itself).sort.intersection(\n    l2.uniq(&:itself).sort\n\
    \  ).sort\nend", "  l1.uniq(&:itself)&.uniq(&:itself)\nend", "  l1.each do |x|\n\
    \    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\nend", " \
    \ c=[]\n  l.each do |i|\n    c << i if l1.include?(i)\n  end\n  l.each do |i|\n\
    \    c << i if l2.include?(i)\n  end\n  c\nend\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ doesn't seem to answer the question - how does it work when you have multiple\
    \ lists?\n<|/ c |>\n<| a |>\nA simple and fast solution:\n<code>", "  set = Set.new\n\
    \  set.merge!(l1) if l1.is_a?(Array)\n  set.merge!(l2) if l2.is_a?(Array)\n  set\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| a tags=arrays,ruby,ruby-on-rails,hash,performance\
    \ |>\n<code>", "  c=[]\n  while l1\n    while l2\n      if l1 == l2\n        c.push\
    \ l1\n        l1 = l1.next\n        l2 = l2.next\n      else\n        break\n\
    \    end\n  end\n  c\nend", "  l1.to_a.combine(l2, :+).uniq.sort \nend\n</code>\n\
    This works by creating a set of the two lists, then taking the union of the two\
    \ sets, and then sorting them by their keys in ascending order.\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate elements in the lists.\n\
    <|/ c |>\n<| a |>\nThis is another approach with Ruby 2.4.0:\n<code>", "  common\
    \ = []\n  intersection = l1.intersect(l2)\n  l1.each do |i|\n    if l2.include?(i)\n\
    \      common << i\n    end\n  end\n  intersection.each do |i|\n    common <<\
    \ i\n  end\n  common\nend", "    l = Set.new\n    (l1 & l2).each do |e|\n    \
    \    if !l.include?(e)\n            l << e\n        end\n    end\n    return l\n\
    end", "  l1.size.upto(l2.size) do |i|\n    return false if l1.include? l2[i]\n\
    \  end\n  true\nend\n</cell>\n<text>\nWe can now define a new function common?\
    \ that checks if two lists have at least the same elements.", "  a1 = []\n  a2\
    \ = []\n  a3 = []\n  if l1 and l2\n    l1.each do |x|\n      if l2.include? x\n\
    \        a1 << x\n      end\n    end\n    a2 = a1\n    l2.each do |x|\n      if\
    \ l1.include? x\n        a1 << x\n      end\n    end\n    a2 = a1\n  elsif l1\
    \ and !l2\n    a1 = l1\n  elsif !l1 and l2\n    a2 = l2\n  end\n  a1.each do |x|\n\
    \    if a2.include? x\n      a3 << x\n    end\n  end\n  a3\nend", "  l1.each_with_object([])\
    \ { |e,a| a << e if a.any? {|x| x == e} } & l2.each_with_object([]) { |e,a| a\
    \ << e if a.any? {|x| x == e} }\nend\n</code>\nThis can then be used as:\n<code>\n\
    if common(@array1,).size > 1\n  ...\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This is pretty clever, but I don't see how this would be any faster than `intersection`\
    \ as long as the arrays are short. Can you give an example?\n<|/ c |>\n<| c |>\n\
    For a big `l` (list) it might be faster as `l` grows large. But, for small `l`,\
    \ it could be slower as `intersection` is implemented in `C`. For small `l` it\
    \ might even be slower than `common`. For a small `l` it might be slower than\
    \ the version using an `intersection` as `C` code might be slower than `Ruby`.\
    \ For a small `l` it might be slower than `common`.\n<|/ c |>\n<| c |>\nI agree,\
    \ and I agree. However, the question is asking for the most efficient way to do\
    \ it, and your answer is pretty clever, but too clever. There has to be a better\
    \ way than that.\n<|/ c |>\n<| c |>\nFair enough, that makes a lot of sense. I\
    \ don't know of any efficient way to do it but this answer is the best I've seen.\n\
    <|/ c |>\n<| c |>\nI like this answer but I'm afraid it might be too \"clever\"\
    \ when compared to `intersection`. You will need to create a hash with the elements\
    \ of the input arrays first, and then perform a lookup for each element of the\
    \ intersection. `intersection` will use a hash to reduce the number of operations,\
    \ whereas this won't.\n<|/ c |>\n<| a |>\nThe fastest way is probably to use Hash.select,\
    \ but this requires that both arrays are sorted:\n<code>", "    l1.sort!\n   \
    \ l2.sort!\n    common = []\n    i = 0\n    j = 1\n    while i < l1.length and\
    \ j < l2.length\n        if l1[i] == l2[j]\n            common << l1[i]\n    \
    \        i += 1\n            j += 1\n        else\n            i += 1\n      \
    \  end\n    end\n    common.sort!\n    return common\nend\n</cell>\n<code language=julia-1.0>",
  "  c = Set.new\n  l1.each{ |i| c << i }\n  l2.each{ |i| c << i }\n  c.to_a\nend",
  "  a = l1.to_a\n  b = l2.to_a\n  return a.intersect(b).to_a\nend", "  l1.each do\
    \ |e1|\n    l2.each do |e2|\n      return e1 if e1 == e2\n    end\n  end\n  return\
    \ nil\nend", "  l1 = l1.to_a\n  l2 = l2.to_a\n  common = []\n  (1..(l1.length\
    \ + l2.length)).each do |i|\n    if l1[i] == l2[i]\n      common << l1[i]\n  \
    \    l1.delete_at(i)\n      l2.delete_at(i)\n    end\n  end\n  (1..(l1.length\
    \ + l2.length)).each do |i|\n    common = common & l1.to_a\n    l1.delete_at(i)\n\
    \  end\n  common\nend\n</code>\n<|/ a dscore=0 tags=sorting,ruby |>\n<| c |>\n\
    This does not work well with hashes - it just returns an array of all key/value\
    \ pairs, even the ones that don't appear in either list.\n<|/ c |>\n<| c |>\n\
    , how about you try it yourself?\n<|/ c |>\n<| a tags=sorting,ruby |>\n<code>",
  "  l1.each do |a|\n    l2.each do |b|\n      return a if a.eql?(b)\n    end\n  end\n\
    \  return nil\nend", "  l1 = l1.sort\n  l2 = l2.sort\n  \n  l1.each do |item1|\n\
    \    l2.each do |item2|\n      return item1 if item1 == item2\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nWhat is this line doing? `@values =\
    \ values.collect! { |v| v }` and `@values.uniq!` I am getting an error.\n<|/ c\
    \ |>\n<| c |>\nIn response to 's comment, this is a very short method that simply\
    \ removes duplicates and then adds them back in again in sorted order. So you\
    \ could do this for instance if you have an array of numbers, and want them sorted:\
    \ my_array.uniq.sort.\n<|/ c |>\n<| c |>\nThanks a lot for that great answer.\
    \ Your explanation is great and makes sense. I am really happy that I have asked\
    \ a question on StackOverflow, learned something and helped me with my problem.\
    \ Thanks for that!\n<|/ c |>\n<| c |>\nGreat explanation but one thing you should\
    \ mention is that this will produce duplicates if `@values` has duplicates. It\
    \ works fine but should really be modified to remove duplicates before sorting.\n\
    <|/ c |>\n<| a dscore=5 |>\nHere is an example to solve this problem:\n<code>\n\
    require 'set'", "  common = []\n  common = l1 & l2\n  return common\nend", "\t\
    common = Set.new\n\tcommon = Set.new(common).merge(Set.new(l1)).merge(Set.new(l2))\n\
    \treturn common.to_a.uniq\nend\n\t", "  l1.zip(l2).to_a.sort.map(&:first).uniq\n\
    end", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n\
    \  end\nend", "  l1.each_with_object(l2) do |x, a|\n    return a if a.include?(x)\n\
    \    a.push(x)\n  end\n  nil\nend\n</code>\nNow you can do this:\n<code>\ncommon_elements\
    \ = common(array1, array2)\n</code>\n<|/ a |>\n<| a |>\n<code>\narray1 = [1,2,3,4]\n\
    array2 = [1,3,4]", "  c = []\n  l1.each_with_index { |e,i| c << e if l2[i] ==\
    \ e }\n  c\nend", '  common = []', "  l1.zip(l2).to_a.reduce(:&)\nend", "  l1.sort\n\
    \  l2.sort\n  result = []\n  while l1.length > 0 and l2.length > 0\n    same =\
    \ l1.pop == l2.pop\n    break if same\n    result << l1.pop if l1.length > 0\n\
    \    result << l2.pop if l2.length > 0\n  end\n  result\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nA quick follow-up question. If I have two lists of different sizes\
    \ and I wanted to return the element that was the same in both lists, how would\
    \ I go about doing that? In the code I provided, I used `common(arr1, arr2)` but\
    \ that only works if they're the same size.\n<|/ c |>\n<| c |>\nI updated my question\
    \ to answer your follow-up question.\n<|/ c |>\n<| c |>\n, thanks for the heads\
    \ up! I appreciate it.\n<|/ c |>\n<| c |>\nThanks for your help - one last follow\
    \ up. Is there a way to do this without loops? I ask because I'm working with\
    \ a very large list and my instructor said that loops aren't the best way to go\
    \ (he wants us to learn to use map/reduce/filter). Any thoughts?\n<|/ c |>\n<|\
    \ c |>\n, I updated my answer to use a more functional approach. Does this fit\
    \ your needs?\n<|/ c |>\n<| a |>\nThis is an old thread, but thought I'd throw\
    \ my hat into the ring as a possible solution.  I like the accepted answer, but\
    \ unfortunately it doesn't work if you have duplicate elements.\n<code>\narr1\
    \ = [1,1,1,1]\narr2 = [1,1]\narr1.uniq.sort_by(&:last).zip(arr2).first", "  if\
    \ l1 == []\n  then l2\n  else l1\n  & l2\n  |> List.sort\n  |> List.unique |>\
    \ List.reduce (fun x y -> if x == y then x else x + y)\n  |> List.reduce (fun\
    \ x y -> x + y)\n  end\nend", "  l3 = l1.clone\n  l3.delete_if { |i| !l2.include?(i)\
    \ }\n  l3\nend", "    common = Set.new\n    (l1 & l2).each do |el|\n        common\
    \ << el\n    end\n    common.to_a\nend", "  l1.sort!\n  l2.sort!\n  l1.uniq!\n\
    \  l2.uniq!\n  l1 - l2\nend", "  c1 = Set.new\n  c2 = Set.new\n  c1.merge(l1)\n\
    \  c2.merge(l2)\n  c1.size == c2.size ? (Set.new(c1), Set.new(c2)) : (c1.intersection(c2),\
    \ c1.union(c2))\nend", "  l1.each_with_index do |x, i|\n    break if l2.blank?\n\
    \    l2.each_with_index do |y, j|\n      return i if x == y\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a tags=arrays,ruby,sorting,ruby-on-rails |>\n<| c |>\n\
    I love it when people like yourself. Thank you so much.\n<|/ c |>\n<| c |>\nOne\
    \ more thing: if l1 is sorted, then you might consider using insertion_sort instead\
    \ of selection sort.\n<|/ c |>\n<| c |>\n- thank you for the suggestion. Indeed,\
    \ insertion sort is preferable for sorting small arrays, and selection sort for\
    \ larger arrays. I'll add an implementation for insertion sort to my answer.\n\
    <|/ c |>\n<| a tags=arrays,ruby,sorting,ruby-on-rails |>\nHere's an O(n) solution\
    \ using two hashes: one to keep track of where the current value goes in the final\
    \ sorted array, and one to keep track of where the next value goes in the array.\n\
    <code>", "  l1.uniq.sort.intersect(l2.uniq.sort).sort\nend", "    l1_set = set\n\
    \    l2_set = set\n    l1_list = []\n    l2_list = []\n    l1.each do |e|\n  \
    \      l1_set << e\n    end\n    l2.each do |e|\n        l2_set << e\n    end\n\
    \    l1_set.each_with_index do |e, i|\n        l1_list << e if l2_set[i] && l2_set[i]\
    \ != e\n    end\n    l2_set.each_with_index do |e, i|\n        l2_list << e if\
    \ l1_set[i] && l1_set[i] != e\n    end\n    return l1_list.sort.uniq + l2_list.sort.uniq\n\
    end", "  u1 = []\n  u2 = []\n  l1 += l1[0..-2]\n  l2 += l2[0..-2]\n  for i in\
    \ (0..l1.length)\n    u1 += l1[(i+1..l1.length).min..i]\n    u2 += l2[(i+1..l2.length).min..i]\n\
    \  u1 += l1[0..(l1.length-1)]\n  u2 += l2[0..(l2.length-1)]\n  a1 = Hash.new\n\
    \  a2 = Hash.new\n  for i in (0..u1.length)\n    a1[u1[i]] = true\n    for i in\
    \ (0..u2.length)\n      a2[u2[i]] = true\n      if a1[u1[i]] and a2[u2[i]]\n \
    \       return u1\n      end\n    end\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby,arrays,math\
    \ |>\n<| c |>\nIt returns only one value when there is a duplicate\n<|/ c |>\n\
    <| c |>\nGood point.  Let me revise this.\n<|/ c |>\n<| c |>\nIt works now...\
    \ though it still isn't a solution to his problem.\n<|/ c |>\n<| c |>\nI added\
    \ a second version to my answer.\n<|/ c |>\n<| c |>\n: I made this as a general\
    \ case for more than two lists.\n<|/ c |>\n<| a tags=algorithm,ruby,arrays,math\
    \ |>\n<code>", "  common = []\n  l1.each do |e|\n    l2.each do |f|\n      common\
    \ = [e] if e == f\n    end\n  end\n  common\nend", "  l1.each_with_index do |elem1,\
    \ i1|\n    l2.each_with_index do |elem2, i2|\n      return elem2 if elem1 == elem2\n\
    \    end\n  end\n  return nil\nend", "    intersection = l1.intersection(l2)\n\
    \    union = l1.union(l2)\n    common =  intersection.size != union.size\n   \
    \ return intersection if common else nil\nend", "  l1 = l1.sort.uniq \n  l2 =\
    \ l2.sort.uniq \n  l1.zip(l2).select { |e| e[0] != e[1] }\nend\n</code>\n<|/ a\
    \ |>\n<| a |>\nI like the other answers, but my version is much shorter:\n<code>\n\
    require 'set'", "  unique1 = Set.new(l1)\n  unique2 = Set.new(l2)\n  result =\
    \ Set.new\n  l1.each do |elem|\n    if unique1.include?(elem)\n      result.add(elem)\n\
    \      unique1.delete(elem)\n    end\n  end\n  l2.each do |elem|\n    if unique2.include?(elem)\n\
    \      result.add(elem)\n      unique2.delete(elem)\n    end\n  end\n  result\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI think OP wants to get unique items from the\
    \ two lists\n<|/ c |>\n<| c |>\nOP wants to get unique items. I have revised my\
    \ answer accordingly.\n<|/ c |>\n<| c |>\nI guess he wants union of items. But\
    \ that requires some extra processing.\n<|/ c |>\n<| c |>\nHe wants the `common()`\
    \ method which he wrote. And your method doesn't produce the result he wants,\
    \ which is `[\"A\", \"B\"]`\n<|/ c |>\n<| c |>\nI understood the question differently,\
    \ you are right it could have been clearer. Fixed my answer accordingly. Thanks\
    \ for pointing this out.\n<|/ c |>\n<| a tags=arrays,ruby |>\nUse inject instead\
    \ of inject\n<code>\na = [1, 2, 3, 4]\nb = [1, 2, 3, 4]\na.inject(Set.new) { |s,\
    \ e| s.include?(e) ? s + [e] : s << e; a }\n  #=> [3, 4, 1, 2, 3] \na.inject(Set.new)\
    \ { |s, e| s.include?(e) ? s + [e] : s << e; b }\n  #=> [3, 4, 1, 2, 3] \n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 tags=arrays,ruby |>\nHere's an example from RubyMonk\n\
    <code>\na = [1, 2, 3, 4]\nb = [1, 2, 3, 4]\nc = a.inject(Set.new) { |s, e| s <<\
    \ e if a.include?(e); s }\n  #=> [3, 4, 1, 2, 3] \nd = b.inject(Set.new) { |s,\
    \ e| s << e if b.include?(e); s }\n  #=> [3, 4, 1, 2, 3] \n[c, d]\n  #=> [3, 4,\
    \ 1, 2, 3] \n</code>\nNote also that Set.new is unnecessary because a << e would\
    \ also work.\n<|/ a |>\n<| a tags=arrays,ruby |>\n<code>", "  common = []\n  l1.each\
    \ do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\nend",
  "  l1.each do |i|\n    l2.each do |j|\n      break if i == j\n    end\n  end\n \
    \ l2.each\nend\n</code>\n<|/ a dscore=1 tags=ruby,sorting,arrays |>\n<| c |>\n\
    Thanks, I see what you mean now, I just didn't realize I wasn't getting all unique\
    \ elements in each array. Thanks so much for helping me learn how to make these\
    \ methods much better!\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\nIt appears\
    \ as if you were trying to find common values in your arrays and remove duplicates?\n\
    <code>", "  c = []\n  loop do\n    break if c.empty?\n    break if c.any? { |e|\
    \ e == l1 }\n    break if c.any? { |e| e == l2 }\n    break if c.any? { |e| e\
    \ == [l1, l2] }\n    c << l1\n    c << l2\n  end\n  c.uniq\nend\n</code>\n<|/\
    \ a dscore=5 tags=list,ruby |>\n<| c |>\nThis was by far the best answer.\n<|/\
    \ c |>\n<| c |>\nThanks a lot! It worked well in an Array but in a Hash I got\
    \ `undefined method 'any?' for 1:Fixnum` error. So, I had to change this line\
    \ `break if c.any? { |e| e == l1 }` to `break if c.any?(&:equal?(l1))`\n<|/ c\
    \ |>\n<| c |>\nI believe a better solution will be to replace `break if` with\
    \ `break unless c.include?(l1)` or `break if !c.include?(l1)`\n<|/ c |>\n<| a\
    \ tags=list,ruby dscore=5 |>\nRuby 1.9 has an Enumerable#intersection method,\
    \ which will give you the intersection of two lists.\n<code>\n[1,2,3,4].intersection([2,4,6,8])",
  "\tarr = []\n\tl1.each do |e|\n\t\tl2.each do |f|\n\t\t\treturn e if e == f\n\t\t\
    end\n\tend\n\treturn arr\nend", "  l1.sort.each do |e1|\n    l2.sort.each do |e2|\n\
    \      return e1 if e1 == e2\n    end\n  end\nend", "  common = []\n  i = nil\n\
    \  j = 0\n  while j < l1.length\n    i = j\n    while i < l2.length and l2[i]\
    \ == l1[i]\n      i += 1\n    common << l1[i] if i and l2[i] == l1[i]\n    j +=\
    \ 1\n  end\n  common.sort\nend", "  a1 = []\n  a2 = []\n  l1.each do |x|\n   \
    \ if a1.include?(x)\n      next if a2.include?(x)\n      a2 << x\n    else\n \
    \     a1 << x\n    end\n  end\n  l2.each do |x|\n    if a2.include?(x)\n     \
    \ next if a1.include?(x)\n      a1 << x\n    else\n      a2 << x\n    end\n  end\n\
    \  return a1, a2\nend\nputs common([1, 2], [3, 4])\nputs common([1, 2], [4, 3])\n\
    puts common([1, 2], [5, 3])\nputs common([1, 2], [])\nputs common([], [1, 2, 3])\n\
    puts common([], [1, 2, 4])\n</code>\nOutput is:\n<code>\n[1, 2]\n[4, 3]\n[]\n\
    [1, 2, 3]\n[1, 2, 4]\n</code>\n<|/ a dscore=1 tags=ruby,arrays |>\n<| a |>\nThis\
    \ solution can be done using recursion and a Hash:\n<code>", "  common = []\n\
    \  l1.each do |el|\n    if l2.include? el\n      common << el\n    end\n  end\n\
    \  common\nend", "\th1, h2 = Hash.new([]), Hash.new([])\n\tl1.each do |item|\n\
    \t\th1[item] ||= []\n\t\th1[item] << item\n\tend\n\tl2.each do |item|\n\t\th2[item]\
    \ ||= []\n\t\th2[item] << item\n\tend\n\th1.merge(h2)\nend", "  l1.dup.sort.uniq.map\
    \ { |n| l2.detect { |n2| n == n2 } }.compact\nend", "  l1.each do |item1|\n  \
    \  l2.each do |item2|\n      return item1 if item1 == item2\n    end\n  end\n\
    \  nil\nend", "  l1 & l2\nend\n</code>\n<|/ a tags=ruby,arrays dscore=5 |>\n<|\
    \ c |>\nI like this. It makes it clear that `l1` and `l2` aren't modified in place.\n\
    <|/ c |>\n<| c |>\nGood point about `&` vs `and`, but wouldn't `Array#&` return\
    \ a new array rather than modifying the existing array?\n<|/ c |>\n<| c |>\n`Array#&`\
    \ is equivalent to `Array#&=` (which returns the receiver).\n<|/ c |>\n<| c |>\n\
    If you're using Ruby 2.6+, you can use [Set#&](https://ruby-doc.org/core-2.6.3/Set.html#method-i-26-3F).\
    \ `a = [\"a\", \"b\", \"c\"]; b = [1, 2, 3]; a.&(b)` => `[\"a\", \"b\", \"c\"\
    , 1, 2]`\n<|/ c |>\n<| c |>\nIt also works on arrays with non-comparable elements\
    \ like hashes, arrays of class objects or even arbitrary objects of class `Array`.\
    \ A bit like `a.map(&:to_s)` - it converts all elements to strings and concatenates\
    \ them.\n<|/ c |>\n<| a tags=ruby,arrays |>\nThis is an old question, but I thought\
    \ I'd post the answer here as it's the first result when googling for the same\
    \ thing.\n<code>\n[1,2,3].to_set.to_a\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ is definitely the most concise and efficient way to do it.\n<|/ c |>\n<| c |>\n\
    The question is specifically about arrays. `to_set` returns `Set` instance which\
    \ is probably not what OP needs.\n<|/ c |>\n<| c |>\nYes, as mentioned above this\
    \ answer is for arrays. But as soon as you have a hash or any other object than\
    \ `to_set` will return `nil`.\n<|/ c |>\n<| c |>\nIt will return `nil` for hashes.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\nA variation on the first two answers is the\
    \ following:\n<code>", "  l1.each do |item|\n    return item if l2.include?(item)\n\
    \  end\n  nil\nend", "  l1.zip(l2).flatten.reject { |x,y| x == y }\nend\n</code>\n\
    It takes two arguments: l1 and l2 and returns a hash with keys from l1 and values\
    \ form l2. Values of l2 are compared with values of l1 and the key with value\
    \ that is common is rejected.\n<|/ a |>\n<| c |>\nThis code doesn't work if the\
    \ hashes have different keys. For example, `common({'a' => 1, 'b' => 2}, {'b'\
    \ => 2, 'c' => 3})` returns `{'b' => 2, 'c' => 3}`, when it should return `{}`\n\
    <|/ c |>\n<| c |>\n, you are right, I added a method to return empty hash if the\
    \ hashes have different keys\n<|/ c |>\n<| a tags=hash,ruby |>\n<code>\nh1 = {a:\
    \ 1, b: 2, c: 3, d: 4}\nh2 = {a: 2, d: 3, c: 4, b: 1}\n</code>\nAnswer: \n<code>\n\
    Hash[h1.merge(h2).grep(&:key?)]", "  l1.select { |x| l2.include? x }.sort\nend",
  "  return Set.new([ l1 & l2 ]).to_a\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nIt might be better to do `Hash[*(l1.zip(l2).map(&:to_a))]`, since `Hash::[]`\
    \ uses the default proc anyway when given two nil args.\n<|/ c |>\n<| c |>\nI\
    \ did not know about `Hash::[]`. Thanks!\n<|/ c |>\n<| c |>\nNice, thanks. I didn't\
    \ know about `Hash::[]` either, and it is pretty handy. I'd like to see more use\
    \ cases for it, so maybe you can add to your answer - e.g., using `Enumerable#zip`\
    \ to get `[['a', 'b'], ['c', 'd']]`, then `Hash::[]` takes that `[['a', 1], ['b',\
    \ 2], ['c', 3]]` and converts it to a `Hash` with keys 1, 2, and 3.\n<|/ c |>\n\
    <| c |>\nIt would be nice if there was a way to get `Set` from Arrays in ruby\
    \ 1.9.\n<|/ c |>\n<| c |>\nI don't see how this works.  `l1.zip(l2)` gives you\
    \ `[[\"a\", \"b\"], [\"c\", \"d\"]]`, but then `l1.zip(l2).map(&:to_a)` gives\
    \ you `[[\"a\", 1], [\"b\", 2], [\"c\", 3]]`, which doesn't seem to do anything.\
    \  What am I missing?\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays |>\nI came up\
    \ with a slightly more elegant way of getting unique arrays from two lists using\
    \ the union operator & which combines two arrays into one. I then used sort to\
    \ remove the duplicates:\n<code>\na = [1,2,3]\nb = [2,3,4]\na.sort.uniq.concat(b.sort.uniq).uniq\n\
    => [1,2,3,4,5]\n</code>\n<|/ a |>\n<| c |>\nThis only works when the array elements\
    \ are unique as per OP's posting example.  Try this for a unique element array:\
    \  `a = [1,2,3]; b = [1,3,4]; a.sort.uniq.concat(b.sort.uniq).uniq`\n<|/ c |>\n\
    <| c |>\nYes, but that was not the question. I thought he wanted to combine both\
    \ lists into one array without duplicating elements. I thought this would be the\
    \ easiest way of doing it.\n<|/ c |>\n<| a tags=ruby,arrays |>\nIf you're working\
    \ with Ruby >= 2.2, you can do ", "  l1 = l1.to_a\n  l2 = l2.to_a\n  common =\
    \ []\n  until l1.empty? || l2.empty?\n    if l1.first == l2.first\n      common\
    \ << l1.shift\n      l1.shift\n    else\n      common << l2.shift\n      l2.shift\n\
    \    end\n  end\n  common\nend\n</code>\n<|/ a tags=ruby dscore=3 |>\n<| c |>\n\
    Nice solution. I made an update. Can you explain what you mean by \"shift element\"\
    ? I didn't fully get it from the comment.\n<|/ c |>\n<| c |>\n`l1.shift` shifts\
    \ the first element of l1 to the left. `l2.shift` shifts the first element of\
    \ l2 to the left.\n<|/ c |>\n<| c |>\nThank you! It's very intuitive and simple\
    \ to understand. Your solution does work, however my original question was about\
    \ performance.\n<|/ c |>\n<| c |>\nThanks, I've added a benchmark for your solution\
    \ to my answer. My solution had a performance benefit of about 40% over your solution.\n\
    <|/ c |>\n<| a dscore=3 |>\nIf you don't need the elements to be in any particular\
    \ order:\n<code>", "  l1 = l1()\n  l2 = l2()", "  common_elements = []\n  \n \
    \ for i in l1\n    if l2.include?(i)\n      common_elements << i\n    end\n  end\n\
    \  \n  common_elements\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby dscore=1\
    \ |>\nI think this is a pretty clean way to do the trick:\n<code>\nl1 = [1,2,3,4]\n\
    l2 = [1,3,4]\nl1.uniq - l2.uniq\n</code>\n<|/ a |>\n<| a tags=ruby |>\nIn case\
    \ you only want to compare the first element of each array, you can use Enumerable#transpose\
    \ to create an array of arrays containing all the combinations:\n<code>\nl1.map(&:first)\
    \ + l2.map(&:first).uniq\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby dscore=0\
    \ |>\nI think your answer is a good start. You don't need to find all the permutations\
    \ and then use uniq to remove duplicates. You can just go through all the permutations\
    \ and find the duplicates.\n<code>\nl1 = [1,2,3,4]\nl2 = [3,4]\nl3 = [1,4,3]",
  "  common = []\n  l1.each do |x|\n    if l2.include? x\n      common << x\n    end\n\
    \  end\n  common\nend", "    l3 = []\n    l1.each do |i|\n        l2.each do |j|\n\
    \            l3.push(i if j == i)\n        end\n    end\n    l3\nend", "  a1 =\
    \ []\n  a2 = []\n  a1_hash = Hash.new(0)\n  a2_hash = Hash.new(0)\n  l1.each do\
    \ |item|\n    a1_hash[item] += 1\n  end\n  l2.each do |item|\n    a2_hash[item]\
    \ += 1\n  end\n  a1_hash.keys.sort.reverse.each do |item|\n    a1 << item\n  end\n\
    \  a2_hash.keys.sort.reverse.each do |item|\n    a2 << item\n  end\n  a1.sort.reverse\
    \ & a2.sort\nend", "  l1.each do |item|\n    l2.each do |item2|\n      yield item\
    \ if item == item2\n    end\n  end\nend", "  l1.each do |val1|\n    l2.each do\
    \ |val2|\n      return val1 if val1 == val2\n    end\n  end\n  nil\nend", "  \
    \  l1.each do |i|\n        l2.each do |j|\n            return i if i == j\n  \
    \      end\n    end\n    return nil\nend", "  l1 = l1[:] if l1.is_a?(Array)\n\
    \  l2 = l2[:] if l2.is_a?(Array)\n  l1.each do |el|\n    l2.delete(el) if l2.include?(el)\n\
    \  end\n  l2.size\nend\n</code>\n<|/ a tags=hash,sorting,ruby,arrays |>\n<| c\
    \ |>\nA few comments on your code. Firstly your `common` method is flawed, it\
    \ will not return unique values if any of them are `nil`. Secondly, your second\
    \ `each` loop will blow up when `l2` has 0 elements. The reason for this is that\
    \ `delete` will not return `true` when it finds the first element to be deleted.\
    \ Lastly, your `common` method could benefit from using `Array#uniq`\n<|/ c |>\n\
    <| c |>\nGood catch,, thanks! I didn't think of that. I've amended my answer accordingly.\n\
    <|/ c |>\n<| c |>\nYou still have one bug in your code. Try `common([1,3,4], [1,2,3])`\
    \ -- it will return `0`, when the correct answer is `2`.\n<|/ c |>\n<| c |>\n\
    Thanks, I've fixed the bug in my answer.\n<|/ c |>\n<| a tags=hash,sorting,ruby,arrays\
    \ |>\n<code>", "  return Set.new(l1).intersection(Set.new(l2))\nend\n</cell>\n\
    <cell>\ncommon([1, 2, 3], [1, 2, 3])\n</cell>\n<cell>\ncommon([1, 2, 3], [1, 2,\
    \ 2, 3])\n</cell>\n<text>\nUsing reduce", "  l1 += l2\n  l1.uniq.compact!\nend",
  "  # Create an empty set for comparison.\n  common = []\n  \n  # Iterate over the\
    \ two lists.\n  l1.each { |e| common << e }\n  l2.each { |e| common << e }\n \
    \ \n  # Return the array of unique common elements.\n  common.uniq\nend", "  return\
    \ [l1[0], l2[0]] unless l1[0] == l2[0] && l1.length > 1\n  common(l1[1..-1], l2)\n\
    end", "  l1.each do |elem1|\n    l2.each do |elem2|\n      return elem1 if elem1\
    \ == elem2\n    end\n  end\n  nil\nend", "  l1.zip(l2).flatten.uniq.sort\nend\n\
    </code>\n<|/ a |>\n<| a dscore=2 |>\nI wanted to see if a list contained another\
    \ list so I came up with this method\n<code>", "  a = l1.to_a\n  b = l2.to_a",
  "  l1.each { |x| l2.each { |y| return x if x == y } }\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-4\
    \ dscore=0 |>\n<| c |>\nI dont think you understood the question, I'm sorry if\
    \ I'm wrong, but my issue is when I'm running a query with a where clause that\
    \ contains a hash... For instance `Post.where(category: { \"#{ params[:category]\
    \ }\": 1 })` ... this only return me posts from that category\n<|/ c |>\n<| c\
    \ |>\nThis is not an answer. This is the same as your answer. How about some explanation\
    \ as to why this works?\n<|/ c |>\n<| c |>\nSorry.  I thought this was a comment.\
    \  I added some comments.\n<|/ c |>\n<| a dscore=0 |>\nI came up with a solution\
    \ for my problem but i don't know if it's the best solution.\nI create my hash\
    \ and pass it into a scope\n<code>\nscopes = {\n  categories: {\n    'sports'\
    \  => 1,\n    'tech'    => 1,\n    'life'    => 1,\n    'news'    => 1\n  }\n}",
  "  u = []\n  l1.each_with_index do |e1, i1|\n    l2.each_with_index do |e2, i2|\n\
    \      next if e1 == e2\n      break if i == i2\n      u << e1 if e1.eql?(e2)\n\
    \    end\n  end\n  u\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nWhat is\
    \ the complexity of this solution? Is it O(nlogn)?\n<|/ c |>\n<| c |>\nYes, it\
    \ is. O(nlogn) is the best we can do, since n is the size of both arrays. Note\
    \ that if you had a hash of lists instead of arrays, it would be O(nlogn).\n<|/\
    \ c |>\n<| c |>\nIn fact, this is O(|l1| + |l2|). :)\n<|/ c |>\n<| c |>\nJust\
    \ out of curiosity, is this a more efficient solution than the one from Abubakar\
    \ Ghadiyaram?\n<|/ c |>\n<| c |>\n: Yes, it's more efficient in terms of space\
    \ complexity. Not efficient in terms of time complexity though.\n<|/ c |>\n<|\
    \ a tags=arrays,ruby |>\n<code>\nrequire 'set'", "    uniques = l1.select { |e|\
    \ l2.include? e }\n    uniques.sort\nend\n</code>\n<|/ a tags=ruby-on-rails,ruby,activerecord,rails-activerecord\
    \ dscore=1 |>\n<| a tags=ruby-on-rails,ruby,activerecord,rails-activerecord dscore=1\
    \ |>\nUse Enumerable#each_cons:\n<code>", "  common = Set.new\n  l1.each { |x|\
    \ common << x if l2.member?(x) }\n  common\nend", "  common = Set.new\n  l1.each\
    \ do |x|\n    l2.each do |y|\n      if x == y\n        common << x\n      end\n\
    \    end\n  end\n  common\nend", "    common = []\n    i = 0\n    j = -1\n   \
    \ while i < l1.length and j < l2.length\n        if l1[i] == l2[j]\n         \
    \   common << l1[i]\n            i += 1\n            j += 1\n        else\n  \
    \          i += 1\n        end\n    end\n    common << l2[j] if i < l1.length\n\
    \    common << l1[i] if j < l2.length\n    return common\nend", "  l1.each do\
    \ |elem1|\n    l2.each do |elem2|\n      return elem1 if elem1 == elem2\n    end\n\
    \  end\nend", "  common = Set.new\n  l1.each do |i|\n    l2.each do |j|\n    \
    \  common << i if i == j\n    end\n  end\n  common\nend", "    common = []\n \
    \   i = j = 0\n    while i < l1.length and j < l2.length\n        if l1[i] ==\
    \ l2[j]\n            common << l1[i]\n            i += 1\n            j += 1\n\
    \        else\n            i += 1\n            j += 1\n        end\n    end\n\
    \    while i < l1.length\n        common << l1[i]\n        i += 1\n    end\n \
    \   while j < l2.length\n        common << l2[j]\n        j += 1\n    end\n  \
    \  common\nend\n</cell>\n<code language=julia-1.5>", "  l1.sort!\n  l2.sort!\n\
    \  common = []\n  while l1.length > 0 and l2.length > 0\n    if l1[0] == l2[0]\n\
    \      common << l1[0]\n      l1.shift\n      l2.shift\n    elsif l1[0] < l2[0]\n\
    \      l1.shift\n    else\n      l2.shift\n    end\n  end\n  common\nend", " \
    \ # Return an empty array if there are no common elements.\n  return [] if l1.size\
    \ <= l2.size or l1.size == 0", "\ta1 = l1.sort()\n\ta2 = l2.sort()\n\tl1.length\
    \ >= l2.length and l1.length and l2.length and l1[0] == l2[0]\n\tl1.length >=\
    \ l2.length and l2[0]\n\tl1.length >= l2.length and l2[0] and a2[0] == a1[0]\n\
    \tl1.length >= l2.length and a2[0] == a1[0] and a1.length == a2.length\n\tl1.length\
    \ >= l2.length and a2[0] == a1[0] and a2.length == a1.length\n\tl1.length >= l2.length\
    \ and a1.length == a2.length\n\tl1.length >= l2.length and a1.length == a2.length\
    \ and a1[0] == a2[0]\n\tl1.length >= l2.length and a1.length == a2.length and\
    \ a1[0] == a2[0] and a1.length == a2.length\n\tl1.length >= l2.length and a1[0]\
    \ == a2[0] and a1.length == a2.length\n\ta1.length == a2.length and a1[0] == a2[0]\
    \ and a1.length == a2.length\n\tl1.length == a2.length and a1[0] == a2[0] and\
    \ a2.length == a1.length\n\ta2.length == a1.length and a1[0] == a2[0] and a2.length\
    \ == a1.length\n\ta1[0] == a2[0] and a1.length == a2.length and a2.length == a1.length\n\
    \ta1[0] == a2[0] and a2.length == a1.length\n\ta1[0] == a2[0] and a1.length ==\
    \ a2.length\n\ta1[0] == a2[0]\nend", "  l1 += l2\n  l2.uniq!\n  l1.uniq!\n  l1.sort!\n\
    \  l2.sort!\n  l1.uniq!\n  l2.uniq!\n  l1\nend", "  a = Array.new\n  l1.each do\
    \ |e|\n    if l2.include? e\n      a << e\n    end\n  end\n  a.sort\nend", " \
    \   intersect = Set.new(l1 & l2).to_a\n    disjoint = Set.new(l1 - l2).to_a\n\
    \    common = Set.new(intersect & disjoint).to_a\n    common.sort\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nNice answer! I like it even though it only works\
    \ for arrays with unique items.\n<|/ c |>\n<| a dscore=4 |>\nThe simplest solution\
    \ is probably to use Array#uniq!\n<code>", "  l1.zip(l2).select { |k, v| k ==\
    \ v }\nend", "    common_elements = []\n    common_elements_count = 0\n    common_elements_added\
    \ = False\n    l1.each_with_index do |element, i|\n        common_elements_count\
    \ += 1\n        if common_elements_count == l1[i]\n            common_elements_added\
    \ = True\n            common_elements << element\n        end\n    end", "  set\
    \ = Set.new\n  l1.each { |a| set << a unless set.include?(a) }\n  l2.each { |a|\
    \ set << a unless set.include?(a) }\n  set\nend", "    l1.each_with_object([]).with_index\
    \ { |e,a| a.concat([e]) } & l2.each_with_object([]).with_index { |e,a| a.concat([e])\
    \ }\nend", "  l1 & l2.sort\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    The sort at the end is unnecessary, `&` creates a new array, sorts that, then\
    \ returns the intersection.\n<|/ c |>\n<| c |>\nyeah. I was just trying to make\
    \ it more legible.\n<|/ c |>\n<| a tags=ruby,arrays |>\nIn Ruby 1.9 you can use:\n\
    <code>", "  a1 = l1.uniq\n  a2 = l2.uniq\n  a1 & a2\nend", "\tl1 ||= []\n\tl2\
    \ ||= []\n\tl1.uniq!\n\tl2.uniq!\n\tl1.zip(l2).flatten!\n\tl1.uniq.sort.intersection(l2.uniq.sort).compact!\n\
    end", "  a = Set.new\n  (l1 & l2).each { |x| a << x }\n  a.to_a\nend\n</code>\n\
    <|/ a tags=arrays,ruby,hash,array-difference dscore=3 |>\n<| c |>\nI love how\
    \ concise this is, compared to the solutions above. Had to try it on about 10K\
    \ pairs. Very nice indeed.\n<|/ c |>\n<| a |>\nA solution that works for me (irb)\n\
    <code>\n>> arr = [1,2,3,4,5]\n=> [1, 2, 3, 4, 5]\n>> arr & arr\n=> [1, 2, 3, 4,\
    \ 5]\n>> arr & arr - [2,3]\n=> [1, 4]\n>> arr & arr - [2,3] + [3,5]\n=> [1, 4]\n\
    </code>\n<|/ a tags=arrays,ruby,hash,array-difference dscore=2 |>\n<| c |>\nthis\
    \ does not work for me, `arr = [1,2,3,4,5,6]; arr & arr - [2,3] - [3,5]` returns\
    \ `[1,2,4,5,6]`\n<|/ c |>\n<| a tags=arrays,ruby,hash,array-difference dscore=2\
    \ |>\nThis approach is simple, easy to read, and easy to modify. It works for\
    \ arbitrary sized arrays (it only does O(n) comparisons, where n is the size of\
    \ the smaller array).\n<code>\nmodule ArrayDifference\n  def self.difference(array)\n\
    \    array.each_with_index.select { |el, i| !(i == array.index(el)) }\n  end\n\
    end\n</code>\nExample:\n<code>\n[1,2,3] - [1,3,4]", "    common = Set.new\n  \
    \  l1.each do |el|\n        l2.each do |other|\n            common << el if el\
    \ == other\n        end\n    end\n    common.to_a\nend", "  return l1.uniq | l2.uniq\n\
    end", "  l1 = l1.to_a\n  l2 = l2.to_a\n  common = []\n  common = common+(l1&l2)\
    \ - common+(l1|l2)\n  common = common+(l1^l2) - common+(l1&l2^l2)\n  common\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI think you meant to say `(l1 & l2) - common`,\
    \ not `common+(l1 & l2)`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l1.find {|i|\
    \ l2.include? i}\nend", "  common = []\n  l1.each do |i|\n    l2.each do |j|\n\
    \      return i if i == j\n    end\n  end\n  return nil\nend", "  l1 = l1[:] if\
    \ l1.is_a?(Array); l2 = l2[:] if l2.is_a?(Array)\n  l1.zip(l2).select { |x, y|\
    \ x != y }.map(&:first)\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`l1.zip(l2).select\
    \ { |x, y| x != y }` can be simplified to `l1.zip(l2).all?{|x,y| x==y}`\n<|/ c\
    \ |>\n<| c |>\nyeah, I know, but I was trying to keep it simple. I'll edit my\
    \ answer.\n<|/ c |>\n<| a |>\nRuby >= 2.4\n<code>\n[ \"1\", \"2\", \"3\" ].join.to_i(\"\
    ,\").scan(/(\\d+)/).map(&:to_i).uniq", "  common = []\n  a1 = l1.sort\n  a2 =\
    \ l2.sort\n  (length(a1) - 1).downto(0) do |i|\n    j = i + 1\n    (j > length(a2))\
    \ ? break : (length(a1) - i).downto(j - 1) do |j|\n      common << a1[i..j]\n\
    \    end\n  end\n  common.sort.uniq\nend\n</code>\nNote that this solution uses\
    \ uniq at the end. If you want to avoid that, simply add a ! at the end of that\
    \ line so that it becomes: common << a1[i..j] unless a1[i..j].include?(common[i..j])\
    \ \nAnother solution would be to use an array and loop through it, adding the\
    \ elements of the smaller array to the new array: \n<code>", "  l1.each do |e1|\n\
    \    l2.each do |e2|\n      return e1 if e1 == e2\n    end\n  end\nend\ncommon(l1,\
    \ l2)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI think your second example is wrong:\
    \ it returns all items that are common to both lists. You need to return only\
    \ common items between two lists. E.g. `[1, 1, 2, 3, 3, 6, 6]`.\n<|/ c |>\n<|\
    \ a |>\nHere's my solution:\n<code>", "  common = Set.new\n  l1.each do |x|\n\
    \    l2.each do |y|\n      common << x if x == y\n    end\n  end\n  common.sort\n\
    end\n</cell>\n<cell>", "  l1.zip(l2).map { |a, b| (a & b).size }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThanks, I really appreciate the detailed explanation. I think\
    \ I understand it a bit better now. I also just read something about `Enumerable#group_by`,\
    \ which looks like a good way to go about it. I was also trying to figure out\
    \ how to do a `select` in `Enumerable` so I added my own answer.\n<|/ c |>\n<|\
    \ c |>\nI accepted your answer because it pointed me in the right direction, but\
    \ I actually went with `Enumerable#group_by` because it was the most elegant solution\
    \ I could come up with. Thanks again.\n<|/ c |>\n<| c |>\n`#group_by` is more\
    \ efficient for larger datasets because it doesn't build an intermediate hash\
    \ table. However, if you have a small dataset and `#group_by` is working, it's\
    \ likely just as efficient as `#uniq`.\n<|/ c |>\n<| a dscore=1 |>\nHere is a\
    \ solution I found on another question:\n<code>", "    common = []\n    common\
    \ = l1.select do |item|\n        l2.include? item\n    end\n    common\nend",
  "  l1.sort.zip(l2.sort).inject(:&)\nend", "  if l1.size < l2.size\n    l1, l2 =\
    \ l2, l1\n  a1 = l1.sort\n  a2 = l2.sort\n  (l1, l2) = l1.size, l2.size\n  (i,\
    \ j, ai) = (0, 0, a1)\n  (k, l, a2) = l1, l2, a2\n  while i < k and j < l\n  \
    \  i <<= 1\n    j <<= 1\n    ai << (a1[i] < a2[j] ? i : j)\n  end\n  a1, a2 =\
    \ ai, ai + a1, ai + a2\n  k -= i\n  l -= j\n  result = []\n  while i < k\n   \
    \ result << a1[i]\n    i <<= 1\n  end\n  while j < l\n    result << a2[j]\n  \
    \  j <<= 1\n  end\n  return result\nend", "  common = []\n  i1, j1 = l1.length,\
    \ 0\n  i2, j2 = l2.length, 0\n  while i1 != 0 or j1 != 0\n    # Remove elements\
    \ from both lists.\n    i1 -= 1 if i1 != 0 else 0\n    j1 -= 1 if j1 != 0 else\
    \ 0\n    i2 -= 1 if i2 != 0 else 0\n    j2 -= 1 if j2 != 0 else 0\n    if i2 !=\
    \ 0\n      common << l2[j2]\n      j2 -= 1\n    elsif j2 != 0\n      common <<\
    \ l1[i1]\n      i1 -= 1\n    else\n      # Found a common element.\n      if common\
    \ && !commons.include?(common)\n        # Add to common array.\n        commons\
    \ << common\n      end\n      common = nil\n    end\n  end\n  commons\nend", " \
    \ # First we get the sorted unique elements.\n  l1 = l1.uniq.sort\n  l2 = l2.uniq.sort\n\
    \  # Then we check whether there are common elements.\n  common_elements = l1.intersection(l2)\n\
    \  # Now we sort unique common elements.\n  common_elements.sort\nend", "  common\
    \ = Set.new\n  l1.each { |e| common << e if l2.include?(e) }\n  common\nend",
  "\tl3 = []\n\tl3 = l1\n\tl3.merge(l2)\n\tl3.compact!\n\tl3.unique!\nend", "  u1\
    \ = Set.new\n  u2 = Set.new\n  common = []", "  common = Set.new\n  l1.each do\
    \ |i|\n    l2.each do |j|\n      common << i if i == j\n    end\n  end\n  common.to_a\n\
    end", "  result = l1.dup\n  l2.each_index do |i|\n    if result[i] && result[i]\
    \ != l1[i]\n      result.delete_at(i) if result.include?(result)\n      result.insert(i,\
    \ l1[i])\n    end\n  end\n  result\nend", "  c = Set.new\n  (l1 & l2).each{ |v|\
    \ c << v }\n  c.uniq.sort\nend", "  l1 = l1.to_a\n  l2 = l2.to_a\n  l1.reject!\
    \ { |e| l2.include?(e) }\n  l2.reject! { |e| l1.include?(e) }\n  l1.concat(l2)\n\
    end", "  # Create hash set for both lists.\n  h1 = Hash[*l1]\n  h2 = Hash[*l2]\n\
    \  # Return sorted unique common elements.\n  h1.keys & h2.keys\nend\n</code>\n\
    The Ruby standard library includes the Enumerable module which includes the Enumerable\
    \ class. All of the methods in the Enumerable class include a bang method, which,\
    \ when invoked, returns self. It then iterates over all the elements in a given\
    \ collection, in order or by order. Enumerable#find invokes the given block for\
    \ each element in the collection. If the block returns true, the current element\
    \ is returned. Otherwise, the return value of Enumerable#find is returned instead.\
    \ Thus, an if statement is equivalent to the following code: \n<code>\nif block.call(element)\
    \ == true then return element else return enum_for(__method__).find end end\n\
    </code>\nA common use case for find:\n<code>\nusers = [\"David\", \"Bob\", \"\
    Kate\"]\nusers.find do |user|\n  user == \"Bob\" or user == \"Kate\"\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThanks for this, I'll look into it now.\n<|/ c |>\n\
    <| c |>\nWhat is the `||` operator doing? I've seen that before, but I don't remember\
    \ what it is.\n<|/ c |>\n<| c |>\n`||` is the [logical operator](http://www.tutorialspoint.com/ruby/ruby_logical_operators.htm).\
    \ The logical operator in Ruby is a double-pipe `||`, which evaluates the left\
    \ hand side and returns `nil` if the left hand side is `nil` or is not true; otherwise,\
    \ it evaluates the right hand side and returns `true` if the left hand side is\
    \ `true`, or `false` if it's `false` or `nil`. A common use case for `find`: `users.find\
    \ { |user| user == \"Bob\" || user == \"Kate\" }` will return `\"Kate\"` because\
    \ `\"Bob\"` and `\"Kate\"` are both truthy.\n<|/ c |>\n<| a |>\n<code>", "  l1.flatten!\n\
    \  l2.flatten!\n  uniq_elements = l1.uniq\n  uniq_elements -= l2\n  uniq_elements.flatten!\n\
    end\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work in all cases. E.g.\
    \ for [1, 1, 1] and [1, 1], it returns [1, 1] instead of [1]. Also, I believe\
    \ this is a different algorithm to `merge`, which merges arrays in an order from\
    \ longest to shortest, and this algorithm merges arrays in an order from shortest\
    \ to longest.\n<|/ c |>\n<| c |>\nThanks for the feedback. I think your comment\
    \ about merging is a valid point. It seems I've made an error in my implementation.\
    \ I will edit my answer to correct it.\n<|/ c |>\n<| c |>\nThis is definitely\
    \ more efficient, though I would be interested to see some performance tests.\
    \ I think it can be made even more efficient by sorting the arrays first.\n<|/\
    \ c |>\n<| a |>\nAs suggested in other answers, the simplest way is to use Array#&\
    \ with the intersection operator:\n<code>", "  l1.each_with_object(Hash.new(0))\
    \ { |e,h| h[e] += 1 }\n    .select { |k,v| l2.include?(k) }\n    .keys\nend",
  "  l1.each_with_index do |x, i|\n    if l2.include? x\n      l2.delete_at(i)\n \
    \     l1.delete_at(i)\n      return\n    end\n  end\n  l1\nend", "  l1.sort {\
    \ |a, b| b <=> a }\n  l2.sort { |a, b| b <=> a }\n  l1.zip(l2).select { |e| e[0]\
    \ != e[1] }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
