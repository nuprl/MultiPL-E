name: HumanEval_13_greatest_common_divisor
language: rb
prompt: "# Return a greatest common divisor of two integers a and b\ndef greatest_common_divisor(a,\
  \ b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_greatest_common_divisor\n\
  \    candidate = method(:greatest_common_divisor)\n    assert_equal(1, candidate.call(3,\
  \ 7))\n    assert_equal(5, candidate.call(10, 15))\n    assert_equal(7, candidate.call(49,\
  \ 14))\n    assert_equal(12, candidate.call(144, 60))\n  end\nend\n"
completions: ["  return b ? gcd(b, a % b) : a\nend", "  if a > b\n    (a, b) = (b,\
    \ a)\n  end\n  return a - (b / a)\nend", "  while b != 0\n    a, b = b, a % b\n\
    \  end\n  a\nend", "  lcm = lcm(a, b)\n  div = a / lcm\n  while (b % lcm)\n  \
    \  lcm = lcm * div\n    div = div / div\n  return lcm\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI like the fact that I can easily write my own lcm function\n<|/ c |>\n\
    <| a dscore=3 |>\nFor any positive integer x we can find the greatest common divisor\
    \ of x and 1 by finding x modulo 1 and dividing it by that divisor. The remainder\
    \ of dividing x by 1 is the gcd of x and 1.\n<code>", "  return nil unless a.is_a?(Integer)\
    \ && b.is_a?(Integer)\n  while b > 0\n    a, b = b, a % b\n  end\n  a\nend", " \
    \ return a % b if a % b != 0 else b\nend", "  i = a % b\n  a = b\n  b = i\nend",
  "  return a if b == 0 then 1 else b if b > a then b else a\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays,algorithm |>\n<| a tags=ruby,arrays,algorithm |>\nI wrote an\
    \ answer on finding a GCD of a given list of integers in Ruby. It should be fairly\
    \ fast for larger input lists and I believe it handles the edge cases of the highest\
    \ input list being a perfect square. I'll post my answer here too for the record:\n\
    <code>", "  if b == 0 || b == 1\n    return a\n  elsif a == 0 || a < 0\n    raise\
    \ ArgumentError, \"can't divide by zero\"\n  end", "  # Define a variable to keep\
    \ our running total of the divisor\n  total = 0\n  # Use while loop to keep going\
    \ as long as we haven't found the divisor\n  while a != b\n    # If the remainder\
    \ is not 0 then we found the divisor\n    if a % b != 0\n      # Update the total\
    \ to keep a running total\n      total = total + a\n      # Set our a to the remainder\n\
    \      a = a % b\n    # If our b is 0 then we found the divisor\n    elsif b ==\
    \ 0\n      # The total is the running total of the divisor plus the total of the\
    \ remaining a\n      return total + a\n    # Else, we have to get our b down to\
    \ 0\n    b -= 1\n  end\nend", "  while b\n    a, b = b, a % b\n  end\n  a\nend\n\
    </code>\nThen to find the greatest common divisor of 2 numbers x and y you can\
    \ use the following (using a nested loop would also work):\n<code>\nx = 9\ny =\
    \ 7\nwhile y > 0\n  x = greatest_common_divisor(x, y)\n  y = y - 1\nend\nx", " \
    \ while b != 0\n    a, b = b, a % b\n  end\n  a\nend", "    factors = []\n   \
    \ factor = 1", "  x = a % b\n  y = b\n  while x != 0\n    x = a % x\n    y = b\n\
    \    while y != 0\n      y = y % y\n    end\n  end\n  x\nend\n</cell>\n<cell>",
  "  while b % a != 0\n    a = a+1\n  end\n  return a\nend\n</code>\n<|/ a |>\n<|\
    \ a tags=ruby,ruby-on-rails,algorithm dscore=0 |>\n<code>", "  if b == 0 then\
    \ return a\n  return greatest_common_divisor(b, a % b)\nend\n</cell>\n<code language=julia-1.5>",
  "  if a == 0 then return b\n  if b == 0 then return a\n  if a > b then b, a = a,\
    \ b\n  loop do\n    if a % b == 0 then return b\n    b, a = a, b - a % b\n  end\n\
    end", "    \n    # Initialize a prime to store gcd \n    prime = []\n    \n  \
    \  # Perform prime number generation\n    until b == 1 do\n        prime = prime..(GCD\
    \ a b)\n    end\n    \n    # Return the smallest common multiple\n    return prime[1]\n\
    end", "  if a == 0 and b == 0\n    0\n  elsif a < 0 && b < 0\n    -1\n  else\n\
    \    greatest_common_divisor(abs(a), abs(b)) unless a * b == abs(a) * abs(b)\n\
    \  end\nend", "  if a > b\n    a = a\n    b = b\n  end\n  (1..(b / a).each_index).reduce(:*)\n\
    end", "  (if a == 0)\n  then\n    (b == 0)\n  else\n    (if (b == 0)\n      then\n\
    \        (a%b)\n      else\n        (greatest_common_divisor (a%b, b))\n    )\n\
    \  end\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\nA simple solution using modulus\
    \ and division (not taking into account the case that the two numbers are equal\
    \ or one is 0):\n<code>\nfunction gcd(a,b) \n  local mod = a%b\n  if mod > 0 then\n\
    \    return gcd(b,mod)\n  else\n    return mod\n  end\nend", "    return a if\
    \ (b == 0) else greatest_common_divisor(b, a % b)\nend", "  return a if b == 0\
    \ else greatest_common_divisor(b, a % b)\nend", "    if a == 0 \n        return\
    \ b\n    if b == 0\n        return a\n    \n    greatest_common_divisor = (b /\
    \ greatest_common_divisor(a))\n    \n    return greatest_common_divisor\n</cell>\n\
    <text>\nThe function below returns the least common multiple of two integers a\
    \ and b \n(a number a that is the least common multiple of the numbers contained\
    \ in b). \nThe greatest common divisor can be found with greatest_common_divisor(). ",
  "  return a % b if b.even? && a && b && b.odd? else b\nend\n</code>\n<|/ a tags=ruby,gmp,math\
    \ |>\n<| a tags=ruby,gmp,math dscore=1 |>\nA Ruby implementation of the Euclid's\
    \ Algorithm for GCD (greatest common divisor) using Array#each_cons to get the\
    \ pairwise combinations and Array#min to find the GCD in each pair, using Array#-:\n\
    <code>", "  return a - (b % a)\nend", "    return a if b == 0 else b if a == 0\
    \ else greatest_common_divisor(b, a % b)\nend\n</code>\nThen call it like this:\n\
    <code>\nprint greatest_common_divisor(greatest_common_divisor(7, 3), 10)\n</code>\n\
    It works by computing the greatest common divisor of the two numbers, then the\
    \ second number. Then the final number is computed by finding the greatest common\
    \ divisor of those two numbers.\n<|/ a dscore=2 |>\n<| a dscore=2 tags=ruby,primes\
    \ |>\nI found that the first three methods posted here were not quite working\
    \ (at least on my computer).  I was hoping that it would return all prime numbers\
    \ but instead it returned all non-prime numbers. \nI took a look at my computer\
    \ science book and came up with this code:\n<code>\nprime_numbers = Array.new(1000)",
  "  while b > 0\n    a, b = b, a % b\n  end\n  a\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-4,algorithm\
    \ |>\n<| c |>\nYou need to *really* get familiar with Ruby's [assignment operators](http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Operators#Assignment)\
    \ before you can apply this solution.\n<|/ c |>\n<| a dscore=2 |>\nHere's an answer\
    \ that uses \"only\" standard library:\n<code>", "  return ( b - a % b ) / b if\
    \ b != 0 else a\nend\n</cell>\n<code language=julia-1.6>", "    return b if a\
    \ > b else a\nend", "  return a if b == 0 else greatest_common_divisor_aux(b,\
    \ a%b)\nend", "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend", "  if a\
    \ == 0 # base case\n    return b\n  return greatest_common_divisor(b, a % b) #\
    \ recursive case\nend\n</code>\nNow we can create a function that counts how many\
    \ times each value occurs in a list. We pass it a hash representing the values\
    \ we want to count, and a function that checks if a value is in a hash using the\
    \ in? method.\n<code>", "  return a / gcd(a, b) unless b == 0\n  greatest_common_divisor(b,\
    \ a % b)\nend", "  return a if b == 0 else greatest_common_divisor(b, a % b)\n\
    end", "  if b == 0 then return a\n  if a % b == 0 then return greatest_common_divisor(b,\
    \ a % b)\n  else\n    return greatest_common_divisor(b, a % b) \n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks so much, this is an elegant solution!\n<|/\
    \ c |>\n<| a dscore=2 |>\nI assume that your problem is with finding the greatest\
    \ common divisor (GCD) of two integers. \nMy first thought is to create a list\
    \ of the numbers from 1 to a billion, then use the fact that GCD(a,b) = a/gcd(a,b)\
    \ if a = b/gcd(a,b).\n<code>", "  return a % b ? greatest_common_divisor(b, a\
    \ % b) : b\nend", "  gcd = 1\n  while b /= a\n    gcd = b\n  end\n  gcd\nend",
  "  return a if b == 0 else greatest_common_divisor(b, a % b)\nend", "  if a == 0\
    \ and b == 0\n    return 0\n  elsif a == 0\n    return b\n  elsif b == 0\n   \
    \ return a\n  else\n    return greatest_common_divisor(a % b, b)\n  end\nend",
  "  return a % b if a && b && a >= b \n  a % b\nend", "  if a < b \n    return greatest_common_divisor(b,\
    \ a)\n  end\n  # Return GCD of a and b\n  x = 1\n  y = 0\n  while a > 0\n    if\
    \ a % 2 == 1\n      x += 1\n    end\n    y += 1\n    a = a / 2\n  end\n  while\
    \ b > 0\n    if b % 2 == 1\n      x += 1\n    end\n    y += 1\n    b = b / 2\n\
    \  end\n  return y if y == x\n  return x\nend", "  return a if b == 0 else b if\
    \ a > b else a\nend\n</cell>\n<cell>", "  return a % b if (b > 0 and a >= b) \n\
    \    else b if a < b\nend", "  if a == 0\n    b\n  elsif b == 0\n    a\n  else\n\
    \    (greatest_common_divisor(b, a % b)) + (a // b)\n  end\nend", "  if b == 0\
    \ then return a\n  if a == 0 then return b\n  return greatest_common_divisor(b,\
    \ a % b)\nend", "  return a / b if (a % b == 0 || b != 0) else\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI don't think that's right. `greatest_common_divisor(10,\
    \ 20)` is `5`, not `2`.\n<|/ c |>\n<| c |>\nYes, you are right, my mistake. Fixed.\n\
    <|/ c |>\n<| c |>\nI still think your solution is incorrect because it doesn't\
    \ handle negative numbers. `greatest_common_divisor(-5, -5)` returns -5, instead\
    \ of -2.\n<|/ c |>\n<| c |>\nFixed, thanks.\n<|/ c |>\n<| c |>\nYour original\
    \ solution was also wrong, now fixed. Sorry for the inconvenience.\n<|/ c |>\n\
    <| a tags=ruby |>\nIf you want a pure Ruby solution, this one should do the trick:\n\
    <code>", "  while b % a == 0\n    b = b / a\n  end\n  return b\nend", "  while(\
    \ a != 0 )\n    a, b = b % a, a\n  end", "  return a if b == 0 else greatest_common_divisor(b,\
    \ a % b)\nend\n</code>\n<|/ a |>\n<| a tags=ruby,algorithm |>\n<code>", "    if\
    \ a == 0\n        return b\n    return greatest_common_divisor(b, a % b)\nend",
  "  while a && b && a.to_i <= b.to_i\n    a -= b.to_i\n    b -= 1\n  end\n  a\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for the solution. My task is different\
    \ than this one. I just want to return the greatest common divisor of two numbers\
    \ x and y. And I have to use recursive functions.\n<|/ c |>\n<| c |>\nI don't\
    \ understand why a recursive function would be better.  Can you give some examples?\n\
    <|/ c |>\n<| c |>\nI have added a code snippet for you. This is a recursive function.\n\
    <|/ c |>\n<| c |>\nYes your code is great! I got it.\n<|/ c |>\n<| c |>\nThe task\
    \ is to find the greatest common divisor of x and y.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nI believe the solution provided by is pretty good, but I wanted to offer\
    \ another one. It might seem overly simple, but it should provide some additional\
    \ insight.\nFor each integer in the range from 0 to (2^k - 1) inclusive, find\
    \ the common factors, and then add them together to find the greatest common divisor\
    \ of the two numbers:\n<code>", "  return a if a.zero? || b.zero? || (a.one? &&\
    \ b.one?) || (a.one? && !b.one?) || (b.one? && !a.one?) ? 1 : b % a\nend", " \
    \ while b > 0\n    a, b = b, a % b\n  end\n  a\nend\n</code>\nHere's a much faster\
    \ solution:\n<code>", "  if a == 0\n    return b\n  else\n    greatest_common_divisor\
    \ b, a % b\n  end\nend\n</code>\n<|/ a dscore=2 tags=ruby |>\n<| c |>\nGreat solution!\
    \ And it also works with negative numbers (although it's not the best option)\n\
    <|/ c |>\n<| a tags=ruby |>\nThe only way to get the greatest common divisor of\
    \ two numbers is to find the GCD for one number and then divide by the other number.\
    \ Here's a solution:\n<code>", "  if b == 0\n    a\n  else\n    greatest_common_divisor(b,\
    \ (a%b)+b)\n  end\nend", "  return a if b == 0 or a == b\n  b = b if b > a else\
    \ b - a\n  while a != 0\n    b = a % b\n    a = b\n  end\n  return b\nend\n</code>\n\
    <|/ a |>\n<| c |>\nYour `greatest_common_divisor` function is wrong for negative\
    \ numbers. [Wikipedia has a better example](https://en.wikipedia.org/wiki/Euclidean_algorithm#Algorithm_to_compute_GCD_of_two_integer_numbers).\n\
    <|/ c |>\n<| c |>\nYes, `greatest_common_divisor` is incorrect for negative numbers.\
    \ I fixed it in my answer.\n<|/ c |>\n<| c |>\nI fixed `greatest_common_divisor`\
    \ to also accept negative numbers (and only positive numbers). Now it should be\
    \ correct. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=3 |>\nA more elegant\
    \ solution would be to define a new method:\n<code>", "  if b == 0 \n    return\
    \ a\n  return greatest_common_divisor(b, a % b) # Recursive call\nend", "  return\
    \ 0 if (a == 0 and b == 0) or (b == 0 and a != 0) else (1..b).inject(:*)\nend",
  "    return a if (a > b) else b\nend", "  return a / b if (a % b) == 0 else\n  \
    \       greatest_common_divisor(b, a % b)\nend", "    gcd = a\n    while b > 0\n\
    \        gcd = b if gcd % b == 0 else gcd % b\n        b = a % b\n        a =\
    \ gcd\n    end\n    return gcd\nend", "  return a if b == 0 else greatest_common_divisor\
    \ b a\nend", '  return a % b if a and b % a == 0 else b', "    i = a\n    j =\
    \ b\n    while i < 0 or j > 0:\n        if (i != 0) and (j != 0):\n          \
    \  if (i % j == 0):\n                return i\n        i += 1\n        j -= 1\n\
    \    return -1", "  a = [a]\n  b = [b]\n  while b != [0]\n    a.pop\n    b.pop\n\
    \    i = 0\n    j = 0\n    while i < a.length && j < b.length\n      j = (j +\
    \ 1) % b.length\n      a[i] = (a[i] * b[j]) % modulus\n      i += (j + 1) % a.length\n\
    \    end\n  end\n  a.reverse\n  a[0]\nend", "    while(b != 0)\n        a, b =\
    \ b, a % b\n    end\n    return a\nend", "  return a if b == 0 or a == b else\
    \ greatest_common_divisor(b % a, a)\nend", "  return a if b == 0 then 1 else gcd(b,\
    \ a%b)\nend\n</code>\nThe function returns a and b divided by greatest_common_divisor:\n\
    <code>\n> a, b, c =\n>   7, 8, 9\n>  \n> a, b, c = greatest_common_divisor(a..b+1,\
    \ c..d+1)\n> \n> a\n8\n> b\n7\n> c\n9\n</code>\nThe function returns an Array:\n\
    <code>\n> greatest_common_divisor(a..b+1, c..d+1)\n=> [8,7,9]\n</code>\nThe last\
    \ line is equivalent to:\n<code>\n> [8,7,9].grep( &:even? )\n=> [7,9]\n</code>\n\
    To be honest, the code above is much more complex than the code in the linked\
    \ question, although the linked question does demonstrate how to achieve this.\n\
    <|/ a dscore=3 |>\n<| a |>\nHere is another solution that is not based on recursion:\n\
    <code>\nfunction max_of_two(left, right)\n  if left == 0\n    return right\n \
    \ else\n    mid = (left + right) / 2\n    if right - left < 1\n      return mid\n\
    \    else\n      return max_of_two(left, mid) if max_of_two(mid + 1, right) >\
    \ mid\n    end\n  end\nend\n</code>\n<|/ a tags=math,algorithm,ruby dscore=2 |>\n\
    <| c |>\nThis is really the simplest solution that I found, although I wish it\
    \ wasn't recursive and was more efficient. Also, it would be nice if the result\
    \ was a tuple of two elements.\n<|/ c |>\n<| a tags=math,algorithm,ruby |>\n<code>",
  "    divisors = []\n    while a > 0\n      divisor = a\n      a /= b\n      b /=\
    \ divisor\n      divisors << divisor\n    end\n    divisors.reverse!\n    divisors.last\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou don't need to convert them to strings\
    \ before passing them as arguments, or to split them at all: `GCD(a,b)` will work\
    \ just fine.\n<|/ c |>\n<| a dscore=1 |>\nYou can use the GCD function in Ruby\
    \ which is available in many languages and libraries.\n<code>", "  if a == 0 or\
    \ a == 1\n    return b\n  end\n  return greatest_common_divisor(b, a % b) if b\n\
    end", "  while a >= b\n    a = a % b\n  end\n  a\nend", "    divisors = []\n \
    \   while (a != 0) and (a != b) do\n        a = a % b\n        divisors.push(a)\
    \ \n    end\n    return divisors[divisors.length - 1]\nend", "  if a == 0 and\
    \ b == 0\n    return 1\n  div = 1\n  while b > 0\n    a, b = b, a % b\n    div\
    \ += 1\n  end\n  return div\nend\n</cell>\n<code language=julia-0.6>", "  if a\
    \ > b\n    a - b\n  else\n    b - a\n  end\nend", "  div = a % b\n  return div\
    \ if div != 0 \n  ", "    if b == 0\n        1\n    else\n        greatest_common_divisor(b,\
    \ a % b)\n    end\nend", "  GCD = a * b\n  [a, b, GCD] = [b % GCD, GCD % b, GCD]\n\
    \  GCD\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nthanks for your reply, but I\
    \ don't want to do it in ruby, i want to do it in java or python\n<|/ c |>\n<|\
    \ c |>\nPlease have a look at the updated answer then.\n<|/ c |>\n<| c |>\nThanks,\
    \ i will test it\n<|/ c |>\n<| c |>\nGreat! If it works, please accept the answer\
    \ :)\n<|/ c |>\n<| c |>\nSure, Thank you very much\n<|/ c |>\n<| a tags=math,algorithm,java\
    \ |>\nThe most straightforward solution to this problem would be to write a recursive\
    \ function, using only addition and subtraction.\n<code>\nint gcd(int a, int b)\
    \ {\n    return a == 0 ? b : gcd(b % a, a)\n}\n</code>\nA more efficient approach\
    \ would work like this\n<code>\nint gcd(int a, int b) {\n    while (a != 0) {\n\
    \        int temp = a;\n        a = b - (temp % b);\n        b = temp;\n    }\n\
    \    return b;\n}\n</code>\nThis method has a time complexity of O(log(n)) and\
    \ uses only addition and subtraction.\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,java\
    \ |>\nA very simple solution is given below.\n<code>\npublic int gcd(int a, int\
    \ b) {\n    int r = a % b;\n    if (r > 0) {\n        return r + gcd(b, r);\n\
    \    } else {\n        return b;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=math,algorithm,java\
    \ |>\n<code>\npublic class GreatestCommonDivisor {", "  return a if b == 0 then\
    \ 0 else greatest_common_divisor(b, a % b)\nend\n</cell>\n<cell>", "  # Return\
    \ 1 if a = 0 & b = 0\n  raise \"Error: No greatest common divisor for a and b\"\
    \ if (a == 0 && b == 0)\n  # Return b divides a if a > b\n  if (a > b)\n    raise\
    \ \"Error: No greatest common divisor for a and b\" if (a == 0)\n    # Return\
    \ b divides a if a < b\n    greatest_common_divisor(b, a)\n  # Return a\n  raise\
    \ \"Error: No greatest common divisor for a and b\" if (b == 0)\n  # Return a\n\
    \  raise \"Error: No greatest common divisor for a and b\" if (a == 0)\n  # Return\
    \ b divides a if a < b\n  greatest_common_divisor(a, b)\nend", "  if a == 0\n\
    \    b\n  else\n    greatest_common_divisor(a - b, b)\n  end\nend", "    if a\
    \ == 0\n        return b\n    return greatest_common_divisor(b, a % b)\nend",
  "  return a if b == 0 or a == b else\n    greatest_common_divisor(b, a % b)\nend",
  "    return 0 if a == 0 else gcd_mod(a, b)\nend\n</cell>\n<code language=julia-0.5>",
  "  if b == 0 \n    1\n  else\n    greatest_common_divisor(b, a%b)\n  end\nend",
  "  if b == 0 \n    return a\n  else \n    return greatest_common_divisor(b, a %\
    \ b)\nend", "  return a if b == 0 else greatest_common_divisor(b, a % b)\nend\n\
    </code>\nNow we are ready to write our own method that does what we want. Here\
    \ we take the arguments and determine which one is greatest and which one is least\
    \ and call our greatest_common_divisor method to find which one is the greatest.\
    \ From here we simply determine which side of the line the curve is on by comparing\
    \ our value to the left of the curve. \n<code>", "  if a == 0 and b == 0\n  then\n\
    \    return a\n  else\n    greatest_common_divisor(b, a % b)\n  end\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\nYou can try this also.\n<code>", "  return a if (b\
    \ == 0) then a else greatest_common_divisor(b, a % b)\nend", "  return a if b\
    \ == 0 else greatest_common_divisor b % a\nend\n</cell>\n<cell>", "  div = a %\
    \ b\n  return div if div != 0 && a.to_i == b.to_i && div < b else a.gcd(b)\nend",
  "  # Write your code here\n  return 0 # <---\nend", "  return a if (b == 0) then\
    \ a else greatest_common_divisor(b, a % b)\nend\n</code>\nUsing greatest_common_divisor\
    \ to find the greatest common divisor of the two numbers you provided.\n<code>\n\
    greatest_common_divisor(9, 9)", "  return a if (b == 0) then nil\n    else greatest_common_divisor(b,\
    \ a % b)\n  end\nend\n</code>\nNow we can implement the function\n<code>", " \
    \ return a if (b == 0) then 1 else a % b\nend", "    factors = []\n    factor\
    \ = 1\n    while (a != 0 and b != 0):\n        if (a % b == 0):\n            factors.append(factor)\n\
    \            factor = 1\n        else:\n            factor *= a\n            factor\
    \ *= b\n    return factors[-1]\n</cell>\n<cell>", "    if b == 0\n        1\n\
    \    else\n        greatest_common_divisor(b, a % b)\n    end\nend\n</code>\n\
    The next step is to use recursive call and apply the above function to each and\
    \ every number you encounter as such\n<code>", "    if b == 0\n        return\
    \ a\n    else\n        return greatest_common_divisor(b, a%b)\n    end\nend",
  "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend", "  return a - (b / a)\n\
    end", "  return 0 if (b == 0) || (a == 0)\n  r = 1\n  while ((a != 0) && (b !=\
    \ 0))\n    r =(a%b) if (r < a) else (r, b)\n    a /= b\n    b /= r\n  r\nend",
  "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend", "    (a*b)%1 == 0\nend\n\
    </code>\nWe can use this to print out an entire list of prime numbers:\n<code>",
  "  if a==b\n    return a\n  while b!=0 and a%b==0\n    return b\n  return a\nend\n\
    </code>\n<|/ a |>\n<| c |>\nWhile this code snippet may solve the question, [including\
    \ an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, as this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| c |>\nThis answer was flagged as low-quality because\
    \ it is so short - but it is also a comment, not an answer. Once you have sufficient\
    \ [reputation](http://stackoverflow.com/help/whats-reputation) you will be able\
    \ to [comment on any post](http://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](http://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/16547990)\n<|/ c |>\n<| c |>\nHi Sir.\
    \ I am new to Ruby and I wanted to know how this code works. Can you please explain?\n\
    <|/ c |>\n<| c |>\nwhat is a \"while\" loop? It seems to me like `greatest_common_divisor`\
    \ could be replaced with `return (a==b) ? a : b`, which seems simpler and less\
    \ repetitive.\n<|/ c |>\n<| c |>\nIt's a loop, a while loop will execute the code\
    \ in the body repeatedly until some condition is met.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nFor those who want to get rid of the loop (without break)\n<code>", "  \
    \  (a/b).to_f\nend\n</code>\nNow it works:\n<code>\ngreatest_common_divisor(3,2)",
  "  while b != 0\n    div = a % b\n    a, b = b, div\n  end\n  a\nend", "  return\
    \ a if (a > b) then b else a\nend", "  return BigDecimal(a / b) if a && b && a.abs\
    \ <= b || b.abs <= a || a > b ? a : b\nend", "  if a == 0\n    b\n  elsif b ==\
    \ 0\n    a\n  else\n    greatest_common_divisor(b, a % b)\n  end\nend", "  if\
    \ b == 0\n    a\n  else\n    greatest_common_divisor(b, a % b)\n  end\nend", " \
    \ if a == 0\n    return b\n  if b == 0\n    return a\n  if a > b\n    return greatest_common_divisor(b,\
    \ a % b)\n  return greatest_common_divisor(a % b, b)\nend", "  while b\n    while\
    \ a\n      while b and (a % b == 0)\n        b = b - 1\n      end\n      a = a\
    \ - 1\n    end\n    b = b - 1\n  end\n  a\nend", "  return a if b == 0 else greatest_common_divisor(b,\
    \ a % b)\nend", "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend", "  return\
    \ a if b == 0 else greatest_common_divisor(b, a % b)\nend\n</code>\n<|/ a |>\n\
    <| c |>\nYour answer does not include an explanation.\n<|/ c |>\n<| c |>\nI wanted\
    \ to tell OP how to calculate the GCD of numbers in Ruby\n<|/ c |>\n<| c |>\n\
    The OP asked how to use recursion to calculate the GCD of 2 numbers. The GCD is\
    \ always the highest number `a` divided by `b` that is less than `a`. That is\
    \ how I read your answer but maybe I'm wrong.\n<|/ c |>\n<| a dscore=5 |>\nUsing\
    \ recursion:\n<code>", "  d = a % b\n  return b if d == 0\n  greatest_common_divisor(b,\
    \ d)\nend\n</code>\nHere are a few examples of the output when called with greatest_common_divisor(12,\
    \ 8) and greatest_common_divisor(6, 7):\n<code>\n> greatest_common_divisor(12,\
    \ 8)\n=> 8\n> greatest_common_divisor(6, 7)\n=> 7\n> greatest_common_divisor(15,\
    \ 10)\n=> 15\n</code>\nSo now that we know what our recursive function does, we\
    \ can implement the GCD function ourselves:\n<code>", "    if a < b\n        (a,\
    \ b) = (b, a)\n    end\n    \n    common = (a % b)\n    \n    while a != 0 and\
    \ b != 0 and common != 0\n        (a, b) = (b, a % b)\n        common = (common\
    \ % b)\n    end\n    \n    common\nend", "  while b > 0\n    a, b = b, a % b\n\
    \  end\n  a\nend\n</code>\nNow, we can find the greatest common divisor of 8 and\
    \ 16 as follows\n<code>\ngreatest_common_divisor(8, 16)", "    if b==0 then return\
    \ a\n    else return greatest_common_divisor(b, a % b)\nend", "  return a if a.zero?\
    \ || b == 0 || (a.nonzero? && b != 0) || (b.nonzero? && a.nonzero? && b != 0)\
    \ || (a.nonzero? && !b.nonzero? && a.odd? && b.even?) || (b.nonzero? && !a.nonzero?\
    \ && b.odd? && a.even?) || (a.odd? && b.odd? && a.even? && !b.even?) || (a.even?\
    \ && b.even? && !a.odd? && b.odd?) else\n  \n  # Calculate a's greatest common\
    \ divisor with b\n  a = a % b\n  while a.nonzero? && b % a == 0\n    a = a % b\n\
    \  end\n  \n  a\nend", "  return b if b == 0 else a % b\nend", "  if a > b\n \
    \   a, b = [b, a]\n  a = a.to_i\n  b = b.to_i\n  return a / b if a % b == 0\n\
    \  greatest_common_divisor(b, a%b)\nend\n</code>\n<|/ a |>\n<| c |>\nYour code\
    \ doesn't even work under Ruby 2.7. Try `greatest_common_divisor(\"1\",\"3\")`.\n\
    <|/ c |>\n<| c |>\nActually, this works, but it also gives a wrong answer `greatest_common_divisor(\"\
    1\",\"3\")` returns 1, instead of the correct answer of 3\n<|/ c |>\n<| c |>\n\
    Okay I fixed it\n<|/ c |>\n<| c |>\nThis doesn't work. It says 3 is not a symbol\n\
    <|/ c |>\n<| c |>\nOh sorry I accidentally wrote symbols, now I edited it\n<|/\
    \ c |>\n<| a tags=algorithm,ruby,recursion |>\nThis seems to be a perfect opportunity\
    \ to learn a little about tail recursion.\n<code>", "  return (a * b).to_i if\
    \ a.to_i > b.to_i \n  ", "  if a > b\n    b, a = a, b\n  end\n  (1...b).reduce(:*)\n\
    end", "  if b==0\n    a \n  else\n    greatest_common_divisor(b, a % b)\n  end\n\
    end\n</cell>\n<text>\nWrite a recursive function  that takes three integers ($a$,\
    \ $b$, and $c$) and returns their greatest common divisor.", "  if a > b\n   \
    \ a, b = b, a\n  while b % a == 0\n    b = b % a\n  return b\nend\nputs greatest_common_divisor(5,10)\n\
    puts greatest_common_divisor(6,3)", "    return b % a\nend", "    return a if\
    \ b == 0 or a == b else greatest_common_divisor (b , a % b)\nend", "    div, mod\
    \ = divmod(a, b)\n    while mod != 0\n        div, mod = divmod((div + mod), a)\n\
    \    end\n    div\nend", "    divisor = 1\n    while b % a != 0\n        divisor\
    \ = divisor + 1\n        a = a / divisor\n    return divisor\nend\n</code>\nand\
    \ my test file\n<code>", "  b = b % a\n  while b != 0\n    b = b % a\n  end\n\
    \  b\nend\n</code>\n<|/ a |>\n<| c |>\nI guess this won't work when the least\
    \ common factor is greater than the prime factor.\n<|/ c |>\n<| c |>\nThis is\
    \ exactly what I needed.  Thanks very much!\n<|/ c |>\n<| c |>\nThis doesn't work.\
    \ try using greatest_common_divisor(2, 21), which returns 3\n<|/ c |>\n<| c |>\n\
    this doesn't work. try using greatest_common_divisor(12, 21), which returns 11\n\
    <|/ c |>\n<| a dscore=4 |>\nFor a function that finds GCD of two number n1 and\
    \ n2 using Ruby's Bignum library, the code is as follows:\n<code>\nrequire 'bigdecimal'",
  "  return a / gcd(a, b) if (a / gcd(a, b) != b / gcd(a, b))\n  else b\nend", " \
    \ return a % b unless b == 0 or a == 1\n  greatest_common_divisor(b, a % b)\n\
    end\n</cell>\n<code language=julia-1.5>\ngreatest_common_divisor(13, 5)\n</cell>\n\
    <code language=julia-1.5>", "  return b if a % b == 0 else a % b\nend", "  return\
    \ a if (a.zero? || b.zero?) ? a : a == b ? b : greatest_common_divisor(b, a %\
    \ b)\nend\n</code>\nThen you can define GCD on integers:\n<code>\nmodule Integer\n\
    \  def gcd\n    greatest_common_divisor self\n  end\nend\n</code>\nNow that we\
    \ have our GCD function, we can use it!\n<code>\n module Math\n  def gcd\n   \
    \ greatest_common_divisor self\n  end\nend", "    return 0 if a == 0 or b == 0\
    \ else gcd(b, a % b) if a > b else gcd(a, b)\nend\n</code>\nThe function gcd returns\
    \ greatest common divisor of 2 numbers. But we also need to change method greatest_common_divisor\
    \ to use return statements to return greatest common divisor of 2 numbers.\n<|/\
    \ a |>\n<| c |>\nWhat is `gcd` ? It seems undefined for me\n<|/ c |>\n<| c |>\n\
    `gcd` is a function which returns greatest common divisor of two numbers.\n<|/\
    \ c |>\n<| c |>\nI think you meant `greatest_common_divisor` not `gcd`. And what\
    \ is `gcd_2` ?\n<|/ c |>\n<| c |>\nAlso a little bug. The `greatest_common_divisor`\
    \ will return the GCD, but `gcd(a, b)` should just be `b`.\n<|/ c |>\n<| c |>\n\
    Yes I meant `greatest_common_divisor`. `gcd_2` is function which returns greatest\
    \ common divisor of 2 numbers.\n<|/ c |>\n<| a |>\nYou need only two methods.\
    \ One for finding the GCD and one for finding the GCD with modulo:\n<code>", " \
    \   loop do\n        quo = a / b\n        rem = a % b\n        return rem if rem\
    \ == 0\n        a = quo\n    end\nend\n</code>\nWe can then define the next_permutation\
    \ function as follows:\n<code>", "  if a == 0\n    return b\n  return greatest_common_divisor(b\
    \ % a, a)\nend", "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend", "  if\
    \ b == 0 then\n    return a\n  else\n    return greatest_common_divisor(b, a %\
    \ b)\n  end\nend", "  return a if (a <= b) else greatest_common_divisor(b,a)\n\
    end", "  while b > 0\n    a, b = b, a % b\n  end\n  a\nend\n</code>\nThis is more\
    \ efficient than using div (which repeatedly divides your number by 2, until it\
    \ reaches 1).\n<|/ a tags=ruby,math |>\n<| c |>\nI'm pretty sure this will perform\
    \ worse than div and more memory intensive. Also it won't work if a or b is 0.\n\
    <|/ c |>\n<| c |>\nYes, this is what I was looking for. Thanks!\n<|/ c |>\n<|\
    \ c |>\nThis is great, and very useful to know. I really appreciate it\n<|/ c\
    \ |>\n<| a dscore=5 |>\nI figured it out!\n<code>", "  return a if b == 0 or a\
    \ % b == 0 else greatest_common_divisor(b, a % b)\nend", "  return true if a.zero?\
    \ or b.zero?\n  return false if a.zero? and b.zero?\n  a = a.abs\n  b = b.abs\n\
    \  if a == b\n    return a\n  elsif a > b\n    return greatest_common_divisor(b,\
    \ a % b)\n  else\n    return greatest_common_divisor(a, b.mod(a))\n  end\nend",
  "  return a if (b == 0) then nil else greatest_common_divisor(b, a % b)\nend\n</code>\n\
    And we can find the greatest common divisor of any two numbers using this function:\n\
    <code>", "  if a < b\n    return greatest_common_divisor(b, a)\n  \n  c = a\n\
    \  while b != 0\n    if b mod c == 0\n      return c\n    b /= c\n  end\n  return\
    \ a\nend", "  if a == 0 and b == 0\n    return 0\n  if a == 0 or b == 0\n    return\
    \ 1\n  gcd = gcd(a,b)\n  return a/gcd\nend", "    return a if (a == b) then (b)\
    \ else greatest_common_divisor(b, a % b)\nend\n</cell>\n<text>\nExercise 3\nThe\
    \ greatest_common_divisor function can be extended to work with rational numbers.\
    \ The function should take a rational number $a$ and $b$ and return the greatest\
    \ common denominator of the two integers $a$ and $b$. Here is an example with\
    \ a and b set to 8:", "  \n  # If a and b are equal, return b\n  return b if a\
    \ == b then return b\n  \n  # If b is zero, return a a\n  return a if a == 0 then\
    \ return a else a * (b % a)\nend", '    return b if (not a) ', "  return a if\
    \ (b == 0) \n  return greatest_common_divisor(b, a % b) \nend", "  return a if\
    \ b == 0 else greatest_common_divisor(b, a % b)\nend", "  # Make sure a and b\
    \ are positive integers\n  a = a.to_i\n  b = b.to_i", "  while a && b\n    a,\
    \ b = b, a % b\n  end\n  a\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nCan you please explain the usage of `greatest_common_divisor` method?\
    \ why `greatest_common_divisor(6, 9)` and `greatest_common_divisor(9, 6)` will\
    \ give `6`? Thanks!\n<|/ c |>\n<| c |>\nThey both return `9`, but `6` is evenly\
    \ divisible by `9`.\n<|/ c |>\n<| c |>\nThanks! The `greatest_common_divisor`\
    \ method was very helpful! I used your solution to fix an issue I was having with\
    \ `greatest_common_divisor`. Thanks again!\n<|/ c |>\n<| a dscore=0 |>\nHere is\
    \ a recursive solution.\n<code>", "    a, b = abs(a), abs(b)\n    while a != 0\n\
    \        if b == 0 then\n            return 0\n        b /= a\n    end\n    return\
    \ a\nend", "  i = b\n  while i > 0 && a%i == 0\n    i -= 1\n  end\n  i\nend",
  "  return a if (b == 0) then b else greatest_common_divisor_aux(a, b, a % b)\nend",
  "  return a if b == 0 else greatest_common_divisor(b, a % b)\nend\n</cell>\n<code\
    \ language=julia-1.5>", "  if a < b\n    (a, b) = [b, a]\n  end\n  divisor = GCD(a,\
    \ b)\n  (a / divisor) * divisor\nend", "    return b if b == a else greatest_common_divisor(b,\
    \ a % b)\nend", "    return b if b == 0 else greatest_common_divisor_iter(a,b-1)\n\
    end", "    a, b = a % b, b % a\n    while a != 0 and b != 0:\n        a, b = b,\
    \ (a % b) \n    return a if a != 0 else None\n</cell>\n<text>\nWrite a function\
    \ that returns the product of the two integers passed as arguments. Make sure\
    \ to handle errors and edge cases.", "    return a - (b * a.quo(gcd(a, b)))\n\
    end", "    return a if (b == 0) else greatest_common_divisor(b, a % b)\nend",
  "  return 0 if b == 0 else (a % b) + 1\nend", "  return a if b == 0 else greatest_common_divisor(b,\
    \ a % b)\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThat function takes more than\
    \ a second to complete...\n<|/ c |>\n<| c |>\nI agree with you, but a faster way\
    \ would be to cache the results, so you only need to call this once.\n<|/ c |>\n\
    <| c |>\nYes, this would work. Depending on your use-case this may be better than\
    \ having to calculate it each time you call the function.\n<|/ c |>\n<| c |>\n\
    This was the fastest I could get on my machine (running Ruby 2.5.2 on a MacBook\
    \ Pro, with 8 GB RAM)\n<|/ c |>\n<| c |>\nThanks for sharing. As this code is\
    \ actually working for me (comparing the timings with `GCD`), I have submitted\
    \ a pull request to [Github](https://github.com/benvanik/ruby-gcd/pull/19), including\
    \ a benchmark test which I added after the original pull request.\n<|/ c |>\n\
    <| a tags=ruby,integer-division,modulo,algorithm |>\nI noticed that a lot of answers\
    \ use the recursive approach but this is slow because Ruby doesn't do tail-recursion\
    \ (it's an interpreter thing).\nThe GCD algorithm is faster but it's slow because\
    \ it's an iterative algorithm.\nSo here's a recursive implementation in Ruby.\n\
    <code>", "  return a % b if (a % b).zero?\n  greatest_common_divisor(b, a % b)\n\
    end", "  if b == 0 then\n    return a\n  else\n    greatest_common_divisor(greatest_common_divisor(a,b-1),b)\n\
    \  end\nend\n</code>\n<|/ a tags=lua,loops,nested-loops,lua-table,iteration dscore=2\
    \ |>\n<| c |>\nYour method fails for large numbers. You need to modify it to use\
    \ division instead of recursion.\n<|/ c |>\n<| c |>\n: It uses only division for\
    \ `a` when `b` is 1.\n<|/ c |>\n<| c |>\nI missed that completely. Sorry.\n<|/\
    \ c |>\n<| c |>\n: No need to apologize if you had missed it. The recursive solutions\
    \ work (as they should) but require too much time for large numbers. The iterative\
    \ solution should (nearly) always be a bit faster. I'll see if I can optimize\
    \ it more.\n<|/ c |>\n<| a |>\nI took the liberty of creating a module for you:\n\
    <code>\nfunction math.gcd(a,b)\n    if b==0 then return a\n    else return gcd(b,a%b)\
    \ end\nend\n</code>\nAnd here are the benchmarks for a few of the solutions presented\
    \ so far (all using math):\n<code>\n-- My version:\nlocal function gcd(a,b)\n\
    \  if b==0 then return a\n  else return gcd(b,a%b) end\nend", "  lcm = (a * b)\
    \ / greatest(a, b)\n  raise ArgumentError if lcm == 0 # raise error if gcd ==\
    \ 0\n  gcd = b / lcm\n  return gcd # return gcd, i.e. greatest\nend", "    return\
    \ b if b == 0 else greatest_common_divisor(b, a % b)\nend", '    return a if (b
    % a == 0) else b', "  while b\n    (a % b) == 0 ? return b : (b,a % b)\n  end\n\
    \  return a\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nIt's not really \"easier\"\
    , it's just \"more correct\", so I'd say it's more correct. Just for the record,\
    \ your implementation will always return *b* for any values *a > b*.\n<|/ c |>\n\
    <| c |>\n`greatest_common_divisor` is not a great function in general. For example,\
    \ `greatest_common_divisor(103, 97)` returns `97` instead of `3`. Also, it's very\
    \ inefficient in that it loops over each of the numbers *a* and *b* multiple times.\
    \ For example, `greatest_common_divisor(103, 97)` loops over `97` two times (once\
    \ to determine if it's the greatest common divisor, once to determine if *a* divides\
    \ *b*).\n<|/ c |>\n<| c |>\n: Indeed, I agree. Just wanted to demonstrate that\
    \ there is a well-defined way to do it, which can be done with one single loop.\
    \ By the way, `greatest_common_divisor` is wrong: it will return `b` for any pair\
    \ (a,b) where b > a.\n<|/ c |>\n<| c |>\n: But it works perfectly well for the\
    \ problem as given, so I didn't add any unnecessary complexity.\n<|/ c |>\n<|\
    \ c |>\n: Well, I agree with you. I edited my answer accordingly.\n<|/ c |>\n\
    <| a dscore=1 tags=ruby |>\nHere's a quick and dirty way to do it using recursion\
    \ and a ternary operator:\n<code>", "  while b\n    if a % b == 0\n      a\n \
    \   else\n      b = b % a\n    end\n  end\nend", "  a = a.to_i\n  b = b.to_i\n\
    \  return a.gcd(b).to_i\nend\n</code>\nThen you can do\n<code>", "  raise \"This\
    \ algorithm is too slow for large numbers\"\nend\n</code>\nThere are more efficient\
    \ ways to implement this algorithm, but this should suffice for you to solve the\
    \ problem in the simplest way possible.\n<|/ a dscore=0 |>\n<| c |>\nIt sounds\
    \ like he's trying to solve a problem for which `divmod` is a solution. I agree\
    \ that this can be done efficiently with `divmod`, but it isn't what was asked\
    \ for.\n<|/ c |>\n<| c |>\nThe question did not specify that the algorithm needed\
    \ to be used on a big number. On a big number, `divmod` would have to do all the\
    \ computations needed, so this would be an efficient solution. It could also be\
    \ modified to work with integers by just making it work with an array of integers,\
    \ rather than a single integer.\n<|/ c |>\n<| c |>\n`divmod` works on bignums\
    \ just fine. I think you should re-read the question.\n<|/ c |>\n<| c |>\nI read\
    \ the question, I don't see anything that suggests otherwise. Also, you're wrong\
    \ about the time complexity here. It does use only integer arithmetic, no bignums.\
    \ You can find [an implementation in OCaml](https://github.com/lewisliff/ocaml-bignum/blob/master/lib/bignum.ml#L38).\n\
    <|/ c |>\n<| c |>\nYour answer only works on integers.  Your test case is completely\
    \ different.  It works at all, no matter how big or small your numbers are or\
    \ what they represent.  Please read [this answer](http://stackoverflow.com/questions/18546342/is-there-an-efficient-way-to-check-for-the-greatest-common-divisor-of-two-numbers/18547040#18547040).\n\
    <|/ c |>\n<| a tags=math,algorithm,ruby,division |>\nYou want to find GCD of integer\
    \ numbers.\nUse following function", "  return a if (b % a == 0)\n  return greatest_common_divisor(b\
    \ % a, a)\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,primes |>\nThe prime\
    \ sieve method does not work if you have a number that is bigger than the max\
    \ value that an integer can hold. \nAs you can see in line 4 you set max = 10000000\
    \ - 1 but in line 15 you try to find all primes between 2 and max which is not\
    \ possible since the max value can not be a integer bigger than the max value\
    \ an interger can hold.\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nHere's another way\
    \ with one pass:\n<code>", "  if a < b\n    (a, b) = (b, a)  # a will always be\
    \ lesser than b\n  end\n  for i in 0...b\n    if a % i == 0\n      return i\n\
    \    end\n  end\n  return b\nend\n</code>\n<|/ a |>\n<| c |>\nThis fails if you\
    \ call it with 2 as an argument. Try it with greatest_common_divisor(6, 2)\n<|/\
    \ c |>\n<| c |>\nYour algorithm is still wrong. Try `greatest_common_divisor(6,\
    \ 2)`\n<|/ c |>\n<| c |>\nI thought you were supposed to pass in two arguments.\
    \ I edited my answer to take that into account.\n<|/ c |>\n<| c |>\nYes, I meant\
    \ that you just pass one argument to the `greatest_common_divisor` method. You\
    \ can't call `greatest_common_divisor(6, 2)` because `greatest_common_divisor`\
    \ requires two arguments.\n<|/ c |>\n<| c |>\nI think you missed the point. I\
    \ wasn't saying that `greatest_common_divisor` should take two arguments. I was\
    \ just giving a simple example of `greatest_common_divisor` to illustrate how\
    \ it works. Of course, `greatest_common_divisor` would also have to be modified\
    \ to support one argument being passed in, if that is what you meant.\n<|/ c |>\n\
    <| a |>\nA bit late but might be helpful for others.\nThe idea is to go through\
    \ the list of divisors starting with the smallest ones and working up to the biggest\
    \ ones. So if you have the numbers 2 and 6 you start with 2 and go up until you\
    \ get to 6. The number 6 is in the list so you output 6. On the other hand, the\
    \ number 2 is not in the list so you output 2. \nThen you go back to the list\
    \ and start from 2 and work down to the biggest number.\n<code>", "  while b >\
    \ 0\n    a, b = b, a % b\n  end\n  a\nend", "  r = a % b\n  if r == 0 then b else\
    \ r\nend\n</code>\nThe function greatest_common_divisor will return the greatest\
    \ common divisor of a and b. If both a and b are equal, it will return b.\nTo\
    \ compute the GCD, you need a function called gcd, which is given as below:\n\
    <code>", "    return a if b == 0 else greatest_common_divisor(b, a % b)\nend\n\
    </code>\nThe above function returns the GCD (Greatest Common Divisor) of a and\
    \ b.\n<code>", "  while b > 0\n    a, b = b, a % b\n  end\n  a\nend\n</code>\n\
    <|/ a tags=ruby,algorithm,math dscore=1 |>\n<| c |>\nI'm very new to ruby, but\
    \ could you expand on the second solution?  I understand that greatest common\
    \ divisor is a recursive function, but how does it know which of the two values\
    \ is the smaller of the two?  Is it because a is the smaller number?  Or am I\
    \ misunderstanding some of this?\n<|/ c |>\n<| c |>\nthe second solution is simply\
    \ a Ruby implementation of Euclid's algorithm.\n<|/ c |>\n<| c |>\nThanks for\
    \ your help.  I think I understand what you are doing in the second solution,\
    \ just not quite how it works.  For the first solution, I don't think you are\
    \ understanding what I'm looking for exactly, which is basically determining which\
    \ of the two numbers is the smaller of the two.  For example, if the first integer\
    \ is 20 and the second is 15, it would be 20 - 15 = 5.  But what you are doing\
    \ is basically finding the first common factor of the two numbers.  In this case,\
    \ that would be 5.  So in this case I would think 20 % 5 = 0.  But how does this\
    \ work out?  I guess it's really a math question, sorry.\n<|/ c |>\n<| c |>\n\
    Oh I see.  I misunderstood.  So the idea is the second integer is divided by the\
    \ first integer, until the second integer is less than one, then that is the common\
    \ factor.\n<|/ c |>\n<| c |>\nI modified your algorithm to return the gcd instead\
    \ of the greatest common divisor.  I got it to work but it is pretty slow.  I'm\
    \ guessing you were right to think I was trying to do the wrong thing.  Thanks\
    \ for the help.\n<|/ c |>\n<| a tags=ruby,algorithm,math dscore=0 |>\n<code>",
  "  while b != 0\n    a, b = b, a % b\n  end\n  a\nend\n</cell>\n<cell>", "  return\
    \ if b <=> 0\n  (a <=> 0) == 0 ? a : greatest_common_divisor(b, a % b)\nend",
  "  while b > 0\n    a, b = b, a % b\n  end\n  a\nend", "  return 0 if b == 0 else\
    \ if a<b then greatest_common_divisor(b, a%b) else a\nend", "  return 0 if b ==\
    \ 0 else (a // b) if (a % b) == 0 else greatest_common_divisor(b, a % b)\nend",
  "    return gcd(a, b) if a != 0 & b != 0 & a != b # Return Greatest Common Divisor\
    \ of a and b\nend", "  # Compute the GCD using the Euclidian Algorithm\n  # https://rosettacode.org/wiki/Euclidean_algorithm\n\
    \  while a != 0 and b != 0\n    q, r = a / b, a % b\n    a, b = b, q\n  end\n\
    \  return a\nend", "  return a if b == 0 else greatest_common_divisor(b, a % b)\n\
    end", "  while a > 0 && b > 0\n    if a > b\n      a -= b\n    else\n      b -=\
    \ a\n    end\n  end\n  a\nend", "  if a == 0 || b == 0\n    return 0\n  c = greatest_common_divisor(b\
    \ % a, a)\n  if c == 0 \n    return b\n  else \n    return c\nend", "  while b\
    \ !~ 0\n    a, b = b, a % b\n  end\n  a\nend", "  return if a.zero? || b.zero?\n\
    \  r = a % b\n  return a if r == 0\n  greatest_common_divisor(b, r).ceil\nend\n\
    </code>\n<|/ a tags=integer-division,ruby,modulus,division |>\n<| a dscore=2 |>\n\
    <code>", "  div = a % b\n  while div != 0\n    a, b = b, a % b\n    div = a %\
    \ b\n  end\n  a\nend", "  if a == 0 || b == 0 then return a\n  return greatest_common_divisor(a\
    \ % b, a) or greatest_common_divisor(b, a % b)\nend", "  if a < b\n    a,b = b,a\n\
    \  end\n  while a % b != 0\n    a,b = b,a % b\n  end\n  a\nend", "  # TODO: Return\
    \ the greatest common divisor of the integers a and b\n  # a = a.to_i\n  # b =\
    \ b.to_i\n  while a != 0\n    a, b = b, (a % b)\n  end\n  a\nend", "  return b\
    \ if (a == 0 || b == 0) ? a : greatest_common_divisor (b % a, a)\nend\nputs \"\
    GCD(8, 12) = #{greatest_common_divisor(8, 12)}\"\nputs \"GCD(20, 8) = #{greatest_common_divisor(20,\
    \ 8)}\"\nputs \"GCD(20, 12) = #{greatest_common_divisor(20, 12)}\"\nputs \"GCD(20,\
    \ 18) = #{greatest_common_divisor(20, 18)}\"\nputs \"GCD(100, 200) = #{greatest_common_divisor(100,\
    \ 200)}\"\nputs \"GCD(10, 12) = #{greatest_common_divisor(10, 12)}\"\nputs \"\
    GCD(8, 8) = #{greatest_common_divisor(8, 8)}\"\nputs \"GCD(5, 5) = #{greatest_common_divisor(5,\
    \ 5)}\"\nputs \"GCD(0, 5) = #{greatest_common_divisor(0, 5)}\"\nputs \"GCD(-5,\
    \ 5) = #{greatest_common_divisor(-5, 5)}\"\nputs \"GCD(-10, 12) = #{greatest_common_divisor(-10,\
    \ 12)}\"\nputs \"GCD(-200, 200) = #{greatest_common_divisor(-200, 200)}\"\nputs\
    \ \"GCD(-3, -2) = #{greatest_common_divisor(-3, -2)}\"\nputs \"GCD(-200, 200)\
    \ = #{greatest_common_divisor(-200, 200)}\"\nputs \"GCD(-3, -2) = #{greatest_common_divisor(-3,\
    \ -2)}\"", "    return a % b\nend", "    return a % b if b && b % a else 0\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
