name: HumanEval_27_flip_case
language: rb
prompt: "# For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\ndef flip_case(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_flip_case\n\
  \    candidate = method(:flip_case)\n    assert_equal(\"\", candidate.call(\"\"\
  ))\n    assert_equal(\"hELLO!\", candidate.call(\"Hello!\"))\n    assert_equal(\"\
  tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", candidate.call(\"These violent delights\
  \ have violent ends\"))\n  end\nend\n"
completions: ["  string.downcase.gsub!(/[a-z](?![a-z])/, '\\U\\1')\n  string.upcase.gsub!(/[A-Z](?![A-Z])/,\
    \ '\\l')\n  string\nend", "  string.gsub(/./) do |letter|\n    letter.upcase ==\
    \ letter ? letter.downcase : letter\n  end\nend", "  string.downcase!\n  string.upcase!\n\
    end", "  string.gsub(/./, :upcase).gsub(/./, :downcase)\nend\n</code>\nand call\
    \ it like:\n<code>\n\"My Name Is JonDoe\".downcase.gsub(\".\", :flipcase)\n</code>\n\
    <|/ a dscore=1 tags=ruby,regex |>\n<| c |>\nYeah I was trying to avoid the flipcase\
    \ method, but I guess I can't.\n<|/ c |>\n<| c |>\nWhy can't you \"avoid\" `flipcase`?\n\
    <|/ c |>\n<| c |>\nWell I think I may have my answer. I was trying to avoid having\
    \ to write the flipping method every time I wanted to flip lowercase characters\
    \ to uppercase. Instead, I'll make an instance method on String.\n<|/ c |>\n<|\
    \ a tags=ruby,regex |>\nYou can do this with a regex like so:\n<code>", "  string.downcase!\n\
    \  string.upcase!\n  string\nend\n</cell>\n<cell>\nflip_case('apple')\n</cell>\n\
    <cell>\nflip_case(\"Sweet 'n' smooth!\")\n</cell>\n<cell>\nflip_case(\"The sky\
    \ is blue and snow.\")\n</cell>\n<cell>\nflip_case(\"The sky is blue. Nobody cares.\"\
    )\n</cell>\n<cell>\nflip_case(\"apple and banana\")\n</cell>\n<cell>\nflip_case(\"\
    apple and banana, peach\")\n</cell>\n<cell>\nflip_case(\"apple and banana, peach\
    \ and strawberry\")\n</cell>\n<cell>", "  string.downcase!\n  string.upcase!\n\
    end", "  result = string.downcase\n  string.upcase!\n  result\nend\n</code>\n\
    This way, we avoid the need to perform the downcase and upcase operations multiple\
    \ times in the loop. Now let's refactor the main method and add the changes we\
    \ made in flip_case:\n<code>", "  string.downcase!\n  string.upcase!\nend", " \
    \ string.gsub(/([a-z]+)/){|i| i.upcase }\nend\nflip_case(\"HeLLo\")\n  #=> \"\
    HELLO\" \nflip_case(\"hello world\")\n  #=> \"Hello World\" \nflip_case(\"hello_world\"\
    )\n  #=> \"HelloWorld\" \nflip_case(\"FoO Bar\")\n  #=> \"Foo Bar\"\nflip_case(\"\
    foo-bar-baz\")\n  #=> \"FooBaz\" \nflip_case(\"foo-bar-baz\")\n  #=> \"FooBaz\"\
    \n</code>\nNow the function can be applied to the array of strings:\n<code>\n\
    result = strings.map(flip_case)\n  #=> [\"Hello World\", \"HelloWorld\", \"Foo\
    \ Bar\", \"FooBaz\"]\n</code>\nYou can verify that it works by checking the result\
    \ of:\n<code>\nresult.each{|s| puts s.upcase }\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a |>\nI suggest using inject and upcase on the result:\n<code>", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.downcase!\n  string.upcase!\nend\n</code>\n\
    <|/ a |>\n<| c |>\nWhy are you using an instance method on string? The strings\
    \ are immutable and can be manipulated using their own methods. String#downcase\
    \ and String#upcase would make more sense.\n<|/ c |>\n<| c |>\nI used the instance\
    \ method because he used it and I wanted to keep it close to the original. Using\
    \ a class method would also be possible, by passing 'self' as an argument to the\
    \ class method.\n<|/ c |>\n<| a |>\nJust one more answer on Ruby 2.4, which doesn't\
    \ have downcase! method\n<code>", "  string.downcase!\n  string.upcase!\nend\n\
    </code>\nThen you can create some methods to make it easier to work with strings:\n\
    <code>", "  string.chars.map do |char|\n    char.downcase if char.downcase !=\
    \ char\n    end.join(\"\")\n  end\nend", "  string.downcase!\nend", "  string.downcase!\n\
    \  string\nend", "  string.gsub(/[a-z]/) { |c| c.upcase }.gsub(/[A-Z]/) { |c|\
    \ c.downcase }\nend\n</code>\nWe can test it with\n<code>\nflip_case(\"Hello\"\
    )\n  #=> \"elloH\"\nflip_case(\"123\")\n  #=> \"321\"\n</code>\nSo for \"ABCDEF\"\
    , flip_case(\"ABCDEF\") gives \"FEDCBA\".\nFor \"123\", flip_case(\"123\") gives\
    \ \"123\".\n<|/ a tags=ruby,regex,string dscore=2 |>\n<| a tags=ruby,regex,string\
    \ |>\nYou don't need to use regular expressions for this, you can just use String#tr:\n\
    <code>", "  string.gsub(/./) { |c| c.upcase <=> c.downcase }\nend\n</code>\nLet's\
    \ see what that gives us:\n<code>\nflip_case(\"fooBarBaz\")\n  #=> \"foobarbaz\"\
    \nflip_case(\"fooBarBaz\")\n  #=> \"foobarbaz\"\nflip_case(\"FOO BAR BAZ\")\n\
    \  #=> \"foobarbaz\"\nflip_case(\"FOO BAR BAZ\")\n  #=> \"foobarbaz\"\nflip_case(\"\
    Foo bar baz\")\n  #=> \"foobarbaz\"\nflip_case(\"Foo bar baz\")\n  #=> \"foobarbaz\"\
    \nflip_case(\"FooBar baz\")\n  #=> \"foobarbaz\"\nflip_case(\"FooBar baz\")\n\
    \  #=> \"foobarbaz\"\nflip_case(\"FooBaz\")\n  #=> \"foobarbaz\"\nflip_case(\"\
    FooBaz\")\n  #=> \"foobarbaz\"\nflip_case(\"Foo Bar Baz\")\n  #=> \"foobarbaz\"\
    \nflip_case(\"Foo Bar Baz\")\n  #=> \"foobarbaz\"\nflip_case(\"Foo BAR BAZ\")\n\
    \  #=> \"foobarbaz\"\nflip_case(\"Foo BAR BAZ\")\n  #=> \"foobarbaz\"\nflip_case(\"\
    Foo BAR baz\")\n  #=> \"foobarbaz\"\nflip_case(\"Foo BAR baz\")\n  #=> \"foobarbaz\"\
    \nflip_case(\"FooBar Baz\")\n  #=> \"foobarbaz\"\nflip_case(\"FooBar Baz\")\n\
    \  #=> \"foobarbaz\"\nflip_case(\"fooBarbaz\")\n  #=> \"foobarbaz\"\nflip_case(\"\
    fooBarbaz\")\n  #=> \"foobarbaz\"\nflip_case(\"fooBARbaz\")\n  #=> \"foobarbaz\"\
    \nflip_case(\"fooBARbaz\")\n  #=> \"foobarbaz\"\nflip_case(\"fooBarBaz\")\n  #=>\
    \ \"foobarbaz\"\nflip_case(\"fooBarBaz\")\n  #=> \"foobarbaz\"\nflip_case(\"fooBarBaz\"\
    )\n  #=> \"foobarbaz\"\n</code>\nSo that works, but as mentioned in the other\
    \ answer, it's kind of ugly. We can write a little helper method for that.\n<code>",
  "  string.downcase!\nend", "  string.gsub!(\"\\A[a-z]+\", \"\\\\u\\&\")\n  string.gsub!(\"\
    \\z\", \"\\\\u\\&\")\nend", "  return string.downcase + string.upcase\nend\n  ",
  "  string.downcase!\n  string.upcase!\nend\n</code>\nNotice the difference between\
    \ downcase! and upcase!.  If you call downcase! on an already uppercased string,\
    \ it will leave it uppercased.\n<code>", "  string.gsub!('a'..'z', 'A'..'Z').gsub!('A'..'Z',\
    \ 'a'..'z')\nend\n</cell>\n<cell>\nflip_case(\"This_is_the_easiest_case_ever!\"\
    ) \n</cell>\n<cell>", "    string.gsub(/[a-z]/) { |x| x.upcase }\n    string.gsub(/[A-Z]/)\
    \ { |x| x.downcase }\n    string\nend\n</cell>\n<text>\nThe next step is to test\
    \ the method. Before we do that, let's see what happens when we pass in a string\
    \ with nothing but lowercase characters.", "  string.downcase!\n  string.upcase!\n\
    end", "  string.split(\"\").map { |c| c.upcase == c.downcase ? c.downcase : c.upcase\
    \ }.join\nend", "    string.downcase!\n    string.upcase!\nend\nputs flip_case(\"\
    Hello World\")", "  string.downcase!\n  string.upcase!\nend", "    string.downcase!\n\
    \    string.upcase!\nend", "  string.gsub(/[a-z]/) { |char| char.upcase }.gsub(/[A-Z]/)\
    \ { |char| char.downcase }\nend", "  # If the given string is a number.\n  if\
    \ string.is_a? Numeric\n    # Return the given number if it is in lowercase or\
    \ uppercase.\n    if string < 0 || string > 0\n      return string\n    else\n\
    \      return string\n    end\n  else\n    # If given string is in lowercase,\
    \ return string.\n    string = string.upcase\n  end\n  # Return the given string.\n\
    \  return string\nend", "  # Convert the input string to a lower case ASCII string.\n\
    \  string = (string + '').downcase.encode('ascii')", "  new_string = string.downcase\n\
    \  new_string.gsub!(/[^a-z]+/i, \"\\&\\&\")\n  new_string.gsub!(/[^A-Z]+/i, \"\
    \\&\\&\")\n  new_string.downcase\nend\n</code>\n<|/ a |>\n<| a |>\nYou might be\
    \ able to use gsub to do this\n<code>\ngsub!(/[^A-Z]/, \"&\", string)\ngsub!(/[^a-z]/,\
    \ \"&\", string)\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| c |>\n\
    Won't this only replace the first occurrence of a character in the string?\n<|/\
    \ c |>\n<| c |>\n: I believe so, see [this answer](http://stackoverflow.com/questions/1545546/how-to-replace-all-non-alphanumeric-characters-in-a-string-in-rails).\n\
    <|/ c |>\n<| a |>\nThe easiest way to solve this issue would be to use a Rails\
    \ helper: \n<code>", "  string.gsub!(\"a\", \"A\").gsub!(\"b\", \"B\").gsub!(\"\
    c\", \"C\").gsub!(\"d\", \"D\").gsub!(\"e\", \"E\").gsub!(\"f\", \"F\").gsub!(\"\
    g\", \"G\").gsub!(\"h\", \"H\").gsub!(\"i\", \"I\").gsub!(\"j\", \"J\").gsub!(\"\
    k\", \"K\").gsub!(\"l\", \"L\").gsub!(\"m\", \"M\").gsub!(\"n\", \"N\").gsub!(\"\
    o\", \"O\").gsub!(\"p\", \"P\").gsub!(\"q\", \"Q\").gsub!(\"r\", \"R\").gsub!(\"\
    s\", \"S\").gsub!(\"t\", \"T\").gsub!(\"u\", \"U\").gsub!(\"v\", \"V\").gsub!(\"\
    w\", \"W\").gsub!(\"x\", \"X\").gsub!(\"y\", \"Y\").gsub!(\"z\", \"Z\")\nend",
  "  result = string.downcase\n  string.gsub!(/[a-z]/) {|s| s.upcase }\n  result\n\
    end\n</code>\nWe then use a hash to store the case-fliped versions of the words\
    \ that are in the hash. Now we can just search the array for a word that matches\
    \ the search string and use the case fliped version to get the correct case:\n\
    <code>\ncases = Hash.new { |h,k| h[k] = flip_case(k) }", "    string.downcase!\n\
    \    string.upcase!\n    string\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails-3,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails-3,ruby-on-rails |>\n<code>", "  string.downcase!\
    \ unless string.nil?\n  string\nend\n</code>\nThe flip method can be called on\
    \ a string in almost any way you want. For example:\n<code>\n> \"The quick brown\
    \ fox jumps over the lazy dog\".flip\n=> \"DOg fox brown quick jumps over the\
    \  The\"\n</code>\n<|/ a tags=ruby-on-rails |>\n<| c |>\nThis was very helpful.\
    \ Thank you for pointing out the method I didn't know about.\n<|/ c |>\n<| a tags=ruby-on-rails\
    \ dscore=3 |>\nA more general version of Andy's solution that also allows you\
    \ to flip any string:\n<code>", "  string.downcase! if string != string.downcase\n\
    \  string\nend", "    string.downcase!\n    string.upcase!\nend", "  string.downcase!\
    \ \n  string.upcase!\nend\n</cell>\n<cell>\nflip_case(\"Hello world\")\n</cell>\n\
    <text>\nStrings can be concatenated by using the + operator.", "  string.downcase!\n\
    \  string.upcase!\nend\n</code>\nIn order to avoid this problem altogether, it\
    \ would be better to use String interpolation instead of concating the strings\
    \ together:\n<code>", "  string = string.downcase\n  string.upcase!\nend", " \
    \ string.split('').map { |char| char.downcase }.join\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\n  string.upcase!\nend",
  "  string.gsub(/[a-z]/) do |x|\n    x.upcase\n  end\nend", "    string.downcase!\n\
    \    string.upcase!\nend", "  string.downcase!\n  string.upcase!\n  string\nend",
  "    string.gsub!(/[a-z]/) { |c| c.upcase }\n    string.gsub!(/[A-Z]/) { |c| c.downcase\
    \ }\nend\n</cell>\n<cell>\nflip_case(sample_string)\n</cell>\n<cell>", "  string.gsub(/./)\
    \ do |c|\n    case\n    when c.upcase == c\n      c.downcase\n    when c.downcase\
    \ == c\n      c.upcase\n    else\n      c\n    end\n  end\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.downcase.upcase\nend", "  string.split('').map\
    \ { |c| c.swapcase }.join('')\nend", "  string.upcase + string.downcase\nend\n\
    </code>\n<|/ a tags=ruby,regex |>\n<| c |>\nI'd like to see a solution that doesn't\
    \ use global variables ;)\n<|/ c |>\n<| c |>\nThe question states \"in Ruby\"\
    .\n<|/ c |>\n<| c |>\n`gsub` doesn't use global variables, it uses the return\
    \ value.\n<|/ c |>\n<| c |>\nIn Ruby, `gsub` returns an array and I used that\
    \ return value\n<|/ c |>\n<| c |>\n`gsub` is `gsub!` in Ruby\n<|/ c |>\n<| a dscore=1\
    \ |>\nOne liner :\n<code>\ns = \"abcde\"\ns.gsub(/[[:alpha:]]/) {|x| x.upcase\
    \ + x.downcase}\n</code>\n<|/ a tags=ruby,regex |>\n<| a dscore=0 |>\n<code>\n\
    \"abcde\".gsub(/[A-Z]/) { |c| c.upcase + c.downcase }\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| c |>\nThis does a global substitution which may not be desired if the\
    \ string contains regex characters.\n<|/ c |>\n<| a tags=ruby,regex dscore=0 |>\n\
    <code>\n p \"abcde\".scan(/[a-zA-Z]+/)\n => [\"a\", \"b\", \"c\", \"d\", \"e\"\
    ]\n p \"abcde\".scan(/[a-zA-Z]+/).map { |x| x.upcase + x.downcase }\n => [\"ABC\"\
    , \"BC\", \"C\", \"D\", \"E\"]\n</code>\n<|/ a |>\n<| a tags=ruby,regex |>\n<code>\n\
    string.gsub(/[[:alpha:]]/) {|c| c.upcase + c.downcase}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| c |>\nYour answer was already\
    \ there when I posted it ;)\n<|/ c |>\n<| c |>\nI don't think it's there, if you\
    \ look closely at the list of answers there wasn't one with this exact same solution\
    \ that ", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.chars.map\
    \ { |c| c.upcase == c.downcase ? c.downcase : c.upcase }.join(\"\")\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThat's a lot of code. A simple `string.downcase.capitalize`\
    \ would have done the job too. Thanks though\n<|/ c |>\n<| c |>\nI agree; I answered\
    \ for completeness, not necessarily performance. I've also written my own version\
    \ below as a learning exercise.\n<|/ c |>\n<| c |>\nGood answer, I hadn't even\
    \ thought about using the downcase and capitalize methods!\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer, as it answers directly to the question, without\
    \ adding additional methods that are not part of the language and that should\
    \ be avoided anyway.\n<|/ c |>\n<| a |>\nA simple solution would be using gsub\
    \ method. Like this\n<code>\n\"The quick brown fox\".gsub(/[a-z]/i) { |a| a.upcase\
    \ }", "  string.downcase! unless string.length <= string.length\n  string.upcase!\
    \ if string.length <= string.length\n  string\nend", "  string.downcase.gsub(/./,\
    \ &:upcase)\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\nend\n</cell>\n<cell>\nflip_case(\"Hello World\")\n</cell>\n\
    <cell>\nflip_case(\"Hello World!\")\n</cell>\n<cell>\nflip_case(\"Hello World!!\"\
    )\n</cell>\n<cell>\nflip_case(\"Hello World!!!\")\n</cell>\n<cell>\nflip_case(\"\
    Hello\")\n</cell>\n<cell>\nflip_case(\"Hello World!\")\n</cell>\n<cell>\nflip_case(\"\
    Hello World!!!\")\n</cell>\n<text>\nWe can do this with Ruby's case method, which\
    \ is a little less obfuscated:", "    string.downcase!\nend\n</code>\nThen, given\
    \ an input string (that needs to be transformed one way or the other), simply\
    \ call\n<code>", "    string.downcase!\n    string.upcase!\n    string\nend",
  "  string.split('').map(&:capitalize).join\nend", "  string.tr!(\"a-z\", \"A-Z\"\
    ).tr!(\"A-Z\", \"a-z\")\nend\n</cell>\n<cell>\nflip_case(\"hello world\")\n</cell>\n\
    <text>\nBy the way, note that the \"tr!\" method modifies its receiver.  If you\
    \ want to assign the new string to the variable then you need to use the bang\
    \ operator.", "  return string.downcase.gsub(/./) {|c| c.upcase == c.downcase\
    \ ? c : c.downcase}\nend\n</cell>\n<text>\nThe next function takes a string of\
    \ any length and splits it into individual letters. \nIt also takes an optional\
    \ argument that is the maximum number of letters to return. \nIf no number is\
    \ provided, it will return all possible letters within the string.", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.downcase!\n  string.upcase!\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.gsub(/./) { |char| char.upcase == char.downcase\
    \ ? char.downcase : char }\nend\n</code>\n<code>\nflip_case(\"The Quick Brown\
    \ Fox Jumped Over the Lazy Dog.\")\n  #=> \"ThEy QuICk BrOx Jumped Over thE LaZy\
    \ DoG.\"\n</code>\nIf you prefer not to use gsub (which is arguably more efficient\
    \ than a regular expression), you can do this:\n<code>", "  string.downcase.gsub(/./)\
    \ { |c| c.upcase }\nend\n</code>\nAs you can see, I used a regular expression\
    \ with .downcase to convert everything to lowercase (I used the method .downcase\
    \ instead of .upcase because I realized that this is probably what you're after),\
    \ and I used a block that converts every character from lowercase to uppercase.\
    \ I then used a regular expression to convert uppercase letters to lowercase.\
    \ \nYou can then flip all instances of uppercase to lowercase and lowercase to\
    \ uppercase by doing the following:\n<code>", "    string.gsub!(/[a-z]/){|char|\
    \ char.upcase + char.downcase}\n    string.gsub!(/[A-Z]/){|char| char.downcase\
    \ + char.upcase}\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks. You answered\
    \ my question even before I saw your answer. :-)\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  string.upcase!\n  string.downcase!\n  string\nend", "  string.gsub(/\\\
    w/) do |word|\n    word.upcase\n  end\nend", "  string.downcase! || string\nend",
  "  string.downcase!\n  string.upcase!\nend", "  string.tr!('a-zA-Z', 'A-Z')\n  string.tr!('A-Z',\
    \ 'a-z')\n  string\nend", "  string.downcase.gsub!(/\\w/) { |char| char.upcase\
    \ }\n  string.upcase.gsub!(/\\w/) { |char| char.downcase }\n  string\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nIf you're using rails, you can do the following with\
    \ your user object:\n<code>", "    string.upcase!\n    string.downcase!\nend",
  "  string.downcase! if string =~ /^[a-z]/i\n  string.upcase!\nend", "  string.downcase.gsub(/[a-z]/)\
    \ {|c| c.upcase }\nend", "  return string.downcase + string.upcase\nend\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThe downside is that it can give false positives and\
    \ false negatives.\n<|/ c |>\n<| c |>\n: What do you mean by \"false positives\"\
    ? Do you mean false negatives? If so, would you care to elaborate?\n<|/ c |>\n\
    <| c |>\nI mean false positives, for example \"a\" and \"\" are flipped to \"\"\
    \ and \"\" respectively. If you're comparing two strings, it could be that you\
    \ want them to be considered equal. I don't know of any regex that would do the\
    \ job, although I might be missing something.\n<|/ c |>\n<| a |>\nHere is an explanation\
    \ of some regex that I use to flip the case:\n<code>\n string =~ s/(^|[A-Z])/upcase($1)/;\n\
    </code>\nThis works by matching a lowercase letter or an uppercase letter and\
    \ replacing it with the uppercase version.\nThe explanation of what it does is\
    \ as follows:\n<code>\n ^          match start of string\n |          OR\n [A-Z]\
    \      match an uppercase letter\n (?1)      use the match in the replacement\n\
    \ /          end-of-string\n upcase     capitalize it\n $1         first match\
    \ backreference\n</code>\n<|/ a tags=string,ruby,regex dscore=4 |>\n<| c |>\n\
    : Yes, it does. `/hello/` results in `/Hello/` which matches `hello`. The regex\
    \ `/Hello/` will match `Hello`. `Hello` is the replacement string.\n<|/ c |>\n\
    <| c |>\nI don't think you need the backreference as long as you only match lowercase\
    \ letters. `string.downcase` will also do the trick.\n<|/ c |>\n<| c |>\nThis\
    \ approach is wrong. `upcase` returns the same string as `downcase` - `downcase`\
    \ doesn't do anything to the string.\n<|/ c |>\n<| c |>\nThe OP didn't ask to\
    \ capitalize `'Hello'`, so the answer is correct. Also, downcase is a method of\
    \ String, not of a regular expression, so it won't work on a regex. Also, downcase\
    \ is a method of String, so it only transforms individual characters in the string.\
    \ See the docs: http://www.ruby-doc.org/core-1.9.3/String.html\n<|/ c |>\n<| a\
    \ dscore=2 tags=string,ruby,regex |>\nHere's another one:\n<code>", "  if string.nil?\
    \ || string.length == 0\n    \"\"\n  else\n    string.upcase\n  end\nend\n</cell>\n\
    <cell>", "  string.gsub(/./) do |char|\n    case char\n    when 'a'\n      'A'\n\
    \    when 'A'\n      'a'\n    when '0'\n      '0'\n    else\n      char\n    end\n\
    \  end\nend", "  string.gsub(/\\w/){|m| m.upcase + m.downcase }\nend\n</code>\n\
    Then we can use that function on the string.  We can also use map to apply the\
    \ function to a set of strings:\n<code>\n[\"Hi there\", \"How are you?\"].map\
    \ do |string|\n  flip_case(string)\nend\n</code>\nGives:\n<code>\n=> [\"HI THERE\"\
    , \"HOW ARE YOU?\"]\n</code>\nNow that we have a string and can flip case, let's\
    \ take our original strings and create a regex that will identify the word that\
    \ is in lowercase:\n<code>\nstrings = %w[Hi how are you?]\n</code>\nWe'll need\
    \ some regex to find the word that is in lowercase:\n<code>\nregexp = /\\b(\\\
    w+)\\b/\n</code>\nAnd now we can use map to apply the regex to the set of strings:\n\
    <code>\nstrings.map do |string|\n  string\n    .gsub(regexp, lambda {|x| flip_case(x)}\
    \ )\nend\n</code>\nGives:\n<code>\n=> [\"HI THERE\", \"HOW ARE YOU?\"]\n</code>\n\
    <|/ a |>\n<| c |>\nI like your answer but I thought of one more method\n<|/ c\
    \ |>\n<| c |>\nI like your answer but I thought of one more method. \n1. split\
    \ word with white space => [\"word\", \"another\"]\n2. then find the word from\
    \ array => [\"word\"]\n<|/ c |>\n<| c |>\nThat's probably a good way to do it\
    \ if you really want a one-line answer, but in general the one-liner solutions\
    \ are usually more readable.\n<|/ c |>\n<| c |>\nI have added another method which\
    \ I think is more readable. :)\n<|/ c |>\n<| c |>\n+1 for the second method. I\
    \ don't understand why people always go for regex solutions when there are simpler\
    \ alternatives.\n<|/ c |>\n<| a dscore=2 |>\nAnother method:\n<code>\nirb(main):014:0>\
    \ string = \"Hi How are you?\"\n=> \"Hi How are you?\"\nirb(main):015:0> string.gsub(/(\\\
    w)\\w*$/){|m| m.reverse.upcase }\n=> \"Hi How are you?\"\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis is probably the most straightforward one-line answer. :)\n\
    <|/ c |>\n<| c |>\nI like this one as well. :)\n", "  return string.downcase\n\
    end", "  string.downcase! if string.casecmp('') == 0\n  string.upcase!\nend\n\
    </code>\nThe other two methods are just simple Ruby string methods.  It's worth\
    \ mentioning that you can chain these methods together like so:\n<code>\nirb(main):008:0>\
    \ 'my string'.upcase&.to_s\n=> \"MY STRING\"\n</code>\nThis flips the case of\
    \ the string and converts it to lower case.\n<code>\nirb(main):009:0> 'my string'.downcase&.to_s\n\
    => \"my string\"\n</code>\nThis flips the case of the string and converts it to\
    \ upper case.\nThe downcase method returns the string in all uppercase (uppercase!)\
    \ and upcase method does the opposite.\nThese two methods return a new String\
    \ object.\nNow if you need to reverse the case of a string...\n<code>\nirb(main):011:0>\
    \ 'my string'.downcase.reverse == 'my string'.upcase.reverse\n=> true\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't answer the OP's question.\n<|/ c |>\n\
    <| c |>\nThat's not how this site works.\n<|/ c |>\n<| c |>\nI thought the question\
    \ was pretty clear. It was an example of a simple way to flip case in Ruby. As\
    \ I said in my answer, the other two methods were simple Ruby string methods.\
    \ There's no need to downvote. I'm happy to help if I can and to help someone\
    \ that might have the same question in the future. So why did you downvote?\n\
    <|/ c |>\n<| c |>\nI did downvote, but then I realized that my answer was incorrect.\
    \ I apologize for that.\n<|/ c |>\n<| c |>\nNo need to apologize. I got some rep\
    \ points for it. I did upvote you for your answer, though, as it was very informative.\n\
    <|/ c |>\n<| a tags=string,ruby dscore=1 |>\n<code>", "    string.downcase!\n\
    \    string.upcase!\nend\n</code>\nWith this method, you are able to create a\
    \ hashmap with key as a string, and the value as the transformed string as shown\
    \ below\n<code>\nHash[\"one\"=>\"One\", \"two\"=>\"Two\"]\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=2 tags=ruby,ruby-on-rails |>\nHow about this?\n<code>", "  string.gsub(/[a-z]/)\
    \ { |s| s.upcase }.gsub(/[A-Z]/) { |s| s.downcase }\nend", "  string.downcase!\n\
    end\n</code>\nNow you can chain together your transformations:\n<code>\nstr =\
    \ \"Foo, bar, foobar, FOO BAR\"\nputs str.gsub(/foo/).gsub(/bar/).gsub(/foobar/).gsub(/FOO\
    \ BAR/).gsub(/FOO/).gsub(/BAR/).gsub(/FOO/).gsub(/BAR/).gsub(/fooo/).gsub(/barr/).gsub(/fooba/).gsub(/barar/).gsub(/fooar/).gsub(/bara/).gsub(/foobar/).gsub(/foo/).gsub(/foobar/).gsub(/bar/).gsub(/fooba/).gsub(/barar/).gsub(/fooar/).gsub(/bara/).gsub(/foobar/).gsub(/foo/).gsub(/foobar/).gsub(/bar/).gsub(/fooba/).gsub(/barar/).gsub(/fooar/).gsub(/bara/).gsub(/foobar/).gsub(/foo/).gsub(/foobar/).gsub(/bar/).gsub(/fooba/).gsub(/barar/).gsub(/fooar/).gsub(/bara/).gsub(/foobar/).gsub(/FOO/).gsub(/FOO/).gsub(/BAR/).gsub(/BAR/).gsub(/FOO/).gsub(/BAR/).gsub(/FOO/).gsub(/BAR/).gsub(/fooo/).gsub(/barr/).gsub(/fooba/).gsub(/barar/).gsub(/fooar/).gsub(/bara/).gsub(/foobar/).gsub(/FOO/).gsub(/FOO/).gsub(/BAR/).gsub(/BAR/).gsub(/FOO/).gsub(/BAR/).gsub(/FOO/).gsub(/BAR/).gsub(/fooo/).gsub(/barr/).gsub(/fooba/).gsub(/barar/).gsub(/fooar/).gsub(/bara/).gsub(/foobar/).gsub(/FOO/).gsub(/FOO/).gsub(/BAR/).gsub(/BAR/).gsub(/FOO/).gsub(/BAR/).gsub(/FOO/).gsub(/BAR/",
  "  string.upcase.gsub(/./, &:downcase)\nend", "  string.downcase!\nend\n</cell>\n\
    <cell>\nflip_case(\"Hello World!\")\n</cell>\n<cell>", "  return string.chars.reverse.tr(\"\
    \ !\"\\\n    \"\\a\"\\\n    \"\\e\"\\\n    \"\\i\"\\\n    \"\\o\"\\\n    \"\\\
    u\"\\\n    \"\\l\"\\\n    \"\\L\"\\\n    \"\\e\"\n  ).chars.reverse\nend", " \
    \ string.downcase!\nend", "  string.downcase!\n  string.upcase!\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThat's not the point. He wants to write code that\
    \ works both ways.\n<|/ c |>\n<| c |>\nThe point is it's easier to work with when\
    \ all you have to worry about is upper/lower case.\n<|/ c |>\n<| c |>\nI agree,\
    \ but my point is your answer does not address OPs question. If it did I would\
    \ upvote.\n<|/ c |>\n<| c |>\nIt does address the OPs question.  The OP just has\
    \ his problem with the code he has written.\n<|/ c |>\n<| c |>\nThe OP asks \"\
    how do I do X\" which means he needs help with doing X. Your answer does not address\
    \ how to do X. He needs to fix the code he has written which doesn't address the\
    \ OPs question\n<|/ c |>\n<| a |>\nYou're close.  You're just missing a couple\
    \ things.  First, flip the case, and second you need to check if the string was\
    \ converted to uppercase first by flipping the case.  Here's what you're looking\
    \ for:\n<code>", "  string.gsub(/([a-z])/) {|s| s[0..1].upcase + s[1..-1].downcase}\n\
    end", "  string.downcase!\nend", "  string.downcase!\n  string\nend", "  string.downcase!\
    \ if string =~ /\\A[a-z]+\\z/i\n  string.upcase! if string =~ /\\A[A-Z]+\\z/i\n\
    \  string\nend", "  string.gsub(/./){|c| c.upcase == c.downcase ? c.downcase :\
    \ c.upcase }\nend", "  string.upcase.ljust(string.size, 'A').upcase\nend\n</code>\n\
    As per my comment in the code, you can convert a string into uppercase or lowercase.\
    \ Now, you can do this:\n<code>\nflip_case(string.capitalize)\n</code>\nYou will\
    \ have to pass the argument inside the function.\n<|/ a tags=ruby |>\n<| c |>\n\
    This doesn't work. `string.upcase.ljust(string.size, 'A')` returns `#<Enumerator:\
    \ \"FOO\">`.\n<|/ c |>\n<| c |>\nYeah, that did the trick after removing the \"\
    A\" from the end. Thanks.\n<|/ c |>\n<| a tags=ruby |>\nIn Ruby 1.8, you have\
    \ the String#tr and String#reverse methods for this:\n<code>\n>> \"abcd\".tr(\"\
    abcdefghijklmnopqrstuvwxyz\", \"klmnopqrstuvwxyzabcdefghijk\")\n=> \"KNOQVZ\"",
  "  string.downcase!\n  string.upcase!\nend", "  string.tr!('abcdefghijklmnopqrstuvwxyz',\
    \ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n  string.tr!('ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')\n\
    \  return string\nend", "  string.downcase! unless string == \"\"\n  string.upcase!\
    \   unless string == \"\"\nend", "  string.downcase! unless string =~ /\\A[A-Z]+\\\
    z/\n  string.upcase!\nend", "    string.downcase!\nend\n</code>\nNow, you can\
    \ flip the cases of all the letters in a string using one simple line of code:\n\
    <code>\nflip_case(\"hello\")", "  string.gsub(/[a-z]/) {|char| char.upcase + char.downcase}\n\
    end", "  string.downcase!\nend\nflip_case(\"Hello World\")\nflip_case(\"Hello\
    \ World\")", "  # Replace a with A, A with a, Z with Z, Z with z.\n  string.replace\
    \ /a/, /A/\n  string.replace /z/, /Z/\n  string.replace /0/, /0/\nend", "  string.gsub!(/[[:lower:]]/)\
    \ { |m| m.upcase }\n  string.gsub!(/[[:upper:]]/) { |m| m.downcase }\n  string\n\
    end", "  string.downcase!\n  string.upcase!\nend\n</code>\nWe can then call flip_case\
    \ on our string in two ways:\n<code>\nflip_case(\"Hello World\")\nflip_case(\"\
    hello world\")\n</code>\nWe can also use a block to avoid repeating ourselves:\n\
    <code>\nflip_case(\"Hello World\") {|s| s.upcase}\n</code>\nThe downside to this\
    \ is that it only applies the transformation to one string at a time.  If you\
    \ need to make multiple changes to a string, you could create an array and process\
    \ them in a loop:\n<code>\nstrings = [\"Hello World\", \"hello world\"]\nstrings.each\
    \ do |string|\n  flip_case(string)\nend\n</code>\nAnother thing to keep in mind\
    \ is that downcase! will mutate your original string.  We can make a copy if we\
    \ want a completely new string.\n<code>\nnew_strings = strings.map { |string|\
    \ flip_case(string) }\n</code>\n<|/ a |>\n<| c |>\nGreat answer. One thing to\
    \ note is that `downcase!` will modify the original string. So to preserve the\
    \ original string and just lowercase it, use `downcase`.\n<|/ c |>\n<| c |>\n\
    True. I've clarified that in my answer.\n<|/ c |>\n<| a |>\n<code>\n\"Hello World\"\
    .scan(/./).map{ |x| x.upcase }.join\n</code>\nThe scan part takes all characters\
    \ and then maps the upper case to the character. After that you can join the characters\
    \ into a string.\n<|/ a dscore=1 tags=ruby |>\n<| a tags=ruby |>\n<code>\n\"Hello\
    \ World\".split.map(&:upcase).join(' ')\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This was closest, except you forgot to add a `.join(' ')`. I'll edit for clarity.\n\
    <|/ c |>\n<| c |>\nYou don't need `.split('')` - `'Hello World'.split('')` is\
    \ just as valid\n<|/ c |>\n<| c |>\nThanks for the advice, I'm new to Ruby, and\
    \ I often forget that you can omit `split`, I guess it's just habit.\n<|/ c |>\n\
    <| c |>\nIt's not just \"habit\" but a necessary part of the language.\n<|/ c\
    \ |>\n<| a |>\n<code>\n\"Hello World\".split.map(&:upcase).join(' ')\n</code>\n\
    <|/ a dscore=1 tags=ruby |>\n<| a dscore=0 |>\n<code>\n", "    string.downcase!\n\
    \    string.upcase!\n    string\nend\n</code>\nAs a result of the following test:\n\
    <code>\nit \"should flip lowercase letters to uppercase letters\" do\n  expect(\"\
    aAbBcCdD\").to(flip_case).to eq(\"abcdD\")\nend\n</code>\nI get:\n<code>\n1) Error:\n\
    Test#test_should_flip_lowercase_letters_to_uppercase:\nArgumentError: argument\
    \ must be a string (was nil)\n    app/controllers/test_controller.rb:11:in `flip_case'\n\
    \    app/controllers/test_controller.rb:11:in `test'\n    test/controllers/test_controller_spec.rb:24:in\
    \ `block (3 levels) in <top (required)>'\n</code>\nIt seems to be that flip_case\
    \ is returning nil.\nIn order to debug this you can add an argument like argument\
    \ or argument or argument or argument to flip_case and add a breakpoint on the\
    \ argument to see the value before it is passed to flip_case.\n<|/ a |>\n<| c\
    \ |>\nThis works. But when I run the spec I get the following error: `NameError:\
    \ undefined local variable or method `string' for #<String:0x00000002b6db70>`\n\
    <|/ c |>\n<| c |>\nI added some more detail about the error. Maybe it helps. Can\
    \ you try adding `puts flip_case` just before `expect`?\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,ruby-on-rails,rspec,testing |>\nTry adding \"flip\" to the expect\
    \ like so\n<code>\nit \"should flip lowercase letters to uppercase letters\" do\n\
    \  expect(flip_case(\"aAbBcCdD\")).to eq(\"abcdD\")\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nSince string is a reserved keyword, you cannot use it as variable\
    \ name.\n<code>", "  string = string.dup\n  string.gsub!(/./) do |char|\n    char\
    \ = char.upcase if char < 'A'\n    char = char.downcase if char > 'Z'\n    char\n\
    \  end\n  string\nend", "  case string\n    when /\\A[a-z]+\\z/i then string.upcase\n\
    \    when /\\A[A-Z]+\\z/i then string.downcase\n  end\nend", "    string.gsub(/([a-z])/)\
    \ { $1.upcase }\nend", "  string.downcase!\n  string.upcase!\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "    string.downcase!\nend", "  string.gsub(/[^[:upper:][:lower:]]/)\
    \ do |char|\n    char.upcase + char.downcase\n  end\nend", "  string.chars.map.with_index\
    \ do |c, i| \n    if c.downcase == c\n      c.swapcase\n    end\n  end\n  string\n\
    end\n</code>\n<|/ a tags=ruby-on-rails,ruby dscore=0 |>\n<| a |>\nI figured it\
    \ out! Thanks for all the help!\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend\n</code>\nThen, you could do something like this:\n<code>", " \
    \ string.gsub(/[^A-Z]/){|m| m.upcase + m.downcase}\nend", "  string.gsub(/./)\
    \ { |c| c.upcase == c.downcase ? c.downcase : c.upcase }\nend\n</code>\nYou can\
    \ now call your helper method in the following way:\n<code>\n> flip_case(\"hello\"\
    )\n=> \"Hello\"\n</code>\nOr as others pointed out, simply call the .capitalize()\
    \ method on the String object.\n<code>\n> \"hello\".capitalize\n=> \"Hello\"\n\
    </code>\n<|/ a tags=ruby dscore=0 |>\n<| a dscore=0 |>\nYou can use the capitalize\
    \ method for strings. \nExample:\n<code>\n\"hello\".capitalize\n</code>\nWill\
    \ return:\n<code>\n\"Hello\"\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n\
    If you want to capitalize every word in a string, you can do this: \n<code>\n\"\
    The big brown fox jumped over the lazy dog.\".split.map(&:capitalize).join(' ')\n\
    => \"The big brown fox jumped over the lazy dog.\"\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nThis solution is far more inefficient than using `capitalize`: `\"The\
    \ big brown fox jumped over the lazy dog.\".gsub(/\\b(\\p{L})\\B/) { $1.upcase\
    \ }`\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\"The big brown fox jumped over the\
    \ lazy dog.\".split.map(&:capitalize).join(' ')\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nYou don't need to call `split` here. The `String#capitalize` method will\
    \ split for you, e.g. `\"the big brown fox jumped over the lazy dog\".capitalize\n\
    => \"The Big Brown Fox Jumped Over The Lazy Dog\"`.\n<|/ c |>\n<| c |>\nThe string\
    \ may be huge, so it might be better not to use `split`, but `gsub` instead.\n\
    <|/ c |>\n<| c |>\n`gsub` isn't needed at all. It will split on whitespace, too.\
    \ `capitalize` will do that as well.\n<|/ c |>\n<| c |>\nThe `String#capitalize`\
    \ method will split on whitespace, too, but it's possible to call `split` beforehand,\
    \ if one wants to split the string into words. Of course the question wasn't about\
    \ that, but I thought it was worth mentioning.\n<|/ c |>\n<| c |>\nYes, but if\
    \ you ", "    string.downcase!\n    string\nend", "  result = \"\"\n  string.downcase!\
    \ unless string.nil?\n  string.upcase! unless string.nil?\n  return result\nend",
  "  string.downcase! # Change to lowercase\n  string.upcase!    # Change to uppercase\n\
    \  return string\nend\n</code>\nNotice how we used the downcase! method instead\
    \ of upcase!, since we are trying to flip the case of the string, rather than\
    \ convert it to lower and upper.\n<|/ a |>\n<| a dscore=0 tags=ruby,string,regex\
    \ |>\nHere's a regex that would do it. \n<code>", "    string.upcase!\n    string.downcase!\n\
    \    string\nend", "  string.gsub(/./) { |char| char.upcase + char.downcase }\n\
    end", "  string.downcase!\n  string.upcase!\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nI wish it was `string=string.downcase; string=string.upcase`, but that's\
    \ not what it's giving me in irb. Also, it's giving me `undefined method 'downcase'\
    \ for \"abc\":String (NoMethodError).`\n<|/ c |>\n<| c |>\nSorry, I had a typo\
    \ in there. I'll edit the code sample\n<|/ c |>\n<| c |>\nThat's not true. `downcase!`\
    \ is an instance method.\n<|/ c |>\n<| c |>\n`downcase!` is an instance method.\
    \ `downcase` is a class method.\n<|/ c |>\n<| a tags=ruby |>\nIf a string is all\
    \ caps and you want it to be all lowercase you can do that by calling downcase!\n\
    <|/ a dscore=2 |>\n<| c |>\nIt is not correct that `downcase!` changes the receiver,\
    \ but `downcase` does not. `downcase!` mutates the receiver while `downcase` just\
    \ returns a new string.\n<|/ c |>\n<| c |>\nSorry, I meant to say that `downcase!`\
    \ changes the object it is called upon, not the string itself.\n<|/ c |>\n<| a\
    \ tags=ruby |>\nThis one works too:\n<code>\n\"Hello World\".swapcase\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis is interesting, because `swapcase!` modifies\
    \ the string itself, while `swapcase` returns a new string. `swapcase!` is often\
    \ used to convert a string to its uppercase or lowercase form.\n<|/ c |>\n<| a\
    \ |>\nJust to add, if you have a string, you can do:\n<code>\n\"HellO WORLD\"\
    .downcase!\n</code>\nwhich returns \"Hello World\".\n<|/ a dscore=2 tags=ruby\
    \ |>\n<| c |>\n`downcase!` changes the receiver. `downcase` does not.\n<|/ c |>\n\
    <| a tags=ruby |>\nYou can use a gsub to do this:\n<code>\ns = \"HellO WORLD\"\
    \ns.gsub(/./) { |c| c.upcase }", "  string.downcase!\n  string.upcase!\nend\n\
    </code>\n<|/ a tags=ruby-on-rails,ruby,ruby-on-rails-5 dscore=1 |>\n<| a |>\n\
    <code>", "  string.chars.map(&:capitalize).join\nend", "  string.upcase.gsub(/./){|s|\
    \ s.upcase + s.downcase}.downcase\nend\n</code>\nThe regexp /./{|s| s.upcase +\
    \ s.downcase} will match any single character and apply the upcase and downcase\
    \ methods to it. \nI realize it's not the most idiomatic ruby code, however, it\
    \ demonstrates the power of blocks, and it uses simple string methods. \nIf you\
    \ need more help on the regex, check out http://regexr.com/\n<|/ a |>\n<| c |>\n\
    Thank you for the detailed description. After reading the description, I realize\
    \ that I misunderstood `gsub` syntax. The correct form is: `string.gsub(/./){|s|\
    \ s.upcase + s.downcase}.downcase`. Without `|s| s.upcase + s.downcase`, the return\
    \ value was `nil`.\n<|/ c |>\n<| c |>\nAhh, good catch. That was a little too\
    \ much for me to put into one comment :) I'm glad you figured it out.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  string.tr!('a-z', 'A-Z')\n  string.tr!('A-Z', 'a-z')\n\
    \  string\nend", "  string.downcase!\n  string.upcase!\n  string\nend", "  string.downcase!\n\
    \  string.upcase!\nend", "  string.downcase!\n  string.upcase!\nend", "    string.gsub!(/[a-z]/)\
    \ { |i| i.capitalize }\n    string.gsub!(/[A-Z]/) { |i| i.capitalize }\n    string.downcase\n\
    end", "  string.downcase!\n  string.upcase!\nend", "  string.gsub(/[a-z]/i) do\
    \ |match|\n    match.upcase == match ? match.downcase : match.downcase\n  end\n\
    end\n</code>\nAnd now to test it:\n<code>\nrequire 'minitest/autorun'", "  string.downcase!\n\
    \  string.upcase!\nend\n</cell>\n<cell>\nflip_case(\"Thomas Edison\")\n</cell>\n\
    <cell>\nflip_case(\"Thomas Edison\".downcase)\n</cell>\n<cell>\nflip_case(\"Thomas\
    \ Edison\".upcase)\n</cell>\n<text>\nString#split\nIt splits a string into a given\
    \ number of parts, where each part is delimited by whitespace.", "  string.downcase!\n\
    \  string\nend\n</cell>\n<cell>\n\"HeLLo\".downcase!\nflip_case(\"heLLo\")\n</cell>\n\
    <cell>\nflip_case(\"HEllo\")\n</cell>\n<cell>\nflip_case(\"hello\")\n</cell>\n\
    <cell>\nflip_case(\"HELLO\")\n</cell>\n<text>\nWe can remove punctuation with\
    \ String#delete.", "  string.gsub(/./) do |c|\n    c.ord < 33 ? c.chr.downcase\
    \ : c.chr.upcase\n  end\nend", "  string.downcase!\n  string.upcase!\nend", " \
    \ string.downcase!\n  string.upcase!\nend", "  string.downcase!\n  string.upcase!\n\
    end\n</code>\nWith these changes in place, your code will behave as expected and\
    \ behave as documented:\n<code>\nirb(main):001:0> flip_case('Hello')\n=> \"HELLO\"\
    \nirb(main):002:0> flip_case('hELLO')\n=> \"HELLO\"\nirb(main):003:0> flip_case('hELLO')\n\
    => \"hELLLO\"\nirb(main):004:0> flip_case('Hello')\n=> \"HELLO\"\nirb(main):005:0>\
    \ flip_case('Hello World')\n=> \"HELLO World\"\nirb(main):006:0> flip_case('Hello\
    \ World')\n=> \"Hello World\"\nirb(main):007:0> flip_case('Hello World')\n=> \"\
    Hello World\"\nirb(main):008:0> flip_case('hello world')\n=> \"Hello World\"\n\
    irb(main):009:0> flip_case('hELLO World')\n=> \"HELLO World\"\nirb(main):010:0>\
    \ flip_case('hELLO World')\n=> \"hELLO World\"\nirb(main):011:0> flip_case('hELLO\
    \ World')\n=> \"HELL World\"\nirb(main):012:0> flip_case('HELL LO WORLD')\n=>\
    \ \"HELL World \"\nirb(main):013:0> flip_case('HELL LO WORLD')\n=> \"HELL LO World\"\
    \nirb(main):014:0> flip_case('hELLO World')\n=> \"HELL LO World\"\nirb(main):015:0>\
    \ flip_case('HELL LO WORLD')\n=> \"HELL LO WORLD\"\nirb(main):016:0> flip_case('hELLO\
    \ World')\n=> \"HELL LO WORLD\"\nirb(main):017:0> flip_case('HELL LO WORLD')\n\
    => \"HELL LO WORLD\"\nirb(main):018:0> flip_case('HELLO World')\n=> \"HELLO World\"\
    \nirb(main):019:0> flip_case('HELLO World')\n=> \"HELLO World\"\nirb(main):020:0>\
    \ flip_case('HELLO World')\n=> \"HELLO World\"\nirb(main):", "  string.downcase!\n\
    end", "  string.downcase! # 'hello' -> 'HELLO'\n  string.upcase!    # 'HELLO'\
    \ -> 'hello'\n  string\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=2\
    \ tags=ruby,ruby-on-rails |>\nAs a complement to the answer of Randy Cate, here\
    \ is my code which uses gsub and upcase! and downcase! methods:\n<code>", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.gsub(/[a-z]/i) { |x| x.upcase }.gsub(/[A-Z]/i)\
    \ { |x| x.downcase }\nend", "  if string.length == 0 \n    string\n  else\n  \
    \  string.downcase! unless string.length == 1 && string[0].upcase == string[0]\n\
    \    string.upcase! unless string.length == 1 && string[0].downcase == string[0]\n\
    \    string\n  end\nend", "  string.downcase!\n  string.upcase!\n  string\nend",
  "  string.gsub(/[a-z]/) { |s| s.upcase }\nend", "    string.downcase.split(\"\"\
    ).map { |char| char.upcase }.join\nend", "  string.upcase!\n  string\nend", " \
    \   string.tr!('abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n \
    \   string.tr!('ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')\nend",
  "  string.gsub(/./) { |c| c.upcase == c.downcase ? c.downcase : c.upcase }\nend\n\
    puts flip_case(\"Hello World!\")", "  new_string = string.downcase\n  new_string.upcase!\n\
    \  new_string\nend", "  string.gsub(/./){|c| c.upcase == c.downcase ? c.downcase\
    \ : c.upcase}\nend\n</code>\nNow, we can do the following:\n<code>\na = \"FooBarBaz\"\
    \n</code>\nMethod 1:\n<code>\nflip_case(a).gsub(/([A-Z]+)/){|m| m.capitalize}\n\
    </code>\nMethod 2:\n<code>\nflip_case(a).gsub(/([a-z]+)/){|m| m.capitalize}\n\
    </code>\nThis gives the following results:\n<code>\n=> \"fooBarBaz\"\n</code>\n\
    or\n<code>\n=> \"fooBarbaz\"\n</code>\ndepending on which method you choose to\
    \ use.\n<|/ a tags=string,ruby |>\n<| c |>\nI like this better than my answer,\
    \ +1.\n<|/ c |>\n<| c |>\n`def flip_case(string); string.downcase.gsub(/[A-Z]/)\
    \ { |m| m.upcase }; end`\n<|/ c |>\n<| c |>\n- I was just writing up exactly that\
    \ as I wrote my comment on the OP. :)\n<|/ c |>\n<| c |>\n- `gsub` is case sensitive,\
    \ meaning it will only change the first character if you use `/[A-Z]/`. Try it\
    \ out if you like.\n<|/ c |>\n<| c |>\nThe method name should be \"flip_case\"\
    .\n<|/ c |>\n<| a tags=string,ruby |>\nIf you're happy with using a regex, this\
    \ is shorter and more readable:\n<code>\n\"FooBarBaz\".downcase.gsub(/[a-z]/){|m|\
    \ m.capitalize}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like that one. But I would\
    \ replace `/[a-z]/` with `/([a-z])/` to be able to use more `|` and `?` inside\
    \ the block. Otherwise it's a lot more code and less readable.\n<|/ c |>\n<| c\
    \ |>\nThanks for that.  I've updated the code example accordingly.\n<|/ c |>\n\
    <| a tags=string,ruby dscore=2 |>\n<code>\n\"FooBarBaz\".gsub(/([A-Z])/) {|x|\
    \ x.capitalize}\n=> \"FooBarBaz\"\n</code>\n<|/ a |>\n<| a tags=string,ruby |>\n\
    Just for fun, here's another way:\n<code>\n\"FooBarBaz\".gsub(/(?<!\\w)([A-Z])/)\
    \ {|m| m.capitalize}\n</code>\nThe ", "  new_string = string.dup.downcase\n  new_string.gsub!(/\\\
    b([a-z])/) do |match|\n    match.toupper()\n  end\n  new_string.gsub!(/\\b([A-Z])/)\
    \ do |match|\n    match.tolower()\n  end\n  new_string\nend\n</code>\nThe gsub!\
    \ methods are the ones that actually do the replacement, just as we did before.\
    \ Here's what each one does:\n<code>\nnew_string.gsub!(/\\b([a-z])/) { |match|\
    \ match.toupper}", "  string.gsub(/[a-z]/) { |c| c.upcase }\nend\n</pre>\n<p>\n\
    <i>Note: the Ruby string class does not have a case method, nor does it have an\
    \ upcase or downcase method; \n however, they are provided by ActiveSupport</i></p>\n\
    <pre class=\"prettyprint\"># Example\nflip_case(\"hello\")", "    string.gsub(/(?<=[A-Z])[a-z]/)\
    \ { |x| x.upcase }.gsub(/(?<=[a-z])[A-Z]/) { |x| x.downcase }\nend\n</code>\n\
    In action:\n<code>\n> flip_case(\"hello\")\n\"HELLO\"\n> flip_case(\"Hello\")\n\
    \"HELLO\"\n> flip_case(\"hello world\")\n\"Hello World\"\n> flip_case(\"Hello\
    \ World\")\n\"Hello World\"\n> flip_case(\"Hello world\")\n\"Hello World\"\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,string,ruby-on-rails-3 |>\n<| c |>\nI guess I should\
    \ point out that this approach is a bit fragile in that it depends on certain\
    \ character-sets, which may or may not match with others.\n<|/ c |>\n<| c |>\n\
    If this were my problem I would have used a different approach. :-) Thanks!\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,string,ruby-on-rails-3 |>\nTo make it even\
    \ more robust, you can add a negative lookahead to check for other characters:\n\
    <code>\nstr.gsub(/(?![a-zA-Z0-9])(?<=[a-zA-Z])/) { |m| m.upcase }\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nA little bit of explanation will make this answer better\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,string,ruby-on-rails-3 dscore=3 |>\nAnother\
    \ option:\n<code>\n'aBcD'.gsub(/([^a-zA-Z0-9])/){|s| s.upcase }\n=> \"aBcD\"\n\
    </code>\n<|/ a |>\n<| c |>\nThis has the problem of replacing \"aBcD\" with \"\
    ABCD\", which is not what the OP wants. The question also asks how to replace\
    \ all lowercase letters to uppercase, so this also misses the point of the question.\n\
    <|/ c |>\n<| c |>\nI believe this should be the accepted answer, because it doesn't\
    \ miss the point of the question. Yes, the OP asked how to turn all lowercase\
    \ letters into uppercase letters, but this solution is just for lowercase letters.\n\
    <|/ c |>\n<| a dscore=3 tags=ruby,ruby-on-rails,string,ruby-on-rails-3 |>\nIn\
    \ case you don't want to mess with regexes you can go for something like this:\n\
    <code>\n def upcase_", "  string.downcase!\n  string.upcase!\nend", "  string.chars.map\
    \ { |c| c =~ /[a-z]/i ? c.upcase : c.downcase }\nend", "    string.gsub!('a'..'z',\
    \ 'A-Z')\n    string.gsub!('A'..'Z', 'a-z')\n    string.upcase!\nend", "  new_string\
    \ = string.dup\n  new_string.gsub!(/[a-z]/) { |c| c.upcase }\n  new_string.gsub!(/[A-Z]/)\
    \ { |c| c.downcase }\n  new_string.downcase!\nend", "  string.downcase! if string\
    \ != ''\n  string\nend", "  string.downcase! # Downcase the string.\n  string.upcase!\
    \ # Upcase the string.\n  string.swapcase! # Swap lowercase and uppercase.\n \
    \ string\nend\n</code>\nThe code above is more succinct and readable, but to make\
    \ it as efficient as possible, you should avoid using methods that do more than\
    \ you need to (downcase, upcase, swapcase!).\nYou can replace these methods with\
    \ built-in methods to reduce the amount of work:\n<code>", "  if string == nil\n\
    \    string\n  elsif string == \"\"\n    string\n  else\n    string.downcase\n\
    \  end\nend", "  case string\n  when 'yes'\n    'Yes'\n  when 'no'\n    'No'\n\
    \  when 'nope'\n    'Nope'\n  when 'maybe'\n    'Maybe'\n  when 'i'\n    'I'\n\
    \  when 'o'\n    'O'\n  when 'up'\n    'Up'\n  when 'down'\n    'Down'\n  when\
    \ 'left'\n    'Left'\n  when 'right'\n    'Right'\n  when 'forward'\n    'Forward'\n\
    \  when 'backward'\n    'Backward'\n  when 'stop'\n    'Stop'\n  when 'backwards'\n\
    \    'Backwards'\n  when 'forwards'\n    'Forwards'\n  when 'turn'\n    'Turn'\n\
    \  when 'stops'\n    'Stops'\n  when 'back'\n    'Back'\n  when 'forward'\n  \
    \  'Forward'\n  when 'left'\n    'Left'\n  when 'right'\n    'Right'\n  when 'rights'\n\
    \    'Rights'\n  when 'lefts'\n    'Lefts'\n  when 'up'\n    'Up'\n  when 'down'\n\
    \    'Down'\n  when 'ups'\n    'Ups'\n  when 'downs'\n    'Downs'\n  when 'upward'\n\
    \    'Upward'\n  when 'downward'\n    'Downward'\n  when 'upwards'\n    'Upwards'\n\
    \  when 'downwards'\n    'Downwards'\n  when 'left'\n    'Left'\n  when 'right'\n\
    \    'Right'\n  when 'lefts'\n    'Lefts'\n  when 'rights'\n    'Rights'\n  when\
    \ 'down'\n    'Down'\n  when 'downs'\n    'Downs'\n  when 'left'\n    'Left'\n\
    \  when 'right'\n    'Right'\n  when 'up'\n    'Up'\n  when 'lefts'\n    'Lefts'\n\
    \  when 'rights'\n    'Rights'\n  when 'upward'\n    'Upward'\n  when 'downward'\n\
    \    'Downward'\n  when 'left'\n    'Left'\n  when 'right'\n    'Right'\n  when\
    \ 'forward'\n    'Forward'\n  when 'backward'\n    'Backward'\n  when 'forwards'\n\
    \    'Forwards'\n  when '", "  string.downcase!\n  string.upcase!\nend\n</code>\n\
    And lastly the test cases. This is what a test case looks like.\n<code>", "  return\
    \ string.gsub(/[a-z]/) do |char|\n    if char == char.downcase\n      char.upcase\n\
    \    else\n      char\n    end\n  end\nend", "    string.downcase!\nend", "  return\
    \ string.gsub(/[a-z]/) do |word|\n    word.upcase + word.downcase\n  end\nend\n\
    </code>\n<|/ a |>\n<| c |>\nHi Roger, I am afraid I have not been able to get\
    \ that to work. I have added the code you suggested above and also the code you\
    \ suggested to the original question. I am not getting any error messages but\
    \ I am not getting the expected output. Would you mind taking another look?\n\
    <|/ c |>\n<| c |>\nI used `puts` instead of `print` because `print` is printing\
    \ to `stdout` and I don't see any output from the program when `puts` is used.\n\
    <|/ c |>\n<| c |>\nThanks for the suggestion. I have added the code to the original\
    \ question. I am still not getting anything but I am not sure what I am doing\
    \ wrong.\n<|/ c |>\n<| c |>\nIt looks like the regex isn't matching `b`. Maybe\
    \ try `/b/` instead?\n<|/ c |>\n<| c |>\nThanks. That didn't work either. I am\
    \ so frustrated. I tried the code above and got the same results. I don't get\
    \ what I am doing wrong.\n<|/ c |>\n<| a dscore=0 |>\nI haven't found the solution\
    \ to my problem yet but I have made some changes to my code which makes it work.\
    \ I tried using the suggested code from above and got the same results.\nMy code:\n\
    <code>\n  require 'nokogiri'", "  string.upcase.downcase\nend\n</code>\nYou didn't\
    \ tell us what the program should do so I will leave that as an exercise.\n<|/\
    \ a tags=ruby,methods,string |>\n<| c |>\nThank you sir! This is very helpful.\n\
    <|/ c |>\n<| a dscore=1 |>\nMy answer is:\n<code>", "  string.gsub(/./) { |char|\
    \ char.upcase != char.downcase ? char.downcase : char.upcase }\nend\n</code>\n\
    Now, to answer your questions:", "  string.tr(\"[a-z]\", \"[A-Z]\")\n  string.tr(\"\
    [A-Z]\", \"[a-z]\")\nend", "  string.downcase!\nend\n</code>\nThen, we can write\
    \ the code to do what you want:\n<code>", "  string.downcase!\n  string.upcase!\n\
    end\n</code>\nTo make the problem easier, let's make a file with the names of\
    \ all of the people in your list with one name per line:\n<code>\nJohn\nAdam\n\
    Alan\nBill\n</code>\nThen, just add this code to your Ruby file:\n<code>", " \
    \ string.chars.map { |c| c.downcase == c.upcase ? c.upcase : c.downcase }.join\n\
    end\n</code>\nThe above method will convert \"hello\" to \"Hello\".\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\nI was able to come up with a method that works for Ruby\
    \ 2.5.1+ with the upcoming 2.6.0 release:\n<code>", "  string.downcase!\n  string.upcase!\n\
    \  string\nend", "  string.downcase!\nend", "  # Split the string into an array\
    \ of characters.\n  chars = string.split(//)\n  # Empty string if there are no\
    \ characters to flip.\n  return chars.empty? ? string : chars.map{|c| c.swapcase}.join\n\
    end", "  result = string.downcase\n  result === string.upcase ? string.swapcase\
    \ : result\nend", "  string.downcase! if string.respond_to?(:downcase)\n  string.upcase!\
    \ if string.respond_to?(:upcase)\n  string\nend\n</code>\n<|/ a tags=ruby,regex\
    \ |>\n<| a dscore=2 |>\nI find that in general regexes aren't always the best\
    \ solution for this sort of problem. Regexes tend to be less readable, and if\
    \ you need an easy solution it might be a sign that you should rethink the problem\
    \ itself.\nHere's a solution that just reverses two characters in each matched\
    \ block:\n<code>", "  string.gsub! /[a-z]/i, '\\U$&'\n  string.gsub! /[A-Z]/i,\
    \ '\\L$&'\n  string\nend", "  string.downcase!\n  string.upcase!\n  string\nend",
  "  string.split(' ').map { |w| w.downcase }.join(\" \")\nend", "  string.gsub(/./)\
    \ { |c| c.upcase == c.downcase ? c.downcase : c.upcase }\nend", "  string.chars.map\
    \ do |char|\n    char =~ /[a-z]/i ? char.upcase : char.downcase\n  end.join(\"\
    \")\nend\n</cell>\n<text>\nRemoving punctuation\nLet's define a method that removes\
    \ punctuation characters from a string:", "  string.gsub!(/[a-z]/) { |l| l.upcase\
    \ }\n  string.gsub!(/[A-Z]/) { |u| u.downcase }\nend", "  string.downcase!\n \
    \ string.upcase!\nend", "  string.downcase!\n  string.upcase!\n  string\nend",
  "  string.downcase.gsub(/./) { |char| char.upcase }\nend", "  string.downcase! unless\
    \ string == nil\n  string.upcase!\nend", "  result = string.dup\n  result.gsub!(/./)\
    \ do |s|\n    match = s.match(/^[a-z]/)\n    match.nil? ? s : s[0...match.end].upcase\
    \ + s[match.end..-1].downcase\n  end\n  result\nend\n</code>\nThe method gsub!\
    \ takes two arguments: the first is a regular expression, and the second is a\
    \ block. The gsub! method replaces all instances of the regular expression with\
    \ what's inside the block (which itself is a block). The regular expression matches\
    \ any character in the string, because . matches every character except newline\
    \ characters.\nThe regular expressions inside the block is written as a string.\
    \ Each block argument gets executed once for each match in the string. The first\
    \ argument of the block is the match (which can be referred to as s). We can use\
    \ a regular expression literal instead of a string literal (which allows us to\
    \ use a shorter syntax):\n<code>\nresult = 'abcde'\nresult.gsub!(/./) do |s|\n\
    \  s[0...1] + s[2..-1].upcase + s[3]\nend\nputs result", "  case string\n  when\
    \ 'hello'\n    'Hello'\n  when 'world'\n    'World'\n  else\n    string\n  end\n\
    end\n</code>\nNow you can simply do something like this:\n<code>\nflip_case('hello')",
  "  string.downcase! if string =~ /[A-Z]/\n  string.upcase! if string =~ /[a-z]/\n\
    \  string\nend", "  string.gsub(/([a-z])/) { $1.upcase }\nend", "  string.downcase!\n\
    \  string.upcase!\n  string\nend", "  string.downcase!\n  string.upcase!\nend",
  "  string.downcase!\n  string.reverse!\n  string.upcase!\nend\n</code>\nNow you\
    \ can see where your error is occurring.\n<code>", "  string.gsub(/./) { |x| x.upcase\
    \ == x.downcase ? x.downcase : x.upcase }\nend\nflip_case(\"This IS a test!\"\
    ) # => \"ThIs Is A TeSt!\"\nflip_case(\"ThiS is a test!\") # => \"ThIs Is A TeSt!\"\
    \n</code>\n<|/ a tags=ruby,string,ruby-on-rails |>\n<| a dscore=5 |>\n<code>\n\
    require 'active_support'\n\"This is my string\".downcase\n</code>\n<|/ a tags=ruby,string,ruby-on-rails\
    \ |>\n<| c |>\nDoesn't work for non-ASCII strings: `'\xB5'.downcase #=> \"\\u03bc\"\
    `\n<|/ c |>\n<| c |>\nThis has nothing to do with the OP's question!\n<|/ c |>\n\
    <| a dscore=4 tags=ruby,string,ruby-on-rails |>\nAnother option:\n<code>\n\"Hello\
    \ World\".downcase"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
