name: HumanEval_66_digitSum
language: rb
prompt: "# Task\n# Write a function that takes a string as input and returns the sum\
  \ of the upper characters only'\n# ASCII codes.\n# Examples:\ndef digitSum(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digitSum\n\
  \    candidate = method(:digitSum)\n    assert_equal(0, candidate.call(\"\"))\n\
  \    assert_equal(131, candidate.call(\"abAB\"))\n    assert_equal(67, candidate.call(\"\
  abcCd\"))\n    assert_equal(69, candidate.call(\"helloE\"))\n    assert_equal(131,\
  \ candidate.call(\"woArBld\"))\n    assert_equal(153, candidate.call(\"aAaaaXa\"\
  ))\n    assert_equal(151, candidate.call(\" How are yOu?\"))\n    assert_equal(327,\
  \ candidate.call(\"You arE Very Smart\"))\n  end\nend\n"
completions: ["  sum = s.split(//).map{|d| d.to_i + (d.ord >= 'a' && d.ord <= 'z'\
    \ ? -d.ord : 0)}.sum\nend", "    sum = 0\n    s.each {|x| sum += x.ord - 96 if\
    \ x.ord >= 48 and x.ord <= 57}\n    return sum\n</code>\n<|/ a dscore=0 tags=ruby,python,ruby-on-rails\
    \ |>\n<| a |>\n<code>", "  s.each_char.inject(0) { |sum, char| sum + char.upcase\
    \ }\nend", "  sum = 0\n  s.chars.each { |c| sum += (c >= 'A' && c <= 'Z') ? c\
    \ : '?' }\n  sum\nend\nputs digitSum('abcef')", "    return sum(map(lambda x :\
    \ ord(x) - ord('A') + 1, s))", "  sum = 0\n  s.each_byte do |x|\n    if x >= 0\
    \ && x < 0x20\n      sum += x\n    end\n  end\n  return sum\nend", "  # write\
    \ your code!\n  return 0", "    sum = 0\n    s.each { |c| sum += c if c.upcase\
    \ == c }\n    sum\nend", "  sum = 0\n  s.chars.each do |c|\n    sum += c if c.upcase\
    \ <= 'Z'.ord \n  end\n  return sum\nend", "  return s.inject(0) { |sum, n| sum\
    \ + n.to_i.digit }\nend", "  result = 0\n  s.each_char do |c|\n    result += c.ord\
    \ - 'A'.ord\n  end\n  result\nend", "    return sum((ord(letter) - ord('A') +\
    \ 1) * 1 for letter in s)", "  sum = 0\n  s.each_byte do |b|\n    sum += b if\
    \ b.between?(48, 58)\n  end\n  sum\nend", "    sum = 0\n    s.chars.each do |c|\n\
    \        if c >= 'A' && c <= 'Z'\n            sum += c\n        end\n    end\n\
    \    return sum\nend", "  return s.upto('Z').inject(:+)\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ dscore=0 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  sum\
    \ = s[0]\n  (0...s.length).each do |i|\n    sum += s[i].ord - 48 if s[i].ord >=\
    \ 48 and s[i].ord <= 57\n  end\n  sum\nend", "    return s.upto('a').sum # or\
    \ s.upto('z').sum, same thing\nend", "    s.each_char.map {|i| i.to_i.upcase}.inject\
    \ {|s, i| s + i}\nend", "  sum = 0\n  for i in s.split(//).collect { |d| d.to_i\
    \ }\n    sum += i\n  end\n  return sum\nend", "    return s.each_char.inject(0)\
    \ {|s, n| n + n.upcase if n.is_a?(String) }.to_s\nend", "  total = 0\n  for i\
    \ in s\n    if i.upcase == true\n      total += i.value\n    end\n  end\n  return\
    \ total\nend", "  sum = 0\n  s.each_char { |c| sum += (c.ord - 48) } # c - '0'\
    \ is ascii code for '0'\n  sum\nend", "    count = 0\n    digit = s.chars.map\
    \ { |x| x.ord }\n    digits.each do |x|\n        if x >= 48 && x <= 57 then count\
    \ += 1\n    end\n    return count\nend", "  sum = 0\n  s.upcase.each_byte { |c|\
    \ sum += c }\n  sum\nend", "    sum = 0\n    count = 0\n    while count < s.length\n\
    \        sum += (s.codepoint_at(count) - 32)\n        count += 1\n    end\n  \
    \  return sum\nend\nputs digitSum(\"Hello, world!\")", "    sum = 0\n    chars\
    \ = s.split(//)\n    chars.each{|x| sum += x.to_i}\n    return sum\nend", "  return\
    \ s.to_i.sum\nend", "    sum = 0\n    digits = s.split('')\n    for d in digits\n\
    \        sum += d.upcase\n    return sum", "  sum = 0\n  for i in s\n    if (i.isdigit)\n\
    \      sum += i.to_i\n  return sum\n</code>\n<|/ a tags=ruby dscore=2 |>\n<| c\
    \ |>\nYeah! That's a lot more clean. Thank you.\n<|/ c |>\n<| c |>\nActually,\
    \ I did a little bit of research and noticed that you are iterating over `i` twice.\
    \  You can do `sum +=` instead of `sum += i.to_i`.  Also, the `if` statement can\
    \ be written as `if i.isdigit`.\n<|/ c |>\n<| c |>\nyeah that's true. Having said\
    \ that, it's kind of unlikely that a string containing only digits would contain\
    \ numbers in non-integer forms. Probably a good idea to include that check in\
    \ the method.\n<|/ c |>\n<| a tags=ruby |>\nA more \"pure\" Ruby implementation\
    \ would use the String#chars method to return an array of the characters in the\
    \ string. The array can be passed to Array#sum to get the sum of the elements.\n\
    <code>", "    total = 0\n    s.chars.each { |c| total += c if c.upcase >= 'A'\
    \ && c.upcase <= 'Z' }\n    total\nend", "  s.chars.map(&:to_i).inject(:+)\nend\n\
    </cell>\n<cell>\ndigitSum(\"AAPL\")\n</cell>\n<cell>\ndigitSum(\"BbBzZzZz\")\n\
    </cell>\n<text>\nMap, Reduce & Filter\nNone reduce", "  sum = 0\n  s.each_char\
    \ do |c|\n    sum += c if c >= 'A' && c <= 'Z'\n  end\n  return sum\nend\nprint\
    \ digitSum(ARGV[0]) # => 9", "  # Write your code here.\n  sum = 0\n  s.each_byte\
    \ do |c|\n    sum+= c if c.ord == 0x20 # checking for uppercase\n  end\n  return\
    \ sum\nend", "  return s.to_s.chars.reduce(:+)\nend\n</cell>\n<cell>\ndigitSum(\"\
    1234567890\")\n</cell>\n<cell>", "    sum = 0\n    for i in s\n        if i.to_i\
    \ > 48\n            sum += i.to_i - 48\n        end\n    end\n    return sum\n\
    end", "  digits = Array.new\n  digitSum = 0\n  s.each { |x| digitSum += x.ord\
    \ }\n  digitSum\nend", "    sum = 0\n    i = 0\n    while i < s.length\n     \
    \   sum = sum + s.codePointAt(i)\n        i = i + 1\n    return sum\nend", " \
    \   sum = 0\n    for i in 0...s.length()-1\n        if s[i].upcase > s[i].downcase\n\
    \            sum += s[i].upcase\n        end\n    end\n    return sum\nend", " \
    \ s = 0\n  i = 0\n  while i < s.length\n    if s[i] >= 48 && s[i] <= 57\n    \
    \  s = s + s[i]\n      i += 1\n    end\n  end\n  \n  return s\nend", "    # Write\
    \ your code here\n    return s.to_i.reduce(:+)\nend", "    s = s.downcase\n  \
    \  sum = 0\n    begin\n        if s.include? \"-\"\n            sum -= (s.index\
    \ % 2) - 32\n        end\n        if s.include? \" \"\n            sum -= \" \"\
    \n        end\n        sum += s.to_i \n        s << \" \"\n    end\n    return\
    \ sum\nend", "  sum = 0\n  s.split('').each do |char|\n    sum = sum + char.upcase\
    \ if char >= '0' && char <= '9'\n  end\n  return sum\nend", "  sum = 0\n  s.each\
    \ do |char|\n    if (char.upcase >= 'A') && (char.upcase <= 'Z')\n      sum +=\
    \ char.upcase.to_i\n    end\n  end\n  sum\nend", "    sum = 0\n    for c in s\n\
    \        sum = sum + ord(c)\n    return sum", "    sum = 0\n    s.each_char {\
    \ |c| sum += c if c.upcase == c}\n    return sum\nend", "  total = 0\n  for c\
    \ in s\n    if c >= 'A' and c <= 'Z'\n      total += c - 'A'\n    end\n  end\n\
    \  total\nend", "  sum = 0\n  for i in s\n    sum += ord(i)\n  end\n  sum\nend",
  "    sum = 0\n    sum = sum(ord(char) for char in s)\n    return sum", "    sum\
    \ = 0\n    for d in s\n        if d.to_i >= 48 and d.to_i < 58\n            sum\
    \ += d.to_i - 48\n        end\n    end\n    return sum\nend\n</cell>\n<code language=julia-1.5>",
  "    return s.scan(/./).reduce(:+)\nend\n</cell>\n<text>\nString#chars", "  return\
    \ s.chars.map(&:ord).inject(:+)\nend", "  sum = 0\n  for c in s\n    if c >= '0'\
    \ and c <= '9'\n      sum += c\n  return sum\n  ", "    # Write your code here\n\
    \    #return sum(int(i) for i in s)\n    return sum((ord(i)-97)*(ord(i)-97) for\
    \ i in s)", "  sum = 0\n  s.each_byte {|e| sum += e} \n  sum\nend", "  return\
    \ s.reduce(:+)\nend", "  s.upto('', :ascii_upper).inject(0) { |sum, ch| sum +\
    \ ch.to_i }\nend\n</code>\n<|/ a dscore=3 |>\n<| a |>\nI thought I might add a\
    \ little bit more of an explanation to the accepted answer.\nThe upto method of\
    \ the String class takes in a range, in this case from empty to :ascii_upper.\
    \ Which means that if you pass it an empty string, the method will return the\
    \ empty string. \n<code>\n\"\".upto('', :ascii_upper)", "  sum = 0\n  s.downcase.split(\"\
    \").each do |char|\n    sum = sum + (ord(char) - 96) if char >= 'a' && char <=\
    \ 'z'\n  end\n  return sum\nend\nputs digitSum(\"asd12asd1\")", "\tsum = 0\n\t\
    for i in (s.upcase)\n\t   sum += i.ord\n\t   end\n\treturn sum\nend", "  sum =\
    \ 0\n  s.each_char do |char|\n    sum += char.to_i\n  end\n  sum\nend\nassert\
    \ digitSum('123') == 5\nassert digitSum('abc') == 12\nassert digitSum('abcde')\
    \ == 10\nassert digitSum('') == 0\nassert digitSum(123) == 0\nassert digitSum(null)\
    \ == 0\nassert digitSum(true) == 0", "  sum = 0\n  for i in 0..s.length\n    if\
    \ i.to_s.scan(/\\d/).join.length.to_i < 10\n      sum += i.to_s.scan(/\\d/).join.length.to_i\n\
    \    end\n  end\n  return sum\nend\nassert digitSum(\"1234567\") == 18\nassert\
    \ digitSum(\"a1b3c\") == 3\nassert digitSum(\"aaaabc\") == 3\nassert digitSum(\"\
    aaabbc\") == 3\nassert digitSum(\"abcde\") == 6\nassert digitSum(\"abc\") == 3\n\
    assert digitSum(\"abc123\") == 6\nassert digitSum(\"abcd\") == 3\nassert digitSum(\"\
    abcd123\") == 6\nassert digitSum(\"z\") == 0 ", "  result = s.to_s.gsub(/[^\\\
    d]/, \"\").inject(0) { |sum, char| sum + char.ord }\n  puts result\nend\ndigitSum('hello')\n\
    digitSum('1+1')\ndigitSum('1+1+1+1+1+1+1+1+1')\ndigitSum('1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+",
  "\tsum = 0\n\tfor i in s: sum += ord(i)\n\treturn sum\nprint digitSum('Python')",
  "    return s.upcase.split('').sum { |c| c.codepoint }\nend", "  # TODO: Write a\
    \ for loop to iterate through each character in the string\n  # TODO: Test each\
    \ character against the ASCII codes\n  # TODO: Add up only the digital characters\n\
    \  # TODO: Return the total sum\nend", "  sum = 0\n  s.upcase {|c| sum += (c -\
    \ '0') }\n  sum\nend", "    sum = 0\n    for ch in s:\n        if ch.isupper():\n\
    \            sum += ch\n    return sum", "  sum = 0\n  for i in s.chars\n    sum\
    \ += i.ord - 'A'.ord\n  end\n  sum\nend", '# Write a function that takes a string
    as input and returns the sum of the digits in a string.', "  # TODO: Write your\
    \ code here\n  return 0", "   s.upcase!\n   s.scan(/./).map { |x| x.to_i }.inject\
    \ { |sum, v| sum + v }\nend", "  s.downcase!\n  s.gsub!('a',0)\n  s.gsub!('b',0)\n\
    \  s.gsub!('c',0)\n  s.gsub!('d',0)\n  s.gsub!('e',0)\n  s.gsub!('f',0)\n  s.gsub!('g',0)\n\
    \  s.gsub!('h',0)\n  s.gsub!('i',0)\n  s.gsub!('j',0)\n  s.gsub!('k',0)\n  s.gsub!('l',0)\n\
    \  s.gsub!('m',0)\n  s.gsub!('n',0)\n  s.gsub!('o',0)\n  s.gsub!('p',0)\n  s.gsub!('q',0)\n\
    \  s.gsub!('r',0)\n  s.gsub!('s',0)\n  s.gsub!('t',0)\n  s.gsub!('u',0)\n  s.gsub!('v',0)\n\
    \  s.gsub!('w',0)\n  s.gsub!('x',0)\n  s.gsub!('y',0)\n  s.gsub!('z',0)\n  s.to_i.inject(0)\
    \ {|sum, n| sum + n }\nend\n</cell>\n<cell>\nputs digitSum(\"abcde\").inspect\n\
    </cell>\n<cell>\nputs digitSum(\"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"\
    ).inspect\n</cell>\n<cell>\nputs digitSum(\"1234567890\").inspect\n</cell>\n<cell>",
  "    return s.to_s.chars.inject(0){|sum,c| sum+c.ord - 'A'.ord}\nend\ndigitSum(\"\
    abc\")", "    # Write your solution here.\n    sum = 0\n    for c in s:\n    \
    \    if c.isupper():\n            sum += ord(c)\n    return sum", "  s.upcase!\
    \ # convert to Upcase\n  s.chars.inject(0) {|sum, ch| sum + ch.ord }\nend\nputs\
    \ digitSum(\"Seamus\") # => 42\nputs digitSum(\"Seamusseamus\") # => 42", "  total\
    \ = 0\n  for i in s\n    total += i.ord - 48\n  return total", "  sum = 0\n  for\
    \ i in [char.ord for char in  s]\n     sum+=i\n  end\n  sum\nend\nprint digitSum(\"\
    123\") #=> 6\nprint digitSum(\"1234\") #=> 7\nprint digitSum(\"12345\") #=> 8\n\
    print digitSum(\"12\") #=> 6\nprint digitSum(\"123a\") #=> 9", "    sum = 0\n\
    \    for c in s\n        if c.upcase == true\n            sum += c\n    \n   \
    \ return sum", "    sum = 0\n    for i in 0...s.length\n        sum+=ord(s[i])-64\n\
    \    sum\nend", "  s.upcase.gsub(/[^0-9]/, '').to_i\nend", "    return s.sum(s.map(&:to_i).map(&:upper).sum\n\
    end\nputs digitSum('hello')\nputs digitSum('123')\nputs digitSum('123abc')\nputs\
    \ digitSum('abc123')\n</cell>\n<text>\n2. Methods\nLet's talk about methods in\
    \ Ruby.", "  s.chars.reduce(0) {|s, c| s + c if c.upcase == c}\nend", "  # TODO:\
    \ write your code here\n  sum = 0\n  for i in s\n    sum = sum + i\n  end\n  return\
    \ sum\nend", "    total = 0\n    for c in s\n        total += c.ord - 48\n   \
    \ end\n    return total\nend\n</cell>\n<cell>\ndigitSum(\"123 454 765 891 \")\n\
    </cell>\n<cell>\ndigitSum(\"123\")\n</cell>\n<cell>\ndigitSum(\"1-2345678901\"\
    )\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"\
    123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\n\
    digitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n\
    <cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\"\
    )\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"\
    123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\n\
    digitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n\
    <cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\"\
    )\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"\
    123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\n\
    digitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\")\n</cell>\n\
    <cell>\ndigitSum(\"123-456-78901\")\n</cell>\n<cell>\ndigitSum(\"123-456-78901\"\
    )\n</cell>\n<cell>\ndigitSum(\"123-45", "    count = 0\n    for i in s\n     \
    \   if i.upcase >= 'A'.upcase and i.upcase <= 'Z'.upcase then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "    sum = 0\n  \
    \  digits = s.split('')\n    \n    for d in digits\n        sum += (d.to_i)\n\
    \    end\n    \n    return sum\nend", "  s.downcase!\n  s.gsub!(/[\\d]/, '')\n\
    \  s.chars.each_with_index.inject(:+) do |sum, (x, y)| sum += y.ord end\nend",
  " digits = Array.new\n s.chars.each_with_index { |x,i| digits << x.ord } # Convert\
    \ to chars array, add each char to chars array\n return digits.inject(0) { |sum,x|\
    \ sum + x } # Sum chars array and return sum\nend\nputs digitSum(\"hello\")",
  "    sum = 0\n    s.each_char do |c|\n        if c >= 'a' && c <= 'z'\n        \
    \    sum += c.ord - 'a'\n        end\n    end\n    return sum\nend", '# Return
    sum of digits in s', "    sum = 0\n    for c in s:\n        if c >= 'A' and c\
    \ <= 'Z':\n            sum += ord(c) - ord('A')\n    return sum", "    sum = 0\n\
    \    for i in s\n        if (i.upcase >= 'A'.upcase && i.upcase <= 'Z'.upcase)\n\
    \            sum += i.upcase\n    end\n    return sum\nend", "  sum = 0\n  s.chars.each\
    \ do |c|\n    sum += c if c.upcase >= 'A'.upcase && c.upcase <= 'Z'.upcase\n \
    \ end\n  sum\nend", "  s.chars.map {|c| c.ord - 'A'.ord}.inject(0, &:+)\nend",
  "  sum = 0\n  s.each_byte do |b|\n    sum += b if b.between?(48..57)\n  end\n  return\
    \ sum\nend", "  # Solution code here\n  return sum\nend", "    # Your code here\n\
    \    return s.map(&:ord + 0)\nend", "    sum = 0\n    if s.is_a? Integer\n   \
    \     sum\n    elsif s.is_a? String\n        sum = 0\n        s.chars.each do\
    \ |char|\n            sum += char.ord - 96 if char >= 'A' && char <= 'Z'\n   \
    \     end\n        sum\n    else\n        0\n    end\nend\n</cell>\n<text>\nNow\
    \ we can run our function on our task by simply inputting our string:", "    #\
    \ Write code here\n    # Return 0\n    sum = 0\n    for i in s:\n        if i.isupper:\n\
    \            sum += ord(i)\n    return sum\n</code>\nOutput\n<code>\nprint(digitSum(\"\
    abcd\"))  # -> 6\nprint(digitSum(\"aBcD\"))  # -> 6\nprint(digitSum(\"abdE\"))\
    \  # -> 6\n</code>\n<|/ a tags=python,string,algorithm |>\n<| a |>\nMy attempt:\n\
    <code>", '  # Write your code here', "  s.chars.map { |c| c.to_i(16).to_s + c.to_s\
    \ }.reduce(''.succ => :+) \nend", "    return s.chars.inject(:+)\nend", "  # Write\
    \ your code here\n  return nil # or something very simple\nend", "  sum = 0\n\
    \  s.each_byte { |c| sum += c if c >= 32 } \n  sum\nend\np digitSum('asdfghjkl')\n\
    p digitSum('1234567')\np digitSum('abcd')\np digitSum(\"A'b'cd\") # Ruby single\
    \ quotes\np digitSum(\"A'b'c\") # Ruby double quotes\np digitSum('abccc') # Ruby\
    \ single quote string with single quotes\np digitSum('abccc') # Ruby double quote\
    \ string with single quotes\np digitSum(\"A'b'cd\")\np digitSum(\"A'b'c\")\np\
    \ digitSum('abccc')\np digitSum('abcc')\np digitSum('abcc')\np digitSum('abcc')\n\
    p digitSum(\"A'b'cd\")\np digitSum(\"A'b'c\")\np digitSum('abccc')\np digitSum('abcc')\n\
    p digitSum(\"A'b'cd\")\np digitSum(\"A'b'c\")\np digitSum('abccc')\np digitSum('abcc')\n\
    p digitSum('abcc')\np digitSum('abcc')\np digitSum('abcc')\np digitSum('abcc')\n\
    p digitSum('abcc')\np digitSum('abcc')\np digitSum('abcc')\np digitSum('abcc')\n\
    p digitSum('abcc')\np digitSum('abcc')\np digitSum(\"A'b'cd\")\np digitSum(\"\
    A'b'c\")\np digitSum('abccc')\np digitSum(\"A'b'cd\")\np digitSum(\"A'b'c\")\n\
    p digitSum('abccc')\np digitSum('abcc')\np digitSum(\"A'b'cd\")\np digitSum(\"\
    A'b'c\")\np digitSum('abccc')\np digitSum(\"A'b'cd\")\np digitSum(\"A'b'c\")\n\
    p digitSum('abccc')\np digitSum('abcc')\np digitSum(\"A'b'cd\")\np digitSum(\"\
    A'b'c\")\np digitSum('abccc')\np digitSum('abcc')\np digitSum(\"A'b'cd\")\np digitSum(\"\
    A'b'c\")\np digitSum('abccc')\np digitSum('ab", " sum = 0\n s.chars.each do |e|\n\
    \  if e.chr >= 'A' && e.chr < 'Z'\n   sum = sum + e.chr.to_i\n  end\n end\n return\
    \ sum\nend\nprint digitSum(\"abc-123\")", "  sum = 0\n  for c in s\n    if c.upcase\
    \ == true\n      sum = sum + c.code\n    end\n  end\n  sum\nend", "  sum = 0\n\
    \  for i in s.chars\n    if i.upcase >= 48 && i.upcase <= 57\n      sum += i.upcase\n\
    \    end\n  end\n  return sum\nend", "  s.downcase!\n  sum = 0\n  s.each do |c|\n\
    \    sum += c >= 48 && c <= 57 ? c : c-32\n  end\n  sum\nend", "    s = 0\n  \
    \  # iterate over each character in string\n    s.each_byte do |d|\n        if\
    \ (d.ord == 48) or (d.ord == 57) then\n        s += d.ord\n        end\n    end\n\
    \    return s\nend", "  sum = 0\n  s.each_char do |char|\n    if char >= 65 &&\
    \ char <= 90\n      sum += char\n    end\n  end\n  return sum\nend", "  sum =\
    \ 0\n  s.each { |c| sum += c.ord if c.ord >= 48 && c.ord <= 57 }\n  sum\nend",
  "   sum = 0\n   for i in s\n      sum = (sum + ord(i)-96)\n   return sum", "   \
    \ sum = 0\n    for i in s\n        if i.upcase >= 'A'\n            sum += 1\n\
    \    return sum\n</code>\nThe function digitSum takes one parameter - the string\
    \ - and returns the sum of the upper characters in the string. For example, digitSum(\"\
    HelloWorld\") returns the number 5, as H + W is 5. The sum of the digits in an\
    \ input string would simply be the length of the string, with digitSum(\"HelloWorld\"\
    ) returning 5 and digitSum(\"abcdefg\") returning 8.\n<|/ a tags=ruby,string dscore=0\
    \ |>\n<| c |>\nI don't want to see a negative vote and I am not the one who downvoted\
    \ your answer, but I think I might have misunderstood the question. I don't think\
    \ you understood how to find the sum of only the first upper case letters in a\
    \ string. Do you know how to do this or do you think my solution is better?\n\
    <|/ c |>\n<| c |>\nI think I understand your question now. My solution assumes\
    \ that a string is given as an input. If this is not the case, then my solution\
    \ would have to be modified to handle a different situation - for example, it\
    \ would be necessary to convert every letter in the string to lowercase prior\
    \ to doing the sum.\n<|/ c |>\n<| c |>\nI think I understand what you are saying,\
    \ but it is not really the issue. The issue is how to find the sum of uppercase\
    \ characters in a string. My answer gives the correct answer for \"HelloWorld\"\
    , but fails to calculate the sum of uppercase characters in \"abcdefg\" correctly.\
    \ I am not sure why, because in my solution I am checking if the character is\
    \ a uppercase character, and if it is, then I am adding it to a sum variable.\
    \ Shouldn't it be exactly that?\n<|/ c |>\n<| c |>\nI understand that I can modify\
    \ the code to work differently if needed, and I know how I could do that, but\
    \ my question is not so much how to do it but why my solution doesn't work and\
    \ how I can change it to work correctly.\n<|/ c |>\n<| c |>\nAhh ok, now I understand\
    \ your question. Your solution does not work because the character is considered\
    \ a lowercase letter in the first place - and therefore is never added to the\
    \ sum.\n<|/ c |>\n<| a tags=ruby,string |>\nYour code doesn't work because you\
    \ misunderstood how String#sum works. It sums all numbers within a string that\
    \ satisfy a certain condition. So let's see what String#sum does:\n<code>\n\"\
    a\".sum # => 97\n\"a\".sum { |i| i.upcase > 'Z' } # => 97\n</code>\nWhen you pass\
    \ a block to ", "  digitSum = 0\n  s.upcase! # Convert string to uppercase\n \
    \ s.each_char do |c|\n    if c >= '0' && c <= '9'\n      digitSum += c.to_i.to_s\n\
    \    end\n  end\n  digitSum.to_i\nend", "  total = 0\n  for i in s\n    total\
    \ += i if i.upcase == i else 0\n  return total\nend\nprint(digitSum(\"Batman\"\
    ))", "  sum = 0\n  s.each_char do |x|\n    sum += x.upcase if x.upcase >= '0'\
    \ and x.upcase <= '9'\n  end\n  return sum\nend", "    sum = 0\n    digits = s.split(//)\n\
    \    digits.each do |digit|\n        if digit.upcase == digit\n            sum\
    \ = sum + digit.downcase\n        end\n    end\n    return sum\nend", "  sum =\
    \ 0\n  s.each { |i| sum += i.ord }\n  sum\nend\np digitSum(\"1234\")", "  sum\
    \ = 0\n  for i in s\n    sum += i.codepoint.to_i\n  end\n  return sum\nend\nassert\
    \ digitSum(\"ab12c\") == 2\nassert digitSum(\"ab\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\
    \xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8\xF8", "  s.chars.reduce(:+)\nend", "    s = s.downcase.to_s\n\
    \    s.scan(/\\d/)\n    sum = 0\n    s.each { |char| sum += char.ord }\n    return\
    \ sum\nend\n</code>\n<|/ a |>\n<| c |>\nGreat thanks. Any ideas on how to make\
    \ that work on an iPhone? I know ruby is supposed to be able to run on phones\
    \ but it doesn't seem to.\n<|/ c |>\n<| c |>\nIt's a Ruby program and should run\
    \ on a Mac. Did you try the code?\n<|/ c |>\n<| c |>\nSure. It doesn't work. When\
    \ I try to run the file on my phone it crashes and says my app keeps unresponsive.\
    \ It just shows an empty screen.\n<|/ c |>\n<| c |>\nWhat happens when you run\
    \ the program on the phone?\n<|/ c |>\n<| c |>\nIt opens up the simulator and\
    \ then it says it crashed\n<|/ c |>\n<| a tags=ios,ruby-on-rails,ruby dscore=1\
    \ |>\nHere is a solution that works:\n<code>", "  sum = 0\n  s.chars.each do |char|\n\
    \    if (char.upcase >= 'A'.upcase)\n      sum += char.upcase\n    end\n  end\n\
    \  sum\nend\nassert digitSum(\"1ABCdef9\") == 26\nassert digitSum(\"a\") == 0\n\
    assert digitSum(\"HelloWorld\") == 26", "    sum = 0\n    s.each_byte { |d| sum\
    \ += d.to_i }\n    sum\nend", "    sum = 0\n    s.to_i.times do |char|\n     \
    \   sum += char.upcase\n    end\n    return sum\nend\n</cell>\n<cell>\ndigitSum(\"\
    12\")\n</cell>\n<cell>\ndigitSum(\"123\")\n</cell>\n<cell>\ndigitSum(\"ABC\")\n\
    </cell>\n<cell>\ndigitSum(\"\")\n</cell>\n<cell>\ndigitSum(\"123A\")\n</cell>\n\
    <cell>\ndigitSum(\"123ABC\")\n</cell>\n<cell>\ndigitSum(\"ABC123\")\n</cell>\n\
    <text>\nExercise\nWrite a function that takes a number as input and returns the\
    \ sum of the digits (all numbers)", "    sum = 0\n    length = s.length\n    if\
    \ length == 0 || length == 1\n        return s[length]\n    end\n    \n    for\
    \ i in 0...length\n        if s[i] == 'A' || s[i] == 'B' || s[i] == 'C' || s[i]\
    \ == 'D'\n            sum += s[i]\n        end\n    end\n    return sum\nend",
  "\tsum = 0\n\tfor i in (s.upcase)\n\t\tsum = sum + i.to_i\n\tsum\nend", "    sum\
    \ = 0\n    # write your code here", "  # your code here\nend\n</cell>\n<cell>\n\
    digitSum(123)\n</cell>\n<cell>\ndigitSum(\"aBcD\")\n</cell>\n<cell>\ndigitSum(\"\
    aBcD\")\n</cell>\n<cell>\ndigitSum(12345)\n</cell>\n<cell>\ndigitSum(1234567)\n\
    </cell>\n<cell>\ndigitSum(\"aBcD\")\n</cell>\n<cell>\ndigitSum(\"aBcD\")\n</cell>\n\
    <text>\nWrite a function that takes a string as input and returns the sum of the\
    \ decimal digits only'.\nThe decimal characters are the characters '0' to '9'.\n\
    The decimal numbers include leading zeros.\nExamples:\ndigitSum(\"1234\")\ndigitSum(\"\
    aBcD\")\ndigitSum(\"aBcD\")\ndigitSum(\"1234\")\ndigitSum(\"1234567\")", "  sum\
    \ = s.each_char.inject(0) { |sum, c| sum + c.ord - 64}\n  sum\nend", '    return
    sum(map(ord, list(s)))', "    s = 0\n    for c in s:\n        if ord(c) >= ord('A')\
    \ and ord(c) <= ord('Z'):\n            s += ord(c) - ord('A')\n    return s",
  "  sum = 0\n  s.each_byte do |i|\n    if i.chr >= \"A\" && i.chr <= \"Z\"\n    \
    \  sum = sum + i.chr - \"A\".chr\n    end\n  end\n  return sum\nend", "    sum\
    \ = 0\n    for i in s\n        if i >= 48 and i <= 57\n            sum += i \n\
    \    return sum\nprint(digitSum('ABC123'))\n</cell>\n<text>\nTask\nWrite a function\
    \ that takes a string as input and returns the length of the string in its decimal\
    \ form (as opposed to characters).", "  return s.each_char.inject(:+).to_s #.split(\"\
    \").inject(:+)\nend", "  return s.upcase.length\nend", "  # write your solution\
    \ here\n  return s.upcase.sum\nend\ndigitSum(\"abc\")\n</cell>\n<cell>", "   \
    \ sum = 0\n    for c in s:\n        if c >= \"A\" and c <= \"Z\":\n          \
    \  sum += ord(c)\n    return sum", "  sum = 0\n  for i in 0...s.length\n    if\
    \ s[i].upcase >= 'A' && s[i].upcase <= 'Z'\n      sum += s[i].upcase\n    end\n\
    \  end\n  return sum\nend", "    sum = 0\n    for i in s(s) do sum += i end\n\
    \    return sum\nend\n</cell>\n<cell>", "    sum = 0\n    for i in s:\n      \
    \  sum += int(i)\n    return sum", "    sum = 0\n    \n    str = s.to_s\n    str.upcase!\
    \ # Change the string to uppercase", "  s = 0\n  s.each { |i| s += i if i.upcase\
    \ == i.downcase }\n  s\nend", "  sum = 0\n  s.each_byte { |x| sum += (x - 48)\
    \ } \n  sum\nend\n</cell>\n<code language=julia-0.4>\ndigitSum(12345)\n</cell>\n\
    <code language=julia-0.4>\ndigitSum(101)\n</cell>\n<text>\nTask\nWrite a function\
    \ that takes a string as input and returns the number of upper case letters (excluding\
    \ lowercase letters).'\nASCII codes for upper case letters are:\nA-Z = 65-90,\
    \ a-z = 97-122\nExample\n\"HelloWorld\" -> returns 7", "  # TODO: write code here\n\
    end", "    total = 0\n    sum = 0\n    for c in s\n        if 97 <= ord(c) <=\
    \ 122\n            sum += ord(c) - 96\n    total += sum\n    return total", " \
    \   sum = 0\n    s.each_char { |c| sum += c.ord - 'a'.ord }\n    return sum\n\
    end", "  sum = 0\n  s.each do |c|\n    if (c.ord >= 65 && c.ord <= 90)\n     \
    \ sum += c.ord \n    end\n  end\n  return sum\nend", "    count = 0\n    for i\
    \ in range(len(s)):\n        count += s.codePointAt(i)\n    return count\n</code>\n\
    <|/ a dscore=0 tags=python,string |>\n<| c |>\nThis isn't really what I was looking\
    \ for.  I wanted a way to count the characters in a string that were above a certain\
    \ value.\n<|/ c |>\n<| c |>\nI see. Sorry, I misunderstood the problem. Hope you\
    \ find a solution soon. :)\n<|/ c |>\n<| c |>\nNo problem, thank you for your\
    \ help!  It was much appreciated.\n<|/ c |>\n<| a tags=python,string |>\nHere\
    \ is a solution which does what you want, but only in the ASCII range:\n<code>",
  "  # Write your solution here\n  sum = 0\n  i = s.length\n  while i >= 0\n    #\
    \ Write your solution here\n    sum = sum + s.slice(i).upcase.ord\n    i--\n \
    \ end\n  return sum\nend", "  sum = 0\n  for c in s\n    sum += (c.ord >= 48 &&\
    \ c.ord <= 57)\n  end\n  sum\nend", "  return s.chars.reduce(:+)\nend\n</cell>\n\
    <cell>", "  sum = 0\n  s.each_byte { |c| sum += c if c >= '0' && c <= '9' }\n\
    \  sum\nend", '    return sum(int(x) for x in s.upper() if x >= ord("0"))', " \
    \   sum = 0\n    s.each_char do |c|\n        if c>='0' && c<='9'\n           \
    \ sum+=c\n        end\n    end\n    return sum\nend", "  return s.map {|e| e.ord\
    \ }.reduce(:+)\nend\np digitSum(\"hello\")   # => 13\np digitSum(\"A\")      #\
    \ => 65", "  sum = 0\n  s.each_char do |c|\n    if c >= '0' && c <= '9'\n    \
    \  sum += c.to_i\n    end\n  end\n  sum\nend", "  # TODO: Write your solution\
    \ below:\n  return s.inject(0) { |sum, digit| sum + digit.ord }\nend", "  sum\
    \ = 0\n  s.each_char.with_index do |c,i|\n    if c >= '0' && c <= '9'\n      sum\
    \ += c - (c.ord.chr - '0')\n    end\n  end\n  sum\nend\n</code>\nOutput\n<code>\n\
    digitSum(\"foobar\") # => 42\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>\n\"\
    foobar\".downcase.scan(/[a-z]/).map(&:to_i).inject(0, &:+) # => 42\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI understand that you did not downvote me or I did\
    \ not upvote you. I appreciate your effort. `scan` works with regex. It takes\
    \ the given string and converts it to an array. `downcase` converts the string\
    \ into all lower case. `map` applies a function to each element in the array.\
    \ `inject` takes two arguments. `&:+` applies a function that returns the sum\
    \ of the elements in the array. I find this syntax easier to read than `inject(0){|sum,x|\
    \ sum + x}`.\n<|/ c |>\n<| c |>\nOh, I didn't know that. Yes, I did upvote you\
    \ :) Thanks for your effort!\n<|/ c |>\n<| c |>\nThanks, I appreciate your effort!\
    \ I upvoted you. :)\n<|/ c |>\n<| c |>\nThanks again for your help! I still don't\
    \ understand `downcase` but it is a very elegant solution. Thank you!\n<|/ c |>\n\
    <| a tags=ruby |>\nYou can use inject:\n<code>\n\"foobar\".split('').map(&:to_i).inject(0)\
    \ {|sum, x| sum + x}\n</code>\nOr use inject{|sum, x| sum + x.to_i } if you need\
    \ to convert it to integer.\n<|/ a dscore=2 |>\n<| c |>\nIt's not the end of the\
    \ world if your variable names are `sum`, `x` or `y`, but you should change `sum`\
    \ to `sumsum`.\n<|/ c |>\n<| c |>\n`inject` takes an initial value (zero), and\
    \ calls the block with the current value and the value of each element. The block\
    \ is called once for each element and returns the value of the last call. The\
    \ block also returns the initial value.\n<|/ c |>\n<| c |>\nI understand now.\
    \ Thanks for your effort! I upvoted you and you gave an explan", "    total =\
    \ 0\n    for i in s:\n        if i.isupper():\n            total += ord(i)\n \
    \   return total", "    sum = 0\n    for c in s\n        if c.upcase == c.upcase\
    \ \n            sum += c.upcase\n    return sum\nprint(digitSum(\"a1b2c3d4e5\"\
    ))", "  # Your code here\n  s.scan(/\\d/).inject(0) { |sum, n| sum + n.to_i }\n\
    end\nputs digitSum('The quick brown fox jumps over the lazy dog') # => 12", " \
    \ sum = s.chars.inject(0) { |sum, a| sum + a.ord - 'A'.ord }\n  sum\nend", " \
    \   sum = 0\n    \n    for i in s:\n        if i.isupper():\n            sum +=\
    \ ord(i)\n    return sum\nprint(digitSum('hello'))\nprint(digitSum('world'))\n\
    </cell>\n<text>\nTask 14. Reverse the digits of the given integer.\nFor example\
    \ when given an integer 123 the output should be 321.\nRemember that we are talking\
    \ about a digit here and not a decimal or anything like that.", "    s = 0\n \
    \   i = 0\n    while i < s.length\n        s[i] = s[i].upcase # Upper case\n \
    \       s += s[i]\n        i += 1\n    return s\n</cell>\n<cell>\ndigitSum('123\
    \ abc')\n</cell>\n<cell>\ndigitSum(\"AA aa\")\n</cell>\n<text>\nTask\nWrite a\
    \ function that takes two strings s1 and s2 as input and returns the sum of their\
    \ digits.", "    digits = [0]\n    for i in s do\n        if i.isUpper\n     \
    \       digits += i.codePointAt(0)\n    digits.reduce(0, :+)\nend", "  if s ==\
    \ \"\" then return 0\n  sum = 0\n  for i in s do\n    sum = sum + char_code(i)\n\
    \  end\n  return sum\nend", "    # Your code here\n    res = 0\n    for i in s:\n\
    \        if i.isupper():\n            res += ord(i)\n    return res", "\tsum =\
    \ 0\n\tfor character in s\n\t\tif character >= '0' and character <= '9'\n\t\t\t\
    sum += character\n\treturn sum", "  sum = 0\n  for i in 0..s.length - 1\n    if\
    \ i.modulo(10) > 9\n      sum += i.modulo(10)\n    end\n  end\n  return sum\n\
    end\nprint digitSum('1233')\nprint digitSum('abc')\nprint digitSum('1')\nprint\
    \ digitSum(' ')\nprint digitSum('1234567')\nprint digitSum('1')\nprint digitSum('0')\n\
    print digitSum('a')\nprint digitSum('aa')\nprint digitSum('aaa')\nprint digitSum('aaab')\n\
    print digitSum('1234567')\nprint digitSum('123456789')\nprint digitSum('12')\n\
    print digitSum('34')\nprint digitSum('45')\nprint digitSum('5')\nprint digitSum('9')\n\
    print digitSum('9')\nprint digitSum('123456789')\nprint digitSum('123456789')\n\
    print digitSum('1234567890')\nprint digitSum('12345678901')\nprint digitSum('123456789012')\n\
    print digitSum('1234567890123')\nprint digitSum('12345678901234')\nprint digitSum('123456789012345')\n\
    print digitSum('1234567890123456')\nprint digitSum('12345678901234567')\nprint\
    \ digitSum('123456789012345678')\nprint digitSum('1234567890123456790')\nprint\
    \ digitSum('12345678901234567909')\nprint digitSum('123456789012345679098')\n\
    print digitSum('1234567890123456790987')\nprint digitSum('12345678901234567909876')\n\
    print digitSum('123456789012345679098765')\nprint digitSum('1234567890123456790987654')\n\
    print digitSum('12345678901234567909876543')\nprint digitSum('123456789012345679098765432')\n\
    print digitSum('1234567890123456790987654321')\nprint digitSum('12345678901234567909876543211')\n\
    print digitSum('12345678901234567909876543210')\nprint digitSum('123456789012345679098765432101')\n\
    print digitSum('1234567890123456790987654321010')\nprint digitSum('12345678901234567909876543210100')\n\
    print digitSum('123456789012345679098765432101010')\nprint digitSum('1234567890123456790987654321010100')\n\
    print digitSum('12345678901234567909876543210101011')\nprint digitSum", '    return
    sum(int(x) for x in  s if ord(x) > 48 and ord(x) < 58)', "  s.chars.map { |c|\
    \ c.ord - 'A'.ord }.reduce(:+)\nend", "    total = 0\n    for c in s\n       if\
    \ c.upcase >= 'A' and c.upcase <= 'Z'\n           total += c.upcase - 'A' + 10\n\
    \       else\n           total += c.upcase\n    return total\nend", "    return\
    \ s.inject(0) { |sum,i| sum + i.to_i(16) }\nend\np digitSum(\"abcde\") == 14\n\
    p digitSum(\"aacb\") == 1\np digitSum(\"a\") == 0\np digitSum(\"abc\") == 12\n\
    p digitSum(\"abcdefghijklmnopqrstuvwxyz\") == 438\np digitSum(\"0123456789\")\
    \ == 49", "    return sum((ord(c) - ord('0')) for c in s)\n</cell>\n<cell>\ndigitSum('789')\n\
    </cell>\n<cell>\ndigitSum('987')\n</cell>\n<cell>\ndigitSum('123')\n</cell>\n\
    <cell>\ndigitSum('')\n</cell>\n<cell>\ndigitSum('1234567890')\n</cell>\n<cell>",
  "    digitSum = 0\n    for c in s\n        if c.upcase < 64\n            digitSum\
    \ = digitSum + c.upcase\n        end\n    end\n    return digitSum\nend", "  s.upto(\"\
    Z\").inject(:+)\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a |>\n<code>\ns =\
    \ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ns.split('').inject(0, &:succ)", "    count = 0\n\
    \    char = ''\n    sum = 0\n    for i in s:\n        if i.isdigit():\n      \
    \      sum = sum + int(i)\n            count = count + 1\n        else:\n    \
    \        if count > 0:\n                char = char + str(sum)\n             \
    \   sum = 0\n                count = 0\n            else:\n                char\
    \ = char + i\n    return char", "  sum = 0\n  for i in s\n    sum+=i.ord\n  end\n\
    \  return sum\nend", "  s = 0\n  for i in (s.reverse + s).chars\n    if i.upcase\
    \ == i.downcase\n      s += i.upcase \n  end\n  return s\nend", "  s.chars.map\
    \ { |c| c.ord - 'A'.ord }.sum\nend", "  sum = 0\n  s.each_byte do |char| \n  \
    \  sum += char.upcase\n  end\n  return sum\nend", "    sum = 0\n    i = 0\n  \
    \  while i < s.length\n        sum += s.chars.upto(i)\n        i += 1\n    return\
    \ sum\nend", "  return s.map(&:to_i).inject(:+)\nend", "  s = string.split(s)\n\
    \  result = 0\n  for digit in s\n    result += (digit.ord - 'A'.ord)\n  return\
    \ result", "  sum = 0\n  s.each_char { |c| sum += c if c >= '0' && c <= '9' }\n\
    \  return sum\nend\nputs digitSum('012')\nputs digitSum('abcde')\nputs digitSum('10')",
  "  sum = 0\n  s.each do |char|\n    sum = sum + char.upcase \n  end\n  sum\nend",
  "  # Solution\nend", "    sum = 0\n    for c in s\n        if c.upcase?\n      \
    \      sum += c.ord\n    end\n    return sum\nend", "    return s.chars.map(&:ord).inject\
    \ {|sum,i| sum+i}\nend", "    digitSum = 0\n    for i in s\n        if i.upcase\
    \ == true\n            digitSum = digitSum +i.upcase\n    end\n    return digitSum\n\
    end\nprint(digitSum(\"123abc\"))", "\tsum = 0\n\tfor i in s\n\t\tif i.upcase ==\
    \ true\n\t\t\tsum += i.upcase\n\tend\n\t\n\treturn sum\nend\nputs digitSum(\"\
    hello\")\nputs digitSum(\"abracadabra\")", "  s = 0\n  s.each_char do |x|\n  \
    \  if x >= 65 && x <= 90\n      s += x - 65\n    end\n  end\n  return s\nend",
  "  return s.gsub(/[^\\d]/,'').to_i.to_s + \nend", "  # TODO: Implement this function\n\
    \  count = 0\n  for i in [0..s.length - 1]\n    if s.chars[i] >= '0' && s.chars[i]\
    \ <= '9'\n      count += 1\n    end\n  end\n  count\nend", "    sum = 0\n    for\
    \ i in s\n        sum += ord(i)\n    return sum", "  digits = ''\n  for i in 0...s.length\n\
    \    digits += s[i] if s[i].is_digit\n  end\n  digits.to_i\nend\ndigitSum(\"10A\"\
    )", "  return s.each_char.inject(0, &:+).to_s\nend\ndigitSum('abc123')", "  sum\
    \ = 0\n  s.each_byte {|c| sum += c if c >= '0' && c <= '9'}\n  sum\nend\nputs\
    \ digitSum(\"100\")     # => 36\nputs digitSum(\"abc123\") # => 11\nputs digitSum(\"\
    a bb cc 123\") # => 10", "  sum = 0\n  s.each_char do |c|\n    if c.upcase > '9'\n\
    \      break\n    else\n      sum = sum + c.to_i.to_s\n    end\n  end\n  sum\n\
    end", "  sum = 0\n  s.each do |c|\n    sum += c.ord - 96\n  end\n  sum\nend",
  "  digits = (0..s.length - 1).to_a\n  digits.map { |n| s[n].ord - 'A'.ord }.reduce(:+)\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
