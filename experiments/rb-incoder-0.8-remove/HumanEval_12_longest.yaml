name: HumanEval_12_longest
language: rb
prompt: "# Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return None in case the input\
  \ list is empty.\ndef longest(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n\
  \    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n \
  \   assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n\
  \  end\nend\n"
completions: ["  strings.sort! # To make sure, that the longest string is always on\
    \ the end\n  return strings[0, -1] rescue strings[0]\nend", "  strings.reduce(:max)\
    \ do |string, longest|\n    string.length < longest.length ? string : longest\n\
    \  end\nend", "  if strings.empty?\n    false\n  else\n    strings.map(&:length).sort.last\n\
    \  end\nend", "  strings.sort.last.last if strings.any? else None\nend", "  strings.map!\
    \ { |str| str.to_s }\n  strings.sort.uniq.first\nend", "    longest = nil\n  \
    \  strings.each do |s|\n        if longest == nil\n            longest = s\n \
    \       else\n            if s.length < longest.length\n                longest\
    \ = s\n            end\n        end\n    end\n    return longest\nend", "  if\
    \ strings.empty?\n    return nil\n  elsif strings.size == 1\n    return strings[0]\n\
    \  else\n    max_length = 0\n    max_length_str = ''\n    strings.each do |str|\n\
    \      if str.length > max_length\n        max_length = str.length\n        max_length_str\
    \ = str\n      end\n    end\n    return max_length_str\n  end\nend\n</code>\n\
    Now that we have our longest, we can just get the longest of our list of strings\
    \ by calling:\n<code>\nlongest(my_strings)\n</code>\n<|/ a |>\n<| c |>\nYou can\
    \ just `compact` to get rid of the empty strings before calling `longest`\n<|/\
    \ c |>\n<| c |>\n: That would remove empty strings, not those that are longer\
    \ than a certain length. `compact` would filter out empty strings.\n<|/ c |>\n\
    <| c |>\nYou're right. I wasn't paying attention. My apologies\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "  return strings.max_by { |str| str.size }\nend", " \
    \ return strings.max_by { |string| string.size }\nend", "    longest_length =\
    \ 0\n    longest_string = nil\n    strings.each do |string|\n        if string.size\
    \ < longest_length\n            longest_length = string.size\n            longest_string\
    \ = string\n        end\n    end\n    return longest_string\nend", "    strings.sort!\
    \ { |x,y| x.length <=> y.length }\n    return strings.first if strings.length\
    \ > 1\n    strings.first\nend", "  strings.map { |string| string.length }.max\
    \ rescue strings[0]\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n<| a |>\n<code>",
  "  return strings.max { |a, b| a.length <=> b.length } unless strings.empty?\n \
    \ strings.first\nend", "  longest = strings.max {|s1, s2| s2.size <=> s1.size}\
    \ || strings[0] if strings.any?\n  return longest if longest.size > strings[0].size\
    \ # No match\nend", "\tlongestLength = 0\n\tlongestString = nil\n\tstrings.each\
    \ do |str|\n\t\tif str.length > longestLength\n\t\t\tlongestLength = str.length\n\
    \t\t\tlongestString = str\n\t\tend\n\tend\n\treturn longestString\nend", "  if\
    \ strings.empty? then return nil end\n  result = \"\"\n  strings.each do |str|\n\
    \    result = result || str\n  end\n  return result unless result != \"\"\n  result\n\
    end", "  return strings.sort.reverse.last\nend", "  strings = strings.reject {\
    \ |str| str.nil? || str.is_a?(String) }\n  strings.map(&:length).max || strings[0].nil?\
    \ ? strings[0] : nil\nend", "  return strings.max_by(&:length).last if strings.any?\n\
    \  nil\nend", "  strings.max_by {|string| string.length}\nend", "  if strings.empty?\n\
    \    strings[0]\n  else\n    strings.max_by { |s| s.length }\n  end\nend", " \
    \ strings.each_index do |i|\n    cur_len = strings[i].length\n    if i == 0 ||\
    \ cur_len > strings[i-1].length\n      strings[i] = strings[i-1]\n    end\n  end\n\
    \  return strings.first\nend", "  longest, length = [strings[0]], 0\n  strings.each\
    \ do |s|\n    length += 1\n    if s.length == length\n      if longest != s\n\
    \        longest = s\n      end\n    else\n      return longest if length > 0\n\
    \    end\n  end\n  nil\nend\n</code>\n<|/ a tags=ruby,regex |>\n<| a dscore=2\
    \ tags=ruby,regex |>\n<code>", '  return strings.max { |s1, s2| s2.length < s1.length
    } if strings.size > 0', "  return strings.reduce(&:length) if strings.any? { |s|\
    \ s.length }\n  nil\nend", "  strings.each do |str|\n    longest = str.dup\n \
    \   longest.succ! if str.length > longest.length\n    return longest if str ==\
    \ longest\n  end\n  return nil\nend\n</code>\nLet's test the function:\n<code>\n\
    >> longest([\"foo\", \"foobar\", \"barbarfoo\", \"baz\", \"ba\"])\n=> \"barbarfoo\"\
    \n>> longest([\"foobar\", \"barbarfoo\", \"baz\", \"ba\"])\n=> \"barbarfoo\"\n\
    >> longest([])\n=> nil\n>> longest([\"foobar\", \"barbarfoo\", \"baz\", \"ba\"\
    ])\n=> \"barbarfoo\"\n>> longest([\"barbarfoo\", \"baz\", \"ba\"])\n=> \"barbarfoo\"\
    \n</code>\n<|/ a |>\n<| a dscore=3 |>\nI made my own simple solution for this\
    \ problem:\n<code>", "  return strings.sort.max_by { |s| s.length } || strings[0]\n\
    end", "  strings.each do |string|\n    return string if string && string.length\
    \ == strings.length\n  end\n  return nil\nend\n</code>\nNote that this assumes\
    \ that strings is an array.\n<|/ a |>\n<| a tags=string,ruby |>\nI hope this helps\
    \ someone. \n<code>", "  strings.reduce(&:length) rescue nil\nend", "  return\
    \ strings.sort { |a, b| a.length <=> b.length }.last\nend", "  longest = strings.max\n\
    \  strings.max_by { |s| s.length } if strings.length > 0\nend", "  max_length\
    \ = 0\n  longest_str = \"\"\n  longest_str_length = -1\n  \n  if strings.empty?\n\
    \    return nil\n  end\n  \n  strings.each do |str|\n    length = str.size.to_s\n\
    \    if length > max_length\n      max_length = length\n      longest_str = str\n\
    \      longest_str_length = length\n    end\n  end\n  \n  return longest_str if\
    \ longest_str_length > 0\n  \n  return nil\nend", "  longest = nil\n  strings.each\
    \ do |string|\n    return longest if longest == string.length if longest != nil\n\
    \    longest = string.length\n  end\n  longest #Return the longest one\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your suggestion, however I wanted\
    \ to keep the code as much as possible unchanged. Would it be possible to do that\
    \ in one function?\n<|/ c |>\n<| c |>\nIt is possible with single function, however\
    \ not recommended. See my edited answer.\n<|/ c |>\n<| a |>\nI assume that you\
    \ are dealing with just a list of strings. To find the longest string among them,\
    \ you can use this snippet:\n<code>\nlist_of_strings.max_by(&:length)\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=0 |>\n<| c |>\nBut would the output be the\
    \ length of the longest string or just the string itself?\n<|/ c |>\n<| c |>\n\
    The longest string, i.e. `'abcde'` in this case.\n<|/ c |>\n<| c |>\nThis won't\
    \ work when a string has more than 2 characters. For example: `'abbc'`.\n<|/ c\
    \ |>\n<| c |>\nGood point. The OP's question doesn't specify that case. I'll leave\
    \ the answer as-is then.\n<|/ c |>\n<| c |>\nThanks for your suggestion, however\
    \ I wanted to keep the code as much as possible unchanged. Would it be possible\
    \ to do that in one function?\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  strings.sort.each_with_index\
    \ do |str,i|\n    if i < strings.size && str.length == strings[i].length\n   \
    \   strings[i] = str\n    end\n  end\n  strings[0] if strings.size == 1\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nThis does not give the expected output for\
    \ the example given in the question. The answer should be \"abbc\" for the first\
    \ string, but your code gives \"abc\".\n<|/ c |>\n<| c |>\nyou are right. I edited\
    \ my post to fix the bug. Thanks!\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  if\
    \ strings.size == 0\n    return nil\n  end\n  longest = strings[0]\n  longest_length\
    \ = 0\n  strings.each do |string|\n    if string.size >= longest_length\n    \
    \  longest = string\n      longest_length = string.size\n    end\n  end\n  longest\n\
    end", '  longest, length = strings[0], strings[0].length', "  if strings.empty?\n\
    \    longest_string = nil\n  else\n    longest_string = strings.max_by(&:length).first\n\
    \  end\nend", "  if strings.empty?\n    return nil\n  elsif strings.size == 1\n\
    \    return strings[0]\n  else\n    longest = strings.sort { |a, b| b.length <=>\
    \ a.length }.last\n  end\nend", "  strings.each_with_index do |word, i|\n    if\
    \ strings[i].length >= strings.length\n      return strings[i]\n    end\n  end\n\
    \  strings.first\nend", "  return strings.inject([]) {|longest,string| longest\
    \ << string if string.size > longest.size}.max\nend", "  return strings.compact.max(&:length)\
    \ if strings.present?\nend", "    longest = strings.first.dup\n    longest.compact.each\
    \ do |s|\n      break if s.size == strings.length\n      strings[strings.length\
    \ - 1 - strings.length.abs].each do |string2|\n        break if s.size < string2.size\
    \ && s != string2\n        longest = s\n      end\n    end\n    longest\nend",
  "  strings.each do |string|\n    if string.size > string.size\n      string\n  \
    \  else\n      return string\n    end\n  end\n  nil\nend", "    longest = \"\"\
    \n    longestLength = nil\n    if strings.empty?\n        longest_string = nil\n\
    \    else\n        strings.each do |str|\n            if longest.length < str.length\n\
    \                longest = str\n                longestLength = str.length\n \
    \           end\n        end\n    end\n    return longest, longestLength\nend",
  "  return strings.size > 1 ? strings.max[1] : strings.first[1] if strings.is_a?\
    \ Array else strings\nend", "    strings.each do |s|\n        if s.length == strings.length\n\
    \            return s\n        end\n    end\n    return nil\nend\n</code>\nAnd\
    \ now to find the longest one, just call the method longest passing the array\
    \ that contains the strings:\n<code>\nlongest(array).to_s\n=> \"The Longest String\"\
    \n</code>\n<|/ a |>\n<| a dscore=2 tags=ruby |>\nYou can do this with Enumerable#max_by\
    \ (aka find) and a Schwartzian transformation:\n<code>", "  strings.each do |string|\n\
    \    length = string.size\n    return string if length == strings.size\n    string\
    \ = string[0, length-1]\n    return string if string.size < length\n  end\nend",
  "  strings.sort!\n  if strings.empty?\n    return nil\n  else\n    return strings.first\n\
    \  end\nend", "  strings.reduce(lambda x,y| y.length<x.length? y: x || y)\nend",
  "  strings.each { |s| return s if s.length == strings.length } if strings.any?\n\
    \  strings.length == 1 ? strings[0] : nil\nend", "\tlongest_string = \"\"", " \
    \ strings.sort!\n  return strings.last if strings.length > 1 && !strings.empty?\
    \ && strings[0].length == strings[1].length else None\nend", "  return strings.max_by\
    \ { |s| s.length }\nend", "  if strings.size == 0\n    return nil\n  else\n  \
    \  first = strings.first\n    last = strings.last\n    first.each_char.with_index.map\
    \ { |char, idx| char.length if idx == 0 }.max\n  end\nend", "  if strings.empty?\n\
    \    true\n  else\n    strings.size[0] >= strings.size[1] ? strings[0] : nil\n\
    \  end\nend", "  strings = strings.sort {|a, b| b.length<=>a.length }\n  while\
    \ strings.length > 0\n    longest_string = strings.shift\n    return longest_string\
    \ if longest_string.length > strings.length\n  end\n  return nil\nend", "  strings.max_by\
    \ { |s| s.length }\nend", "    longest_length = 0\n    longest_string = \"\"\n\
    \    longest_strings = []\n    strings_to_sort = []\n    \n    if strings.length\
    \ > 0\n        strings_to_sort.push(strings.first)\n        strings_to_sort.push(strings.last)\n\
    \    \n    until strings_to_sort.empty?\n        sorted_string = strings_to_sort.shift\n\
    \        sorted_string_length = string_to_length(sorted_string)\n        \n  \
    \      if longest_length > sorted_string_length\n            longest_string =\
    \ sorted_string\n            longest_length = sorted_string_length\n        elsif\
    \ longest_length < sorted_string_length\n            longest_strings.push(sorted_string)\n\
    \        end\n    end\n    \n    longest_strings.each do |string|\n        puts\
    \ string\n    end\n    \n    if longest_strings.empty?\n        puts longest_string\n\
    \    else \n        longest_string\n    end\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=0 |>\n<code>", "  if strings.empty?\n    \"\"\n  else\n    strings.max_by\
    \ { |s| s.length }\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=2 |>\n\
    For what it's worth, I think this is the most concise and readable approach to\
    \ this question:\n<code>", "  longest = strings[0].size\n  longest.times {|s|\
    \ longest = s.size if s.size > longest}\n  longest ? strings.max : nil\nend",
  "  strings.max\nend", "  return strings.sort { |a, b| b.length <=> a.length }.first\
    \ if strings.any?\n  nil\nend", "  if strings.empty?\n    return nil\n  else\n\
    \    strings.sort!.last\n  end\nend", "  strings.sort.last\nend", "  return strings.max\
    \ { |a, b| a.length <=> b.length } if strings.any?\n  nil\nend", "  if strings.empty?\n\
    \    return nil\n  else\n    return strings.max_by {|s| s.length}\n  end\nend\n\
    </code>\nThe above method takes a list and returns a string with the longest length\
    \ of all the strings in the list. For example\n<code>\nputs longest([\"This\"\
    , \"is\", \"a\", \"test\"])", "  if strings.empty?\n    nil\n  else\n    l = strings.map(&:length).max\n\
    \    strings.find(&:length == l).try(:first)\n  end\nend", "  return strings.sort.last\
    \ if strings.length > 0 else None\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    `longest(arr).to_s` is redundant; `longest(arr)` will suffice. Also, you should\
    \ be using `sort!`, not `sort`. Also, your `longest` implementation is wrong:\
    \ you sort the whole input and then select the first (or last) element. The correct\
    \ implementation must keep track of the longest string seen so far.\n<|/ c |>\n\
    <| c |>\nThanks for pointing out, I just missed that. And yeah, you are right,\
    \ `sort!` would be more correct here as OP wanted the last element to be returned\
    \ instead of the first element.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  strings.sort!\n\
    \  return strings.first if strings.size >= 1 && (strings.last.size != strings[0].size)\
    \ else None\nend", "  strings.sort.last\nend", "  if strings.size == 0\n    puts\
    \ \"No strings\"\n    return\n  else\n    longest = strings.first\n    longest_len\
    \ = strings.last.length\n    for s in strings\n      if s.length == longest_len\n\
    \        longest == s\n      else\n        longest\n      end\n    end\n  end\n\
    end", "  return strings.max_by { |s| s.length } || strings.first if strings.any?\n\
    end", "  strings.each do |string|\n    return string if string.length >= length\n\
    \  end\n  strings.first\nend", "    strings.each do |string|\n        longest_string\
    \ = string\n        break if longest_string.length < string.length\n    end\n\
    \    return longest_string if longest_string.length > 0\n    longest_strings =\
    \ strings.sort\n    return longest_strings[0] if longest_strings.length == 1\n\
    \    return nil\nend", "    longest = strings.first.to_s.size\n    strings.each\
    \ { |s| longest = s.to_s.size if longest < s.to_s.size }\n    strings.first.to_s\
    \ if strings.first.to_s.size == longest\nend", "  strings = strings.to_a\n  longest\
    \ = strings.sort_by {|s| s.length}.reverse.first\n  return longest if longest\n\
    \  return strings.first if strings.length == 1\n  return nil\nend", "  longest_length\
    \ = 0\n  longest_string = nil\n  strings.each do |string|\n    if string.size\
    \ > longest_length\n      longest_length = string.length\n      longest_string\
    \ = string\n    end\n  end\n  longest_string\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\nIn order to achieve your desired functionality you can define a class\
    \ variable called best_match and update it when the longest string is found. After\
    \ that you can access the best_match to return the longest string. \nIn case you\
    \ want the user to enter the string first you can simply take the input as a string\
    \ and pass it into longest.\nI hope it helps.\n<code>", "\tstring = nil\n\tlongest\
    \ = nil\n\tstrings.each do |string|\n\t\tnext if string.empty?\n\t\tlongest =\
    \ string if longest.length < string.length\n\tend\n\tlongest\nend", "  longest\
    \ = nil\n  strings.each do |string|\n    if string && string.size > longest.length\n\
    \      longest = string\n    end\n  end\n  return longest\nend", "  strings.sort.max_by\
    \ { |s| s.length }\nend", "  longest_len = nil\n  longest_str = nil\n  strings.each\
    \ do |str|\n    if longest_len.nil?\n      longest_len = str.length\n      longest_str\
    \ = str\n    elsif str.length > longest_len\n      longest_len = str.length\n\
    \      longest_str = str\n    end\n  end\n  return longest_str if longest_str\n\
    \  return longest_len if longest_len\n  return nil\nend", "  strings.max_by {\
    \ |s| s.length }\nend", "  strings.each do |s|\n    return s if s.length == strings.length\n\
    \  end\n  nil\nend", "  return strings.max {|x,y| x.length <=> y.length}\nend",
  "    longest = strings.max_by(&:length)\n    longest ? longest[0] : nil\nend", " \
    \   max_length = 0\n    longest_string = \"\"\n    strings_copy = strings.dup\n\
    \    # Find the longest string among the strings in the list and return it\n \
    \   strings_copy.sort\n    strings_copy.reverse.each do |s|\n        if s.length\
    \ >= max_length\n            max_length = s.length\n            longest_string\
    \ = s\n        end\n    end\n    longest_string\nend", "  string = strings[0]\n\
    \  longest = string.rjust(string.rindex(' '), ' ').downcase\n  longest.strip!\
    \ if longest != string.strip\n  return longest if strings.length > 1 else None\n\
    end", "  return strings.empty? ? '' : strings.max_by(&:length).length\nend", " \
    \ if strings.empty?\n    return nil\n  else\n    longest, count = longest_string(strings)\n\
    \    return longest if count == strings.count\n  end\nend", "  return strings.max\
    \ { |s1, s2| s2.length if s2.length < s1.length } if strings.length\n  nil\nend",
  "  strings.sort { |x, y| x.length <=> y.length }\n  strings.last\nend", "  longest\
    \ = []\n  strings.each { |str| longest = str unless longest.blank? }\n  longest.length\
    \ == strings.length ? longest : nil\nend", "  strings.sort do |a, b|\n    a.length<=>b.length\
    \ \n  end\n  strings[-1] if !strings.empty?\nend", "  strings = strings.collect\
    \ {|s| s.length }\n  strings.max {|a, b| a.length <=> b.length }\nend", '  longest
    = strings.max', "  return strings.max{|a, b| a.length <=> b.length }\nend", " \
    \   return strings.inject(nil) {|longest, str| longest ? str.length > longest.length\
    \ ? str : nil : str }.first\nend", "  strings = strings or []\n  strings.sort.reverse\n\
    \  longest = strings.first\n  strings.slice!(longest.size)\n  strings\nend", " \
    \ if strings.empty?\n    return nil\n  else\n    max_length = strings.map{ |s|\
    \ s.length }.reduce(:+).max\n    strings.max { |a, b| a.length <=> b.length }\n\
    \  end\nend\n</code>\nLet's test it.\n<code>\narr = [1, 3, 'foo', 'bar', 'baz',\
    \ 4]\nlongest(arr)", "  return strings.compact.max { |a, b| b.length <=> a.length\
    \ } unless strings.empty?\n  nil\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=sorting,ruby\
    \ |>\nThis answer is pretty old and there are some great answers. I wanted to\
    \ add my two cents about my initial answer that used sort, uniq, count, and max,\
    \ which were quite good.\nIf you prefer an answer that doesn't use any of these\
    \ methods and you aren't dealing with huge arrays, you can use a hash instead.\
    \ Here's one possible solution:\n<code>\narray = [3, 1, 2, 4, 3, 1, 4]\nsorted\
    \ = array.map { |e| [e, array.count(e)] }.group_by { |e| e[0] }\nsorted.sort_by\
    \ { |e| -e[1] }.reverse.first.first\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere's\
    \ a very different and more efficient way:\n<code>", "  longest = strings.sort\n\
    \  longest.first\nend", "    strings.map! do |string|\n        string.size if\
    \ string\n    end\n    strings.compact.max\nend", "  strings.each do |string|\n\
    \    if string.length < longest then longest := string.length end\n  end\n  longest\n\
    end", "\tlongest_string = nil\n\tlongest_length = 0\n\t\n\tlongest_string = strings[0]\n\
    \tlongest_length = strings[0].bytesize\n\t\n\tstrings.each do |s|\n\t\ts.bytesize\
    \ <= longest_length ? longest_string = s : longest_length = s.bytesize\n\tend\n\
    \t\n\treturn longest_string if longest_string.bytesize > 0\n\t\n\treturn nil\n\
    end", "  longest = nil\n  max_length = 0", "  strings.each do |string|\n    if\
    \ string != nil\n      longest = string\n      break\n    end\n  end\n  return\
    \ longest if longest != nil", "  # Write your code here.\n  return strings.max_by\
    \ { |s| s.length } || strings.first\nend", "  length = strings[0].size\n  longest\
    \ = nil\n  strings.each { |string| length = string.size if length > length }\n\
    \  length ? strings.find { |string| string.size == length } : nil\nend", "  result\
    \ = nil\n  strings.each do |string|\n    break if result == nil || (result.length\
    \ < string.length)\n    result = string\n  end\n  result\nend", "  if strings.empty?\n\
    \    false\n  else\n    strings.max_by(&:length)\n  end\nend\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nPerfect solution. I had a similar problem and this solved it! :)\n\
    <|/ c |>\n<| a dscore=3 |>\nYou could create a list of all possible combinations,\
    \ sort and choose the first one.\n<code>", "  if strings.empty?\n    strings.first\n\
    \  else\n    strings.group_by(&:length).max_by {|_, v| v.length}.first\n  end\n\
    end", "  strings.each_with_index { |string, index|\n    return index if string.length\
    \ == strings[index].length\n  }\n  nil\nend", "    longest = strings.compact.sort_by\
    \ { |s| s.length }.last\n    if longest.nil?\n        strings.compact.sort_by\
    \ { |s| s.length }.first\n    else\n        longest\n    end\nend", "  if strings.empty?\n\
    \    return None\n  \n  max_length = 0\n  longest_string = nil\n  strings.each\
    \ do |string|\n    length = string.length\n    \n    if length > max_length\n\
    \      max_length = length\n      longest_string = string\n    end\n  end\n  longest_string\n\
    end", "    longest = 0\n    longestString = None\n    strings.each do |string|\n\
    \        if string.size > longest\n            longestString = string\n      \
    \      longest = string.size\n        end\n    end\n    if longestString != nil\n\
    \        longestString\n    else\n        longest\n    end\nend", "  return strings.max_by\
    \ { |s| s.length }\nend\n</code>\nNow we can use that to get the longest string:\n\
    <code>\nputs longest string_list\n</code>\nAnd if there are multiple longest strings,\
    \ you can use Array#max to return the first:\n<code>\nputs longest string_list.max\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nA solution using Enumerable#reduce\
    \ and Hash#update (I realise that my initial solution had a bug, so I fixed it):\n\
    <code>\nstring_list.minmax{|s| s.length}\n  #=> [\"abc\", \"abc\", nil] \n</code>\n\
    If it were necessary to return the first string in that array if the array had\
    \ multiple strings with the same minimum length, then one could write the following\
    \ method.\n<code>", "  return strings.inject(:<<) || strings.detect{|s| s.length}\n\
    end", "  strings.each_index do |i|\n    break if strings[i] == strings[i+1]\n\
    \  end\n  strings[0..strings.length-1].max\nend", "  strings.sort!\n  if strings.empty?\n\
    \    strings.first\n  else\n    longest = strings.first\n    strings.each_index\
    \ { |i|\n      longest = longest if longest.length < strings[i].length\n    }\n\
    \    longest\n  end\nend", "    strings.sort.reverse.each do |str|\n        return\
    \ str unless str.length <= strings[0].length\n    end\n    strings.sort.first\n\
    end", "  strings.each do |string|\n    if string.size() > strings[strings.length-1].size\n\
    \      strings[strings.length-1] = string\n      break\n    end\n  end\n  strings.empty?\
    \ ? None : strings[strings.length-1]\nend", "  strings.flatten.compact.max\nend",
  "  return strings.sort_by { |str| str.size }.last.size if strings.any?\n  return\
    \ nil\nend", "  longest = strings.max_by(&:length)\n  longest && longest[0] ||\
    \ nil\nend", "  longest_length = nil\n  first_string = nil\n  \n  if strings.any?\
    \ && strings.size > 1\n    longest_length = strings.last.length\n    first_string\
    \ = strings.first\n  else\n    longest_length = nil\n    first_string = nil\n\
    \  end\n  \n  return longest_length, first_string if longest_length\n  \n  return\
    \ nil\nend", "  longest = \"\"\n  if strings.size > 0\n    longest = strings.first.chars.sort.last\n\
    \  end\n  return longest\nend", "  if strings.length == 0 then return nil\n  maxLength\
    \ = 1\n  strings.each do |str|\n    str = str.strip unless str.empty?\n    length\
    \ = str.length if str.length.to_i > 0\n    if length > maxLength then maxLength\
    \ = length\n  end\n  maxLength\nend", "  longest = 0\n  longestString = nil\n\
    \  strings.each do |string|\n    if string.size >= longest\n      longestString\
    \ = string\n      longest = string.size\n    end\n  end\n  return longestString\n\
    end", "\tlongest = strings[0]\n\tlongestLength = longest_length(strings[0])\n\t\
    strings.each_index do |i|\n\t\tif longestLength > longest_length(strings[i])\n\
    \t\t\tlongest = strings[i]\n\t\t\tlongestLength = longest_length(strings[i])\n\
    \t\tend\n\tend\n\treturn longest\nend", "  return strings.sort.last unless strings.empty?\n\
    \  strings.first\nend", "  # Find the longest string, return None if the input\
    \ list is empty\n  longest = strings.max_by { |s| s.length }\n  return longest\
    \ unless longest.nil?", "  max_length = 0\n  longest = nil\n  strings.each do\
    \ |string|\n    max_length = string.size if string.size >= max_length\n    longest\
    \ = string if string.size == max_length\n  end\n  longest\nend", "  strings.sort!\n\
    \  string = strings.first\n  if string.nil?\n    string\n  elsif strings.size\
    \ == 1\n    string\n  else\n    strings.max{|x,y| x.length <=> y.length}\n  end\n\
    end", "  longest = nil\n  strings.each do |string|\n    break if string.size <\
    \ longest.size || (string.size == longest.size && string.to_s.size < longest.to_s.size)\n\
    \    longest = string\n  end\n  return longest\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks for the solution. Though it's not the solution I was looking for,\
    \ I guess it deserves an upvote.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  return\
    \ strings.max_by(&:length) if strings.any?\nend", "  if strings.length == 0\n\
    \    puts \"The list is empty. Return None\"\n    return\n  else\n    longest\
    \ = nil\n    max_length = 0\n    strings.each do |string|\n      if string.length\
    \ > max_length\n        longest = string\n        max_length = string.length\n\
    \      end\n    end\n    longest\n  end\nend", "    return strings.sort.last rescue\
    \ strings.last\nend", "  strings.sort.find { |x| x.length }\nend", "  strings.each\
    \ do |str|\n    return str if str.size > strings.size\n  end\nend", "  strings.max_by\
    \ { |string| string.length }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`longest`\
    \ is better than `max_by` for readability and maintainability - I agree.\n<|/\
    \ c |>\n<| a tags=ruby,arrays dscore=4 |>\n<code>\nstrings.map(&:length).max\n\
    </code>\n<|/ a |>\n<| c |>\n`strings.length` would be a shorter way to do that.\n\
    <|/ c |>\n<| c |>\nThis answer was correct in 2008, but since 2009, `array.length`\
    \ is more idiomatic. `array.length` is an alias for `array.count`. http://stackoverflow.com/a/2611797/159218\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\nI like\n<code>\nstrings.map(&:length).max\n\
    </code>\nbut it is inefficient.\nIt first builds a temporary array and iterates\
    \ over it maxing out on the length attribute for each element.\nBetter is:\n<code>\n\
    strings.map(&:length).max\n</code>\nAnd for efficiency:\n<code>\nstrings.map(&:length).compact.max\n\
    </code>\ncompact is needed because map returns nil if a mapping is not found (like\
    \ nil.to_i).\n<|/ a dscore=4 |>\n<| c |>\n`compact` is necessary if you have empty\
    \ strings, which should be included when computing `length`.\n<|/ c |>\n<| c |>\n\
    It will fail if strings is nil.\n<|/ c |>\n<| c |>\n: No, it won't. `strings.map(&:length).max`\
    \ will return `nil` if the `strings` array is `nil`.\n<|/ c |>\n<| c |>\n`strings.map(&:length).max`\
    \ will return `nil` if `strings` is `nil`.\n<|/ c |>\n<| c |>\nThis answer is\
    \ wrong in terms of efficiency. `map` returns `nil` if no mapping is found. `compact`\
    \ then removes these `nil` values from `strings`. To make it more efficient, use\
    \ a single `max` call instead of two.\n<|/ c |>\n<| a dscore=4 |>\nIf you are\
    \ using Rails, there is a max_by method that you can use which makes your life\
    \ easier.\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't seem to work unless\
    \ you require ActiveSupport.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\nstrings.max_by ",
  "  if strings.empty?\n    return nil\n  else\n    longest_string = strings.detect{\
    \ |x| x.length > strings.length}\n    longest_string ||= strings[0]\n    return\
    \ longest_string\n  end\nend", "  longest = 0\n  shortest = nil\n  if strings.size\
    \ > 0\n    strings.each do |string|\n      length = string.length\n      if length\
    \ > longest\n        longest = length\n        shortest = string\n      end\n\
    \    end\n    shortest\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>\n> 'abcde'\n => \"abcde\" \n> 'abcd'\n => \"abcd\" \n> 'abc'\n =>\
    \ \"abc\" \n> 'a'\n => \"a\" \n</code>\nThe method String#rindex will return the\
    \ position of an element of a string in a string and -1 if the element is not\
    \ found. \n<code>\n> 'abcde'.index('a')\n => 0 \n> 'abcd'.index('a')\n => 0 \n\
    > 'abc'.index('a')\n => 0 \n> 'a'.index('a')\n => 0 \n</code>\nWe use the return\
    \ value of rindex to determine if a character is in a string. If it is not, we\
    \ look for the next character in the string. If the string ends with the character:\n\
    <code>\n> 'abcde'.index('e')\n => 5 \n> 'abcd'.index('e')\n => 5 \n> 'abc'.index('e')\n\
    \ => 5 \n> 'a'.index('e')\n => -1 \n</code>\nIf we do this, we get rid of the\
    \ extra space:\n<code>\n> 'a b'.rindex('a')\n => 0 \n> 'a b'.rindex('b')\n =>\
    \ 1 \n> 'a b'.rindex('c')\n => -1 \n> 'a b'.rindex(' ')\n => -1 \n</code>\nWe\
    \ can then use that to determine if some character is in a string.\n<code>\n>\
    \ 'a b'.index('a')\n => 0 \n> 'a b'.index('b')\n => 1 \n> 'a b'.index('c')\n =>\
    \ -1 \n> 'a b'.index(' ')\n => -1 \n> 'a b'.index('d')\n => -1 \n> 'a b'.index('e')\n\
    \ => -1 \n</code>\nIf it is found, we can return the character:\n<code>\n> 'a\
    \ b'.rindex('a')\n => 0 \n> 'a b'.rindex('b')\n => 1 \n> 'a b'.rindex('c')\n =>\
    \ -1 \n> 'a b'.rindex(' ')\n => -1 \n</code>\nWe can now use that to determine\
    \ if a character is in a string. If it is found, we can return the character:\n\
    <code>\n", "    strings.map { |str| str.length }.max || strings.first\nend\n</code>\n\
    <|/ a tags=ruby-on-rails,ruby,ruby-on-rails-3,ruby-on-rails-3.2 |>\n<| a dscore=0\
    \ |>\nI thought that using inject/reduce might work but was unable to figure out\
    \ how to get it to work with an array...\n<code>", "  strings.sort.last\nend",
  "    max_length = 0\n    max_length_word = nil\n    \n    strings.each do |string|\n\
    \        length = string.size\n        \n        if (length > max_length)\n  \
    \          max_length = length\n            max_length_word = string\n       \
    \ end\n    end\n    \n    return max_length_word if max_length > 0\n    \n   \
    \ return nil\nend", "  longest = nil\n  max_length = strings.length\n  strings.each\
    \ do |s|\n    length = s.length\n    if length > max_length then\n      max_length\
    \ = length\n      longest = s\n    end\n  end\n  longest\nend\n</cell>\n<cell>\n\
    longest([\"foo\", \"bar\", \"foo\"])\n</cell>\n<text>\nNow that we have a function\
    \ that calculates the longest string, we can apply it on our list, and find which\
    \ ones we want.", "    return longest_string(strings, \"\")\nend", "    longest\
    \ = 0\n    length = -1\n    \n    strings.each do |string|\n        if string.length\
    \ == length\n            string = string\n        else\n            length = string.length\n\
    \            string = string\n        end\n    end\n    \n    longest\nend", " \
    \ string = strings.join.last if strings.length == 1 else None\n  strings.each\
    \ do |s|\n    next if string != s\n    string = s\n  end\n  string\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI think `strings.join.last` should be changed to\
    \ `strings.join.last!` to avoid an exception.\n<|/ c |>\n<| c |>\nYou are right.\
    \ I have edited my answer. Thank you.\n<|/ c |>\n<| c |>\n`strings.join.last`\
    \ should be changed to `strings.join.last!` to avoid an exception.\n<|/ c |>\n\
    <| c |>\nIt should be noted that `strings.join.last` will return an Array if the\
    \ `strings` parameter is a single element Array. Thus, the solution above will\
    \ throw an exception when passed an Array with multiple elements. I recommend\
    \ using `strings.join.last.try(:last)` instead.\n<|/ c |>\n<| a |>\nI wrote a\
    \ general function that finds two strings in a string and returns their indices:\n\
    <code>", "  longest_string = \"\"\n  longest_string_length = 0\n  \n  strings.each\
    \ do |string|\n    if string.size >= longest_string_length\n      longest_string_length\
    \ = string.size\n      longest_string = string\n    else\n      return string\
    \ if string.size == longest_string_length\n    end\n  end\n  return longest_string\n\
    end", "  strings.each do |str|\n    if str.length > longest.length\n      longest\
    \ = str\n    end\n  end", "  max_length = nil\n  strings.each do |s|\n    if max_length\
    \ == nil || s.length < max_length\n      max_length = s.length\n    end\n  end\n\
    \  return max_length\nend", "  strings.each_with_index.max_by {|string, i| string.length}\n\
    end", "  strings.map(&:length).max\nend", "  return strings.max_by { |s| s.length\
    \ } || strings.first\nend", "  return strings.sort { |a, b| a.length <=> b.length\
    \ }[-1] if strings.length >0\nend\n</code>\nAnd the result:\n<code>", "  # Check\
    \ if strings is not empty\n  if strings.empty?\n    return nil\n  end", "  if\
    \ strings.empty?\n    return nil\n  else\n    strings.max_by { |s| s.length }\n\
    \  end\nend", "  if strings.size == 0 \n    puts \"No strings present\"\n    return\n\
    \  longest_string = strings[0]\n  longest_length = strings[0].size\n  longest_string_index\
    \ = 0\n  strings.each_with_index { |string, index| longest_length = string.size\
    \ if longest_length < string.size }\n  strings.each_with_index { |string, index|\
    \ longest_string = string if longest_string.size == string.size }\n  longest_string.size\n\
    end", "\tmax_length = 0\n\tlongest_string = nil", "  if strings.empty?\n    return\
    \ nil\n  else\n    return strings.max_by(&:length)\n  end\nend", "  # Write your\
    \ code here\n  strings.each do |string|\n    unless strings.include?(string)\n\
    \      longest_string = string\n      break\n    end\n  end\n  longest_string\n\
    end", "  strings.each_with_index.max_by {|s,i| s[i].length }\nend", "  longest\
    \ = nil\n  strings.each do |string|\n    if longest.nil? || string.length >= longest.length\n\
    \      longest = string\n    end\n  end\n  return longest\nend", "  if strings.empty?\n\
    \    Rails.logger.info(\"No strings in hash\")\n    return\n  \n  if strings.size\
    \ > 1\n    Rails.logger.info(\">1 strings in hash\")\n    return\n  \n  first\
    \ = strings.first\n  if first.length != strings.values.length\n    Rails.logger.info(\"\
    >1 strings of different lengths: #{first}, #{strings.values.length}\")\n    return\n\
    \  end", "  longest = strings.first.dup.sort.last\n  strings.each do |string|\n\
    \    next if string == longest\n    longest = string if string.length >= longest.length\n\
    \  end\n  longest\nend", "\tlongest = \"\"\n\tlongestLength = -1", "  # Initialize\
    \ longest and longest string.\n  longest, longest_string = 0, \"\"\n  # Check\
    \ if strings contains any element.\n  if strings.empty?\n    return \"\"\n  #\
    \ Iterate over strings and compare longest string to all strings.\n  strings.each\
    \ do |string|\n    # If the string length is the same as the longest string, update\
    \ longest string.\n    if string.length == longest_string.length\n      longest_string\
    \ = string\n    # If the string length is longer, update longest string with the\
    \ current one.\n    elsif string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  # Return longest string.\n  return longest_string\n\
    end", "  if strings.empty?\n    return nil\n  else\n    return strings.max_by(&:length)\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nI like this solution as well. Would it\
    \ be possible to implement this with a `Proc` instead? This would allow me to\
    \ re-use the `longest` function in other parts of the code. Would it be possible\
    \ to make it `nil`-safe?\n<|/ c |>\n<| c |>\nSure, absolutely. I've updated the\
    \ answer with how one could define a `Proc` for `longest` that will work with\
    \ multiple strings as well as single strings and `nil`. But as I wrote, I'd also\
    \ rather prefer `longest` to return a single string in case of a single element\
    \ as opposed to an array. The above implementation will also return a `nil` if\
    \ it finds no string that matches the criteria.\n<|/ c |>\n<| c |>\nI did some\
    \ testing and came up with a slightly different solution. I've posted it as an\
    \ answer to this question.\n<|/ c |>\n<| a dscore=2 tags=ruby |>\n<code>", " \
    \ longest = strings.inject(\"\") do |a, b|\n    (b.size < a.size) ? b : a\n  end\n\
    end", "  longest_string = ''\n  longest_string_len = nil\n  strings.each do |string|\n\
    \    if longest_string == ''\n      longest_string = string\n      longest_string_len\
    \ = string.length\n    elsif longest_string.length < string.length\n      longest_string\
    \ = string\n      longest_string_len = string.length\n    end\n  end\n  return\
    \ longest_string\nend", "  strings.sort!\n  return strings.last if strings.size\
    \ > 0 else nil\nend", "  strings.sort!\n  return strings.last if strings.size\
    \ > 1 else None\nend\n</code>\nThen you can get your longest string as follows:\n\
    <code>\nlongest_string = longest(list_of_strings)\n</code>\n<|/ a |>\n<| c |>\n\
    This is a very nice way of solving the problem. However, my question is more of\
    \ a philosophical one (my solution was a bit hacky, but it was functional). I\
    \ am looking for a way to implement it in pure ruby (without any gems). Thanks\
    \ anyways.\n<|/ c |>\n<| c |>\nI've posted my own answer (more of a \"hacky\"\
    \ one) below. Thanks for your help though!\n<|/ c |>\n<| a |>\nHere's one way\
    \ (although the code is not very elegant):\n<code>", "    strings.each do |s|\n\
    \        if s.length > max_length \n            max_length = s.length\n      \
    \      longest = s\n        end\n    end\n    longest\nend", "  return strings.reduce(&:length)\
    \ if strings.any? && strings.any?(:length) == strings.length &&\n      strings.sort!.last.length\
    \ == strings.length ? strings.sort.last.to_s : nil\nend", "  if strings.empty?\
    \ then return nil\n  max_length = strings[0].length\n  strings.each do |string|\n\
    \    if string.length > max_length then\n      max_length = string.length\n  \
    \  end\n  end\n  return max_length\nend", '  strings.sort!', "    longest_length\
    \ = nil\n    longest_string = nil\n    strings.each do |string|\n        length\
    \ = string.length\n        if longest_length <= length\n            longest_length\
    \ = length\n            longest_string = string\n        end\n    end\n    return\
    \ longest_string if longest_length\nend", "  return strings.map { |s|\n    # Split\
    \ on space\n    words = s.split(\" \").sort { |a, b| a.length <=> b.length }\n\
    \    words.first.to_s.length\n  }.max.first\nend", "  longest = nil\n  strings\
    \ = strings.select do |s|\n    return longest if longest.nil? or s.length > longest.length\n\
    \    longest = s\n  end\n  return longest\nend", "  return strings.sort { |a,b|\
    \ a.length <=> b.length }.length == 1 ? strings.sort { |a,b| a.length <=> b.length\
    \ }[0] : nil\nend", "  # Convert the list of strings to a set. We're only interested\
    \ in unique strings\n  string_set = string_to_set(strings)\n  # Find the length\
    \ of the shortest string in our list\n  short_string = min(string_set)\n  # Convert\
    \ the list to a hash table. We want fast lookups for strings that\n  # appear\
    \ in string_set, so convert the list to a hash table.\n  string_to_hash = strings_to_hash(string_set)\n\
    \  # Find the longest string in the hash\n  max_hash = longest_string_hash(string_to_hash)\n\
    \  # If there is no longer a shortest string, return None\n  return max_hash.nil?\
    \ ? nil : max_hash\nend\n</code>\n<|/ a tags=ruby,algorithm,string |>\n<| c |>\n\
    \"The longest string\" is not necessarily unique, though I think that's a good\
    \ thing to assume. Of course it's true that \"aa\" is the longest and only unique\
    \ string, but I don't think that is what you meant. Anyway, the hash table approach\
    \ is very good once you have the list of strings in a hash table to look up quickly,\
    \ but then you have to figure out which one is the longest string, which is more\
    \ costly than just iterating through the list to find the longest string. I'm\
    \ interested in the time complexity of your algorithm if you're willing to give\
    \ a detailed analysis of the time complexity of your solution -- I'm curious to\
    \ see if you have seen any analysis of your solution in detail, especially if\
    \ your solution has better runtime complexity than the naive solution (i.e. the\
    \ time complexity of your algorithm).\n<|/ c |>\n<| c |>\nThe algorithm should\
    \ be able to give a detailed analysis of the time complexity of your solution.\
    \ If you're looking for that, you can post the problem statement in a separate\
    \ question and tag me with a link here, so I can check it out. Also, you can post\
    \ your solution as a separate answer, so I can check it out if I find time to\
    \ look at it (if you don't get to it before next Monday).\n<|/ c |>\n<| c |>\n\
    You're right. I misread the problem statement, thinking \"the longest string is\
    \ unique,\" but the OP said \"the longest string is always the same\" instead\
    \ of \"the longest string is that unique\". I'll edit my answer to change that.\n\
    <|/ c |>\n<| c |>\nI just edited my answer with a more detailed analysis of my\
    \ algorithm. Does that help?\n<|/ c |>\n<| c |>\nI edited my answer to include\
    \ an implementation using your hash table solution. It turns out that my hash\
    \ table solution isn't that good at finding the longest string, so I went ahead\
    \ and implemented my own hash table ", "  strings.max_by(&:length) || strings.first\n\
    end", "  # Compute the longest string\n  longest_string = \"\"\n  if strings.size\
    \ > 0\n    longest_string = strings.sort!.reverse.first.to_s\n  end", "  maxlen\
    \ = -1\n  longest = \"\"", "  strings.sort.reverse\n  longest_string = strings.first\n\
    \  longest_string_length = strings.count\n  strings.each do |string|\n    break\
    \ if string == longest_string\n    longest_string = string\n    longest_string_length\
    \ = string.size\n  end\n  longest_string if longest_string_length > 0\nend", " \
    \ return strings.reduce(function(old, current) \n    if current.length <= old.length\
    \ \n      current \n    else \n      old \n    end)\nend\n</code>\nThe same thing\
    \ can be done with the Array#max method, but the function below is faster in some\
    \ cases:\n<code>", "  strings.sort_by{|s| s.length}\n  longest = strings.last\n\
    \  if strings.empty?\n    return nil\n  end\n  longest_index = 0\n  longest_length\
    \ = 0\n  i = 0\n  while i <= strings.length\n    length = strings[i].length\n\
    \    if length > longest_length\n      longest_length = length\n      longest_index\
    \ = i\n    end\n    i += 1\n  end\n  return longest[longest_index]\nend", "  strings.max_by{\
    \ |string| string.length }\nend", "  strings.flatten.sort.last\nend", "  return\
    \ strings.empty? ? nil : strings.max_by(&:length)\nend", "  strings.reduce(:<)\n\
    end", "  lengths = strings.map {|str| str.size }\n  longest = lengths.max\n  if\
    \ longest\n    strings.find {|str| str.size == lengths[str] }\n  else\n    strings[0]\n\
    \  end\nend", "  return strings.sort.last\nend", "\tstring = strings[0]\n\tbest_length\
    \ = string.length\n\tbest_string = string", "  return strings.flatten.max { |e|\
    \ e.length } if strings.any?\n  return nil\nend\n</code>\n<|/ a tags=ruby,string,arrays\
    \ |>\n<| a tags=ruby,string,arrays |>\n<code>", "    longest = strings.empty?\
    \ || strings.max_by{ |s| s.length } || strings.first\n    if longest.nil?\n  \
    \      nil\n    else\n        longest\n    end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 dscore=1 |>\n<code>", "  return\
    \ strings.size == 0 ? nil : strings.max { |a, b| b.length <=> a.length }\nend",
  "  strings = (strings || []).sort\n  strings.first\nend", "  strings.each_with_index.max_by\
    \ { |a,i| a.length }\nend\n</code>\nAnd then call longest(string_array) instead\
    \ of longest in all your helper functions.\n<|/ a |>\n<| c |>\nYou probably want\
    \ to return the empty array in case no strings have the same length.\n<|/ c |>\n\
    <| c |>\nyes, I should've done that. Thanks.\n<|/ c |>\n<| a |>\nJust for fun,\
    \ here's an alternative that uses a combination of map and max:\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
