name: HumanEval_30_get_positive
language: rb
prompt: "# Return only positive numbers in the list.\ndef get_positive(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_positive\n\
  \    candidate = method(:get_positive)\n    assert_equal([4, 5, 6], candidate.call([-1,\
  \ -2, 4, 5, 6]))\n    assert_equal([5, 3, 2, 3, 3, 9, 123, 1], candidate.call([5,\
  \ 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]))\n    assert_equal([], candidate.call([-1,\
  \ -2]))\n    assert_equal([], candidate.call([]))\n  end\nend\n"
completions: ["  l.map { |x| x > 0 ? x : nil }.compact\nend\n</code>\nIf l is nil,\
    \ then this returns nil.\nIf l is not nil, then you map each element to nil or\
    \ the element itself if the element is positive. Then you compact and return the\
    \ resulting list.\nIf you don't like ternary expressions, you could use a block\
    \ instead:\n<code>", "  l.select { |x| x >= 0 }\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nI wonder if there is a way to make it a bit more terse like `l.select {\
    \ |x| x >= 0 }`.\n<|/ c |>\n<| c |>\nYou can always use `reject`, but that would\
    \ return a different array than `select` does (which makes it less useful here\
    \ since you're only using the `select` result). You could also create your own\
    \ method to do this, by copying `select` and using `reject` instead.\n<|/ c |>\n\
    <| c |>\n`reject` will just return the rejected elements, which would require\
    \ a second step to actually use the values.\n<|/ c |>\n<| c |>\nYes, but `select`\
    \ already returns a new array with only elements that are positive - so no need\
    \ to waste any time by writing a custom method that does the same thing. `select`\
    \ does that already.\n<|/ c |>\n<| a tags=ruby |>\nHere is a function that will\
    \ work regardless of the types of the array elements.\n<code>", "  l.select {\
    \ |e| e.positive? }\nend\n</code>\nYou can then do:\n<code>\nputs get_positive(my_list)\n\
    </code>\nNote that this only works if you have an actual Array. If you have a\
    \ String or something else, you have to use a more sophisticated solution:\n<code>\n\
    get_positive(my_list.split(','))\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| a |>\n\
    Assuming that you have a string that contains your input, and you want to get\
    \ all positive integers out of that string you could do something like this:\n\
    <code>\nstring.scan(/\\d+/).select { |i| i.to_i.positive? }\n</code>\nThis would\
    \ return all positive integers from your string.\n<|/ a dscore=0 tags=ruby |>\n\
    <| a tags=ruby |>\nYou should be able to do:\n<code>\npositive_ints = Array.new(my_string.split).select\
    \ { |i| i.to_i.positive? }\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`my_string.split`\
    \ returns an array, not a string, so `my_string.split` won't work.\n<|/ c |>\n\
    <| c |>\nYes I know, but I didn't want to change what he was doing with his code.\
    \ I've just added a split call at the beginning.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  l.select { |i| i > 0 }\nend", "  l.select { |x| x > 0 }\nend\n</code>\n\
    Now, you can use this method like this:\n<code>\nl = ['a', 'b', nil, 4]\nget_positive(l)\n\
    => [\"b\", nil, 4]\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a |>\nAnother way to do this is to use the select method:\n<code>\nl\
    \ = ['a', 'b', nil, 4]\nl.select(&:present?)\n=> [\"b\", nil, 4]\n</code>\nThe\
    \ advantage of select is that it will return the original array unchanged if none\
    \ of the elements satisfies a condition (like if the nil elements were to be removed).\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 dscore=1 |>\n<| c |>\nJust a nitpick:\
    \ it's better to write `l.select(&:present?)` than `l.select(&:present?)`. `present?`\
    \ returns a boolean, whereas `&:present?` returns a proc. That's not something\
    \ you want to do if the receiver is a boolean, because a boolean is truthy or\
    \ falsy, but a proc is not.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nOne more way is\n<code>\nl = ['a', 'b', nil, 4]\nl.select { |v| v.present?\
    \ }\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ dscore=0 |>\n<code>\nl = ['a', 'b', nil, 4]\nl.select{|e| e.nil? || e.to_i <\
    \ 0}\n</code>\n<|/ a |>\n<| a |>\nIf it's a large list, then you can do something\
    \ like this\n<code>", "  l.select { |e| e >= 0 }\nend\n</code>\n<|/ a dscore=1\
    \ tags=ruby |>\n<| c |>\nIf you're going to use regex to parse a list, then you\
    \ can use the result of `l.select {|e| e >= 0}` to build the filtered array without\
    \ using an intermediate variable (`positive` in the above example).  This isn't\
    \ always the case, though.  As soon as you start manipulating the result of the\
    \ regex or accessing elements by index the regex result is no longer valid.\n\
    <|/ c |>\n<| c |>\nAh, yes you are right, but in the given question, OP has only\
    \ wanted to keep the positive numbers and didn't mention the negatives. But your\
    \ point is valid for sure, thanks for the input\n<|/ c |>\n<| c |>\n, could you\
    \ please provide me with an example of how to access each element using regex?\
    \ Thanks\n<|/ c |>\n<| c |>\n, thank you for all the help. Unfortunately, none\
    \ of the solutions seem to work in the code I'm using. I'm not sure if I should\
    \ raise a new question or edit the original one with the code I'm working with.\
    \ But I have updated my original question with the code I'm using.\n<|/ c |>\n\
    <| c |>\n, thanks again for the help. I'm going to attempt to review my code a\
    \ bit. I have also been unable to find any information as to why this isn't working.\
    \ I've tried a few different ways but none of them seem to work so I'm going back\
    \ and rewriting it again. Thanks for all the help.\n<|/ c |>\n<| a |>\nThe simplest\
    \ way is to use a regex to match the whole string, and then use a block to extract\
    \ the numbers from each line:\n<code>\nlines = %w[\n  1 2\n  3 4\n  5 6\n  7 8\n\
    \  9 0\n]", "  l.select { |x| x > 0 }\nend\n</cell>\n<code language=conda-env-Anaconda3-py>\n\
    get_positive([2,-4,-3,7,4,-7,0,-1,3,-1])\n</cell>\n<code language=conda-env-Anaconda3-py>",
  "  l.select { |x| x > 0 }\nend", "    positive = []\n    for number in l\n     \
    \   if number > 0 && number != nil\n            positive << number\n        end\n\
    \    end\n    positive\nend", "  l.select { |x| x > 0 }\nend", "  l.select(&:positive?)\n\
    end", "  l\nend\n</cell>\n<cell>", "  return l.select{|x| x > 0}\nend", "  l.select{|item|\
    \ item > 0} \nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI actually\
    \ thought of this approach as well, but I felt it wasn't as elegant.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\nIf you need to do this a lot, you could write\
    \ a function that converts the array to a hash and then use grep to find the values\
    \ you want:\n<code>", "    l.select { |x| x >= 0 }\nend\n</code>\nNow you can\
    \ easily get positive numbers in an array. \n<code>\nget_positive([1, 2, 3, 4,\
    \ 5])", "  l.select { |x| x.positive? }\nend\n</code>\n<|/ a |>\n<| c |>\nThe\
    \ question specifically says that this is homework and no one would give the answer\
    \ but rather guide to the right answer\n<|/ c |>\n<| c |>\n: No, it doesn't specifically\
    \ say that.\n<|/ c |>\n<| c |>\nThe question does specifically say that this is\
    \ homework.\n<|/ c |>\n<| c |>\n: It also says that no one would give the answer.\
    \ It's a polite way of saying \"if you are not allowed to use methods that you\
    \ find interesting, you are not allowed to use methods that you find interesting\"\
    .\n<|/ c |>\n<| c |>\nThis is actually a good answer, since it shows a different\
    \ way of doing things. I agree that this is a better way of doing things, which\
    \ is why I upvoted it :). However, this answer assumes that you already have some\
    \ knowledge in Ruby on how to do the assignment (or you can work through some\
    \ online tutorial), which is quite reasonable for this kind of assignments.\n\
    <|/ c |>\n<| a |>\n<code>", "  l.select {|x| x > 0 }\nend", "  return l.select\
    \ {|num| num.positive?}\nend", "  l.select { |x| x >= 0 }\nend", "    positive\
    \ = []\n    positive.push l[1]\n    positive.push l[2]\n    positive.push l[3]\n\
    \    positive.push l[4]\n    positive.push l[5]\n    positive.push l[6]\n    positive.push\
    \ l[7]\n    positive.push l[8]\n    positive.push l[9]\n    positive.push l[10]\n\
    \    positive.push l[11]\n    positive.push l[12]\n    positive.push l[13]\n \
    \   positive.push l[14]\n    positive.push l[15]\n    positive.push l[16]\n  \
    \  positive.push l[17]\n    positive.push l[18]\n    positive.push l[19]\n   \
    \ positive.push l[20]\n    positive.push l[21]\n    positive.push l[22]\n    positive.push\
    \ l[23]\n    positive.push l[24]\n    positive.push l[25]\n    positive.push l[26]\n\
    \    positive.push l[27]\n    positive.push l[28]\n    positive.push l[29]\n \
    \   positive.push l[30]\n    positive.push l[31]\n    positive.push l[32]\n  \
    \  positive.push l[33]\n    positive.push l[34]\n    positive.push l[35]\n   \
    \ positive.push l[36]\n    positive.push l[37]\n    positive.push l[38]\n    positive.push\
    \ l[39]\n    positive.push l[40]\n    positive.push l[41]\n    positive.push l[42]\n\
    \    positive.push l[43]\n    positive.push l[44]\n    positive.push l[45]\n \
    \   positive.push l[46]\n    positive.push l[47]\n    positive.push l[48]\n  \
    \  positive.push l[49]\n    positive.push l[50]\n    positive.push l[51]\n   \
    \ positive.push l[52]\n    positive.push l[53]\n    positive.push l[54]\n    positive.push\
    \ l[55]\n    positive.push l[56]\n    positive.push l[57]\n    positive.push l[58]\n\
    \    positive.push l[59]\n    positive", "  l.select{|x| x > 0 }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=0 tags=ruby-on-rails |>\nYou can put in two array\n\
    <code>\narr1 = []\narr2 = []\n</code>\nThen, make an iteration loop\n<code>\n\
    for i in 0...10\n  if i != 1\n     arr1 << i\n  end\n  if i != 9\n     arr2 <<\
    \ i\n  end\nend\n</code>\nFinally you can join arr1 and arr2 to get the result\n\
    <|/ a |>\n<| a tags=ruby-on-rails |>\nYou can do something like this using inject\
    \ method:\n<code>\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].inject([]) { |x, v| x << v\
    \ if v == 1; x }\n=> [1, 1, 1, 2, 2, 2, 3, 3, 3, 3]\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nYou could do that in the block and return x. No need to use inject here\
    \ at all.\n<|/ c |>\n<| c |>\nYeah, it could be done without `inject` too. :)\
    \ Just wanted to show how you can put condition inside.\n<|/ c |>\n<| a tags=ruby-on-rails\
    \ |>\nYou can easily get it done using each_concat and reject. Below is the sample\
    \ code.\n<code>\narray = [1,2,3,4,5,6,7,8,9,10]\narray.reject { |e| e == 1 }.each_cons(2)\
    \ do |a, b| \n  puts \"#{a} #{b}\"\nend\n</code>\nOutput\n<code>\n1 2\n1 3\n1\
    \ 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ will print out all the odd numbers but not the even ones\n<|/ c |>\n<| c |>\n\
    , My mistake, my answer was a little bit late. Will delete it shortly.\n<|/ c\
    \ |>\n<| c |>\nPlease don't delete answers. It will help the community in the\
    \ future.\n<|/ c |>\n<| c |>\n, I have already updated my answer, now it will\
    \ give even numbers as well. Thanks for pointing out the mistake.\n<|/ c |>\n\
    <| c |>\nNo problem, that's fine. I just wanted to point it out because you didn't\
    \ have it initially.\n<|/ c |>\n<| a dscore=0 tags=ruby-on-rails |>\nUsing Enumerable#",
  "  l.select {|n| n > 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nNice! It's hard to know\
    \ what to call it, because it isn't just \"filtering\" but also \"filtering the\
    \ elements\". Another one would be \"filtering the elements to those that pass\
    \ the predicate\".\n<|/ c |>\n<| c |>\n+1 for pointing out the naming convention\
    \ for the first filter. I was sure it had to be called a \"predicate\", but I\
    \ was struggling to find it when googling.\n<|/ c |>\n<| a dscore=2 tags=ruby,ruby-on-rails,list\
    \ |>\n<code>\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 31].select { |i| i < 100 }\n</code>\n\
    <|/ a |>\n<| c |>\nThe question was how to select only positive numbers.\n<|/\
    \ c |>\n<| c |>\nIn case you were wondering, \"< 100\" does not mean \"less than\
    \ 100\" but \"less than or equal to 100\"\n<|/ c |>\n<| c |>\nYou don't need to\
    \ use 'i' in your block\n<|/ c |>\n<| a dscore=2 tags=ruby,ruby-on-rails,list\
    \ |>\n<code>\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 31].select{|num| num > 0}\n</code>\n\
    <|/ a |>\n<| a tags=ruby,ruby-on-rails,list |>\nTo make it more \"functional\"\
    , you could use:\n<code>\n>> p [23,25,27].select {|x| x > 0}\n=> [25, 27]\n</code>\n\
    Or:\n<code>\n>> p [23,25,27].select {|x| x % 2 == 0}\n=> [25, 27]\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\n`x % 2 == 0` is the same as `x % 2 == 1`\n<|/ c |>\n\
    <| c |>\nYes, my mistake. Corrected the answer. Thanks for the hint.\n<|/ c |>\n\
    <| a dscore=2 |>\nUse Enumerable#grep.\n<code>\n[2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 31].grep{|i| i>0} #=> [5, 7, 11, 13, 17, 19]\n</code>\n<|/ a tags=ruby,ruby-on-rails,list\
    \ |>\n<| a |>\nIn Ruby 2.4.1 there are two methods related to this question:\n\
    <code>\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 31].gre", "  l.map{|x| x<0 ? nil : x}\n\
    end", "    positive = []\n    positive.each do |number|\n        if number > 0\n\
    \            puts number\n        end\n    end\nend", "    l.select { |x| x >\
    \ 0} \nend", "  return l.select { |n| n < 0 }\nend", "  l.select{|x| x > 0}\n\
    end", "    positive = []\n    positive.push l[0] if l.first == -1 \n    return\
    \ positive\nend", "  l.select { |x| x.positive? }\nend\n</code>\nIf you need this\
    \ often, I recommend you to create your own module with these methods and to require\
    \ it in your files that need this behavior.\n<|/ a dscore=2 tags=ruby |>\n<| c\
    \ |>\nThanks! That was really helpful. One question: in the last code block you\
    \ wrote, what does `lambda { |x| x.positive? }` do? I read that it is a proc,\
    \ but what exactly is it doing?\n<|/ c |>\n<| c |>\nIt's a block, it's a sort\
    \ of anonymous method definition. See [this post](http://stackoverflow.com/questions/343057/what-are-closures-in-ruby)\
    \ for an explanation of closures in Ruby. You can also read [this](http://www.tutorialspoint.com/ruby/ruby_blocks.htm)\
    \ article for further information.\n<|/ c |>\n<| c |>\nAhh, I see. Thanks a lot!\n\
    <|/ c |>\n<| a dscore=1 |>\nAnother option (although not as concise) is to define\
    \ a class method in the class that returns a new array containing only positive\
    \ numbers:\n<code>", "  l.select{|el| el > 0}.map(&:to_i)\nend", "  l.select {|x|\
    \ x > 0} \nend\n</code>\nTo return only negative numbers:\n<code>", "  l.select\
    \ { |x| x > 0} # Returns only the positive numbers\nend", "  l.select { |e| e.positive?\
    \ }\nend", "  l.select { |e| e > 0 }\nend", "  return l.select { |num| num > 0\
    \ }\nend", "    l.select { |v| v > 0 }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| a dscore=0 |>\n<code>", "  return l.select { |x| x > 0 }\nend", "    l.select(&:positive?)\n\
    end", "  l.select{ |x| x > 0 }\nend", "    l.delete_if { |x| x.zero? || x.negative?\
    \ }\nend\n</code>\nIt is not necessary to call delete_if, as it iterates the list\
    \ until it finds the first element that meets the condition (!x.zero? || x.negative?),\
    \ and keeps that element in the list, while removing all other elements from the\
    \ list. \nThe above method can be used as follows:\n<code>\nputs \"Enter the list\
    \ of numbers\"\ngets.chomp.to_a.delete_if { |x| x.zero? || x.negative? }\n</code>\n\
    Or more succinctly:\n<code>\nputs \"Enter the list of numbers\"\ngets.chomp.to_a.select(&:nonzero?).map(&:to_i)\n\
    </code>\n<|/ a |>\n<| c |>\nIt's not necessary to `delete_if` here, as `select`\
    \ will stop once it finds a matching element. Just `map(&:to_i)` is all that's\
    \ needed.\n<|/ c |>\n<| c |>\n: Yeah, `select` is more succinct than `delete_if`\
    \ (and faster than `delete_if`). Updated the answer :)\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere's another approach, inspired by the answers to this question:\n<code>\n\
    puts \"Enter the list of numbers\"\nnumbers = gets.chomp.split(//)", "  l.select{|a|\
    \ a > 0 }\nend\n</code>\nNow we can use select to get only positive numbers in\
    \ our array\n<code>\nget_positive([1,2,-3,4])", "  return l.select { |i| i >=\
    \ 0 }\nend\n</code>\nA negative number is a negative number.\n<code>", "    positive\
    \ = l.select { |e| e.is_a?(Fixnum) && e > 0 }\nend", "    l.select {|x| x >= 0}\n\
    end\n</code>\nYou can even use Enumerable#select to filter a collection:\n<code>",
  "  if l\n    l.select { |x| x > 0 }\n  end\nend", "  l.select{|x| x.positive?}\n\
    end", "  return l.select { |e| e > 0 }\nend", "    l.map!{|x| x if x > 0 }\nend",
  "  l.select{|x| x >= 0} \nend", "  return l.select {|e| e.is_a?(Fixnum) && e > 0}\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't quite work -- it converts\
    \ any Fixnum to true in get_positive.  (Fixnum is the only non-nil number in ruby's\
    \ numeric classes, and true is also a Fixnum.)\n<|/ c |>\n<| c |>\nI tested it\
    \ on IRB and it returns `[4, 3, 2]` for `[4, 3, nil, 2]` as expected.\n<|/ c |>\n\
    <| c |>\nYes.  That's how it works -- `nil.to_i` is 0.  You can test it with irb:\
    \ `nil.to_i; nil.to_i.is_a? Fixnum; nil.to_i.is_a? Integer; nil.to_i.is_a? Numeric`.\
    \  (In fact, it's probably a lot more complicated than that.)\n<|/ c |>\n<| c\
    \ |>\nThanks for the clarification. I always thought that `Fixnum` was the only\
    \ non-nil number in ruby's numeric classes. But now I realised that `Fixnum` is\
    \ the only class in ruby that doesn't equal `nil`.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "    positive = []\n    positive.concat(l if l.any? { |num| num > 0 })\n\
    end\n</code>\nNow you can call it in your code as follows\n<code>\nget_positive(@result).first\n\
    </code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails |>\n<| c |>\nThat's a pretty good\
    \ approach but it won't work if there are duplicates in the array (e.g. `[\"1\"\
    , \"2\", \"3\", \"4\", \"5\", \"5\"]`). In this case I'd return only one of them.\n\
    <|/ c |>\n<| c |>\nI like this solution. I would add that you can also use `each_with_object`\
    \ instead of `inject` here as `inject` is only necessary when you want to preserve\
    \ the accumulator value somehow (in this case, you don't, so you can just use\
    \ `each_with_object`). In general, using `inject` when all you need is a value\
    \ from each element is probably a bit unnecessary and misleading.\n<|/ c |>\n\
    <| c |>\n, agreed. I have edited my answer to include this suggestion. Thanks\
    \ :)\n<|/ c |>\n<| c |>\n, I've added your suggestion in my answer.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails dscore=2 |>\nYou can use the select method to achieve\
    \ what you want:\n<code>.select { |item| item > 0 }\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nYou can use the select method:\n<code>.select { |i| i > 0 }\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicates in the array\
    \ (e.g. [\"1\", \"2\", \"3\", \"4\", \"5\", \"5\"]). In this case I'd return only\
    \ one of them.\n<|/ c |>\n<| a |>\n<code>.select { |i| i.to_i > 0 }\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails dscore=1 |>\n<| a dscore=1 tags=ruby,ruby-on-rails\
    \ |>\n<code>.select { |x| x.to_i > 0  }\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>.collect { |number| number.to_i if number.to_i > 0 }\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the array (e.g. [\"\
    1\", \"2\", \"3\", \"4\", \"5\", \"5\"]). In this case I'd return only one of\
    \ them.\n<|/ c |>\n<| c |>\nI ", "  l.select { |x| x.positive? }\nend", "  l.select{|n|\
    \ n < 0}.map(&:to_i).compact\nend\n</code>\n<|/ a |>\n<| c |>\nNote that `select`\
    \ is an alias for `find_all`, so `filter!` will do, and `compact` isn't really\
    \ needed as it's implicit when you call `select`, just like `map` + `compact`.\
    \ Also, `&:to_i` is redundant - `&` already does that for you.\n<|/ c |>\n<| a\
    \ |>\nOne other thing you could do would be to convert it to a hash and then select\
    \ out the values:\n<code>", "  l.select { |n| n > 0 }\nend", "  positive = []\n\
    \  l.each do |i|\n    if i[0] > 0\n      positive << i\n    end\n  end\n  positive\n\
    end", "  l.select { |i| i >= 0 }\nend\n</code>\nNow, let's see what happens when\
    \ we run get_positive([1,-1,0]).\nIn our first step, we will get [2, -1] since\
    \ the first element in the array is greater than or equal to 0.\nThe next iteration\
    \ will do nothing, because the first element is already less than 0. This is because\
    \ the first element of our array is 1, which means we are adding 1 to the array.\
    \ That is, our array is now [2, -1].\nThe second element is -1, which means we\
    \ are subtracting 1 from the array. This is because our array is now [2, -1] and\
    \ we need to subtract 1 from -1.\nThe third element is 0, which means we are subtracting\
    \ 1 from the array. This is because our array is now [2, -1] and we need to subtract\
    \ 1 from -1.\nTherefore, our array is [2, -1] after the second iteration.\nFinally,\
    \ our return value is [2, -1].\n<|/ a dscore=2 |>\n<| c |>\nNice explanation,\
    \ thanks. I do have one question though. Why does the first loop return [-1, -1]\
    \ when `i = 1` since `1 < 0`?\n<|/ c |>\n<| c |>\nI edited my answer. I hope it\
    \ is clearer now.\n<|/ c |>\n<| c |>\nThank you, I now understand why my code\
    \ fails. Would you mind elaborating on the explanation though? Why does the first\
    \ loop return [-1, -1] when `i = 1` since `1 < 0`?\n<|/ c |>\n<| c |>\nI added\
    \ some explanation to my answer.\n<|/ c |>\n<| c |>\nThank you! Very helpful\n\
    <|/ c |>\n<| a dscore=1 |>\nThe problem is with your loop\n<code>", "  l.map {\
    \ |s| s.to_i if s.is_a?(Integer) }\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails\
    \ |>\n<| a tags=arrays,ruby,ruby-on-rails |>\n<code>\narray.map { |e| e.is_a?(Integer)\
    \ ? e : e.to_i }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis won't work if the\
    \ value is an `Array` itself. See my answer.\n<|/ c |>\n<| c |>\nThis will work\
    \ if you add a `to_a` around your `e.is_a?(Integer)` since it will always return\
    \ `e` when `e` is not an `Integer`.  See my answer.\n<|/ c |>\n<| a tags=arrays,ruby,ruby-on-rails\
    \ |>\n<code>\narray.map! { |e| e.is_a?(Integer) ? e : e.to_i }\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=arrays,ruby,ruby-on-rails |>\nThe easiest way to deal\
    \ with this is to filter out non-integers:\n<code>\narray = array.select { |e|\
    \ e.is_a?(Integer) }\n</code>\nThat way, you'll get a nil instead of an array\
    \ where some elements are nil.\n<|/ a dscore=0 |>\n<| c |>\nThis won't work if\
    \ the value is an `Array` itself. See my answer.\n<|/ c |>\n<| a tags=arrays,ruby,ruby-on-rails\
    \ |>\n<code>\narray = [1,3.1,[4,5],[6,7,8]]\n</code>\nThe first thing that comes\
    \ to mind is:\n<code>\narray.map { |e| e.is_a?(Integer) ? e : e.to_i }\n</code>\n\
    But this doesn't work, because Integer#to_i returns an Integer. For example:\n\
    <code>\narray = array.map { |e| e.is_a?(Integer) ? e : e.to_i }\narray.map { |e|\
    \ e.is_a?(Integer) ? e : e.to_i }.class\n=> Array\narray.map { |e| e.is_a?(Integer)\
    \ ? e : e.to_i }.class\n=> Integer\n</code>\nThe second thing that comes to mind\
    \ is:\n<code>\narray.map { |e| e.is_a?(Integer) ? e.to_i : e }\n</code>\nBut this\
    \ doesn't work either. For example:\n<code>\narray = array.map { |e| e.", "  l.select\
    \ { |x| x >= 0 }\nend\n</code>\nI added an explicit return statement at the end\
    \ of the method, so that all valid options in the list will be returned. \nThe\
    \ reason I used select is because I like using method chaining as it can lead\
    \ to nice readable code. \nAs you mentioned, you can also use reject or select\
    \ to remove elements from the array. \nUsing select is probably more efficient\
    \ than using reject and select in that they don't build a new array and return\
    \ the result immediately. \n<code>", "  return l.select { |x| x > 0} \nend\n</code>\n\
    You can read more about these functions in the documentation.\n<|/ a dscore=3\
    \ tags=ruby,arrays,ruby-on-rails-3 |>\n<| a |>\n<code>\narray = [\"0\",\"1\",\"\
    2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"]\narray.select{|x| x.to_i\
    \ == x}\n</code>\n<|/ a dscore=2 tags=ruby,arrays,ruby-on-rails-3 |>\n<| c |>\n\
    `x.to_i == x` => `x == x.to_i`. And `x.to_i > 0` => `x.to_i > 0`\n<|/ c |>\n<|\
    \ c |>\nThis should be `x.to_i.zero?`\n<|/ c |>\n<| c |>\nI don't think that's\
    \ right. `[\"0\", \"1\", \"2\"].select { |x| x.to_i > 0 } == [\"0\", \"1\", \"\
    2\"]` => false.\n<|/ c |>\n<| c |>\nNo, it's not right. `[\"0\", \"1\", \"2\"\
    ].select { |x| x.to_i.zero? } == [\"0\", \"1\", \"2\"]` => true :)\n<|/ c |>\n\
    <| c |>\nThat's right! I didn't test it, because `x.to_i` is the same as `x` here.\n\
    <|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails-3 |>\nHere's a more succinct way\
    \ that avoids creating an array with zeroes in it:\n<code>\na = [1, 3, 5]\na.select\
    \ { |x| x > 0}.flatten\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>",
  "  return l.select {|x| x > 0 }\nend\n</code>\nand now the second method is called\
    \ in the following way:\n<code>", "  l.select { |x| x > 0} \nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| a |>\n<code>\n[12,14,34,56,89,43,32].max\n\
    => 32\n</code>\n<|/ a dscore=4 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<|\
    \ a dscore=4 |>\n<code>\n[12,14,34,56,89,43,32].max\n=> 32\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a dscore=3 |>\nFor an array of objects you can do this:\n<code>\n[{ name:\
    \ 'Ben', age: 24 }, { name: 'John', age: 38 }].max_by(&:age)\n</code>\nFor an\
    \ array of integers you can do this:\n<code>\n[12, 14, 34, 56, 89, 43, 32].max_by(&:max)\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nthis should\
    \ be the best answer\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n\
    <code>\nmy_array = [12,14,34,56,89,43,32]\n</code>\nJust use \n<code>\nmy_array.max\n\
    </code>\nit will return you 32 as max.\n<|/ a dscore=3 |>\n<| c |>\nThis will\
    \ return 43 as max even if it's not the highest value.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing out the mistake, have updated the answer.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\nYou can use Enumerable#max_by as of ruby 2.6. \n<code>\n[12,14,34,56,89,43,32].max_by\
    \ { |a| a }\n</code>\nFor older versions use Enumerable#max_by to find the max\
    \ element and then use the Enumerable#max method on the returned max element.\
    \ \n<code>\n[12,14,34,56,89,43,32].max_by { |a| a }.max\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 |>\n<code>", "  l.select { |v| v > 0 }\nend", "  l.select\
    \ { |i| i.positive? }\nend\n</code>\nOr even better: \n<code>", "  # Use select\
    \ to create a new list with only the positive numbers in l.\n  positive = l.select\
    \ { |num| num > 0 }\n  # Return the new list.\n  positive\nend", "  l.select{\
    \ |i| i > 0 }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n`select` is an instance\
    \ method of `Enumerable` so it doesn't work on Strings.\n<|/ c |>\n<| c |>\nSorry,\
    \ I should have been clearer. It's a method in the `Enumerable` module. Which\
    \ is included in the `ActiveSupport` module. It's a method that is built into\
    \ Ruby, not ActiveSupport.\n<|/ c |>\n<| c |>\nIf you're going to use Rails, you\
    \ should probably at least be using `ActiveSupport::CoreExtensions::Enumerable`,\
    \ not `Enumerable`. Rails 3.2 and up automatically include the Rails extensions.\n\
    <|/ c |>\n<| c |>\nThanks for the answer. I'm actually not using Rails. I'm currently\
    \ using Sinatra (my web framework). Does this change anything? Or is my question\
    \ too vague for StackOverflow?\n<|/ c |>\n<| c |>\nI'm not familiar with Sinatra,\
    \ but that shouldn't change anything.\n<|/ c |>\n<| a tags=ruby,regex |>\nJust\
    \ a little tweak to what has been done by Tom.\nYou can pass the variable \"variables\"\
    \ as the arguments and then use to_enum to convert the variable as an enumerable\
    \ object. This way you can directly apply the \"select\" method on it. It will\
    \ be executed for each of the element one by one.\n<code>\nvariables = %w[abc\
    \ def ghi klm]\nvariables.to_enum.select{ |x| x.match('[a-z]') }.to_a\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\n`to_enum` is only necessary for Rails 3.2 or older.\
    \ Newer versions automatically include Rails' extensions.\n<|/ c |>\n<| a dscore=0\
    \ tags=ruby,regex |>\n<code>", "  l.select { |x| x > 0 }\nend\n</code>\nThen you\
    \ could just do:\n<code>\nget_positive(my_list)\n</code>\nOr you could use map\
    \ instead of select. Which you use will depend on whether you want a list or a\
    \ set, which you didn't specify.\n<|/ a tags=ruby |>\n<| c |>\nYes, this was just\
    \ an example of a method I might have.\n<|/ c |>\n<| c |>\nI added an example\
    \ of using map instead of select.\n<|/ c |>\n<| c |>\n\"Or you could use `map`\
    \ instead of `select`.\" Why? They do the same thing. Also you might want to say\
    \ `get_positive(my_list.map { |x| x - 1 })` since the OP said they don't want\
    \ a list but rather a set.\n<|/ c |>\n<| a tags=ruby |>\nIn Ruby, you could use\
    \ Enumerable#drop_while to remove elements until a certain condition is met.\n\
    <code>\nmy_list.drop_while { |e| e <= 0 }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>\nmy_list - [my_list.min]\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This doesn't work if my_list is a `Float`, since `[my_list.min]` is `[my_list.to_f]`,\
    \ which is not `my_list`.\n<|/ c |>\n<| a |>\nYou can do it in a single line with\
    \ a compact method (docs):\n<code>\nmy_list - my_list.min\n</code>\n<|/ a dscore=1\
    \ tags=ruby |>\n<| c |>\nThis doesn't work if `my_list` is a float, since `my_list.min`\
    \ is `my_list.to_f`, which is not `my_list`.\n<|/ c |>\n<| a dscore=0 |>\nYou\
    \ can do it in one line:\n<code>\nmy_list - my_list.min\n</code>\nBut I wouldn't\
    \ recommend it -- it's just too easy to make mistakes. And it's not very efficient.\
    \ That's one of the reasons I suggest you use map instead (docs).\nIf you're worried\
    \ about the efficiency of a single line, don't use it!\n<|/ a tags=ruby |>\n<|\
    \ c |>\n`my_list - my_list.min` doesn't work because `my_list.min` is an `Integer`\
    \ and isn't a list itself.\n<|/ c |>\n<| c |>\nThe question does say they don't\
    \ want to return a list. They want a set. `", "    positive = []\n    l = l.split(\"\
    , \")\n    l.each do |i|\n        if i.include? \"+\"\n            positive.push(i)\n\
    \        end\n    end\n    return positive\nend\n</code>\nI hope that helps!\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,regex |>\nIf it is the only case where you know\
    \ that the string will match a regex, you don't need to use regex. Just split\
    \ the string on \",\" and use include? on the resulting array:\n<code>", "  l.select\
    \ { |item| item > 0 }\nend\n</code>\nNote that instead of using select we could\
    \ also use find_all to return a list of all positive numbers in the list. If we\
    \ do that we can shorten the method to:\n<code>", "  l.select { |x| x > 0  }\n\
    end", "  l.select { |x| x.positive? }\nend", "  return l.select { |x| x > 0 }\n\
    end", "  l.select { |i| i > 0 }\nend", "  l.select { |i| i >= 0 }\nend", "  l.select\
    \ { |x| x > 0 }\nend\n</code>\n<code>\nget_positive([5, -2, 0])", "    return\
    \ l.select { |e| e > 0 }\nend", "  return l.select {|n| n > 0} # or [n for n in\
    \ l if n > 0]\nend", "  l.select { |e| e.is_a? Integer && e > 0}.map!(&:to_i)\n\
    \  l\nend\n</code>\n<|/ a tags=list,integer,ruby |>\n<| c |>\n`&:to_i` could be\
    \ simplified as `&:to_i` (since `&` converts the block to a Proc that already\
    \ converts it to an Integer :) ). Also, this doesn't really filter negative numbers\
    \ in the list.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l = l.select { |e| e >\
    \ 0 }\n  l\nend", "    return l.select{|i| i > 0}\nend", "  return l.select{ |e|\
    \ e.to_i > 0} \nend\n</code>\nThe select method will allow us to keep the list\
    \ the same size as our original list but only return the elements that meet the\
    \ criteria for the block.  \n<code>\nl = [\"apple\", \"banana\", \"carrot\", \"\
    dog\", \"elephant\", \"fish\"]\nget_positive(l)\n  #=> [\"carrot\", \"dog\", \"\
    fish\"] \n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe above answer is good but if\
    \ you don't need duplicates, like for instance if you just want to get all positive\
    \ numbers from a list then it's better to just use #reject. `arr.reject { |x|\
    \ x<0 }`. No need to create a temporary array and then select from it if you just\
    \ want to reject negative values.\n<|/ c |>\n<| c |>\n: That was my first thought\
    \ as well, but then I thought that if the input was a string, it would return\
    \ an empty array, since the string doesn't have any positive numbers.  So I chose\
    \ to return an empty array instead.\n<|/ c |>\n<| c |>\nYou do not need select\
    \ to reject negative numbers, you can just do `arr.select{ |x| x>0  }`. Remember\
    \ that `select` returns a new array.\n<|/ c |>\n<| a |>\nUsing reject:\n<code>\n\
    [1,2,3,4,5].reject { |n| n <= 0 }\n</code>\n<|/ a tags=ruby dscore=5 |>\n<| a\
    \ |>\nIn case you are using ActiveSupport and Rails, you can use select method:\n\
    <code>\n[1,2,3,4,5].select(&:positive?)", "  l.select { |n| n >= 0 }\nend", " \
    \ l.select{ |x| x > 0 }\nend", "  l.select { |i| i >= 0 }\nend\n</code>\nTo use\
    \ these functions, we simply assign them to the class methods we want to modify:\n\
    <code>", "    l.grep(/\\d+/).map{|n| n.to_i}\nend", "  l.select{|x| x>0}\nend",
  "  l.select{|x| x > 0}\nend", "  l.select { |x| x > 0 }\nend", "    l.select { |x|\
    \ x > 0  }\nend", "  l.select {|v| v > 0 }\nend\n</code>\nSo the whole code is\n\
    <code>", "  l.select{ |x| x > 0}.map(&:to_i).flatten\nend", "  return l.select\
    \ { |x| x > 0} # Returns a new list without deleted elements.\nend", "    l.select\
    \ { |x| x > 0 }\nend", "  l.select { |e| e >= 0 }\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis assumes negative numbers are also the only values that are in the\
    \ list. Is this correct?\n<|/ c |>\n<| c |>\nIn that case you can reverse the\
    \ list `l.select { |e| e < 0 }` and then reverse it again.\n<|/ c |>\n<| c |>\n\
    I thought about this but the input to the function is already reversed and it\
    \ needs to stay that way :(\n<|/ c |>\n<| c |>\nThen I guess you will have to\
    \ do as Mike suggested.\n<|/ c |>\n<| a dscore=1 tags=ruby,arrays,sorting |>\n\
    This will return negative numbers. If you want only positive numbers just remove\
    \ the '<' sign.\n<code>", "  l.select{|x| x.to_i > 0} \nend\n ", "  l.select {\
    \ |x| x > 0 }\nend\n</code>\nNow we can do the computations:\n<code>", "  l.select\
    \ { |x| x > 0 }\nend", "  l.select { |e| e >= 0 }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nThe method I used was:\n<code>", "  l.select {|i| i > 0} # Return\
    \ only positive numbers in the list.\nend\n</code>\n<code>\n> get_positive([1,\
    \ 2, 3, -1])", "  l.select { |x| x.positive? }\nend\n</code>\nThe first two methods\
    \ are there to illustrate how we might create custom methods. In this case, we\
    \ define two new methods: one that selects positive numbers in a list, and the\
    \ other that does not.\nThe second method uses #select to do the heavy lifting\
    \ of filtering out negative numbers. Since #select returns an Enumerator, it can\
    \ be chained to the original list.\n<code>\na = [-1, 0, 1, 2, 3]\na.select { |x|\
    \ x.positive? } # => [0, 1, 3]\na.select { |x| x.positive? }.size # => 2\n</code>\n\
    Notice how we do not have to call #size to retrieve the size of the returned Enumerator.\
    \ This is very important!\nFinally, let's combine our two methods into a single\
    \ method.\n<code>", "  l.select { |x| x > 0 }\nend\n</code>\nUsing those functions\
    \ you can implement the get_positive_numbers method which returns a list of all\
    \ positive numbers in an array.\n<code>", "  l.select { |x| x > 0 }\nend", " \
    \ l.select{|x| x > 0 }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,ruby\
    \ dscore=2 |>\nYou could use grep with a block:\n<code>\np [1,2,3,4,5].grep(/\\\
    d+/){|v| v > 0}", "  l.collect { |v| v.to_i if v.positive? }\nend", "  l.select{|x|\
    \ x > 0 }\nend", "  return l.reject { |x| x < 0 }\nend\n</code>\nThis makes it\
    \ possible to filter a list based on whether each element meets a certain criteria\
    \ using something like:\n<code>\nlist = [1, 2, 3, 4]\npositive = get_positive\
    \ list # => [2, 4]\n</code>\n<|/ a tags=ruby,arrays,loops |>\n<| c |>\nWhy not\
    \ `l.select(&:positive?)`?\n<|/ c |>\n<| c |>\nI thought about this myself, but\
    \ didn't think it through fully. Thanks for pointing that out!\n<|/ c |>\n<| c\
    \ |>\nIn ruby 2.4.0, `&:positive?` will not work, `&:positive?` needs a lambda.\n\
    <|/ c |>\n<| a |>\n<code>\np [1,2,3].select {|x| x > 0 }\n</code>\n<|/ a tags=ruby,arrays,loops\
    \ dscore=5 |>\n<| c |>\nThis is the correct answer. I'm sure the asker probably\
    \ doesn't know this method.\n<|/ c |>\n<| c |>\nThis answer is correct even when\
    \ you're not looking for positive, zero, negative, but any element greater than\
    \ zero.\n<|/ c |>\n<| c |>\nI think this could be the best answer. Simple and\
    \ clean, even if it is a `lambda` one.\n<|/ c |>\n<| c |>\nI personally find it\
    \ easier to read and understand `[1,2,3].select{ |x| x > 0 }`\n<|/ c |>\n<| c\
    \ |>\nThis is the best answer IMO.\n<|/ c |>\n<| a tags=ruby,arrays,loops dscore=5\
    \ |>\nAs in most languages, Ruby allows you to pass an array of objects to each,\
    \ so you can do this:\n<code>\narray = [1,2,3]\narray.each {|e| puts e*2 }\n</code>\n\
    <|/ a |>\n<| c |>\nIf each is what you're after, and you have a big array to iterate\
    \ through, consider this answer instead:\n`array.map { |e| e*2 }`\n<|/ c |>\n\
    <| c |>\nIn Ruby 1.8.7+ and Ruby 1.9+, `array.each(&Proc.new)` also works.\n<|/\
    \ c |>\n<| c |>\nYou might need to do `array.each(&method(:puts))`, otherwise\
    \ `puts` will be treated as a block rather than as an object. `array.each(&Proc.new)`\
    \ also works, though it might not work in many cases.\n", "  l.select{ |x| x >\
    \ 0 }\nend\n</code>\nSo your output looks like this:\n<code>\nputs get_positive([-1,\
    \ 0, 3, -1, 2])", "  return l.select { |x| x > 0 }\nend", "  l.select { |x| x\
    \ >= 0 }\nend", "  l.select { |item| item > 0 }\nend", "  l = l - [0]\n  l = l\
    \ - [\"\"]\n  l.reduce(:+)\nend", "  l.select { |x| x > 0 }\nend", "  positive\
    \ = []\n  l.each do |e|\n    if e.positive?\n      positive << e\n    end\n  end\n\
    \  positive\nend", "  l.select { |i| i > 0 }\nend", "  positive = nil\n  l.each\
    \ do |x|\n    next unless x.is_a? Integer\n    next if x.is_a? Float\n    next\
    \ if x.positive?\n    positive << x\n  end\n  positive\nend\n</code>\nWith this\
    \ function, we now have the following two lines:\n<code>", "  l.select { |e| e\
    \ >= 0 }\nend\n</code>\n<|/ a dscore=2 tags=ruby,ruby-on-rails,list |>\n<| c |>\n\
    This was very helpful, thanks. I have been playing around with your code to see\
    \ how it works and it seems to do exactly what I need. I am going to mark this\
    \ as the answer as it does exactly what I need it to do and gives me a great learning\
    \ opportunity to understand what is going on with your code. Thanks again.\n<|/\
    \ c |>\n<| c |>\n: It's a cool code. Thanks for sharing. :)\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,list\
    \ dscore=1 |>\n<code>\nmodule Enumerable\n  def not_contains?(value)\n    each\
    \ {|x| return false if x == value}\n    true\n  end\nend", "  positive = []\n\
    \  l.each do |i|\n    if i > 0 then\n      positive.push(i)\n    end\n  end\n\
    \  return positive\nend\n</code>\nAnd to get the positive numbers of the list\
    \ we call:\n<code>\npositives = get_positive(mylist)\n</code>\n<|/ a tags=ruby,arrays,sorting,list\
    \ dscore=0 |>\n<| a |>\nYou can do it with ruby as well, here is an example:\n\
    <code>\nmylist = %w{1 2 4 -3 -5 6 7 -1}\nmylist.map { |e| e > 0 ? e : nil }.compact\n\
    </code>\n<|/ a dscore=0 tags=ruby,arrays,sorting,list |>\n<| c |>\nI guess you\
    \ mean `mylist.map { |e| e > 0 ? e : nil }.compact`\n<|/ c |>\n<| a tags=ruby,arrays,sorting,list\
    \ |>\n<code>\nmylist = [-5, -4, -2, 1, 4, 8, -3]\nmylist.compact!.select {|x|\
    \ x>0}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nUsing `select!` would avoid removing\
    \ items from the original list which might not be desirable.\n<|/ c |>\n<| a tags=ruby,arrays,sorting,list\
    \ |>\nAnother way:\n<code>\nmylist = [-5, -4, -2, 1, 4, 8, -3]\nmylist.select\
    \ {|e| e > 0}\n</code>\nThis will return an array with all items which have a\
    \ positive value.\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,sorting,list |>\n\
    Just for completeness, here is a version using Enumerable#each_with_object():\n\
    <code>\nmylist = [-5, -4, -2, 1, 4, 8, -3]", "  # Use grep to select only positive\
    \ numbers in a list.\n  positives = grep('^-[0-9]*$', l)\n  # Return the list\
    \ of only the positive numbers.\n  return positives\nend", "  return l.grep(/\\\
    d/).map(&:to_i)\nend\n</cell>\n<code language=julia-1.5>", "    l.select {|a|\
    \ a > 0} \nend\n</code>\nExample results:\n<code>\nget_positive([])\n[]\nget_positive([1,2,3])\n\
    [1, 2, 3]\nget_positive([2,3,4])\n[2, 3]\nget_positive([-1,-2,-3,-4,5])\n[-1]\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your help but i need it to be\
    \ an array.\n<|/ c |>\n<| c |>\nThanks, just edited the answer to include a way\
    \ to get it as an array\n<|/ c |>\n<| c |>\nThanks, that worked out and sorted\
    \ the whole array :)\n<|/ c |>\n<| c |>\nYou have a minor typo, should be `map\
    \ {|a| a.positive? ? a.to_i : nil}.compact`\n<|/ c |>\n<| a dscore=2 |>\nUse filter:\n\
    <code>", "    l.select { |x| x > 0} \nend\n</code>\nIt returns the same list as\
    \ you pass it without modifying the input.\n<|/ a |>\n<| a tags=ruby,if-statement,ruby-on-rails,arrays,conditional\
    \ |>\nYou can use Ruby's select to return the list elements with condition satisfied,\
    \ as per below example: \n<code>\n list = [\"abc\",\"cde\",\"def\",\"ghi\"]\n\
    \ list = list.select {|x| x.downcase !~ /a|e|i|o/}\n puts list # => [\"cde\",\
    \ \"ghi\"]\n</code>\nPlease note that above code will work when array elements\
    \ are strings as your input contains strings and downcase method will convert\
    \ all string to lower case letters and remove all characters from list that matches\
    \ the given regex.\nIf you want to do some more complex logic, you can create\
    \ a custom method that will return new list elements based on the given condition\
    \ which you can call on array list as per below:\n<code>\n list = [\"abc\",\"\
    cde\",\"def\",\"ghi\"]", "  l.select{|x| x > 0 }\nend", "    l.select{ |e| e.is_a?\
    \ Fixnum and e > 0 }\nend", "    l.select { |e| e > 0 }\nend", "    l.select {\
    \ |x| x > 0}.compact\nend", "  l.select(&:positive?)\nend\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=3 tags=ruby-on-rails,ruby |>\n<code>", "  l.select { |e| e.positive?\
    \ }\nend", "  l.map { |item| item if item > 0 }\nend\n</code>\nLet's see what\
    \ the above method does before we apply it to our original problem statement:\n\
    <code>", "  l.select { |x| x > 0 }\nend\n</code>\nNow let's write an enumerator\
    \ that prints out all numbers from 2 through 100 that are even:\n<code>", "  l.select\
    \ { |x| x >= 0 }\nend", "  l.select { |i| i > 0 }\nend\n</code>\nAnd then use\
    \ your new method as in our examples:\n<code>\nget_positive([5, -4, 6, 1, -10,\
    \ -2])\n</code>\nor\n<code>\nget_positive([1, 2, -3, -4, -5, -6, -7])\n</code>\n\
    If you know Ruby well and you want to be able to use it in the future in other\
    \ parts of your code base, you could also define it as an instance method of Array:\n\
    <code>", "  l.select { |x| x > 0 }\nend\n</code>\nThe Ruby style guides advise\
    \ against using underscores as prefixes for variables and methods.\n<|/ a |>\n\
    <| c |>\nThanks for your time and effort. Your code really helped me understand\
    \ Ruby a bit more. I will have to do some more reading to understand your code.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nNo problem. Glad I could help!\n<|/ c |>\n\
    <| a |>\nTo avoid the error \"undefined method '+' for nil:NilClass\", use:\n\
    <code>\n[1,2,3] + [4,5,6]\n</code>\ninstead of:\n<code>\n[1,2,3].to_s + [4,5,6].to_s\n\
    </code>\n<|/ a tags=ruby,arrays,methods dscore=2 |>\n<| c |>\nIt works fine but\
    \ is there any way to use `#to_s` method in this case ??\n<|/ c |>\n<| c |>\n\
    Yes, you can use `#to_s`\n<|/ c |>\n<| c |>\n`to_s` works without problem. But\
    \ the problem is to add elements to the `Array` not to add them to a `String`\
    \ object.\n<|/ c |>\n<| a tags=ruby,arrays,methods |>\nThe + operator on arrays\
    \ does a concatenation by concatenating the elements in the arrays, not by adding\
    \ the arrays element-wise.\nThe reason for the error message is that Array#+ is\
    \ implemented as:\n<code>", "  return l.select { |x| x > 0 }\nend", "  l.select\
    \ { |x| x > 0}.flatten\nend\n</code>\nThe return value will be an array.\nYou\
    \ can chain these together in multiple ways.\n<code>", "  positive = []\n  l.each\
    \ do |i|\n    if (i > 0)\n      positive << i\n    end\n  end\n  return positive\n\
    end\n</code>\nNow we can:\n<code>", "  l.select { |x| x > 0 }\nend\n</code>\n\
    This example shows how a method like \"select\" can allow you to filter the objects\
    \ in the list without having to use a loop to loop through each object and test\
    \ each one individually.  If you wanted to write your own version of \"select\"\
    , you could do that and still use a loop to do it, but using a \"select\" method\
    \ would allow you to write something like this:\n<code>\nlist = get_numbers()",
  "  l.select { |e| e > 0 }\nend", "  positive = []\n  l.each do |e|\n    if e > 0\
    \ \n      positive << e\n    end\n  end\n  positive\nend", "    positive=[]\n\
    \    for i in l\n        if i>0\n            positive.push(i)\n        end\n \
    \   end\n    positive\nend\n</cell>\n<code language=julia-1.5>\nget_positive([3,-4,0,5])\n\
    </cell>\n<code language=julia-1.5>", "  positive = []\n  l.each do |element|\n\
    \    if element > 0\n      positive << element\n    end\n  end\n  return positive\n\
    end", "  l.select { |e| e > 0 }\nend", "  return l.select{|i| i > 0}\nend", " \
    \ l.select {|x| x >= 0} \nend", "  return l.select { |x| x >= 0 }\nend", "  l.select\
    \ { |x| x > 0 }\nend\n</code>\nI hope this helps.\n<|/ a tags=ruby,arrays,hash\
    \ |>\n<| a |>\nJust in case you want to get all elements from array for which\
    \ predicate return true\n<code>\narray = [1,2,3,4,5]\np array.select {|x| x >\
    \ 5}", "    l.select { |n| n > 0} \nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n\
    In Ruby, you can use a block, i.e. something like this:\n<code>", "  l.select\
    \ { |n| n >= 0 }\nend\n</code>\nSo let's do some testing:\n<code>\n> a = [-1,\
    \ -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13]\n> get_positive(a)\n=> [-10,\
    \ -11, -12, -13]\n</code>\nThis works, because Ruby will return a copy of the\
    \ array (by calling the #clone method) where the values are filtered.\nWhat if\
    \ we want a completely new array and leave the original untouched?\n<code>\n>\
    \ a.select { |n| n >= 0 }\n=> [-10, -11, -12, -13]\n</code>\nThat's not quite\
    \ what we want.  What we want is to replace the original array with a new array\
    \ where all negative values are removed.\n<code>\n> a = [-1, -2, -3, -4, -5, -6,\
    \ -7, -8, -9, -10, -11, -12, -13]\n> a\n=> [-1, -2, -3, -4, -5, -6, -7, -8, -9,\
    \ -10, -11, -12, -13]\n> a.select { |n| n >= 0 }\n=> [-10, -11, -12, -13]\n</code>\n\
    Ruby's enumerable interface allows us to replace the original array with our filtered\
    \ array.  To do this, we'll want to call the #replace method on the original array.\
    \  For example:\n<code>\n> a = [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11,\
    \ -12, -13]\n> a\n=> [-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13]\n\
    > a.replace a.select { |n| n >= 0 }\n=> [-10, -11, -12, -13]\n</code>\nNote that\
    \ this is actually a very Ruby-esque way of doing the same thing.  Ruby has many\
    \ methods that are very similar to each other.  They tend to produce the same\
    \ result, but they may do different things!  Ruby's Enumerable interface can often\
    \ be used to express some of these operations in a more readable manner with less\
    \ code.  It's a great way to gain more Ruby-esque knowledge about how to solve\
    \ problems.\n<|/ a |>\n<| c |>\nYes, but what if the array is *very* large? That's\
    \ not very efficient to copy the array like that. Also note that `select` will\
    \ operate on arrays of objects, so it must first be converted to an array. Your\
    \ solution works with numbers and strings, but not with objects in general. `select`\
    \ also returns an array and you lose the original array if you don't explicitly\
    \ assign ", "    return l.select { |x| x > 0 }\nend\n</code>\nThis allows us to\
    \ do:\n<code>\nnums = nums.reject { |x| x == 0 }\n</code>\nAnd this way we can\
    \ add more tests to the reject block. For example:\n<code>\nnums = nums.reject\
    \ do |x| x == 0 || x > 100 }\n</code>\nThis would remove all numbers that are\
    \ equal to 0 OR greater than 100.\nFor a more complex example, here's a function\
    \ that removes all even numbers from a list:\n<code>", "    l.each { |v| return\
    \ v if v > 0 }\n    return nil\nend\n</code>\n<|/ a |>\n<| a |>\nYou could do:\n\
    <code>\n def get_positive(l)\n  l.select {|x| x > 0}\n end\n</code>\n<|/ a tags=ruby,arrays\
    \ dscore=4 |>\n<| a |>\nIf you only want to use the standard library, this can\
    \ work too:\n<code>\nl = ['a','b','c']\nl.reject(&:empty?)", "  return l.filter{|x|\
    \ x.is_a? Integer}.collect{|x| x.abs}\nend\n</code>\n<|/ a |>\n<| c |>\nthanks,\
    \ it works. but one thing, instead of adding x to the array, how would i add a\
    \ new element to each element in the array? sorry if this is basic\n<|/ c |>\n\
    <| c |>\nYou don't need to add anything to each element in the array; each element\
    \ in the array already contains the elements returned by `x.abs` as elements of\
    \ a separate array.\n<|/ c |>\n<| a |>\n<code>\na = [1, 2, 3, 4, 5]", "  l.select{|i|\
    \ i.to_i > 0}\nend", "  l.select { |x| x.positive? }\nend", "    l.select { |x|\
    \ x > 0 }\nend\n</code>\nThis code will create a new list with only positive numbers\
    \ from the original list.  If the original list contains any negative numbers,\
    \ they will be discarded.\n<|/ a tags=ruby,ruby-on-rails,filter,arrays dscore=3\
    \ |>\n<| c |>\nOr use `reject`, e.g. `@arr.reject { |x| x < 0 }`\n<|/ c |>\n<|\
    \ c |>\nYes, but that would discard the other elements of the array, so if you\
    \ wanted to keep the other elements, you'd need to `map` the resulting array to\
    \ keep the other elements.\n<|/ c |>\n<| c |>\nyeah, good point. Although it's\
    \ unclear what the OP wants.\n<|/ c |>\n<| c |>\n`@arr.select{|x| x>0 }`.\n<|/\
    \ c |>\n<| c |>\n- If he wants to keep those other elements, he can do `@arr.map{|x|\
    \ x>0 }`.  Of course, that's unclear from the question whether he wants to keep\
    \ all of them or not, but he did say \"filter an array\", which I interpreted\
    \ to mean keeping the elements that are positive only.\n<|/ c |>\n<| a dscore=3\
    \ tags=ruby,ruby-on-rails,filter,arrays |>\nIf you wanted to preserve the original\
    \ array,'s answer is the way to go.  If you don't want a copy, you may want to\
    \ take a look at the select method on the Enumerable module, which will return\
    \ a new array.  Here's an example:\n<code> = [1,2,3,4,5]", "  l.select { |x| x\
    \ > 0 }\nend\n</code>\nTo test your solution:\n<code>\n$ ruby my_program.rb",
  "  l.select {|e| e > 0 }\nend", "    l.select { |n| n < 0 }\nend", "    l.select(&:positive?)\n\
    end", "  l.reject{|x| x < 0}.inject(:+)\nend", "  l.select { |x| x > 0 }\nend",
  "    positive = []\n    l.each do |x|\n        if x > 0\n            positive <<\
    \ x\n        end\n    end\n    return positive\nend", "  return l | [ r for r\
    \ in l if r > 0 ]\nend", "  l.select{|e| e.to_i > 0}.collect{|e| e.to_i}\nend",
  "  l.select { |x| x > 0 }\nend\n</code>\nNote that these three functions are much\
    \ easier to write and more understandable.  I do not really recommend making them\
    \ methods of your class. They are just functions in this case.  I find it easier\
    \ to read and maintain.\nThe second function is the same:\n<code>", "  l.select\
    \ {|x| x > 0}\nend", "  l.select { |e| e > 0 }\nend", "  l.select { |e| e > 0\
    \ }\nend", "  l.reject{ |item| item.to_i >= 0  }\nend", "  l.select { |x| x.positive?\
    \ }\nend", "    l.select { |item| item > 0 }\nend", "  l.select { |x| x > 0 }\n\
    end", "    l.select {|item| item > 0 }\nend\n</code>\n<|/ a dscore=2 tags=ruby,string,arrays,filter\
    \ |>\n<| a |>\nYou don't need regular expressions.\n<code>", "  l.select{|x| x\
    \ > 0}\nend", "  return l.select { |e| e.is_a? Fixnum && e > 0 }\nend\n</code>\n\
    Then, just use these methods to get positive numbers, and return them in an array\
    \ with the method to_a.\n<code>", "  l.select { |x| x >= 0 }\nend", "    l.select\
    \ { |e| e > 0 }\nend", "  return l.select { |x| x > 0 }\nend\n</code>\nNow you\
    \ can call this function with a list of integers or floats, and get a list back\
    \ with a subset of those that are positive.\n<code>\nget_positive([1,2,3,4])\n\
    => [1,2,3]\n</code>\n<|/ a dscore=0 tags=ruby,arrays,ruby-on-rails-3 |>\n<| a\
    \ dscore=0 |>\n<code>\narray.select { |e| e > 0 }\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails-3\
    \ |>\n<| c |>\nIt would be better to explain what it does and why it works.\n\
    <|/ c |>\n<| c |>\nI believe it should be `array.select { |e| e > 0 }` to return\
    \ only positive numbers, while `array.select{ |e| e < 0 }` should return only\
    \ negative numbers. Please correct me if I'm wrong.\n<|/ c |>\n<| a |>\nIf you\
    \ don't really want to use select, you might want to try something like\n<code>\n\
    array.map { |x| return true if x.positive? }\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails-3\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\na = ['a','b','c','d']\n</code>\nTo find\
    \ the sum of numbers greater than 0.\n<code>\na.map { |x| x > 0 }.inject(:+)\n\
    </code>\nTo find the number of items greater than 0.\n<code>\na.map { |x| x >\
    \ 0 }.size\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails-3 |>\n<| c |>\nPlease\
    \ format your answer with markdown syntax and use proper formatting, it's really\
    \ hard to read\n<|/ c |>\n<| c |>\nHow about `a.grep(0).size`\n<|/ c |>\n<| c\
    \ |>\nGreat! That works well. Thanks for your kind suggestion.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\n> array = [1, 2, -3, 0, 1, 3, 4, -4, -3]\n=> [1, 2, -3,\
    \ 0, 1, 3, 4, -4, -3]\n> array.select { |i| i > 0}.compact\n=> [1, 3, 0, 4, -4]\n\
    </code>\n<|/ a tags=ruby,arrays,ruby-on-rails-3 |>\n<| a |>\n<code>\narray.select\
    \ {|x| x > 0 }\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails-3 dscore=0 |>\n\
    <| c |>", "  return l.select {|x| x > 0} \nend", "  return l.select { |num| num\
    \ > 0 }\nend", "  positive = []\n  l.each do |e|\n    if e > 0 \n      positive\
    \ << e\n    end\n  end\n  return positive\nend", "  l.select { |x| x.positive?\
    \ }\nend\n</code>\n<|/ a |>\n<| a tags=ruby,hashmap,arrays dscore=1 |>\n<code>",
  "  positives = []\n  positives.concat l\n  positives.select{|l| l > 0}\nend\n  ",
  "  l.select { |e| e.to_i != 0 }\nend", "  positive = []\n  for i in l\n    if i.positive?\n\
    \      positive << i\n    end\n  end\n  return positive\nend\n</cell>\n<text>\n\
    The first function is the filter to find all the positive numbers in a list, and\
    \ the second function will return only positive numbers in the list.", "    l.each\
    \ do |e|\n        if e > 0 then\n            yield e\n        end\n    end\nend",
  "    l.select { |x| x > 0 }\nend", "  l.select { |x| x > 0 }\nend\n  ", "  l.select\
    \ {|i| i > 0 }\nend", "  l.select { |e| e > 0 }\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a |>\nAnother approach\n<code>", "  l.select { |n| n >= 0 }\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't answer the question. The question asks about multiple\
    \ arguments and your answer only shows how to do it with one argument.\n<|/ c\
    \ |>\n<| c |>\nI did not answer my own question because I think it didn't really\
    \ answer the question but it's good that you took the time to elaborate on it.\n\
    <|/ c |>\n<| c |>\nThank you. I had already accepted my own answer but now I see\
    \ how I can make your answer a little bit clearer.\n<|/ c |>\n<| c |>\nWhat does\
    \ this have to do with the question? I thought I understood it - I thought it\
    \ worked for me because I used it for multiple arguments.\n<|/ c |>\n<| c |>\n\
    : This answer shows a way to write a function taking multiple arguments. What\
    \ you're missing is that these functions *must* be written to do what you want.\
    \ The *solution* you accepted does not do what you want.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  return l.select{|n| n > 0}.collect {|n| n}\nend\n</code>\n<|/\
    \ a dscore=1 tags=ruby,enumerable,hashmap |>\n<| a tags=ruby,enumerable,hashmap\
    \ |>\nRuby's Hash object has a handy method called delete_if that will remove\
    \ all key-value pairs where the value is falsy. Here's an example:\n<code>\nh\
    \ = {}\nh[\"key1\"] = true\nh[\"key2\"] = 0\nh[\"key3\"] = nil", "  return l.select\
    \ { |x| x > 0  }\nend", "  l = l.clone\n  l.reject!{|x| x.is_a?(Fixnum)}\n  l\n\
    end", "  l.select{|x| x > 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nI see what you\
    \ did there, that makes it so much easier to understand!\n<|/ c |>\n<| c |>\n\
    This is very good. Really like the use of #select and #each\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  l.map { |i| return i unless i > 0 }\nend", "  return l.select\
    \ { |v| v.positive? }\nend\n</code>\nNow you can use the get_positive method in\
    \ your original code:\n<code>", "    l = l || []\n    l = l.to_a\n    l.each {|x|\
    \ if x.is_a?(Numeric) then\n        if x >= 0\n            return true\n     \
    \   else\n            return false\n        end\n    }\nend", "  l.map { |x| if\
    \ x > 0 then x else nil end }\nend\n</code>\nNotice how I moved your predicate\
    \ into the map block. This is the standard way to filter out elements of an Array\
    \ based on a condition.\n<|/ a dscore=4 tags=ruby |>\n<| a |>\nThe most concise\
    \ way that I've found of doing this is by using select (which uses the method\
    \ Enumerable#select to return a subset of the collection that satisfies the given\
    \ criteria):\n<code>\n[1,2,3].select {|x| x > 1 }", "  l.select { |x| x > 0 }\n\
    end", "  l.select {|x| x > 0 }\nend\n</code>\nAnd now we can use it!\n<code>\n\
    my_list = [1,2,3,-3,-2,-5,4,5,6,-6,7,6,-7,7,3,-2,5,6,8,9] ", "  # Check if list\
    \ is nil.\n  return l.count { |x| x > 0 } if l.is_a?(Array)\n  # Return only positive\
    \ numbers in the list.\n  return l.select { |x| x > 0 }\nend", "  l.select{ |i|\
    \ i > 0 }\nend\n</code>\nOr you can use the select method with the where method\n\
    <code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
