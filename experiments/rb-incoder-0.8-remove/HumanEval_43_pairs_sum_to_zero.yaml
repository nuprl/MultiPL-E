name: HumanEval_43_pairs_sum_to_zero
language: rb
prompt: "# pairs_sum_to_zero takes a list of integers as an input.\n# it returns True\
  \ if there are two distinct elements in the list that\n# sum to zero, and False\
  \ otherwise.\ndef pairs_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n\
  \    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5,\
  \ 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true,\
  \ candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3,\
  \ 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n\
  \    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"
completions: ["  l.group_by { |a| a.to_i }.values.any? { |b| b.any? { |c| c.to_i ==\
    \ 0 } }\nend", "  l.uniq\n  l.map { |e| [e, l.count(e)] }.\n  reduce(:zip).\n\
    \  map { |x, y| x.first == y.first && x.last == y.last }.\n  any?\nend", "  sum\
    \ = 0\n  for i in l\n    sum += i\n    return false if sum > 0\n  end\n  return\
    \ true\nend", "  l.sort.each_with_index do |e,i|\n    break if e<0\n    if i>0\n\
    \      if l[i-1]+e==0\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend\nputs pairs_sum_to_zero([-5,-3,0,3])", "  l.inject(:+) ==  0\nend",
  "  return l.uniq.count == 1\nend", "  return l.inject(true){|t,(i,j)| t && j==0\
    \ }\nend", "  l.sort!\n  l[0] + 1 == l[1]\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\n`each_cons(2)` doesn't always result in pairs.\n<|/ c |>\n<| c |>\nHmm,\
    \ thanks for pointing that out. Can you give an example of when it doesn't result\
    \ in pairs?\n<|/ c |>\n<| c |>\nExample: `[[0,0], [2,0], [4,0]]` doesn't contain\
    \ any pairs with sum zero.\n<|/ c |>\n<| c |>\nAh, good point. I'll edit the answer.\
    \ I didn't realize that `each_cons(2)` only worked when the length of the array\
    \ was odd.\n<|/ c |>\n<| a dscore=0 |>\nThe \"Pairs whose sum is zero\" can be\
    \ solved with:\n<code>", "    l.sort!\n    return l.inject(true) { |sum, (i, j)|\
    \ sum && i == j && sum == 0 }\nend", "    l.uniq!\n    pairs = l.combinations(2).to_a\n\
    \    return pairs.all? { |a| a.all? { |e| e == 0 } }\nend\n</code>\nThe function\
    \ pairs_sum_to_zero returns true if there are any two elements in the list that\
    \ sum to zero, and false otherwise.\nExamples:\n<code>\narr = [1, 2, 3]\npairs\
    \ = arr.combinations(2).to_a\npairs_sum_to_zero(pairs)", "    l.sort!\n    (0..l.size-1).each\
    \ do |i|\n        (1..i).each do |j|\n            if l[i] + l[j] == 0\n      \
    \          return true\n            end\n        end\n    end\n    return false\n\
    end", "  return l.inject(:+) == l.inject(:-)\nend", "    l.sort\n    i = 0\n \
    \   j = 1\n    while i < l.length\n        if l[i] + l[j] == 0\n            return\
    \ false\n        i += 1 \n        j += 1\n    return true\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis is actually a much faster way of doing it.  For a list with\
    \ n elements this method takes O(n) time.  If you were to use this on a larger\
    \ list like a list of pairs with thousands or millions of elements it would take\
    \ O(n^2) time but this would still be much faster than the O(n^2) solution I wrote\
    \ above.\n<|/ c |>\n<| c |>\nIt's O(n) if the list is sorted. But if it's unsorted,\
    \ it depends on the distribution of the elements and is O(n^2)\n<|/ c |>\n<| c\
    \ |>\nI believe it is O(n) if the elements are in range [1..n], as opposed to\
    \ [1..n^2]\n<|/ c |>\n<| c |>\nThe elements are in the range [1, n], so if you\
    \ consider only those elements, it takes O(n) time. But if you consider all elements\
    \ then the algorithm is O(n^2). Which is what I want to show by saying \"for a\
    \ list with n elements this method takes O(n) time.\"\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nHere is a solution using inject:\n<code>\n[1,2,3,4,5,6,7,8,9].inject { |sum,\
    \ number| sum + number } == 0 # => true\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    A recursive solution:\n<code>", "  l.sort.product(l.reverse).all? {|a,b| (a==0\
    \ and b==0) or (a!=0 and b!=0)}\nend", "  l.sort! # sort the list\n  return false\
    \ if l.inject(true) { |result, value| result += value }\n               # if there\
    \ are no pairs that sum to zero,\n               # then the list contains no pairs.\n\
    \  return true  if l.inject(true) { |result, value| result and value != 0 }\n\
    \               # if there are pairs that sum to zero, then\n               #\
    \ every pair must contain a pair of distinct elements\nend", "    l.sort.uniq!\n\
    \    return l.size < 2\nend", "  l.sort\n  pairs = []\n  i = 0\n  n = l.size\n\
    \  while i < n do\n    j = i + 1\n    while j < n do\n      pairs << [l.[i], l.[j]]\n\
    \      j += 1\n    end\n    i += 1\n  end\n  pairs.each do |pair|\n    if pair[0]\
    \ + pair[1] != 0\n      return false\n    end\n  end\n  return true\nend", " \
    \ pairs = l.map{|n| n}\n  pairs.inject(:+) == 0 ? false : true\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nI assume that if there is a pair that sums to zero\
    \ there will also be a pair that sums to 1 but doesn't have a pair that sums to\
    \ 0.\n<|/ c |>\n<| c |>\n\"pairs that sum to 1 but doesn't have a pair that sums\
    \ to 0.\" This is not correct, because the pair sum to 1 is `[1,3]`, but pairs\
    \ that sum to 1 but don't sum to 0 is `[1,2,3]`\n<|/ c |>\n<| c |>\nThanks for\
    \ the comments. I edited my answer.\n<|/ c |>\n<| a |>\nIf you need to solve this\
    \ with simple arrays and without additional gems, here is a solution:\n<code>",
  "    l.sort\n    l.inject(true){|sum, el| sum && el % 2 == 0 && sum + el == 0}\n\
    end\n</cell>\n<cell>", "  l.each_cons(2) do |a,b|\n    return true if a.inject(&:+)\
    \ == 0 && b.inject(&:+) == 0\n  end\n  return false\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nYou don't need the parentheses, e.g. `each_cons(2).all? { |a, b|\
    \ a.inject(&:+) == 0 && b.inject(&:+) == 0 }`\n<|/ c |>\n<| c |>\nThanks, you\
    \ are right! I didn't realize that `each_cons` returns an enumerator... I wonder\
    \ why it works in this way. Maybe it's because `each_cons` returns a lazy enumerator\
    \ and the block is evaluated lazily?\n<|/ c |>\n<| c |>\n`each_cons` is documented\
    \ as \"yields groups of consecutive members\"; `each_cons(2).all?` is documented\
    \ as \"returns false as soon as the first two items in the enumerator don't meet\
    \ the criteria\". So the block is not evaluated until you attempt to iterate over\
    \ the enumerator.\n<|/ c |>\n<| a dscore=0 tags=arrays,ruby |>\nTo check if every\
    \ pair of the array has values different from zero.\n<code>\narray = [2,3,0,-5,0,7,-8]\n\
    array.each_cons(2) do |arr|\n  arr.each do |i|\n    i.zero?\n  end\nend\n</code>\n\
    <|/ a |>\n<| a tags=arrays,ruby |>\n<code>\nrequire 'set'", "    l.sort\n    (first,\
    \ second) = l.partition { |i| (i + first) % 2 == 0 }\n    (first + second).zero?\n\
    end", "  return l.count { |i| l.count(i) == 2 }\nend\n</code>\nAnd that's it.\n\
    <|/ a tags=arrays,algorithm,ruby,loops dscore=2 |>\n<| a tags=arrays,algorithm,ruby,loops\
    \ |>\nThis is an O(n^2) solution:\n<code>", "    l.sort!\n    return l.inject(true)\
    \ { |i, (a, b)| i && b.zero? }\nend", "  if l.length == 0\n    return false\n\
    \  end", "    l.each_cons(2) do |a,b|\n        if b.first == 0\n            return\
    \ true\n        end\n    end\n    return false\nend", "    # your code here\n\
    \    l.inject(0) do |sum, num|\n        sum + num\n    end\n    l.size == l.uniq.size\n\
    end", "  return l.inject(true) do |sum,i|\n    if i % 2 == 0 && sum\n      false\n\
    \    elsif i % 2 == 1 && sum\n      sum.zero?\n    else\n      sum += i\n    \
    \  sum\n    end\n  end\nend\n</code>\nThe code takes an array of integers and\
    \ creates a new array containing only pairs of elements that sum to zero.\nThe\
    \ code can be run here:\nhttp://rubyfiddle.com/riddles/c6b4c4\n<code>\na = [0,1,2,3,4,5]",
  "  return l.inject(true_slurpy) do |result, element|\n    result && element == 0\
    \ || element == -element\n  end\nend\n</code>\n<code>", "  l.each_cons(2) do |a,b|\n\
    \    return false unless a.sum == 0 and b.sum == 0\n  end\n  true\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't seem to work if you're looking\
    \ for pairs that sum to zero, e.g. `[1,2,0,0].each_cons(2).any?(&:zero?)` returns\
    \ true when the pair is `[1,2]`\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays |>\n\
    <code>\n>> a = [1,2,3,4,5,6,7,8,9]\n=> [1, 2, 3, 4, 5, 6, 7, 8, 9]\n>> a.each_cons(2).select\
    \ { |x, y| x + y == 0 }\n=> [[1, 2], [3, 4], [5, 6], [7, 8], [9]]\n</code>\n<|/\
    \ a |>\n<| c |>\nThis approach is very nice because it can be called multiple\
    \ times with the same array and will work faster since it uses a lazy enumerator\
    \ instead of a regular enumerator and can therefore be used on larger arrays.\
    \ I learned this the hard way while writing a test that failed when using the\
    \ solutions above (array size was large and I had to use #each to loop through).\n\
    <|/ c |>\n<| c |>\n`[1,2,3,4,5,6,7,8,9].each_cons(2).select { |x, y| x + y ==\
    \ 0 }` is much better than the answer by because `each_cons` does not loop through\
    \ the whole array before returning `[[],[]]`.\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays\
    \ |>\nAs of Ruby 2.1, you can use Array#slice_before with a block:\n<code>\n[1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9].slice_before{|x| x.sum == 0}.first", "    l.sort\n \
    \   even = []\n    odd = []\n    return even.empty? and odd.empty?\nend", "  l.sort.inject(true)\
    \ {|sum,x| sum && x + sum < 0} && l.length == l.uniq.size\nend", "    l.sort!\n\
    \    return l.all? {|i| l.count(i) == 2} if l.size > 0\n    false\nend\n</cell>\n\
    <code language=julia-1.0>\npairs = [3,5,4,10,6,7,8,11,0]\npairs_sum_to_zero(pairs)\n\
    </cell>\n<code language=julia-1.0>\npairs = [4,5,6,10,7,8,11,0]\npairs_sum_to_zero(pairs)\n\
    </cell>\n<text>\nProblem 3b", "  l.sort!\n  return true if l[1] == l[2]\n  l[0],\
    \ l[1] = l[1], l[0]\n  false\nend\n</code>\nThis approach is somewhat more robust\
    \ to edge cases, and a little more straightforward to read than any of the  other\
    \ answers, but it has a drawback: it requires a sorting step in the middle, which\
    \ is O(n log n). You can make it slightly faster by sorting the list first, and\
    \ then iterating over the list once.\n<code>", "    # your code goes here\n  \
    \  n = l.count\n    i, j = 0, 0\n    while i < n:\n        while j < n and l[i]\
    \ + l[j] == 0: j += 1\n        if j == n: return True\n        i += 1\n    return\
    \ False", "  pair = nil\n  l.each_index do |i|\n    if i > 0 and l[i] - l[i-1]\
    \ != 0\n      pair = [l[i-1], l[i]]\n      return false if pairs.include?(pair)\n\
    \      pairs << pair\n    end\n  end\n  true\nend\n</code>\n<|/ a tags=arrays,ruby,ruby-on-rails,algorithm\
    \ dscore=1 |>\n<| a tags=arrays,ruby,ruby-on-rails,algorithm |>\nHere's my take\
    \ on this:\n<code>", "    l.sort!\n    return false if l[0] == 0 || l[-1] == 0\n\
    \    cur_sum = 0\n    true = true\n    false = false\n    l.each_with_index do\
    \ |num, i|\n        cur_sum += num\n        true = false if cur_sum - i != 0\n\
    \        false = true if cur_sum - i == 0\n    end\n    true if true and false\
    \ # if all values equal zero, then no pairs exist\nend\n</code>\n<|/ a tags=ruby\
    \ dscore=0 |>\n<| c |>\nI like the use of the variables in the loops and assignments.\
    \  I especially like the use of #each_with_index.\n<|/ c |>\n<| c |>\n`l[i] ==\
    \ 0` can be replaced by `l[i] == 0`. Also, `false || true #=> true`, `true &&\
    \ true #=> true`, `false || false #=> false`, `true && false #=> false`\n<|/ c\
    \ |>\n<| c |>\nAnd `l[i] == 0 || l[i-1] == 0` can be replaced by `l[i] == 0` if\
    \ the OP wants to sum the first two elements only. That is, `l[i] == 0` is equivalent\
    \ to `l[i] + l[i-1] == 0`.\n<|/ c |>\n<| c |>\n, Aha, I didn't know that either\
    \ way.  I added that to my answer.\n<|/ c |>\n<| c |>\nThank you very much for\
    \ all the great answers and comments.\n<|/ c |>\n<| a |>\n<code>", "  l.uniq\n\
    \  l.map { |i| [i, l.count(i).zero?] }.all? do |x, y|\n    x != y && !(x.zero?\
    \ && y.zero?)\n  end\nend", "  l.sort!\n  total=0\n  l.each do |pair|\n    if\
    \ pair[0]+pair[1]==0\n      return true\n    end\n    total += pair[0]\n  end\n\
    \  return false\nend", "    l.sort\n    first, last = l[0], l[-1]\n    return\
    \ (first - last).zero? &&\n          (first - last).odd? &&\n          (last -\
    \ first).even?\nend\n</cell>\n<text>\nNext we write a method to find the two numbers\
    \ that sum to zero.", "  l.sort!\n  l.inject(true) { |acc, x| acc && x.zero? &&\
    \ x.next! == nil && false }\nend", "  l.sort!\n  return l.inject(true, :+) ==\
    \ l.inject(true, :-)\nend", "  l.sort.each_with_index do |v, i|\n    begin\n \
    \     break if v == 0 && i+1==l.length\n      v = v + l[i+1]\n    end \n    return\
    \ false if v == 0\n  end\n  return true\nend", "  l.sort.uniq.inject(true) do\
    \ |sum,el|\n    sum && l.size == l.size - 1 and\n     sum + el == 0 && break(el)\n\
    \  end\nend\n</code>\n<|/ a |>\n<| c |>\nThe `sort` step is actually unnecessary,\
    \ you can do it with one scan over the array, something like `pairs.any? { |pair|\
    \ pair[1] == 0 }`.\n<|/ c |>\n<| c |>\nIndeed you can do it with `any?`, but if\
    \ you want something more concise, you can do `pairs.any? { |pair| pair[1] < 0\
    \ }`.\n<|/ c |>\n<| c |>\nThe `sort` step is actually unnecessary, you can do\
    \ it with one scan over the array, something like `pairs.any? { |pair| pair[1]\
    \ == 0 }`.\n<|/ c |>\n<| c |>\nYes, that's true. I didn't realize that the array\
    \ was already sorted in ascending order.\n<|/ c |>\n<| a tags=ruby,algorithm dscore=0\
    \ |>\nHere's another approach, using a simple scan (which I believe is more efficient\
    \ than enumerating over pairs).\n<code>", "  l.each do |i|\n    l.each do |j|\n\
    \      return false if i != j\n    end\n  end\n  true\nend\n</code>\nThen I wrote\
    \ a method to remove elements from list\n<code>", "  l.sort!\n  return false if\
    \ l[0] == 0\n  return false if l[-1] == 0\n  return false if l[0] != l[-1]\n \
    \ return true if l[1..-1].inject(:+) == 0\nend", "    l.sort!\n    pairs = 0\n\
    \    n = l.size\n    return false if n<3 || n==2 && l[1]+l[2]==0\n    trues =\
    \ l.each_index.with_object({}){|i,h|\n        if h.values.include?(0)\n      \
    \      pairs = pairs + 1\n        end\n    }\n    return pairs == n\nend\n</code>\n\
    A helper function which sums a slice of the list\n<code>", "\tl.sort!\n\tl = l.inject(0){|sum,x|\
    \ sum+x }\n\tl.odd? and l.even? and pairs_sum_to_zero[1..l.first].include?(l.first-1)\n\
    end", "  l.sort!\n  sum = 0\n  i = 0\n  while i < l.length\n    sum = sum + l[i]\n\
    \    if sum < 0\n      return false\n    i += 1\n  end\n  return true\nend\n</cell>\n\
    <code language=julia-1.5>\npairs_sum_to_zero([1,-2,3,-4])\n</cell>\n<code language=julia-1.5>\n\
    pairs_sum_to_zero([-1,3,0,4])\n</cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,-2,-3,0,4,-5,-6,-7,-8])\n\
    </cell>\n<code language=julia-1.5>\npairs_sum_to_zero([1,-2,3,-4,1])\n</cell>\n\
    <code language=julia-1.5>\npairs_sum_to_zero([-1,-3,0,-4])\n</cell>\n<code language=julia-1.5>\n\
    pairs_sum_to_zero([-1,-2,-3,0,4,-5,-6,-7,-8])\n</cell>\n<code language=julia-1.5>\n\
    pairs_sum_to_zero([1,-2,3,-4])\n</cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n\
    </cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,4])\n</cell>\n<code\
    \ language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n</cell>\n<code language=julia-1.5>\n\
    pairs_sum_to_zero([-1,-2,-3,0,4,-5,-6,-7,-8])\n</cell>\n<code language=julia-1.5>\n\
    pairs_sum_to_zero([1,-2,3,-4])\n</cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n\
    </cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n</cell>\n\
    <code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n</cell>\n<code language=julia-1.5>\n\
    pairs_sum_to_zero([-1,3,0,-4])\n</cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n\
    </cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n</cell>\n\
    <code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n</cell>\n<code language=julia-1.5>\n\
    pairs_sum_to_zero([-1,3,0,-4])\n</cell>\n<code language=julia-1.5>\npairs_sum_to_zero([-1,3,0,-4])\n\
    </", "    l.sort!\n    (l, r) = l.partition {|x| (l.last+x) == 0 }\n    (r + l).empty?\n\
    end\n</cell>\n<code language=julia-1.5>", "  l.uniq!\n  l.each do |i|\n    l.each_index\
    \ do |j|\n      return false if (j > i) && (l[j]+l[i] != 0)\n    end\n  end\n\
    \  true\nend\n</code>\n<code>", "  return l.inject(true_statement) do |bool, pair|\n\
    \    sum += pair[0]\n    not bool if sum == 0\n  end\nend\n</code>\nThe last statement\
    \ in that block, sum += pair[0], is a shorthand for the following code\n<code>\n\
    sum = sum + pair[0]\n</code>\nWe can actually rewrite the whole thing as\n<code>",
  "  l.sort\n  return true if l[0]+l[-1] == 0 \n  false\nend\n</code>\n<|/ a |>\n\
    <| a |>\nI wrote a solution that uses recursion and passes in two parameters,\
    \ one for the size of the input list and the second for the length of the longest\
    \ subarray (which was initially the sum of the list size).\nThe function returns\
    \ true if the length of the subarray is equal to the length of the input list.\
    \ If not, it recursively calls itself to check other subarrays.\n<code>", "  l.sort\n\
    \  l.uniq\n  l.inject(:+) == 0 && l.reverse.inject(:+) == 0\nend\n</code>\nSo\
    \ if you have an array as such [0,0,0], it will return false (as pairs sum to\
    \ zero).\nIf you have an array as such [1,1,1,0,0,0], it will also return false\
    \ (as pairs sum to zero).\nIf you have an array as such [1,1,1,1,1], it will return\
    \ true (as pairs sum to zero).\nIf you have an array as such [1,1,1,1,1,1], it\
    \ will also return true (as pairs sum to zero).\n<|/ a |>\n<| a tags=arrays,ruby\
    \ |>\nThis is my solution.\n<code>", "    sum = 0\n    pairs = false\n    for\
    \ e in l\n        sum = sum + e\n        pairs = pairs and (sum == 0)\n    end\n\
    \    return pairs\nend", "  l.sort!\n  return false if l.size < 2\n  cur_sum =\
    \ 0\n  l.each do |x|\n    return false if (cur_sum + x).abs <= cur_sum\n    cur_sum\
    \ += x\n  end\n  true\nend\n</cell>\n<text>\n\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\U0001F40D\
    \U0001F40D\U0001F40D\U0001F40D\U0001F40D", "  l.size.times do\n    k = rand(l.size)\n\
    \    l.delete_at(rand(k))\n    l.delete_at(rand(k))\n    break if l.uniq.size\
    \ == 1\n  end\n  pairs = l.to_a\n  pairs.sort!\n  return true if pairs.zip(pairs).all?\
    \ { |x, y| x == y }\n  false\nend\n</code>\n<|/ a dscore=2 tags=performance,ruby\
    \ |>\n<| a dscore=1 |>\nHere are some approaches which avoid sorting.\n<code>",
  "  l.each do |i|\n    l.each do |j|\n      return true if i != j && i + j == 0\n\
    \    end\n  end\n  return false\nend", "    l.each_cons(2) do |x, pairs|\n   \
    \     pairs.any? do |y| y != x end\n    end\nend", "  return false if l.empty?\n\
    \  pair_sum = l.first\n  l.shift\n  l.each do |x|\n    return false if x == pair_sum\n\
    \    pair_sum += x\n  end\n  return true\nend\n</code>\nNow you can call \n<code>\n\
    pairs_sum_to_zero [5, -3, -5, 6, -10, -5, 0]\n</code>\nand you get \n<code>\n\
    true\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a tags=ruby,algorithm |>\nI have\
    \ been trying to improve the above algorithm to make it more performant\n<code>",
  "  l.sort!\n  i, j = 0, 0\n  while i < l.size - 1\n    if l[i] + l[j] == 0\n   \
    \   i += 1\n      j += 1\n    else\n      if j == 0\n        return false\n  \
    \    elsif l[i] + l[j] > 0\n        j += 1\n      else\n        i += 1\n     \
    \ end\n    end\n  end\n  true\nend\nputs \"#{pairs_sum_to_zero([])} #{pairs_sum_to_zero([1])}\
    \ #{pairs_sum_to_zero([1,1])} #{pairs_sum_to_zero([1,1,1])}\"\nputs \"#{pairs_sum_to_zero([1])}\
    \ #{pairs_sum_to_zero([2,1])} #{pairs_sum_to_zero([2,2])}\"\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=algorithm,ruby dscore=0 |>\nThis one is O(n):\n<code>", "    l.sort!\n\
    \    l.inject(0) {|sum,(_,y)| sum+=y }==0\nend\n</code>\nThe sort sorts the list\
    \ so that if two elements sum to zero you get the desired result. The inject function\
    \ works like the reduce method in that it passes two arguments to the block. In\
    \ my example, the first argument is a variable that holds the sum that is returned\
    \ by the block. The second argument is whatever is passed into the block. Here\
    \ I pass zero as the second argument. \nI hope this helps.\n<|/ a dscore=1 |>\n\
    <| c |>\nWhy do you need `inject` here? `reduce(0) { |sum, (_, y)| sum+=y } ==\
    \ 0.`\n<|/ c |>\n<| c |>\nIt's a good point. I will update my answer. Thanks.\n\
    <|/ c |>\n<| c |>\n`reduce(0) { |sum, (_, y)| sum+=y }` is more efficient than\
    \ `inject(0) { |sum, (_,y)| sum+=y }==0` as `inject` will create a new list every\
    \ time, whereas `reduce` will pass the result to the block the first time.\n<|/\
    \ c |>\n<| c |>\nI wouldn't say `reduce` is more efficient, as it has a higher\
    \ amount of operations. If you look up efficiency of functions, you'll find that\
    \ the difference between `inject` and `reduce` will generally be in the order\
    \ of a few thousand operations. But that is a very small amount of operations\
    \ for `reduce`. `inject` has more operations (I did a little research and found\
    \ out that `inject` has a higher amount of operations as well) but that is probably\
    \ not an issue in this case as `inject` seems to be a lot faster.\n<|/ c |>\n\
    <| c |>\nThe only issue with `inject` is if the list is huge, `inject` will require\
    \ O(n^2) operations. `reduce` will require O(n) operations. If you were to benchmark\
    \ them, `inject` would be faster almost every time.\n<|/ c |>\n<| a |>\nThis solution\
    \ uses only Ruby methods and functions. It is very efficient to process a list\
    \ with thousands of elements. The function returns true if the list is non-empty,\
    \ false if empty. \n<code>", "    l.sort!\n    return l.size == 2 and l.include?(0)\n\
    end\n    ", "    pairs = l.map { |i| [i.first, i.second] }\n    pairs.group_by\
    \ { |a, b| a + b }.any?\nend", "  l.sort!\n  (l.size-1).downto(1) do |i|\n   \
    \ return true if l[i]+l[i+1]==0\n    return false if i==l.size-1\n  end\n  return\
    \ true\nend", "  l.each do |i|\n    l.each do |j|\n      return false if i+j ==\
    \ 0\n    end\n  end\n  return true\nend", "  l.sort!\n  pairs = false\n  (0...l.length-1).each\
    \ do |i|\n    (1...l.length-i).each do |j|\n      pairs = true if l[j] + l[j+1]\
    \ == 0\n    end\n  end\n  pairs\nend", "  l.sort {|a,b| b - a}\n  l.each_cons(2)\
    \ do |x,y|\n    break false if x + y == 0\n  end\n  true\nend\n</code>\nIn Ruby\
    \ 1.9.2 and later, Enumerable#each_cons can be used with the argument block to\
    \ produce an enumerator object that is advanced along a list of pairs:\n<code>",
  "  l.each do |pair|\n    return false if (pair[0] + pair[1]).zero?\n  end\n  true\n\
    end", "    l.sort.each do |item|\n        next if item == 0\n        yield(item)\
    \ if item + 1 == l.last\n    end\n    l.sort.each do |item|\n        yield(item)\
    \ if item + 2 == l.last\n    end\nend", "    pairs = 0\n    for i in l do\n  \
    \      for j in l do\n            if i + j == 0\n            then\n          \
    \      pairs = pairs + 1\n            else\n                return false\n   \
    \         end\n        end\n    end\n    return pairs == 2\nend", "  l.sort.reverse!\n\
    \  l.each_cons(2) do |x, y|\n    return false if x + y == 0\n  end\n  true\nend\n\
    </code>\nAnd to use it\n<code>", "  return l.inject(:+) == l.uniq.size\nend",
  "  l.length\n  return l.uniq { |x| (x ^ 0).to_s == \"\" }.count == l.length - 1\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\"return True if there are two distinct\
    \ elements in the list that sum to zero.\"\n<|/ c |>\n<| a |>\n<code>", "    l.sort!\n\
    \    return l[0]+1 == l[-1]\nend\n</code>\n<|/ a |>\n<| a |>\nThe other answers\
    \ did not work for me or I misunderstood the question.  I was looking for a simple\
    \ code that would find all pairs of integers in an array that sum to zero, that\
    \ would allow me to identify which pairs had zero in them in each array separately.\
    \ \nThe code below worked for me:\n<code>\nx = [2, 7, 1, 8, 0, 4, 3, 0] \nx.sort\n\
    z = 0\nwhile z < x.size \n    if x[z] == x[z-1] \n        puts \"#{x[z]}, #{x[z-1]}\"\
    \ \n    elsif x[z] + x[z-1] == z \n        puts \"#{x[z]}, #{x[z-1]}\"\n    elsif\
    \ x[z] + x[z-1] > z \n        z = z + 1 \n    else \n        z = z + 1 \n    end\n\
    end\n</code>\n<|/ a tags=ruby,algorithm dscore=3 |>\n<| a tags=ruby,algorithm\
    \ |>\nHere's one way to do it using the inject method.\n<code>\narr = Array.new(10){rand(1000)}\n\
    arr.sort!", "    l.map!{|i| i.to_i} if l.is_a? Array\n    l.sort!", "    l.uniq!\n\
    \    l.sort!\n    l.each do |x|\n        l.each do |y|\n            return true\
    \ if x - y == 0\n        end\n    end\n    false\nend", "    return l.inject(:+)\
    \ == l.uniq.length\nend\n</cell>\n<cell>", "  l.sort\n  l.each do |i|\n    j =\
    \ i + 1\n    done = false\n    while j < l.length && l[j] == i\n      j += 1\n\
    \      done = true\n    end\n    return true if done\n    return false if j ==\
    \ l.length\n  end\n  return false\nend", "    l.sort!\n    l.inject([]) { |r,\
    \ a|\n        r << [a, r.last.last]\n        a.each { |e| r.last << e }\n    \
    \    r\n    }.uniq!.empty?\nend", "    l.each do |i|\n        l.each do |j|\n\
    \            return false if (i != j and i + j == 0)\n        end\n    end\n \
    \   return true\nend", "  l.sort\n  return false if l[0] == 0 || l[-1] == 0\n\
    \  (left, right) = ([l.shift, l.take_until(1).last] if l.any? || l.size == 1\n\
    \                   else [l.first, l.last] if l.any?)\n  (left, right).reduce(true)\
    \ do |s, el| s + el == 0 && el == 0 ? false : true\nend", "  l.sort!\n  l.reduce(0){\
    \ |sum, el| (sum == 0) && (el > 0) && (el < l.size - 1) }\nend\n</code>\nAnd that's\
    \ how we can use it on your data:\n<code>", "  l.uniq!\n  l.sort!\n  (0...l.size-1).each\
    \ do |i|\n    (1..l.size-i).each do |j|\n      if l[j] + l[j+1] != 0\n       \
    \ return false\n      end\n    end\n  end\n  return true\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a tags=ruby |>\nHere is a solution using Array methods\n<code>",
  "    l.sort.map {|i| [-l.index(l[i]), i] }.uniq.size == 2\nend", "  l.sort!\n  i\
    \ = 0\n  j = 1\n  while i < l.length && j < l.length\n    return false unless\
    \ l[j] == 0 && l[i] == 0\n    i = i + 1\n    j = j + 1\n  end\n  return i == l.length\n\
    end\n</code>\n<|/ a tags=ruby,algorithm dscore=1 |>\n<| c |>\nThank you, this\
    \ is super helpful.\n<|/ c |>\n<| a dscore=1 |>\nI came up with a solution that\
    \ will work for any array length and any array elements, and doesn't require you\
    \ to sort the array.\nMy code essentially checks for all the possible combinations\
    \ of the two elements in the array, and checks to see if the sum of the two elements\
    \ is zero. Here is a quick run through:\n<code>\n Array: [1, 1, 1]\n Possible\
    \ combinations: \n     0       1\n     0       2\n     0       3\n     1     \
    \  2\n     1       3\n     2       3", "  l.sort.each do |i|\n    l.each_index\
    \ do |j|\n      if i+j > 0 and l[i] + l[j] == 0\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "    l.sort!\n    return false if l[0]\
    \ == 0 \n    pair = true\n    l.shift while l[0] != 0 && pair\n    l.shift while\
    \ l[0] != 0 && pair\n    return pair.nil?\nend", "  l.sort!\n  return false if\
    \ l.size < 3 or l[0] == l[-1]\n  return true if l[0] + l[-1] == 0\n  (l[0] + l[-1])\
    \ == (l[0] + l[-2] + l[-1]) == 0\n  l.each_with_index do |x, i|\n    return true\
    \ if l[i] == 0\n    break\n  end\n  false\nend\n</cell>\n<cell>", "  return l.inject(true)\
    \ { |a, (sum, elem)| a && sum == 0 && elem == 0 }\nend\n</code>\nThe Enumerable#inject\
    \ method, like other Enumerable methods, will iterate over the input collection\
    \ until it yields a return value, at which point that return value is returned.\n\
    In our case, our input is an array of integers (pairs of ints), so we want the\
    \ \"return value\" to indicate whether there are two distinct elements in the\
    \ array that sum to zero. So the return value of inject will be true or false,\
    \ which is what we want our function to return. So, our block of code inside the\
    \ inject, a, will be given the return value of each invocation of the block for\
    \ each element in the array. So, if a is false, the block will never be called\
    \ (since a is false), and so a will return nil, which is what we want our function\
    \ to.\nNow, since we know that if our function returns true, there will be two\
    \ distinct elements in the array that sum to zero, we just need to tell Enumerable#inject\
    \ to stop iterating after the first match, which we do by passing in the optional\
    \ second argument to inject, which is the index of the last element of the array\
    \ that we're currently looking at. So, in our case, when we get to our second\
    \ element of the array, that tells inject to stop iterating. That, in turn, tells\
    \ our function that the return value of our function should be true, and we get\
    \ the expected result.\nIf all you care about is finding out if there are two\
    \ distinct elements that sum to zero that's not a bad approach, though this approach\
    \ can short-circuit by returning false if two elements in the array add up to\
    \ zero (since we know that if that happens, there will be no other elements in\
    \ the array that add up to zero). That can be useful in some situations, such\
    \ as in situations where you want to make sure you only iterate over an array\
    \ once.\n<|/ a |>\n<| c |>\nThank you, this is an amazing answer. I would definitely\
    \ need to practice this some more, but I'm still learning Ruby so I wouldn't be\
    \ able too at this point. I appreciate it.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays,sum\
    \ |>\nMy first answer would have been very different, but I found that there were\
    \ two good answers already.\nHere is a solution that will solve the issue you\
    \ are having, but it will have O(n^2) performance.\n<code>", "  pairs = l.to_a\n\
    \  pairs.each_with_index do |(el1,el2), idx|\n    next if el1 + el2 == 0\n   \
    \ return false if idx == 0\n  end\n  return true\nend\n</code>\nIf you don't care\
    \ to see the return value of pairs_sum_to_zero, you could also use the method\
    \ any?\n<code>", "    l.sort\n    return false\nend\n</code>\nA couple of notes\
    \ on sort: it returns void, so you cannot do l.sort and expect it to modify the\
    \ list, you need to assign a variable to it (I chose l).\nThe second note is I\
    \ used <=> to return a <=> b which means \"a compared to b\", a < b is less than\
    \ zero, a > b is greater than zero, and a == b is equal to zero.\n<|/ a |>\n<|\
    \ c |>\nthank you so much for your answer and your explanation!  It really helped\
    \ me learn about sorting and I learned a lot about Ruby.  I haven't been able\
    \ to try out your solution, but I'll definitely start trying now.\n<|/ c |>\n\
    <| c |>\nI've tried out your solution and it works great!  I learned a lot from\
    \ your solution and your explanation.  Thanks again!\n<|/ c |>\n<| c |>\nGlad\
    \ you found it useful! I updated my answer to use `<=>` which I find is more readable.\
    \ It is a great way to learn about sorting in Ruby.\n<|/ c |>\n<| a dscore=0 |>\n\
    This was a great question, thanks for posting.\nI couldn't find a solution that\
    \ had the lowest complexity O(n log n).\nHowever, I think the solution below can\
    \ achieve that. It uses hashing which allows us to create a hash from the array.\
    \ Then, each value is compared to the previous value in the hash. If the current\
    \ value is greater than the previous one, then it must be greater than 0.\n<code>",
  "  l.sort.map { |x| x == 0 ? true : false\n    \n  }.each_cons(2) do |pair|\n  \
    \  if pair[0].nil? || pair[1].nil?\n      puts \"invalid input\"\n      exit(0)\n\
    \    end\n  end\nend", "  # write your code here\n  \nend", "\tfor i in 1...l.length\n\
    \t\tpair_sum = l[i - 2] + l[i]\n\t\tif pair_sum != 0\n\t\t\treturn false\n\treturn\
    \ true\nend", "  l.sort\n  l.each_cons(2) do |a, b|\n    return true if a + b\
    \ == 0\n  end\n  false\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe `if` statement\
    \ is redundant\n<|/ c |>\n<| c |>\nYou are right, I always forget that. Thanks!\n\
    <|/ c |>\n<| c |>\n`l.sort.each_cons(2).all?(&:zero?)`\n<|/ c |>\n<| a dscore=1\
    \ tags=ruby |>\nThe simplest solution would be to use an algorithm known as the\
    \ Knuth-Morris-Pratt algorithm. It's one of the most famous algorithms in computer\
    \ science. Here's a link to Wikipedia article that describes the algorithm.\n\
    In fact, there is even a gem for Ruby that implements this algorithm:\n<code>\n\
    require 'kmp'", "  l.inject(true) { |x, y| x && y }\nend", "    l.each_cons(2)\
    \ do |x,y|\n        return true if x+y == 0\n    end\n    false\nend\n</code>\n\
    <|/ a tags=ruby,arrays,ruby-on-rails,combinations |>\n<| c |>\nThanks for your\
    \ answer. I think I was a bit unclear in my question but I think I got the idea\
    \ from you and I really appreciate the help.\n<|/ c |>\n<| c |>\nYou're welcome,\
    \ let me know if it works. I got it right at first, then took some time and went\
    \ back and made some edits to make sure I was right. By the way, if you could\
    \ mark the answer as accepted that would be great for both you and me\n<|/ c |>\n\
    <| c |>\nYour method works for an array with odd number of elements. But it fails\
    \ when you have an even number of elements. For example, for `[1,2,3]`, it returns\
    \ `false`.\n<|/ c |>\n<| c |>\nYes, because OP said that he doesn't want to include\
    \ `[0,0,0]`. I'll edit my answer to handle that case\n<|/ c |>\n<| c |>\nI understand\
    \ now. Thanks\n<|/ c |>\n<| a |>\nI guess this method is more efficient. Try this\
    \ out:\n<code>", "    l.uniq!\n    return l.count(2) == 2\nend\n</code>\n<|/ a\
    \ dscore=3 tags=ruby |>\n<| c |>\nI like the idea, but your solution seems to\
    \ not work correctly when the list contains more than 2 elements.\n<|/ c |>\n\
    <| a tags=ruby |>\nHere is my contribution:\n<code>", "    l.sort\n    two_count\
    \ = 0\n    even_count = 0\n    for number in l\n        if number % 2 == 0\n \
    \           even_count += 1\n        else\n            two_count += 1\n    return\
    \ two_count == 0 and even_count == 0\nend", "    # Your code here\n    l.sort!\n\
    \    return false if l.first == l.last or l.last.to_s.split(//).reduce(:+) ==\
    \ 0 \n    true\nend", "  l.sort!\n  l.inject(true) do |acum,item|\n    if acum\
    \ and item == acum + item\n      false\n    elsif acum\n      false\n    else\n\
    \      acum = item\n      true\n    end\n  end\nend\n</code>\n<|/ a dscore=1 tags=arrays,ruby\
    \ |>\n<| c |>\nThanks for your detailed answer! I did some testing on your code\
    \ and I got the same results as the previous answer, but I thought this would\
    \ probably be faster because it avoids an extra `if statement`\n<|/ c |>\n<| a\
    \ tags=arrays,ruby |>\nThe issue is that ruby will try to convert the string into\
    \ an integer and it will fail.\nSo you need to add .to_i to your array and use\
    \ .compact instead of .uniq\n<code>\n> [1,2,'a'].compact # => [1]\n> [1,2,'a'].compact.to_i\
    \ # => ArgumentError (invalid value for Integer(): 'a')\n> [1,2,'a'].compact.map(&:to_i)\
    \ # => [1,2,0]\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI tested the above code and\
    \ it seems to work, but then `[1,2,'a'].compact.map(&:to_i) # => [1,2,nil]` so\
    \ I'm wondering if there is anything else I should do?\n<|/ c |>\n<| c |>\nSorry\
    \ my mistake. Check it again :)\n<|/ c |>\n<| c |>\nThanks for your answer!  I\
    \ tested it again and I still get the same results as in my previous comment.\
    \ I'm wondering if there is anything else I can do to fix this so I don't have\
    \ to add `.to_i` to every item in my array in my code?\n<|/ c |>\n<| c |>\nI believe\
    \ it depends on how your array is populated. As far as I can tell my solution\
    \ will work fine. Try `[1,2,'a'].compact.map(&:to_i) # => [1,2,0]`\n<|/ c |>\n\
    <| c |>\nThanks for your help everyone! I added a comment to the answer with my\
    \ full code. Could you take a look at it and let me know what I'm doing wrong?\
    \ I just posted my question so you could see what I'm asking for help with. Thanks!\n\
    <|/ c |>\n<| a |>\nI tested the following code:\n<code>\narray = [1,2,3,4]\narray.uniq.map{|i|\
    \ i}\n</code>\nand it returns\n<code>\n[1, 2, 3, 4]\n</code>", "  return l.inject(:+)\
    \ == l.uniq.inject(:+)\nend\n</code>\n<|/ a |>\n<| a |>\nYou can use the pairs\
    \ method to achieve this\n<code>", "  l.sort.each_with_index do |e,i|\n    if\
    \ i > 0 and e == l[i-1] + l[i-2]\n      return false\n    end\n    return true\n\
    \  end\n  return true\nend", "  l.sort.uniq.length == 1 # can only have one pair\
    \ if they're all the same\nend\n</code>\nFor a more robust solution that handles\
    \ any number of elements in your array, see this answer.\n<|/ a dscore=3 |>\n\
    <| c |>\nI think this code is wrong. For example, consider `[1, 1, 2]` and `[1,\
    \ 1, 2, 3]`.\n<|/ c |>\n<| c |>\nYes, that's why I suggested a better solution\
    \ [here](http://stackoverflow.com/a/43008334/405017). I'll edit my answer.\n<|/\
    \ c |>\n<| c |>\nThis algorithm only checks for two distinct elements, but there\
    \ can be more. For example, it returns true for `[1, 1, 2, 2, 3]` - two distinct\
    \ elements sum to zero.\n<|/ c |>\n<| c |>\nIndeed. What would the correct return\
    \ value be for that case? Two booleans? Two numbers? Two sets of numbers? Something\
    \ else?\n<|/ c |>\n<| c |>\nThat's a good question. Ideally, the algorithm should\
    \ return two numbers, each representing a pair in the array that sum to zero.\
    \ `[1, 1, 2, 3]` would return `[true, false, true]`. But it's unclear what to\
    \ return in this case. I'd say the implementation should return one boolean for\
    \ each pair.\n<|/ c |>\n<| a dscore=2 |>\nYou can do it using hash tables, specifically\
    \ a hash table that can store values by key and value at the same time.\nThe time\
    \ complexity is O(n), n being the number of elements in the array.  \n<code>",
  "    l.each do |x|\n        l.each do |y|\n            return true if x + y != 0\n\
    \        end\n    end\n    return false\nend", "  l.uniq!\n  l.sort!\n  l.each\
    \ do |i|\n    l.each do |j|\n      puts \"#{i} + #{j} == #{i+j}\"\n      puts\
    \ \"\\t#{i+j} > 0 ? 1 : 0\" if i+j > 0\n      puts \"\\t#{i+j} < 0 ? 1 : 0\" if\
    \ i+j < 0\n    end\n  end\n  puts l.uniq.count? ? \"True\" : \"False\"\nend",
  "  l.length.times.with_object(false) do |i,b|\n    b.tap do |c|\n      next if i\
    \ == 0\n      pair = l[i..-1]\n      next unless pair.length == 1\n      a = pair.first\n\
    \      c.update(a != pair.last)\n    end\n  end\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like this a lot. Not a fan of using enumerators like this, though.\n\
    <|/ c |>\n<| a dscore=2 |>\nYou can do it with a single line as :\n<code>\n[1,2,3,4,5,6,7].select\
    \ { |n| n.odd? } + [1,2,3,4,5,6,7].select { |n| n.even? }", "    l.sort!\n   \
    \ return l.inject(true) do |t, el|\n        t && el + t\n    end\nend", "  l.sort!\n\
    \  l.inject(true) { |sum_of_two_elements, pair_of_elements| sum_of_two_elements\
    \ and (pair_of_elements[0] + pair_of_elements[1] == 0) }\nend", "  l.uniq.each\
    \ { |i| return false if l[i.to_s] == i }\n  return true\nend\n</code>\nAnd finally\
    \ we test the function like this:\n<code>\ntest_array = [-1, 5, -4, -2, 7, -5,\
    \ 6, 0]\nputs pairs_sum_to_zero(test_array)\n</code>\nAnd we get:\n<code>\ntrue\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nYou don't need to convert\
    \ `i` to a string. Also, `l[i]` will raise an error if the index is out of bounds.\n\
    <|/ c |>\n<| c |>\n: Yeah, I was going to change it but forgot it because I'm\
    \ tired, but thanks.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\nThis is my contribution,\
    \ based on code by Rodrigo Mej\xEDa Su\xE1rez A\xF1adir.\nIt returns a list of\
    \ all arrays that add up to the same value or all negative numbers. Example:\n\
    <code>\n[\n  [-10, 20, 0, -1], # => [[], [], [], [], [], [], [], [], []]\n  [4,\
    \ -4, 0, 0], # => [[], [], [], [], [], [], [], [], []]\n  [10, 15, 30, 10], #\
    \ => [[], [], [], [], [], [], [], []]\n  [12, 5, -10, -5], # => [[], [], [], [],\
    \ [], [], [], []]\n  [4, -2, -10, -10], # => [[], [], [], [], [], [], []]\n  [4,\
    \ -2, -10, 0], # => [[], [], [], [], [], [], []]\n]\n</code>\nCode\n<code>", " \
    \ l.sort!\n  sum = 0\n  index = 0\n  while index < l.size\n    sum = sum + l[index]\n\
    \    if sum == 0\n      return true\n    index += 1\n  end\n  return false\nend",
  "  return l.count(l[0]) == l.count(l[-1]) and l.count(l[1]) == 0\nend", "  l.sort.each\
    \ do |i|\n    next if l.index(i).nil?\n    j = i+1\n    until j.succ == l[j]\n\
    \      j = j+1\n      if j == l[j]\n        return true\n      end\n    end\n\
    \  end\n  return false\nend\n</code>\n<|/ a tags=ruby,algorithm,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nI don't believe this is a correct solution, e.g. `[1,2,0]`\
    \ is `[1,2,3]` and `[0,0,0]`\n<|/ c |>\n<| c |>\n, thanks for pointing that out.\
    \  I fixed it by making sure the list is sorted, but I'm curious why it shouldn't\
    \ be correct.\n<|/ c |>\n<| c |>\nLooking at `[1,2,3]` in the first iteration,\
    \ `i+1` = `2`, which does not equal `3`. In the second iteration, `i+1` = `3`,\
    \ which equals `3`, so `j+1` equals `3`, not `4`, which is what it should be.\
    \ The correct solution is `return true if j < l[j]`.\n<|/ c |>\n<| c |>\nThanks\
    \ for the correction.  I just looked at my code and saw that I had that same problem\
    \ earlier.  I was trying to figure out how to fix it and ended up getting stuck.\
    \  It's good to remember that you can check your own code for a little longer\
    \ to make sure I didn't miss anything before posting it.  I appreciate the help.\n\
    <|/ c |>\n<| a |>\n<code>", "  # your code here\n  return false\nend", "  l.uniq!\n\
    \  l.length.times do |i|\n    l.slice!(i..i+1).any? { |j| l[i] + l[j] == 0 }\n\
    \  end\n  l.length == (l.uniq.count - l.count)\nend", "  l.uniq.select do |x|\n\
    \    l.count(x) == 0\n  end.reduce(:+) == 0\nend", '    l.sort!', "    l.sort!\n\
    \    (l.length-2).times do |i|\n        if l[i] == l[i+1] and l[i] != 0\n    \
    \        return true\n        end\n    end\n    false\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThe question is about a specific problem with Ruby, but your answer is\
    \ about the general approach of finding common pairs. I think the question is\
    \ asking how to implement the algorithm, not how to find the pairs.\n<|/ c |>\n\
    <| a tags=ruby,algorithm dscore=0 |>\n<code>", "  l.each_cons(2) do |a,b|\n  \
    \  return false if (a<b)\n  end\n  true\nend", "    pairs = l.each_cons(2).select\
    \ { |a,b| a+b == 0 }\n    return pairs.length == l.length\nend\n</code>\n<|/ a\
    \ dscore=3 |>\n<| c |>\nI should mention that it assumes your input list has at\
    \ least two elements.\n<|/ c |>\n<| c |>\nIt does. That's why it's called `pairs_sum_to_zero`,\
    \ because it checks if there are two distinct elements in the list that sum to\
    \ zero.\n<|/ c |>\n<| c |>\nOh, I see where you're coming from. Never heard of\
    \ that term before. Thanks for the correction.\n<|/ c |>\n<| a tags=ruby |>\n\
    This answer comes very late but I hope it is useful to someone. I used the idea\
    \ of hashmaps as suggested by Mark, however, I added an additional check on whether\
    \ the sum of the hashes matches the length of the array. I think this should cover\
    \ all the possibilities that could be encountered and would provide a more comprehensive\
    \ solution to find the pairs that sum to zero.\n<code>", "  return l.inject(true)\
    \ do |sum,x|\n    sum && ((l[x-1] + l[x+1]) == 0)\n  end\nend\n</code>\nNow we\
    \ can write the method and test the behaviour:\n<code>", "  l.each_index do |i|\n\
    \    l.each do |j|\n      break if j == i\n      return false if l[i] + l[j] ==\
    \ 0\n    end\n  end\n  return true\nend", "  l.each_cons(2) do |x,y|\n    return\
    \ true if x == y\n  end\n  false\nend", "  l.inject(true){|b, (e, s)| b && e +\
    \ s == 0}\nend\n</code>\n<|/ a dscore=0 tags=ruby,algorithm,data-structures,arrays\
    \ |>\n<| c |>\nWhy not use `Array#inject`?\n<|/ c |>\n<| a dscore=0 tags=ruby,algorithm,data-structures,arrays\
    \ |>\n<code>", "    pairs.each { |x| return false if l.count(x) != 2 }\n    return\
    \ true\nend\n</code>\n<|/ a |>\n<| c |>\nI really like this idea.  However it\
    \ takes O(n^2) to run.  This is O(n^2 logn) so if there were a clever way to do\
    \ it in O(n) it would be better.\n<|/ c |>\n<| c |>\nI totally agree about this\
    \ being O(n^2 logn). I think my solution just needs a little tweaking. If you\
    \ are not averse to some refactoring, perhaps you could try this: use some hashing\
    \ to create pairs of elements in the list that sum to zero. You could create an\
    \ array or hash that has elements of pairs that sum to zero and then iterate over\
    \ the list to check if each element in the list exists in that hash. If so, you\
    \ have found a pair and can stop the search. Otherwise, continue with the next\
    \ element in the list.\n<|/ c |>\n<| c |>\nYeah it does need to be O(n).  I didn't\
    \ want to post the full code, but my professor wants us to do it this way.  I\
    \ guess I'll go over his solution with him and see what he thinks.\n<|/ c |>\n\
    <| c |>\nI updated the code to fix a bug in that it was missing a pair of parentheses.\
    \  I also cleaned up the code a little bit by creating an array of all the pairs\
    \ you want to test. Using `Array#count` instead of `Array#each` also removed a\
    \ lot of superfluous code. Hopefully this will be enough for you to finish your\
    \ assignment.\n<|/ c |>\n<| a dscore=2 |>\nA couple of observations:", "  return\
    \ l.count(l[0]) == l.count(l[-1]) == 0\nend", "    l.sort!\n    zeros = 0\n  \
    \  pairs = 0\n    nil = 0\n    l.each_index { |i| pairs += 1 if l[i] + l[i+1]\
    \ == 0 }\n    pairs -= nil\n    return nil == pairs\nend\n</code>\nThen we can\
    \ define a new method which checks if there are any pairs with sum zero, using\
    \ the method above:\n<code>", "  l.each_cons(2) do |a,b|\n    return false unless\
    \ a + b == 0\n  end\n  true\nend\n</code>\nThen I wrote a little helper function\
    \ that will check whether a list contains only zeroes:\n<code>", "  pairs = combinations(l,\
    \ 2)\n  pairs.each do |pair|\n    first = pair[0]\n    second = pair[1]\n    return\
    \ true if first + second == 0\n  end\n  false\nend", "  l.map { |i| i**2 }.reduce(:+)\
    \ == 0 && l.uniq.size < 2\nend", "  return l.inject(:+) == 0 && l.uniq.size ==\
    \ 1\nend\n</code>\nThe function pair? is just as simple as pairs_sum_to_zero.\
    \  So the function pair? takes any input and returns true or false depending on\
    \ whether or not there are two distinct elements in the list that sum to zero.\
    \  Then:\n<code>", "    l.sort!\n    return false if l[0] + l[1] == 0 \n    pairs\
    \ = (0..l.length-1).to_a\n    i = 0\n    while i < pairs.length\n        j = i\
    \ + 1\n        k = pairs[i]\n        sum_to_zero = (j+k).reduce(:+) == 0\n   \
    \     if sum_to_zero\n            return true\n        end\n        while j <\
    \ pairs.length and pairs[j] + pairs[i] == k\n            j += 1\n        end\n\
    \        i = j\n    end\n    return false\nend\n</cell>\n<cell>", "    pairs =\
    \ l.to_a\n    pairs.map! {|x, y| (x - y).abs == 0 }\n    return pairs.size ==\
    \ 0\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(2) do |a, b|\n    return false\
    \ if (a + b) > 1\n  end\n  true\nend", "    l.sort!\n    l.each_with_index do\
    \ |x, i|\n        j = i + 1\n        while j < l.size && l[j] == x\n         \
    \   j += 1\n        end\n        if j - i > 1\n            return false\n    \
    \    end\n    end\n    true\nend\n</code>\nNow for the actual problem. We are\
    \ trying to check how many numbers can be written as the sum of two distinct powers\
    \ of two. \nFor example 22 = 2 * 2 * 2, so there are four ways to write two distinct\
    \ powers of two.\nSo the function takes a list of integers as an input. \nIt returns\
    \ an integer that is the total number of numbers that can be written as the sum\
    \ of two distinct powers of two.\nThe function does not include any duplicate\
    \ numbers.\n<code>", "  l.sort!\n  return false if l[0] == l[l.length-1]\n  return\
    \ true if l[0] == l[l.length-2] + l[l.length-1]\n  l[0] >= l[l.length-2] + l[l.length-1]\n\
    end", "  l.size.times do |i|\n    (j=i).times do |k|\n      break if l[i] + l[j]\
    \ == 0\n    end\n    return false if j == i\n  end\n  true\nend\n</code>\nThis\
    \ gives us the solution:\n<code>\n>> a = [1, 2, 3]\n>> a.reject { |x| pairs_sum_to_zero([x])\
    \ }\n=> [1, 2, 3]\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there's a more efficient way of doing it?\n<|/ c |>\n<| c |>\n\
    If you don't want the pairs list you can just remove `reject`\n<|/ c |>\n<| a\
    \ tags=ruby,arrays |>\nTo get all the pairs, you should be able to use two nested\
    \ loops. \n<code>", '  return false if l.empty?', "    l.sort!\n    pairs = Hash.new(0)\n\
    \    l.each do |i|\n        pairs[i] = true\n    end\n    pairs[l[0]-pairs[l[1]]]\
    \ = false\nend\nputs pairs_sum_to_zero([2,3,3,3,3])", "  l.uniq!\n  l.each_cons(2)\
    \ do |a, b|\n    if a + b != 0\n      a == b\n    end\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThanks Andrew, that was very helpful :)\n<|/ c |>\n<| c |>\n\
    +1 for the nice solution, but what about `[1, 1, 1, 1, 1]`? What should it return?\
    \ `[1, 1, 1, 1, 0]` or `[1, 1, 0, 1, 1]` or `[1, 1, 1, 0, 0]`?\n<|/ c |>\n<| c\
    \ |>\nThanks for pointing that out. I've updated the code accordingly. I didn't\
    \ test it thoroughly (it's been a long while since I wrote a solution that required\
    \ `uniq`), so I apologize for not having tested it myself.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  return l.count(nil) == (l.count(false) + l.count(true))\nend",
  "  return l.length == 0 || l.all? { |i| (l.last+i).zero? }\nend", "  pairs = l.each_with_index.map\
    \ { |(a,b),i| [a,b,i] }\n  pairs.all? { |(a,b,i)| a + b == 0 }\nend\n</code>\n\
    <|/ a dscore=1 tags=ruby,algorithm |>\n<| a |>\nI got same issue and solved it\
    \ by following.\n<code>", "  l.sort!\n  l.inject(0) {|sum, v| sum + v if sum >\
    \ 0 } == 0 \nend", "  return l.count(0) == 2 and l.count(-1) == 0\nend", "  return\
    \ l.inject(true) do |sum,x|\n    x.to_i.times { sum.zero? ? false : sum.update(x\
    \ + x) }\n  end\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like your answer\
    \ :) However, it's `O(n**2)`, since `+` operation is `O(n)` so it runs in `O(n**2)`\
    \ operations. Better would be to define `pairs_sum_to_zero` as `return l.inject(true)\
    \ do |sum,x|` since `+` operation is `O(1)` :)\n<|/ c |>\n<| c |>\n- I added an\
    \ O(1) version as well. Thanks\n<|/ c |>\n<| a |>\nYou can use a hash and a loop\
    \ to solve this problem. As you said, you cannot use set, so you can use this\
    \ to store each combination of digits in one variable and to check if the combination\
    \ exists in your hash:\n<code>", "    sum = 0\n    pairs = false\n    for num\
    \ in l\n        if num + sum == 0 #sum of elements in list with consecutive numbers\n\
    \            pairs = true\n            sum += num\n        end\n    end\n    return\
    \ pairs\nend", "    l.each { |i| l.delete(0) }\n    l.uniq.length == 1 and l.include?(0)\
    \ ? false : true\nend\n</code>\nExample:\n<code>\nl = [1,3,5,7]", "  return false\
    \ unless l.length == 2\n  a = l[0]\n  b = l[1]\n  return false if b == 0\n  return\
    \ true if a + b == 0\n  false\nend", "  l.sort == []\n  return l.inject(:+) ==\
    \ 0 && l.uniq.length == 1\nend", "  return l.inject(true) do |acc, x|\n    return\
    \ acc && x[1] == 0\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,algorithm,loops\
    \ dscore=0 |>\n<code>", "  return l.inject(true){|sum,e| (sum and e==0) and (!sum);sum}\n\
    end", "  l.sort.each_index do |i|\n    return true if l[i+1] - l[i] == 0\n  end\n\
    \  false\nend", "  l.sort.each_with_index { |x,i| return false if x.to_s == 0\
    \ && l[i+1].to_s == 0 && i != l.size-1 }\n  true\nend\n</code>\n<|/ a |>\n<| a\
    \ dscore=2 |>\nHere's a way to do it with Enumerable#all?\n<code>", "  return\
    \ l.inject(true, :+) == l.inject(true, :-)\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks for the answer, but my goal is specifically to avoid this kind\
    \ of solution. I am not looking to learn how to solve the problem at hand, I am\
    \ just trying to figure out why the method I describe in the question is not correct.\n\
    <|/ c |>\n<| c |>\nThanks for your edit. Can you help me understand why this is\
    \ correct? This seems like a very logical solution. I am just not sure where it\
    \ comes from.\n<|/ c |>\n<| c |>\nThe issue is that you don't always know what\
    \ the difference between the two sums is going to be.  You have to test all possible\
    \ pairs against zero.  What happens when you have 3 pairs that sum to zero?  What\
    \ about 4 pairs that sum to zero?  What if there are 5 pairs that sum to zero?\n\
    <|/ c |>\n<| c |>\nYes, I understand that the pairs need to be tested against\
    \ zero. My question was more along the lines of \"Why is the method I implemented\
    \ wrong?\" Why is the method I implemented wrong? This seems like a very logical\
    \ solution.\n<|/ c |>\n<| c |>\nThe method you implemented is wrong.  It will\
    \ give false positives.  If you had three pairs that sum to zero, it wouldn't\
    \ consider them equal, and would return a false positive.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  i = 0\n  j = 1\n  while i <= l\n    j = (j + i) % l\n    i +=\
    \ 1\n    return j == 0 or i == l\n  end\nend", "  l.uniq\n  pairs = l.to_a.reverse.map\
    \ { |e| [e.first, e.last] }\n  pairs.each_cons(2) do |pair|\n    return false\
    \ if pair[0].zero? || pair[1].zero?\n  end\n  true\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "  pairs = []\n  pairs << [l[0], l[1]]\n  pairs << [l[1],\
    \ l[2]]\n  pairs << [l[2], l[0]]\n  return pairs.any? { |pair| pair.inject(:+)\
    \ == 0}\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis fails for `l = [3, -5,\
    \ 0]`, whereas `pairs_sum_to_zero l.sort` returns `true`.\n<|/ c |>\n<| c |>\n\
    The question is asking for two distinct elements in the list that sum to zero,\
    \ and not for any two elements that sum to zero.\n<|/ c |>\n<| c |>\nI see what\
    \ you're saying. Thanks for pointing that out.\n<|/ c |>\n<| a tags=ruby |>\n\
    This is an old question, but I thought I'd share my solution:\n<code>\npairs =\
    \ [-1, 0, -2, 3, -5, 6, 7, -8]", "  l.each_cons(2) do |a, b|\n    return false\
    \ if a.sum != 0 && b.sum != 0\n  end\n  true\nend", "  l.inject(true) { |sum,i|\
    \ sum && sum != i }\nend", "  l.each_cons(2) do |a,b|\n    return false if (a\
    \ + b).zero?\n  end\n  true\nend", '    return l.count(l[0]) == len(l)-len(l.find(l[0]))',
  "    l.length\n    pairs = []\n    l.each do |i|\n      pairs.push([i, l.find_index(i)])\n\
    \    end\n    pairs.each do |x|\n      y = x + 1\n      break if pairs[y].nil?\n\
    \      pairs[y].each do |i|\n        if x.first + i.first == y.first + i.first\n\
    \          return false\n        end\n      end\n    end\n    return true\n  end\n\
    </code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nI like the idea of using a hash\
    \ to find the first instance of duplicate elements. But it won't be accurate if\
    \ there are repeated non-zero values as you noted. I'll add a code solution for\
    \ that case as well.\n<|/ c |>\n<| a tags=ruby |>\nHere's a version using Array#each_index\
    \ and Enumerable#each_cons:\n<code>", "  l.sort.uniq\n  first = l.first\n  pairs\
    \ = []\n  last = 0\n  while last < l.size\n    current = first + last\n    if\
    \ current > 0\n      pairs << [current, -current]\n    last += 1\n  end\n  pairs.any?\
    \ { |e| e.sum != 0 }\nend\n</cell>\n<cell>", "    # write your code here\n   \
    \ return true\nend", "  # Your code here\n  return true\nend\n</code>\n<|/ q tags=ruby,arrays,sorting,algorithm\
    \ |>\n<| c |>\nWhat is your question?\n<|/ c |>\n<| c |>\nCan you explain what\
    \ \"it takes a while to finish\" means?\n<|/ c |>\n<| c |>\nThis looks like a\
    \ homework question, which is fine, but if you do have some specific problem we\
    \ can help you, but we won't do the work for you. Explain what you are trying\
    \ to do, and how you think it should be done. Give us the code you wrote to solve\
    \ the problem, and say how it's not fast enough for your purposes.\n<|/ c |>\n\
    <| c |>\nI agree with you but in real life scenario you are the only user of such\
    \ question which means you are the only one who understands the problem and who\
    \ can make any appropriate suggestions. I hope you agree with me and I will be\
    \ happy to help you.\n<|/ c |>\n<| c |>\nOk, I understand. My goal here was to\
    \ give an idea of how I thought about this problem. I thought about it a bit and\
    \ I think I might have found a solution. I'll add it to my question.\n<|/ c |>\n\
    <| a |>\nI think you need to look at the knapsack problem, and see if a similar\
    \ solution is applicable here: http://www.geeksforgeeks.org/knapsack-problem/\
    \ . \nThe idea here is to consider all the combinations of items in the array\
    \ that sum to zero and count the different values of that combination so you can\
    \ get the item that is the most valuable. \nIf your knapsack algorithm takes a\
    \ long time to finish, then there may be a possibility that it can finish in a\
    \ shorter time with a different algorithm that you may have implemented, but I\
    \ don't think you can have that guarantee with your current algorithm. \nOne problem\
    \ with this approach, as mentioned, is that it can take a long time to run (as\
    \ you mentioned) because you are checking for all possible combinations.\n<|/\
    \ a tags=ruby,arrays,sorting,algorithm dscore=3 |>\n<| c |>\nThanks, I hadn't\
    \ seen the knapsack problem. I think this could work. Thanks for the suggestion.\n\
    <|/ c |>\n<| c |>\nThis solution is very good if you're willing to sacrifice space\
    \ efficiency (by cutting down the search space). If you want something that runs\
    \ in time proportional to the size of the input, you're going to have to look\
    \ for something different.\n<|/ c |>\n<| a |>\nThis is an interesting problem!",
  "  l.each_cons(2) do |a, b|\n    return false if a.sum != b.sum\n  end\n  true\n\
    end\n</code>\nThe only thing that makes pairs_sum_to_zero more elegant than the\
    \ one you proposed is that it returns immediately after finding the first pair\
    \ whose sum does not match. On the other hand, your method would have to search\
    \ the whole list until it found one pair that does not match. If your list is\
    \ large enough, this might become a significant burden.\nOne last remark: the\
    \ above code is very inefficient. For instance, if your list is too large for\
    \ enumerating, it will take up all the memory and time spent searching the list.\
    \ On the other hand, my proposed solution does not have the memory and time issue.\
    \ Thus, I wouldn't use either of these methods. However, if your list is very\
    \ large, it is probably OK to use the above method (or my proposed solution).\n\
    <|/ a dscore=1 |>\n<| c |>\nNice answer! I wouldn't use this solution, though.\
    \ I would use [this one](http://stackoverflow.com/a/3468607/479863) instead. Or\
    \ even better, one that uses [this method](http://stackoverflow.com/a/3468607/479863)\
    \ instead.\n<|/ c |>\n<| a |>\nI wrote a quick ruby program to solve your problem:\n\
    <code>", "  l.each { |i| l.count(i) == 1 && l.count(i) == l[0].count(i) }\nend",
  "  l.uniq.each do |i|\n    l.uniq.each do |j|\n      return false if (i - j) ==\
    \ 0\n    end\n  end\n  true\nend", "    l.sort.with_index{ |x,i| return false\
    \ if (x-i).abs==0 }\n    l.size == 2 and l[0] == l[1]\nend", "  l.uniq\n  l.uniq.each_with_index\
    \ do |n,i|\n    break if i == l.size - 1\n    return false if (n.to_i + l[i+1].to_i).zero?\n\
    \  end\n  true\nend", "    l.sort!\n    return true if l.inject(true) { |a, b|\
    \ a && b && (a + b) == 0 }\n    return false\nend\n</code>\nExample:\n<code>\n\
    puts \"Are they equal?\", pairs_sum_to_zero([4,3,6,7]) == pairs_sum_to_zero([4,3,7,6])\
    \ # Returns true\n</code>\n<|/ a dscore=1 tags=arrays,algorithm,ruby |>\n<| c\
    \ |>\nThanks, this also covers my test case where I needed to use inject like\
    \ you suggested.\n<|/ c |>\n<| a tags=arrays,algorithm,ruby dscore=1 |>\n<code>",
  "    pairs = {}\n    sum = 0\n    \n    # loop through each element in the list\n\
    \    for element in l\n        \n        # if the sum has already been determined\
    \ \n        if sum in pairs\n        \n            # if the element has not already\
    \ been added\n            if element not in pairs[sum]\n            \n       \
    \         # add the element to the list of elements if the sum has not \n    \
    \            # already been determined.\n                pairs[sum].append(element)\n\
    \                \n            # if the element has already been added\n     \
    \       else\n                \n                # if the current element does\
    \ not sum to zero\n                if element != pairs[sum][-1]\n            \n\
    \                    # add the element to the list of elements if the sum has\
    \ not \n                    # already been determined.\n                    pairs[sum].append(element)\n\
    \                    \n            # if the sum is still zero\n            else\n\
    \                \n                # add the element to the list of elements if\
    \ it still sums to zero\n                pairs[sum].append(element)\n        \n\
    \        # if the sum is still zero\n        else\n            \n            #\
    \ add the element to the list of elements if it still sums to zero\n         \
    \   pairs[sum] = [element]\n            \n        # add the sum to the hash\n\
    \        sum += element\n    \n    # return the pairs hash\n    return pairs\n\
    end", "  l.sort.each do |i|\n    return false if l[i..-1].uniq.length == 1\n \
    \   return true if l[i..-1].uniq.length == 0\n  end\n  true\nend", "    l.each_with_index\
    \ { |(e1, i1),| (e2, i2),| i1+i2 == 0 }\nend", "    l.sort!\n    return l.inject(:+)\
    \ == 0 && l.uniq.length == 1\nend\n</code>\nI should note that I'm fairly new\
    \ to Ruby. I know some Python, but I know that there are some parts of the language\
    \ that I don't yet fully understand.\n<|/ q |>\n<| c |>\nWhy aren't you just using\
    \ `Hash#keys` here? It seems like an obvious solution to me, but I'm not sure\
    \ if that would work here.\n<|/ c |>\n<| c |>\nOh thank you. I didn't know that.\
    \ I'll look into that.\n<|/ c |>\n<| c |>\nOkay so I figured out that the problem\
    \ is the return type of my method. I'm guessing it needs to be something other\
    \ than an enumerable object but I don't know enough about Ruby to be sure. I think\
    \ my understanding of Enumerables is very poor.\n<|/ c |>\n<| c |>\nAh, you were\
    \ right about the return type for my method. It has to be a boolean value but\
    \ I don't have enough experience with Ruby to figure out how to use Hash#keys.\n\
    <|/ c |>\n<| a dscore=2 tags=ruby,enumerable |>\nYou can do this:\n<code>", " \
    \ l.uniq!\n  return l.inject(true) { |accum, item| (accum && item == 0 && l.count(item)\
    \ == 1) }\nend", "  # write your code here\n  l.each do |pair|\n    if pair.sum\
    \ != 0\n      return false\n    end\n  end\n  return true\nend", "  l.inject(true)\
    \ do |sum, (elem, pos)|\n    return false if sum\n    sum.update(elem => pos)\n\
    \    true\n  end\nend\n</cell>\n<code language=julia-1.6>\npairs_sum_to_zero([1,\
    \ 2, 5, 7])\n</cell>\n<text>\nPart 2\nWe'll use our function pairs_sum_to_zero\
    \ to solve the second problem of the famous Pset1 problem. Here's the link to\
    \ the problem description:", "    l.sort\n    return pair? nil : (first == last)\n\
    end\n</code>\nWe could also write this as:\n<code>", "  l.each_with_index do |x,i|\n\
    \    i = i+1\n    l = l[i..-1]\n    break if l.empty?\n    (l.reduce(0, :+) ==\
    \ 0) or (l.reduce(&:-, :+) == 0)\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ dscore=0 |>\nHere is a method which checks whether the sum divides evenly into\
    \ the number of elements in the array.\n<code>", "  l.each_with_index do |n,i|\n\
    \    sum = 0\n    l.each_with_index do |m,j|\n      if m == n\n        sum +=\
    \ 1\n      end\n    end\n    return false if sum > 1\n  end\n  true\nend\n</cell>\n\
    <cell>", "  l.sort\n  return l[0] == l[-1] if l.size > 0 else false\nend", " \
    \   sum=0\n    for e in l do\n        sum+=e\n        if sum==0 then return true\
    \ end\n    end\n    return false\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      return false if i != j\n    end\n  end\n  return true\nend\n</code>\nThis\
    \ code returns the following result:\n<code>\npairs_sum_to_zero [[1, 2], [1, 0],\
    \ [0, 1], [1, 2], [0, 2], [2, 1]]\n=> true\n</code>\n<|/ a |>\n<| c |>\nThat will\
    \ require more memory than is needed. The only real requirement is that the two\
    \ pairs of elements be consecutive in the input.\n<|/ c |>\n<| a |>\n<code>",
  "    l.sort!\n    return (l.inject(true) do |sum,(n,i)|\n      sum && ((l.length-(i+1))*(n-sum).zero?)\
    \ ? false : sum\n    end).eql? false\nend", "  sum = 0\n  pairs = []\n  l.each_with_index\
    \ { |el, index|\n    sum = sum + el\n    if (sum == 0)\n      pairs << [index,index]\n\
    \      sum = 0\n    else\n      pairs << [index]\n      sum = 0\n    end\n  }\n\
    \  pairs.all? {|a,b| a + b == 0}\nend\n</code>\n<|/ a dscore=3 |>\n<| a tags=ruby,algorithm\
    \ |>\n<code>", "  l.sort!\n  pairs = l.reject { |i| l.count(i) == 1 }\n  pairs.any?\
    \ { |i| l.count(i) == 1 }\nend", "    l.sort!\n    return l.inject(true) { |memo,(n,s)|\
    \ memo &&\n        s == 0 &&\n        memo[n] + 1 == n }\nend", "    return l.inject(true,\
    \ :+) == l.reduce(:+)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like this,\
    \ because it doesn't use any unwanted methods. But I guess I like Andrew Henry\
    \ Moore's answer as well. Thanks :)\n<|/ c |>\n<| a tags=ruby |>\nA simple solution\
    \ that uses no unwanted methods is to use partition to split up the array in two.\
    \ Within the first partition, the array will contain all the elements that are\
    \ greater than or equal to zero, while within the second partition it will be\
    \ all the elements that are less than or equal to zero.\n<code>\n[1,2,3,0,5].partition\
    \ { |num| num > 0 }", "  pairs.reduce([]) { |a, p| a + [(p[0] + p[1], p[0])] }.reduce(:==).nil?\n\
    end", "  return l.each_cons(2) do |x, y|\n    x <=> y == 0\n  end\nend\n</cell>\n\
    <cell>", "    l.sort\n    return false if l.reduce(:+) == 0\n    pairs = l.each_cons(2).to_a\n\
    \    pairs.select { |a, b| a + b == 0 }.length == 2\nend\n</code>\nIt turns out\
    \ this works as well for large lists (in fact, it'll be faster with large lists),\
    \ but I still think the built-in .select method makes for a nice readable solution.\n\
    <|/ a dscore=2 |>\n<| c |>\nIt doesn't work for me (at least not on Ruby 2.4.2).\
    \ I get: NoMethodError: undefined method `sort' for nil:NilClass. I suspect Ruby\
    \ is complaining that the array is nil. I'm not sure why.\n<|/ c |>\n<| c |>\n\
    : I'm guessing you have `nil` values in your array somewhere. Did you try the\
    \ code exactly as posted?\n<|/ c |>\n<| c |>\n, yes, I tried the code exactly\
    \ as posted. I must have an extra value somewhere. It worked to eliminate the\
    \ nil values. However, I still wonder why Ruby doesn't like my code (it's actually\
    \ more compact than mine, though!)\n<|/ c |>\n<| c |>\n: It works on Ruby 2.4.1,\
    \ but not on Ruby 2.4.2. And I suspect the problem is that the `nil` values get\
    \ filtered out when the `to_a` is called.\n<|/ c |>\n<| c |>\nInteresting. I'd\
    \ love to know why that is. I added a test to my answer that demonstrates how\
    \ `to_a` makes the problem go away.\n<|/ c |>\n<| a dscore=0 |>\nHere's my solution:\n\
    <code>", "    # initialize a flag to keep track if two elements sum to zero\n\
    \    flag = True\n    # iterate over the list and compare elements to zero and\
    \ sum them up\n    for i in l\n        flag = flag and (i != 0)\n    return flag",
  "  l.sort! # this makes sure we are dealing with an ascending sequence\n  return\
    \ l.length < 2 || !l[0] + l[-1]\nend", "  return l.inject(true, :+) == l.inject(true,\
    \ :-)\nend\n</cell>\n<cell>", "  l.sort!\n  pair = 0\n  until pair == l.size\n\
    \    pair = pair + 1\n    if l[pair] == l[(pair + 1)]\n      return false\n  \
    \  end\n  end\n  return true\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1\
    \ tags=ruby |>\nA simple way would be\n<code>", "  l.each_cons(2) do |x, y|\n\
    \    return false unless ((x + y) == 0) || ((x - y) == 0)\n  end\n  true\nend",
  "  l.length.times do |i|\n    l.each_index do |j|\n      if l[j].zero? and l[j +\
    \ 1].zero?\n        return true\n      elsif l[j].zero? and l[j + 1].nonzero?\n\
    \        return false\n      elsif l[j].nonzero? and l[j + 1].zero?\n        return\
    \ false\n      end\n    end\n  end\nend", "  l.sort == l.reverse.sort # sort the\
    \ list before checking pairs\n  l.inject(:+) == l.inject(:-) # return true if\
    \ there is a pair\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThank you,\
    \ this is very helpful!\n<|/ c |>\n<| a dscore=4 tags=ruby,arrays |>\nThe fastest\
    \ solution is using the following code:\n<code>\n(0..a.size-1).any?{ |i| (a[i..-1].inject{\
    \ |sum, el| sum + el}.to_i <= 0) }\n</code>\nThe code works like this:\n<code>\n\
    a.inject{ |sum, el| sum + el }\n</code>\nThe inject method returns the sum of\
    \ all the elements in the array, starting from the first element. Then, we add\
    \ the second element to the sum and so on...\n<code>\n(el1 + el2 + el3... <= 0)\n\
    </code>\nThis means, if sum is less than 0, then the element is not added to the\
    \ sum. If it is greater or equal to 0, then the sum is added to the element being\
    \ added.\n<|/ a |>\n<| c |>\nThanks for your reply.  While I do like your solution,\
    \ it is slower than the ones provided above.\n<|/ c |>\n<| c |>\n: I checked the\
    \ performance of your solution and it worked fine on my end. The fastest solution\
    \ would be to use one of the provided solutions.\n<|/ c |>\n<| c |>\n: Did you\
    \ use the code I posted above? If it didn't, then please provide the code that\
    \ I posted above and let me know how it performs.\n<|/ c |>\n<| c |>\n: My solution\
    \ is much faster than the one provided by Dheepak. The reason is because I am\
    \ calculating the sum of the array using inject method and then checking if that\
    \ sum is equal to zero. The inject method is very fast compared to the sum method\
    \ which would be slower than the sum method. Hence, the performance of the solutions\
    \ is almost same. Hence, I used the sum method to calculate the sum first and\
    \ then compared the sum to zero. The sum method was more optimized. However, I\
    \ used the inject method only to check the sum greater than zero since it is much\
    \ faster.\n<|/ c |>\n<| c |>\n: I updated my solution to your latest code. Hope\
    \ it works for you now\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
