name: HumanEval_114_minSubArraySum
language: rb
prompt: "# Given an array of integers nums, find the minimum sum of any non-empty\
  \ sub-array\n# of nums.\n# Example\ndef minSubArraySum(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minSubArraySum\n\
  \    candidate = method(:minSubArraySum)\n    assert_equal(1, candidate.call([2,\
  \ 3, 4, 1, 2, 4]))\n    assert_equal(-6, candidate.call([-1, -2, -3]))\n    assert_equal(-14,\
  \ candidate.call([-1, -2, -3, 2, -10]))\n    assert_equal(-9999999999999999, candidate.call([-9999999999999999]))\n\
  \    assert_equal(0, candidate.call([0, 10, 20, 1000000]))\n    assert_equal(-6,\
  \ candidate.call([-1, -2, -3, 10, -5]))\n    assert_equal(-6, candidate.call([100,\
  \ -1, -2, -3, 10, -5]))\n    assert_equal(3, candidate.call([10, 11, 13, 8, 3, 4]))\n\
  \    assert_equal(-33, candidate.call([100, -33, 32, -1, 0, -2]))\n    assert_equal(-10,\
  \ candidate.call([-10]))\n    assert_equal(7, candidate.call([7]))\n    assert_equal(-1,\
  \ candidate.call([1, -1]))\n  end\nend\n"
completions: ["    # Write your code here.\n    nums.sort!\n    sum = 0\n    i = 0\n\
    \    count = 0\n    while i < nums.length\n        sum += nums[i]\n        i +=\
    \ 1\n        count += 1\n    end\n    return sum if count > 0\nend", end, "  \
    \  return 0\nend", "  (0...nums.size).inject(0, :+).to_a.reduce(:+)\nend\n</cell>\n\
    <code language=julia-1.0>\nminSubArraySum([-1, 0, 1])\n</cell>\n<text>\n6.2 The\
    \ maximum of all numbers in a list\nFor an array such as [5, -2, -3, 7], we would\
    \ expect the maximum out of all numbers to be 7. Write a function that takes a\
    \ list of integers and returns the maximum of that list.", "  sum = 0\n  sum,\
    \ j = 0, nums.size\n  while sum < nums[0]\n    sum += nums[j]\n    j -= 1\n  \n\
    \  return sum if j == 0 else j\nend", "  nums.sort!\n  nums.length.times do |i|\n\
    \    min = nums[i]\n    nums.shift\n    while nums.length > 0 do\n      sum +=\
    \ nums[0]\n      nums.shift\n    end\n    min.succ! if sum < min\n  end\n  return\
    \ min if min > 0\n  return 0\nend", "  # Write your code here.\n  nums.each do\
    \ |num|\n    min = num\n    break num if nums.include?(num - min)\n    min = num\
    \ - min\n  end\nend", "  result = nums.inject(:+)\n  i = nums.size\n  while i\
    \ >= 1\n    result -= nums[i - 1]\n    i -= 1\n  end\n  result\nend\n</cell>\n\
    <cell>\nminSubArraySum([-10, -3, -5, -15, 0, 2, 5, 10])\n</cell>\n<cell>", " \
    \   sorted = nums.sort\n    minimum = sorted[0]\n    sum = 0\n    i = 0\n    \n\
    \    while i < nums.length\n        if i < nums.length - 1\n            sum =\
    \ sum + sorted[i + 1] - sorted[i]\n        end", "  minSum = 0\n  minSum = nums[0]\n\
    \  for i in 1..nums.length\n    minSum = minSum + nums[i]\n    if minSum < nums.length\n\
    \      minSum = nums[i]\n    end\n  end\n  minSum\nend\n</pre>\n</div>\n</div>\n\
    </div>\n</div>\n</div>\n<div class=\"cell border-box-sizing text_cell rendered\"\
    ><div class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"\
    text_cell_render border-box-sizing rendered_html\">\n<h3 id=\"Problem-7\">Problem\
    \ 7<a class=\"anchor-link\" href=\"#Problem-7\">&#182;</a></h3><p>For each of\
    \ these number pairs, count the number pairs where one number is greater than\
    \ the other but not both.</p>\n<p>Example\nnums = [1,3,5,2,3,4]\npairs = [[1,3],[2,5],[3,4]]\n\
    count = [2,2,3]\n</p>", "  minimum = nums.reduce(:+)\n  (nums[1..-1] + nums).each{\
    \ |i| minimum = minimum - i if minimum > i }\n  minimum\nend\n</cell>\n<cell>\n\
    nums = [1, 3, -1, -3, 4, 1, -5, -4, -5, 1]\nminSubArraySum(nums)\n</cell>\n<text>\n\
    Array#sum\nArray#sum is equivalent to calling reduce, passing in the symbol #{|+|}\
    \ as its block argument.", "  \nend\n</cell>\n<text>\nQuestion 8 (6.4s)\nGiven\
    \ a 2D matrix matrix, and an integer n where n is less than or equal to 9. Assume\
    \ matrix is a square matrix. Write a function that returns True if and only if\
    \ a square matrix with sides n and n contains only integers from 1 to 9. For example,\
    \ given matrix is [[1,2,3],[4,5,6]], and n = 2, your function should return True\
    \ since a square matrix with sides 2 and 2 contains only integers from 1 to 9.\
    \ Otherwise, your function should return False.", '  nums.sort!', "  nums.sort!\n\
    \  minSum = nums[0]\n  sum = 1\n  for i in 1..nums.length\n    sum+=nums[i]\n\
    \    if sum<minSum\n      minSum = sum\n    end\n  end\n  return minSum\nend",
  end, "  minSum = nums.first\n  nums.each_index { |index| minSum = minSum + nums[index]\
    \ }\n  minSum\nend", "    # Write your code here.\n    nums.each do |i|\n    \
    \    num = num.shift\n        if num == 0 || num == 0\n            sum = num\n\
    \        else\n            sum += num\n        end\n    end\n    return sum\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>\n\
    nums = [1, 2, 3]\nsum = nums.inject(0) { |sum, num| sum + num }\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThanks, I didn't realize that inject existed in ruby\
    \ 1.9.\n<|/ c |>\n<| c |>\nI love this solution, however it misses out the case\
    \ that the list is nil. I'm sure there is a way to handle that case but I just\
    \ couldn't figure it out without using inject. Still a good solution!\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>\nnums = [1, 2, 3]\nsum = nums.inject(0) do |sum, num|\n\
    \  sum + num\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n\
    <| c |>\nHah! Good answer. As much as I love Ruby, I really hate that syntax and\
    \ lack of elegance :)\n<|/ c |>\n<| a dscore=2 tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>\nnums = [1, 2, 3]\nnums.inject{|sum, num| sum + num}\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\nHere's another option,\
    \ which is a combination of everyone's answers:\n<code>\nnums = [1, 2, 3]\nsum\
    \ = nums.inject(0) {|sum,num| sum + num} if nums.any?\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI added a case for nil arrays to your answer, I appreciate the\
    \ help!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  # write your code here\n  return\
    \ 0\nend", "  nums.each { |n| return n }\n  return 0\nend", "    total = 0\n \
    \   array.each do |n|\n        total += n\n    end\n    total\nend\n</pre>", " \
    \   nums.inject(0) { |memo, num| memo + num }\nend", "  # Your code here\nend",
  "    min, sum = nums.minmax\n    min, sum\nend", "    sorted = nums.sort!\n    total\
    \ = 0\n    i = 0\n    while i < sorted.length\n        total += sorted[i]\n  \
    \      i += 1\n    end\n    while i < sorted.length\n        total -= sorted[i]\n\
    \        i += 1\n    end\n    return total\nend\n</code>\n<|/ a tags=ruby,arrays,performance\
    \ |>\n<| c |>\n`-` doesn't work if you use negative values as you do. Your code\
    \ would return `0` for `[-3, -7, -1]`\n<|/ c |>\n<| c |>\nAhh I didn't realize\
    \ that negative values wouldn't work in this case. Good catch.\n<|/ c |>\n<| a\
    \ dscore=1 tags=ruby,arrays,performance |>\nHere is something you can do:\n<code>",
  "  nums.sort {|a,b| a <=> b}\n  nums.each {|x| return x-nums.min}\nend", "  nums.sort.min\n\
    end", "  return 0\nend", "  return nil if nums.empty? || nums.any?(&:zero?)\n\
    \  min, idx = nums.min, 0\n  until nums[idx].zero?\n    sum = nums[idx] + nums[idx\
    \ ^ 1].abs + nums[idx ^ 2].abs\n    return sum if sum < min\n    min = sum\n \
    \   idx ^= 2\n  end\n  min\nend", "  nums.sort!\n  curr_sum = nums.first\n  min_sum\
    \ = curr_sum\n  max_sum = curr_sum\n  max_ending_here = 0\n  min_ending_here =\
    \ 0", "    min = Integer.MAX_VALUE\n    i = 0\n    j = 0\n    while(i < nums.length\
    \ && j < nums.length)\n        if(nums[i] < 0)\n            i += 1\n        else\n\
    \            min = Math.min(min, nums[i] + nums[j])\n        i += 1\n        j\
    \ += 1\n    end", "\tarray.sort {|a, b| b <=> a}\n\tarray.empty? ? 0 : (array.max\
    \ - array[0] + array.min + array[-1]) / 2 + array[0]\nend\n\t\t</pre>\n\t</div>",
  "  # Your code here\n  return\nend\n</cell>\n<cell>", "  min, min, max = nums[0],\
    \ nums[0], nums[0]\n  nums.each do |i|\n    min = i\n    nums.each do |j|\n  \
    \    sum = j + min\n      max = sum if sum > max\n    end\n  end\n  min\nend",
  "  return 0 if nums.length == 0\n  min = nums[0]\n  max = nums[0]\n  nums.each do\
    \ |x|\n    if x > max\n      max = x\n    elsif x < min\n      min = x\n    else\n\
    \      max = max if x > max\n      min = min if x < min\n    end\n  end\n  return\
    \ min\nend", "  # Write your code here.\nend\n</cell>\n<code language=julia-0.6>\n\
    minSubArraySum([1, 2, 3])\n</cell>\n<code language=julia-0.6>\nminSubArraySum([1,\
    \ 2, 2, 2])\n</cell>\n<code language=julia-0.6>\nminSubArraySum([1, 2, 3, 2, 1])\n\
    </cell>\n<code language=julia-0.6>\nminSubArraySum([3, 1, 4, 1, 5, 9, 6])\n</cell>\n\
    <code language=julia-0.6>\nminSubArraySum([4, 6, -2, -3, 1, 2, -1, -4])\n</cell>\n\
    <code language=julia-0.6>\nminSubArraySum([-1, -2, -3, -4, -5, -6, -7, -8])\n\
    </cell>\n<code language=julia-0.6>\nminSubArraySum([7, -7, -7, 7, -7, 7, -7, -7,\
    \ 7])\n</cell>\n<text>\nProblem 3\nThe sum of the primes below 10 is 2 + 3 + 5\
    \ + 7 = 17.\nFind the sum of all the primes below two million.", "  minimum =\
    \ -nums.min\n  minimum = minimum.abs if minimum > 0 else minimum\n  minimum.times\
    \ do |i|\n    minimum -= nums[i]\n    minimum -= nums[nums.size-i-1] if nums[i]\
    \ > 0\n  end\n  minimum\nend", "    sumOfAnArray = Array.new\n    sumOfAnArray.push(0)\n\
    \    sumOfAnArray[0] = 0\n    sumOfAnArray.length = 0\n    nums.each do |num|\n\
    \        sumOfAnArray[sumOfAnArray.length-1] += num\n        sumOfAnArray.length\
    \ += 1\n    end\n    min = sumOfAnArray[sumOfAnArray.length-1]\n    min.downto(0,-1)\
    \ do |i|\n        if sumOfAnArray[i] - sumOfAnArray[i+1] < min\n            min\
    \ = sumOfAnArray[i] - sumOfAnArray[i+1]\n        end\n    end\n    return min\n\
    end", "  # TODO: Write your code here.\n  return nil\nend", "  nums.inject(0)\
    \ { |sum, x| sum + x }\nend\n</cell>\n<cell>", "    nums.to_a.min_by { |i| i }\n\
    end", "  min_sum, min_index = (0, -1)\n  max_sum, max_index = (0, -1)\n  nums.each_with_index\
    \ { |val, idx|\n    min_sum = val if val < min_sum\n    min_sum = val if val >\
    \ max_sum\n    max_sum = val if val > max_sum\n    max_sum = val if val < max_sum\n\
    \    min_sum = val if val > min_sum\n    min_sum = val if val < min_sum\n  }\n\
    \  return min_sum\nend\n</cell>\n<code language=julia-1.0>\nminSubArraySum([-2,\
    \ 1, 3, 5])\n</cell>\n<text>\n4.5 Inversion Count\nLet us now look at Inversion\
    \ Count for Two Arrays: $x_1, x_2$ where $x_1$ has non-zero elements and $x_2$\
    \ has zero elements. \nThe definition of the Inversion count is as follows:",
  "    i, j, k = 0, 0, 0\n    min, sum = -10000, 0\n    while i < len(nums) and j\
    \ < len(nums):\n        if nums[i] > nums[j]:\n            sum += nums[i] - nums[j]\n\
    \            i += 1\n            j += 1\n        else:\n            sum += nums[j]\
    \ - nums[i]\n            j += 1\n        min = min if sum < min else sum\n   \
    \     k = j if sum == min else k\n    sum = sum if sum < min else min\n    return\
    \ sum", "  # Return the minimum sum of a non-empty sub-array of nums.\n  nums.inject([0,-1]){|s,v|\
    \ s + v}\nend", "    nums.each { |x| return nil if x.zero? }\n    smallest = nums[0]\n\
    \    (0...nums.size).each { |i|\n        if nums[i] < smallest\n            smallest\
    \ = nums[i]\n        end\n    }\n    smallest\nend", "  \nend", "  sums = nums.min_by\
    \ { |x| x.to_i }\n  sums[:index].to_i\nend", "  nums.each_with_index { |n, i|\
    \ nums[i] = [n, i]}\n  nums.sort { |a,b| a[0] <=> b[0] }\n  nums.select { |n,i|\
    \ n != 0 }.inject { |s, i| s + nums[i].last }\nend", "  nums.sort { |a, b| a <=>\
    \ b }\n  nums.min_by { |i| nums.sum - i }\nend", "  nums.each_with_index do |num,i|\n\
    \    sum = num\n    min = num\n    i.times do\n      sum = sum + nums[i+1]\n \
    \     min = nums[i] if sum < min\n    end\n    min\n  end\nend", "  # your code\
    \ goes here\nend\n</cell>\n<code language=julia-1.0>\n@code_warntype minSubArraySum(@[1,\
    \ 2, 3, 2])\n</cell>\n<code language=julia-1.0>\n@code_warntype minSubArraySum(@[Int8(1),\
    \ Int8(2), Int8(3), Int8(4)])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@[1, 2, 3])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@[Int8(1), Int8(2), Int8(3)])\n</cell>\n<code language=julia-1.0>\n\
    @code_warntype minSubArraySum(@[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Int8[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Set{Int8})\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Vector{Int8})\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Dict{Int8, Int8})\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Array{Int8, 1})\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Vector{Int8}[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Set{Int8}[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Dict{Int8, Int8}[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Array{Int8, 1}[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Vector{Int8}[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Set{Int8}[])\n</cell>\n<code language=julia-1.0>\n@code_warntype\
    \ minSubArraySum(@Dict{Int8, Int8}[])\n</cell>\n<text>\nSolution\nLet's implement\
    \ this with some basic Julia code.", "    # write your code here\n    return 0\n\
    end", "  sum = 0\n  nums.each do |num|\n    sum += num\n  end", "end\n</code>\n\
    <|/ a tags=dynamic-programming,optimization,algorithm,ruby dscore=0 |>\n<| a dscore=0\
    \ tags=dynamic-programming,optimization,algorithm,ruby |>\nI have been struggling\
    \ with this for a while. I ended up doing the following:\n<code>", "    n = nums.size\n\
    \    min = Integer.MAX_VALUE # initialize\n    sum = 0", "  nums.sort\n  nums.shift\
    \ # discard any empty sub array\n  minimum = nums[0]\n  for i in 0...nums.length\n\
    \    if minimum > nums[i]\n      minimum = nums[i]\n    end\n  end\n  minimum\n\
    end", "    sorted = nums.sort\n    start = sorted.first\n    end = sorted.last",
  end, "  nums.inject{|sum, e| sum+e}\nend", end, "\tmin = nums[0]\n\tminSum = nums[0]\n\
    \tfor i in nums[1..-1]\n\t\tif i < min\n\t\t\tmin = i\n\t\t\tminSum = nums[1..-1].min\n\
    \t\telse\n\t\t\tminSum = minSum + i\n\treturn minSum\nend\n'''", "\tmin = Float::MAX\n\
    \tfor i in 0...nums.length\n\t\tsub_sum = nums[i]\n\t\tsub_array = nums[0...i]\n\
    \t\tsub_array.each do |n|\n\t\t\tsub_sum += n\n\t\t\tmin = sub_sum if sub_sum\
    \ < min\n\t\tend\n\tend\n\tmin\nend", "    sum=0\n    sum1=0\n    sum2=nums[0]\n\
    \    for n in nums\n        if n>0\n            sum+=n\n            sum1+=n\n\
    \            sum2+=n\n            sum1+=n\n    return sum if sum<=sum2 else sum1\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe question was about using multiple\
    \ variables in a single loop, so this is just wrong.  It could be made to work\
    \ by creating a variable with the previous sum, but that would be inefficient.\n\
    <|/ c |>\n<| c |>\nThe question was about using multiple variables in a single\
    \ loop, so this is just wrong. It could be made to work by creating a variable\
    \ with the previous sum, but that would be inefficient.\n<|/ c |>\n<| c |>\nYeap,\
    \ i know this code. but i want to know how it works.\n<|/ c |>\n<| c |>\nYou were\
    \ asking about multiple variables. So I was giving you a way to do it using multiple\
    \ variables. I said it was inefficient because you always have to recalculate\
    \ variables multiple times when you don't need to. It was a way of showing you\
    \ how it could be done. It isn't the best way to do it\n<|/ c |>\n<| c |>\nSorry\
    \ if you insist, but the OP asked specifically about using multiple variables\
    \ in a single loop, so this is just an example of how it could be done.  It does\
    \ not say anything about efficiency or efficiency not being an issue.\n<|/ c |>\n\
    <| a |>\nHere is the solution to your problem using only one variable\n<code>",
  "  # Your code here\n  nums.min", "    nums.each {\n        num ->\n           \
    \ minSum = num;\n            nums.each {\n                sumOfOtherNums = num\
    \ - sumOfOtherNums;\n                minSum = Math.min(sumOfOtherNums, minSum)\n\
    \            }\n    }\n    \n    minSum\nend\n</cell>\n<code language=julia-1.5>",
  "    sum = 0\n    min = nums[0]\n    max = nums[0]\n    sum = 0\n    until nums.empty?\
    \ do\n        min = nums[0]\n        max = nums[0]\n        until nums.empty?\
    \ do\n            min = nums.shift\n            max = nums.shift\n           \
    \ sum += min\n        end\n        sum += max\n    end\n    return sum\nend",
  "  # Your code here\n  sum = nums.min_by(&:to_i).last\n  sum == 0 ? 0 : sum - nums.min_by(&:to_i).last\n\
    end", "  min_sum = nums.min\n  min_sub_array = []\n  for i in nums\n    sub_sum\
    \ = 0\n    for j in nums\n      if j < i\n        sub_sum += i\n        break\n\
    \      else\n        sub_sum += j\n      end\n    end\n    min_sub_array << sub_sum\n\
    \    min_sum += sub_sum\n  end\n  min_sub_array.min\nend", '  # write your code',
  "  # code here\n  return minimum\nend", "  nums = nums.sort\n  min = nums.reduce(:+).to_f\n\
    \  (0 .. (nums.length - 1)).each do |i|\n    next if nums[i] > nums[i - 1]\n \
    \   sum = 0\n    (i .. (nums.length - 1)).each do |j|\n      sum += nums[j]\n\
    \      break if sum >= min\n    end\n    min = sum\n  end\n  min\nend\n</cell>\n\
    <cell>\nnums = [2, 7, 11, 15]\nnums = nums.sort\nmin = nums.reduce(:+).to_f\n\
    (0...nums.length).each do |i|\n  next if nums[i] > nums[i - 1]\n  sum = 0\n  (i\
    \ .. nums.length).each do |j|\n    sum += nums[j]\n    break if sum >= min\n \
    \ end\n  min = sum\nend\nmin\n</cell>\n<cell>", " \n\treturn 0\nend\n</cell>\n\
    <code language=julia-0.5>\nnums = [-1,2,-3,-4]\n</cell>\n<code language=julia-0.5>\n\
    minSubArraySum(nums)\n</cell>\n<code language=julia-0.5>\nfunction minSubArraySum(nums)\n\
    \t\n\tsum = 0\n\t\n\tfor num in nums\n\t\tsum += num\n\tend\n\t\n\treturn sum\n\
    end\n</cell>\n<code language=julia-0.5>\nminSubArraySum(nums)\n</cell>\n<code\
    \ language=julia-0.5>\nfunction minSubArraySum(nums)\n\t\n\tsum = 0\n\t\n\tfor\
    \ num in nums\n\t\tsum += num\n\tend\n\t\n\tsum\nend\n</cell>\n<code language=julia-0.5>\n\
    minSubArraySum(nums)\n</cell>\n<code language=julia-0.5>\nfunction minSubArraySum(nums)\n\
    \t\n\tsum = 0\n\t\n\tfor num in nums\n\t\tsum += num\n\tend\n\t\n\tsum\nend\n\
    </cell>\n<code language=julia-0.5>\nminSubArraySum(nums)\n</cell>\n<code language=julia-0.5>\n\
    function minSubArraySum(nums)\n\t\n\tsum = 0\n\t\n\tfor num in nums\n\t\tsum +=\
    \ num\n\tend\n\t\n\tsum\nend\n</cell>\n<code language=julia-0.5>\nminSubArraySum(nums)\n\
    </cell>\n<code language=julia-0.5>\nfunction minSubArraySum(nums)\n\t\n\tsum =\
    \ 0\n\t\n\tfor num in nums\n\t\tsum += num\n\tend\n\t\n\tsum\nend\n</cell>\n<code\
    \ language=julia-0.5>\nminSubArraySum(nums)\n</cell>\n<code language=julia-0.5>\n\
    function minSubArraySum(nums)\n\t\n\tsum = 0\n\t\n\tfor num in nums\n\t\tsum +=\
    \ num\n\tend\n\t\n\tsum\nend\n</cell>\n<code language=julia-0.5>\nminSubArraySum(nums)\n\
    </cell>\n<code language=julia-0.5>\nfunction minSubArraySum(nums)\n\t\n\tsum =\
    \ 0\n\t\n\tfor num in nums\n\t\tsum += num\n\tend\n\t\n\tsum\nend\n</cell>\n<code\
    \ language=julia-0.5>\nminSubArraySum(nums)\n</cell>\n<code language=julia-0.5>\n\
    function minSubArraySum(nums)\n\t\n\tsum = 0\n\t\n\tfor num", "end\n</pre>\n</div>\n\
    </div>\n</div>\n<div class=\"cell border-box-sizing text_cell rendered\"><div\
    \ class=\"prompt input_prompt\">\n</div><div class=\"inner_cell\">\n<div class=\"\
    text_cell_render border-box-sizing rendered_html\">\n<p><strong>Time Complexity</strong>:\
    \ O(n)</p>", "    nums.sort.each{|i| return i if i > 0 }\n    nums.min\nend",
  "  # your code goes here\n  return 0\nend", "    nums.each do |num|\n        array.delete_if(|n|\
    \ n == num).min_by { |n| n }\n    end\nend", "  result = []\n  sum = []\n  for\
    \ i in 0...nums.length\n    sum.push(0)\n    result.push(sum.last)\n    sum.push(nums[i])\n\
    \    result.push(sum.last)\n  end\n  result.push(sum.last)\n  result.min\nend\n\
    </cell>\n<code language=conda-root-py>\nminSubArraySum([4, 3, 1, 2])\n</cell>\n\
    <text>\nExercise 9\nIn the previous exercise you solved the following problem:\
    \ Given a list of numbers and a number target, \nfind the smallest positive integer\
    \ that does not occur in the list within the specified number of \niterations.",
  " \n  min, min_idx = 0, -1\n \n  nums.each do |i|\n    min_idx += 1\n \n    next\
    \ if min_idx > nums.length\n \n    current =  nums[min_idx] - i\n \n    next if\
    \ current < 0\n \n    min += current\n \n    break if nums[min_idx] > i\n  end\n\
    \ \n  min\nend", "    min = nil\n    max = nums[0]\n    for num in nums\n    \
    \    sum = max + num\n        min = nil if sum < min or min == nil then sum +=\
    \ sum else min = sum end\n        max = num\n    end\n    min\nend\n</code>\n\
    <|/ a tags=ruby dscore=3 |>\n<| c |>\nI think this is slightly incorrect (though\
    \ it's very close). If `nums == [nil]`, then `minSubArraySum([nil])` should return\
    \ nil, but your code returns 0. Also, it doesn't work when the array has only\
    \ one element. For example, `minSubArraySum([3])` should return 3, but your code\
    \ returns 3.\n<|/ c |>\n<| c |>\nYou are absolutely right - I did not consider\
    \ that. I've updated the answer. I had missed that possibility\n<|/ c |>\n<| a\
    \ dscore=3 tags=ruby |>\nYou can use Array#min and Array#max and some math (using\
    \ Integer#div):\n<code>\nnums = [nil, 4, nil, 7]  # => [nil, 4, nil, 7]\nmin =\
    \ nil\nnums.each do |i| \n  sum += i \n  min = nil if !min || sum < min \n  max\
    \ = i unless max \n  min = sum / max \nend\nmin #=> 3\n</code>\nThis takes advantage\
    \ of the fact that the integer division returns the whole number if there is no\
    \ remainder; hence if sum / max is greater than 1, it is the largest integer divisor\
    \ of sum.\n<|/ a |>\n<| a tags=ruby dscore=3 |>\n<code>", "  # TODO: Your code\
    \ here\nend", "    # Write your code here.\nend\n</cell>\n<code language=julia-0.5>\n\
    nums = [1, 2, 3, 4, 5]", "    n = nums.length\n    min = Bignum.zero\n    sum\
    \ = Bignum.zero\n    \n    for i in 0...n-1\n        sum += nums[i]\n        if\
    \ sum < min\n            min = sum\n        end\n    end\n    \n    return min\n\
    end\n</cell>\n<code language=julia-1.5>\nfunction minSubArraySum(nums)\n    n\
    \ = length(nums)\n    min = Bignum.zero\n    sum = Bignum.zero\n    \n    for\
    \ i in 0...n-1\n        sum += nums[i]\n        if sum < min\n            min\
    \ = sum\n        end\n    end\n    \n    return min\nend\n</cell>\n<code language=julia-1.5>\n\
    function minSubArraySum(nums)\n    n = length(nums)\n    min = Bignum.zero\n \
    \   sum = Bignum.zero\n    \n    for i in 0...n-1\n        sum += nums[i]\n  \
    \      if sum < min\n            min = sum\n        end\n    end\n    \n    return\
    \ min\nend\n</cell>\n<code language=julia-1.5>\nfunction minSubArraySum(nums)\n\
    \    n = length(nums)\n    min = Bignum.zero\n    sum = Bignum.zero\n    \n  \
    \  for i in 0...n-1\n        sum += nums[i]\n        if sum < min\n          \
    \  min = sum\n        end\n    end\n    \n    return min\nend\n</cell>\n<code\
    \ language=julia-1.5>\nfunction minSubArraySum(nums)\n    n = length(nums)\n \
    \   min = Bignum.zero\n    sum = Bignum.zero\n    \n    for i in 0...n-1\n   \
    \     sum += nums[i]\n        if sum < min\n            min = sum\n        end\n\
    \    end\n    \n    return min\nend\n</cell>\n<code language=julia-1.5>\nfunction\
    \ minSubArraySum(nums)\n    n = length(nums)\n    min = Bignum.zero\n    sum =\
    \ Bignum.zero\n    \n    for i in 0...n-1\n        sum += nums[i]\n        if\
    \ sum < min\n            min = sum\n        end\n    end\n    \n    return min\n\
    end\n</cell>\n<code language=julia-1.5>\nfunction minSubArraySum(nums)\n    n\
    \ = length(nums)\n    min = Bignum.zero\n    sum = Bignum.zero\n    \n    for\
    \ i in 0...n-1\n        sum += nums[i]\n        if sum < min\n            min\
    \ = sum\n        end\n    end\n    \n    return min\nend\n</cell>\n<code language=julia-1.5>\n\
    function minSubArraySum(nums)\n    n = length(nums)\n    min = Bignum.zero\n \
    \   sum = Bignum.zero\n    \n    for i in 0.", "  min = nums[0]\n  for i in nums[1..-1]\n\
    \    if i < min\n      min = i\n  return min\nend", "  sum = nums.inject(0){|sum,el|\
    \ sum+el}\n  while nums.length > 0\n    sum = nums.inject(0){|sum,el| sum+el}\n\
    \    nums.delete_if{|el| sum-el <= 0}\n    sum = nums.inject(0){|sum,el| sum+el}\n\
    \  end\n  sum\nend", "    # write your code here\n    nums.sort!\n    sum = 0\n\
    \    for i in nums\n        sum += i\n    end\n    return sum\nend", "    nums.each\
    \ do |i|\n        sum = (nums.size - 1) * nums.last\n        if sum < i\n    \
    \        sum = i\n        end\n        nums.delete(sum)\n    end\n    nums.sort!\n\
    \    sum = (nums.size - 1) * nums.last\n    sum -= nums.first if sum == 0\n  \
    \  sum\nend\nputs minSubArraySum([1,2,3,4])", '  return 0 # Your code here', " \
    \   min = nums[0]\n    count = 0\n    \n    nums.each do |num|\n        if min\
    \ > num + count\n            min = num + count\n        end\n        count +=\
    \ 1\n    end\n    return min\nend", "  nums.sort\n  minSubArray = nil\n  minSubArray\
    \ = nums.inject( 0 ) { |sum, el| sum + el }\n  sum = 0\n  nums.each { |el| sum\
    \ += el if sum < minSubArray }\n  minSubArray\nend", "    # Write your code here\n\
    \    nums=nums.sort\n    sum=0\n    nums.each_index do |i|\n        i+=1\n   \
    \     sum+=nums[i]\n    end\n    return sum\nend", "    puts \"minSubArraySum(nums)\
    \ begins ...\"\n    puts \"nums length: #{nums.length}\"\n    puts \"nums: #{nums}\"\
    \n    nums.each do |n|\n        puts \"n: #{n}\"\n    end\n    \n    nums.each\
    \ do |n|\n        puts \"n: #{n}\"\n    end\n    puts \"minSubArraySum(nums) ends\
    \ ...\"\nend", "  minSum, minIndex = 0, -1\n  nums.each do |i|\n    if minSum\
    \ < i \n      minSum = i \n      minIndex = i\n    end \n  end \n  minIndex\n\
    end", "    # Write your code here\n    sorted_array = nums.sort.to_a\n    return\
    \ sorted_array.length.times { |i| sorted_array[i..-1].min }.min\nend", "  minSum\
    \ = nums[0]\n  nums.each {|num|\n    if min != num\n      minSum = num\n    end\n\
    \  }\n  return minSum\nend", "  result = 0\n  nums.each do |num|\n    result +=\
    \ (num > 0) ? num : 0\n  end\n  return result\nend", "    nums.each_with_index\
    \ do |num, i|\n      min = num\n      nums.delete_at(i - 1)\n      nums.delete_at(i)\n\
    \      nums.each do |j|\n        min = num if num + j < min\n      end\n     \
    \ return min if min >= 0\n    end\n    return -1\n  end\n  ", "  nums.sort!\n\
    \  minimum = nums.min\n  (1..minimum).each do |index|\n    minimum -= nums[index]\n\
    \    break if minimum == 0\n  end\n  minimum\nend", "\treturn 0 if nums.empty?\
    \ else nums.inject(0) { |sum, num| sum + num }\nend", "  # Write your code here.\n\
    end", "\tmin = nums[0]", "  # Your code here\n  minimum = Integer.max\n  min =\
    \ nil\n  arr.each do |n|\n    if n <= minimum then\n      minimum = n\n      min\
    \ = n\n    else\n      minimum += n\n      min = nil\n    end\n  end\n  min\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c |>\nThe solution is not valid\
    \ for the question. `minSubArraySum([1,2,3]) == 1`, while `minSubArraySum([1,2,4,5])\
    \ == 4`\n<|/ c |>\n<| c |>\nI understand your point. Can you please help me to\
    \ optimize this code?\n<|/ c |>\n<| c |>\nI posted a solution that does work.\
    \ I'm not convinced this is an improvement, but it doesn't get you downvoted.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  # Write your code here.\nend", "  # Handle\
    \ edge case\n  if nums.empty?\n    0\n  else\n    num = nums.max\n    sum = num\
    \ + minSubArraySum(nums[1..-1])\n  end\nend", "  sorted_nums = nums.sort.reverse\n\
    \  sum = sorted_nums[0]\n  for i in 1..sorted_nums.length\n    sum = sorted_nums[i]\
    \ + sum\n  end\n  return sum\nend\n</code>\nNow we can test the function:\n<code>\n\
    array1 = [-1,3,-4,5,7,0,9]\np minSubArraySum(array1) # => -11", "  sum = 0\n \
    \ min = nil\n  max = nums.max", "  sum = 0\n  n = nums.length", "  nums.min\n\
    end\n</cell>\n<cell>\nminSubArraySum([4, 6, 3])\n</cell>\n<text>\nReturn to task\
    \ 1.1", "    arr = [nums[0], nums[1]]\n    arr.each do |num|\n        min_sum\
    \ = nums[0]\n        min_so_far = nums[0]\n        (1..nums.size).each do |i|\n\
    \            num = nums[i]\n            next if num == 0\n            if num <\
    \ min_so_far\n                min_so_far = num\n            elsif num > min_sum\n\
    \                min_sum = num\n            end\n        end\n        arr = [min_so_far\
    \ + nums[0], min_sum + nums[1]]\n    end\n    arr\nend\n</cell>\n<code language=julia-1.5>\n\
    minSubArraySum([5,3,4,5,2,10,1])\n</cell>\n<code language=julia-1.5>", "  # code\
    \ here\nend", "  return nil\nend", "    # Write your code here.\n    result =\
    \ nums[0]\n    for i in 1...nums.length\n        result = result + nums[i]\n \
    \   return result \nend", "  \n  # your code here\n  nums.sort!\n  sum = 0\n \
    \ sum = (nums[0..nums.size/2] + [nums[nums.size/2-1]] * (nums.size/2-1)) + nums[nums.size/2]\n\
    \  return sum\nend", "    count = 0\n    sum = nums[0]\n    temp = nums[0]\n \
    \   for i in nums\n        if i == 0\n            count += 1\n        else\n \
    \           count += 2\n            sum += i\n        end\n        if count >\
    \ 1\n            temp += i - sum\n            sum = temp\n            count =\
    \ 0\n        end\n    end\n    temp\nend", "    min = nums.last\n    max = nums.first\n\
    \    sum = 0\n    nums.each do |i|\n        sum += i\n        if sum < min\n \
    \           min = sum\n        end\n        if sum > max\n            max = sum\n\
    \        end\n    end\n    min\nend", "\tmin = nil\n\tmin_sum = nil", "  nums.map\
    \ {|n| n}.uniq.sort.reduce(:+)\nend\n</pre>", "  # Your code here\nend", "   \
    \ sum = nums.reduce(:+)\n    min = nums[0]\n    max.each { |v| min = nums.reduce(:+)\
    \ if v < min }\n    min + (sum - min)\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays\
    \ |>\nMy Ruby version\n<code>", end, "  min_sum = nums.min\n  min_sum.downto(0)\
    \ { |n| min_sum = nums.min if nums.min > n+min_sum end}\n  min_sum\nend", "  \
    \  return minSubArraySum(nums, 0, nums.length - 1);\nend", "    return nums.inject(:+).min\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThank you very much for taking the time to write\
    \ such a detailed answer. I'm going to try to understand what it's doing but for\
    \ the moment I'll stick with my solution. Thanks again.\n<|/ c |>\n<| c |>\nIt's\
    \ good to see you understand Ruby and how to break it down into pieces.  It may\
    \ be helpful for someone to think of it like that, instead of as an \"algorithm\"\
    \n<|/ c |>\n<| c |>\nI added a solution that uses `inject`.  My solution is essentially\
    \ what `inject` does in Ruby, but it's a bit simpler.  I believe my solution is\
    \ also more efficient, although I haven't verified this.\n<|/ c |>\n<| c |>\n\
    I understand your code. It's a very nice explanation as to how the inject method\
    \ works. The inject method iterates through the array of numbers. In this case,\
    \ the inject method takes a symbol :+ as its first parameter and a number as its\
    \ second parameter. So it iterates through the array adding together the numbers\
    \ in the array. Finally it returns the minimum value. Thanks again.\n<|/ c |>\n\
    <| a |>\n<code>", "  nums.each_with_index do |num, i|\n    if num > 0\n      num\
    \ = nums.delete_at(i)\n      nums.unshift(num)\n    end\n  end\n  nums.min\nend\n\
    </code>\n<|/ a tags=ruby,algorithm dscore=0 |>\n<| c |>\nThis returns wrong answer\
    \ if array contains only negative numbers, eg. [-3, -4, 3, 5] will give -3 instead\
    \ of 3.\n<|/ c |>\n<| c |>\nPlease read again, especially the part where I put\
    \ \"Example\" at the bottom of the answer. It shows exactly how negative numbers\
    \ are handled in the example I gave. Besides, I specifically said that negative\
    \ numbers were not allowed, which meant that they were not handled at all. `-3`\
    \ is **not** \"handled\".\n<|/ c |>\n<| c |>\nAh, missed that. I read it again\
    \ after posting my comment and now I see it. Sorry.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  return nums.reduce(:+, 0)\nend", '  nums = nums.sort.sort', "    minimumSum\
    \ = 0\n    smallestIndex = 0\n    largestIndex = nums.length - 1\n    \n    while(smallestIndex\
    \ <= largestIndex)\n        minimumSum = nums[smallestIndex] + minimumSum\n  \
    \      smallestIndex += 1\n        if(smallestIndex == largestIndex)\n       \
    \     smallestIndex += 1\n            largestIndex += 1\n            \n      \
    \  while(smallestIndex < largestIndex)\n            minimumSum = nums[largestIndex]\
    \ - minimumSum\n            largestIndex -= 1\n            \n            if(minimumSum\
    \ < 0)\n                largestIndex -= 1\n            else\n                largestIndex\
    \ += 1\n                \n    return minimumSum\nend\n</cell>\n<code language=julia-1.5>",
  "\tsum = nums[0]\n\tmin = nums[0]\n\tfor i in 1..nums.length\n\t\tif nums[i] > sum\
    \ + min then\n\t\t\tmin = sum + min\n\t\t\tsum = nums[i]\n\t\telse\n\t\t\tsum\
    \ = sum + nums[i]\n\t\tend\n\tend\n\tmin\nend", "  nums.max\nend", "\tsum = 0\n\
    \tfor i in 0..(nums.length - 1)\n\t\tsum += nums[i]\n\tminSum = sum\n\tfor i in\
    \ 0..(nums.length - 1)\n\t\tif nums[i] > minSum\n\t\t\tminSum = nums[i]\n\t\t\
    end\n\tend\n\treturn minSum\nend", "  min = nums.inject(0, :+).min\n  nums.each\
    \ do |n|\n    min = Math.min(min, n)\n  end\n  min\nend", "  # base case\n  if\
    \ nums.length == 0\n    return 0\n  # subarray case\n  if nums.length == 1\n \
    \   return nums[0]\n  # recursive case\n  nums.each do |num|\n    min_sum = nums[0]\n\
    \    sub_nums = nums[1..num.length-1]\n    sub_nums.each do |num|\n      min_sum\
    \ += num\n    end\n    return min_sum if min_sum >= num\n  end\nend", "    min\
    \ = Integer.MAX_VALUE\n    max = Integer.MIN_VALUE\n    total = 0\n    sum = 0\n\
    \    \n    nums.each do |n|\n        total += n\n    end\n    \n    sum = total\n\
    \    \n    until sum >= 0\n        total -= nums.shift\n        \n        sum\
    \ = total\n    \n        min = nums.first if min > total\n        max = nums.last\
    \ if max < total\n    end\n    \n    min\nend", "  # Your code here\n  total=0\n\
    \  minimum=nil\n  for i in (0...nums.length)\n    arr=nums.slice(i,i)\n    sum=0\n\
    \    for j in (0...arr.length-1)\n      sum+=arr[j]\n    end\n    total+=sum\n\
    \    if minimum==nil || total<minimum\n      minimum=total\n    end\n  end\n \
    \ minimum\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails-3 |>\n<| a dscore=0\
    \ |>\n<code>", "    # Write your code here.\n    i = 0\n    sum_of_array = nums[0]\n\
    \    sum1 = nums[0]\n    while i < nums.length\n        sum1 += nums[i]\n    \
    \    i += 1\n        sum_of_array += sum1\n    end\n    return sum_of_array\n\
    end\n</cell>\n<code language=julia-0.3>\nminSubArraySum([3, 6, -5, 3, 1])\n</cell>\n\
    <text>\nPart 4: Basic Rubik's Cube\nWrite a function, cube(size), that takes the\
    \ size of a cube as a parameter and returns the cube of the size entered.", " \
    \   array.sort {|a, b| b - a}\n    n = nums.size\n    max = nums.first\n    min\
    \ = nums.last\n    sum = 0\n    while n < nums.size\n        sum = sum + nums[n]\n\
    \        if sum >= max then \n            max = sum\n            min = nums[n]\n\
    \        elsif sum < max then\n            sum = sum - max\n            max =\
    \ nums[n]\n        elsif sum >= min then\n            sum = sum - min\n      \
    \      min = nums[n]\n        else\n            return sum\n        end\n    \
    \    n = n + 1\n    end\n    return sum\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ c |>\nThis has a bug: It doesn't handle empty arrays. A solution is to check\
    \ whether the array is empty before you call `array.sort`. If it is, you return\
    \ 0. Otherwise, call `array.sort`. After calling `array.sort`, you check whether\
    \ `array.first` is 0. If so, you return `0`. Otherwise, you return the sum of\
    \ the first element, because that's the sum you're looking for.\n<|/ c |>\n<|\
    \ c |>\nThank you for the comment. It should be fixed now.\n<|/ c |>\n<| a dscore=4\
    \ |>\nI came up with this:\n<code>\nnums = [1,2,3,4,5]", "  min = -999\n  min\
    \ = nums[0]\n  nums.each do |x|\n    min = min > x ? x : min\n  end\n  min\nend",
  "\treturn nums.inject(:+).min\nend\n</cell>\n<code language=julia-0.5>", "  min\
    \ = nil\n  nums.each_index do |i|\n    cur_sum = nums[i]\n    cur_subs = nums[0..i-1]\n\
    \    if cur_sum < min || cur_subs.empty? || cur_sum < cur_subs.min\n      min\
    \ = cur_sum\n    end\n  end\n  min\nend", "    minimum = nums[0]\n    sub_array\
    \ = []\n    i = 0\n    while(i<nums.length)\n        if nums[i] <= minimum\n \
    \           sub_array = [nums[i]] + sub_array\n        else\n            sub_array\
    \ = [minimum] + sub_array\n        end\n        i += 1\n        minimum = sub_array.reduce(:+)\
    \ \n    end\n    return minimum\nend", "  nums.sort!\n  nums.inject(:+).min if\
    \ nums.any?\nend", "\tsum = nums[0]\n\tmin = nums[0]\n\tfor i in nums\n\t\tif\
    \ i < sum\n\t\t\tmin = i\n\t\t\tsum -= i\n\t\tend\n\tend\n\treturn min\nend",
  "    # Write your code here.\n    minimum = nums[0]\n    size = nums.length\n  \
    \  for i in 1...size\n        minimum = minimum + nums[i]\n    end\n    return\
    \ minimum\nend", "  \n  # Initialize the minimum sum found so far to infinity\n\
    \  sum = 0 ", "\tminSum = nums[0]\n\tminSubArraySumRecursion(nums, 0)\n\treturn\
    \ minSum\nend", "  minSum = nums[0]\n  for i in 1..nums.size\n    currentSum =\
    \ nums[i] + nums[i-1]\n    minSum = currentSum < minSum ? currentSum :minSum\n\
    \  end\n  minSum\nend", "  # Write your code here.\nend", '  return nil if nums.empty?',
  "  # Your code here\nend", "    minimum_sum = 0\n    size = nums.count{|i| i > minimum_sum}\n\
    \    sum_of_nums = nums.reduce(0, :+) + nums.reduce(nums.last, :+)\n    minimum_sum\
    \ = sum_of_nums - nums.inject(0) {|sum, e| sum + e}\n    size\nend", "    # Write\
    \ your code here.\n    if nums.empty? || nums.size == 0\n        return -1\n \
    \   end", "  return nil if nums.empty?\n  \n  nums.each do |num|\n    curr_sum\
    \ = num\n    next_sum = nil\n    \n    # Go through the rest of the array and\
    \ find the minimum sum of any sub-array.\n    nums[1..-1].each do |num|\n    \
    \  if next_sum.nil? or next_sum > curr_sum + num\n        next_sum = curr_sum\
    \ + num\n      end\n    end\n    \n    return next_sum if next_sum\n  end\n  \n\
    \  nil\nend\n</cell>\n<cell>", "  min_sum = nums[0]\n  min_sub_array = []\n  nums.each\
    \ do |i|\n    min_sum += i\n    sub_arr = nums.select { |v| v > i }\n    min_sub_array\
    \ << sub_arr.sum if sub_arr.any?\n  end\n  return min_sum, min_sub_array\nend",
  "  raise \"Not implemented\"\nend", "  return nums.reduce{|a,b| a if a < b ? a :\
    \ b}\nend", "  min, sum, index = nums.first\n  index = 0\n  while index < nums.length\n\
    \    sum = sum + nums[index]\n    if sum > max\n      max = sum\n      min = index\n\
    \    index += 1\n  end\n  return min\nend", "  # write your code in Ruby\nend",
  "  (0...nums.size).find do |i|\n    i <=> nums.min\n  end\nend", "  nums.each_with_index.inject(0)\
    \ {|sum, (i, v)|\n    return sum if v == 0\n    return sum if v < i || (v == i\
    \ && sum < sum)\n    return sum + v }\nend", "  minimum = nums.min\n  minimum\
    \ = 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty?\
    \ then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n\
    \  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum =\
    \ nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n\
    \  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum =\
    \ 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty?\
    \ then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n\
    \  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum =\
    \ nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n\
    \  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum =\
    \ 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty?\
    \ then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n\
    \  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum =\
    \ nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n\
    \  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum =\
    \ 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty?\
    \ then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n\
    \  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum =\
    \ nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n\
    \  minimum = 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum =\
    \ 0 if nums.empty? then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty?\
    \ then minimum\n  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n\
    \  minimum = nums.min\n  minimum = 0 if nums.empty? then minimum\n  minimum =\
    \ nums.min\n  ", "  return nil\nend", "    smallestSubArraySum = 0\n    smallestSubArray\
    \ = Array.new\n    nums.each {|x| smallestSubArray << x}\n    smallestSubArray.each\
    \ {|x| smallestSubArraySum += x}\n    smallestSubArraySum\nend", "    # write\
    \ your solution here\n    return 0\nend", "    return 0\nend", "    min = nil\n\
    \    sum = 0\n    until nums.empty? do\n        sum = nums.inject(:+) + sum\n\
    \        if min == nil || sum < min\n            min = sum\n        end\n    \
    \    sum -= nums.pop\n    end\n    min\nend", "  return nums.min if nums.length\
    \ > 0 else 0\nend", "    # Write your code here.\nend", "  nums.each {|num| return\
    \ nums.min if nums.min == num}\nend", "  nums.uniq.map { |n| nums.reduce(:+) +\
    \ n }.reduce(:+)\nend\n</pre>\n</div>\n</div>\n</div>\n</div>\n<div id=\"footer\"\
    >\n<div id=\"footer-text\">\nLast updated 2016-12-15 12:46:52 PST\n</div>\n</div>\n\
    </body>\n</html>\n<|/ file ext=.html filename=index.html |>\n<| c |>\nThanks,\
    \ this was very helpful and it helped me understand how to use reduce.\n<|/ c\
    \ |>\n<| a tags=ruby |>\nIt will be much easier if we rewrite this problem using\
    \ a more ruby way (I suppose)\n<code>", "  minSum = nil\n  nums.each do |n|\n\
    \    sum += n\n    minSum = sum if sum < minSum\n  end\n  minSum\nend", "    sum\
    \ = 0\n    diff = nil\n    if nums.length < 2\n        return sum\n    end\n \
    \   diff = nums.max - nums.min\n    nums.sort\n    nums.each do |num|\n      \
    \  sum += num - nums.min if num - nums.min >= 0 && num - nums.min <= diff\n  \
    \  end\n    return sum\nend", "  nums.sort.each do |i|\n    (i + nums.min).to_a\n\
    \  end\nend", "  max_sum = nums.reduce(0, :+)\n  min_sum = nums.reduce(0, :+,\
    \ 0)\n  min_sum = max_sum if max_sum < min_sum", "    return nums.min\nend", " \
    \   loop do\n        minsum = nums[0] # Initialize minimum sum to first number\n\
    \        minindex = 0\n        minindex = 1 unless nums.include?(minsum) # If\
    \ first number not in array, do not update\n        minindex = 2 unless nums.include?(minsum\
    \ + nums[1]) # If second number not in array, do not update\n        minindex\
    \ = 3 unless nums.include?(minsum + nums[1] + nums[2]) # If third number not in\
    \ array, do not update\n        minindex = 4 unless nums.include?(minsum + nums[1]\
    \ + nums[2] + nums[3]) # If forth number not in array, do not update\n       \
    \ minindex = 5 unless nums.include?(minsum + nums[1] + nums[2] + nums[3] + nums[4])\
    \ # If fifth number not in array, do not update\n        minindex = 6 unless nums.include?(minsum\
    \ + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]) # If sixth number not in\
    \ array, do not update\n        minindex = 7 unless nums.include?(minsum + nums[1]\
    \ + nums[2] + nums[3] + nums[4] + nums[5] + nums[6]) # If seventh number not in\
    \ array, do not update\n        minindex = 8 unless nums.include?(minsum + nums[1]\
    \ + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7]) # If eighth number\
    \ not in array, do not update\n        minindex = 9 unless nums.include?(minsum\
    \ + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8])\
    \ # If ninth number not in array, do not update\n        minindex = 10 unless\
    \ nums.include?(minsum + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6]\
    \ + nums[7] + nums[8] + nums[9]) # If tenth number not in array, do not update\n\
    \        minindex = 11 unless nums.include?(minsum + nums[1] + nums[2] + nums[3]\
    \ + nums[4] + nums[5] + nums[6] + nums[7] + nums[8] + nums[9] + nums[10]) # If\
    \ eleventh number not in array, do not update\n        minindex = 12 unless nums.include?(minsum\
    \ + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8]\
    \ + nums[9] + nums[10] + nums[11]) # If twelveth number not in array, do not update\n\
    \        minindex = 13 unless nums.include?(minsum + nums[1]", "  return minimumSum(nums,\
    \ 0, nums.length-1, 0)\nend\n</cell>\n<cell>\nnums = [-4, -2, 1, 3, 6]\n</cell>\n\
    <cell>\nminSubArraySum(nums)\n</cell>\n<cell>\nminSubArraySum([1, 2, 5])\n</cell>\n\
    <cell>", "  min_sum = nums.reduce(0, :+).min\n  nums.each do |num|\n    min_sum\
    \ = num if num + min_sum > num\n  end\n  min_sum\nend", "  nums.reduce(:+)\nend",
  "  if nums.empty?\n    return 0\n  else\n    nums.first\n    num = nums.shift\n\
    \    ans = num\n    i = nums.size\n    until nums.empty? do\n      num << nums.shift\n\
    \      num -= num\n      ans = num if num < ans else ans\n      i -= 1\n    end\n\
    \    return ans\n  end\nend\n</code>\nMy solution with dynamic programming\n<code>",
  "  # Write your solution here\nend", "  nums.sort!\n  result = -Float::INFINITY\n\
    \  i = 1\n  while i < nums.length\n    result += nums[i]\n    if result < 0\n\
    \      result = nums[i]\n      i += i + 1\n    else # result = nums[i]\n     \
    \ i = 0\n    end\n  end\n  result\nend", "  min_sum = nums.reduce{|sum, i| sum\
    \ + i}\n  return min_sum if min_sum > 0", '  return nil if nums.length == 0 ',
  "    nums.each_with_index.map{|i,j| i+j}.inject{|sum,i| sum if sum<i }\nend", " \
    \ nums.each do |n|\n    nums.each do |n|\n      if n < nums.min\n        nums.min\
    \ = n\n      end\n    end\n  end\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n\
    <| c |>\nCan you explain why this works? I'm having a difficult time visualizing\
    \ it.\n<|/ c |>\n<| c |>\nThe `min` function returns the minimum value in the\
    \ array. Since you don't care which value it returns, just calling it twice is\
    \ the same as calling `min` once. Instead, you have to store the minimum value\
    \ you find somewhere and then compare it to the new value you're looking at. `min`\
    \ and `max` work the same way in this context, but `min` returns an array of the\
    \ minimum values that have been encountered so far.\n<|/ c |>\n<| a tags=algorithm,ruby\
    \ |>\nThis is a different way but much faster and uses less memory, and doesn't\
    \ require a pre-sorted array:\n<code>", "  return nums.reduce(:+)\nend\n</cell>\n\
    <text>\nThe reduce method is a method of Arrays, and is extremely useful.", " \
    \ # TODO: Implement this function\n  min = nums[0]\n  for i in nums\n    min =\
    \ min + i\n  end\n  return min\nend", "  sum = 0\n  minSum = nil", "  min = Integer.new\n\
    \  minArray = nums\n  sum = 0\n  n = nums.length\n  nums.each_with_index do |value,\
    \ index|\n    sum += value\n    min = value if min > sum\n    sum -= nums[index]\n\
    \  end\n  minArray = nums.select { |value| value == min }\n  if minArray.empty?\n\
    \    sum\n  else\n    minArray.first\n  end\nend", "  # Write your code here\n\
    \  smallest_sum = 1\n  sum_of_min_subarray = nums[0]\n  for num in nums\n    sum_of_min_subarray\
    \ = sum_of_min_subarray + num\n    return sum_of_min_subarray if sum_of_min_subarray\
    \ < smallest_sum \n    smallest_sum = sum_of_min_subarray\n  end\n  return smallest_sum\n\
    end", "    # write your code here\n    # return min element\n    sum_array = Array.new\n\
    \    sum_array.push(nums[0])\n    sum_array.push(nums[0])\n    sum_array.push(nums[0])\n\
    \    sum_array.push(nums[0])\n    sum_array.push(nums[0])\n    sum_array.push(nums[0])",
  "  # Write your code here.\n  smallest_sum = Integer.MAX_VALUE\n  subarray_sum =\
    \ Integer.MAX_VALUE\n  result = 0\n  begin_index = 0\n  end_index = nums.length\
    \ - 1\n  while begin_index <= end_index\n    smallest_sum = subarray_sum\n   \
    \ subarray_sum = nums[begin_index..end_index].inject(0) {|sum, el| sum + el}\n\
    \    if subarray_sum < smallest_sum\n      smallest_sum, subarray_sum = subarray_sum,\
    \ smallest_sum\n      begin_index += 1\n    else\n      begin_index += 1\n   \
    \ end\n    if begin_index == end_index\n      result = smallest_sum\n    end\n\
    \  end\n  result\nend\n</cell>\n<code language=julia-1.0>\nnums = [-10, -3, 2,\
    \ -5, -7, -1, 3, 6, 5, 3, -4]\n</cell>\n<code language=julia-1.0>\nminSubArraySum(nums)\n\
    </cell>\n<code language=julia-1.0>", "  return (nums.reduce(:+).min || 0)\nend",
  "  # base case: empty array\n  return 0 if not nums ", "\tmin = Integer.MAX_VALUE\n\
    \ti = 0\n\tj = 0\n\twhile (i < nums.length and j < nums.length):\n\t\tmin = Math.min(min,\
    \ nums[i] + nums[j])\n\t\ti += 1\n\t\tj += 1\n\treturn min\nend", "  min = nums[0]\n\
    \  max_sum = nums[0]\n  for i in 1..nums.length\n    sum = nums[i]\n    if sum\
    \ < min\n      min = sum\n    if sum > max_sum\n      max_sum = sum\n  end\n \
    \ max_sum\nend", "\t\n\t# O(n) time and O(1) space\n\tsums, size = nums.reduce(&:+),\
    \ nums.size", "  minSum(nums, 0, nums.length - 1)\nend", "    nums.reduce(:+)\n\
    end", "  min_so_far = nums.min\n  min_so_far[0] = nil\n  min_so_far.last.nil?\
    \ ? min_so_far : min_so_far.pop\n  for i in 1..nums.length\n    temp = min_so_far\n\
    \    min_so_far[i] = min_so_far[i-1] + nums[i]\n    min_so_far[i-1] = temp\n \
    \ end\n  return min_so_far.sum\nend", "    sum, min = 0, nums.last\n    nums.each_with_index\
    \ do |num, i|\n        sum, min = sum + num, min if sum > min\n    end\n    min\n\
    end\n</cell>\n<cell>\nminSubArraySum([1,2,3,4])\n</cell>\n<cell>\nminSubArraySum([1,2,3,0])\n\
    </cell>\n<cell>\nminSubArraySum([1,2,3,0,4,5])\n</cell>\n<cell>\nminSubArraySum([1,2,0,3])\n\
    </cell>\n<text>\nCoin Change\nGiven two integer arrays amounts and denominations\
    \ where amounts[i]\ndenotes the amount of a given denomination and denominations[i]\
    \ denotes\nthe denomination of a given coin. Return the minimum number of coins\n\
    required to make the total amount.", "  nums.sort\n  ans = nums.min\n  (0...nums.length).each\
    \ do |i|\n    break if nums[i] != ans\n    ans = nums[i] + ans\n  end\n  ans\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
