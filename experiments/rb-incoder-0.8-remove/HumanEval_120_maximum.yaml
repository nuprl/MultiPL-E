name: HumanEval_120_maximum
language: rb
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# Example\
  \ 2:\n# Example 3:\n# Note:\n# 1. The length of the array will be in the range of\
  \ [1, 1000].\n# 2. The elements in the array will be in the range of [-1000, 1000].\n\
  # 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n\
  \    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3,\
  \ -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2],\
  \ candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123,\
  \ -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123,\
  \ 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5,\
  \ 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2,\
  \ 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n   \
  \ assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10],\
  \ candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23,\
  \ 243, -400, 0], 0))\n  end\nend\n"
completions: ["    \n    # Write your code here\n    \n    return max_arr\nend", " \
    \   sorted = Array.new(k) # Create a new array with the size k\n    maximum_value\
    \ = nil # Initialize a variable for storing the maximum value found so far\n \
    \   # Traverse through the array\n    sorted = arr.reverse.sort.reverse # Sort\
    \ the array in descending order\n    # Loop through k times, get the maximum value\
    \ and store it in the variable maximum_value\n    (0...k).each { |i| maximum_value\
    \ = arr[i] if arr[i] > maximum_value }\n    sorted\nend", "    max = -99999999\n\
    \    i = 0\n    while i < k\n        j = i + k - i\n        max, i = max(max,\
    \ arr[i]), j\n        k, i = k - 1, i\n    max\nend\n</code>\n<|/ a tags=algorithm,sorting,arrays\
    \ dscore=4 |>\n<| a tags=algorithm,sorting,arrays |>\nI made a small modification\
    \ to my algorithm: instead of taking the max out of the middle of the array, I\
    \ take the max from the beginning and end of the array. \nThis gives us this code:\n\
    <code>", "  sorted_arr = []\n  if k == 1\n    sorted_arr.push(arr[0])\n  else\n\
    \    sorted_arr.push(arr[0])\n    arr.shift\n    maximum(a, k)\n  end\nend", " \
    \ return arr.sort.last(k)\nend", "  # Your code here\n  arr.sort!\n  maxArr =\
    \ []\n  (arr.size-k).times do |i|\n    maxArr << arr[i]\n  end\n  return maxArr\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI appreciate the effort but your answer doesn't\
    \ use recursion (except in the recursion-less code part).\n<|/ c |>\n<| a dscore=0\
    \ tags=sorting,arrays,ruby,algorithm |>\nHere is an answer without recursion\n\
    <code>\narr = [7, 3, 1, 2, 5, 8, 0, 9]", "  sorted = Array.new\n  i = 0\n  while\
    \ i < k\n    min = arr[i]\n    j = i\n    while j < k and min > arr[j]\n     \
    \ min = arr[j]\n      j += 1\n    arr[i] = min\n    i += 1\n  end\n  while i <\
    \ k\n    sorted.push arr[i]\n    i += 1\n  end\n  sorted\nend", "    max = nil\n\
    \    max2 = nil\n    arr.each do |i|\n        if !i.nil?\n            if i.to_i\
    \ > max and !max.nil?\n                max = i.to_i\n                max2 = i\n\
    \            end\n        end\n    end\n    return max2\nend", "  max_arr = []\n\
    \  max_arr.push(*arr.pop(k))\n  max_arr.push(*arr.max_by{|i| i})\n  max_arr.push(*arr.max_by{|i|\
    \ i}.last(k))\n  max_arr.push(*arr.max_by{|i| i}.first(k))\n  max_arr.push(*arr.max_by{|i|\
    \ i}.take(k))\n  max_arr.push(*arr.max_by{|i| i}.take_while{|i| i})\n  max_arr.push(*arr.max_by{|i|\
    \ i}.take_until{|i| i})\n  max_arr.push(*arr.max_by{|i| i}.take_while{|i| i}.last(k))\n\
    \  max_arr.push(*arr.max_by{|i| i}.take_until{|i| i}.first(k))\n  max_arr.push(*arr.max_by{|i|\
    \ i}.take_while{|i| i}.last(k).first(k))\n  max_arr.push(*arr.max_by{|i| i}.take_until{|i|\
    \ i}.first(k).first(k))\n  max_arr.push(*arr.max_by{|i| i}.take_while{|i| i}.first(k).first(k))\n\
    \  max_arr.push(*arr.max_by{|i| i}.first(k).first(k))\n  max_arr.push(*arr.max_by{|i|\
    \ i}.first(k).first(k))\n  max_arr.push(*arr.max_by{|i| i}.first(k).first(k).first(k))\n\
    \  max_arr.push(*arr.max_by{|i| i}.first(k).first(k).first(k).first(k))\n  max_arr.push(*arr.max_by{|i|\
    \ i}.first(k).first(k).first(k).first(k).first(k))\n  max_arr.push(*arr.max_by{|i|\
    \ i}.first(k).first(k).first(k).first(k).first(k).first(k))\n  max_arr.push(*arr.max_by{|i|\
    \ i}.first(k).first(k).first(k).first(k).first(k).first(k).first(k))\n  max_arr.push(*arr.max_by{|i|\
    \ i}.first(k).first(k).first(k).first(k).first(k).first(k).first(k).first(k).first(k))\n\
    \  max_", "    # write your code here\n    arr.sort!\n    max = arr.first\n  \
    \  arr.delete(0)\n    arr.delete_if{|x| x < max}\n    arr.delete_if{|x| x > max}\n\
    \    return arr[k..-1] if arr.size == k\n    return arr\nend", "  result = []\n\
    \  maxNum = arr[0]\n  minNum = arr[0]\n  \n  for i in 1..k\n    if maxNum > arr[i]\n\
    \      maxNum = arr[i]\n      \n    if minNum < arr[i]\n      minNum = arr[i]\n\
    \    end\n    \n    result.push(maxNum)\n    result.push(minNum)\n  end\n  \n\
    \  return result\nend\n</cell>\n<cell>\narr = [1,9,5,0,6,7,2,3]\nmaximum(arr,\
    \ 3)\n</cell>\n<cell>", "    arr.sort!\n    res = []\n    (0...k).each do |i|\n\
    \        arr.delete_at(i) if arr[i] > arr[i + 1]\n        res << arr[i]\n    end\n\
    \    res\nend", "  sorted_arr = arr.sort\n  length = sorted_arr.length\n  return\
    \ sorted_arr[k..length]\nend\n</cell>\n<code language=julia-0.6>", "  maximum\
    \ = arr[0]\n  maximum_index = -1\n  index_count = 0", "    return arr.combination(k).max_by(&:last)\n\
    end\n</cell>\n<cell>\nmaximum(arr, k)\n</cell>\n<text>\n12.3 Remove Duplicates\n\
    Given an array arr of integers, \nyou are asked to remove duplicates in-place\
    \ such that each element appears only once and returns the new length of the array.\n\
    You can modify the input array in-place as well.", "    \n    len = arr.length\n\
    \    \n    maximum = Array.new\n    \n    i = 0\n    j = 0\n    \n    while i\
    \ < k && j < len\n        \n        if arr[i] < arr[j]\n            \n       \
    \     maximum[i] = arr[i]\n            \n            i += 1\n            \n  \
    \      elsif arr[i] > arr[j]\n            \n            maximum[j] = arr[j]\n\
    \            \n            j += 1\n        \n        else\n            \n    \
    \        i += 1\n            \n            j += 1\n        \n    end", "  arr.sort!\n\
    \  return arr[0...k] if arr.length <= k else arr[0...k].max\nend", "  \n    max\
    \ = arr[0]\n    \n    arr.each_with_index { |e, i| \n       if arr[i] > max\n\
    \         max = arr[i]\n       end\n    }\n    \n    max = arr[k-1]\n    \n  \
    \  arr.each_with_index { |e, i| \n       if arr[i] < max\n         max = arr[i]\n\
    \       end\n    }\n    \n    max\n  end", "    \n    max = arr[0]\n    if k >\
    \ arr.length\n        return max\n    \n    for i in 1..k\n        if arr[i] >\
    \ max\n            max = arr[i]\n    \n    return max\nend", "    \n    max =\
    \ 0\n    \n    # Write your code here\n    i = 0\n    \n    while i < k\n    \
    \    \n        if arr[i] > max\n            max = arr[i]\n            \n     \
    \   i += 1\n    \n    end\n    \n    return max\n    \nend", "  return arr.reverse\
    \ \nend", "  arr = arr.sort\n  arr[k..-1] = arr[0..k]\n  return arr\nend\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 5)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 10)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 20)\n</cell>\n\
    <text>\nExercise 2\nGiven a positive integer n, return an array arr where arr[i]\
    \ is n if i is a multiple of 3, and -n otherwise. HINT: n can be any number, not\
    \ just an integer.\nExample 1:\nInput: n = 13\nOutput: [-7, -7, 3, 7]\nExample\
    \ 2:\nInput: n = 42\nOutput: [0, 0, -9, 0, -9, -18, 0, 3, 18, 36]\nExample 3:\n\
    Input: n = 10\nOutput: [10, -10, 0, 10]", "  arr.sort!\n  ret = []\n  (k..arr.length).each\
    \ do |i|\n    ret[k] = arr[i]\n    k = k-1\n  end\n  ret\nend", "    # write your\
    \ code here\n    arr.sort\n    arr.slice!(0, k)\n    arr\nend", "    return arr\
    \ \nend", "\tmax_arr = [0 for _ in 1..k] \n\tfor i in 0..k\n\t\tif arr[i] > max_arr[i]\n\
    \t\t\tmax_arr[i] = arr[i]\n\t\tend\n\tend\n\treturn max_arr\nend", "  arr &= (-2**63).to_i\n\
    \  arr.sort!\n  (arr[-k..-1] || []).reverse.first(k).to_a.shuffle\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby |>\n<| c |>\nWhat is this supposed to do? What is `(-2**63).to_i`?\n\
    <|/ c |>\n<| c |>\nIt is explained in the question: `1. The elements in the array\
    \ will be in the range of [-1000, 1000].`\n<|/ c |>\n<| c |>\nI meant \"what is\
    \ `(-2**63).to_i`?\", not \"what is your full question?\"\n<|/ c |>\n<| c |>\n\
    Oh yeah, I understand what you mean. Good idea, though.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is another way, using max_by and Array#combination:\n<code>\narr =\
    \ [1, 4, 2, 9]\narr.max_by { |e| e.combination(2).to_a.map(&:first) }\n  #=> [1,\
    \ 2, 4, 9]\n</code>\nLet's see what happens when we apply max_by to the array:\n\
    <code>\narr.max_by { |e| e.combination(2).to_a.map(&:first) }\n  #=> [1, 4, 2,\
    \ 9]\n</code>\nIt will be helpful to understand why this works. Let's recall what\
    \ Array#combination does:\n<code>\na = [1, 2, 3, 4]\na.combination(2).to_a\n \
    \ #=> [[1, 2], [3, 4]]\na.combination(2).to_a.map(&:first)\n  #=> [1, 2]\na.combination(2).to_a.map(&:first).map(&:first)\n\
    \  #=> [1, 2]\n</code>\nNow we can work backwards:\n<code>\na.combination(2).to_a.map(&:first).map(&:first)\n\
    \  #=> [1, 2]\n</code>\nThe last line says \"for each sub-array in the range [1,\
    \ 2], return the first element in it\". This means that we return [1, 2] from\
    \ each sub-array. We can apply this to the example array:\n<code>\na.combination(2).to_a.map(&:first).map(&:first)\n\
    \  #=> [1, 4, 2, 9]\n</code>\nTo do this, we first need to convert the array a.combination(2).to_a\
    \ to an array:\n<code>\na.combination(2).to_a\n  #=> [[1, 2], [3, 4]]\na.to_a\n\
    \  #=> [[1, 4], [2, 9]]\n</code>\nNow we can apply to_", "    \n    # Write your\
    \ code here.\n    maximums = [0]*(k+1)\n    max = -9999\n    i = 0\n    for i\
    \ in range(k):\n        if arr[i] > max:\n            maximums[i] = max\n    \
    \        max = arr[i]\n        elif arr[i] < max:\n            maximums[i] = arr[i]\n\
    \    for i in range(k+1):\n        maximums[i] = max(maximums[i], max)\n    return\
    \ maximums\n    ", "    puts arr\n    puts k\n    sorted_array = arr.sort\n  \
    \  puts sorted_array\n    return sorted_array[k]\nend", "    # write your code\
    \ here\n    largest = []\n    i = 0\n    j = k-1\n    while(i<j):\n        if(arr[i]\
    \ > arr[j]):\n            largest.append(arr[j])\n            j -= 1\n       \
    \ else:\n            largest.append(arr[i])\n            i += 1\n    largest.sort()\n\
    \    return largest", "    # \u9012\u5F52 O(n * k)\n    max = nil\n    if k ==\
    \ 1\n        return arr\n    else \n        arr.each do |i|\n            if i\
    \ == max \n                max = i\n            else\n                max = max\
    \ if i > max\n            end\n        end\n        maximum(arr, k - 1).unshift(max)\n\
    \    end\nend", "  max_array = []\n  if arr.size > 0\n    # Generate max_array\
    \ from arr.\n    for num in arr\n      max_array << num\n    # Find max number\
    \ from max_array and remove from max_array.\n    max_number.each do |number|\n\
    \      max_array << max_array.delete(number)\n    end\n    # sort max_array\n\
    \    max_array.sort!\n    # return max_array\n    k <= max_array.size\n  end\n\
    end", "    sorted = []\n    max = arr.max\n    while arr.length > 0\n        arr.delete(max)\n\
    \        sorted = sorted + [max]\n    end while\n    return sorted\nend\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 2)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 4)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 5)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 10)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 20)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 100)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 200)\n</cell>\n<text>\nExercise 2", " \
    \ # Write your code here\n  arr.sort!\n  arr.last(k).reverse!\n  return arr\n\
    end", "  maximum = arr.sort.reverse.first(k) # first k elements are maximum\n\
    \  maximum.each_cons(k + 1).each { |v| arr << v }\nend\n</cell>\n<text>\n13. Given\
    \ a binary tree and a sum, find if this tree has a root-to-leaf path such that\
    \ adding up all the values along the path equals the given sum.", "    # \u65B9\
    \u6CD5\u4E00\uFF1A\u9009\u62E9\u6392\u5E8F\uFF0C\u6BD4\u8F83\u5927\u7684\u4E00\
    \u90E8\u5206\uFF0C\u7136\u540E\u518D\u9009\u62E9\n    ans = []\n    i = 0\n  \
    \  while i < k and i < arr.length\n        if arr[i] > arr[i - 1]\n          \
    \  ans.push arr[i]\n            i += 1\n        else\n            i += 1\n   \
    \     end\n    end\n    \n    # \u65B9\u6CD5\u4E8C\uFF1A\u5229\u7528\u9012\u5F52\
    \u6CD5\uFF0C\u9009\u62E9\u5927\u7684\u90E8\u5206\uFF0C\u5E76\u4E14\u5C06\u5176\
    \u548C\u524D\u4E00\u6570\u7EC4\u7684\u548C\u4F5C\u4E3A\u7B2C\u4E00\u6B21\u8FDB\
    \u5165\u9012\u5F52\u51FD\u6570\u7684\u7ED3\u679C\n    # i = 1\n    # while i <\
    \ k and i < arr.length\n    #     if arr[i] > arr[i - 1]\n    #         ans.push\
    \ arr[i]\n    #         i += 1\n    #     else\n    #         i += 1\n    #  \
    \   end\n    # end\n    \n    # \u65B9\u6CD5\u4E09\uFF1A\u5229\u7528\u52A8\u6001\
    \u89C4\u5219\n    ans = []\n    i =  k + 1\n    while i < arr.length\n       \
    \ if arr[i] > arr[i - 1]\n            ans.push arr[i]\n            i += 1\n  \
    \      else\n            i += 1\n        end\n    end\n    \n    return ans\n\
    end", "    # Write your code here.\n    if k == 0 or len(arr) <= k\n        return\
    \ arr\n    max_length = 1\n    for i in 1..k\n        if arr[i] > arr[i-1]\n \
    \           max_length += 1\n            arr[i-1] = arr[i-1] + maximum[arr[i..-1],\
    \ k - max_length]\n            arr[i-1] = arr[i-1] + arr[i]\n            arr[max_length]\
    \ = arr[i-1]\n        elsif arr[i] > arr[i-1]\n            max_length += 1\n \
    \           arr[i-1] = arr[i-1] + maximum[arr[i..-1], k - max_length]\n      \
    \      arr[i-1] = arr[i-1] + arr[i]\n            arr[max_length] = arr[i-1]\n\
    \        end\n    end\n    arr\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI wanted\
    \ to see a solution to this problem, so I did a solution in Ruby. It runs in about\
    \ 2 seconds for an array of length 15 on my computer.\n<code>\nrequire 'time'",
  "  # write your code here\nend", "  return arr \nend", "  max_len = k\n  max_val\
    \ = arr[0]\n  max_idx = 0\n  min_val = arr[0]\n  min_idx = 0\n  for i in 1...k\n\
    \    if arr[i] > max_val\n      max_val = arr[i]\n      max_idx = i\n    elsif\
    \ arr[i] < min_val\n      min_val = arr[i]\n      min_idx = i\n    end\n  end\n\
    \  max_val = (max_val + max_val) / 2\n  max_idx = max_idx % k\n  max_idx = k -\
    \ max_idx\n  max_val = arr[max_idx]\n  max_idx = max_idx % k\n  return [max_val,\
    \ max_idx]\nend", "    maximums = []\n    arr.sort.reverse \n    return maximums\n\
    end", "    # Your code here\n    max = -1\n    if k == 0 or k == len(arr):\n \
    \       return arr\n    else:\n        for i in range(0,k-1):\n            curr\
    \ = 0\n            for j in range(0,k-1):\n                if j == i:\n      \
    \              curr = arr[j]\n                elif j > i and arr[j] > arr[j+1]:\n\
    \                    curr = arr[j]\n                elif j > i and arr[j] < arr[j+1]:\n\
    \                    curr = arr[j+1]\n            max = max(max,curr)\n    return\
    \ max", "    # Write your code here\n    \n    return arr\n    ", "    max = nil\n\
    \    arr.each do |i|\n        if i == max.last || i >  max.last\n            max\
    \ = i if k == i\n        end\n    end\n    return max\nend", "  result = Array.new(k+1)\n\
    \  max_idx = -1\n  arr.each_with_index do |i, idx|\n    i <=> max_idx <=> idx\
    \ if idx < k || idx > k\n    if i < 0\n      result[max_idx] << i\n      max_idx\
    \ = i\n    elsif i > 0 \n      max_idx = idx\n    end\n  end\n  result.compact!\n\
    \  result\nend", "  arr.sort!\n  (arr.length > k) ? arr : arr.slice(-k)\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis answer is too slow. Use `arr.sort_by\
    \ { |x| -x }[-k..-1]` instead.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\narr\
    \ = [1,2,3,4,5,6,7,8,9,10]\narr.sort![-6,-5,-4,-3,-2,-1,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\nThis is actually the most\
    \ efficient way to do it in Ruby as of June 2019.\n<code>\narray = [1,2,3]\narray.sort_by\
    \ { |x| -x }[-3..-1]\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI see this was mentioned\
    \ elsewhere but this is what I ended up using. It avoids sorting the array and\
    \ instead sorts its internal array.\n<code>", end, "    # write your code here\n\
    \  \n    length = arr.length\n    if k < length\n      sorted = []\n      maximum\
    \ = [-1000, 1000]\n      for i in arr\n        if i > maximum[1]\n          maximum\
    \ = [i, i]\n        else if i < maximum[1]\n          maximum = [maximum[0], i]\n\
    \        if i == maximum[1]\n          sorted.push i\n      sorted.push maximum[0]\n\
    \    end\n    return sorted\n  end\nend\n</code>\n<|/ a tags=ruby,algorithm,sorting,arrays,ruby-on-rails\
    \ dscore=0 |>\n<| c |>\nCould you explain how this works? How does the `maximum`\
    \ function work?\n<|/ c |>\n<| c |>\nHow does this sort the array in the way OP\
    \ wants? I mean, it seems to return the maximum element first (i.e. `[1,4,5,3]`).\
    \ How do you know which element that is?\n<|/ c |>\n<| c |>\nSorry I misread the\
    \ question I guess. I've just updated my answer\n<|/ c |>\n<| a |>\nA possible\
    \ solution:\n<code>", "  max_array = []\n  max_count = 0\n  for x in arr\n   \
    \ if x > max_count\n      max_array = [x]\n      max_count = 1\n    else if x\
    \ == max_count\n      max_array << x\n      max_count += 1\n    else\n      max_count\
    \ = 0\n      max_array << x\n      max_count = 1\n  end\n  max_array\nend", " \
    \   arr_size, max_size = arr.size, 0\n    while max_size < k\n        max_size\
    \ += 1\n    end\n    max = arr[0]\n    arr_size = 1\n    max_size = 1\n    arr.each\
    \ do |x|\n        max_size += 1\n        if x > max\n            max = x\n   \
    \     end\n    end\n    arr_size = max_size\n    max = arr[0]\n    arr_size =\
    \ 1\n    max_size = 1\n    arr.each do |x|\n        max_size += 1\n        if\
    \ x > max\n            max = x\n        end\n    end\n    return arr\nend", " \
    \   max = arr[0]\n    largest = []", "  return if k <= 0 || k >= arr.length ||\
    \ arr.nil?\n  maximum = arr[k] if arr.length > k\n  arr.each do |num|\n    maximum\
    \ = num if num > maximum\n  end\n  return maximum\nend", "    arr.sort!\n    arr.length\
    \ == k ? arr : arr[0 .. k-1]\nend", "    # Write your code here.\n    arr_sorted_list\
    \ = arr.sort.reverse\n    arr_sorted_list.first(k).reverse\n    return arr_sorted_list\n\
    end", "  return arr[k-1] if k == arr.length || k < 1 || k > arr.length ? nil :\
    \ arr.max_by { |i| i-arr[k-1] } << arr[k-1]\nend", "    arr.sort!\n    i = 0\n\
    \    n = arr.length\n    while i < k\n        i +=1\n        n = arr.length\n\
    \    end\n    arr\nend\n</cell>\n<code language=julia-1.6>\nmaximum(arr,1)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,2)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,3)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,4)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,5)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,6)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,7)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,8)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,9)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,10)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,11)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,12)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,13)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,14)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,15)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,16)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,17)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,18)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,19)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,20)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,21)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,22)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,23)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,24)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,25)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,26)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,27)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,28)\n</cell>\n\
    <code language=julia-1.6>\nmaximum(arr,29)\n</cell>\n<code language=julia-1.6>\n\
    maximum(arr,30)\n</cell>\n<code language=julia-1.6>\nmaximum(arr,31)\n</cell>\n\
    <code language=julia-1.6>", "    p =  (arr.max / k).ceil\n    p > 1 ? arr.sort!\
    \ { |x,y| (p > 0 ? x - y : y) } : p - 1\n    return arr[0..(p - 1)]\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,ruby-on-rails,algorithm,ruby-on-rails-4 dscore=2\
    \ |>\nIf you don't care about memory usage, you could use slice:\n<code>\na =\
    \ [1,2,3,4,5,6,7,8,9,10]\nk = 2", "  max_elements = []\n  max_count = 0\n  if\
    \ arr.empty? || k <= 0\n    return\n  end\n  arr.sort.reverse\n  for i in 0...k\n\
    \    if arr[i] > max_count\n      max_count = arr[i]\n      max_elements = i\n\
    \    end\n  end\n  return arr[max_elements...k]\nend", "  m = Math.max(arr[0],\
    \ arr[1])\n  for i in 2..k\n    m = Math.max(m, Math.max(arr[i], arr[i-1]))\n\
    \  end\n  return [m, arr[1..k]]\nend", "    # Write your code here\n    largest\
    \ = []\n    largest.push(arr[0])\n    count = 0\n    while count != k\n      \
    \  largest.push(arr[largest.length - 1])\n        count = count + 1\n    end",
  "    sorted = []\n    i = 0\n    \n    # Sort the array arr\n    while i < k\n \
    \       element = arr[i]\n        max_element = element", "    \n    # write your\
    \ code here\n    max_list = arr\n    for num in arr\n        if num < max_list[-k]\n\
    \            max_list[-k] = num\n    return max_list", "  arr_sorted = arr\n \
    \ arr_sorted = arr_sorted.sort\n  maximum = arr_sorted\n  maximum = maximum.slice(0,k)\n\
    \  return maximum\nend", "    # write your code here\n    if k > len(arr) or k\
    \ == 0 or k > len(arr):\n        return [arr[0]]\n    # find max of subarray\n\
    \    largest = arr[0]\n    for i in range(1,len(arr)):\n        if arr[i] > largest:\n\
    \            largest = arr[i]\n    # find k largest subarray\n    sub_largest\
    \ = largest\n    for i in range(1,k):\n        sub_largest = max([arr[i*i:i*(i+1)]\
    \ for i in range(0,len(arr)//i)])\n        sub_largest = sub_largest if sub_largest\
    \ != arr[0] else largest\n    \n    # add it to the list\n    lst = arr[0:k]\n\
    \    lst.append(sub_largest)\n    return lst", "    max = arr[0]\n    for i in\
    \ 1..k\n        if arr[i] > max\n            max = arr[i]\n        end\n    end\n\
    \    max\nend", "  \n  sorted = []", "    # Write your code here\n    maximum\
    \ = arr.clone\n    maximum.sort!\n    maximum.slice!(k,k+1).each do |num|\n  \
    \      arr[num] = arr.pop\n    end\n    arr\nend\n</code>\n<|/ a dscore=2 tags=ruby,sorting,algorithm\
    \ |>\n<| c |>\nNice! This is better than my solution. I think it can be optimized\
    \ a bit, though. :)\n<|/ c |>\n<| a tags=ruby,sorting,algorithm dscore=1 |>\n\
    To make it slightly faster, you can keep track of the max elements you have seen\
    \ and only change them if they exceed the previous ones, rather than always adding\
    \ them to the list.\n<|/ a |>\n<| c |>\nCan you give an example? I don't know\
    \ what you mean.\n<|/ c |>\n<| c |>\nKeep a variable max. Now when you get a new\
    \ element check if it > max, and if so, update max. This will make it much faster\
    \ if there are several maxes in the array.\n<|/ c |>\n<| a tags=ruby,sorting,algorithm\
    \ |>\nHere is a solution that has O(n log n) time complexity (for the sorting\
    \ algorithm). One can find the maximum element with O(n) time complexity, once\
    \ it has been found.\n<code>", "  max_arr = arr.dup\n  max_arr.sort!\n  max_arr\
    \ >> k\nend\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 2)\n</cell>\n<code\
    \ language=julia-1.5>\nmaximum(arr, 3)\n</cell>\n<code language=julia-1.5>\nmaximum(arr,\
    \ 6)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 10)\n</cell>\n<text>\n\
    Write a function to compute the sum of an array of integers.", "    arr.sort!\n\
    \    result = []\n    (k == 0) ? (return result) : (k until arr.size).each do\
    \ |i|\n        result << arr[i] if i > k\n    end\n    return result\nend", " \
    \   # Write your code here.\n    max = arr.max\n    arr.reduce { |a, b| a > b\
    \ ? a : b }\n    arr.sort { |a, b| a <=> b }\n    arr[0..k-1]\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nthank you so much. I've tried the solution on the\
    \ leetcode site and it is working just fine. I'm still a little confused about\
    \ how exactly the reduce method works. Are there any other ways to do it?\n<|/\
    \ c |>\n<| c |>\nI think this solution would be much slower than others proposed\
    \ so far.\n<|/ c |>\n<| c |>\n`arr.sort { |a, b| b <=> a }` (this orders elements\
    \ from max to min)\n<|/ c |>\n<| c |>\nOh yes, thanks for pointing it out, I've\
    \ edited my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    # write your code\
    \ here\n    if arr.empty?\n       arr\n    end\n    \n    arr.sort!\n    \n  \
    \  if k <= 0\n       arr\n    end\n    \n    arr.slice!(0, k)\nend\n</cell>\n\
    <cell>\narr = [1, 8, 7, 10, 5, 3, 6, 4, 2, 9, 11, 12]\nmaximum(arr, 10)\n</cell>\n\
    <cell>\narr = [1, 8, 7, 10, 5, 3, 6, 4, 2, 9, 11, 12]\nmaximum(arr, 7)\n</cell>\n\
    <cell>\narr = [1, 8, 7, 10, 5, 3, 6, 4, 2, 9, 11, 12]\nmaximum(arr, 3)\n</cell>\n\
    <cell>\narr = [1, 8, 7, 10, 5, 3, 6, 4, 2, 9, 11, 12]\nmaximum(arr, 9)\n</cell>\n\
    <text>\nFind Median in Array", "  # Write your code here\n  max_arr = arr\n  max_arr.sort!\n\
    \  max_arr.take(k).reverse!\n  return max_arr\nend", "  arr = arr.sort\n  return\
    \ arr[0..k-1]\nend", "    arr.sort!\n    maxlist = []\n    i = 0\n    while( i\
    \ < k )\n        if ( arr[i] > arr[i+1] )\n            maxlist << arr[i+1]\n \
    \           i += 1\n        else\n            i += 1\n            maxlist << arr[i]\n\
    \    end\n    maxlist\nend", "  maximums = []\n  while arr.length > k\n    maximums\
    \ << arr.shift\n  end\n  maximums << arr.shift\n  return maximums\nend", "  #\
    \ write your code here\n  max = [-1]*k\n  arr.sort.each do |x|\n    if(max[x]\
    \ == -1)\n      max[x] = x\n    elsif(x>max[x])\n      max[x] = x\n    end\n \
    \ end\n  max\nend", "    # Write your code here.\n    h = arr.max\n    maximums\
    \ = []\n    while k != 0 and k > 0:\n        if arr[k] < h:\n            h-=arr[k]\n\
    \            maximums = [h] + maximums\n        k -= 1\n    return maximums",
  "  arr.sort!\n  result = []\n  maximum_index = 0\n  for i in 0..k-1\n    result\
    \ << arr[i]\n    maximum_index += 1 while maximum_index > i && arr[i-1] > result[i-1]\n\
    \  end\n  result\nend", "    max = arr[0]\n    i = 0\n    while i < k and i <\
    \ arr.length\n        if arr[i] > max\n            max = arr[i]\n        i +=\
    \ 1\n    return arr[0, arr.length - k + 1]\nend", "    puts arr\n    maximums\
    \ = arr.dup\n    maximums.sort!\n    puts maximums\n    maximums.take(k)\nend",
  "  (0...k).reduce(:<=>){|max, i| max > arr[i] ? max : arr[i]}\nend", "    arr.sort!\n\
    \    if k == 1\n        return [arr]\n    arr1 = []\n    \n    i = k\n    while\
    \ (i <= arr.length) && (arr[i] < arr[k-1])\n        arr1 = arr1 + arr[i]\n   \
    \     i = i + 1\n    end\n    arr1 = arr1 + arr[k-1]\n    \n    return arr1 +\
    \ maximum(arr[0..i-1], k-1)\nend\n</code>\n<|/ a |>\n<| a |>\nThe simple solution\
    \ is :\n<code>", "  return arr.reduce([nil, *arr].min)\nend", "  # write your\
    \ code here\n  maximum = nil\n  arr.each do |x|\n    if maximum == nil or x >\
    \ maximum\n      maximum = x\n    end\n  end\n  maximum.times(k).unshift(arr[0])\n\
    end", "  max_num = arr[0]\n  max_idx = 1\n  for i in arr[k-1..-1]\n    if i >\
    \ max_num\n      max_num = i\n      max_idx = k-1\n  end\n  arr << max_num\n \
    \ k += 1\n  maximum(rest,k)\nend", "  arr.sort! \n  arr.take(k).sort!\n  return\
    \ arr\nend", "  result = []\n  arr_length = arr.length\n  for i in 0..k-1\n  \
    \  max_index = k-1\n    max_value = arr[max_index]\n    arr_index = 0\n    while\
    \ (arr_index < arr_length && max_value < arr[i..arr_length])\n      max_value\
    \ = arr[i..arr_length]\n      max_index = arr_index\n      arr_index += 1\n  \
    \  result << max_value\n  end\n  result.sort!\n  return result\nend", "  result\
    \ = arr.sort\n  result.delete_at(-k)\n  result\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nUsing Array#max:\n<code>\narr = [1, 2, 3, 4, 5]", "    \n    # write\
    \ your code here\n    arr.sort!\n    maximum = arr\n    \n    if k <= 0\n    \
    \    arr = maximum\n        return arr\n    end\n    \n    maximum[k] = maximum.last\n\
    \    maximum.delete(k - 1)\n    \n    return maximum\nend\n</cell>\n<cell>\nmaximum(arr,\
    \ 3)\n</cell>\n<text>\n\uC18C\uC218 \uCC3E\uAE30", "    len = arr.size\n    max\
    \ = []\n    max.push(arr[len-1])\n    (arr[0..k-1].max-1).times do\n        max.push(arr.pop)\n\
    \    end\n    max\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis code\
    \ will fail when `k > len`, which means the input array has duplicate values\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's another way.\n<code>", "    arr1 = []\n   \
    \ length = arr.length\n    for i in (0...length)\n        arr1 << arr[i]\n   \
    \ end\n    arr1.sort!\n    arr1.reverse\n    return arr1[0...k] \nend", "  arr.sort!\n\
    \  k <= arr[-1] and return arr[0...k]\n  arr.each do |i|\n    arr[i] = arr[i-1]\
    \ if arr[i-1] > i\n  end\n  arr.sort!\n  k <= arr[-1] and return arr[0...k]\n\
    end", "  max_arr = []\n  arr.each_with_index do |element, index|\n    if index\
    \ == k || element > max_arr[-1]\n      max_arr << element\n    else\n      max_arr\
    \ << max_arr.max\n    end\n  end\n  max_arr.sort!\n  return max_arr\nend\n</code>\n\
    <|/ a tags=arrays,sorting,ruby,algorithm dscore=0 |>\n<| c |>\nCan you elaborate\
    \ on `each_with_index`? I don't understand what you're saying about it being an\
    \ in-place operation.\n<|/ c |>\n<| c |>\nIt is in-place because you can only\
    \ return max_arr after sorting the array. sort! is in-place too since it mutates\
    \ the array but returns the sorted array.\n<|/ c |>\n<| c |>\nYes, but the line\
    \ `max_arr << max_arr.max` is an in-place operation.\n<|/ c |>\n<| c |>\nYes,\
    \ but that line is executed inside the loop and it is the one that actually mutates\
    \ the array so it is in-place. I am sorry I did not clarify that point\n<|/ c\
    \ |>\n<| c |>\n`each_with_index` is an in-place operation, it mutates the array,\
    \ and returns a new array containing the new values.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThis doesn't use sort! but it is easy to understand and easy to write.\n\
    <code>", "    arr1=arr.sort\n    i=k\n    arr=[]\n    while(i<arr.length)\n  \
    \      if(arr1[i]>arr1[i+1])\n            arr<<arr1[i]\n        else\n       \
    \     arr<<arr1[i+1]\n        i=i+1\n    arr\n    end\nend", "    # write your\
    \ code here\n    if k <= 0\n        return nil\n    \n    maximums = []\n    \n\
    \    arr.each_with_index do |x, index|\n        if index == k\n            maximums\
    \ << x\n        end\n        \n        if index >= k\n            maximums <<\
    \ x\n        end\n    end\n    \n    return maximums\nend\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 3)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 4)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 5)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 10)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 11)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, -1)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 100)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 1000)\n</cell>\n\
    <code language=julia-1.0>\nmaximum(arr, 1000)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 100000)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 100001)\n\
    </cell>\n<code language=julia-1.0>\nmaximum(arr, 1000000)\n</cell>\n<code language=julia-1.0>\n\
    maximum(arr, 10000000)\n</cell>\n<code language=julia-1.0>\nmaximum(arr, 100000000)\n\
    </cell>\n<text>\n\uBB38\uC81C 3", "    arr.sort!\n    max = (arr[k - 1].nil? ?\
    \ arr[0] : arr[k - 1].max).to_i\n    arr.delete_at(k)\n    arr.unshift(max)\n\
    \    return arr\nend", "    # Write your code here\n    size = arr.size\n    maximum\
    \ = arr[0]\n    max_size = 1\n    i = 0\n    while i < size\n        if arr[i]\
    \ > maximum\n            maximum = arr[i]\n            i = i + 1\n        else\n\
    \            i = i + 1\n        if i > k\n            max_size = i - k\n     \
    \       break\n    max = max_size\n    max_arr = arr[1..size]\n    return max_arr\n\
    end", "    # \u6700\u5927\u6570\u7684\u5217\u8868\n    maximum_list = []\n   \
    \ # \u4ECE arr \u5F00\u59CB\u5FAA\u73AF\uFF0C\u627E\u5230 k - 1 \u4E2A\u6700\u5927\
    \u6570\u7684\u7D22\u5F15\uFF0C\u5E76\u5C06\u8FD9 k - 1 \u4E2A\u6570\u653E\u5230\
    \u6700\u5927\u6570\u7684\u5217\u8868\u4E2D\n    # \u5373 arr \u7684\u7B2C k -\
    \ 1 \u4E2A\u6570\u7684\u4F4D\u7F6E\u653E\u5230 maximum_list\n    for i in (0 ...\
    \ k - 1)\n        maximum_list.push(arr[i])\n    # \u5BF9\u6700\u5927\u6570\u7684\
    \u5217\u8868\u8FDB\u884C\u6392\u5E8F\n    maximum_list.sort()\n    # \u8FD4\u56DE\
    \u6700\u5927\u6570\u7684\u5217\u8868\n    return maximum_list\nend", "  i = 0\n\
    \  max = -1000\n  while i < k\n    if arr[i] > max\n      max = arr[i]\n    i\
    \ += 1\n  end\n  k = 0\n  while k <= i\n    arr[k] = max\n    k += 1\n  end\n\
    \  arr\nend\n</cell>\n<code language=julia-1.4>\nmaximum(maximum(maximum(maximum(maximum([-1,2,-3,4,-5,-6,-7,-8]),\
    \ -9), -10), 11), 11)\n</cell>\n<text>\n\u6700\u957F\u9012\u589E\u5B50\u5E8F\u5217\
    \nGiven a non-negative integer num, find the length of the longest increasing\
    \ subsequence (LIS) of num.", "  result = []\n  for i in 0..(k-1)\n    result.push(arr.max)\n\
    \  end\n  result\nend", "    length = arr.length\n    max = -1\n    for i in 1...length\n\
    \        if arr[i] > max\n            max = arr[i]\n        end\n    end\n   \
    \ result =  Array.new(k)\n    result.pushmax!(max)\nend", " \n    # Get the max\
    \ index\n    max_idx = -1\n    max_num = 0\n \n    # For each value in the array\n\
    \    for e in arr\n \n        # Get the index of this value\n        curr_idx\
    \ = -1\n \n        # Search for the right index\n        for index in (0..k-1)\n\
    \            if arr[index] > arr[index]\n                curr_idx = index\n  \
    \              break\n \n        # If the current number is greater than the max,\
    \ then update\n        # the max index and max number\n        if e > max_num\n\
    \            max_num = e\n            max_idx = curr_idx\n \n    # Return the\
    \ maximum\n    return arr[max_idx]\nend\n</cell>\n<cell>\narr = [2, 12, 3, 6,\
    \ 43, 54, 56, 73, 78, 95, 345, 5343, 234]\nk = 4\nprint(maximum(arr, k))\n</cell>\n\
    <text>\nReturn an array arr of positive integers and a positive integer k. \n\
    Find a pair of numbers (i, j), where arr[i] < arr[j] and i <= j \nsuch that the\
    \ difference between i and j is minimized. The numbers \n(i, j) are in the range\
    \ [1, n]. Return the min number.", "    arr = arr.reverse if k < arr.size && k\
    \ > 0 \n    max = arr.max\n    res = []\n    res.push(max)\n    i = arr.size -\
    \ 1\n    while i >= 1\n        res.push(max) if arr[i] > max \n        i -= 1\n\
    \    return res.reverse if k < res.size && k > 0 \n    return res\nend\n</cell>\n\
    <cell>\narr = [7, 2, -3, 4]\nmaximum([1, 2, 3, 4], 3)\n</cell>\n<text>\nMaximum\
    \ Binary Search Tree", "  \n  max_num = arr[0]\n  max_index = 0\n  \n  for index\
    \ in range(1, k)\n    if arr[index] > max_num\n      max_num = arr[index]\n  \
    \    max_index = index\n  \n  arr.remove(max_num)\n  return arr\nend", "    arr.sort.reverse\n\
    \    return arr[0..k] #This line is not necessary for our solution\nend", "  \
    \  max_length = 0\n    max_length_k = 0\n    sorted = nil", "    # write your\
    \ code here\n    return arr\nend\n</cell>\n<code language=julia-1.5>\nmaximum(arr,\
    \ 1)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 2)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 3)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 4)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 5)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 6)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 7)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 8)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 9)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 10)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 11)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 12)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 13)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 14)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 15)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 16)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 17)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 18)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 19)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 20)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 21)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 22)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 23)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 24)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 25)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 26)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 27)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 28)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 29)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 30)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 31)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 32)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 33)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 34)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 35)\n</cell", "  sorted = []\n  max_index\
    \ = -1\n  arr.each do |num|\n    index = -1\n    loop do\n      index += 1\n \
    \     if sorted[index] > num and index < k\n        break\n      elsif index >=\
    \ k\n        sorted = sorted + [num]\n        break\n      end\n    end\n  end\n\
    \  return sorted\nend", "    \n    # Your code here\n    \n    return arr", " \
    \   arr.sort!\n    max_length = arr.length\n    if k > max_length \n        max_length\
    \ = k\n    end\n    arr[0..max_length].max\nend", "  # @return a list of length\
    \ k with the maximum k numbers in arr\n  # @return nil if k is out of bounds\n\
    \  result = []\n  for i in 1..k do\n    result.push( arr[i-1] )\n  end\n  return\
    \ result.max( &:to_i ) if result.size < k && k >= 0\n  result.push( arr[-k-1]\
    \ )\n  return result.max( &:to_i ) if result.size > k\nend", "    arr.sort!\n\
    \    if arr.size == k\n        return arr\n    else\n        maximum(k - arr.size,\
    \ arr)\n    end\nend", "  if k == 0 or k > arr.length\n    return []\n  else\n\
    \    max_k = nil\n    arr.each do |x|\n      if x > max_k\n        max_k = x\n\
    \      end\n    end\n    maximum = (arr - [max_k]).sort[1..k]\n  end\nend", " \
    \   arr.sort!\n    max_length = (arr.length * k) - (arr.length - k)\n    result\
    \ = arr[0, max_length]\n    for i in 1..k\n        result -= arr[i, max_length-i]\n\
    \    end\n    result\nend", "    \n    l = arr.length\n    arr.sort!\n    \n \
    \   if k > l\n        k = l\n    end\n    \n    return arr[0...k]\nend", "   \
    \ answer = []\n    i = 0\n    while i < k\n        if arr[i] > arr[i+1]\n    \
    \        arr[i] > arr[i+1]\n            answer << arr[i]\n        i += 1\n   \
    \ answer << arr[k]\n    answer.sort!\n    answer\nend", "  # Write your code here\n\
    \  a = []\n  for i in range(k-1):\n    max = -1\n    for j in range(len(arr)):\n\
    \      if max < arr[j]:\n        max = arr[j]\n    a = a + [max]\n  return a",
  "  max_arr = arr.max\n  sorted_arr = (0...arr.length).select {|x| x < max_arr}\n\
    \  return(sorted_arr[k..k+1])\nend", "    # Write your code here\n    maximum\
    \ = []\n    for i in arr\n        j = i + 1\n        while (j < arr.length) &&\
    \ (arr[j] <= arr[i])\n            j += 1\n        if (j - i > k - 1)\n       \
    \     maximum = [arr[j - 1]]\n        else\n            maximum = [arr[j - 1],\
    \ arr[j]]\n        break\n    return maximum\nend\n</cell>\n<cell>\n@test maximum([2,\
    \ 3, 4, 1, 5], 1) == [3, 5]\n</cell>\n<cell>\n@test maximum([2, 3, 4, 1, 5], 2)\
    \ == [3, 4, 5]\n</cell>\n<cell>\n@test maximum([2, 3, 4, 1, 5], 3) == [3, 4, 1,\
    \ 5]\n</cell>\n<cell>\n@test maximum([2, 3, 4, 1, 5], 4) == [3, 4, 1, 5]\n</cell>\n\
    <cell>\n@test maximum([2, 3, 4, 1, 5], 5) == [3, 4, 1, 5]\n</cell>\n<cell>\n@test\
    \ maximum([1, 2, 3, 4, 5], 2) == [1, 3, 5]\n</cell>\n<cell>\n@test maximum([1,\
    \ 2, 3, 4, 5], 5) == [1, 3, 5]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4,\
    \ 5, 6, 7], 0) == [-1]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7],\
    \ 1) == [1, 3, 5]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 2)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 3)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 4)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 5)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 6)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 7)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 8)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 9)\
    \ == [4, 5, 6, 7]\n</cell>\n<cell>\n@test maximum([-1, 2, -3, -4, 5, 6, 7], 10)\
    \ == [4, 5, 6, 7]\n</", "  # Write your code here\n  arr.sort!\n  arr.length>=k?(arr[k..-1]):[]\n\
    end\n</cell>\n<cell>", "  sorted = false\n  max = -1000\n  while !sorted\n   \
    \ if k == 0\n      sorted = true\n    else\n      if arr[k-1] > max\n        max\
    \ = arr[k-1]\n      end\n    end\n    k -= 1\n  end\n  max.times do |i|\n    arr[i]\
    \ = arr[i] + max\n  end\n  arr\nend\n</code>\nThis is my solution to problem #1.\
    \ But it's very slow because it's O(n^2). Can you guys help me to improve my solution?\
    \ Thank you so much!\n<|/ q dscore=3 tags=algorithm,sorting,ruby,arrays |>\n<|\
    \ c |>\nHi David! I edited the post and post my code. Thanks!\n<|/ c |>\n<| a\
    \ dscore=3 tags=algorithm,sorting,ruby,arrays |>\nThe first thing to do is to\
    \ get rid of the extra array copy in your code.\n<code>", "  arr.sort!\n  return\
    \ arr[0..(k-1)]\nend", "  arr = arr.sort\n  return arr.last(k) \nend", "  max\
    \ = []\n  i = 0\n  while i < k\n    if arr[i] > max[i] \n      max = arr\n   \
    \   i = 1\n    else \n      i += 1\n  end\n  return max\nend\n</cell>\n<cell>\n\
    maximum(arr, 3)\n</cell>\n<cell>\narr\n</cell>\n<text>\nGiven a binary search\
    \ tree and a node in that tree, design a method to insert a node in the given\
    \ tree such that the tree remains a binary search tree (BST).\nExample:\nGiven\
    \ binary search tree: [1,null,2,3],\n      Node to be inserted: 4,\n      Binary\
    \ tree: [1,null,2,3,4,null,null,5]\nAfter the insertion, the binary tree should\
    \ be [1,2,3,4,5,null,null,null].", "  max = [0 for _ in range(k)]\n  max[0] =\
    \ arr[0]\n  max[1] = arr[0]\n  for i in 1..k-1\n    if arr[i] > max[i - 1]\n \
    \     max[i] = arr[i]\n      max[i - 1]\n    else if arr[i] < max[i - 1]\n   \
    \   max[i] = arr[i]\n      max[i - 1]\n    else\n      max[i] = arr[i]\n     \
    \ max[i] = max[i - 1]\n  end\n  return max\nend", "  arr = arr.reverse # reverse\
    \ the array\n  max = 0\n  for i in (0..k-1)\n    if arr[i] > max\n      max =\
    \ arr[i]\n    end\n  end\n  arr.reverse!\n  return arr\nend", "    max = arr[0]\n\
    \    temp = []\n    i = 0\n    while i < k\n        if arr[i] > max\n        \
    \    max = arr[i]\n            temp = []\n            temp << max\n        else\
    \ \n            temp << arr[i]\n        i += 1\n    return temp\nend", "  sorted\
    \ = []\n  i = 0\n  while i < k\n    j = i\n    while j < k and arr[j] < arr[j]\n\
    \      j += 1\n    if arr[i] > arr[j]\n      sorted.push arr[i]\n      i += 1\n\
    \    else\n      sorted.push arr[j]\n      j += 1\n    end\n  end\n  sorted.push\
    \ arr[k]\n  return sorted\nend", "  arr.sort!\n  p arr\n  p k\n  return arr[-k..-1]\n\
    end", "    # write your code here\n    max = arr[0]\n    i = 1\n    while i <\
    \ k\n        max = arr[i] if arr[i] > max else max\n        i += 1\n    arr.shift\
    \ if k <= arr.length\n    arr << max\n    return arr\n    ", "  arr = arr.reverse\
    \ if k > 0\n  max = arr.shift(k)\n  return arr if k > 0 else  [0, max]\nend",
  "end\n</cell>\n<cell>\narr = [1, 10, 100, -1000, -10, 50, 20, -7, 8]\nk = 3\nmaximum(arr,\
    \ k)\n</cell>\n<cell>", "  max_count = 0\n  max_arr = []", "  # write your code\
    \ here\n  max_list = []\n  max_value = arr[0]\n  max_list.push([max_value])\n\
    \  for i in 1..k\n    if arr[i] > max_value\n      max_value = arr[i]\n      max_list.push([max_value])\n\
    \    else \n      max_list.push([arr[i]])\n  end\n  max_list\nend", "\tresult\
    \ = Array.new(k) \n\tarr.each do |num|\n\t\tindex = result \n\t\twhile index.length\
    \ < k\n\t\t\tindex = index + [num]\n\t\tend\n\t\tresult << num if num > result[-k]\n\
    \tend\n\treturn result\nend", "    sorted = []\n    sorted = maximumArray(arr)\n\
    \    \n    return sorted[k]\nend\n</cell>\n<code language=julia-0.4>\nmaximum(arr,\
    \ 2)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 3)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 4)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 5)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 6)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 7)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 8)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 9)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 10)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 11)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 12)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 13)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 14)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 15)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 16)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 17)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 18)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 19)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 20)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 21)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 22)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 23)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 24)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 25)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 26)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 27)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 28)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 29)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 30)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 31)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 32)\n</cell>\n\
    <code language=julia-0.4>\nmaximum(arr, 33)\n</cell>\n<code language=julia-0.4>\n\
    maximum(arr, 34)\n</cell>\n<code language=julia-0.4>\nmaximum(arr, 35)\n</cell>\n\
    <code language=juli", "    return sorting(arr, k)\nend", "    # write your code\
    \ here\n    l = [0]\n    l.push([arr.max]) \n    while l[-1][0] < arr.min\n  \
    \      l[-1][0] = l[-1][0] + arr.min\n        l.push([l[-1][0]])\n    max = l[-1][0]\n\
    \    i = 1\n    l = l[0..(k-1)]\n    l.reverse\n    while i < k\n        if l[i].min\
    \ > max\n            max = l[i].min\n        i += 1\n    return [max] + l\nend",
  "  arr.sort!\n  arr.take(k).reverse\nend", "    max = nil\n    i = 0\n    while(i\
    \ < k)\n        if max < arr[i]\n            max = arr[i]\n        end\n     \
    \   i += 1\n    end\n    return max\nend", "    # write your code here\n    if\
    \ k > arr.length\n        k = arr.length\n    end", "    # Write your code here.\n\
    \    ans = []\n    arr.sort.reverse_each{|i| ans << i }\n    return ans\nend",
  "    nums = arr[k..-1]\n    max = nums.max\n    arr.clear\n    arr.push(*nums.min..max)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution works with one test case\
    \ (which is very similar to the one in the question).\n<|/ c |>\n<| a tags=ruby,sorting,algorithm\
    \ |>\nYou can do it in O(n) time using a single pass through the array.\nFor each\
    \ element in the array you need to find the maximum index j such that arr[j] >=\
    \ arr[i]. \nThe index j will then be the index of the maximum element in arr[j..i].\
    \ Now you can just sort the numbers in the range between j and i using the same\
    \ sorting you already have.\n<|/ a dscore=0 |>\n<| c |>\n`j` will always be 0\
    \ or 1 since `j` is always less than `i`.\n<|/ c |>\n<| c |>\nYou're right, thanks\
    \ for pointing that out.\n<|/ c |>\n<| a |>\nHere's my take on the problem using\
    \ a single pass through the array and O(n) space. \nI used the approach of sorting\
    \ a subarray of size k with the elements of the array from index j to i. \n<code>",
  "  max = arr.dup\n  \n  count.times do |i|\n    max << arr[i] if arr[i] > max[i]\n\
    \  end\n  \n  max.take(k).sort\nend", "    # Write your code here.\n    arr.sort!\n\
    \    ans = arr.take(k)\n    return ans\nend", "    max = arr.sort\n    max <<\
    \ k-1\n    max.each {|i| arr << i}\n    return arr\nend", "    arr = arr if arr\
    \ <= 1000 else arr.to_i\n    arr = arr.sort{|a,b| b <=> a}\n    arr << arr.pop\
    \ if k <= arr.length\n    arr[-k]\nend", "    # write your code here\n    maximum\
    \ = [0]*k\n    for i in arr\n        if i<maximum[k]\n           maximum[k] =\
    \ i\n    return maximum\nend\n</cell>\n<code language=julia-1.5>\nmaximum(arr,\
    \ 1)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 3)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 10)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 11)\n</cell>\n\
    <code language=julia-1.5>\nmaximum(arr, 999)\n</cell>\n<code language=julia-1.5>\n\
    maximum(arr, 1001)\n</cell>\n<code language=julia-1.5>\nmaximum(arr, 10)\n</cell>\n\
    <text>\nFind the median of an array", "    puts arr\n    puts k\n    \n    arr.sort_by!\
    \ {|x| x}\n    puts arr\nend", "    arr_sorted = []\n    arr.sort.each do |i|\n\
    \        if arr_sorted.length > k\n            arr_sorted = arr_sorted << i\n\
    \        else\n            if i < (arr_sorted[0] - arr_sorted[1])\n          \
    \      arr_sorted = arr_sorted << i\n            end\n        end\n    end\n \
    \   return arr_sorted\nend", "  return arr[0...k] \nend", "  if k >= arr.length\n\
    \    return []\n  res = []\n  for i in 0 .. (arr.length - k + 1)\n    if arr[i]\
    \ > arr[i + k]\n      res << arr[i + k]\n    else\n      res << arr[i]\n  end\n\
    \  return res\nend", "  max = []\n  n = arr.length\n  for i in 0..k-1\n    max\
    \ = arr[i].max\n    arr.delete_at(arr.index(i))\n    arr.push(max)\n  end\n  max\n\
    end", "    \n    # write your code here\n    \n    max_arr = []\n    for ele in\
    \ arr:\n        if ele not in max_arr:\n            max_arr.append(ele)\n    \
    \        if k > len(max_arr):\n                return max_arr\n    return max_arr\n\
    \    \n</cell>\n<cell>\narr = [1, 5, 10, 23, 100, 4, 3, 2]\nk = 3\nprint(maximum(arr,\
    \ k))\n</cell>\n<cell>", "    if k == 1 or k > arr.length\n        return [arr[0],\
    \ arr[0], arr[0]]\n    \n    maxArr = [arr[0]]\n    maxSum = [arr[0]]\n    \n\
    \    i = 1\n    while i <= arr.length\n        diff = arr[i] - arr[i-1]\n    \
    \    maxSum = [arr[i-1], arr[i] - arr[i-1]] + maxSum\n        if diff > k\n  \
    \          maxArr.unshift(maxSum[1])\n            diff -= k\n        else\n  \
    \          maxArr.unshift(maxSum[0])\n            diff += k\n        i += 1\n\
    \    \n    maxArr.push(arr[i])\n    maxSum.push(arr[i])\n    \n    return maxArr\n\
    end", "  return max_k_length(arr, k)\nend", "  max_val = []\n  i = 0\n  while(\
    \ i < k )\n    val = arr[i]\n    if val > max_val[-1]\n      max_val = [val]\n\
    \      i += 1\n    else\n      max_val.push(val)\n      i += 1\n  end\n  return\
    \ max_val\nend", "  k = (k*k).to_f\n  arr.each_with_index.sort.reverse \n  arr.each_with_index.select\
    \ { |x| x < k }.first(k-1)\nend", "  result = arr\n  until result.size != k\n\
    \    maximum = max(result)\n    result = result.map { |num| num > maximum ? num\
    \ : maximum }\n  end\n  result\nend", "  m = -999999999\n  \n  max_arr = [0 for\
    \ i in 0..k-1]\n  \n  for i in 0..k-1\n    max_arr[i] = max(arr[i], m)\n    m\
    \ = max_arr[i]\n  \n  return max_arr\nend", "  arr.sort\n  puts arr[0,k] if k\
    \ >= 0\n  puts arr[-1,k] if k <= arr.length\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nA more efficient way is to iterate through the array, storing the\
    \ highest value you come across. Then simply return the last k items. Of course,\
    \ this is still O(n), but in practice it's very fast.\n<|/ c |>\n<| c |>\n- I\
    \ agree that your solution is superior, but this isn't actually any less efficient\
    \ than your solution (because you're still sorting it). You're just doing less\
    \ work.\n<|/ c |>\n<| c |>\n- I agree, but in practice I've seen that even when\
    \ sorting isn't required the algorithm is still as fast as possible. Using a heap,\
    \ by contrast, does allow for better optimization, but I wouldn't call it more\
    \ efficient.\n<|/ c |>\n<| c |>\nThis would not work in general because sorting\
    \ is a n^2 algorithm. Your solution requires n sorts to sort n elements. This\
    \ is much worse than O(n*log(n)).\n<|/ c |>\n<| c |>\n- Yes, I see your point,\
    \ and I agree with you. But in practice this isn't the case (at least not in the\
    \ general case). When dealing with small arrays, sorting is much more expensive.\
    \ For larger ones, it's much better to iterate through than to use an algorithm\
    \ that requires sorting.\n<|/ c |>\n<| a dscore=4 |>\nThis is very easy to do\
    \ in Ruby with the Enumerable#max_by method, as long as your numbers are consecutive:\n\
    <code>\n(1..3).max_by(3)", "  max_arr = Array.new(k) \n  max_arr.push(arr[0])\n\
    \  \n  1.upto(k) {|i|\n    if arr[i] > max_arr[i]\n      max_arr[i] = arr[i]\n\
    \    end\n  }\n  max_arr\nend", "  maxArr = []\n  maxArrSize = k\n  while k >\
    \ 0 do\n    maxArr.push( arr.shift )\n    k -= 1\n  \n  while k > 0 do\n    maxArr.pop\n\
    \    maxArrSize -= 1\n  \n  while k > 0 do\n    maxArr.push arr.shift\n    k -=\
    \ 1\n  end\n  \n  return maxArr\nend", "    # write your code here\n    maximum\
    \ = arr[0]\n    for i in arr\n        maximum = i\n        break if maximum ==\
    \ k\n    \n    maximum.push[maximum]\n    \n    return maximum\nend", "    # Your\
    \ code here\n    maximum_list = Array.new\n    arr.each do |num|\n      if num\
    \ > maximum_list.length\n        maximum_list << num\n      else\n        if maximum_list.length\
    \ > k\n          maximum_list = maximum_list.delete_at(maximum_list.length)\n\
    \        else\n          maximum_list = maximum_list.delete_at(0)\n        end\n\
    \        maximum_list << num\n      end\n    end\n    return maximum_list\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThanks for the response! I believe this solution works\
    \ for the most part but I've got an additional question which I put at the bottom\
    \ of my original post. Would you be willing to help me out with a second question\
    \ if possible? Thanks again!\n<|/ c |>\n<| a dscore=1 tags=arrays,ruby,algorithm,sorting,max\
    \ |>\nAnother solution, using Enumerable#sort_by (doc):\n<code>", "  # Your code\
    \ here\n  maximum = arr.sort\n  p =0 \n  \n  \n  return maximum[k]\nend", "  \
    \  # Write your code here.\n    return arr.sort[-k, -1]\nend\n</code>\nTest:\n\
    <code>\narr = [-1, 5, -10, 100, 0, -2, 5, 9, -3, 1]\nk = 2\np maximum(arr, k)",
  "  max_arr = Array.new(k)\n  arr.each_with_index do |x, i|\n    max_arr[i] = x if\
    \ i > 0 && x < max_arr[i-1]\n  end\n  max_arr\nend", "    arr.sort! # Sort the\
    \ array\n    \n    # Return the max k values\n    arr[0, k]\nend", "  result =\
    \ [0] * k\n  i = 0\n  len = arr.length\n  \n  while i < k\n    max_num = -1\n\
    \    \n    for j in 0...len\n      if arr[j] > max_num\n        max_num = arr[j]\n\
    \      end\n    end\n    \n    result[i] = max_num\n    i += 1\n  end", "    arr1\
    \ = []\n    maximum = arr[0]\n    for i in arr\n        if arr[i] > maximum\n\
    \            maximum = arr[i]\n            arr1 = []\n        elsif arr[i] ==\
    \ maximum\n            arr1.push(maximum)\n        elsif arr[i] < maximum\n  \
    \          arr1.push(arr[i])\n        end\n    end\n    arr1.sort\n    if k ==\
    \ arr.length\n        return arr1\n    else\n        return arr1[0..k-1]\n   \
    \ end\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| a |>\nThis question can be\
    \ solved in two ways.", "  len = arr.length\n  arr.sort\n  result = arr.dup\n\
    \  max_num = result.shift\n  i = 0\n  while i < k\n    if result[i] > max_num\n\
    \      max_num = result[i]\n    end\n    i += 1\n  end\n  result\nend", "  puts\
    \ arr\n  puts k\nend\n</code>\n<|/ q dscore=1 tags=algorithm,ruby,sorting |>\n\
    <| c |>\nYour approach is not bad, but it is too slow with large arrays. You should\
    \ try implementing [binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm)\
    \ algorithm.\n<|/ c |>\n<| c |>\nThe algorithm for binary search is simple and\
    \ straightforward. I will post my code for the array in question.\n<|/ c |>\n\
    <| c |>\nI posted the code for the array in question.\n<|/ c |>\n<| c |>\nBinary\
    \ search is probably the way to go for this. But you should know that you can\
    \ save lots of time if the array is sorted in descending order.\n<|/ c |>\n<|\
    \ c |>\nThe array is already sorted in descending order. This is a small part\
    \ of an algorithm that I have already written.\n<|/ c |>\n<| a |>\nI think you're\
    \ using too much of the core Ruby library.  It's not clear what you're trying\
    \ to accomplish, exactly, so it's difficult to suggest a good approach.  But here's\
    \ some pseudocode for a couple things:\n<code>", "  arr = arr.sort\n  result =\
    \ []\n  for i in 0...k\n    result << arr[i]\n  end\n  return result\nend\n</code>\n\
    <|/ a tags=ruby dscore=0 |>\n<| c |>\nA simple `arr.reduce(0) { |t,x| t < x ?\
    \ t : x }` should be more efficient.\n<|/ c |>\n<| c |>\n: I agree, but that doesn't\
    \ address his question, which was about the time complexity of his solutions.\n\
    <|/ c |>\n<| a dscore=0 |>\nIt looks like, based on our discussion, your problem\
    \ could be solved with O(k log k) time complexity. Consider the following code:\n\
    <code>", "    arr = sort(arr)\n    if k <= 0 or k > arr.length\n        return\
    \ arr\n    arr_max, max_index = [], -1\n    arr_max.push(arr[0])\n    max_index\
    \ += 1\n    max = -1\n    arr.each do |i|\n        if i > max and i < arr_max.last\n\
    \            arr_max.pop\n            max_index -= 1\n            arr_max = sort(arr_max)\n\
    \            max = arr_max.last\n            arr_max.push(arr[i])\n          \
    \  max_index += 1\n        end\n        if i > max\n            arr_max = sort(arr_max)\n\
    \            arr_max.push(arr[i])\n            max_index += 1\n        end\n \
    \   end\n    arr_max.pop\n    return arr_max\nend", "  max_num = arr[0]\n  max_idx\
    \ = 1", "  sorted = sort(arr)\n  return sorted[k..-1]\nend", "  return arr.reverse_sort.take(k)\
    \ if k <= arr.length \n    arr.reverse_sort.take_while { |i| i < k }.\n    sort.reverse.take_while\
    \ { |i| i < k }.\n    concat(arr.reverse_sort.take(k + 1))\nend\n</code>\nThe\
    \ above code is pretty straightforward.\nIn order to understand what exactly happens,\
    \ I wrote the Ruby equivalent as well.\n<code>", "  max_elements = arr.dup\n \
    \ max_elements.sort!\n  max_elements[k..-1]\nend\n</code>\n<|/ a tags=ruby,algorithm,arrays\
    \ |>\n<| c |>\nYes. It does work. Just don't use it.\n<|/ c |>\n<| c |>\nNo, it's\
    \ not working in Ruby 1.9.3. The return value is `nil` instead of the array.\n\
    <|/ c |>\n<| c |>\nNot working in ruby 1.9.3 but works well on 1.8.7\n<|/ c |>\n\
    <| c |>\nYes, sorry. Didn't test it on 1.8.7 :)\n<|/ c |>\n<| c |>\nAs an alternative\
    \ to the last line you could do `[max_elements[k..-1]]`.\n<|/ c |>\n<| a dscore=4\
    \ |>\n<code>", "    # write your code here\n    return arr\nend", "    count =\
    \ 0\n    temp = []\n    \n    for i in arr\n        if i > 0\n            count\
    \ += 1\n            temp = [i]\n        else\n            if count >= k\n    \
    \            break\n            else\n                temp << i\n            \
    \    count += 1\n        end\n    end\n    \n    temp\nend", "  if arr.nil? or\
    \ k < 1 or not k.between?(1, arr.size)\n    arr\n  else\n    arr.sort! { |a, b|\
    \ a > b ? 1 : a < b ? -1 : 0 }\n    arr[0..k-1]\n  end\nend", "  max_arr = []\n\
    \  max_arr << arr[0]\n  k = 0\n  while k+1 < k\n    max_arr << arr[k+1]\n    k\
    \ += 1\n  end\n  return max_arr\nend\n</code>\n<|/ a dscore=2 tags=arrays,ruby,sorting\
    \ |>\n<| c |>\nI see that it's been quite a while since I've seen this question\
    \ but if you're still looking for the answer, the problem with this is that it\
    \ doesn't take advantage of the sorted nature of the array as mentioned by. The\
    \ problem is that this algorithm is O(nk) while sorting only takes O(nlgn). Which\
    \ is why I recommend taking a look at my answer for this question.\n<|/ c |>\n\
    <| c |>\nSure, i didn't say the best algorithm, i say the best complexity, i don't\
    \ see any reason for it to not take advantage of the sorted nature of the array\
    \ (i mean it has to traverse it twice)\n<|/ c |>\n<| c |>\nYes, but i also think\
    \ it's O(nk). To see this, think of what happens in the while loop in ruby; when\
    \ you do `arr[0]` you get an element, but when you do `arr[k+1]` you get the next\
    \ element; both are O(n) and if you had n elements in the array then `k` would\
    \ be O(n). Therefore it's O(nk). When you do `max_arr << arr[k+1]` you do it in\
    \ O(n) so it's the same as doing `max_arr.push`. However, `push` is O(nlgn) so\
    \ in overall it's O(nlgn)\n<|/ c |>\n<| c |>\nYes, but if you look at the question\
    \ carefully, the OP is asking for a sorted list with maximum k elements. I believe\
    \ my solution is the best algorithm for this question\n<|/ c |>\n<| c |>\nOh I\
    \ see you mean that i didn't see your solution; I agree with you that your solution\
    \ has better complexity, but it's also O(nk), I still think it's O(nlgn)\n<|/\
    \ c |>\n<| a |>\nThis answer is a bit late but it's what i would have done. I\
    \ would suggest using an insertion sort and keep track of the smallest element\
    \ encountered so far and use that to determine if the current element should be\
    \ added or not. \n<code>", "  return arr.sort.reverse[k..-1]\nend", "    # write\
    \ your code here\n    arr.sort!\n    arr.each_cons(k).to_a\nend", "  # Write your\
    \ code here.\n  return sorted(arr, reverse = True)[:k]\nend\n</code>\n<|/ a tags=algorithm,ruby,arrays\
    \ |>\n<| c |>\nI ran this in irb, but got an output of `[1,2,3,4,5,6,7,8,9,10]`\
    \ when run from the command line and `nil` when run from within the method `maximum`.\
    \ What is happening here?\n<|/ c |>\n<| c |>\n, have you seen the output of `[1,2,3,4,5,6,7,8,9,10]`\
    \ ? The `return` statement in method `maximum` returns `nil` and doesn't return\
    \ `[1,2,3,4,5,6,7,8,9,10]`. The method returns `nil` because there are no more\
    \ items to return so there is no point of continuing. Try calling `maximum` with\
    \ `k = 1` you will see the result.\n<|/ c |>\n<| c |>\nOh, I see, I was thinking\
    \ you were calling the method `maximum` without assigning it to a variable. Sorry,\
    \ I misunderstood.\n<|/ c |>\n<| a tags=algorithm,ruby,arrays dscore=3 |>\nThe\
    \ simplest answer would be to sort the array and slice it until the number of\
    \ items you want is reached. \n<code>", "    max = arr[0]\n    for i in arr\n\
    \        if i > max\n            max = i\n    end\n    maxs = Array.new(k+1)\n\
    \    maxs[k] = max\n    return maxs\nend\n</code>\n<|/ a |>\n<| c |>\nOh yeah,\
    \ I forgot about the `k` parameter. Updated my answer\n<|/ c |>\n<| c |>\nYou\
    \ don't need the argument `k` anymore. Just `return arr.sort`. Also, `Array` is\
    \ overkill and should be avoided in favor of simple `[]`.\n<|/ c |>\n<| c |>\n\
    Hi, I ran your codes in ruby irb. `return arr.sort` worked for me but `return\
    \ arr.sort!` didn't work. Could you help me?\n<|/ c |>\n<| c |>\nHi, sorry for\
    \ the late response. I'm still new to ruby and just trying to learn. Thanks for\
    \ your help!\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  arr.sort\n  arr[k-1]\n\
    end", "  \n  # create an empty array\n  max_numbers = Array.new(k) # => []\n \
    \ \n  # iterate through the array\n  for i in 0...arr.length-1\n    \n    # compare\
    \ the current number with every other number in the array\n    curr_index = arr.index(arr[i])\n\
    \    other_numbers = arr.drop(curr_index)\n    \n    # add current number to max\
    \ numbers list\n    unless other_numbers.nil? || other_numbers.length < k\n  \
    \    max_numbers.push(other_numbers.max)\n    end\n  end\n  \n  return max_numbers\n\
    end", "    max_length = 1\n    max_list = []\n    max_length = k\n    for i in\
    \ range(k):\n        if arr[i] > arr[i-1]:\n            arr[i], arr[i-1] = arr[i-1],\
    \ arr[i]\n            arr[i], arr[i-1] = arr[i-1], arr[i]\n            max_list.insert(0,arr[i-1])\n\
    \            max_list.insert(0,arr[i])\n        else:\n            max_list.append(arr[i])\n\
    \    max_length = k\n    return max_list\n    ", "    if k <= 0\n        return\
    \ []\n    return arr.sort_by(&:to_i).take_while{|x| x < k}.to_a\nend", "    if\
    \ k > length(arr) || k == 0 || k > length(arr)\n        return nil\n    end\n\
    \    i = 0\n    arr = [arr[i] for i in range(k)]\n    sorted = arr.sort\n    return\
    \ sorted\nend", "    arr.sort!\n    arr.size\n    arr.slice!(0, k)\nend\n</code>\n\
    <|/ a dscore=3 tags=ruby |>\n<| c |>\nYes, this was what I was looking for. Thanks\
    \ for the help and explaining why this is what it is.\n<|/ c |>\n<| a dscore=3\
    \ |>\nThe only ruby method that I am aware of for array \"compression\" (aka grouping\
    \ consecutive items with the same key) is Array#group_by, but it doesn't take\
    \ into account negative values and it also requires that you specify the key for\
    \ grouping.\n<code>", "  max_length = arr.length\n  sorted_arr = arr[0...k-1].max_by(&:length).reverse\n\
    \  max_count = 0\n  sorted_arr.each do |num|\n    if num.length > max_count\n\
    \      max_count = num.length\n    end\n  end\n  sorted_arr[0...k-1] + arr[0...k-1][0...max_count]\n\
    end\n</code>\n<|/ a dscore=0 tags=ruby,sorting,arrays |>\n<| a tags=ruby,sorting,arrays\
    \ |>\nHere's a slightly different approach, without using any extra memory:\n\
    <code>", "    arr.sort! # O(n log n)\n    res = []\n    while k <= arr.length\n\
    \        res << arr[0...k-1]\n        k = k - 1\n    end\n    res << arr[0...k]\n\
    \    return res\nend", "  result = []\n  i = 0\n  while i < k\n    max = arr[i]\n\
    \    i += 1\n    while i < k && max < arr[i]\n      max = arr[i]\n      i += 1\n\
    \    result.push max\n  end\n  result\nend", "    # \u6700\u5927\u7684\u6570\u7684\
    \u6570\u7EC4\n    max = 0\n    # \u4ECE arr[0] \u5F00\u59CB\u904D\u5386\u6570\u7EC4\
    \uFF0C\u627E\u5230\u6700\u5927\u7684\u6570\n    max = arr[0]\n    # \u7B2C k \u4E2A\
    \u6570\u7684\u6570\u7EC4\n    maxArr = arr[k-1]", "  arr.sort!\n  result = []\n\
    \  for i in (1..k)\n    if arr[i-1] < arr[i]\n      result.push arr[i-1]\n   \
    \ else\n      result.push arr[i]\n    end\n  end\n  result\nend", "  result =\
    \ Array.new(k+1)\n  result[0], result[1] = arr[0], arr[1]", "  return arr.reverse.reverse.take_while\
    \ { |e| k <= e } \nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
