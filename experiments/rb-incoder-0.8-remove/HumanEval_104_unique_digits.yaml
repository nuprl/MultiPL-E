name: HumanEval_104_unique_digits
language: rb
prompt: "# Given a list of positive integers x. return a sorted list of all \n# elements\
  \ that hasn't any even digit.\n# Note: Returned list should be sorted in increasing\
  \ order.\n# For example:\ndef unique_digits(x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n\
  \    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15,\
  \ 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n \
  \   assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31,\
  \ 135], candidate.call([135, 103, 31]))\n  end\nend\n"
completions: ["  x.uniq!\n  x.to_a.select{|e| e.to_i(2)}.sort\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\nHere is a solution using Array#uniq!\n\
    <code>", "  x.uniq!\n  x.group_by {|x| x/10}.select {|k,v| v.size == 1}.keys.sort\n\
    end", "  x.each do |n|\n    digits = n.to_s.reverse.to_i.to_s.chars.\n      select\
    \ {|c| c !~ /\\d/}.\n      select {|c| c !~ /\\d/}.reverse # remove all digits.\n\
    \    digits = digits.length\n    break if digits != 0\n  end\nend\n</code>\n<|/\
    \ a |>\n<| a tags=ruby,sorting |>\nThis one uses only single loop. \n<code>",
  "  x.sort!\n  output = []\n  x.each do |d|\n    if d.to_s.to_i(0).even?\n      output\
    \ << d\n    end\n  end\n  output\nend\np unique_digits([1, 3, 6, 1, 9, 5, 2, 8,\
    \ 3])\n</code>\nIt run in around 0.033 seconds and return [3, 6].\n<|/ a |>\n\
    <| c |>\nthis has quadratic complexity, where you only need linear complexity\
    \ with a single pass. i don't think this works with any input except `[1, 2, 3,\
    \ 4, 5]`\n<|/ c |>\n<| a dscore=1 |>\nWe can use this solution to find the element\
    \ which contains unique digits in array using only single pass.\n<code>\nfunction\
    \ find_unique_digit(arr) {\n  var len = arr.length;\n  var index = 0;\n  var result\
    \ = [];\n  var temp_arr = [];\n  while (len > index) {\n    var digit = parseInt(arr[index]);\n\
    \    if (temp_arr.indexOf(digit) == -1) {\n      temp_arr.push(digit);\n     \
    \ result.push(digit);\n    }\n    index++;\n  }\n  return result;\n}", "  x.sort!\n\
    \  ret = []\n  x.each do |el|\n    ret << el if el % 2 == 0\n  end\n  ret.sort!\n\
    \  ret\nend", "    sorted = x.sort \n    even = []\n    odd  = []\n    x.each\
    \ do |x|\n        x.to_s.chars.each do |c|\n            if  c.odd?\n         \
    \       odd << c\n            elsif c.even?\n                even << c\n     \
    \       end\n        end\n    end\n    sorted.delete_if {|x| x.odd? || x.even?\
    \ }\n    even.concat(odd)\n    sorted.sort\nend", "  x.sort { |a,b| a.to_s <=>\
    \ b.to_s }\n  x.each_with_object([]).inject([]) do |arr,x|\n    arr << x unless\
    \ x.to_s.gsub('0',\"\").size % 2 == 0\n  end\nend\nunique_digits([2,3,1])", " \
    \ x.sort\n  x.map! { |n| n % 10 }.uniq!\n  x\nend", "  return x.group_by(&:to_i).values.map\
    \ do |v|\n    if v.count(&:odd?) > 0\n      v\n    else\n      nil\n    end\n\
    \  end\nend\nunique_digits([2,1,7,3,5,1,7,3,5,9,8,9,8])", "    # Your code here\n\
    end", "  # +++your code here+++\n  # Hint: Use Collections module to sort and\
    \ remove\n  # Hint: Use a set instead of list\n  # Hint: Use Integer's .odd? method\
    \ to check for odd digit\n  \n  \n  \n  \n  # Unique elements in x\n  unique_x\
    \ = x.sort\n  \n  # Remove any even digit\n  unique_x.delete_if {|i| i.odd?}\n\
    \  \n  # Sort in increasing order\n  unique_x.sort\nend\n</cell>\n<cell>\nunique_digits([1,2,3,4,5,6,7,8,9,0])\n\
    </cell>\n<text>\nEjercicio 3\nEn este ejercicio vamos a crear un m\xE9todo para\
    \ determinar si un n\xFAmero es premium o no. Para ello deber\xE1s pasar el n\xFA\
    mero al primer par\xE1metro de la funci\xF3n y comprueba si el n\xFAmero es primo.\
    \ El segundo par\xE1metro de la funci\xF3n deber\xE1s ser un booleano de vuestro\
    \ choosen manera. Si es un primo deber\xE1s regresar un true, sino un false.",
  "  x.sort.group_by{|x| x.to_s.split(\"\").delete_if(&:odd?).map(&:to_i)}.values.flatten\n\
    end\n</code>\n<|/ a |>\n<| a dscore=1 tags=ruby,sorting,algorithm |>\nJust in\
    \ case you really want a Ruby solution\n<code>", "    # write your code here\n\
    \    a = []\n    a.sort\n    x.each do |i|\n        a.push(i) if i.to_s.chars.uniq.count\
    \ != 1\n    end\n    a\nend", "  x.sort.map { |s| s.split(//).map { |c| c.to_i\
    \ }.uniq.sort }.flatten.compact\nend", "    unique_digits_array = []\n    for\
    \ i in x\n        digit_check = []\n        for j in i\n            if j % 2 ==\
    \ 0\n                digit_check << j\n            end\n        end\n        unique_digits_array\
    \ << digit_check\n    end\n    unique_digits_array.sort!\nend", "  x.sort_by {\
    \ |x| x.to_s.split('').uniq.size }\nend", "  x.sort.map{|x| x % 10}.uniq\nend\n\
    unique_digits([1,2,3,4,5,6,7,8,9,10])", "  x.sort.select{|x|x%2==0}.uniq.sort.each\
    \ do |x| \n    x.to_s.each_char.uniq.each do |x| \n      puts x.to_i\n    end\
    \ \n  end \nend\nunique_digits([1, 2, 3, 4, 5, 6])", "    x.sort!\n    result\
    \ = x.select { |e| e % 2 == 0 }\n    result.sort!\n    return result\nend", " \
    \   x.each do |y|\n        x.each do |z|\n            x.each do |i|\n        \
    \        if z.to_s.length == 1 && i.to_s.length == 1 && i.to_s == z.to_s\n   \
    \                 x.delete(z)\n                end\n            end\n        end\n\
    \    end\nend", "    \n    list = []", "  x.sort!\n  i = 0\n  result = []\n  while\
    \ i < x.length\n    while x[i] % 2 == 0 && i < x.length - 1\n      i += 1\n  \
    \  end\n    if i == x.length - 1\n      result << x[i]\n      i += 1\n    else\n\
    \      x[i], x[i + 1] = x[i + 1], x[i]\n    end\n  end\n  return result\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| a dscore=1 |>\nTry this code,\
    \ hope it helps you\n<code>", "    seen = set()\n    seen_add = seen.add\n   \
    \ return sorted(x for x in x if not (x in seen or seen_add(x)))", "    x.sort!\n\
    \    return x.select {|el| el =~ /\\A[\\d]+\\z/}\nend", "  x.sort!\n  result=[]\n\
    \  for i in x\n    if i.to_s.split(\"\").uniq.count != 0\n      result << i\n\
    \    end\n  end\n  return result\nend\n</cell>\n<cell>\nunique_digits([4,6,2,8])\n\
    </cell>\n<text>\nHow do you create a hash of unique elements?", "  y = []\n  x.each\
    \ do |n|\n    next if n % 2 != 0\n    y.push(n)\n  end\n  y.sort\nend", "    x.sort!\n\
    \    result = []\n    x.each_with_index do |i,idx|\n      if i.to_s.length % 2\
    \ == 0\n        if result.include?(i)\n          result << i\n        else\n \
    \         result << i\n        end\n      end\n    end\n    result\nend\n</code>\n\
    <|/ a dscore=2 tags=ruby,arrays |>\n<| a |>\nJust for fun, I rewrote it using\
    \ hashes and sort.\n<code>", "    x.each do |i|\n        if i % 2 == 0\n     \
    \       x.delete(i)\n            x.sort!\n        end\n    end\n    return x\n\
    end\n</code>\n<|/ a tags=ruby,algorithm,sorting,ruby-on-rails dscore=2 |>\n<|\
    \ a dscore=2 |>\nThe first thing I would do is change the test to test whether\
    \ the number is divisible by 3.\n<code>", "  sorted = x.sort.uniq\n  sorted.each\
    \ do |num|\n    if num % 2 == 0\n      sorted = sorted.delete(num)\n    end\n\
    \  end\n  sorted\nend\n</code>\nThe result is the same as the original list.\n\
    <|/ a dscore=0 tags=ruby,algorithm |>\n<| c |>\nWhy not `sort.uniq { |n| n % 2\
    \ == 0 }` instead of `x.sort.uniq.select{ |n| n % 2 == 0 }` ?\n<|/ c |>\n<| c\
    \ |>\nThank you for pointing that out ! I edited my answer accordingly. Now it's\
    \ `sort`, not `uniq`.\n<|/ c |>\n<| a tags=ruby,algorithm |>\nHere is another\
    \ solution using Enumerable#partition:\n<code>", "  x.sort!\n  x.reject! { |i|\
    \ i.to_s.split(//).count(i.to_s[0,1]) % 2 == 0 }\n  x\nend\n</code>\n<code>",
  "  return x.select { |e| e % 10 != 0 }.sort\nend", "  x.sort!\n  \n  result = []\n\
    \  for i in 0...x.size-1\n    next if i.to_s.split('').count(x[i].to_s[0]) ==\
    \ 0\n    result << x[i]\n  end\n  \n  result\nend\n</cell>\n<code language=julia-0.6>\n\
    unique_digits([1,2,3,4,5,6,7,8,9])\n</cell>\n<code language=julia-0.6>\nunique_digits([1,2,3,4,5,6,7,8,9],\
    \ true)\n</cell>\n<code language=julia-0.6>\nunique_digits([1,2,3,4,5,6,7,8,9],\
    \ false)\n</cell>\n<text>\nThe longest increasing subsequence\nThe longest increasing\
    \ subsequence (LIS or LISB or LISF) is the longest sequence of items that are\
    \ strictly increasing or strictly decreasing from a given starting point in a\
    \ given sequence. For example, if you have sequences starting with 4, 5, 6, 7,\
    \ 8, 9, and you want to find the longest increasing subsequence starting from\
    \ 6, you can:", "  x.sort! \n  x.uniq!\nend\nunique_digits([1,2,1,3]) ", "  digits\
    \ = {}\n  x.map!{|x| digits[x] ||= 0}\n  x\n    .uniq\n    .map!{|x| digits[x]\
    \ +=1;}\n    .sort!\n    .map!{|x| x.to_s.gsub(/\\d/, '0')}\nend", "    sorted\
    \ = x.sort\n    even = 0\n    res = []\n    \n    until even == x.size - 1\n \
    \       if sorted.count % 2 == 0 then even += 1\n        res += sorted.delete_at(even)\n\
    \    return res\nend\n</cell>\n<code language=julia-0.4>", "    x.sort!\n    return\
    \ x unless x.uniq.size <= 1\n    first = x.uniq.first\n    return x.uniq.reject\
    \ {|y| y.to_s.include?(first) }\nend", "  unique = x.uniq\n  unique.delete_if\
    \ { |x| x.to_s.chars.map(&:to_i).reject {|x| x%2 == 0}.length == 0}\n  unique.sort\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a dscore=1 |>\nIn case you need just unique\
    \ digit strings, here is a solution with Enumerable only:\n<code>\nx = '45443432'\n\
    x.chars.select { |x| x.to_i.to_s == x }.uniq.sort.join", "  x.sort!\n  \n  result\
    \ = []\n  \n  x.each_with_index do |i, index|\n    if i % 2 == 0 && i.to_s.count\
    \ != \"0\"\n      result << i.to_s\n    end\n  end\n  \n  result.sort\nend", " \
    \ x.sort! # Sort the array\n  x.each do |i|\n    x.delete_at(x[i] % 10) if i %\
    \ 2 == 0\n  end\n  x\nend\nunique_digits([23,12,2,34])", "    sorted = x.sort\n\
    \    evens = sorted.select {|n| n % 2 == 0}\n    evens.delete_if {|n| n != 0 &&\
    \ n != 1}\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThe easiest and most compact\
    \ way to do this would probably be to use .uniq, .select, and a lambda.\n<code>\n\
    >> x = ['0', '0', '0', '0', '1', '1', '1', '1']\n>> x.uniq {|s| s.count('0')}\n\
    => [\"0\", \"1\", \"1\"]\n</code>\nThis works by counting how many times a character\
    \ appears in the array. If it's 0 then that element will be included in the result.\
    \  If it's 1 then it won't.\n<|/ a tags=ruby,arrays,count,sorting dscore=0 |>\n\
    <| c |>\nThis will have different results than [the other answer](http://stackoverflow.com/a/21498066/2414957).\n\
    <|/ c |>\n<| c |>\nThis is more efficient, yes, but it's still not equivalent\
    \ to the other answers. e.g. what about `\"1111\".uniq{|s| s.count('0')}` ?\n\
    <|/ c |>\n<| c |>\n, that's true - it's pretty obvious why the other answers don't\
    \ work for the OP's specific requirements. I did upvote your answer for the effort\
    \ though.\n<|/ c |>\n<| a dscore=0 tags=ruby,arrays,count,sorting |>\nThis works\
    \ for me: \n<code>", "    x.sort!\n    x.map!{|y| y % 10 }\n    x.delete_if{|y|\
    \ y % 2 == 0}\n    x\nend", "  x.sort.uniq.join\nend\n</code>\n<|/ a |>\n<| a\
    \ |>\nI wrote this ruby code which is pretty straight forward. It uses map,sort,\
    \ and uniq to get the unique digits and then joins the results together by putting\
    \ them in a single line.\n<code>", "    x.map! { |e| e.to_s.chars.map(&:to_i).reduce(:+)\
    \ }\n    return x.uniq(&:even?)\nend\n</code>\nHere we calculate the frequency\
    \ of each character and sum them.\nThen we get all those elements which has odd\
    \ sum\n<|/ a dscore=2 tags=ruby,algorithm |>\n<| c |>\nI thought about that too\
    \ but then I think OP wants sorted output. Your method doesn't return it.\n<|/\
    \ c |>\n<| c |>\n: Yes. I missed that. Thanks.\n<|/ c |>\n<| c |>\nYeah, now I\
    \ realized that I missed that too ;-) Fixed.\n<|/ c |>\n<| c |>\nThe `#to_s` call\
    \ is unnecessary. `chars` is already an array of `char`s, so that `to_s` call\
    \ does nothing useful.\n<|/ c |>\n<| c |>\n: I was thinking in general case, as\
    \ OP mentioned about any integers. Thanks.\n<|/ c |>\n<| a |>\nHere's an answer\
    \ that uses reduce:\n<code>\nx = [7, 1, 1, 5, 9, 9, 3, 6, 1]", "  x.sort.map do\
    \ |i|\n    i = i.to_s.split(\"\").map(&:to_i).select do |x|\n      x % 2 == 0\n\
    \    end\n    i = i.uniq.sort.to_a\n    if i.length == 1\n      i[0]\n    else\n\
    \      i[0]\n    end\n  end\nend\nputs unique_digits(ARGV[0]).inspect\n</code>\n\
    <|/ a |>\n<| c |>\nThis does not provide an answer to the question. Once you have\
    \ sufficient [reputation](http://stackoverflow.com/help/whats-reputation) you\
    \ will be able to [comment on any post](http://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](http://meta.stackexchange.com/questions/214173/why-do-i-need-50-reputation-to-comment-what-can-i-do-instead).\
    \ - [From Review](/review/low-quality-posts/10496181)\n<|/ c |>\n<| c |>\nThe\
    \ OP did ask for \"any hints\". IMO it's an answer to his question \"how could\
    \ I do this?\"\n<|/ c |>\n<| c |>\n, your solution produces an empty array: `[].uniq`\
    \ => `[]`. Thus, it does not answer the OP's question.\n<|/ c |>\n<| c |>\n: I\
    \ tested the code in my answer and it works fine. Could you please provide an\
    \ example input which does not work?\n<|/ c |>\n<| c |>\nThe question asks *how\
    \ to do this*. Your answer does not do that. It's just a code dump without any\
    \ explanation.\n<|/ c |>\n<| a tags=ruby,arrays |>\nYou want to filter out elements\
    \ that only contain digits, right? If that's so, you can do this:\n<code>\nx.reject\
    \ { |s| s.match(/\\D/) }\n</code>\n<|/ a dscore=3 |>\n<| c |>\n+1 Good one. But\
    \ I'd use `/\\D/` instead of `/\\D+/` so the regex is clearer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>\n arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]", "    x.map!\
    \ {|n| n % 10}\n    x.uniq!\n    x.sort.reverse\nend\n</cell>\n<cell>\narr = [1,2,3,4,5]\n\
    unique_digits(arr)\n</cell>\n<cell>", "    x.sort!\n    ret = []\n    \n    (0..x.length-1).each\
    \ do |i|\n        ret << x[i] if x[i].to_s.length % 2 == 0 && x[i] > 9\n    end",
  "  s = x.sort.map { |v| [v, v.to_i] }\n  s.select { |v| v.first % 2 == 0 }.map {\
    \ |v| v.first }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt should be noted\
    \ that if the input is a very large set of integers, this method will take a long\
    \ time to run. In that case, it would benefit from sorting the list first, as\
    \ in the other solutions.\n<|/ c |>\n<| c |>\nI guess this approach doesn't always\
    \ guarantee `uniq` ordering since `uniq` is essentially a hash and does not preserve\
    \ ordering.\n<|/ c |>\n<| a dscore=1 |>\nYou can get all of the unique integers\
    \ in the range by doing:\n<code>\n(1..100).select { |i| i.to_s.split('').uniq.size\
    \ == 1 }\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is not very efficient, since\
    \ it will scan the range twice: First to count how many unique characters are\
    \ in the range, then to select the first number in the range.\n<|/ c |>\n<| c\
    \ |>\nThis also does not guarantee that all integers within the range have unique\
    \ digits.\n<|/ c |>\n<| a dscore=0 |>\n<code>\n(1..100).select { |i| i.to_s.split('').uniq.size\
    \ }\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is not very efficient, since it\
    \ will scan the range twice: First to count how many unique characters are in\
    \ the range, then to select the first number in the range.\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHere is a faster solution that uses sort.\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |n|\n    if n % 2 == 0\n      result << n\n    end\n  end\n\
    \  result\nend\nunique_digits(1234)\n=> [4, 3, 1, 2, 5]\nunique_digits(12345)\n\
    => [4, 5, 1, 2, 3]\nunique_digits(12345)\n=> [4, 5, 1, 2, 3]\nunique_digits(12345)\n\
    => [4, 5, 1, 2, 3]\n</code>\n<|/ a |>\n<| c |>\n`unique_digits(123)` should return\
    \ `[1,2,3]`, not `[1,2,3]`.\n<|/ c |>\n<| c |>\nYou might want to look at your\
    \ `unique_digits` implementation: it returns an empty array if passed an empty\
    \ array.\n<|/ c |>\n<| a tags=ruby,arrays |>\nI suggest you use the Enumerable\
    \ module and implement each method yourself, as Ruby will most probably use an\
    \ optimized implementation that uses the C code from GC that Ruby uses to garbage\
    \ collect objects.\nThe first method can simply be:\n<code>", "  x.sort!\n  result\
    \ = []\n  for x in x\n    result.append(x.to_s) unless x.odd?\n  end\n  result.uniq.sort\n\
    end\n</code>\n<|/ a |>\n<| c |>\nJust as a heads-up, the second example is not\
    \ correct (it is still O(n)), since you don't return an array in that first example\
    \ (even though it might look like it is).\n<|/ c |>\n<| c |>\n, you're right,\
    \ I'll fix it.\n<|/ c |>\n<| a dscore=0 |>\nYou can get it in O(n log n) time\
    \ using a radix sort.\n<code>", "  x.map {|i| i.to_s.split('').map {|j| j.to_i}}.flatten.uniq.sort\n\
    end\n</code>\n<|/ a tags=ruby dscore=0 |>\n<| c |>\nI didn't downvote, but I suspect\
    \ it's because you've posted a solution that doesn't actually work. You've shown\
    \ how to create a method that takes numbers and returns a sorted list with unique\
    \ digits. But you've shown no way to get it to work if the number passed into\
    \ the method is negative. I suspect the reason it was downvoted is that it looks\
    \ like you're just trying to get someone else to do the work for you, rather than\
    \ actually trying to understand what you've written.\n<|/ c |>\n<| c |>\nActually,\
    \ I did try a couple of things before I posted my question. It wasn't just giving\
    \ me the correct answer, it was giving me a wrong answer. I'm still new to Ruby,\
    \ so I probably didn't fully understand your solution. I'm pretty sure that if\
    \ I was able to understand your answer, I wouldn't have needed to ask the question\
    \ on SO.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  return x.select { |e| x.count(e).even?\
    \ }.sort_by { |e| -x.count(e) }\nend", "  x.sort.uniq\nend", "    x.sort!\n  \
    \  result = []\n    (0...x.length-1).each do |i|\n        if x[i]%2 == 0 \n  \
    \          result.push(x[i])\n        end\n    end\n    result\nend\n</code>\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\n def unique_digits(array)\n    array.each_with_object([])\
    \ do |value, array|\n      array << value unless array.include?(value)\n    end\n\
    \  end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\nAnother one with\
    \ #sort_by, #partition and #reject methods:\n<code>", "    # Your code here\n\
    \    \n    # Your code here\n    \n    # Your code here\n    \n    # Your code\
    \ here\n    \n    # Your code here\n    \n    return x", "    arr = x.map {|n|\
    \ n.to_s.reverse.to_i}\n    arr.map! {|i| i.modulo(10)}\n    arr.uniq!\n    arr.sort_by!\
    \ {|i| i.to_s.reverse.to_i}\n    arr\nend", "  x.sort.reduce(:<<) do |result,el|\n\
    \    result + el if el.to_s.chars.count { |x| x == '0'} != 0\n  end\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays dscore=0 |>\n<code>\narr = [0,1,2,3,4,5,6,7,8,9]\n\
    arr.sort.uniq(&:odd?)", "  return x.uniq {|y| y == y.to_s.scan(/\\d/).size }\n\
    end", "    digits = []\n    x.each do |x|\n        digits.push(x[0].to_i)\n  \
    \  end\n    digits.sort.uniq.each do |x|\n        if x.modulo(10).zero?\n    \
    \        digits.delete(x)\n        end\n    end\n    digits\nend\nunique_digits([-10,\
    \ 1, 2, 3, 10, 4, 5])", "  x.sort!\n  result = x.inject([]) do |memo, el|\n  \
    \  if el % 2 == 0\n      memo << el\n    end\n    memo\n  end\n  result\nend\n\
    </code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nI think it should be memo instead\
    \ of m\n<|/ c |>\n<| a tags=ruby,sorting dscore=0 |>\n<code>", "  result = x.select\
    \ { |i| i.to_s !~ /\\d/ }\n  result.sort\nend\n</code>\n<|/ a |>\n<| c |>\nI appreciate\
    \ you commenting on my answer. I just did an edit because your solution was buggy\
    \ and I think you made a good point (I didn't think of the problem as having to\
    \ be sorted). To fix this, I changed the `sort` to `sort!`. Also, `unique` was\
    \ a misnomer. It just means \"no duplicates\". `uniq` would have been correct\
    \ but just means \"unique\". Hope that makes sense.\n<|/ c |>\n<| c |>\nAh yes,\
    \ that was a misnomer indeed! Thanks for the heads-up!\n<|/ c |>\n<| a |>\n<code>",
  "  x.map do |i|\n    i = i.to_s.to_i\n    i = i / 10 if i % 10 == 0\n    i = i.to_s\n\
    \    i = i + ((i % 2) == 0 ? \"_even\" : \"_odd\")\n    i.to_i\n  end\nend\nunique_digits([1,2,3,4,5,6,7,8,9,10])",
  "  x.to_s.chars.uniq.map(&:to_i).sort\nend\n</pre>\n</div>\n</div>\n</div>\n<div\
    \ class=\"cell border-box-sizing text_cell rendered\"><div class=\"prompt input_prompt\"\
    >\n</div><div class=\"inner_cell\">\n<div class=\"text_cell_render border-box-sizing\
    \ rendered_html\">\n<p>Let's test our new function on <code>[2,7,4,1,8,3,5,6,5,4,6,7,8,9,3,6,1,9,0,9,2,3,6,2,8,3,1]</code></p>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.split('').uniq.size\
    \ != 1\n  end\n  result\nend\n</code>\nand you can call it with:\n<code>\np unique_digits(['12',\
    \ '23', '34', '56', '67'])\n=> [\"56\", \"34\", \"67\"]\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\n`x.sort` does not work for me in Rails 4.\n<|/ c |>\n<| c |>\n\
    : which version of Ruby are you using?\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nIf you need ruby 2.1 or above and no additional gems, you can use:\n<code>",
  "  x.sort!\n  ret = []\n  x.each do |x|\n    if x.to_s.chars.uniq.size == 1\n  \
    \    ret << x\n    end\n  end\n  ret\nend", "  if x.empty?\n    []\n  else\n \
    \   unique_digits_helper([], x, 0)\n  end\nend", "  x.sort!\n  new_x = []\n  x.each\
    \ do |x|\n    if x.to_i.to_s == x % 10\n      new_x << x\n    end\n  end\n  new_x.sort!\n\
    \  return new_x\nend", " \n  result = x.select { |i| (i**2).to_i < i.to_i }.sort\n\
    \  return result unless result.size == 1\n  return result if result[0] % 2 ==\
    \ 0\n  result[0]\nend\n</cell>\n<text>\nSort all elements in a list", "  x.sort!\n\
    \  x.reverse!\n  x.select! {|e| e % 2 == 0}\n  x\nend", "    even = x.select{|i|\
    \ i.to_s.chars.map(&:to_i).all?(&:even?)}\n    even.sort!.map{|e| x.delete(e)\
    \ }\n    even\nend", "  x.group_by {|i| i /= 10}.map {|k, v| k if v.size == 1}.sort_by(&:first)\n\
    end\n</pre>\n          </div>\n        </div>\n        <hr>\n      </div>\n  \
    \    <footer>\n        <p>\n          &copy; 2013 Rubens Urbanujaman<br/>\n  \
    \        Based on the Ruby code by <a href=\"http://github.com/vhochstein\">Vimal\
    \ Hochstein</a>.\n        </p>\n      </footer>\n    </div>\n    <script>\n  \
    \    function toggleTOC(){\n        var $TOC = $('.toc-link');\n        if($TOC.size()\
    \ > 0){\n          $(window).scrollTop($TOC.offset().top - 20);\n          $TOC.show();\n\
    \        } else {\n          $TOC.hide();\n        }\n      }", "  # your code\
    \ goes here\n  x.map { |y| y.to_s.split('').reject { |z| z.to_i.zero? }.size }.uniq.sort.sort\n\
    end", "    x.sort!\n    evens = x.select {|e| e % 2 == 0}\n    evens.delete_if\
    \ {|e| x.count(e) == 1}\n    evens\nend", "    x.each_index { |i| x[i] = x[i].to_s.split(//).sort\
    \ }.\n        uniq.\n        map(&:last).\n        sort\nend\n</code>\n<|/ a |>\n\
    <| a dscore=0 |>\nA bit late to the party, but this is more readable:\n<code>",
  "  x.sort!\n  x.each_with_index do |n,i|\n    return n if n % 2 == 0\n  end\n  x.first\n\
    end", "  x.sort.uniq\nend\n</pre>\n</div>\n</div>\n</div>\n<p>\nNow that we have\
    \ seen our first algorithms, let's try to implement them with Ruby!\n</p>", " \
    \ x.sort_by{|x| x.to_s.split(\"\").uniq.size}\nend\nunique_digits([23, 67, 67,\
    \ 81, 67])", "  unique_digits = x.select { |v| v % 10 == 0 }.sort\nend\nunique_digits([9,\
    \ 4, 8, 6, 9, 4, 6, 7, 5, 2])", "  x.each do |x|\n    puts x.to_s.chars.map(&:to_i).sort.uniq.size\n\
    \  end\nend", "  x.sort.each_with_index do |i, idx|\n    next if i.to_s.chars.uniq.size\
    \ == 1\n    return i if i.to_s.chars.uniq.count == idx\n  end\nend\n</code>\n\
    <|/ a tags=sorting,ruby dscore=1 |>\n<| c |>\nOh, wow! I never knew this trick\
    \ `uniq` before. Thanks!\n<|/ c |>\n<| a dscore=1 tags=sorting,ruby |>\n<code>\n\
    [1,2,3,4,5,6,7,8].sort_by { |v| v.to_s.chars.uniq.size }.uniq\n</code>\n<|/ a\
    \ |>\n<| a dscore=1 |>\n<code>\n[1,2,3,4,5,6,7,8].sort.uniq{|x| x.to_s.chars.uniq}\n\
    </code>\n<|/ a tags=sorting,ruby |>\n<| a tags=sorting,ruby dscore=0 |>\nTry this:\n\
    <code>\n[1,2,3,4,5,6,7,8].sort{|a,b| a.to_s.chars.uniq.size <=> b.to_s.chars.uniq.size\
    \ }.uniq\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n[1,2,3,4,5,6,7,8].sort_by\
    \ {|i| i.to_s.chars.uniq.size }.uniq\n</code>\n<|/ a tags=sorting,ruby |>\n<|\
    \ c |>\nPlease add some explanation to your code such that others can learn from\
    \ it\n<|/ c |>\n<| c |>\nWhile this code snippet may solve the question, [including\
    \ an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=sorting,ruby |>\nI guess you were looking\
    \ for a method that would return all elements having the same number of unique\
    \ characters.\n<code>", "  x.map {|i| i.to_s.split('').uniq.map{|y| y if y.to_s.chars.map(&:to_i).reduce(:+)\
    \ == 0 }}.flatten.sort\nend", "  x.sort.reject {|i| i.odd?}.flatten.uniq.sort\n\
    end\nunique_digits([1,2,3,4,5,6,7,8])\n=> [1, 2, 3, 4, 5, 6, 7, 8]", "  # Your\
    \ code here\nend\n</pre>", "  x.sort!\n  result = []\n  for i in 0..x.size-1 do\n\
    \    if x[i] % 2 == 0 and result.include?(x[i]) == false then\n      result <<\
    \ x[i]\n    end\n  end\n  result\nend\nunique_digits([2,4,7,9,11,50])", "    arr\
    \ = x.to_s\n    x.sort.each do |x|\n        arr.delete(x)\n    end\n    arr\n\
    end\n</cell>\n<code language=julia-1.4>", "    # write code here\nend", "  sorted\
    \ = x.sort\n  result = []\n  for i in sorted\n    break unless i.even?\n    result\
    \ << i\n  end\n  result\nend", "  result = []\n  while x.any? \n    result <<\
    \ x.find { |x| x % 10 == 0 }\n    x << x.delete_at x.find { |x| x % 10 == 0 }\n\
    \  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nAwesome solution!\n<|/ c |>\n\
    <| a dscore=2 |>\nI came across this question when solving this problem. You can\
    \ use inject to solve it in one line:\n<code>\n[1,2,3,4,5,6,7,8,9,10].inject([])\
    \ { |s,i| s << i if s.any? { |e| e.to_s.chars.map(&:to_i).include? i } }.sort\n\
    </code>\n<|/ a tags=arrays,ruby |>\n<| a dscore=1 tags=arrays,ruby |>\nYou can\
    \ simply use inject method on Array:\n<code>\n[1, 2, 3].inject([]) {|memo, elem|\n\
    \  memo << elem if elem =~ /^[0-7]/\n  memo.sort\n}", "  x.sort!\n  x.map!{|v|\
    \ v.to_i}\n  x.uniq!\n  x\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails dscore=0\
    \ |>\n<| c |>\nThanks for the suggestion. However i want the output to be in ascending\
    \ order and unique digits.\n<|/ c |>\n<| c |>\nHi I did try your solution. It\
    \ works. However this solution doesn't output the unique digits. Thanks.\n<|/\
    \ c |>\n<| c |>\nYou are correct, my bad. I will try to add unique digits as well.\n\
    <|/ c |>\n<| c |>\nEdited the solution. Hope it helps.\n<|/ c |>\n<| c |>\nThanks\
    \ for your suggestion. However i want a solution which doesn't require adding\
    \ new method into the class. I appreciate your help and your time.\n<|/ c |>\n\
    <| a dscore=0 |>\nThe other answers work perfectly. But I believe a solution without\
    \ using new methods would be cleaner. \n<code>\nx = 10", "  x.sort.uniq{|y| y\
    \ % 10 == 0}\nend", "  x.sort.each do |e|\n    x.delete_if {|x| x % 10 == 0}\n\
    \  end\n  return x\nend\n</code>\n<|/ a tags=ruby,sorting dscore=0 |>\n<| a |>\n\
    <code>", "    x.sort!\n    unique = []\n    x.each do |y|\n        y.to_s.split('').each\
    \ do |z|\n            if z.to_i =~ /^\\d+$/ and z % 2 == 0 then\n            \
    \    unique.push(z)\n            end\n        end\n    end\n    return unique\n\
    end", "    return x.find_all{|e| e % 2 == 0}\nend", "  x.each_with_object({})\
    \ { |e, acc| acc[e] = true if x.count(e) % 2 == 0 }.\n  sort_by { |k, v| k.to_i\
    \ }.\n  map(&:first)\nend\n</code>\n<|/ a tags=sorting,ruby dscore=1 |>\n<| c\
    \ |>\nGood solution. `Enumerable#sort_by` returns a new array, so you can just\
    \ do `x.sort_by { |e| e.to_i }.map(&:first)`\n<|/ c |>\n<| a dscore=1 |>\nJust\
    \ for fun: \n<code>", "  unique_digit = []\n  x.each do |n|\n    if n.to_s.chars.uniq.count\
    \ % 2 == 0\n      unique_digit << n\n    end\n  end\n  unique_digit.sort\nend\n\
    </code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails,ruby-on-rails-4 |>\n<| a dscore=2\
    \ |>\n<code>", "  x.sort!\n  x.uniq!\n  x.compact!\n  x\nend", "  x.map!{|x|x.to_s.split('').sort.uniq.join.to_i}\n\
    \  x.to_a.uniq.sort\nend", "  digits = x.uniq.map{|d| d.to_s.split('').map(&:to_i)}\n\
    \  digits.reduce([]) do |acc, val|\n    acc << val if digits[val].any? {|i| i\
    \ % 2 != 0}\n    acc\n  end\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\n\
    I wonder if your `unique_digits` method could be optimized by creating a new array\
    \ with the elements `to_s`, then grouping them by the digits, rather than converting\
    \ to and from strings. The only problem with that is that you'd then need to do\
    \ `unique_digits.sort_by(&:to_s)` in order to get them in order.\n<|/ c |>\n<|\
    \ c |>\nYes, your comment is correct. I did it because I was trying to get unique\
    \ digits from the string representation, but now I realise it makes sense to get\
    \ unique numbers from the numbers. Thanks.\n<|/ c |>\n<| a |>\nAs suggested by\
    \ jamesw, I have created a benchmark which compares the different solutions (in\
    \ terms of asymptotic complexity) available by different users.\n<code>\nrequire\
    \ \"benchmark\"", "  x.sort!\n  result = []\n  for i in x \n    if i.to_s.chars.uniq.count\
    \ == 0\n      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis is an interesting solution, although it feels like the method\
    \ should be returning `x.uniq` instead of `result`.\n<|/ c |>\n<| c |>\n, `x.uniq`\
    \ would also do the job, but I used `result` as an example to show the original\
    \ code structure. Thanks for your comment!\n<|/ c |>\n<| c |>\nThat's not the\
    \ whole point of the question. OP wants something like `[5, 12, 21, 34, 3, 6,\
    \ 5]`.\n<|/ c |>\n<| c |>\n, thank you for the clarification. I edited my answer\
    \ to include this possibility.\n<|/ c |>\n<| a tags=ruby |>\nI wrote a small piece\
    \ of code:\n<code>\nrequire 'set'", "  x.uniq!\n  x.uniq!.to_a\nend\n</code>\n\
    and I got what I want.\n<|/ a dscore=0 |>\n<| a |>\n<code>", "    x.sort!\n  \
    \  ans = []\n    for i in x\n        if i.to_s.length == 0 and i % 2 == 0\n  \
    \      ele << i\n        end\n    end\n    ans\nend\n</code>\n<|/ a dscore=1 tags=ruby\
    \ |>\n<| c |>\nThank you for helping me out with the first step. I realize I made\
    \ a mistake with my original post. I will edit this accordingly and clarify my\
    \ question\n<|/ c |>\n<| a tags=ruby |>\nThis is my solution:\n<code>", "  x.sort!\n\
    \  x.reject{|num| num.odd?}\n  x\nend\nprint unique_digits([1, 2, 4, 12, 20])",
  "  x.sort!\n  result = []\n  for i in 0..x.size-1\n    if (x[i]%2 == 0)\n      result\
    \ << x[i]\n    end\n  end\n  result\nend", "  x.each do |n|\n    if n % 2 == 0\
    \ && n.to_s.chars.uniq.size == 0\n      puts n\n    end\n  end\nend", "  return\
    \ [] if x.empty? \n  hash ={}\n  x.each do |i|\n    if hash[i] \n      hash[i].each_index\
    \ { |j| hash[i][j] = false }\n    end\n  end\n  x.each do |i|\n    if i.to_s.chars.select\
    \ {|x| x.to_i % 2 == 0}.length == 0\n      hash[i] << true\n    end\n  end\n \
    \ return x.select {|i| hash[i].all?}\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThanks Mr.Wizard. Your code is working great.\n<|/ c |>\n<| c |>\n\
    This would work fine too: `def unique_digits(x)\n  return [] if x.empty?\n  x.uniq.select\
    \ { |i| i&.to_i }\nend`\n<|/ c |>\n<| c |>\nThe last `to_i` can be omitted.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\nHere's one way:\n<code>", "  return\
    \ x.select { |num| num.zero? || num.odd? }.sort\nend", "  x.sort!\n  x.uniq!\n\
    \  x\nend", "    x.sort.uniq\nend\n</code>\n<|/ a dscore=1 tags=ruby |>\n<| c\
    \ |>\nNote that this answer does not sort the array in ascending order, which\
    \ seems like the expected behavior.\n<|/ c |>\n<| c |>\nSorry I missed that. Thanks\n\
    <|/ c |>\n<| a tags=ruby dscore=0 |>\n<code>", "  digits = x.collect{|n| n % 10}\n\
    \  digits.sort.collect{|d| x.delete_if{|n| n % 10 == d}}\nend\n</code>\nExample:\n\
    <code>\n>> x = [\"12\", \"10\", \"34\", \"14\", \"9\"]\n>> unique_digits(x)\n\
    => [\"9\", \"10\", \"12\", \"14\", \"34\"]\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nThe sorting is also a big problem since the digits need to be sorted.\n\
    <|/ c |>\n<| c |>\nYes, that's true. I missed that.\n<|/ c |>\n<| c |>\nYeah,\
    \ I knew it would be a problem, but I really didn't want to add another sorting\
    \ step just for that one case.\n<|/ c |>\n<| a dscore=0 tags=ruby |>\n<code>\n\
    x = [\"12\", \"10\", \"34\", \"14\", \"9\"]\nx.group_by(&:to_i).map { |k,v| v.first\
    \ }", "  x.uniq!\n  x.select {|i| i%3 == 0}\nend", "  x.sort!\n  digits = []\n\
    \  x.each do |i|\n    while i.to_i < 9\n      digits << i.to_i\n      i -= 1\n\
    \    end\n  end\n  digits.uniq\nend", "  x.sort.uniq \nend", "  x.sort.select\
    \ {|num| num.odd?}.map {|num| num.to_s.rjust(2, '0')}\nend\n</code>\n<|/ a |>\n\
    <| a tags=algorithm,ruby |>\nThis is a fairly straightforward way to do it that\
    \ doesn't require any libraries:\n<code>", "  x.to_s.chars.sort.uniq.to_a\nend\n\
    </code>\n<|/ a dscore=3 tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\n\
    Note that this will return an array of strings rather than integers, so it will\
    \ not be able to be used as part of a unique index on a db field for example.\n\
    <|/ c |>\n<| c |>\nYes, I noticed that too. Fixed the answer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>", "  if x.nil? or x.empty?\n    []\n  else\n    x.inject([]){|y|\
    \ y <<  x.index{|i| i % 10 != 0}}\n  end\nend\n</code>\n<|/ a |>\n<| a tags=ruby\
    \ |>\nJust to add to the good answers already, here's a way to get the original\
    \ order if that is important:\n<code>", "  x.select { |v| v.to_s.split(//).sort.uniq.size\
    \ == 1 }\nend", "    x.sort!\n    count = 0\n    x.each do |x|\n        if x %\
    \ 2 == 0\n            count += 1\n        else\n            break\n        end\n\
    \    end\n    x.delete_if{|x| x % 2 == 0}\n    x.sort!\n    x.each do |x|\n  \
    \      if x.to_s.size < count \n            return x\n        end\n    end\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI edited your answer, since it's not really\
    \ a solution to the problem, and therefore not a good way to answer the question.\
    \ Feel free to roll it back.\n<|/ c |>\n<| a tags=ruby |>\nHere's an iterative\
    \ solution (for educational purposes only):\n<code>", "  x.sort { |a, b| b <=>\
    \ a }\n  x.select { |i| i[/\\d/].to_s.count(\"0\") == 1 }\nend\n</code>\n<|/ a\
    \ dscore=3 tags=ruby,sorting,arrays,unique |>\n<| c |>\nNice! You can just sort\
    \ without using uniq. Just change `uniq` to `sort` and remove the `select` block.\n\
    <|/ c |>\n<| c |>\nThanks for the help, but I got the exact same answer above\
    \ :) \n Just a small correction: the question asked for \"even\" digits, not \"\
    odd\".\n<|/ c |>\n<| c |>\nThanks for the comment. I revised the answer, but also\
    \ added the comment of Mr. Rakshit for my comment. :)\n<|/ c |>\n<| c |>\nThanks\
    \ for the detailed answer Danyal, I will try to get it to work. :)\n<|/ c |>\n\
    <| c |>\nThanks for your answer. It does work! Just a quick question though: how\
    \ would you do this when given a hash? For example, `x = { 1 => 'a', 2 => 'b',\
    \ 3 => 'c', 4 => 'd', 5 => 'e', 6 => 'f', 7 => 'g', 8 => 'h', 9 => 'i', 10 =>\
    \ 'j', 11 => 'k', 12 => 'l', 13 => 'm', 14 => 'n', 15 => 'o', 16 => 'p', 17 =>\
    \ 'q', 18 => 'r', 19 => 's', 20 => 't', 21 => 'u', 22 => 'v', 23 => 'w', 24 =>\
    \ 'x', 25 => 'y' }`. How would I do this with the hash instead of an array? Thanks!\n\
    <|/ c |>\n<| a dscore=3 |>\nAnother nice solution in ruby is using Array#partition:\n\
    <code>\narr.sort.partition{|i| i.to_s !~ /\\d/}.flatten\n</code>\n<|/ a tags=ruby,sorting,arrays,unique\
    \ |>\n<| c |>\nThanks for that solution. I tried to vote up but don't have enough\
    \ reputation points yet.\n<|/ c |>\n<| a tags=ruby,sorting,arrays,unique |>\n\
    Here is one way to do it by counting the number of digits by converting them to\
    \ strings and then counting the number of digits:\n<code>", "    x.sort_by!(&:to_s)\
    \ # Sort the integers\n    x.reject! { |n| n % 2 == 0 }\n    x.each do |n| \n\
    \        if n % 2 == 0 \n            x.delete_at(x) \n        end\n    end\n \
    \   return x\nend", "  x.sort!\n  ret = []\n  \n  x.each do |i|\n    ret = ret\
    \ << i if i.even?\n  end\n  \n  ret\nend\nunique_digits([12, 3, 34, 52, 98])",
  "    x.sort # ascending order\n    x.reverse\n    \n    x.find { |a| a.to_i.to_s.to_i[1..-1].count\
    \ != 0 }\nend\nunique_digits([1, 2, 3, 2])\n=> [1, 2]\n</code>\n<|/ a |>\n<| a\
    \ dscore=2 |>\nYou can try this also,\n<code>", "    digits = x.map {|d| d.to_s.split(//).map\
    \ {|i| i.to_i}.uniq}\n    digits.flatten.sort\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ dscore=1 |>\n<| a |>\nThe solution given by Kent is very good and is very readable\
    \ and very easy to understand.\nBut I prefer to use the sort_by method which gives\
    \ a very clear approach to the problem and can be easily understandable as well.\n\
    <code>", "  sorted = x.sort\n  result = []\n  digits = []\n  x.each do |i|\n \
    \   digits << i.to_s\n  end\n  digits.each do |d|\n    sorted.each do |s|\n  \
    \    result << s unless s.include?(d)\n    end\n  end\n  result.sort!\n  return\
    \ result\nend", "  x.sort!\n  x_res = []\n  x.each_index do |i|\n    x_res <<\
    \ x[i] unless x[i].to_i.odd?\n  end\n  return x_res.sort\nend", "  x.sort.uniq.map\
    \ {|n| n.to_s.chars.map {|c| c.to_i}}.flatten\nend\n</cell>\n<cell>\nunique_digits([23,\
    \ 32, 4, 45, 63, 23, 22])", "  x.sort!\n  result = []\n  x.each do |x|\n    if\
    \ x.even?\n      result << x\n    end\n  end\n  result.sort!\n  return result\n\
    end\nprint unique_digits([123, 234, 345, 456, 567, 678, 890])", "  x.each do |e|\n\
    \    x.each do |f|\n      x.each do |g|\n        x.each do |h|\n          x.each\
    \ do |i|\n            x.each do |j|\n              x.each do |k|\n           \
    \     x.each do |l|\n                  x.each do |m|\n                    x.each\
    \ do |n|\n                      x.each do |o|\n                        x.each\
    \ do |p|\n                          x.each do |q|\n                          \
    \  x.each do |r|\n                              x.each do |s|\n              \
    \                  x.each do |t|\n                                  x.each do\
    \ |u|\n                                    x.each do |v|\n                   \
    \                   x.each do |w|\n                                        x.each\
    \ do |x|\n                                          x.each do |y|\n          \
    \                                  x.each do |z|\n                           \
    \                   x.each do |aa|\n                                         \
    \       x.each do |ab|\n                                                  x.each\
    \ do |ac|\n                                                    x.each do |ad|\n\
    \                                                      x.each do |ae|\n      \
    \                                                  x.each do |af|\n          \
    \                                                x.each do |ag|\n            \
    \                                                x.each do |ah|\n            \
    \                                                  x.each do |ai|\n          \
    \                                                      x.each do |aj|\n      \
    \                                                            x.each do |ak|\n\
    \                                                                    x.each do\
    \ |al|\n                                                                     \
    \ x.each do |am|\n                                                           \
    \             x.each do |an|\n                                               \
    \                           x.each do |ao|\n                                 \
    \                                           x.each do |ap|\n                 \
    \                                                             x.each do |aq|\n\
    \                                                                            \
    \    x.each do |ar|\n                                                        \
    \                          x.each do |as|\n                                  \
    \                                                  x.each do |at|\n          \
    \                                                                            x.each\
    \ do |au|\n                                                                  \
    \                      x.each do |av|\n                                      \
    \                                                    x.each do |aw|\n        \
    \                                                                            \
    \        x.each do |ax|\n                                                    \
    \                                          x.each do |ay|\n                  \
    \                                                                            \
    \  x.each do |az|\n                                                          \
    \                                        x.each do |ba|\n                    \
    \                                                                            \
    \    x.each do |bb|\n                                                        \
    \                                              x.each do |bc|\n              \
    \                                                                            \
    \              x.each do |bd|\n                                              \
    \                                                            x.each do |be|\n\
    \                                                                            \
    \                                x.each do |bf|\n                            \
    \                                                                            \
    \      x.each do |bg|\n                                                      \
    \                                                          x.each do |bh|\n  \
    \                                                                            \
    \                                    x.each do |bi|\n                        \
    \                                                                            \
    \                x.each do |bj|\n                                            \
    \                                                                          x.each\
    \ do |bk|\n                                                                  \
    \                                                      x.each do |bl|\n      \
    \                                                                            \
    \                                        x.each do |bm|\n                    \
    \                                                                            \
    \                            x.each do |bn|\n                                \
    \                                                                            \
    \                  x.each do |bo|\n                                          \
    \                                                                            \
    \          x.each do |bp|\n                                                  \
    \                                                                            \
    \    x.each do |bq|\n                                                        \
    \                                                                            x.each\
    \ do |br|\n                                                                  \
    \                                                                    x.each do\
    \ |bs|\n                                                                     \
    \                                                                   x.each do\
    \ |bt|", "  digits = []\n  x.each do |x| \n    if x.to_s.gsub!(/[^\\d]/, \"\"\
    )\n      digits.push(x.to_s)\n    end\n  end\n  digits.uniq.sort.join(\" \")\n\
    end", "  \nend", "  xs = x.sort\n  odd = []\n  even = []\n  for x in xs\n    unless\
    \ x.to_s.split(\"\").map{|a| a.to_i}.uniq.size == 1\n      odd << x\n    elsif\
    \ x.to_s.split(\"\").map{|a| a.to_i}.uniq.count == 1\n      even << x\n    end\n\
    \  end\n  odd + even.sort\nend", "  x.sort!\n  result = []\n  \n  x.each do |i|\n\
    \    result += x.select {|n| n % i == 0}\n  end\n  result\nend\n</code>\n<|/ a\
    \ |>\n<| c |>\nWhat is the output of your code? Have you tested it?\n<|/ c |>\n\
    <| c |>\nYes, I tested it before answering the question. It worked for me. Try\
    \ it again.\n<|/ c |>\n<| c |>\nFor the input '12343123', the output should be\
    \ [1,2,3,4,3123], which is not the case. The output I get is [1,2,3,4,3,4,3,3,3]\n\
    <|/ c |>\n<| c |>\nI modified my answer. Just use uniq.\n<|/ c |>\n<| c |>\nI\
    \ believe that you should use the `+=` operator instead of `=` because it's faster\n\
    <|/ c |>\n<| a tags=ruby,arrays dscore=0 |>\n<code>\na = ['12', '34', '56', '78',\
    \ '9', '10', '11']\na.group_by { |s| s[/^\\d+/].to_i }.values", "    x.each do\
    \ |x|\n        if x.to_s.chars.count { |c| c =~ /\\A\\D/ } % 2 == 0\n        \
    \    x.to_s.chars.uniq\n        end\n    end\nend", "  x.sort!\n  \n  result =\
    \ []\n  for i in x\n    result << i unless i.to_s.chars.uniq.size > 1\n  end\n\
    \  \n  result\nend", "  return [] if x.empty?\n  hash = {}\n  x.each do |i|\n\
    \    hash[i] = true if hash[i] || !i.odd?\n  end\n  hash.keys.sort\nend", "  \
    \  # write your code here\n    unique_digits = []\n    \n    for i in x \n   \
    \     if i mod 2 != 0 \n            unique_digits << i\n    return unique_digits\n\
    end", " \n    return x \nend", "    sorted = x.sort\n    sorted_even = sorted.select\
    \ { |a| a % 2 == 0 }\n    sorted_odd = sorted.select { |a| a % 2 != 0 }\n    sorted_odd.zip(sorted_even).map\
    \ { |a,b| b if b > a }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nHaven't you\
    \ mentioned that `unique_digits` is your function in the question?\n<|/ c |>\n\
    <| c |>\nYou are right, I hadn't noticed that `unique_digits` is your function.\n\
    <|/ c |>\n<| c |>\nThis would also have worked, if it were not for the fact that\
    \ `unique_digits` was given as a homework assignment and had not been given as\
    \ part of your assignment (which I doubt). :)\n<|/ c |>\n<| c |>\n, Thank you\
    \ for the reminder. :)\n<|/ c |>\n<| c |>\nI see that this is not a homework.\
    \ I'm learning Ruby from the beginning. I'm learning Ruby from Jeff Atwood's Ruby\
    \ book. The book is called Ruby Programming. It's a great book to learn Ruby,\
    \ but I'm a little confused that why doesn't this book teach Ruby from beginning?\n\
    <|/ c |>\n<| a |>\nHere's one way to do it that makes the problem easier:\n<code>",
  "    puts x.sort.map { |i| i.to_s }.uniq.sort.join ','\nend\nunique_digits([\"12\"\
    ,\"23\",\"34\",\"45\",\"56\"])", "  x.sort!\n  return x.select { |num| num.zero?\
    \ } + x.select { |num| num.odd? }\nend", "  x.sort\n  result = []\n  x.each do\
    \ |i|\n    if i.to_s.chars.map(&:to_i).select {|e| e % 2 == 0}.length == 0\n \
    \     result << i\n    end\n  end\n  return result\nend\nunique_digits([23,45,62,73,45,12])",
  "  x.sort.uniq\nend\nunique_digits([2, 5, 13, 22, 34, 55])", " \n    # Your code\
    \ here\n    \n    return \n</cell>\n<text>\nPart 2", "\tx.sort!\n\tx = [x.to_s.chars.map(&:to_i).reduce(:&)].reduce(:|)\n\
    \tx != 0\nend ", "  # TODO: your code here\nend", "  digits = x.map {|n| n % 10\
    \ }\n  unique_digits = digits.uniq\n  unique_digits.sort { |a,b| a <=> b }\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis is an excellent answer.  I wish I could give\
    \ two up votes.\n<|/ c |>\n<| c |>\nGreat answer, +1 from my side.\n<|/ c |>\n\
    <| c |>\nI like this answer and I'm glad to see it's so simple. Can you explain\
    \ a bit what is going on in the second line of the function? I'm new to Ruby and\
    \ would like to learn why it's doing what it's doing.\n<|/ c |>\n<| c |>\nIn the\
    \ second line we're calling `map`, which takes a block, and passes each element\
    \ of the original array into the block. In this case, we're doing `n % 10` on\
    \ each element of the array (i.e. each digit). We then call `uniq`, which returns\
    \ a new array containing only unique items. In Ruby, `uniq` sorts items in ascending\
    \ order, which is why the final line is sorting by the return value of `uniq`\
    \ (i.e. the original digits).\n<|/ c |>\n<| a tags=ruby,arrays,algorithm |>\n\
    <code>", "  x.sort.reverse\n  result = []\n  for i in x\n    next if i.odd?\n\
    \    result << i\n  result\nend", "  result = []\n  x.sort.with_index do |v, i|\n\
    \    if (v % 2 == 0)\n      result << v\n    end\n  end\n  result.sort\nend\n\
    unique_digits([-2, -7, 2, 8, 2, 5, -5, -5, 1])", "  return x.uniq.sort.take_while\
    \ {|e| e.to_s.split(//).map(&:to_i).count { |i| i & 1 == 0 } == 0 }\nend", " \
    \ x.sort!\n  new_array = []\n  new_array << x unless x.size < 2\n  x = x.join\
    \ # make it string before looping\n  x.each_char.with_index do |c,i|\n    if c.to_i\
    \ < 10\n      new_array << c unless new_array.include?(c)\n    end\n  end\n  new_array\n\
    end", "    sorted = x.sort\n    \n    i = 0\n    while i < sorted.length\n   \
    \     \n        if (sorted[i]%2 == 0)\n            # add element to result\n \
    \           sorted.delete(i)\n        elsif (sorted[i] % 2 != 0)\n           \
    \ # increment i\n            i += 1\n        end\n        \n    end\n    return\
    \ sorted\nend", "    unique_digits_hash = {}\n    unique_digits_hash = x.map {\
    \ |n| n.to_s.chars.map{|x| x.to_i}.uniq}.flatten\n    unique_digits_hash.sort!\n\
    end", "  x.sort!\n  ret = []\n  x.each do |x|\n    if x % 2 == 0\n      ret <<\
    \ x\n    end\n  end\n  ret\nend\nunique_digits(1234321)", "    x.sort!\n    s\
    \ = []\n    i = 0\n    while i < x.length\n        digit = x.slice!(i..i).join.to_i\n\
    \        unless s[digit] == nil\n            s[digit] += 1\n        else\n   \
    \         s[digit] = 1\n        end\n        i += 1\n    end\n    \n    # Remove\
    \ elements that has even number of appearance.\n    s.reject! {|k, v| v % 2 ==\
    \ 0}", "  x.sort.delete_if { |e| x.count(e) % 2 == 0 }\n  x\nend", "    digits\
    \ = []\n    x.each do |x|\n        digit = x.to_i\n        x.to_s.each_char do\
    \ |char|\n            next unless char.to_i.even?\n            digits << digit\n\
    \        end\n    end\n    digits.sort\nend\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nNice solution, just one thing, this returns `[1,7,10]` instead of `[2,6,8,9,10]`\n\
    <|/ c |>\n<| c |>\nThanks! I thought this was a trick question, but I see that\
    \ you've already got an answer :-)\n<|/ c |>\n<| a dscore=0 |>\nI thought I should\
    \ post my solution in case someone else has the same issue (I only saw this question\
    \ after I posted my solution).\nFirst of all, here are some more examples of how\
    \ my solution behaves:\n<code>\nunique_digits([10, 9, 8, 7, 9])\n=> [7, 9]", " \
    \ result = []\n  x.each do |e|\n    result << e if e % 2 == 0\n  end\n  result.sort\n\
    end\n</code>\nThen I refactored the code a little bit to make it a bit more readable.\n\
    <code>", "  return x.sort do |i| \n    # loop through the number\n    while x[i].odd?\n\
    \      # if the number is even, remove that digit\n      x[i]=x[i].truncate \n\
    \      # If it has no even digits, add it to the result\n      x.include?(x[i])\
    \ ? x.delete(x[i]) : x[i] << \" \"\n    end\n  end\nend", "  # O(N^2) time complexity\n\
    \  x.sort.each do |i|\n    x.reject! { |e| e % i == 0 } # O(N^2) time complexity\n\
    \  end\n  x\nend\n</code>\n<|/ a tags=algorithm,ruby dscore=0 |>\n<| c |>\nIt\
    \ seems very intuitive. Maybe I'm missing something, but I don't see how the `each`\
    \ loop could finish in less than `O(N^2)` time. `each` just needs to iterate over\
    \ every item in the array, and `reject!` needs to remove every item that satisfies\
    \ the condition. Since `each` is an iterator, I would expect it to eventually\
    \ return the whole array, and it could finish in `O(n)`. I think the question\
    \ is really about how to implement this in Ruby, rather than how to do it as part\
    \ of some general algorithm.\n<|/ c |>\n<| c |>\nYou're right in that it's an\
    \ O(n) operation on the first `each` iteration.  However, `reject!` is O(n) because\
    \ it's iterating through every item in the array as well.  It would be O(n^2)\
    \ if `reject!` was done in O(n).\n<|/ c |>\n<| c |>\n, you are right. I was thinking\
    \ about a general solution and just wrote the code that works for positive integers.\
    \ `reject { |e| e % i == 0}` won't work for negative integers because of the modulo.\
    \ So, I was just thinking about a general solution. I updated the answer and added\
    \ the O(n) solution for negative numbers as well.\n<|/ c |>\n<| c |>\nAwesome,\
    \ thanks! It's interesting to see that my original solution doesn't work for negative\
    \ numbers too.\n<|/ c |>\n<| c |>\n, my original solution works for the negative\
    \ numbers too. So, I'll edit the answer to include the negative numbers solution\
    \ as well.\n<|/ c |>\n<| a tags=algorithm,ruby |>\nIt's possible to do this in\
    \ linear time using bitwise logic to identify the integers whose digits are even.\
    \  For each integer, find the first power of 2 that's evenly divisible by that\
    \ integer.  Once you find the first power of 2 that's evenly divisible by that\
    \ integer, you can increment the count of integers whose digits are evenly divisible\
    \ by that integer.  After you have finished counting, you have the answer.\n<|/\
    \ a dscore=0 |>\n<| a tags=algorithm,ruby |>\nJust another solution with no loops\
    \ at all, but rather with recursion.\n<code>", "  x.sort!\n  \n  result = []",
  "    x.sort_by(&:to_i) #sort the array\n    x.select {|x| x.odd? } #select elements\
    \ with even digit\nend\n</code>\n<|/ a |>\n<| c |>\nThis isn't what the question\
    \ asked. I guess you meant `x.select {|x| x.odd? }` (no trailing `?`), otherwise\
    \ you wouldn't be able to return an array.\n<|/ c |>\n<| c |>\nThanks for your\
    \ comment, I just corrected my answer\n<|/ c |>\n<| c |>\nWhat about negative\
    \ numbers?\n<|/ c |>\n<| a |>\n<code>", "  x.uniq.sort\nend", "  x.sort!\n  ret\
    \ = []\n  while x\n    idx = x.index(0)\n    ret.push x[idx] if idx != 0 && x[idx\
    \ - 1] % 2 == 0\n    x.delete_at(x[idx])\n  end\n  ret\nend", "    x.sort.each\
    \ do |i|\n        next if i.to_s.chars.uniq.count != 1\n        puts \"#{i} has\
    \ #{i.to_s.chars.uniq.count} unique digits\"\n    end\nend", "    return x.map\
    \ {|y| y % 10 }.select {|y| y % 2 == 0 }.sort\nend\n</code>\n<|/ a tags=arrays,ruby,sorting\
    \ |>\n<| a |>\n<code>\narray1 = %w[1 2 3 4 5 6 7 8 9 10] \narray2 = %w[2 4 6 8\
    \ 10 12 14 16 18 20]\narray3 = %w[3 5 7 9 11 13 15 17 19 21]\narray4 = %w[4 6\
    \ 8 10 12 14 16 18 20]\narray5 = %w[5 6 8 10 12 14 16 18 20]\narray6 = %w[6 8\
    \ 10 12 14 16 18 20]\narray7 = %w[7 8 10 12 14 16 18 20]\narray8 = %w[8 10 12\
    \ 14 16 18 20]\narray9 = %w[9 10 12 14 16 18 20]", "  return x.inject([]) { |a,\
    \ e| a << (e % 2 == 0 ? e : a) }\nend", "  x.sort.uniq { |z| (z % 10).zero? }\n\
    end", "  return x.select { |y| y % 2 == 0 }\nend\n</code>\nSolution 2\n<code>",
  "   p =x.clone\n   p.sort_by!{|e| e % 10}\n   p.reject!{|e| e.odd?}\n   p.uniq\n\
    end\n</code>\n<|/ a tags=ruby,list |>\n<| a dscore=2 tags=ruby,list |>\n<code>\n\
    nums.sort.uniq.select{ |x| x.to_s(2).size != 1 }\n</code>\n<|/ a |>\n<| a tags=ruby,list\
    \ |>\n<code>\n[1,2,3,4,5,6].select { |e| e.to_s.count =~ /^\\d\\d$/ }\n=> [1,\
    \ 5]\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "  x.map!{|v| v.to_i}\n  x.sort!\n\
    \  x.select{|v| v.to_i%2 == 0}\nend", "  uniques = []\n  x.each do |x|\n    if\
    \ x.to_s.chars.map(&:to_i).uniq.size == 1\n      uniques << x\n    end\n  end\n\
    \  uniques.sort!\n  return uniques\nend\n</cell>\n<cell>\nunique_digits([1,234,23,32,12])\n\
    </cell>\n<cell>", "    x.sort!\n    x.reject!{ |n| n % 2 == 0 }\n    return x\n\
    end", " \n\t# your code goes here\n\tresult = []\n\t\n\tx.each_with_index { |i,\
    \ index|\n\t\n\t\tif i.to_s.split(\"\").uniq.count == 1\n\t\t\tresult << i\n\t\
    \tend\n\t}\n\t\n\tresult.sort!\n\t\n\treturn result\nend", "  x.sort.each do |e|\n\
    \    if e % 2 == 0\n      x.delete(e)\n    end\n  end\n  x\nend", "  digits =\
    \ x.select { |n| n.to_s.chars.uniq.count == 1 }\n  digits.sort.uniq\nend", " \
    \ x.sort! # Sorted array\n  result = []\n  x.each do |i|\n    if i.to_s.chars.any?(&:odd?)\n\
    \      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=ruby,algorithm,performance,sorting,ruby-on-rails |>\nThis solution avoids\
    \ converting the integers to strings and converting the strings to integers twice\
    \ (which is what gave me the performance issue), also avoids any calls to uniq\
    \ (which kills performance on a large array):\n<code>", "  digits = x.map { |x|\
    \ x.to_s.split(//).uniq.size }\n  digits = digits.reduce(:+)\n  digits = Array.new(digits)\
    \ { |e, i| e + x[(i/2).ceil].to_i }\n  digits.sort\nend\n</code>\n<|/ a dscore=1\
    \ tags=arrays,ruby |>\n<| a dscore=1 |>\nI believe a one-liner method like this\
    \ would do the job:\n<code>", "  x.sort!\n  result = []\n  for i in 0..x.size\n\
    \    next if x[i]%2 == 0\n    result << x[i]\n  end\n  result\nend\nputs unique_digits([8,8,2,7,8,8,7,8,8,2,8])",
  "  return x.select(&:odd?).sort.uniq\nend\n</code>\n<|/ a dscore=2 tags=ruby,performance,algorithm\
    \ |>\n<| c |>\nWhy not `x.select(&:odd?).sort.uniq`?\n<|/ c |>\n<| c |>\nThanks\
    \ :)\n<|/ c |>\n<| a dscore=2 |>\nIf this was in Python I would use a dictionary\
    \ to do the lookups, something like:\n<code>", "  return x.select{|y| y.to_i.to_s\
    \ == y.to_s.chars.sort.join.to_s}\nend", "  x.sort!\n  result = []\n  x.each do\
    \ |n|\n    if n % 2 == 0\n      result << n\n    end\n  end\n  result\nend", " \
    \ x.sort!\n  x = x.map {|i| i.to_i}\n  res = []\n  x.each_with_index do |v, i|\n\
    \    unless v % 2 == 0 && v.to_s.chars.uniq.count == 1 res<< v.to_s end\n  end\n\
    \  res\nend\nunique_digits([1, 2, 3, 1, 2, 5, 9])\n  #=> [1, 3, 9, 5, 2] \n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 tags=arrays,ruby,algorithm,sorting,ruby-on-rails\
    \ |>\nI do not know Ruby, but how about this..\n<code>", "    x.uniq!\n    x.select{\
    \ |e| e%2 == 0 }.sort\nend", "    x.sort!\n    ans = []\n    for i in x\n    \
    \    next if i % 2 == 0\n        ans.push i\n    ans\nend\n</code>\n<|/ a dscore=0\
    \ tags=ruby,arrays,algorithm |>\n<| a dscore=0 |>\n<code>\nnums.map{|a| a.to_s.chars.uniq.join}.compact.sort.uniq\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| a dscore=0 |>\n<code>\nx = []\n\
    [2,4,5,5,6].each {|i| x << i.to_s }\nx.sort!\nx.uniq! # uniq! to remove the duplicates\n\
    x\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| a dscore=0 |>\nThis would\
    \ be my solution:\n<code>", "   result = []\n   x.each do |i|\n      while i.to_s.reverse!.each_char.uniq.count\
    \ % 2 == 0\n         result << i\n         i += 1\n      end\n   end\n   return\
    \ result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays dscore=0\
    \ |>\nTry this:\n<code>", "  x.sort!\n  unique_digits_list = []\n  unique_digits_list.push(x[0])\
    \ \n  x = x.join.to_i\n  while x > 0\n    digit = x % 10\n    unique_digits_list.push\
    \ digit\n    x = x / 10\n  end\n  unique_digits_list.sort!\nend\nunique_digits(['12',\
    \ '123', '0', '1', '34']) # => [\"1\", \"2\", \"3\", \"0\"]", "  x.sort!\n  res\
    \ = []\n  x.each do |i|\n    res << i if i.to_s.split(//).to_a.reduce(:+) % 2\
    \ == 0\n  end\n  res\nend", "\tx.sort\n\tresult = x.select { |x| x.to_s.split(\"\
    \").map(&:to_i).uniq.size == 1 }\n\tresult.sort\nend", "    x.sort\n    unique_digits\
    \ = []\n    unique_digits = [].each do |x|\n      unless x.to_s.chars.map { |c|\
    \ c.to_i}.uniq.count == 1\n        unique_digits << x\n      end\n    end\n  \
    \  unique_digits\nend\n</code>\nI suggest you to read this link: http://betterlogic.com/roger/2009/01/15/the-best-way-to-do-your-homework-part-2\n\
    <|/ a tags=ruby dscore=2 |>\n<| a tags=ruby |>\n<code>\narray = [1,3,5,7,9,11,13,17]",
  "  x.sort!\n  result=[]\n  i=0\n  while i<=x.size\n    if x.at(i)%2 == 0\n     \
    \ result.push x.at(i)\n    end\n    i+=1\n  end\n  return result\nend", "  x.sort.map{|i|\
    \ i if i =!0 && (i.to_s.chars.map(&:to_i).uniq.count > 0)}\nend\n</code>\n<|/\
    \ a tags=ruby-on-rails,ruby |>\n<| a tags=ruby-on-rails,ruby dscore=1 |>\nIn case\
    \ you wanna do it in one line\n<code>", "  result = x.select {|i| i =~ /\\d/ }\n\
    \  result.uniq\nend\n</code>\nTest Results\n<code>", "  x.map { |x| x.to_s.split('').uniq.size\
    \ }.uniq\nend\n</code>\n<|/ a tags=arrays,ruby,sorting |>\n<| a dscore=0 tags=arrays,ruby,sorting\
    \ |>\nHere's a solution without regular expressions:\n<code>", "  x.select { |x|\
    \ x.to_s.chars.uniq.size % 2 == 0 }\nend\n</code>\n<code>\n> unique_digits([-1,\
    \ 2, 3, 456, 1])\n=> [1, 3, 5, 456, 2]\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ answer the question. Also, you're sorting before filtering out the digits.\n\
    <|/ c |>\n<| c |>\nThank you. Updated my answer. Do you think it still not meets\
    \ your expectations?\n<|/ c |>\n<| c |>\nWhat does the first line `x.select {\
    \ |x| x.to_s.chars.uniq.size % 2 == 0 }` do?\n<|/ c |>\n<| c |>\nit selects only\
    \ the odd numbers from the collection\n<|/ c |>\n<| c |>\nThanks again. Can you\
    \ please explain me the function of **select** statement in ruby?\n<|/ c |>\n\
    <| a |>\nHere's a solution that uses Ruby's Enumerable#slice_before method and\
    \ Enumerable#reject method.\n<code>", "  # write your code here\n  return x\n\
    end\nprint unique_digits([10, 10, 15, 20, 35])", "  x.sort_by { |i| i }\n  result\
    \ = []\n  i = -1\n  x.each do |num|\n    i += 1\n    if num.to_s[0..1].to_f %\
    \ 2 != 0\n      result << num\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  x.map!{|i| i.to_s.split('').map{|s| s.split('').reduce(0)\
    \ {|r,c| r + if c.to_i.even? then 1 else 0 end}}.sort_by{|i| i}.uniq}\nend\nunique_digits([2,4,6,8,10,12,14,16,18,20])\n\
    \ => [6,8,10,12,14,16,18,20]\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "  x.map!(&:to_i)\n  x.sort\n  x.find_all { |v| x % 10 == 0 }\nend\n</code>\n<|/\
    \ a dscore=3 |>\n<| a tags=ruby |>\nThis solution uses the Ruby inject method,\
    \ to go from your list of numbers into an array of the digits. Then, it does a\
    \ quick scan to see how many times each digit occurs. And then it just takes the\
    \ max of those digits. \n<code>\nnumbers = [979, 511, 451, 353, 123]\ndigits.inject([])\
    \ do |memo, digit| \n  memo << digit if numbers.count(digit) == numbers.uniq.count\n\
    \  memo\nend", "  return x.select { |n| n % 10 != 0 }.sort.map(&:to_s).join('')\n\
    end", "  return x.reduce(:<<).\n    select {|i| i =~ /\\d/ && i != i.to_i }.\n\
    \    sort {|a,b| a.to_i < b.to_i }.\n    uniq \nend", "  x.sort!\n  unique_digits\
    \ = []\n  unique_x = []\n  x.each do |x|\n    x.to_s.each_char.select { |i| i.to_i\
    \ >= 10 }\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for your solution. I\
    \ know about uniq, and sort, but didn't think about them together. Do you think\
    \ it would work if I added a method to check if the number is even or odd? Like\
    \ so:", "    \n    x.sort\n    \n    n.times do\n        x.delete_at(0)\n    end\n\
    \    \n    x.sort\n    \n    puts x.inspect\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
