name: HumanEval_24_largest_divisor
language: rb
prompt: "# For a given number n, find the largest number that divides n evenly, smaller\
  \ than n\ndef largest_divisor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_divisor\n\
  \    candidate = method(:largest_divisor)\n    assert_equal(1, candidate.call(3))\n\
  \    assert_equal(1, candidate.call(7))\n    assert_equal(5, candidate.call(10))\n\
  \    assert_equal(50, candidate.call(100))\n    assert_equal(7, candidate.call(49))\n\
  \  end\nend\n"
completions: ["  largest_divisor = nil\n  largest_divisor_number = nil\n  n.times\
    \ do |i|\n    number = n % i\n    if (number == 0)\n      return i\n    elsif\
    \ (number > largest_divisor)\n      largest_divisor = number\n      largest_divisor_number\
    \ = i\n    end\n  end\n  largest_divisor_number\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nCan you explain more your solution?\n<|/ c |>\n<| c |>\nYes, I\
    \ will add more descriptions to my solution.\n<|/ c |>\n<| a |>\nOne way to do\
    \ this is to use the formula for the greatest common divisor of 2 numbers - LCM(m,\
    \ n) where m is your starting number, and n is the end number.\nTo find the LCM\
    \ of 2 numbers, you can use the following algorithm:\n<code>", "\tnumDivisors\
    \ = 0\n\tlargestDivisor = 0\n\twhile n > 1\n\t\tnumDivisors += 1\n\t\tn /= 2\n\
    \tend\n\tlargestDivisor = n \n\tnumDivisors -= 1\n\twhile numDivisors > 0\n\t\t\
    if n%largestDivisor == 0\n\t\t\tlargestDivisor = largestDivisor + 1\n\t\tend\n\
    \t\tnumDivisors -= 1\n\tend\n\tlargestDivisor\nend", "  1.upto(sqrt(n).ceil) {\
    \ |i| break if n % i == 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nYour code fails\
    \ for large `n`: `largest_divisor(10**15)` returns `10` and that number is clearly\
    \ not evenly divisible.\n<|/ c |>\n<| c |>\n, I'm afraid that depends on the definition\
    \ of \"evenly divisible\" in the OP's case. Let's see if I can come up with a\
    \ more general solution.\n<|/ c |>\n<| c |>\nI believe that you can solve this\
    \ with dynamic programming: `def largest_divisor(n); 1.upto(sqrt(n).ceil) { |i|\
    \ break if n % i == 0 }; end`\n<|/ c |>\n<| c |>\n, I've just edited my answer\
    \ to include a more general solution that works for any even divisor.\n<|/ c |>\n\
    <| c |>\n, that's a great idea, thanks.\n<|/ c |>\n<| a tags=ruby,math dscore=3\
    \ |>\nFor a number that is a multiple of the greatest common divisor (GCD) of\
    \ two numbers, you can calculate its GCD by taking the GCD of the numbers in reverse\
    \ order.  This is more or less the solution given by Henrik.\nIt can be written\
    \ as a formula using Euclid's algorithm, which is more efficient than the method\
    \ given in Henrik.\n<code>", "    largest_divisor = 2\n    largest_divisor_factor\
    \ = 2\n    largest_divisor_counter = 0", "  n.to_s.split('').sort.reduce(:*)\n\
    end", "  # Write your code here\nend", "  if n < 2\n    return n\n  else\n   \
    \ div = nil\n    while true\n      d = n % 10\n      n = n / 10\n      if d >\
    \ 0 && n % d == 0\n        if d == 1\n          div = d\n          break\n   \
    \     else\n          div = d\n        end\n      else\n        if d > 0 && n\
    \ % d == 0\n          div = d\n          break\n        else\n          break\n\
    \        end\n      end\n    end\n  end\nend", "  # Write your code here.\n  i\
    \ = 2\n  while i <= n\n    if n % i == 0\n      n\n    else\n      i += 1\n  \
    \  end\n  end\nend", "    largest_divisor_n = 0\n    if n%3 == 0: largest_divisor_n\
    \ = n%3\n    if n%5 == 0: largest_divisor_n = n%5\n    if n%7 == 0: largest_divisor_n\
    \ = n%7\n    if n%9 == 0: largest_divisor_n = n%9\n    if n%11 == 0: largest_divisor_n\
    \ = n%11\n    if n%13 == 0: largest_divisor_n = n%13\n    if n%15 == 0: largest_divisor_n\
    \ = n%15\n    if n%17 == 0: largest_divisor_n = n%17\n    if n%19 == 0: largest_divisor_n\
    \ = n%19\n    if n%21 == 0: largest_divisor_n = n%21\n    if n%23 == 0: largest_divisor_n\
    \ = n%23\n    if n%25 == 0: largest_divisor_n = n%25\n    if n%27 == 0: largest_divisor_n\
    \ = n%27\n    if n%29 == 0: largest_divisor_n = n%29\n    if n%31 == 0: largest_divisor_n\
    \ = n%31\n    if n%33 == 0: largest_divisor_n = n%33\n    if n%35 == 0: largest_divisor_n\
    \ = n%35\n    if n%37 == 0: largest_divisor_n = n%37\n    if n%39 == 0: largest_divisor_n\
    \ = n%39\n    if n%41 == 0: largest_divisor_n = n%41\n    if n%43 == 0: largest_divisor_n\
    \ = n%43\n    if n%45 == 0: largest_divisor_n = n%45\n    if n%47 == 0: largest_divisor_n\
    \ = n%47\n    if n%49 == 0: largest_divisor_n = n%49\n    if n%51 == 0: largest_divisor_n\
    \ = n%51\n    if n%53 == 0: largest_divisor_n = n%53\n    if n%55 == 0: largest_divisor_n\
    \ = n%55\n    if n%57 == 0: largest_divisor_n = n%57\n    if n%59 == 0: largest_divisor_n\
    \ = n%59\n    if n%61 == 0: largest_divisor_n = n%61\n    if n%63 == 0: largest_divisor_n\
    \ = n%63\n    if n%65 == 0: largest_divisor_n = n%65\n    if n%67 == 0: largest_divisor_n\
    \ = n%67\n    if n%69 == 0: largest_divisor_n = n", "  largest_divisor_number\
    \ = nil\n  n.times do |i|\n    break if n % i == 0\n    largest_divisor_number\
    \ = i if largest_divisor_number.nil? || largest_divisor_number > i\n  end\n  largest_divisor_number\n\
    end", "  numbers = n.to_s.chars\n  numbers.each do |number|\n    if number.to_i\
    \ == 1\n      return n\n    elsif number.to_i/2\n      return number if numbers.count(number.to_i)\
    \ > 1\n    end\n  end\nend", "  largest_divisor_count = 0\n  largest_divisor =\
    \ 0", "  divisors = 0\n  number = 1\n  while number * divisor < n\n    divisors\
    \ += 1\n    number = number * 2\n  end\n  divisors\nend", "  largest_divisor =\
    \ BigDecimal.new(\"0\")\n  n.times do |i|\n    if n % i == 0\n      largest_divisor\
    \ = i\n    end\n  end\n  largest_divisor\nend", "  max_divisor = 0\n  max_divisor_num\
    \ = 0\n  while n > max_divisor\n    divisor_num = 1\n    while n % divisor_num\
    \ == 0\n      divisor_num += 1\n    if divisor_num > max_divisor_num\n      max_divisor\
    \ = divisor_num\n      max_divisor_num = divisor_num\n    end\n    n = (n / max_divisor)\n\
    \  end\n  max_divisor_num\nend", "  1.upto(n) do |x|\n    return x if n % x ==\
    \ 0\n    break if x == n\n  end\nend", "  div = 0\n  for i in [2,3,5,7...sqrt(n)]\n\
    \    if n % i == 0\n      div = i\n    end\n  end\nend", "    div = 0\n    # initialize\
    \ max number as the largest number\n    max.to_s # max is a string so convert\
    \ to int to compare\n    n.to_i # n is a string so convert to int to compare\n\
    \    # loop through number until max is found\n    while n != div\n    # find\
    \ the first number that is less than or equal to n and greater than n\n      \
    \  div = (div + n).to_i # div is a int and so is n so no conversion is needed\n\
    \        max.to_i # max is a string so convert to int to compare\n    end\nend",
  '    divisors = []', "    n.to_s.split(//).reduce(:+).to_i\nend", "    largest =\
    \ 0\n    while n % 2 == 0\n        n /= 2\n        if n > largest\n          \
    \  largest = n\n    end\n    n -= 1\n    while n % 2 == 0\n        n /= 2\n  \
    \  end\n    if n > largest\n        largest = n\n    end\n    largest\nend", " \
    \ max_factor = 1\n  max_factor = (1..n).max_by { |e| (1..n).detect { |e| e % e\
    \ == 0 } } \n  max_factor\nend", "\tnums = []\n\tfor i in (0..n-1)\n\t\tnums <<\
    \ i if n % i == 0\n\tnums.sort\n\tnums.last\nend", "    divisors = []\n    (1..n).each\
    \ { |i| divisors.push(i) }\n    divisors.sort! { |a,b| a <=> b }\n    largest_divisor\
    \ = divisors.first\nend\n</code>\n<|/ a tags=algorithm,ruby |>\n<| a tags=algorithm,ruby\
    \ |>\nI have come up with something similar to what you are looking for, I hope\
    \ it helps:\n<code>", "    if n % 2 == 0\n        largest_divisor_1 = n\n    \
    \    largest_divisor_2 = n\n    else\n        largest_divisor_1 = largest_divisor_2\
    \ = n\n    end\n    count = 0\n    while largest_divisor_1\n        if largest_divisor_1\
    \ % 2 == 0\n            largest_divisor_1 = largest_divisor_1 / 2\n        else\n\
    \            largest_divisor_1 = largest_divisor_1 / 2\n            largest_divisor_2\
    \ = largest_divisor_2 / 2\n        end\n        count += 1\n    end\n    return\
    \ largest_divisor_1\nend", "  # Write your code here\n  n.times do |i|\n    largest_divisor_i\
    \ = (n%i).ceil\n    if largest_divisor_i == n\n      largest_divisor_i\n    end\n\
    \  end\nend", "  largest_divisor = n.downto(1)\n  largest_divisor << 1\n  largest_divisor.downto(2)\
    \ do |divisor|\n    return divisor if divisor % n == 0\n  end\nend", "  divisor\
    \ = 1\n  largest_divisor = 0\n  remainder = n\n  while remainder != 1\n    divisor\
    \ = divisor+1\n    if remainder % divisor == 0\n      largest_divisor = divisor\n\
    \    end\n    remainder = remainder / divisor\n  end\n  return largest_divisor\n\
    end\n</cell>\n<cell>", "\tdivisors = Array.new(n)\n\tn.downto(1) { |i| divisors[i]\
    \ = i }\n\tn.times do |i|\n\t\tdivisors[i] = n[i.to_i] if (divisors[i] % 2) ==\
    \ 0\n\tend\n\tdivisors.max\nend", "  # Initialize max_divisor\n  max_divisor =\
    \ 1", "  largest_divisor = n\n  largest_divisor_so_far = n.to_s.to_i\n  n.downto(1).each\
    \ do |i|\n    if n % i == 0\n      if i > largest_divisor_so_far\n        largest_divisor\
    \ = i\n        largest_divisor_so_far = i\n      end\n    end\n  end\n  largest_divisor\n\
    end", "  divisor_num = 1\n  while divisor_num <= n\n    if n % divisor_num ==\
    \ 0\n      break\n    divisor_num += 1\n  end\n  return divisor_num\nend", " \
    \ result = 0\n  n.times do |i|\n    result += i if i % 2 != 0\n    result -= i\
    \ if i % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>",
  "    largest = 1\n    div = 1\n    while n % div != 0\n        div += 1\n    while\
    \ div > 1\n        if n % div == 0\n            largest += div\n        div -=\
    \ 1\n    return largest", "    i = 2\n    while (i <= n/2)\n        if (n % i\
    \ == 0)\n            return i\n        i += 1\n    return n\nend", "  # Initialize\
    \ the variable d\n  d = 0\n  # Initialize a list of d integers\n  divisors = []\n\
    \  # While d less than n, find the smallest number that divides n evenly, and\
    \ add it to divisors\n  while d < n\n    # Divide n by d\n    d = n/d\n    # Add\
    \ d to divisors\n    divisors << d\n  end\n  # Return the largest of divisors\n\
    \  return divisors.max\nend", "  if n == 1\n    return n\n  else\n    largest_divisor\
    \ = largest_divisor(n / 2)\n    return if n % largest_divisor == 0\n  end\nend",
  "  largest_divisor_count = 0\n  n.times { |i| largest_divisor_count = i if n % i\
    \ == 0 } #the if statement basically says \"if i is a divisor of n\", and if not,\
    \ continue with the next number\n  return n\nend", "    divisors = []\n    divisors.push\
    \ 1", "\tlargest_divisor = 0\n\tfor i in 1..n\n\t\tif n % i == 0\n\t\t\tlargest_divisor\
    \ = i\n\t\tend\n\tend\n\tlargest_divisor\nend", "  largest_divisor = nil\n  divisors\
    \ = [1,3,5,7,9]\n  for i in divisors\n    if n % i == 0\n      largest_divisor\
    \ = i\n      break\n  end\n  return largest_divisor\nend", "  max = n\n  1.upto(Math.sqrt(n))\
    \ {|d| max = n if n % d == 0}\n  max\nend\n</code>\n<|/ a tags=ruby |>\n<| a |>\n\
    <code>", "  largest_div = nil\n  divisor = 2", "    factors = []\n    factor =\
    \ 1\n    while factor != n\n        if n % factor\n            factors\n     \
    \   else \n            factors = factors + factor\n        end\n    end\n    factors\n\
    end\n</cell>\n<code language=julia-1.5>\nlargest_divisor(9)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(10)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(11)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(12)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(13)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(14)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(15)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(16)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(17)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(18)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(19)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(20)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(21)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(22)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(23)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(24)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(25)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(26)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(27)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(28)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(29)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(30)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(31)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(32)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(33)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(34)\n</cell>\n<code language=julia-1.5>\nlargest_divisor(35)\n\
    </cell>\n<code language=julia-1.5>\nlargest_divisor(36)\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(", "    largest_divisor = n # initialize to n\n    while n % 2\
    \ == 0 and n > 1 \n        n = n/2 # reduce the number by dividing by 2 while\
    \ still greater than 1\n        largest_divisor = largest_divisor if n < largest_divisor\
    \ else n # keep track of largest divisor so far\n    \n    largest_divisor = largest_divisor\
    \ if n < largest_divisor else n # keep track of largest divisor so far\n    return\
    \ largest_divisor", "    i = 2\n    largest_divisor = 1\n    while i <= n\n  \
    \      if n % i == 0\n            largest_divisor = i\n            i += 1\n  \
    \      else\n            i += 1\n    end\n    largest_divisor\nend\n</cell>\n\
    <cell>", "  divisors = []\n  (1..n).each do |num|\n    (num - 1).times do\n  \
    \    divisors.unshift(num % 2)\n    end\n  end\n  divisors.max\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nNice solution, though I'd use `(1..n).to_a` to avoid\
    \ all the allocations.\n<|/ c |>\n<| c |>\n`(1..n).to_a` is slower than `(1..n).each`,\
    \ because `each` has to allocate an array.\n<|/ c |>\n<| c |>\n: I haven't looked\
    \ at the implementation, but I imagine it's doing the same thing.\n<|/ c |>\n\
    <| c |>\n`each` doesn't have to allocate an array either. Ruby 1.9 introduced\
    \ `each` with a block in which it returned a value (similar to `each` with a block\
    \ in which it returned a value).\n<|/ c |>\n<| c |>\n: I haven't looked at the\
    \ implementation, but I imagine it creates a new array and loops through each\
    \ number. I'd be surprised if the `each` implementation did any better.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nHere's a way to do it without an explicit loop:\n<code>\n\
    (1..n).reduce(:lcm).to_i # n! / gcd(n!, 2)\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\nIt's worth noting that this is also not O(n).\n<|/ c |>\n<| a tags=ruby\
    \ |>\nHere's my solution in Ruby 1.8.7 and up:\n<code>", "  result = nil\n  n.times\
    \ do |i|\n    if i%2 != 0 && i%3 == 0 && i%5 == 0 && i%7 == 0 \n      result =\
    \ i\n    end\n  end\n  result\nend", "  divisor = 0\n  for i in [1..n]\n    divisor\
    \ = i\n    if n % i == 0 then\n      divisor = nil\n      break\n  end\nend\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\nMy solution is:\n<code>", "  divisors = []\n\
    \  divisor = 1\n  while divisors.length < n\n    divisor = divisor * 2 while divisor\
    \ < n\n    divisors << divisor\n  end\n  divisors.max\nend", "  largest_divisor\
    \ = 1\n  i = 2\n  while i * i < n\n    i += 1\n    if n % i == 0\n      largest_divisor\
    \ = i\n    end\n  end\n  largest_divisor\nend", "  largest = 0\n  divisor = 0\n\
    \  \n  for i in 1...n do\n    if n % i == 0\n      divisor = i\n      largest\
    \ = n\n    elsif largest * divisor > n\n      divisor = i\n      largest = n\n\
    \    end\n  end\n  largest\nend", "  number_to_check_for_largest_divisor = n\n\
    \  while number_to_check_for_largest_divisor != 0\n    number_to_check_for_largest_divisor\
    \ = number_to_check_for_largest_divisor / 2 # Find the largest divisor smaller\
    \ than n\n  end\n  number_to_check_for_largest_divisor\nend", "    max = n\n \
    \   div = 2\n    while div < n\n        if n % div == 0\n            max = div\n\
    \            break\n        div += 1\n    return max\nend", "  max_div = 0\n \
    \ max_div2 = 1\n  n.times { |i| max_div = max_div.odd? ? max_div : max_div2.even?\
    \ ? max_div : max_div2 }\n  max_div\nend", "    return n.bit_length <= n ? (n/n).floor\
    \ : 1\nend", "  # Check if n is even or not\n  if n % 2 == 0\n    return n\n \
    \ # Otherwise, divide the number by 2\n  else\n    return largest_divisor(n /\
    \ 2)\nend", "  divisor = 0\n  while n % divisor == 0\n    divisor+=1\n  divisor\n\
    end\n</code>\n<|/ a tags=ruby,algorithm dscore=3 |>\n<| c |>\nThis doesn't give\
    \ the largest number that divides n evenly, but rather gives the largest number\
    \ that divides n evenly enough that it would yield n if n is evenly divisible\
    \ by all numbers from 1 to n-1.\n<|/ c |>\n<| a dscore=2 tags=ruby,algorithm |>\n\
    Here's a solution I put together:\n<code>", "  # Write your code here\n  return\
    \ n.to_s.split(//).max {|i| (i%2 == 0) && (i).to_i > n }\nend", "  divisor = divisors_of(n)\n\
    \  divisor[divisor.rindex { |x| x % 2 == 0 }] = nil", "  if n % 2 == 0\n    return\
    \ n / 2\n  else\n    prime_array = (1..n).to_a\n    prime_array.delete_if do |i|\n\
    \      i.remainder(2) != 0\n    end\n    prime_array.reduce(:+)\n  end\nend",
  "  # Create a number array\n  nums = []\n  # Loop through the numbers between 1\
    \ and n\n  (1..n).each { |i| nums.push(i) }\n  # Start building the list of possible\
    \ divisors\n  divisors = []\n  # Loop through the possible divisors\n  nums.each\
    \ { |i| divisors.push(i / nums.last) }\n  # Return the largest one\n  divisors.max\n\
    end\n</cell>\n<code language=rb-app>", "  return n.times.reduce(:*)\nend", " \
    \   n.to_s.chars.reduce(:divmod).max_by { |div, mod| mod }[1]\nend", "  divisor\
    \ = 1\n  max_divisor = 1\n  while divisor <= n\n    if n % divisor == 0\n    \
    \  max_divisor = divisor\n    end\n    divisor += 1\n  end\n  return max_divisor\n\
    end", "  largest_divisor = 0\n  divisor = 1\n  while n > 1\n    n /= divisor\n\
    \    if n % 1 == 0\n      break\n    largest_divisor = divisor\n    divisor +=\
    \ 1\n  end\n  largest_divisor\nend\n</cell>\n<code language=conda-root-py>\nlargest_divisor\
    \ 6\n</cell>\n<code language=conda-root-py>\nlargest_divisor 7\n</cell>\n<text>\n\
    Exercise 7\nWrite a function that counts the number of digits in an integer. Given\
    \ a non-negative integer, repeatedly divide it by 10 until the quotient is a whole\
    \ number. If it is an exact division between two integers, return 1 followed by\
    \ n-1 zeros (where n is the number of times the division occurred).", "  max =\
    \ n\n  div = 1\n  while div <= n\n    div = div + 1\n    if div > n\n      max\
    \ = div\n    end\n  end\n  max\nend", "  if n % 2 == 0\n    return 2\n  else\n\
    \    n -= 1\n    i = 2\n    while i*i <= n\n      i += 1\n    \n    return i if\
    \ n % i == 0 else i-1\nend", "  divisors = []\n  i = 1\n  while i <= n do\n  \
    \  if n % i == 0 then\n      divisors.push(i)\n      n = n / i\n    end\n    i\
    \ = i + 1\n  end\n  \n  if n > 1 then\n    divisors.push(n)\n  end\n  \n  divisors.max\n\
    end\n</cell>\n<code language=julia-0.5>\nlargest_divisor(24)\n</cell>\n<code language=julia-0.5>\n\
    largest_divisor(19)\n</cell>\n<text>\nExercise: Find the largest prime factor\
    \ of 19", "  largest = 0\n  largest2 = 0\n  while n > 1\n    largest2 = largest2\n\
    \    largest = n / largest2\n    n -= largest\n  end\n  return largest\nend",
  "    large_divisor = 1\n    large_divisor_factor = 1", "    \n    # Base case\n\
    \    return 1 if n == 0 else n % 6\n    \n    # Recursive case\n    \n    # If\
    \ the number is odd\n    if n % 2 == 1\n        return n\n    \n    # Otherwise,\
    \ divide it by 2 and call it recursively on the resulting number\n    else\n \
    \       return largest_divisor(n / 2)\n    \n</cell>\n<cell>\nlargest_divisor(144)\n\
    </cell>\n<cell>\nlargest_divisor(150)\n</cell>\n<cell>\nlargest_divisor(20)\n\
    </cell>\n<cell>\nlargest_divisor(100)\n</cell>\n<cell>\nlargest_divisor(10)\n\
    </cell>\n<cell>\nlargest_divisor(100)\n</cell>\n<cell>\nlargest_divisor(20)\n\
    </cell>\n<cell>\nlargest_divisor(1000)\n</cell>\n<text>\nWrite a function that\
    \ accepts an integer and returns true if the number is odd or false if even.",
  "  for i in [1..n]\n    if n % i == 0\n      return i\n  end\nend\n</cell>\n<text>\n\
    We will now define a function that determines the number of prime factors of a\
    \ given number.", "  largest_divisor = nil\n  n.times do |i|\n    if (n % i) ==\
    \ 0 && i != 1\n      largest_divisor = i\n      break\n    end\n  end\n  largest_divisor\n\
    end", "\t\n\t# Step 1: initialize a maximum integer that divides n evenly\n\t\
    maximum_divisor = 1\n\t\n\t# Step 2: iterate over all integers greater than or\
    \ equal to n\n\tfor i in 2..(n/2)\n\t\t# Step 3: check if the integer divides\
    \ n evenly\n\t\tif (n%i) == 0\n\t\t\t# Step 4: if it does, update maximum_divisor\n\
    \t\t\tmaximum_divisor = i\n\t\t\t\n\t# Step 5: return the maximum_divisor\n\t\
    return maximum_divisor\nend\n</cell>\n<code language=julia-1.1>\nlargest_divisor(8)\n\
    </cell>\n<code language=julia-1.1>\nlargest_divisor(100)\n</cell>\n<text>\nFind\
    \ the nth number in a series\nProblem 3: Find the nth number in a series. Given\
    \ a series of n integers, find the nth smallest number in the series. For example,\
    \ consider the series 1, 2, 3, 4. One of the smallest numbers in the series is\
    \ 3. However, by following the rules of the game of chess, we know that the smallest\
    \ number in the series is actually the one on the 4th row, 3rd column. Thus the\
    \ nth smallest number in the series is 3.", "  # return n**.5 if n**.5 is an integer\n\
    \  return n if n.is_integer and n % 1 == 0 ", "  \n  # base case 1: n is even\n\
    \  if n%2 == 0\n    return n\n  \n  # base case 2: n is odd\n  else\n    \n  \
    \  # find the largest odd divisor of n\n    even = largest_divisor(n / 2)\n  \
    \  \n    # find the largest even divisor of n\n    odd = largest_divisor(n / 2)\n\
    \    \n    # if even > odd then return even\n    if even > odd\n      return even\n\
    \    \n    # otherwise return odd\n    else\n      return odd\n    \nend\n</cell>\n\
    <cell>\nlargest_divisor(25)\n</cell>\n<cell>", "  divisors = [1,n]\n  divisors.each\
    \ do |divisor|\n    break if divisor > n\n    break if n % divisor == 0\n    divisor\
    \ = divisor + 1\n  end\n  return divisor\nend", "  largest_divisor = nil\n  for\
    \ i in 1..n\n    next unless n % i == 0\n    largest_divisor = i\n  end\n  largest_divisor\n\
    end", "  primes = []\n  divs = n.div(n+1)\n  divs.each do |i|\n    primes << i\
    \ unless primes.include?(i)\n  end\n  divs.each do |i|\n    primes << i if primes.include?(i)\
    \ || !divs.include?(i) && n != i\n  end\n  primes.max\nend", "  largest = 1\n\
    \  largest_divisor = 1\n  while n > largest\n    largest *= 2\n    largest_divisor\
    \ *= 2\n    n /= largest_divisor\n  end\n  largest_divisor\nend", "    i = 2\n\
    \    while i<= n\n        j = n\n        counter = 1\n        while j > i\n  \
    \          j = j / i\n            counter += 1\n            if counter == i\n\
    \                return i\n            end\n        end\n        i = i + 1\n \
    \   end\nend", "    # Write your code here\n    factors = []\n    n *= n\n   \
    \ while n != 1:\n        if n % 2 == 0:\n            factors.append(2)\n     \
    \       n /= 2\n        else:\n            factors.append(3)\n            n /=\
    \ 3\n    while n != 1:\n        if n % 3 == 0:\n            factors.append(3)\n\
    \            n /= 3\n        else:\n            factors.append(4)\n          \
    \  n /= 4\n    while n != 1:\n        if n % 5 == 0:\n            factors.append(5)\n\
    \            n /= 5\n        else:\n            factors.append(6)\n          \
    \  n /= 6\n    while n != 1:\n        if n % 7 == 0:\n            factors.append(7)\n\
    \            n /= 7\n        else:\n            factors.append(8)\n          \
    \  n /= 8\n    while n != 1:\n        if n % 9 == 0:\n            factors.append(9)\n\
    \            n /= 9\n        else:\n            factors.append(10)\n         \
    \   n /= 10\n    factors.reverse()\n    return factors[-1]", "  largest_divisor_n\
    \ = nil # initialize largest divisor n\n  largest_divisor_num = nil # initialize\
    \ largest divisor num\n  divisor = 2\n  i = 2\n  while i <= n do\n    if n % i\
    \ == 0\n      break # break if we found a divisor of n\n    end # end if\n   \
    \ divisor = divisor + 1\n    largest_divisor_num = divisor if divisor > largest_divisor_num\
    \ then divisor else largest_divisor_num\n    i = i + 1\n  end # end while\n  return\
    \ largest_divisor_num\nend # end largest_divisor", "  highest_divider = 0\n  highest_divisor\
    \ = 0\n  for i in 1..n\n    quotient = n.quo(i).to_f\n    if quotient > highest_divider\n\
    \      highest_divider = quotient\n      highest_divisor = i\n  end\n  highest_divider\n\
    end\n</code>\n<|/ a tags=ruby,primes |>\n<| a dscore=0 |>\n<code>", "  divisors\
    \ = []\n  n.times do |i|\n    divisor = i\n    break if divisor > n / 2\n    divisors\
    \ += [i].downto(divisor)\n  end\n  divisors.sort.last\nend", "  divisor = 0\n\
    \  while divisor < n\n    divisor = n / divisor\n  end\n  divisor\nend", "  largest_div\
    \ = 1\n  largest_div = n / 2 while n.even? and n % 2 == 0 and largest_div > 2\n\
    \  largest_div\nend", "    largest_div = 3\n    largest = 0", "    num = n.to_i\n\
    \    if num == 1\n        0\n    else\n        divisor = 1\n        while num\
    \ > divisor\n            divisor <<= 1\n        end\n        divisor\n    end\n\
    end", "  # Initialize a list to store the numbers that divide n evenly\n  divisors\
    \ = []\n  # Initialize a variable to track the largest divisor found\n  largest\
    \ = 1\n  # Loop over all numbers from 1 to n\n  for i in 1..n\n    # If the number\
    \ is evenly divisible, add it to the list of divisors\n    if n%i == 0\n     \
    \ divisors << i\n      # If the number is larger than the last largest divisor\
    \ found so far\n      if n > largest\n        largest = n\n      end\n    end\n\
    \  end\n  # Return largest if n is evenly divisible by any number\n  largest\n\
    end", "  n\nend", "  return n if n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n %\
    \ 7 == 0 else (n % 5 == 0 ? 5 : n % 7 == 0 ? 7 : largestDivisor(n / 7))\nend",
  "  largest_div = 0\n  largest_div_of_n = 0\n  for i in (1..n) do \n    if n % i\
    \ == 0 then\n      largest_div_of_n = i\n      largest_div = n\n    end if\n \
    \ end\n  return largest_div\nend", "  largest = 1\n  while n != 0\n    n /= 2\n\
    \    largest += 1 if n % 2 == 0\n  end\n  largest\nend", "    largest_divisor\
    \ = 0\n    i = 2\n    while i <= n/2\n        if n % i == 0\n            largest_divisor\
    \ = i\n            i += 2\n        else\n            i += 1\n    end\nend\n</cell>\n\
    <code language=julia-1.5>\nlargest_divisor(15)\n</cell>\n<text>\nProblem 7\nIn\
    \ a previous assignment you used a binary search to find the position of a target\
    \ in a sorted array. In this problem you will use a binary search to find all\
    \ instances of a target in a sorted array.", "    largest = 0\n    numbers = (1..n).to_a\n\
    \    numbers.each do |num|\n        if (num % 2) == 0 && num > largest\n     \
    \       largest = num\n        end\n    end\n    largest\nend", "  # Base case:\
    \ n is a perfect power of 2\n  return 2 if n.odd? else n\n  \n  # Keep the largest\
    \ divisor found so far\n  largest_divisor = nil\n  \n  # Loop through all possible\
    \ divisors, starting from 2, up to sqrt(n)\n  (2..n.sqrt(n)).each do |divisor|\n\
    \    # Check if a given n can be divided by this divisor\n    break if n % divisor\
    \ == 0\n    \n    # Keep the largest divisor encountered so far\n    largest_divisor\
    \ = divisor if largest_divisor.nil? || divisor > largest_divisor\n  end\n  \n\
    \  # Return the largest divisor encountered so far\n  return largest_divisor\n\
    end", "  largest = 2 # 2 will be the largest divisor in our test\n  num_factors\
    \ = []", "  largest_divisor = nil\n  n.times do\n    largest_divisor = n if n\
    \ % largest_divisor==0\n    n /= largest_divisor\n  end\n  largest_divisor\nend\n\
    </code>\n<|/ a tags=ruby,primes |>\n<| c |>\nIt isn't the most efficient way to\
    \ go about it, but it does solve the OP's problem. :)\n<|/ c |>\n<| c |>\nSurely\
    \ there must be some more efficient way?\n<|/ c |>\n<| c |>\nThe code above is\
    \ just one way it could be done. There may be better ways to do it, but the code\
    \ above is a good start. The bigger problem with this code is that you are dividing\
    \ by an arbitrary number in the event of failure. This is not necessarily efficient\
    \ and will fail quickly if `n` is very large. Also, your algorithm is incomplete\
    \ - what happens if `largest_divisor < 2`, for instance?\n<|/ c |>\n<| c |>\n\
    Aha I see, so you didn't actually code the algorithm in your answer. Now that\
    \ makes sense, thank you.\n<|/ c |>\n<| c |>\nThis answer does not answer the\
    \ question as it states explicitly that \"no built-in methods exist\" but the\
    \ question is about built-in methods. Also, your `largest_divisor` algorithm does\
    \ not return any number.\n<|/ c |>\n<| a |>\nYou need a method to find the prime\
    \ factors of a given number. Below is one way to do it. It divides the number\
    \ by every number in the range (2, sqrt(n)). It then tries to divide by each prime\
    \ in the range (2, sqrt(n)). If the number is not divisible by any prime, that\
    \ prime is removed from the list and it's division will never get divided by it.\n\
    <code>", "  largest_divisor = 1\n  \n  n.downto(1) do |d|\n    next if d > largest_divisor\n\
    \    largest_divisor = d\n  end", "  if n<0\n    return nil\n  end\n  largest_divisor(n\
    \ % 6) + 1\nend", "  largest_number = nil\n  largest_divisor = 0\n  for i in 1..n\n\
    \    if (n % i == 0)\n      largest_divisor = i\n      if (largest_number == nil\
    \ || largest_divisor > largest_number)\n        largest_number = largest_divisor\n\
    \      end\n    end\n  end\n  largest_number\nend", "  # Initialize all values\
    \ to 0\n  num_divisors = 0\n  # Get the remainder to check for even divisors\n\
    \  remainder = n % 2\n  while remainder != 0 and remainder != 1\n    num_divisors\
    \ += 1\n    remainder = n % 2\n  end\n  # Find largest number that divides n evenly\
    \ and is smaller than n\n  return num_divisors if num_divisors <= n\n  return\
    \ n\nend", "  divisor = 1\n  while divisor < n\n    divisor += 1\n  end\n  divisor\n\
    end", "    largest_divisor = 1\n    div = 2\n    while div <= n\n        div +=\
    \ 1\n        if n % div == 0\n            largest_divisor = div\n    return largest_divisor\n\
    </code>\nThis approach works in O(sqrt(n)) time.\n<|/ a tags=math,performance,algorithm,ruby,ruby-on-rails\
    \ |>\n<| c |>\nYou don't need to find `sqrt(n)` you can test for `n % div == 0`\
    \ immediately.\n<|/ c |>\n<| a |>\nO(n) solution:\n<code>", "  if n<0\n    return\
    \ -1\n  i = 1\n  while n%i!=0 do\n    i<<=1\n  end\n  while n%(i*i)!=0 do\n  \
    \  i=i*i\n  end\n  return i\nend", "  divisor = 1\n  largest_divisor = 1\n  max_divisor\
    \ = 1\n  max_divisor_n = 1", "  n%4==0 ? n%2 > n : n%3 == 0 ? n%5 > n : n%5 ==\
    \ 0\nend\n</code>\nThis will return false for anything > 6, but not for anything\
    \ below 3.\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "    divisor = 0\n\
    \    while n % divisor == 0\n        divisor += 1\n    largest_divisor = divisor\n\
    \    while divisor < n\n        divisor += 2\n        largest_divisor = divisor\n\
    \    return divisor\n</cell>\n<code language=julia-1.0>\nlargest_divisor(27)\n\
    </cell>\n<text>\nDerive the number $a$ by using the above formula\n$$a = 2^{\\\
    large{n \\cdot \\log{n}-1}} \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\\
    cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\cdot \\c", "    largest_divisor\
    \ = (1..n).to_a.max_by { |i| divides_evenly(i) }\nend", "  max_divisor = nil\n\
    \  n.times do |i|\n    div = n / i\n    break div if div.to_i <= max_divisor.to_i\n\
    \    max_divisor = div\n  end\n  max_divisor\nend", "  return n if n.even? ||\
    \ n.odd? \n  largest_divisor_without_even(n).tap { |l| largest_divisor_without_odd(l)\
    \ }\nend", "  highest_divisor = 1\n  divisor = 2\n  until divisor > highest_divisor\n\
    \    divisor = n % divisor\n    highest_divisor = divisor\n  end\n  highest_divisor\n\
    end", "  largest_divisor_number = 1\n  largest_divisor_count = n\n  (1..n).each\
    \ do |i|\n    if (n % i == 0)\n      if i < largest_divisor_count\n        largest_divisor_count\
    \ = i\n        largest_divisor_number = n\n      end\n    end\n  end\n  largest_divisor_number\n\
    end", "  divisors = divisors(n)\n  largest_divisor = divisors.max { |a, b| a <=\
    \ b }\n  divisors.delete(largest_divisor)\n  divisors.compact!\n  largest_divisor\n\
    end\n</code>\nThen you can call largest_divisor on a number (e.g., '123') and\
    \ it will return the largest divisor that is less than or equal to 'n'.\n<|/ a\
    \ dscore=1 |>\n<| c |>\nThis doesn't work for large numbers. Try it with `largest_divisor(2**128-1)`.\n\
    <|/ c |>\n<| a tags=ruby,numbers,algorithm |>\nHere's an improvement on kislyub's\
    \ answer that runs in O(sqrt(n)) time.  Instead of checking each divisor, it checks\
    \ only the divisors up to sqrt(n).  It only uses integers to get the next factor\
    \ and to calculate the next factor.  It does not perform division at all.  It\
    \ also does not use division to solve a problem that could have been solved using\
    \ division.\n<code>", "    largest_divisor = 0\n    i = 2\n    while (i <= n)\n\
    \        if (n % i == 0)\n            largest_divisor = i\n            break\n\
    \        i += 1\n    \n    return largest_divisor\n</cell>\n<text>\nTesting the\
    \ Function", "  largest_divisor = 1\n  for i in range(1, n + 1)\n    break if\
    \ n % i == 0\n    if i > largest_divisor\n      largest_divisor = i\n  n\nend",
  "  a = n / 2 \n  b = n / 4\n  c = n / 8\n  d = n / 16\n  e = n / 32\n  f = n / 64\n\
    \  g = n / 128\n  h = n / 256\n  i = n / 512\n  j = n / 1024\n  k = n / 2048\n\
    \  l = n / 4096\n  m = n / 8192\n  n = n / 16384\n  o = n / 32768\n  p = n / 65536\n\
    \  q = n / 131072\n  r = n / 262144\n  s = n / 524288\n  t = n / 1048576\n  u\
    \ = n / 2097152\n  v = n / 4194304\n  w = n / 8388608\n  x = n / 16777216\n  y\
    \ = n / 33554432\n  z = n / 67108864\n  a = a * 256\n  b = b * 256\n  c = c *\
    \ 256\n  d = d * 256\n  e = e * 256\n  f = f * 256\n  g = g * 256\n  h = h * 256\n\
    \  i = i * 256\n  j = j * 256\n  k = k * 256\n  l = l * 256\n  m = m * 256\n \
    \ n = n * 256\n  o = o * 256\n  p = p * 256\n  q = q * 256\n  r = r * 256\n  s\
    \ = s * 256\n  t = t * 256\n  u = u * 256\n  v = v * 256\n  w = w * 256\n  x =\
    \ x * 256\n  y = y * 256\n  z = z * 256\n  a = a * 256\n  b = b * 256\n  c = c\
    \ * 256\n  d = d * 256\n  e = e * 256\n  f = f * 256\n  g = g * 256\n  h = h *\
    \ 256\n  i = i * 256\n  j = j * 256\n  k = k * 256\n  l = l * 256\n  m = m * 256\n\
    \  n = n * 256\n  o = o * 256\n  p = p * 256\n  q = q * 256\n  r = r * 256\n \
    \ s = s * 256\n  t = t * 256\n  u = u * 256\n  v = v * 256\n  w = w * 256\n  x\
    \ = x * 256\n  y = y * 256\n  z = z * 256\n  a = a * 256\n  b = b * 256\n  c =\
    \ c * 256\n  d = d * 256\n  e = e * 256\n  f = f * 256\n  g = g * 256\n  h = h\
    \ * ", "    \n    # Initialize the array with all numbers greater than or equal\
    \ to n\n    arr = Array.new(2..n)", "    largest_divisor = 0\n    smallest_divisor\
    \ = n", "\tndiv = n.to_i\n\tremainder = n\n\twhile (remainder > 0)\n\t\tremainder\
    \ = remainder - ndiv\n\t\tndiv = ndiv - 1\n\t\n\treturn ndiv\nend\n\t", "  largest\
    \ = n/2\n  while n != 1\n    if n % largest == 0\n      largest = n/largest\n\
    \    else\n      n = n-1\n  end\n  return largest\nend", "    largest = 1\n  \
    \  i = 2\n    while i <= n/2\n        if (n%i == 0)\n            largest = n\n\
    \            i = i + 1\n        end\n        i = i + 1\n    end\n    return largest\n\
    end", "  div = 0\n  for i in 2..n do\n    div = if i % i == 0 then div else i\n\
    \  end\n  div\nend", "  n = n.to_i\n  n.times do |i|\n    return i if (n % i ==\
    \ 0)\n    return n if (n % i != 0)\n  end\nend", "    largest_divisor = nil\n\
    \    largest_divisor_num = 0\n    (1..n).each do |num|\n        divisor = n /\
    \ num\n        if n % divisor == 0\n            largest_divisor_num = divisor\n\
    \            largest_divisor = num\n        end\n    end\n    largest_divisor\n\
    end", '  divisors = Array.new(1000)', "    # Base Case\n    if n < 2 \n      \
    \  return n", "  primes = []\n  primes.push(2)\n  for i in 2..n do\n    primes.push(primes[i]\
    \ + i)\n  end", "  return n==1 ? 1 : n.to_s.size/2\nend", "    # Store the largest\
    \ divisor seen\n    max_divisor = 0\n    # Loop through possible divisors 1 to\
    \ n\n    for i in 1..n\n        # Check if i is a divisor\n        if n%i == 0\n\
    \            # And update if necessary\n            if max_divisor < i\n     \
    \           max_divisor = i\n            end\n        end\n    end\n    # Return\
    \ maximum divisor\n    return max_divisor\nend\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(8)\n</cell>\n<code language=julia-1.5>", "  if n % 2 == 0 then\
    \ return n\n  else largest_divisor(n/2) end \nend\n</cell>\n<code language=julia-1.4>\n\
    largest_divisor(17)\n</cell>\n<text>\nExercise 2\nWrite a recursive function called\
    \ sum that computes the sum of the numbers from 0 through n. Recall that in Julia,\
    \ you can use end with if statements, and a for loop to iterate over an array.\
    \ For example, to sum the numbers from 0 to 10 (inclusive) we could write", " \
    \ largest_divisor = n\n  divisor = n\n  while divisor > 1\n    divisor = n/divisor\n\
    \    if divisor > largest_divisor\n      largest_divisor = divisor\n    end\n\
    \  end\n  largest_divisor\nend", "  # Check if n is prime\n  if n.odd? && n.positive?\n\
    \    return n\n  else\n    n.to_i.times do |i|\n      n.to_i / i.to_i\n    end\n\
    \  end\nend", "    divisor = 1\n    temp = n\n    until temp > 1\n        divisor\
    \ = divisor*temp\n        temp = temp/2\n    end\n    divisor\nend", "  largest\
    \ = 0\n  (1...n).each do |i|\n    if (n % i).zero?\n      largest = i\n      break\n\
    \    end\n  end\n  largest\nend", "  largest = 1 # 1! = 1\n  factors = 2 # 2!\
    \ = 2\n  divisor = 2\n  while factors < n do\n    factors = factors * divisor\n\
    \    largest = factors\n    divisor = factors + 2\n  end\n  puts largest\nend",
  "  max_divisor = 1\n  max_dividend = n\n  until max_dividend % max_divisor == 0\n\
    \    # Keep dividing max_dividend until max_dividend % max_divisor == 0\n    n\
    \ -= 1\n    max_divisor += 1\n  end\n  max_divisor\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\n<code>", "    largest_divisor = n # start at n\n    n.downto(1)\
    \ do |d| # go through each number from n down to 1\n        break unless n % d\
    \ == 0 # stop when n does not divide evenly into d\n        largest_divisor =\
    \ d # new number with largest divisor of n\n    end\n    return largest_divisor\n\
    end", "\tlargest_divisor = 1\n\tlargest_divisor_n = 1", "  divisors = []\n  (2...n).each\
    \ do |i|\n    if (i%2 == 0)\n      divisors << i\n    elsif (divisors.count >\
    \ 0)\n      divisors.each do |divisor|\n        if (n / divisor == i)\n      \
    \    break\n        end\n      end\n    end\n  end\n  return divisors\nend", " \
    \ if n % 2 == 0\n    smallest_divisor = n / 2\n  else\n    smallest_divisor =\
    \ n / 2\n    smallest_divisor += 1 if n % smallest_divisor == 0 else 0\n    smallest_divisor\
    \ = 2 ** smallest_divisor\n  until smallest_divisor == n\n  puts smallest_divisor\n\
    end\n</code>\nThe solution comes from here: http://stackoverflow.com/questions/1724101/fastest-way-to-find-the-highest-power-of-a-number-in-ruby\n\
    <|/ a tags=ruby,math |>\n<| c |>\nThis solution does not work correctly for n\
    \ = 300, it returns 600 as largest divisor.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ it out. I've fixed the solution now.\n<|/ c |>\n<| a |>\nI think my solution\
    \ is better:\n<code>\n(1..n).reduce(:*).quo(2..n).to_i\n</code>\n<|/ a dscore=4\
    \ tags=ruby,math |>\n<| c |>\nGreat solution! I wonder if there is a way to modify\
    \ this to return a float, or should I create a new question?\n<|/ c |>\n<| c |>\n\
    `(1..n).reduce(:*).quo(2..n).to_f` - but this way is not good\n<|/ c |>\n<| a\
    \ tags=ruby,math |>\nA bit simpler (but slower):\n<code>", "  nums = []\n  loop\
    \ do\n    div, mod = n.divmod(2)\n    next if mod != 0\n    nums << div\n  end\n\
    \  nums.max\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| c |>\n`max_by` would\
    \ be faster I think.\n<|/ c |>\n<| c |>\n`max_by` would be better but OP asked\
    \ for an array.\n<|/ c |>\n<| c |>\nThe point of using `max_by` is to find the\
    \ largest divisor, not the largest number. As such `max_by` does not really do\
    \ what the OP asked for.\n<|/ c |>\n<| c |>\n, I don't think so. I think it does\
    \ what OP asked for. You could just sort and pick the first element. O(nlogn)\
    \ at most.\n<|/ c |>\n<| c |>\nOP asked for the largest divisor, not the largest\
    \ number.\n<|/ c |>\n<| a tags=arrays,ruby dscore=2 |>\nThe other answer has already\
    \ given good solutions, I'd just like to point out that your original problem\
    \ is similar to finding the largest prime factor of an integer. The difference\
    \ between the two is that you're searching for prime factors, whereas prime factors\
    \ are often not the highest divisor as you call them in the question text.\nSo\
    \ your algorithm should be something like this:\n<code>", "    divisor_set = n.to_s.split('').each_with_object(Hash.new(0))\
    \ { |e,h| h[e] += 1 }\n    n, divisor = divisor, n\n    divisor_set.each { |k,v|\
    \ divisor = v / k }\n    divisor\nend", "  max = n\n  n.times do |i|\n    next\
    \ unless n % i == 0\n    max = i if n > i\n  end\n  max\nend", "  highest_divisor\
    \ = n # starts at n, since 0 divides any number\n  n.times do\n    highest_divisor\
    \ = highest_divisor / 2 \n  end \n  highest_divisor\nend", "  divisor = 1\n  while\
    \ true\n    divisor += 1\n    if n % divisor == 0\n      break\n  end\n  return\
    \ divisor\nend\n</code>\n<|/ a |>\n<| c |>\nThanks, this looks much better than\
    \ my solution :)\n<|/ c |>\n<| a dscore=3 |>\nThis question was asked a long time\
    \ ago, but I've written a ruby gem to solve this problem.  You can use it like\
    \ this:\n<code>\nrequire 'rubygems'\nrequire 'divisors'\ndivisor_number = Divisors::largest_divisor_number(420)\n\
    puts divisor_number # => 2\n</code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=2\
    \ tags=ruby,algorithm |>\nI solved this in java a couple of years ago by bruteforcing\
    \ it. I used an arbitrary prime, such as 13. Basically, you try to divide your\
    \ number by 13 until you hit one. Keep track of the highest number you divide\
    \ by in each iteration of the loop. Then, you check if your new number is bigger\
    \ than your highest number, and if it is, you store it.\n<code>\npublic static\
    \ boolean is_prime(int num){\n    for(int i = 2; i < num / 2; i++){\n        if(num\
    \ % i == 0){\n            return false;\n        }\n    }\n    return true;\n}",
  "    max = n.to_i\n    factor = 1\n    (1..n).each do |i|\n        next unless n\
    \ % i == 0\n        factor = i\n        max = i if i % n == 0\n    end\n    factor\n\
    end", "  divisor_count = n.to_s.split(//).reduce(:+)\n  divisor_count.times do\
    \ |i|\n    return n if i % divisor_count == 0\n  end\nend", "  return n if n %\
    \ 2 == 0 && (n % 3 == 0 || n % 5 == 0) || n % 7 == 0 else largest_divisor(n /\
    \ 2)\nend", "  div = 0\n  while div <= n\n    div = div * 2\n  end\n  return div\n\
    end", "  \n  largest_divisor = 0\n  \n  # This loop finds the largest divisor\
    \ smaller than n\n  for i in 1..n/2 \n    \n    # If this number is evenly divisible\
    \ by n, we keep on checking\n    if n % i == 0\n      \n      # If the largest\
    \ divisor so far is smaller than n\n      if i > largest_divisor\n        \n \
    \       # Update largest_divisor with current i\n        largest_divisor = i\n\
    \      \n      # If not, we keep on checking\n      else\n        \n        #\
    \ Keep on checking\n      end\n    end\n  end\n  \n  return largest_divisor\n\
    end", "  if n % 2 == 0\n    # even\n    largest_divisor = largest_divisor (n/2)\n\
    \  else\n    # odd\n    largest_divisor = n if (largest_divisor / 2) > n else\
    \ (largest_divisor / 2)\n  end", "  # if n < 0 return nil\n  return nil if n <\
    \ 0", "  # Find the first number smaller than n\n  smaller_than = n.abs\n  smaller_than.each\
    \ do |num|\n    if num % 2 != 0\n      return num\n    end\n  end\nend", "  highest_divisor\
    \ = 1\n  \n  while highest_divisor < n\n    if n % highest_divisor == 0\n    \
    \  highest_divisor = highest_divisor + 1\n    else\n      highest_divisor = 1\n\
    \    end\n  end\n  \n  return highest_divisor\nend\n</cell>\n<cell>\nlargest_divisor(123)\n\
    </cell>\n<cell>\nlargest_divisor(12)\n</cell>\n<cell>\nlargest_divisor(6)\n</cell>\n\
    <text>\nExerc\xEDcio 7\nA sequ\xEAncia de Fibonacci \xE9 a mesma em sequ\xEAncias\
    \ de n\xFAmeros reais, com os mesmos n\xFAmeros reais, s\xE3o representadas pela\
    \ sequ\xEAncia de Fibonacci, segundo o fato de n\xE3o serem repetidos. Calcule\
    \ o n\xFAmero de Fibonacci de um n\xFAmero inteiro que tenha o mesmo n\xFAmero\
    \ reais.", "  n = n.to_i\n  factors = []\n  (1..n).each { |i| factors << i if\
    \ n % i == 0 }\n  factors.max\nend\n</cell>\n<cell>\nlargest_divisor(120).to_s\n\
    </cell>\n<cell>", "  largest_divisor_num = n\n  for i in 1..n\n    if n % i ==\
    \ 0\n      largest_divisor_num = i\n      break\n    end\n  end\n  return largest_divisor_num\n\
    end", "    largest_divisor = n\n    largest_divisor_count = 0\n    for divisor\
    \ in divisors\n        if n % divisor == 0\n            largest_divisor_count\
    \ += 1\n            if largest_divisor_count == largest_divisor\n            \
    \    largest_divisor = divisor\n    end\n    return largest_divisor\nend\n</code>\n\
    <|/ a dscore=0 tags=ruby,loops,while-loop |>\n<| c |>\nWhile this may solve the\
    \ problem, you really should expand on how it solves the problem or even better\
    \ how and why it helps.\n<|/ c |>\n<| c |>\nThis is good, but it doesn't help\
    \ OP learn about loops. I suggest you try this and see what happens: http://rubular.com/r/uN2jlxjMxe\n\
    <|/ c |>\n<| a tags=ruby,loops,while-loop |>\nYou can use a for loop for this.\
    \ Ruby has many types of for loops, but a while loop will suffice here.\n<code>",
  "  factors = []\n  factor = 2\n  while factor * factor <= n\n    factors << factor\n\
    \    factor *= 2\n  end\n  factors.each do |factor|\n    while n % factor == 0\n\
    \      n /= factor\n    end\n  end\n  n\nend\n</cell>\n<code language=julia-1.5>\n\
    largest_divisor(11) #= 4\n</cell>\n<text>\nTo test your implementation, run the\
    \ following code cell.  If the result is what you expect, only move on to the\
    \ next section.  If the results don't match your expectations, restart the kernel\
    \ and run the tests again. Feel free to modify this cell to test your own algorithm.",
  "  largest_divisor = n\n  while n % 2 == 0\n    largest_divisor = n / 2\n    n -=\
    \ 1\n  end\n  while n % 3 == 0\n    largest_divisor = n / 3\n    n -= 1\n  end\n\
    \  while n % 5 == 0\n    largest_divisor = n / 5\n    n -= 1\n  end\n  while n\
    \ % 7 == 0\n    largest_divisor = n / 7\n    n -= 1\n  end\n  largest_divisor\n\
    end", "  divisor = 0\n  divisors = []\n  # Loop through all numbers from 1 to\
    \ n, each time\n  # calculating the largest divisor up to n\n  (1..n).each do\
    \ |i|\n    if n % i == 0\n      # If we find a divisor less than or equal to n\n\
    \      # we store the number\n      divisor = i\n      # Then we add the number\
    \ to the list of divisors\n      divisors << i\n      # Once we hit n, we stop\
    \ the loop\n      break\n    end\n  end\n  # Return the largest number that divides\
    \ n evenly\n  divisors.max\nend", "  largest_divisor = 0\n  largest_divisor_divisor\
    \ = 0\n  for i in 1..n\n    if n % i == 0\n      largest_divisor_divisor = i\n\
    \      largest_divisor = i\n      break\n    end\n  end\n  return largest_divisor,\
    \ largest_divisor_divisor\nend\n</cell>\n<text>\nHere is an example of a function\
    \ that checks if a number n is a prime number. The function returns true if the\
    \ number n is a prime number and false if it is not.", "  \n  # initialize an\
    \ array for factors\n  factors = []", "    divisors = [1, n]\n    divisors.each\
    \ do |divisor|\n        next if n % divisor == 0\n        div = divisor - n%divisor\n\
    \        divisors.insert(div+1, divisor) if div > 0\n        break if div == 0\n\
    \    end\n    return divisors.max\nend", "  a = n.to_s.split('')\n  a.map { |e|\
    \ e.to_i }\n  a.sort.reverse.each { |e| puts \"#{e} is a divisor of #{n}\" }\n\
    end", "  i = 2\n  while i <= n\n    i += 2\n    if n % i == 0\n      return i\n\
    \  end\nend\n</code>\n(Note that in Ruby, a while loop has a keyword exit that\
    \ will cause it to exit when its condition becomes false; there is no such keyword\
    \ in C#.)\nWe can then use the code above to find the largest number that is divisble\
    \ by all of the numbers less than a given number. For example, for the number\
    \ 12, there are only four numbers between 1 and 12 whose product can be divided\
    \ by 6. 6 is the largest number for which this happens, so we set n to 12 and\
    \ then repeatedly find the largest number less than n that is divisible by all\
    \ of the numbers less than n:\n<code>", "    largest_number = 1\n    largest_divisor\
    \ = 1\n    \n    for i in 2..n\n        if n % i == 0 # if i divides n evenly\n\
    \            if i > largest_number\n                largest_number = i\n     \
    \           largest_divisor = n / i # i divides n evenly and is the largest divisor\n\
    \            end\n        end\n    end\n    return largest_divisor\nend", "  #\
    \ return if n is divisible by 1 or n\n  return n if n % 2 == 0 || n == 1 || n\
    \ == 2 || n == 3 || n == 4 || n == 5 || n == 6 || n == 7 || n == 8 || n == 9 \n\
    \  \n  # else loop over all odd numbers between 2 and n\n  (2..n).each do | i\
    \ |\n    if n % i == 0\n      largest_divisor = i\n      break\n    end\n  end\n\
    \  \n  # return largest divisor\n  largest_divisor\nend", "  divisors = []\n \
    \ divisor = 1\n  while n > divisor\n    divisors << divisor\n    n -= divisor\n\
    \    divisor = divisors.shift\n  end\n  divisors.last ? n : nil\nend\n</code>\n\
    <|/ a |>\n<| c |>\nHi David, thanks for your answer. As I said, I wasn't looking\
    \ for a solution, but was looking for a little bit of help with how to go about\
    \ approaching the problem. Thanks again.\n<|/ c |>\n<| a tags=ruby,algorithm,big-o\
    \ |>\nThis answer will be somewhat of an exercise in recursion.  But it may help\
    \ a bit.\n<code>", "  n = 1\n  factors = []\n  while n != 0\n    n /= 2\n    factors\
    \ << n\n  \n  factors.each do |n|\n    while n % 2 == 0\n      n /= 2\n    end\n\
    \  end\n  \n  factors.each do |n|\n    while n % 3 == 0\n      n /= 3\n    end\n\
    \  end\n  \n  factors.each do |n|\n    while n % 5 == 0\n      n /= 5\n    end\n\
    \  end\n  \n  factors.each do |n|\n    while n % 7 == 0\n      n /= 7\n    end\n\
    \  end", "    largest_divisor = n\n    largest_divisor_prime = 1\n    \n    #\
    \ Go through the multiples of largest_divisor until we find the next one which\
    \ divides evenly into n\n    i = largest_divisor_prime\n    while i*i <= n and\
    \ i*i%n != 0\n        i += 1\n    end\n    \n    # Keep going until we've found\
    \ one that divides evenly into n\n    while i*i <= n\n        largest_divisor\
    \ = i\n        largest_divisor_prime = i\n        \n        # Go through the multiples\
    \ of largest_divisor until we find the next one which divides evenly into n\n\
    \        i = largest_divisor_prime\n        while i*i <= n and i*i%n != 0\n  \
    \          i += 1\n        end\n    end\n    \n    return largest_divisor\nend",
  "    largest_divisor = 2n\n    i = 2\n    while i <= n\n        largest_divisor\
    \ = i\n        i += 2\n    end\nend\nlargest_divisor(n)\n</cell>\n<cell>", " \
    \ arr = Array.new\n  (1...n).each do |i|\n    if n % i == 0\n      arr.push(i)\n\
    \    end\n  end\n  arr.max_by{ |i| n/i }\nend\n</code>\n<|/ a |>\n<| c |>\nThe\
    \ largest number that divides n evenly is n-1.\n<|/ c |>\n<| c |>\nYes, you are\
    \ right. I've rewritten my answer. Thank you!\n<|/ c |>\n<| a |>\nA simple solution\
    \ can be done using Recursion:\n<code>", "  return n if n.even? and n.positive?\
    \ and n>2 # no need for checking n<=2 here\n  \n  # This code assumes that n <=\
    \ 100\n  largest_divisor = 2 # arbitrary value\n  \n  while largest_divisor*2<=n\n\
    \    # find the next largest divisor of n\n    largest_divisor = largest_divisor*2\n\
    \  \n  return largest_divisor if n%largest_divisor==0 # n is evenly divisible\
    \ by largest_divisor\nend\n</cell>\n<cell>\nlargest_divisor(11)\n</cell>\n<cell>\n\
    largest_divisor(12)\n</cell>\n<cell>\nlargest_divisor(13)\n</cell>\n<cell>\nlargest_divisor(100)\n\
    </cell>\n<text>\nEx 22: Find the factors of the number, 2763\nWe have two prime\
    \ factors:", "  i = 1\n  while i <= n\n    if n % i == 0\n      return i\n   \
    \ i += 1\n  end\n  return n\nend", "    largest = 0\n    current = n\n    while\
    \ current != 1\n        if n % current == 0\n            current /= n\n      \
    \      largest = current if current > largest else largest\n        end\n    end\n\
    \    largest\nend", "  largest = 0\n  until n==1 do\n    if n%2 == 0\n      largest\
    \ = n\n      n/=2\n      largest = largest - 1\n    else\n      n/=2\n    end\n\
    \  end\n  largest\nend", "  largest_divisor_count = 0\n  largest_divisor = 0\n\
    \  \n  # find the largest divisor of n\n  divisors = n.to_s.split(\"\").map {|i|\
    \ i.to_i}\n  divisors.each do |divisor|\n    if divisor > largest_divisor \n \
    \     largest_divisor = divisor\n      largest_divisor_count = 0\n    end\n  \
    \  \n    if divisor > largest_divisor_count\n      largest_divisor_count = divisor\n\
    \    end\n  end", "  largest_divisor_count = 0\n  largest_divisor = 1\n  \n  #\
    \ Loop over all possible divisors of n\n  n.to_s.split(\"/\").each do |divisor|\n\
    \    # If this divisor divides n evenly and is not equal to n\n    if divisor.to_s.scan(/\\\
    d+/).any? { |i| i.to_i % divisor == 0 }\n      # Then this is a possible divisor\n\
    \      largest_divisor_count += 1\n      # If this is the largest divisor so far,\
    \ save it\n      if largest_divisor_count > largest_divisor_count\n        largest_divisor\
    \ = divisor\n      end\n    end\n  end\n  \n  largest_divisor\nend", "  n.downto(0).find\
    \ { |e| (n%e == 0) }\nend", "  divisor = 0\n  while divisor < n / 2\n    divisor\
    \ = (n + 1) / 2\n  until divisor == n\n  divisor\nend", "  max_div = n / 2.0\n\
    \  divisor = 1\n  while divisor < n\n    if n % divisor == 0\n      max_div =\
    \ max_div / divisor\n      divisor = divisor + 1\n    end\n    divisor = divisor\
    \ + 1\n  end\n  return max_div\nend", "  largest = 1\n  largestDivisor = nil",
  "  divisor = 1\n  while divisor <= n / 2\n    divisor = divisor * 2\n  end\n  divisor\n\
    end", '  largest_divisor_number = nil', "  div = []\n  (2..n).each do |i|\n  \
    \  if (n % i == 0)\n      div.push(i)\n      break\n    end\n  end\n  div.each\
    \ do |i|\n    if (n % i == 0)\n      n = (n/div[i]).floor\n      break\n    end\n\
    \  end\n  return n\nend\nlargest_divisor(1000)", "  # If n is 1, return n\n  next\
    \ if n==1\n  # Find the largest divisor of n that is less than or equal to n\n\
    \  largest = n/2 while largest>n and n%largest!=0\n  # Return the largest divisor\n\
    \  largest\nend", "    biggest = 0\n    count = 0\n    while n > 0\n        if\
    \ n % 2 == 0\n            count += 1\n            if count > biggest\n       \
    \         biggest = count\n        end\n        n = n / 2\n    end\n    return\
    \ biggest\nend\n</cell>\n<code language=julia-1.2>", "    largest_divisor = 1\n\
    \    while n % 2 == 0\n        largest_divisor = largest_divisor + 1\n       \
    \ n = n / 2\n    while n % 2 == 1\n        n = n / 2\n    n -= 1\n    while n\
    \ % 2\n        n = n / 2\n    largest_divisor\nend\n</cell>\n<cell>\nlargest_divisor(10)\n\
    </cell>\n<cell>", "  ndiv = 1\n  div = divisor(n)\n  while div > 1\n    if n %\
    \ div == 0 \n      ndiv = div\n      div = divisor(div)\n    else\n      div /=\
    \ 2\n    end\n  end\n  return ndiv\nend", "  \n  # Return nil if n is negative\n\
    \  return if n < 0\n  \n  # If the number is even, there is only one divisor\n\
    \  return if n % 2 == 0\n  \n  max_factor = 1\n  max_factors = []", "    largest_divisor_count\
    \ = 0\n    largest_divisor_number = 1\n    largest_divisor_number_count = 0",
  "  # Write your code here.\n  return n\nend", "  largest_divisor = 1\n  while largest_divisor\
    \ <= n \n    largest_divisor = largest_divisor + 1\n  end\n  largest_divisor\n\
    end\n</cell>\n<cell>\nlargest_divisor == 15\n</cell>\n<text>\nExercise 5 (25 points)\n\
    Find all primes under 10", "  result = 1\n  max_divisor = 0\n  n.downto(1) do\
    \ |i|\n    if n % i == 0\n      result = i\n      break\n    end\n  end", "  \
    \  # Write your code here\n    return n\nend", "  divisor_numbers = []\n  i =\
    \ 1\n  while i <= n\n    divisor_numbers.push(divisors[i])\n    i += 1\n  end\n\
    \  max_divisor = divisor_numbers[0]\n  for i in divisors\n    if max_divisor <\
    \ i\n      max_divisor = i\n    end\n  end\n  return max_divisor\nend", "  n.times\
    \ do |x|\n    if x % 2 != 0\n      return x\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
