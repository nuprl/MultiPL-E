name: HumanEval_14_all_prefixes
language: rb
prompt: "# Return list of all prefixes from shortest to longest of the input string\n\
  def all_prefixes(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_all_prefixes\n\
  \    candidate = method(:all_prefixes)\n    assert_equal([], candidate.call(\"\"\
  ))\n    assert_equal([\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"],\
  \ candidate.call(\"asdfgh\"))\n    assert_equal([\"W\", \"WW\", \"WWW\"], candidate.call(\"\
  WWW\"))\n  end\nend\n"
completions: ["  prefixes = []\n  string = string.dup\n  while string.length > 0\n\
    \    prefix = string.slice!(0, 2)\n    prefixes << prefix\n  end\n  prefixes\n\
    end", "    prefixes = []\n    i = nil\n    string.each_char.with_index do |char,\
    \ i|\n        if prefixes.empty? or i - prefixes.last.size > 1\n            prefixes\
    \ << char\n        end\n    end\n    prefixes\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis does not return all prefixes, as asked.\n<|/ c |>\n<| c |>\nI rephrased\
    \ my answer accordingly\n<|/ c |>\n<| a dscore=1 |>\nYou can use the following\
    \ regex to get all prefixes. It can be optimized, but I am lazy and wanted to\
    \ make it clear:\n<code>\n^(\\D+|\\d+)(\\D+|\\d)*\n</code>\nSee Demo\nExplanation:",
  "    prefix = \"\"\n    prefix_length = 1\n    \n    while prefix_length < string.length\n\
    \        prefix << string[prefix_length..-1]\n        prefix_length += 1\n   \
    \ end\n    \n    [prefix, string[0, prefix_length]]\nend", "  result = []\n  string.split('').each\
    \ do |char|\n    result.concat(prefixes(char))\n  end\n  result\nend", "  all_prefixes\
    \ = Array.new\n  prev_char = nil\n  string.length.downto(1).each do |i|\n    prefix\
    \ = prev_char + string[i]\n    all_prefixes << prefix\n    prev_char = prefix\n\
    \  end\n  all_prefixes\nend", "  \n  # Create list of all possible prefixes\n\
    \  prefixes = string.split(//)\n  \n  # Remove all prefixes that are empty\n \
    \ prefixes.each do |prefix|\n    if prefix.length == 0.\n      prefixes.delete(prefix)\n\
    \    end\n  end\n  \n  # Return list of all possible prefixes that were generated\n\
    \  prefixes\nend", "    prefixes = Array.new\n    prefixes << \"\"\n    string.each_char.with_index\
    \ do |char, i|\n        prefix = char.upcase\n        prefixes << prefix\n   \
    \     prefixes.delete_at(prefixes.rindex(prefix))\n    end\n    prefixes\nend\n\
    </code>\nOutput\n<code>\n=> [\"aa\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"\
    ag\", \"ah\", \"ai\", \"aj\", \"ak\", \"al\", \"am\", \"an\", \"ao\", \"ap\",\
    \ \"aq\", \"ar\", \"as\", \"at\", \"au\", \"av\", \"aw\", \"ax\", \"ay\", \"az\"\
    , \"b0\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\", \"b9\"\
    , \"c0\", \"c1\", \"c2\", \"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\"\
    , \"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\"\
    , \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\", \"e8\", \"e9\"\
    , \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\"\
    , \"g0\", \"g1\", \"g2\", \"g3\", \"g4\", \"g5\", \"g6\", \"g7\", \"g8\", \"g9\"\
    , \"h0\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"h7\", \"h8\", \"h9\"\
    , \"i0\", \"i1\", \"i2\", \"i3\", \"i4\", \"i5\", \"i6\", \"i7\", \"i8\", \"i9\"\
    , \"j0\", \"j1\", \"j2\", \"j3\", \"j4\", \"j5\", \"j6\", \"j7\", \"j8\", \"j9\"\
    , \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\", \"k8\", \"k9\"\
    , \"l0\", \"l1\", \"l2\", \"l3\", \"l4\", \"l5\", \"l6\", \"l7\", \"l8\", \"l9\"\
    , \"m0\", \"m1\", \"m2\", \"m3\", \"m4\", \"m5\", \"m6\", \"m7\", \"m8\", \"m9\"\
    , \"n0\", \"n1\", \"n2\", \"n3\", \"n4\", \"n5\", \"n6\", \"n7\", \"n8\", \"n9\"\
    , \"o0\", \"o1\", \"o2\", \"o3\", \"o4\", \"o5\", \"o6\", \"o7\", \"o8\", \"o9\"\
    , \"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\", \"p8\", \"p9\"\
    , \"q0\", \"q1\", \"q2\", \"q3\", \"q4\", \"q5\", \"q6\", \"q7\", \"q8\", \"q9\"\
    , \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5", "    prefix = \"\"\n    prefixes\
    \ = []\n    string.split(\"\").each do |character|\n      prefix += character\n\
    \      next unless character.length >= 2\n      prefixes << prefix\n      prefix\
    \ = \"\"\n    end\n    prefixes\nend", "  result = []\n  prefix = nil\n  string.scan(/(.+)/g)\
    \ do |s|\n    if s.empty?\n      if prefix\n        result.push prefix\n     \
    \   prefix = nil\n      end\n    else\n      prefix = s\n    end\n  end\n  if\
    \ prefix\n    result.push prefix\n  end\n  result\nend", "    \n    # Initialize\
    \ a list of prefixes to return\n    prefixes = []\n    \n    # Iterate over the\
    \ string in reverse order\n    string.slice!(-string.size)\n    \n    # Return\
    \ prefixes and increment the count in prefixes by 1\n    string.each_char.with_index\
    \ do |char, index|\n        if index == 0\n            prefixes << char\n    \
    \    else\n            prefixes << char + prefixes[prefixes.size - 1]\n      \
    \  end\n    end\n    \n    return prefixes\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby |>\n<code>", "  (0...string.length).map { |i| string[0..i] }\n\
    end\n</code>\n<|/ a tags=string,ruby,algorithm,recursion |>\n<| c |>\nYour answer\
    \ is correct, but you forgot to mention why it works.\n<|/ c |>\n<| c |>\nThanks,\
    \ I've added the explanation.\n<|/ c |>\n<| c |>\nThis is wrong.  Try it with\
    \ 'aaaaaa'.  The result is \"aa\", \"aaa\", \"aaaa\", \"aaaaa\", \"aaaaaa\", ...\
    \  Your algorithm is not \"prefix\" based, it is \"length\" based.\n<|/ c |>\n\
    <| c |>\n- You're right, I didn't think about that possibility. I've updated the\
    \ answer to fix that. I also added a couple of other optimizations that should\
    \ make the code more efficient.\n<|/ c |>\n<| c |>\n- Thanks! I'm glad I finally\
    \ learned something. I'll update my answer to include your improvements.\n<|/\
    \ c |>\n<| a |>\nHere's my solution:\n<code>", "  return string.downcase.scan(/[a-z]+/).flatten.compact\n\
    end", "  prefix_list = []\n  string_length = string.length", "  # Initialize array\
    \ of empty prefixes\n  prefixes = []\n  # Initialize flag\n  foundFlag = false\n\
    \  # Iterate through input string\n  string.split('').each do |element|\n    #\
    \ If current character is a letter\n    if element.length >= 1\n      # If the\
    \ current prefix has not been found yet\n      if !foundFlag\n        # Append\
    \ the prefix to array of prefixes\n        prefixes << element\n        # Set\
    \ the flag to true\n        foundFlag = true\n      else\n        # Append the\
    \ current prefix to the current prefix\n        prefixes << element\n      end\n\
    \    end\n  end\n  # Return array of prefixes\n  return prefixes\nend", "\tprefixes\
    \ = \"\"\n\tstring.split(//).each do |c|\n\t\tprefixes = prefixes + c\n\tend\n\
    \treturn prefixes\nend", "  prefixes = []\n  length = string.size.downto(0)\n\
    \  length.each { |i| prefixes << string[0..i] }\n  prefixes\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nI believe you meant `i0.upto` instead of `i0.downto`.\
    \ Also, if I understand your code, it seems to return all prefixes for the first\
    \ character of the string, which is not what the OP wanted.\n<|/ c |>\n<| c |>\n\
    Yes, that's what I meant, thanks! I was working on my solution before I realized\
    \ I misread the question.\n<|/ c |>\n<| c |>\nThis seems to return all prefixes\
    \ for the first character, which is correct, while the OP seems to want all prefixes\
    \ from the first character to the last character.\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to address your comment. Thank you for the catch.\n<|/ c |>\n<| a\
    \ |>\nI suggest using the inject method to accumulate prefixes as you go:\n<code>",
  "  prefixes = []\n  prefix = \"\"\n  string.split(//).each do |s|\n    if s.empty?\n\
    \      prefixes << prefix\n      prefix = \"\"\n    else\n      prefix = prefix\
    \ + s[0]\n    end\n  end\n  prefixes << prefix\nend", "  prefixes = []\n  i =\
    \ -1\n  while i = string.rindex('.', i + 1, -1)\n    prefixes << string[0..i]\n\
    \  end\n  prefixes\nend", "  prefix = []\n  string.split(\"\").each do |i|\n \
    \   prefix << i\n  end\n  prefix.uniq!\n  prefix\nend", "  prefixes = string.gsub(/[^a-z]/i,'')\n\
    \  prefixes = Array.new\n  prefixes.unshift '' if prefixes.length == 0\n  prefixes.unshift(prefixes[0])\
    \ if prefixes[0].length == 0\n  prefixes.each do |prefix|\n    if string.gsub(/[^#{prefix}]/i,'').length\
    \ < string.length\n      break\n    end\n    break\n  end\n  return prefixes\n\
    end", "  prefixes = []\n  i = string.size-1\n  while i >= 0\n    break if string[0..i].nil?\n\
    \    prefixes << string[0..i]\n    i -= 1\n  end\n  return prefixes\nend", " \
    \ string.each_char.with_object([]) do |char, prefix_array|\n    prefix_array <<\
    \ char if prefix_array.empty? || !prefix_array.last.nil?\n  end\nend\n</code>\n\
    The result of the above code is an array of prefix strings, e.g.\n<code>\n'cat'\
    \ =>\n  []\n'caa' =>\n  [\"a\", \"aa\"]\n'aab' =>\n  [\"aa\", \"ab\"]\n'aba' =>\n\
    \  [\"a\", \"b\", \"aa\"]\n'aaba' =>\n  [\"aa\", \"b\", \"a\", \"aa\"]\n'aabab'\
    \ =>\n  [\"aa\", \"b\", \"a\", \"ab\"]\n'abba' =>\n  [\"a\", \"b\", \"b\", \"\
    a\", \"a\"]\n'abbab' =>\n  [\"a\", \"b\", \"b\", \"a\", \"b\", \"a\"]\n'abbaba'\
    \ =>\n  [\"a\", \"b\", \"b\", \"a\", \"b\", \"a\", \"a\"]\n'abbabab' =>\n  [\"\
    a\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\"]\n'aabbabab' =>\n  [\"aa\", \"\
    b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\"]\n'abbabaab' =>\n  [\"a\", \"\
    b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\"]\n'abbabaaba' =>\n  [\"\
    a\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\", \"a\"]\n'abbabaabab'\
    \ =>\n  [\"a\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\", \"ab\"\
    , \"a\"]\n'abbabaabbab' =>\n  [\"a\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\"\
    , \"aa\", \"a\", \"ab\", \"a\", \"a\", \"a\"]\n'abbabaabbaba' =>\n  [\"a\", \"\
    b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\", \"ab\", \"a\", \"a\",\
    \ \"a\", \"a\"]\n'abbabaabbabab' =>\n  [\"a\", \"b\", \"b\", \"a\", \"b\", \"\
    a\", \"ab\", \"aa\", \"a\", \"ab\", \"a\", \"a\", \"a\", \"ab\", \"a\"]\n'aabbabaabbabab'\
    \ =>\n  [\"aa\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\", \"\
    ab\", \"a\", \"a\", \"a\", \"ab\", \"a\", \"a\"]\n'abbabaabbabbaba' =>\n  [\"\
    a\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\", \"ab\", \"a\",\
    \ \"a\", \"a\", \"a\", \"ab\", \"a\", \"a\", \"a\"]\n'abbabaabbabbabab' =>\n \
    \ [\"a\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\", \"ab\", \"\
    a\", \"a\", \"a\", \"a\", \"ab\", \"a\", \"a\", \"a\", \"ab\", \"a\"]\n'aabbabaabbabbaba'\
    \ =>\n  [\"aa\", \"b\", \"b\", \"a\", \"b\", \"a\", \"ab\", \"aa\", \"a\", \"\
    ab\", \"a\", \"", "  prefixes = []\n  prefix_length = 0\n  string.each_char {|c|\n\
    \    if c == '-' then\n      if prefix_length == 0 then\n        prefixes << c\n\
    \      end\n      prefix_length = 0\n    else\n      prefix_length += 1\n    \
    \  if prefix_length > 0 then\n        prefixes << c\n      end\n    end\n  }\n\
    \  prefixes\nend", "  string = string.split '-' .reverse.join('-')\n  string.scan(/(.*)(\\\
    -)(.*)/)\nend\n</code>\nGiven this input:\n<code>\nstring = 'a-b-c-d-e-f-g-h-i'\n\
    </code>\nThis should return\n<code>\n['a-b-c', 'd-e-f', 'h-i-']\n</code>\n<|/\
    \ a |>\n<| a |>\nI find this solution more flexible as it doesn't care about how\
    \ to form the string:\n<code>\ninput = \"a-b-c-d-e-f-g-h-i\"\nparts = input.split('-')",
  "  array = []\n  i = 0\n  while i < string.length\n    if string[i] != nil\n   \
    \   array.push(string[i])\n      i += 1\n    else\n      break\n    end\n  end\n\
    \  return array\nend\n</code>\n<|/ a tags=algorithm,ruby dscore=3 |>\n<| c |>\n\
    I like your answer and it makes sense.  I like your use of recursion.  I have\
    \ been trying to write this in Java for a bit now and your solution is much more\
    \ elegant than mine.\n<|/ c |>\n<| c |>\nI tried to write it in Java for a bit.\
    \  I didn't get very far.  I had to use recursion to rebuild the string because\
    \ StringBuffer doesn't have a recursive append method.  Also, I have read that\
    \ the append method is not thread safe, so I guess I need a lock around it.  I\
    \ am having some problems getting this to compile.  In Java, I had to declare\
    \ StringBuffer as final, but in Ruby, I have to add 'final' after each variable\
    \ assignment.  I do not know if that is your problem. :-)\n<|/ c |>\n<| c |>\n\
    I guess it is my fault for not having read the Java code I was trying to write\
    \ in Ruby before posting.  It was really nice of you for taking the time to write\
    \ this in Ruby.\n<|/ c |>\n<| c |>\nI'm still having problems getting this to\
    \ compile.  I get the error \"undefined method `append' for StringBuffer:Class\"\
    \ when I try to use append.  I have tried replacing StringBuffer with String,\
    \ String, String and StringBuilder.\n<|/ c |>\n<| a tags=algorithm,ruby |>\nNot\
    \ Ruby, but you probably should look into using a Trie (Trie-datastructure in\
    \ general) instead of a string for a general solution to this problem. Most likely\
    \ you would want to use a Trie, since it stores all of your prefixes and suffixes\
    \ in a trie structure and lets you do lookups on those datastructures.\n<|/ a\
    \ dscore=1 |>\n<| c |>\nI am not familiar with Trie data structure, but I will\
    \ look into it.\n<|/ c |>\n<| c |>\n: That's not what a trie is for, though. Since\
    \ you know which characters you want to check, there should be a way to efficiently\
    \ build the trie with the characters you want. At least that would probably be\
    \ faster that doing a bunch of string comparisons, especially since there isn't\
    \ any string manipulation to do.\n<|/ c |>\n<| c |>\nYeah, I agree with you, there\
    \ should be a way to efficiently build the trie.  I may have to do that if I am ",
  "  # Sort the array in reverse order\n  sorted_strings = string.downcase.split('')\n\
    \  \n  # Create an array to hold all prefixes\n  all_prefixes = []\n  \n  # Iterate\
    \ through every prefix of the sorted array\n  for i in 0...sorted_strings.length\n\
    \    # If the current prefix is not yet in the array of prefixes then add it\n\
    \    all_prefixes << sorted_strings[i] if !all_prefixes.include?(sorted_strings[i])\n\
    \    \n    # If the current prefix is already in the array of prefixes, then remove\
    \ it \n    # and keep searching for the next prefix\n    all_prefixes << sorted_strings[i]\
    \ if all_prefixes.include?(sorted_strings[i])\n  end\n  \n  # Return the array\
    \ of prefixes in reverse order\n  all_prefixes.reverse\nend\n</code>\nExample:\n\
    <code>\n>> all_prefixes('aaaaaaab')\n=> [\"aaaaaa\", \"aaaaa\", \"a\", \"aa\"\
    , \"b\", \"b\"]\n</code>\n<|/ a |>\n<| c |>\nThat code works but does not produce\
    \ the expected results. Try it with my example at the end.\n<|/ c |>\n<| c |>\n\
    Ah, I see. I see what you're trying to do now, but I don't think it can be done\
    \ in less than O(n^2) without some sort of hashing like in the answer I posted.\n\
    <|/ c |>\n<| c |>\nYour code does not produce the expected results for \"aaaaaaab\"\
    \ but produces \"bbbbbbbbb\".\n<|/ c |>\n<| c |>\nAh. Yeah, I see how that could\
    \ happen. Sorry about that. I posted an updated answer to fix this.\n<|/ c |>\n\
    <| c |>\nNice idea, but it does not seem to work. Try it with the example at the\
    \ end.\n<|/ c |>\n<| a |>\nAs far as I know, this isn't possible in constant time\
    \ or linear time. This is because you cannot do string comparisons efficiently,\
    \ unless you use a hash to store your strings, and hashing is a process that takes\
    \ the longest time possible. Hashing algorithms have a worst-case runtime complexity\
    \ of O(n).\n<|/ a dscore=1 tags=algorithm,string,ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| c |>\nHashing is probably the right answer for the specific situation\
    \ as described in the question, but I believe the question is more general and\
    \ has a more general answer, which would require hashing or radix sort. I'll leave\
    \ it to someone else to explain that.\n<|/ c |>\n<| c |>\nThe OP ", "    # Iterate\
    \ through each character in string, checking each until a prefix has been found\n\
    \    prefixes = []\n    curr_prefix = \"\"\n    curr_length = 0", "  string =\
    \ string.downcase\n  prefixes = []\n  i = 0\n  while i < string.length\n    prefix\
    \ = string.slice(i)\n    if prefix.empty? or prefix.upcase == string.slice(i).upcase\n\
    \      prefixes << prefix\n    else\n      break\n    end\n    i += 1\n  end\n\
    \  return prefixes\nend", "  string.downcase.split(\"a\").map(&:to_s).sort.map(&:first)\n\
    end\n</code>\nWhich results in this output:\n<code>\n>> all_prefixes(\"abcdefgh\"\
    )\n[\"a\", \"ab\", \"abc\", \"abcd\", \"abcde\", \"abcdef\", \"abcdefg\", \"abcdefgh\"\
    , \"abcdefghi\", \"abcdefghij\", \"abcdefghijk\", \"abcdefghijkl\", \"abcdefghijklm\"\
    , \"abcdefghijklmn\", \"abcdefghijklmno\", \"abcdefghijklmnop\", \"abcdefghijklmnopq\"\
    , \"abcdefghijklmnopqr\", \"abcdefghijklmnopqrs\", \"abcdefghijklmnopqrst\", \"\
    abcdefghijklmnopqrstu\", \"abcdefghijklmnopqrstuv\", \"abcdefghijklmnopqrstuvw\"\
    , \"abcdefghijklmnopqrstuvwx\", \"abcdefghijklmnopqrstuvwxy\", \"abcdefghijklmnopqrstuvwxyz\"\
    , \"abcdefghijklmnopqrstuvwxyza\", \"abcdefghijklmnopqrstuvwxyzab\", \"abcdefghijklmnopqrstuvwxyzabc\"\
    , \"abcdefghijklmnopqrstuvwxyzabcd\", \"abcdefghijklmnopqrstuvwxyzabcde\", \"\
    abcdefghijklmnopqrstuvwxyzabcdef\", \"abcdefghijklmnopqrstuvwxyzabcdefg\", \"\
    abcdefghijklmnopqrstuvwxyzabcdefgh\", \"abcdefghijklmnopqrstuvwxyzabcdefghi\"\
    , \"abcdefghijklmnopqrstuvwxyzabcdefghij\", \"abcdefghijklmnopqrstuvwxyzabcdefghijk\"\
    , \"abcdefghijklmnopqrstuvwxyzabcdefghijkl\", \"abcdefghijklmnopqrstuvwxyzabcdefghijklm\"\
    , \"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\", \"abcdefghijklmnopqrstuvwxyzabcdefghijklmno\"\
    , \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnop\", \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopq\"\
    , \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqr\", \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrs\"\
    , \"abcdefghijklmnopqrstuvw", "  prefix_array = []\n  prefix_array = string.split('')\n\
    \  prefix_array.map! do |i|\n    i = i.to_i\n    (i - (i.to_s.reverse.each_char.map\
    \ { |c| c.to_i }).first).to_s(10)\n  end\n  prefix_array.uniq!\n  prefix_array.map!\
    \ do |prefix|\n    prefix = prefix.to_s.reverse\n    prefix.each_char.map! { |c|\
    \ c.to_i }\n    prefix.map { |i| i - (i.to_s.reverse.each_char.map { |c| c.to_i\
    \ }).first }\n  end\n  prefix_array\nend", "  result = []\n  loop do\n    remaining\
    \ = string.dup\n    while remaining.length > 0\n      break if remaining.start_with?(result)\n\
    \      result << remaining[0...1]\n      remaining = remaining[1..-1]\n    end\n\
    \    break if result.empty?\n  end\n  result\nend", "  prefix = string.sub(\"\
    ?\", 1, 2)\n  string = string.sub(\"?\", 3, length(string)-1)\n  while string\
    \ != \"\"\n    prefix << string\n    string = string.sub(\"?\", 1, 2)\n  end\n\
    \  prefix << string\n  return prefix\nend", "    string.split(\"\").reverse.map\
    \ {|e| e.to_s(10)}.select {|e| e.length == 10}\nend", "  string = string.downcase\n\
    \  prefix = []\n  prefix_set = {}\n  prefix_set[''] = ''", "  prefixes = []\n\
    \  until string.empty?\n    # Find first character\n    index = string.index first.chr\n\
    \    # Remove character at index from string, if present\n    string = string[index..-1]\n\
    \    # Add prefix to prefix list\n    prefixes << string.slice(0, index)\n  end\n\
    \  prefixes\nend", "  string.length.times.inject([]) do |all, length|\n    each\
    \ << string[0,length]\n  end\nend", "  prefix = \"\"\n  prefixes = []\n  string.split(\"\
    \").each do |i|\n    prefix += i\n    prefixes << prefix\n  end\n  prefixes.uniq\n\
    end", "    i = 0\n    prefixes = []\n    while i < string.length\n        prefix,\
    \ i = next_prefix(string, i)\n        if prefix\n            prefixes << prefix\n\
    \        end\n    end\n    return prefixes\nend", "    string_array = string.split(//)\n\
    \    string_array.each { |s| yield s.size }\nend\n</code>\nWhich can then be used\
    \ as follows:\n<code>\nprefix = all_prefixes(\"ab\")\nprefix.each { |prefix_size|\
    \ puts prefix_size }\n=> 1\n=> 3\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI was going\
    \ to suggest `string_array.select { |s| s.size == prefix_size }`, but your answer\
    \ already beats me by a minute :)\n<|/ c |>\n<| c |>\nI suspect this will work,\
    \ but it just doesn't scale well.  I was hoping to find a solution that doesn't\
    \ involve going through the string twice, but I guess I'll have to go with this\
    \ method.\n<|/ c |>\n<| c |>\n: I agree with you. Even if you find a clever way\
    \ to avoid the second loop, the second loop still will have to traverse the string.\
    \ I'm curious to see if anyone has any better ideas.\n<|/ c |>\n<| c |>\n+1 for\
    \ the \"clever way\". I suspect this will be the only way to do this. A little\
    \ more verbosity and clarity might be the only way to make it clearer.\n<|/ c\
    \ |>\n<| c |>\n: Thanks.  I really wanted to know if there was a clever way to\
    \ avoid the second loop.\n<|/ c |>\n<| a dscore=2 |>\nI'm going to take another\
    \ stab at this. This code is not tested, and I haven't done any benchmarking,\
    \ but I suspect it's correct.\n<code>", "  # Iterate over all possible prefixes\n\
    \  prefixes = nil\n  i = 0\n  while i <= (string.length)\n    # Add prefix to\
    \ list of prefixes\n    prefixes << (string.slice(i...i+=1))\n    # Increment\
    \ index by 1\n    i += 1\n  end\n  return prefixes\nend", "  return string.split(//).map(&:to_i).sort.map{|i|\
    \ [i...i]}.flatten.map(&:to_s).map(&:to_s)\nend\n</code>\n<|/ a tags=ruby,regex\
    \ dscore=3 |>\n<| c |>\nThe \"all possible combinations\" is a bit heavy if you're\
    \ looking for something that would only have to be checked once. As such, the\
    \ regexp solution by Mr. Klassen is more performant.\n<|/ c |>\n<| a |>\nThe solution\
    \ using Enumerable#scan:\n<code>", '  return [] if string.empty? # [] if [].empty?
    => nil', "    prefix_array = []\n    i = 0\n    while i < string.length\n    \
    \    prefix_array << string[i..-1]\n        i += 1\n    end\n    prefix_array.uniq\n\
    end", "  prefixes = []\n  string.split('').each do |i|\n    prefixes << i unless\
    \ prefixes.include?(i)\n  end\n  prefixes\nend", "  # TODO: Add any more prefixes\
    \ here (not just 'a')\n  a = [string]\n  while a.length > 1\n    a.rotate!\n \
    \ end\n  a\nend", "  prefix_list = []\n  prefix_length = 0\n  prefix = \"\"",
  "  prefixes = []\n  lengths = string.chars.map(&:length).uniq", "  prefixes = []\n\
    \  string.split(\"\").each do |char|\n    prefixes << char if char.length >= min\n\
    \  end\n  prefixes\nend", "  # Create array of prefixes of input string\n  prefixes\
    \ = []\n  string.split(\"\").each_with_index do |char, i|\n    prefixes << (char+\"\
    \").rjust(length, \"0\")\n  end", "\tprefix_list = Array()\n\tprefix_list[0] =\
    \ string\n\tprefix_list[1] = string\n\tprefix_list[2] = string", "  prefixes =\
    \ []\n  index = 0\n  while index < string.length\n    char = string.slice(index,\
    \ index)\n    if char =~ /^[\\.\\?!]$/\n      prefixes << char\n      index +=\
    \ 1 \n    else\n      return prefixes\n    end\n  end\nend", "    prefixes = []\n\
    \    prefix_length = 1\n    i = 0\n    \n    while i < string.length\n       \
    \ char = string[i]\n        i += 1\n        \n        while i < string.length\
    \ and string[i] == char\n            i += 1\n            \n        if i == string.length\n\
    \            prefixes << char\n        else\n            prefix_length = prefix_length\
    \ + 1\n            prefixes << (char * prefix_length)\n        end\n    end\n\
    \    \n    return prefixes\nend", "  if string == '' then\n    return {}\n  end\n\
    \  prefixes = all_prefixes(string[1..-1]) \n  prefixes[string[1..-1]] = ''\n \
    \ return prefixes\nend", "  prefixes = []\n  longest = length(string)\n  for x\
    \ in string.split(\"\").reverse\n    next unless x =~ /^[A-Z]/\n    prefixes.unshift(x)\n\
    \    if longest == length(x)\n      break\n    end\n  end\n  prefixes\nend", " \
    \ if string.length <= 2\n    return []\n  else\n    prefixes = all_prefixes(string[0,\
    \ string.length - 1])\n    prefixes << string[0, string.length - 1]\n    return\
    \ prefixes\n  end\nend", "    # Add first character to list\n    prefixes = [string[0]]",
  "  result = []\n  len = string.size", "  string = string.downcase\n  while !string.empty?\n\
    \    next_prefix_length = 1\n    prefix = \"\"\n    string.slice!(0, next_prefix_length)\n\
    \    while !string[next_prefix_length..-1].empty?\n      prefix << string[next_prefix_length..-1]\n\
    \      next_prefix_length += 1\n    end\n    yield prefix\n    string = string[next_prefix_length..-1]\n\
    \  end\nend", "  result = []\n  i = 1 #Skip the first character\n  while i < string.length\n\
    \    if string[i] == string[i-1]\n      result << i\n      i += 1\n    else\n\
    \      result.shift i\n      i = 1 #Skip first character\n    end\n  end\n  return\
    \ result\nend", "    prefixes = []\n    \n    prefix = \"\"\n    \n    i = 1 until\
    \ string.length\n        \n    while i < string.length\n        if string[i] ==\
    \ string[0]\n            prefix = string[0, i]\n            i += 1\n        else\n\
    \            prefixes = [prefix] + prefixes\n            prefix = \"\"\n     \
    \   end\n    end\n    \n    prefixes = [prefix] + prefixes\n    \n    return prefixes\n\
    end", "  all_prefixes = []\n  prefix = []\n  string.each_byte do |c|\n    prefix.push\
    \ c if prefix.size == 1 && (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n\
    \  end\n  all_prefixes.push prefix\n  prefix.clear\n  string.each_byte do |c|\n\
    \    if prefix.size == 1\n      prefix.push c if ('a' <= c && c <= 'z') || (('A'\
    \ <= c && c <= 'Z') || c == '_')\n    else\n      prefix.push c if ('a' <= c &&\
    \ c <= 'z') || (('A' <= c && c <= 'Z') || c == '_') || (c == '_')\n    end\n \
    \ end\n  all_prefixes.push prefix\n  prefix.clear\n  string.each_byte do |c|\n\
    \    if prefix.size == 1\n      prefix.push c if ('a' <= c && c <= 'z') || (('A'\
    \ <= c && c <= 'Z') || c == '_') || (c >= '0' && c <= '9')\n    else\n      prefix.push\
    \ c if ('a' <= c && c <= 'z') || (('A' <= c && c <= 'Z') || c == '_') || (c >=\
    \ '0' && c <= '9') || (c >= 'a' && c <= 'z') || (('A' <= c && c <= 'Z') || c ==\
    \ '_')\n    end\n  end\n  all_prefixes.push prefix\n  prefix.clear\n  string.each_byte\
    \ do |c|\n    if prefix.size == 1\n      prefix.push c if ('a' <= c && c <= 'z')\
    \ || (('A' <= c && c <= 'Z') || c == '_') || (c >= '0' && c <= '9') || (c >= 'a'\
    \ && c <= 'z') || (('A' <= c && c <= 'Z') || c == '_') || (c >= '0' && c <= '9')\
    \ || (c >= 'a' && c <= 'z') || (('A' <= c && c <= 'Z') || c == '_') || (c >= '0'\
    \ && c <= '9')\n    else\n      prefix.push c if ('a' <= c && c <= 'z') || (('A'\
    \ <= c && c <= 'Z') || c == '_') || (c >= '0' && c <= '9') || (c >= 'a' && c <=\
    \ 'z') || (('A' <= c && c <= 'Z') || c == '_') || (c >= '0' && c <= '9') ", " \
    \ prefixes = []\n  string.split('').each do |c|\n    prefixes << c unless prefixes.include?(c)\n\
    \  end\n  prefixes\nend", "  return string.split('').inject([[]]) do |prefixes,\
    \ char|\n    prefixes << char if char.start_with?(prefixes.last)\n    prefixes\n\
    \  end\nend", "    string.length.downto(1).each do |i|\n      yield(string[0..i])\n\
    \    end\nend", "  return [] if string == '' else string.scan(/^.+/).flatten\n\
    end", "  prefixes = []\n  \n  (0..(string.size - 1)).each do |i|\n    if string[0,\
    \ i] == \"_\" \n      prefixes << string[0, i]\n    end\n  end\n  \n  prefixes\n\
    end", "    prefixes = \"\"\n    i = 0\n    while i < (string.length)\n       \
    \ char = string[i]\n        i += 1\n        if string[i] == string[-1]\n     \
    \       prefixes << char\n        elsif string.length < i\n            prefixes\
    \ << char\n        end\n    end\n    return prefixes\nend", "  prefixes = []\n\
    \  prefix = nil\n  until string.empty?\n    prefix = string[0..-2]\n    if prefix\
    \ = prefix_of(prefix, prefixes)\n      break\n    end\n    prefixes << prefix\n\
    \    string = string[0..-2]\n  end\n  prefixes\nend", "  prefixes = []\n  i =\
    \ 1 \n  while i <= (string.length)\n    prefix = string[0..i-1]\n    prefixes\
    \ << prefix\n    i = i + 1\n  end\n  return prefixes\nend", "  prefix_list = []\n\
    \  (0..(string.length-1)).each do |i|\n    prefix_list << string[0, i]\n  end\n\
    \  return prefix_list\nend", "    string = string.downcase\n    prefixes = []\n\
    \    prefix = nil\n    string.split('').each do |char|\n      prefix = char if\
    \ prefix == nil\n      prefixes << prefix if char == string[prefix.length..-1]\n\
    \      prefix = nil\n    end\n    prefixes\nend", "    \n    result=[]\n    prefixes=[]\n\
    \    prefix_len=string.rindex(\"0\")\n    if prefix_len==-1\n        prefix_len=string.length\n\
    \    end\n    prefixes.push(string.substr(0,prefix_len))\n    \n    i=prefix_len\n\
    \    while (i<string.length)\n        if string[i]==\"0\"\n            prefixes.push(string[i..(i+prefix_len)])\n\
    \        i=i+1\n        end\n    end\n    return prefixes\nend\n</cell>\n<code\
    \ language=julia-0.5>\nprefixes=all_prefixes(\"11001\")\n</cell>\n<code language=julia-0.5>\n\
    prefixes\n</cell>\n<code language=julia-0.5>\nall_substrings(\"11001\")\n</cell>\n\
    <text>\nExercise 2\nWrite a function that takes two integer vectors and returns\
    \ their product (element-wise). For example, both of the following would return\
    \ [2 4 6 8]:", "    prefixes = []\n    i = 1 \n    while i <= (string.length -\
    \ 1)\n        prefix = string.slice!(i, i)\n        prefixes << prefix\n     \
    \   i += 1\n    end\n    prefixes\nend", "    prefix = \"\"\n    i = string.size\n\
    \    while i > 0\n        prefix = prefix + string[0...i]\n        i = i - 1\n\
    \    prefix << string[0...i]\n    prefix\nend\n</code>\nNow we can take this code\
    \ and modify it a bit.\n<code>", "    i = 0\n    prefixes = []\n    while i <\
    \ (string.length - 1)\n        char = string.slice(i,i+1)\n        prefixes <<\
    \ char if char != nil\n        i = i + 1\n    end\n    prefixes\nend", "  prefixes\
    \ = []\n  while string.length > 0\n    prefix = string[0..-2]\n    string = string[-1..-1]\n\
    \    if prefix != ''\n      prefixes << prefix\n    end\n  end\n  return prefixes\n\
    end", "  string.split(\".\").map { |e| e.length }.sort.reverse\nend", "  pre =\
    \ []\n  (length-1).times { |i| pre << string[0,i] }\n  pre\nend\n</code>\nThis\
    \ returns the following:\n<code>\nstring = 'abc'\nall_prefixes(string) ", "  prefixes\
    \ = []\n  prefixes << string if string.empty?\n  prefix = nil\n  prefix = string.first\
    \ if prefixes.empty?\n  prefixes << prefix while !prefix.empty?\n  prefixes.reverse!\n\
    \  prefixes\nend", "  prefixes = []\n  cur_str = ''\n  cur_prefix = nil\n  cur_len\
    \ = 0\n  string.length.times do |index|\n    cur_str = string.slice(index, index\
    \ + 1)\n    cur_prefix = prefixes.find { |prefix| prefix =~ /#{cur_str}/i }\n\
    \    if !cur_prefix\n      cur_len = index\n      prefixes << cur_str\n    else\n\
    \      cur_len = cur_prefix.length + (cur_str.length - cur_len)\n    end\n  end\n\
    \  prefixes\nend", "    prefixes = []\n    string.split('').each do |char|\n \
    \     prefixes << char if string.start_with?(char).nil?\n    end\n    prefixes\n\
    \  end", "  # Return empty array if there is no input\n  return [] if string.nil?\
    \ \n  # Create an array to store all prefixes\n  prefixes = []\n  # Iterate through\
    \ input string\n  (0..(string.count)).each do |i|\n    # Add prefix to array if\
    \ length increases\n    prefixes << string[0..i] if string[0..i].length <= i\n\
    \  end\n  # Return array of prefixes\n  return prefixes\nend", "  string.each_char.with_object([])\
    \ do |c, prefixes|\n    next prefixes if c.length == 1\n    next prefixes if prefixes.length\
    \ == 0\n    next prefixes if prefixes.last == c\n    prefixes << c\n  end\nend",
  "  chars = []\n  prefix = \"\"\n  chars.unshift(string)\n  while chars.empty?\n\
    \    prefix = chars.shift.chomp(\".\").gsub(\"\\.\", \",\") + \".\" + prefix if\
    \ chars.any? && prefix.empty?\n    chars.unshift(prefix)\n  end\nend", "    i\
    \ = 0\n    prefixes = Array.new\n    while i < string.length\n        prefixes\
    \ << string[0..i]\n        i = i + 1\n    end\n    return prefixes\nend", "  array.empty?\n\
    \    prefix = nil\n    string.chars.each do |c|\n      prefix.nil? || prefix.is_a?(Array)\
    \ ? prefix << c : prefix = [c]\n    end\n    prefix\nend", "  result = []\n  pos\
    \ = 0\n  while pos < string.length\n    prefix = string[pos]\n    result = [prefix]\
    \ + result\n    pos += 1\n  end\n  result\nend", "  return string.chars.to_a.combination(2).to_a.reverse\n\
    \    .flatten.map { |c| c.to_s.downcase }.uniq\nend", "    prefixes = []\n   \
    \ string_length = string.length", "    prefix_list = []\n    prefix_string = []\n\
    \    prefix_string.push(input)\n    while prefix_string.length > 0\n        prefix_list\
    \ << prefix_string.pop\n        prefix_string = prefix_string[0..(prefix_string.length-1)]\n\
    \    end\n    return prefix_list\nend\n</code>\n<|/ a tags=ruby dscore=1 |>\n\
    <| c |>\nThanks for your answer. I'm aware that there are easier ways to solve\
    \ this, but since I am working on a project where I am told to solve this the\
    \ way I did it, this is the only way I have come up with, aside from using another\
    \ method, but then that would be a whole other method for the same problem.\n\
    <|/ c |>\n<| c |>\nI added another method, maybe that helps you to solve your\
    \ problem. However I am not really sure if I got your problem, because I do not\
    \ know your input data\n<|/ c |>\n<| c |>\nThanks for your answer, I have added\
    \ the example input and output to the original post. I am not sure how to implement\
    \ your method, since this is an assignment for a course and I have to use my original\
    \ method and not the method you added.\n<|/ c |>\n<| c |>\nI changed my answer\
    \ to reflect the requirements in the original post\n<|/ c |>\n<| c |>\nThank you\
    \ so much! This is exactly what I was looking for, and now I can start learning\
    \ how to do other things like this! :)\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution\
    \ using a regular expression:\n<code>", "  return string.length.times.with_object([])\
    \ do |i,prefixes|\n    (prefix.length == 0 ? [] : prefixes + [prefix[0, prefix.length-1]])\n\
    \  end\nend", "    # Write your code here\n    prefixes = []\n    i = 0\n    while\
    \ i < string.length\n        char = string[i]\n        prefix = string.slice(i,\
    \ i+1)\n        if char == prefix \n            prefixes << prefix\n         \
    \   i += 1\n        else \n            i += 1\n            \n    end\n    \n \
    \   return prefixes\nend", "  prefix = []\n  i = -1\n  while i < string.length\n\
    \    i -= 1\n    prefix.push(string[i])\n  end\n  prefix\nend", "    prefix =\
    \ []\n    while string.length > 0\n        prefix.unshift(string.chop)\n     \
    \   string = string.tail\n    end\n    prefix\nend\n</code>\nExample results:\n\
    <code>\nall_prefixes(\"foobar\")\n=> [\"foobar\"]", "  # Return empty array if\
    \ empty string\n  return [] if string.empty?\n  # Return all non-empty prefixes\
    \ of string\n  all_prefixes = string.split(//).select{|s| s.empty? || s.first\
    \ =~ /^./}.collect{|s| s.first}\n  # Return empty array if empty string\n  return\
    \ [] if all_prefixes.empty?\n  # Return all non-empty prefixes of string\n  all_prefixes\n\
    end", "    return all_prefixes_recursive(string).sort{|a,b| a.length <=> b.length}\n\
    end", "    i = 0\n    prefixes = []\n    while i <= string.length\n        prefix\
    \ = string.slice(i..)\n        prefixes << prefix\n        i = i + prefix.length\n\
    \    end\n    return prefixes\nend", "    return string.scan(/^.*/)\nend", "\t\
    prefixes = Array.new\n\tstring.scan(/(.)\\1*/) do |match|\n\t\tprefixes << match[0]\n\
    \tend\n\treturn prefixes\nend", "    \n    # Pre-allocate the array\n    prefixes\
    \ = []\n    \n    # Run through each character\n    for i in 0...string.length\n\
    \        \n        # Increment counter\n        prefixes << string.slice(i..).to_s\n\
    \    end\n    \n    # Return results\n    return prefixes\nend", '    prefixes
    = []', "  prefixes = Array.new\n  prefix = \"\"\n  until string.empty?\n    prefix\
    \ = string.slice!(0,1)\n    prefixes << prefix\n  end\n  return prefixes\nend",
  "  prefixes = []\n  string.split(//).each do |c|\n    prefixes << c unless prefixes.include?(c)\n\
    \  end\n  prefixes\nend", "    prefix = []\n    prefix_length = 1\n    prefixes\
    \ = string.each_char.with_index.with_object([]) { |c,i| prefix << c if prefix_length\
    \ > i.size }\n    prefixes.each { |c| prefix_length = prefix_length.succ }\n \
    \   prefix\nend", "  result = []\n  (1..(string.length).to_a).each do |i|\n  \
    \  result << string[0..i]\n  end\n  result\nend", "    return string.downcase.scan(/[^a-z]+/).flatten.sort\
    \ #sorts to get longest to shortest\nend", "    string.length.times do |i|\n \
    \       prefix << string[0...i]\n    end\n    prefix\nend\n</code>\nThe result\
    \ will be in prefix variable\n<code>\nprefix = \"ABCEFG\"\n</code>\nIf this was\
    \ what you want, I suggest you to add more information on your question. Do you\
    \ want just to know how your method works? Or do you want it to return a value\
    \ with prefix?\n<|/ a dscore=0 |>\n<| a tags=string,ruby |>\n<code>", "  result\
    \ = []\n  result.push(*string.split(//)) while result[-1] == ''\n  result\nend",
  "    prefixes = []\n    i = 0\n    while i < string.length\n        prefixes <<\
    \ string[0..i-1] if i > 0\n        i = i + 1\n    end\n    prefixes\nend", " \
    \ all = []\n  lengths = string.split(//).map{|l| l.length}\n  lengths.sort.reverse_each\
    \ do |length|\n    prefix =  ''\n    string.split(//).each do |string|\n     \
    \ string += prefix\n      all.unshift(string)\n      prefix += '_'\n    end\n\
    \  end\n  all\nend", "  candidates = string.split('').reverse\n  prefixes = []\n\
    \  prefix = ''\n  while candidates.length > 0\n    candidate = candidates.pop\n\
    \    prefix += candidate\n    if candidates.include? candidate\n      prefixes\
    \ << prefix\n      prefix = ''\n    end\n  end\n  prefixes\nend", "  prefix_lengths\
    \ = sort_prefixes(string.split(\".\"))\n  prefix_lengths.reverse.inject([]) do\
    \ |prefixes, prefix|\n    prefix = prefix.to_s\n    prefixes << prefix unless\
    \ prefixes.any? { |x| x.start_with?(prefix) }\n    prefixes\n  end\nend", "  prefix\
    \ = []\n  for i in 0...string.length\n    prefix = prefix << string[i]\n  end\n\
    \  prefix\nend", "  prefix_array = []\n  string.each_char.with_index do |char,\
    \ i|\n    prefix_array << char if prefix_array.empty? || prefix_array[-1].nil?\n\
    \    prefix_array.last.nil? ? prefix_array << char : prefix_array.pop\n  end\n\
    \  return prefix_array\nend", "  return prefixes(string).sort_by(&:length).reverse\n\
    end", "    letters = string.split(//)\n    prefixes = Array.new\n    letters.each\
    \ do |letter|\n        prefixes << letters[0..letters.size - 1]\n    end\n   \
    \ prefixes\nend\n</code>\n<|/ a tags=ruby,algorithm,string |>\n<| a |>\nThis is\
    \ my solution for your case, I hope it helps you\n<code>", "  string.each_char.with_object([])\
    \ do |char, prefixes|\n    prefixes << char if prefixes.length >= string.length\n\
    \  end\nend\n</code>\nNow the prefixes method works, you can test it by running\
    \ the following in the Rails console:\n<code>\nprefixes = all_prefixes(\"aaabbbccc\"\
    )", "    prefix = \"\"\n    prefix_length = 0\n    \n    while string.length >\
    \ prefix_length\n        prefix = string[0..prefix_length]\n        prefix_length\
    \ += 1\n    end\n    \n    return [prefix, prefix_length]\nend", '  prefixes =
    []', "  prefixes = []\n  i = 1\n  while i < string.size\n    if string[0,i] ==\
    \ string[0,i-1]\n      prefixes << string[0,i]\n      i += 1\n    end\n    i +=\
    \ 1\n  end\n  prefixes\nend", "  # For this first loop, we're going to assume\
    \ that all of the input is valid\n  prefixes = []\n  # Loop through each character\
    \ in the input string\n  string.each_char {|c|\n    # If the character isn't a\
    \ letter, then the prefix is the empty string\n    next if !(c=~/[[:alpha:]]/)\n\
    \    # If this character is a letter, add it to the list of prefixes\n    prefixes\
    \ << c if !(c=~/[[:alnum:]]/)\n  }\n  # Return the list of prefixes\n  prefixes\n\
    end\nputs \"The longest prefix is: \" + longest_prefix('abcedefg')\nputs \"The\
    \ shortest prefix is: \" + shortest_prefix('abcedefg')\nputs \"The longest prefix\
    \ is: #{longest_prefix('abcd')}\"\nputs \"The shortest prefix is: #{shortest_prefix('abcd')}\"\
    \nputs \"The longest prefix is: #{longest_prefix('abc')}\"\nputs \"The shortest\
    \ prefix is: #{shortest_prefix('abc')}\"\nputs \"The longest prefix is: #{longest_prefix('abbc')}\"\
    \nputs \"The shortest prefix is: #{shortest_prefix('abbc')}\"\nputs \"The longest\
    \ prefix is: #{longest_prefix('abbbbb')}\"\nputs \"The shortest prefix is: #{shortest_prefix('abbbbb')}\"\
    \nputs \"The longest prefix is: #{longest_prefix('abbbbbb')}\"\nputs \"The shortest\
    \ prefix is: #{shortest_prefix('abbbbbb')}\"\nputs \"The longest prefix is: #{longest_prefix('abbbbbbb')}\"\
    \nputs \"The shortest prefix is: #{shortest_prefix('abbbbbbb')}\"\nputs \"The\
    \ longest prefix is: #{longest_prefix('abbbbbbbb')}\"\nputs \"The shortest prefix\
    \ is: #{shortest_prefix('abbbbbbbb')}\"\nputs \"The longest prefix is: #{longest_prefix('abbbbbbbb')}\"\
    \nputs \"The shortest prefix is: #{shortest_prefix('abbbbbbbb')}\"\nputs \"The\
    \ longest prefix is: #{longest_prefix('abbbbbbbbd')}\"\nputs \"The shortest prefix\
    \ is: #{shortest_prefix('abbbbbbbbd')}\"\nputs \"The longest prefix is: #{longest_prefix('abbbbbbbbb')}\"\
    \nputs \"The shortest prefix is: #{shortest_prefix('abbbbbbbbb')}\"\nputs \"The\
    \ longest prefix is: #{longest_prefix('abbbbbbbbbb')}\"\nputs \"The shortest prefix\
    \ is: #{shortest_prefix('ab", "  prefixes = []\n  prefix = nil\n  while string.length\
    \ > 0\n    prefix = prefix ? prefix + string.charAt(string.length - 1) : nil\n\
    \    prefixes << prefix if prefix != nil\n    string = string.slice(0..-1)\n \
    \ end\n  return prefixes\nend", "  prefix = \"\"\n  prefix = prefix + string.slice(0,\
    \ string.rindex(\" \"))\n  return prefix\nend", "  return string.split(\".\").map\
    \ { |s| s.split(\".\") }\nend", "    prefixes = []\n    string.split('').each\
    \ do |character|\n        prefixes.push(character)\n    end\n    prefixes\nend",
  "  prefixes = []\n  i = 0\n  while i < string.length\n    if string[i] != nil\n\
    \      prefixes << string[i]\n      i += 1\n    else\n      i += 1\n    end\n\
    \  end\n  prefixes\nend", "  prefix_array = []\n  prefixes_hash(string, prefix_array,\
    \ [])\n  return prefix_array\nend", "  prefix_list = []\n  prefix_list << string.downcase[0..0]\n\
    \  prefix_list << string.downcase[0..1]\n  prefix_list << string.downcase[0..2]\n\
    \  prefix_list << string.downcase[0..3]\n  prefix_list << string.downcase[0..4]\n\
    \  prefix_list << string.downcase[0..5]\n  prefix_list << string.downcase[0..6]\n\
    \  prefix_list << string.downcase[0..7]\n  prefix_list << string.downcase[0..8]\n\
    \  prefix_list << string.downcase[0..9]\n  prefix_list << string.downcase[0..10]\n\
    \  prefix_list << string.downcase[0..11]\n  prefix_list << string.downcase[0..12]\n\
    \  prefix_list << string.downcase[0..13]\n  prefix_list << string.downcase[0..14]\n\
    \  prefix_list << string.downcase[0..15]\n  prefix_list << string.downcase[0..16]\n\
    \  prefix_list << string.downcase[0..17]\n  prefix_list << string.downcase[0..18]\n\
    \  prefix_list << string.downcase[0..19]\n  prefix_list << string.downcase[0..20]\n\
    \  prefix_list << string.downcase[0..21]\n  prefix_list << string.downcase[0..22]\n\
    \  prefix_list << string.downcase[0..23]\n  prefix_list << string.downcase[0..24]\n\
    \  prefix_list << string.downcase[0..25]\n  prefix_list << string.downcase[0..26]\n\
    \  prefix_list << string.downcase[0..27]\n  prefix_list << string.downcase[0..28]\n\
    \  prefix_list << string.downcase[0..29]\n  prefix_list << string.downcase[0..30]\n\
    \  prefix_list << string.downcase[0..31]\n  prefix_list << string.downcase[0..32]\n\
    \  prefix_list << string.downcase[0..33]\n  prefix_list << string.downcase[0..34]\n\
    \  prefix_list << string.downcase[0..35]\n  prefix_list << string.downcase[0..36]\n\
    \  prefix_list << string.downcase[0..37]\n  prefix_list << string.downcase[0..38]\n\
    \  prefix_list << string.downcase[0..39]\n  prefix_list << string.downcase[0..40]\n\
    \  prefix_list << string.downcase[0..41]\n  prefix_list << string.downcase[0..44]\n\
    \  prefix_list << string.downcase", "  prefixes = []\n  string.split('').each\
    \ do |char|\n    prefix = char.to_s.reverse.take(3).join\n    prefixes << prefix\
    \ if prefixes.include? prefix\n  end\n  prefixes\nend", "    # Initialize prefixes\
    \ list\n    prefixes = Array.new\n    # Iterate over string characters and add\
    \ to prefixes list\n    string.each_char do |char|\n        prefixes << char\n\
    \    end\n    return prefixes\nend", "  prefixes = []\n  prefix = \"\"\n  string.split(\"\
    \").each do |char|\n    prefix = char + prefix\n    if prefix != string\n    \
    \  prefixes << prefix\n      prefix = \"\"\n    end\n  end\n  prefixes << string\n\
    \  return prefixes\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI haven't had any\
    \ occasion to use it yet, but I'm willing to bet it would be useful for other\
    \ string related problems as well, so +1.\n<|/ c |>\n<| c |>\nThis answer is much\
    \ faster than the accepted one. Nice work.\n<|/ c |>\n<| c |>\nThank you. I'll\
    \ be using this one instead of iterating over all characters and appending to\
    \ a string, which is what many other people have said to do.\n<|/ c |>\n<| a tags=string,ruby,arrays\
    \ |>\n<code>\nstring = \"somestring\"\nstring.split(\"\").reverse.map {|char|\
    \ char * n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis won't work if you want\
    \ n to be dynamic. As n varies from each string.\n<|/ c |>\n<| c |>\nWhat do you\
    \ mean? This works for a dynamic n. Or did you mean something else?\n<|/ c |>\n\
    <| a |>\nI know this is late but for people like me who came to this page looking\
    \ for an answer using Ruby, here's how I do it. I use the inject method which\
    \ takes a block and applies it to each item in the array with the current item\
    \ as its argument. In my example I am simply multiplying the last character by\
    \ the nth number.\n<code>", "  prefixes = []\n  string.each_char.with_index do\
    \ |c, i|\n    prefixes << (i == 0) ? c : prefixes[i - 1] + c\n  end\n  prefixes\n\
    end", "  # Return array of all prefixes\n  string.each_char.with_index.map { |e,\
    \ i| e[/^/] ? e[/^([^/]+)/, 1] : \"\" }\nend\n</code>\nI didn't see any need for\
    \ memoization in the original code, so I only optimized the hash lookup in the\
    \ all_prefixes method.\n<|/ a |>\n<| c |>\nThis is a fantastic solution, and works\
    \ beautifully. However, I ran some tests, and found that when I change the `string`\
    \ to `a = \"abc\"`, I get a very large time difference between the two implementations.\
    \ So I guess there are some cases where this is a bad implementation?\n<|/ c |>\n\
    <| c |>\n: I don't think so. I've tested it with several thousand random strings\
    \ (including one that starts with `a`) and found that `all_prefixes` was faster\
    \ than `prefix_of` in every single case. How many strings did you test?\n<|/ c\
    \ |>\n<| c |>\nI was testing with 5000 random strings. I guess I'll just have\
    \ to test with lots of larger strings.\n<|/ c |>\n<| c |>\n: 5000 random strings\
    \ is already quite a lot. :) If you're concerned, I suggest you use a profiler\
    \ to see where your code is spending most of the time.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is a Ruby one-liner using Enumerable#partition:\n<code>\narray = (0..1000).to_a\n\
    prefixes = []\narray.partition{|x| x.start_with?('a')}.each { |a| prefixes <<\
    \ a[0] }\n</code>\nHere we partition the array by whether each element starts\
    \ with the letter a. We then iterate through the partitions adding each element\
    \ to the prefix array.\n<|/ a tags=algorithm,ruby |>\n<| c |>\nAh, yes. I misread\
    \ the question and thought you wanted to find the first prefix that matched. I\
    \ think the OP is looking for all prefixes.\n<|/ c |>\n<| c |>\nAh, but this doesn't\
    \ work. Try changing the array to  `array = (0..1000).to_a.reverse` and it will\
    \ spit out `[\"a\"]` instead of `[\"a\"]`.\n<|/ c |>\n<| c |>\nInteresting. I've\
    \ corrected the problem and added a one-liner. Can you check it works for you?\n\
    <|/ c |>\n<| a dscore=0 |>\nThis question has been answered before. However, it\
    \ took me a while to find it (thankfully, ", "  prefix_length = -1\n  prefixes\
    \ = []\n  while prefix_length < 0\n    prefix_length = string.length\n    string\
    \ = string.split(//).last\n    prefixes << string\n  end\n  prefixes\nend", " \
    \   # Initialize an empty array for return\n    prefixes = []\n    # Iterate through\
    \ each character in the input string\n    string.each_char do |c|\n        # Append\
    \ each character to the prefixes\n        prefixes << c\n        # If there is\
    \ a longest prefix already in the prefixes array, append the c to the end instead\n\
    \        # of prepending to the beginning\n        prefixes.last << c if prefixes.size\
    \ < prefix.size\n    end\n    # Return the prefixes\n    return prefixes\nend\n\
    </cell>\n<code language=conda-env-tflearn-py>", "    # Initialize array of prefixes\
    \ to return\n    prefixes = Array.new\n    # Initialize current prefix to empty\
    \ string\n    prefix = \"\"\n    # Iterate over each character in the input string\n\
    \    string.chars.each do |char|\n        # If the character is a letter, append\
    \ it to the current prefix\n        if char >= \"a\" && char <= \"z\"\n      \
    \      prefix << char\n        # If the character is a digit, append it to the\
    \ current prefix\n        elsif char >= \"A\" && char <= \"Z\"\n            prefix\
    \ << char\n        # If the character is a non-letter, append it to the current\
    \ prefix\n        elsif char >= \"a\" && char <= \"z\"\n            prefix <<\
    \ char\n        elsif char >= \"A\" && char <= \"Z\"\n            prefix << char\n\
    \        end\n    end\n    # If the current prefix is empty\n    if prefix !=\
    \ \"\"\n        # Add it to the array of prefixes\n        prefixes << prefix\n\
    \    end\n    # Return array of prefixes\n    return prefixes\nend", "  prefixes\
    \ = []\n  prefix = \"\"\n  string.split(\"\").each do |c|\n    prefix << c\n \
    \   prefixes << prefix\n  end\n  prefixes\nend", "    prefixes = []\n    i = -1\n\
    \    while i != string.length\n        i += 1\n        prefix = string[i..-1]\n\
    \        if prefix != ''\n            prefixes << prefix\n        end\n    end\n\
    \    prefixes\nend", "  \n  return string.length.times.collect do |i|\n    string.chars.drop(i\
    \ + 1).join\n  end\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nVery nice. Could\
    \ you also explain why this would work? (I'm a beginner with Ruby so I'm not sure\
    \ how it works.)\n<|/ c |>\n<| c |>\nSure. `string.length` is the number of characters\
    \ in the string. `string.chars` is an array of all the characters of the string.\
    \ `string.chars.drop(index)` is an array containing all the characters except\
    \ the `index`'th character. So `string.chars.drop(1)` gives you an array containing\
    \ all the characters except the `1`'th character. `string.chars.drop(1)` then\
    \ repeats this for the entire string, so the first time it gives you an array\
    \ with the first character removed, then all the characters except the second,\
    \ third, etc.\n<|/ c |>\n<| c |>\nThis looks like a great answer but it doesn't\
    \ work for strings with duplicate letters. For example, `str1 = \"abcdefghi\"\
    `, `str2 = \"abdefijklm\"`. The first string should be split into `[\"abc\", \"\
    def\", \"ghi\"]` and the second should be split into `[\"abde\", \"f\", \"jklm\"\
    ]`\n<|/ c |>\n<| c |>\nYou were right the first time around, I fixed the answer.\
    \ Thanks for catching that.\n<|/ c |>\n<| a tags=string,ruby |>\nI came up with\
    \ this:\n<code>", "    prefixes = string.split('')\n    # Sort from longest to\
    \ shortest\n    prefixes.sort!{|a, b| a.length <=> b.length}\n    # Return array\
    \ containing all prefixes of the string\n    return prefixes\nend", "  prefix\
    \ = []\n  i = -1\n  while i < string.length\n    i = string.rindex(?)\n    prefix\
    \ << string[0..i]\n  end\n  prefix\nend", "    prefix = \"\"\n    prefixes = []\n\
    \    i = 0\n    while i < string.length\n        i += 1\n        if string[i,\
    \ 1] == \"-\"\n            if i < string.length\n                i += 1\n    \
    \            if string[i, 1] == \"-\"\n                    i += 1\n          \
    \          prefix = string[i, 1] + prefix\n                    prefixes << prefix\n\
    \                else \n                    prefix = string[i, 1]\n          \
    \          prefixes << prefix\n            else\n                prefix = string[i,\
    \ 1]\n                prefixes << prefix\n        else\n            prefix = string[i,\
    \ 1]\n            prefixes << prefix\n    end\n    return prefixes\nend", "  prefixes\
    \ = []\n  prefix = ''\n  for i in 0...string.length\n    prefix << string[i]\n\
    \    prefixes.push(prefix)\n  end\n  prefixes\nend", "  return string.downcase.split(//).map(&:downcase)\n\
    end\n</code>\n<code>\nall_prefixes(\"bBabBaba\")\n=> [\"b\", \"bb\", \"bab\",\
    \ \"bba\", \"bbaa\", \"bbbb\"]", "    \n    # Initialize array for return values\n\
    \    prefixes = []", "    prefixes = Array.new\n    string.scan(/[^\\S]*?[^\\\
    s\\S]/).each do |prefix|\n        prefixes << prefix\n    end\n    prefixes\n\
    end", "  prefixes = []\n  while string.length > 0\n    prefixes << string[0..-2]\n\
    \    string = string[-2..-1]\n  end\n  prefixes\nend", "    i = 1;\n    prefixes\
    \ = []\n    while i <= string.length\n        prefixes << string[i..-1]\n    \
    \    i += 2\n    end\n    prefixes\nend", "  prefixes = []\n  prefix = nil\n \
    \ string.scan(/(.{1,})[^a-zA-Z0-9_\\-]*/).each do |n|\n    prefix = n.last.gsub(/[^a-zA-Z0-9_\\\
    -]+/, '')\n    if prefix != nil and prefix != ''\n      prefixes << prefix\n \
    \   end\n  end\n  return prefixes\nend", "  prefix = []\n  string.each_char.with_index\
    \ do |char, index|\n    if index == 0\n      prefix.push char\n    else\n    \
    \  prefix.push char + prefix[index-1]\n    end\n  end\n  prefix\nend", "  result\
    \ = []\n  prefixes = string.split(//)\n  prefixes.each_with_index do |prefix,\
    \ i|\n    result[i] = prefix\n  end\n  result\nend", "  result = []\n  prefix\
    \ = \"\"\n  string.each_char do |i|\n    prefix = i.to_s + prefix\n    result\
    \ << prefix if i < string.size\n  end\n  result\nend", "  array = []\n  length\
    \ = string.size\n  for i in 0..(length - 1)\n    array[i] = string[i, length]\n\
    \  end\n  return array\nend", "\tall_prefixes = []\n\tprefix = \"\"\n\tlength\
    \ = string.length\n\t\n\twhile length > 0\n\t\tprefix = string[length - 1] + prefix\n\
    \t\tlength = length - 1\n\t\tall_prefixes << prefix\n\t\n\treturn all_prefixes\n\
    end", "  # Split string into list of single characters\n  chars = string.split('')\n\
    \  # Initialize list of prefixes\n  prefixes = []\n  # Loop through list of characters\
    \ and add all prefixes to list\n  while chars.any?\n    prefix = chars.join\n\
    \    prefixes << prefix\n    chars.shift\n  end\n  return prefixes\nend", "  prefix_list\
    \ = []\n  until string.empty?\n    prefix_list << string.chomp\n    string = string[1..-1]\n\
    \  end\n  prefix_list.reverse\nend", "  prefixes = []\n  length = string.length\n\
    \  for i = length...1\n    if string[0..i] == string.slice(-i)\n      prefixes\
    \ << string[0..i]\n    end\n  end\n  prefixes\nend", "  result = []\n  for i in\
    \ 0...string.size\n    if string.slice(i) != string.slice(i)\n      result <<\
    \ string.slice(i..-1)\n    end\n  end\n  result\nend", "  string.split.map { |prefix|\
    \ [prefix, string[0, prefix.length]] }.to_h\nend", "  prefixes = []\n  string.split(//).each\
    \ do |a|\n    prefixes << a if a.length == 0\n  end\n  prefixes\nend\n</cell>\n\
    <cell>", "  result = []\n  i = 0\n  while i < string.length\n    char = string[i]\n\
    \    char = char.downcase\n    i += 1 if char == \"-\" else 0\n    result[i] =\
    \ char\n  end\n  result.uniq\nend", "  if string.empty?\n    return []\n  else\n\
    \    return [string] if string.length == 1\n    prefixes = all_prefixes(string[0..-1])\n\
    \    prefixes << string[0..-1]\n    prefixes.flatten\n  end\nend", "    # Initialize\
    \ stack of prefixes\n    stack = []\n    # Iterate through all characters in input\
    \ string\n    string.each_char do |char|\n        # Check if character is first\
    \ character in stack\n        if stack.empty?\n            # Add character to\
    \ the stack\n            stack.push(char)\n        else\n            # Check if\
    \ character is first character in stack\n            if stack.pop == char\n  \
    \              # Add character to the stack\n                stack.push(char)\n\
    \            else\n                # Add stack to prefixes\n                prefixes.push(stack)\n\
    \                # Add character to the stack\n                stack.push(char)\n\
    \            end\n        end\n    end\n    # Add stack to prefixes\n    prefixes.push(stack)\n\
    end", "  prefixes = []\n  while string.length >= 0\n    prefix = string[0...-1]\n\
    \    prefixes << prefix\n    string = string[1..-1]\n  end\n  return prefixes\n\
    end", "  prefix = []\n  prefix_length = 0\n  string.split(//).each do |string|\n\
    \    prefix_length += 1\n    prefix.push(\"#{string[0,prefix_length]}...\")\n\
    \  end\n  prefix\nend", "    return string.split(//).map{|i| i[0...i.size-1] }.uniq.sort\n\
    end", "  result = []\n  pos = 0\n  while pos < string.length\n    result.push(string[pos])\n\
    \    pos = pos + 1\n  end\n  return result\nend", "  prefixes = []\n  string.length.times\
    \ { |i| prefixes << string.slice(i..-1) }\n  prefixes\nend", "  prefix_list =\
    \ Array[].new\n  string.split(\"\").each do |ch|\n    if prefix_list.include?([])\
    \ || prefix_list.include?(ch.downcase)\n      break\n    else\n      prefix_list\
    \ << ch.downcase\n    end\n  end\n  prefix_list\nend", "    prefix_list = []\n\
    \    prefixes = string.each_char.with_index.with_object([]) { |c,i| prefix_list\
    \ << i if c.match(/^\\w$/) }\n    prefixes += ([string.size].min)\n    prefix_list\n\
    end\n</code>\n<|/ a dscore=1 tags=ruby,algorithm,regex |>\n<| a dscore=0 |>\n\
    I wrote a solution for it which works well for me.\n<code>", "  prefix_list =\
    \ []\n  prefix_stack = nil\n  string.split('').each { |c|\n    if prefix_stack.nil?\n\
    \      prefix_stack.push(c)\n    elsif c == prefix_stack.pop\n      prefix_list\
    \ << c\n    end\n  }\n  prefix_list\nend", "  array.empty?(string) ? string :\
    \ all_prefixes(string.split(//)).flatten\nend\n</cell>\n<cell>\nall_prefixes('abcdefg')\n\
    </cell>\n<cell>\nall_prefixes('abbcdefg')\n</cell>\n<cell>\nall_prefixes('abbcadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbcadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>\n<cell>\nall_prefixes('abbccadefg')\n\
    </cell>\n<cell>\nall_prefixes('abbccadefg')\n</cell>", '  prefixes = []', "  prefixes\
    \ = []\n  prefixes << string unless string.empty?\n  prefixes << string unless\
    \ string.eql?(string.gsub(/^/, '')) # exclude if starts with /\n  prefixes.map\
    \ { |s| all_prefixes(s) }.flatten.uniq\nend", '    prefixes = Array.new', "  prefix\
    \ = []\n  i = 1\n  while i <= string.length\n    prefix.unshift(string[i..-1]\
    \ if i =! string.length then nil else string[i..i])\n    i += 1\n  end\n  prefix\n\
    end", "  result = []\n  loop do\n    result << yield(string)\n    break if string\
    \ == ''\n    string[0...-1]\n  end\n  result\nend", "  prefixes = []\n  prefixes\
    \ << string unless string.empty?\n  prefixes << (string.split('.').last.split('-').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 1 else\n               string.split('-').first.tr('A-Z',\
    \ 'a-z') if string.split('-').size > 1 else\n               string.split('.').last.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 1 else\n               string.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('/').size > 1 else\n               string.split('.').last.split('.').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 2 else\n               string.split('.').last.split('.').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 2 else\n               string.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('/').size > 2 else\n               string.split('.').last.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 3 else\n               string.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('/').size > 3 else\n               string.split('.').last.split('.').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 4 else\n               string.split('.').last.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 4 else\n               string.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('/').size > 4 else\n               string.split('.').last.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 5 else\n               string.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('/').size > 5 else\n               string.split('.').last.split('.').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 6 else\n               string.split('.').last.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 6 else\n               string.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('/').size > 6 else\n               string.split('.').last.split('.').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 7 else\n               string.split('.').last.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 7 else\n               string.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('/').size > 7 else\n               string.split('.').last.split('.').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 8 else\n               string.split('.').last.split('/').first.tr('A-Z',\
    \ 'a-z') if string.split('.').size > 8 ", "  # The array that will hold all of\
    \ the prefixes of the string\n  prefixes = Array.new", "  prefixes = []\n  loop\
    \ do\n    if string.length == 0\n      break\n    prefixes << string[0...-1]\n\
    \    string = string[-1]\n  end\n  prefixes\nend", "    prefix = []\n    for letter\
    \ in string.downcase\n        prefix << letter\n    end\n    prefix.uniq!\n  \
    \  prefix\nend", "    shortest = string + string\n    longest = string + string\n\
    \    shortest.each_char do |c|\n      if shortest.index(c) == 0 && c.upcase ==\
    \ c.downcase\n        shortest[shortest.index(c)..-1]\n      end\n    end\n  \
    \  longest.each_char do |c|\n      if longest.index(c) == 0 && c.upcase == c.downcase\n\
    \        longest[longest.index(c)..-1]\n      end\n    end\n    shortest.upcase\
    \ + longest.upcase\nend", "  string.length.times.collect{|i| string[0..i]}\nend",
  "  result = []\n  i = 0\n  while i < string.length\n    if string[0..i].empty? ||\
    \ string[i..-1].empty?\n      break\n    end\n    result[i] = string[0..i]\n \
    \   i += 1\n  end\n  result\nend", "  prefixes = string.scan(/^[^\\.]*[^\\.\\\
    .]*/)\n  prefixes.flatten!\n  prefixes\nend", "  prefix = \"\"\n  while string.length\
    \ > 0\n    prefix << string\n    string = string[1..-1]\n  end\n  prefix\nend",
  "  s = string.split(//)\n  \n  prefix_table = {}\n  prefix_table_sorted = []\n \
    \ prefix_table_sorted.push(s[0])\n  \n  i = 0\n  while i < s.length\n    prefix_table[s[i]]=i\n\
    \    i += 1\n  end\n  \n  until i == s.length\n    prefix = prefix_table[s[i]].to_s\n\
    \    prefix_table_sorted << prefix\n    i += 1\n  end\n  \n  prefix_table_sorted\n\
    end", "  string.split(//).map do |char|\n    char == char[0] ? \"#{char}\" : char\n\
    \  end.compact\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ruby,regex\
    \ |>\nI like Jon's solution as it is simple and straightforward.\nBut if you are\
    \ looking for something that can make your life a bit easier, I might suggest\
    \ to look into a Gem called Deep_Scanner.\nThis is a Ruby library which provides\
    \ an interesting feature called 'Regex Scanner' which provides very powerful parsing\
    \ tools.\nHere is how it would work with your input:\n<code>\nrequire 'deep_scanner'",
  "  prefixes = []\n  chars = string.chars\n  prefix = nil\n  len = string.size\n\
    \  i = 0\n  while i < len\n    char = chars[i]\n    if char == ?_\n      prefix\
    \ = char\n    elsif !prefix or char != prefix\n      prefixes = [prefix]\n   \
    \   prefix = char\n    else\n      prefixes << char\n    end\n    i += 1\n  end\n\
    \  return prefixes\nend", "  if string.nil?\n    []\n  else\n    chars = string.chars\n\
    \    (1..chars.size).flat_map { |i| chars[0..i].map { |c| c * i } }\n  end\nend",
  "  if string.length == 0\n    return nil\n  end\n  prefix = []\n  index = string.size-1\n\
    \  while (index >= 0) do\n    prefix.push string[index..-1]\n    index = index-1\n\
    \  end\n  return prefix\nend", "  prefix = []\n  i = 0\n  while i < string.length\n\
    \    if string[i] == a\n      prefix << string.slice(i..string.length)\n     \
    \ i = string.length\n    i += 1\n  end\n  prefix\nend", "    prefix_list = []\n\
    \    while string.size > 0\n        prefix_list << string[0,0]\n        string\
    \ = string[0,0]\n    end\n    prefix_list\nend", "  ret = []\n  string.downcase!\n\
    \  string.split.each do |word|\n    next if word.empty?\n    ret << word[/^[^aeiouy]+/]\n\
    \  end\n  ret\nend", '  prefixes = []', "  result = []\n  prefixes = []\n  prefix\
    \ = \"\"\n  while string.length > 0\n    index = string.index(\".\")\n    if index\
    \ == 0\n      prefix = string\n    else\n      prefix = string[0...index]\n  \
    \  end\n    if prefix != \"\"\n      prefixes << prefix\n      string = \"\"\n\
    \    end\n  end\n  prefixes.each { |prefix| result << prefix }\n  result\nend",
  "  prefixes = []\n  i = 0\n  while i < string.length\n    prefixes << string[i..-1]\n\
    \    i += 1\n  end\n  prefixes\nend", "  prefixes = []\n  string.each_char do\
    \ |char|\n    prefixes << char unless prefixes.any? { |prefix| prefix == char}\n\
    \  end\n  prefixes\nend", "  prefix_array = string.dup.chars.to_a\n  prefix_array.reduce([])\
    \ { |all, char| all << char.downcase if char =~ /\\A[a-z]/ }.\n              \
    \   sort.reduce([]) { |all, prefix| all << prefix.downcase }.uniq\nend", "  array\
    \ = string.chars.to_a\n  array.length.downto(1).map { |i| array[0..i] }\nend\n\
    </code>\n<|/ a dscore=2 tags=algorithm,string,ruby |>\n<| c |>\nThanks for your\
    \ solution!\n<|/ c |>\n<| a tags=algorithm,string,ruby dscore=1 |>\n<code>\ns\
    \ = 'abbc'"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
