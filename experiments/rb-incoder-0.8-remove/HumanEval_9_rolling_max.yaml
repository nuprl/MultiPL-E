name: HumanEval_9_rolling_max
language: rb
prompt: "# From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n# in the sequence.\ndef rolling_max(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n\
  \    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4,\
  \ 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100],\
  \ candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"
completions: ["  numbers.each do |element|\n    maximum = element\n    numbers.drop(1).each\
    \ do |element|\n      maximum = element if element > maximum\n    end\n    return\
    \ maximum\n  end\nend\n</code>\n<|/ a tags=ruby,max,arrays |>\n<| a tags=ruby,max,arrays\
    \ dscore=1 |>\nMy solution would be something like this: \n<code>\narr = [1, 2,\
    \ 3, 4, 5]\narr_max = arr.dup.max", "    numbers.each do |n|\n        rolling_max_elements\
    \ << n\n    end\nend", "  result = []\n  numbers.each_with_index do |number, index|\n\
    \    rolling_max_number = number\n    while index > 0\n      rolling_max_number\
    \ = rolling_max_number > number ? rolling_max_number : number\n      result.pop.push(rolling_max_number)\n\
    \      index -= 1\n    end\n    result.push(rolling_max_number)\n  end\n  result\n\
    end", "  numbers.each do |num|\n    rolling_max = num if rolling_max.nil? || num\
    \ > rolling_max\n  end\n  rolling_max\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ dscore=2 |>\n<| a dscore=2 tags=ruby,sorting,arrays |>\n<code>\na = [6, 5, 4,\
    \ 3, 2]\na.inject([]) do |m, e|\n  m << e unless m.last < e\n  m\nend.max", " \
    \ result = []\n  rolling = 0\n  max_numbers = numbers.max\n  numbers.each do |number|\n\
    \    rolling = rolling + number\n    if rolling == max_numbers\n      result <<\
    \ number\n      rolling = number\n    end\n  end\n  return result\nend", "  max_element\
    \ = nil\n  rolling_max = nil", "    # Implement your function here\n    rolling_max\
    \ = 0\n    rolling_max_idx = nil", "  # Initialize the result with -1\n  result\
    \ = -1\n  # For each element in the sequence, compare it to the previous element\
    \ in the sequence\n  # and update the result if needed\n  numbers.each { |number|\
    \ result = number if number > result }\n  result\nend\n</code>\nThe last method\
    \ can be generalized to an arbitrary number of arguments by using any of Ruby's\
    \ Array methods:\n<code>", "  numbers_copy = numbers.dup\n  rolling_max_result\
    \ = []\n  max_element = 0\n  numbers.each do |number|\n    max_element = number\
    \ if number > max_element\n  end\n  max_element.downto(0) do |number|\n    rolling_max_result\
    \ << number\n    numbers_copy.shift if number > max_element\n  end\n  rolling_max_result\n\
    end", '  rolling_max_array = Array.new', "  rolling_max_list = Array.new\n  rolling_max_list.push(*numbers)\n\
    \  last_value = numbers[0]", "    numbers.each_with_index.map { |n,i| i.zero?\
    \ ? n : numbers.window(i).max }.compact.last\nend", "    numbers.each do |number|\n\
    \      max_found = false\n      while max_found == false\n        max_found =\
    \ number > numbers.shift\n      end\n      puts \"#{number} => #{numbers.shift}\"\
    \n    end\nend", "  \n  # Initialization\n  max_element = numbers[0]\n  max_index\
    \ = 0\n  \n  # Looping\n  numbers.each do |num|\n    max_element = num if num\
    \ > max_element\n    max_index = numbers.index(num) if num > max_element\n  end\n\
    \  \n  return max_index, max_element\nend", "    rolling_maxes = []\n    rolling_max\
    \ = 0", "  return numbers.max if numbers.any? {|x| x > numbers.min}\n  nil\nend",
  "  numbers.inject([]) do |max, number|\n    max << number if number > max[-1]\n\
    \    max\n  end\nend", "  # Your code here\nend", "  numbers.each_with_index.reduce(:<)\n\
    end", "  numbers.each_with_index.inject([]) do |max, (i,_)|\n    max << (max.last\
    \ || i)\n    max.last\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI did\
    \ `rolling_max` like that: ", "  rolling_max_values = []\n  rolling_max_index\
    \ = nil\n  numbers.each do |number|\n    rolling_max_index += 1\n    rolling_max_values\
    \ << numbers[rolling_max_index] if rolling_max_index <= numbers.size - 1\n  end\n\
    \  rolling_max_values\nend", "    numbers.each_with_index.with_object([]) do |(n,\
    \ i), a|\n        a.unshift(n) if n == 0\n        a.unshift(a[i-1]) if i > 0\n\
    \        a.unshift(a[i-1]) if i > 0\n    end\nend", "  return numbers.each { |number|\
    \ number < numbers.last ? number : numbers.last }\nend", "  numbers[0] = 0 # Initialize\
    \ rolling max\n  result = 1\n  numbers.each do |n|\n    if n > result\n      result\
    \ = n\n    end\n  end\n  result\nend", "  rolling_max.last_rolling_max_element\
    \ = nil\n  rolling_max.last_rolling_max_numbers = nil\n  rolling_max.last_rolling_max_timestamp\
    \ = Time.now\n  numbers.each do |number|\n    current_rolling_max_number = rolling_max.last_rolling_max_number\n\
    \    if (current_rolling_max_number < number)\n      rolling_max.last_rolling_max_numbers\
    \ = number\n      rolling_max.last_rolling_max_timestamp = Time.now\n      rolling_max.last_rolling_max_number\
    \ = number\n    end\n  end\nend", "  rolling_max =[0]\n  max_element = 0\n  rolling_max[0]\
    \ = 0\n  rolling_max.max = 0\n  rolling_max.min = nil\n  rolling_max.index = 0\n\
    \  index = 0\n  numbers.each do |num|\n    rolling_max.index = index\n    if num\
    \ > rolling_max.max\n      rolling_max.max = num\n    elsif num < rolling_max.min\n\
    \      rolling_max.min = num\n    end\n    index += 1\n  end\n  rolling_max.min\n\
    end", "  numbers = numbers.sort.reverse # reverse the order of the array\n  \n\
    \  # find the first number smaller than the previous one\n  first_number = numbers.shift\n\
    \  \n  # the rolling max will be added to the previous one\n  rolling_max = first_number\n\
    \  \n  until numbers.empty?\n    rolling_max = numbers.max rolling_max\n  end\n\
    \  \n  # the rolling max is added to the previous one\n  rolling_max << first_number\n\
    \  \n  rolling_max\nend\n</code>\nThis could be an elegant solution to implement\
    \ the rolling_max method without using any loops or recursion\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThank you. I will add this to the question.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI've just been looking into this and came up with a different solution that\
    \ I believe to be more efficient.\n<code>\nmodule Enumerable\n  def rolling_max\n\
    \    reduce([nil]) do |max_so_far, elem|\n      max_so_far > elem ? max_so_far\
    \ : elem\n    end\n  end\nend", "  numbers.map { |n| [n,n].reject { |a| a.nil?\
    \ }.last.max }.compact.map { |m| m.max }\nend", "  return numbers.max.map { |num|\
    \ num * 2 }\nend\n</code>\nIn the second case, you're not using the same logic\
    \ as the first, you're only generating a single number. This should generate a\
    \ list of numbers between 0 and 6 (inclusive), which you can then do whatever\
    \ you want with.\n<code>\nrolling_max([1, 2, 3, 4, 5])\n=> [1, 2, 3, 4, 5, 6]\n\
    </code>\n<|/ a |>\n<| c |>\nI believe this is more what OP was looking for. However\
    \ I believe it should be `(1..n).map { |n| n * 2 }` instead of `(1...n).map {\
    \ |n| n * 2 }`\n<|/ c |>\n<| c |>\nThanks for the correction, that's what I get\
    \ for typing straight into the stack overflow editor.\n<|/ c |>\n<| c |>\nNo prob.\
    \ I think I've fixed the post. I guess you can also use `(1..n).map { |n| n *\
    \ 2 }` if that's what you prefer. I tend to type `(1...n).map { |n| n * 2 }` because\
    \ it's easier to read/type it in.\n<|/ c |>\n<| c |>\nThanks, I've updated the\
    \ post with your correction and also included a solution to the OP's second problem,\
    \ where they seem to be looking for all possible combinations.\n<|/ c |>\n<| c\
    \ |>\nThis is so much more complicated than it needs to be. Try `(1..n).map {\
    \ |n| n * 2 }`.\n<|/ c |>\n<| a |>\nI believe this can be done more elegantly\
    \ with Enumerable#each_slice:\n<code>\n(1..6).each_slice(2){|a,b| puts \"#{a}\
    \ #{b}\"}\n</code>\n<|/ a dscore=5 tags=ruby |>\n<| c |>\nThis is the best solution\
    \ for me. Thanks!\n<|/ c |>\n<| a dscore=4 tags=ruby |>\nThe other answers are\
    \ fine, but here is another one:\n<code>\n(1..6).to_a.reduce(:*)\n</code>\nOr\
    \ more generally:\n<code>\n(1..n).reduce(:*)\n</code>\n<|/ a |>\n<| c |>\nThis\
    \ should be the accepted answer. It uses Ruby's native reduce method.\n<|/ c |>\n\
    <| c |>\nThis is the only answer that shows how to do it with multiple parameters\
    \ while preserving the array elements as well.\n<|/ c |>\n<| c |>\nThis answer\
    \ is the only one that produces the correct output.\n<|/ c |>\n<| a tags=rub",
  "  max_element = numbers[0]\n  max_elements = []\n  numbers.each do |number|\n \
    \   if number > max_element\n      max_element = number\n    end\n    if number\
    \ == max_element\n      max_elements << max_element\n    end\n  end\n  return\
    \ max_elements\nend", "  max = 0\n  for i in numbers.first(2).last(2).to_a\n \
    \   if i > max\n      max = i\n    end\n  end\n  max\nend", "  # Initialize empty\
    \ list and append first element\n  list = [0]\n  list.each {|i| list << i}\n \
    \ # Initialize current max with first element\n  max = list[0]\n  # While the\
    \ element is not the final element\n  until list.last != list.size - 1\n    #\
    \ Update max\n    max = list[(list.size - 1) + list.length]\n    # Remove the\
    \ last element from the list\n    list.pop\n  end\n  return max\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  numbers.map do |i|\n    i.times.reduce(:max)\
    \ do |rolling_max, i|\n      rolling_max if i > rolling_max\n    end\n  end\n\
    end", "  numbers_copy = numbers.dup\n  rolling_max = nil\n  numbers.each do |number|\n\
    \    rolling_max = number if rolling_max.nil? || number > rolling_max\n    numbers_copy.pop\n\
    \  end\n  rolling_max\nend\n</code>\nAnd here is the unit tests:\n<code>\ndescribe\
    \ Rolling do\n  describe \"#max\" do\n    it \"generates the right list\" do\n\
    \      list = Rolling.new.max\n      expected = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\
    \      expected.should include(*list)\n    end\n    it \"generates the right list\
    \ when given an array\" do\n      list = Rolling.new.max([1, 2, 3, 4, 5])\n  \
    \    expected = [1, 2, 3, 4, 5]\n      expected.should include(*list)\n    end\n\
    \    it \"returns nil when given an empty array\" do\n      list = Rolling.new.max([])\n\
    \      expected.should == nil\n    end\n    it \"returns nil when given nil\"\
    \ do\n      list = Rolling.new.max(nil)\n      expected.should == nil\n    end\n\
    \    it \"returns nil when given an empty string\" do\n      list = Rolling.new.max('')\n\
    \      expected.should == nil\n    end\n    it \"returns nil when given 0\" do\n\
    \      list = Rolling.new.max(0)\n      expected.should == nil\n    end\n  end\n\
    \  describe \"#rolling_max\" do\n    it \"generates the right list\" do\n    \
    \  list = Rolling.new.rolling_max\n      expected = [1, 2, 3, 4, 5, 6, 7, 8, 9,\
    \ 10]\n      expected.should include(*list)\n    end\n    it \"generates the right\
    \ list when given an array\" do\n      list = Rolling.new.rolling_max([1, 2, 3,\
    \ 4, 5])\n      expected = [1, 2, 3, 4, 5]\n      expected.should include(*list)\n\
    \    end\n    it \"returns nil when given an empty array\" do\n      list = Rolling.new.rolling_max([])\n\
    \      expected.should == nil\n    end\n    it \"returns nil when given nil\"\
    \ do\n      list = Rolling.new.rolling_max(nil)\n      expected.should == nil\n\
    \    end\n    it \"returns nil when given an empty string\" do\n      list = Rolling.new.rolling_max('')\n\
    \      expected.should == nil\n    end\n    it \"returns nil when given 0\" do\n\
    \      list = Rolling.new.rolling_max(0)\n      expected.should == nil\n    end\n\
    \  end\nend\n</code>\nAnd here is the unit test for the generator class\n<code>\n\
    require 'minitest/autorun'", "  rolling_max = []\n  rolling_max = numbers.reduce(:[])\
    \ do |memo, number|\n    if number > memo[-1]\n      memo << number\n    end\n\
    \    memo\n  end\nend\n</code>\n<|/ a tags=arrays,ruby |>\n<| a dscore=0 |>\n\
    The accepted answer is fine, and should be considered the correct way to solve\
    \ your problem.\nI however would like to present a more idiomatic way of doing\
    \ this:\n<code>", "    numbers.each do |n|\n        rolling_max_nums = []\n  \
    \      n.times.each do \n            rolling_max_nums.push(numbers.shift)\n  \
    \      end\n        rolling_max = rolling_max_nums.max\n    end\n    rolling_max\n\
    end\n</code>\nThen, we can apply a solution to your problem:\n<code>", "  rollingMax\
    \ = []\n  numbers.each { rollingMax.push(Math.max(rollingMax.last, it)) }\n  rollingMax\n\
    end", "\tnumbers.each do |n|\n\t\trolling = false\n\t\trolling_max = [n]\n\t\t\
    numbers.each do |n|\n\t\t\trolling ? rolling_max[-1] = rolling_max[-1] if n >\
    \ rolling_max[-1] : rolling_max << n\n\t\tend\n\t\trolling_max\n\tend\nend", " \
    \ numbers.inject([numbers.last]){|a,v| a.last > v? [a.last,v] : [v,v]}\nend\n\
    </code>\nIt can be used as follows:\n<code>\nrolling_max([1,3,5,7,9,2,4,6])\n\
    </code>\nIt will return:\n<code>\n[\n  [1,3],\n  [3,5],\n  [5,7],\n  [7,9],\n\
    \  [9,2],\n  [2,4],\n  [4,6]\n]\n</code>\nIt can be easily extended into rolling_min\
    \ function and it's quite easy to understand.\n<|/ a dscore=2 |>\n<| a |>\nThe\
    \ easiest way is probably to generate an array of all the possible rolling sums.\
    \ \nThe algorithm is pretty straight forward, just iterate through each possible\
    \ rolling sum:", "  numbers.each do |number|\n    rolling_max_with_conditional_max(number,\
    \ false)\n  end\nend", "    max = numbers.max\n    rolling_max = Array.new\n \
    \   rolling_max = rolling_max.max_by { |element| element }\n    rolling_max.each_with_index\
    \ do |element, i|\n        if ((i+1) < numbers.size) && (number > 0)\n       \
    \     rolling_max[i] = (rolling_max[i] > numbers[i+1]) ? element : rolling_max[i]\n\
    \        end\n    end\n    rolling_max\nend", "  numbers.each_with_index.inject([])\
    \ do |result, (number, i)|\n    result << number if i > 0 && number >= numbers[i\
    \ - 1]\n    result\n  end\nend", "  rolling = []\n  numbers.each_with_index do\
    \ |i, ind|\n    if ind > 0 && rolling.empty? \n      rolling.push(i)\n    else\n\
    \      if rolling.empty? \n        rolling.push(i)\n      else\n        rolling.push(rolling.max)\n\
    \      end\n    end\n  end\n  rolling\nend", "  # We will use a variable to store\
    \ the result of the rolling operations.\n  results = []", "    rolling_max_index\
    \ = nil\n    rolling_max = nil\n    rolling_max_index = numbers.length-1\n   \
    \ rolling_max = 0\n    until rolling_max_index == 0\n        if rolling_max_index\
    \ > 0\n            rolling_max = numbers[rolling_max_index-1]\n        else\n\
    \            rolling_max = numbers[0]\n        end\n        if numbers[rolling_max_index]>=rolling_max\n\
    \            rolling_max_index -= 1\n        else\n            rolling_max_index\
    \ += 1\n        end\n    end\n    rolling_max\nend", "  numbers.each do |number|\n\
    \    prev = nil\n    rolling_max_value = number\n    numbers.each do |next_number|\n\
    \      if prev_number > rolling_max_value\n        rolling_max_value = prev_number\n\
    \        prev = next_number\n      end\n      prev_number = next_number\n    end\n\
    \    rolling_max_value = prev if prev\n    rolling_max_value\n  end\nend\n</code>\n\
    For your last question, try this:\n<code>", "  return [] if numbers.empty? \n\
    \  (min, max) = (numbers.min, numbers.max)\n  rolling_max = nil\n  numbers.each\
    \ do |number|\n    rolling_max = number if number > max and number <= rolling_max\n\
    \    rolling_max = number if number < max and number >= rolling_max\n  end\n \
    \ return [rolling_max, max] if rolling_max\nend", "\troll_max = numbers.max\n\t\
    roll_max_indexes = []\n\t\n\tfor i in 1...numbers\n\t\troll_max = numbers[i -\
    \ 1].max\n\t\troll_max_indexes.append(i - 1)\n\t\n\troll_max_indexes.reverse\n\
    \treturn roll_max, roll_max_indexes\nend", "  if numbers.nil?\n    return nil\n\
    \  else\n    numbers.each do |number|\n      if number > rolling_max_element\n\
    \        rolling_max_element = number\n      end\n    end\n  end\nend", '    numbers_rolled
    = numbers.clone', "  rolling_max = []\n  # Loop through the given numbers and\
    \ add them to the list of rolling max\n  numbers.each do |n|\n    rolling_max\
    \ << n if rolling_max.last < n && rolling_max.last != 0\n    rolling_max[0] =\
    \ 0 if rolling_max[0] == n\n  end\n  # Return the rolling max list\n  rolling_max\n\
    end\n</cell>\n<text>\nNow we can apply this function to our data using map!:",
  "  numbers.each_with_index.map { |n, i| n > numbers[i - 1] ? n : numbers[i - 1]\
    \ }\nend\n</code>\nOutput:\n<code>\nrolling_max([6, 2, 3, 1, 5, 7, 4])", "  max_element\
    \ = nil\n  numbers.each_with_index do |n, i|\n    if i == 0\n      max_element\
    \ = n\n    else\n      if n > max_element\n        max_element = n\n      end\n\
    \    end\n  end\n  max_element\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays\
    \ dscore=2 |>\nHere is a solution that uses a Hash to track all values seen. \n\
    <code>", "  rolling_max_numbers = []\n  numbers.each { |number| rolling_max_numbers\
    \ << number if number >= rolling_max_numbers.last.last + 1 }\n  rolling_max_numbers.last\n\
    end", "  numbers.each_index {|i| yield((numbers.min - 1).send(i) + numbers[i],\
    \ i) if i >= numbers.min}\n  numbers.last\nend", "\trolling = []\n\tnumbers.each\
    \ do |n|\n\t\twhile numbers.index { |n| n > n }\n\t\t\trolling << n\n\t\t\tnumbers.shift\n\
    \t\tend\n\tend\n\trolling\nend", "  rolling_max_list = []\n  # For each element\
    \ in the list, check the rolling maximum until the current moment in the\n  #\
    \ sequence.\n  numbers.each do |number|\n    rolling_max_list << number if number\
    \ > rolling_max_list.last\n  end\n  return rolling_max_list\nend\n</code>\n<|/\
    \ a dscore=0 tags=ruby |>\n<| a tags=ruby dscore=0 |>\nHere's another solution:\n\
    <code>", "  rolling_max_element = numbers.max\n  rolling_max_position = 0\n  rolling_max_index\
    \ = 0\n  numbers.each do |number|\n    if number > rolling_max_element\n     \
    \ rolling_max_element = number\n      rolling_max_position = rolling_max_index\n\
    \    end\n    rolling_max_index += 1\n  end\n  [rolling_max_element, rolling_max_position]\n\
    end", "  result = numbers.max\n  index = 1\n  while index < numbers.size\n   \
    \ max = numbers.max\n    numbers.delete(max)\n    numbers.push(max)\n    index\
    \ += 1\n    result\n  end\nend", "  numbers.each_cons(2) do |x|\n    x[-1] = x[-2]\
    \ + x[-1] if x[-2]\n  end\nend", "  rollings = numbers.map { |number| number.max\
    \ }\n  rollings.max_by(&:to_f) # Return maximum element found until given moment\n\
    end", "  rolling_max.min = numbers[0]\n  rolling_max.max = numbers[0]\n  rolling_max.max.downto(0)\
    \ do |x|\n    if numbers[x] > rolling_max.max\n      rolling_max.max = numbers[x]\n\
    \    end\n    if numbers[x] < rolling_max.min\n      rolling_max.min = numbers[x]\n\
    \    end\n  end\n  rolling_max.min\nend", "  rolling_max_nums = Array.new\n  rolling_max_nums\
    \ << numbers.max\n  numbers.length.times do |i|\n    numbers.max == numbers[i]\
    \ ? rolling_max_nums.shift : rolling_max_nums.push(numbers.max)\n  end\n  rolling_max_nums\n\
    end", "  rolling_max = Array.new\n  numbers.each do |number|\n    rolling_max.push(number)\
    \ if number > rolling_max[-1]\n  end\n  rolling_max\nend", "  rolling_max = []\n\
    \  rolling_max.push(numbers[0])\n  numbers.each do |number|\n    rolling_max.push(number)\
    \ if number > rolling_max.last\n  end\n  rolling_max\nend", "  rolling = []\n\
    \  rolling.push(numbers.shift())\n  numbers.each do |number|\n    if number >\
    \ rolling.last\n      rolling.push(number)\n    end\n  end\n  rolling\nend", " \
    \ numbers.max # => 4\n  numbers.max_by(&:itself).self # => [4]\n  numbers.max_by(3).self\
    \ # => [4, 2, 2]\n  numbers.max_by(2) { |i| i * i } # => [16, 4]\n  numbers.max_by(2)\
    \ { |i| i * i }.reverse.self # => [4, 2]\nend", "  numbers.each_index {|i|\n \
    \   numbers[i] = numbers[i].max(numbers[i+1])\n  }\n  numbers.max\nend", "  return\
    \ rolling_max(numbers, 0, numbers.length - 1)\nend", "    numbers.each do |element|\n\
    \        rolling_max_element = element\n        numbers.each do |next_element|\n\
    \            if element > next_element\n                rolling_max_element =\
    \ next_element\n            end\n        end\n        puts rolling_max_element\n\
    \    end\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,max,min,list\
    \ |>\nFor Ruby 2.6+ (which uses iterators and lazy Enumerables):\n<code>\na =\
    \ [5, 2, 7, 3, 6, 2, 8, 1]", "  rolling_max_count = 0\n  rolling_max_number =\
    \ nil\n  rolling_max_element = nil\n  numbers.each do |number|\n    rolling_max_count\
    \ += 1\n    if rolling_max_count == number\n      rolling_max_number = number\n\
    \      rolling_max_element = number\n    elsif rolling_max_count > number\n  \
    \    rolling_max_count = number\n      rolling_max_number = number\n      rolling_max_element\
    \ = number\n    end\n  end\n  return [rolling_max_number, rolling_max_element]\n\
    end", "  if numbers.empty?\n    return []\n  max_element = numbers.max_by{|i|\
    \ i}\n  max_index = 0\n  while max_index < numbers.size - 1\n    max_element =\
    \ numbers[max_index]\n    index = numbers.index{|i| i > max_element}\n    if index\
    \ > max_index\n      max_element = numbers[index]\n      max_index = index\n \
    \   end\n  end\n  [max_element, max_index]\nend", "  max_number = numbers[0]\n\
    \  max_roll_number = 0", "  rolling_max = numbers[0]\n  rolling_min = numbers[0]\n\
    \  rolling_max = numbers.shift\n  numbers.each do |num|\n    if num > rolling_max\n\
    \      rolling_max = num\n    end\n    if num < rolling_min\n      rolling_min\
    \ = num\n    end\n  end\n  [rolling_min, rolling_max]\nend\n</code>\nNow let's\
    \ try with input [1,2,5,4,6]:\n<code>\n>> rolling_max([1,2,5,4,6])\n=> [5,6]\n\
    >> rolling_max([1,2,5,4,5])\n=> [5,5]\n>> rolling_max([1,2,5,4,4])\n=> [5,5]\n\
    </code>\n<|/ a dscore=2 tags=ruby |>\n<| a dscore=1 |>\nI tried to do the same\
    \ but in python and here is the code that I got working.\n<code>", "  # Start\
    \ your solution here\n  return nil\nend", "  numbers.each_with_index.map { |number,\
    \ index| number == rolling_max(numbers.drop(index)) ? number : number > rolling_max(numbers)\
    \ ? number : rolling_max(numbers) }.compact\nend", "  numbers = numbers.sort\n\
    \  while numbers.first\n    yield numbers.shift\n  end\nend", "  numbers.reduce(:+)\n\
    end", "  numbers.reduce(:>)\nend", "    rolling_max_list = []\n    numbers.each\
    \ do |num|\n        rolling_max_list << num if num.modulo(2) != 0 && num != 0\n\
    \    end\n    return rolling_max_list\nend\n</code>\n<|/ a tags=algorithm,ruby\
    \ |>\n<| c |>\nAs the OP mentions this is Ruby, why would you use `to_i` for an\
    \ integer comparison?\n<|/ c |>\n<| c |>\nThanks for the tip. I have updated the\
    \ code to make it more clear.\n<|/ c |>\n<| c |>\nThanks for your answer! But\
    \ what if I want the first rolling maximum of a sequence? My understanding is\
    \ that the algorithm you provide here would return the largest element of the\
    \ sequence. I'd like to have the first rolling maximum of a sequence. Can you\
    \ help me with that?\n<|/ c |>\n<| c |>\nI have updated the code again, please\
    \ check it. I am assuming that you are looking for rolling max from a sequence.\n\
    <|/ c |>\n<| a tags=algorithm,ruby dscore=1 |>\nA slight modification of Sachin\
    \ Kumar's solution (Ruby 2.4.0) using Array#min and Array#max_by (Array#max_by\
    \ is a recent addition to Array):\n<code>", "  if numbers.empty?\n    []\n  else\n\
    \    numbers.first + rolling_max(numbers.drop(1))\n  end\nend", "  rolling_max_element\
    \ = numbers.max\n  rolling_max_elements = []\n  \n  # Go through each element\
    \ of the array and find rolling max of those elements.\n  numbers.each do |number|\n\
    \    rolling_max_element += number\n    rolling_max_elements << rolling_max_element\n\
    \  end\n  \n  # Return the rolling maximum element and rolling max elements found.\n\
    \  return rolling_max_element, rolling_max_elements\nend", "  # Your code here\n\
    \  maxes = []\n  last_number = 0\n  numbers.each do |n|\n    if last_number ==\
    \ 0\n      maxes.append(n)\n      last_number = n\n    elsif last_number > n\n\
    \      last_number = n\n    end\n  end\n  maxes\nend", "  numbers.each_with_index.reduce(0)\
    \ { |max, (n, index)| n > max ? n : max }\nend", "  numbers.each_with_index.map\
    \ do |number, i|\n    [number, numbers[i]] if number > numbers[i]\n  end.compact.first\n\
    end", "    rolling_max = numbers.reduce(:<<)\n    numbers.each { |n| rolling_max\
    \ = rolling_max.max_by(&:itself).last.first if rolling_max.last.last >= n }\n\
    end", "  rolling_max = numbers.max\n  numbers.each do |n|\n    rolling_max = n\
    \ if n > rolling_max\n  end\n  rolling_max\nend", "  rollingMax = numbers[0..numbers.size\
    \ - 1].max_by\n  numbers[0..numbers.size - 1].each { |n| rollingMax[n] }\n  rollingMax\n\
    end", "  numbers_max = numbers.max\n  numbers.max.downto(1) do |n|\n    if n.last\
    \ > numbers_max\n      numbers_max = n.last\n    end\n  end\n  numbers_max\nend",
  "  # First compute the maximum of the given list\n  maximum = numbers.max\n  # Then\
    \ find the moment of maximum value in the list\n  index_of_max = numbers.index(maximum)\n\
    \  # Generate a list of values from the moment of maximum value to the end\n \
    \ rolling_max = numbers[index_of_max..-1]\nend\n</code>\n<|/ a dscore=2 tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays dscore=1 |>\nAs others have noted, the best solution\
    \ for this problem is Enumerable#slice_after:\n<code>\n[1,2,3,4,5].slice_after\
    \ { |x| x < 3 }.each { |x| puts x }", "  result = []\n  numbers.each do |number|\n\
    \    result << number if number > result.last\n  end\n  result\nend", "    # Write\
    \ your code here.\n    numbers = numbers.sort\n    result = numbers.inject{ |max,\
    \ n| n > max ? n : max}\n    result.last == numbers.last ? result.pop : result\n\
    end", "  # Roll up our own implementation of a rolling maximum function\n  result\
    \ = []\n  numbers.each do |n|\n    result << n if n > result.last\n  end\n  result\n\
    end", "\tmaximum = numbers.shift\n\tnumbers.each do |num|\n\t\tmaximum = [num]\
    \ + numbers[1...-1].max if num > maximum\n\tend\n\tmaximum\nend", '  rolling_max
    = [numbers[0]]', "  rolling_max =\n    numbers.map { |n| numbers.max_by(&:abs).last\
    \ if n.is_a? Integer }\n  rolling_max.any? ? rolling_max.max.to_s : nil\nend",
  "  numbers.map { |n| n.to_i }.sort[-1,1].map { |n| n.to_s }\nend", "    numbers.each\
    \ do |number|\n        max_element = number\n        max_elements = []\n     \
    \   numbers.each do |number|\n            next unless number > max_element\n \
    \           max_element = number\n            max_elements << number\n       \
    \ end\n        max_elements\n    end\nend", "  if numbers.empty?\n    nil\n  else\n\
    \    (numbers + numbers.max).max\n  end\nend", "  rolling_maxs = []\n  rolling_max\
    \ = 0\n  numbers.each do |number|\n    rolling_max = number if rolling_max < number\n\
    \    rolling_maxs << rolling_max if rolling_max > 0\n  end\n  rolling_maxs\nend\n\
    </code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nWon't that give the wrong answer\
    \ if `numbers` is empty?\n<|/ c |>\n<| c |>\nIt would return an empty array when\
    \ called on an empty array.\n<|/ c |>\n<| c |>\nActually, I tested it and it doesn't\
    \ work. It returns an array containing `[0,0,0]`. You probably meant to write\
    \ `if number <= rolling_max`.\n<|/ c |>\n<| c |>\nThanks for pointing out the\
    \ mistake. I have fixed the answer now\n<|/ c |>\n<| c |>\nThat doesn't work if\
    \ numbers is nil.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", "    # Find\
    \ the maximum\n    max_value = numbers[0]\n    # Find which number was the maximum\n\
    \    max_number = 1\n    # Find the moment of max\n    for number in numbers\n\
    \        until number == max_number\n            max_number += 1\n        # Stop\
    \ if we reach the maximum moment\n        if max_number > number\n           \
    \ break\n        # Update max value\n        max_value = number\n    # Return\
    \ the result\n    max_number\nend", "  numbers.each_with_index.map do |number,\
    \ i|\n    number > numbers[i-1] ? number : numbers[i-1]\n  end\nend", "  numbers.shift\
    \ if numbers.empty?\n  max = numbers.first\n  numbers.each do |number|\n    max\
    \ = number if number > max\n  end\n  max\nend", "  numbers.each do |number|\n\
    \    puts \"Max found after #{number}.\"\n  end\nend", "  rolling = []\n  max\
    \ = numbers[0]\n  numbers.each do |n|\n    if n > max\n      rolling << max\n\
    \      max = n\n    elsif n == max\n      rolling << n\n    elsif n < max\n  \
    \    rolling << n\n    end\n  end\n  rolling << max\n  rolling\nend", "  max_value\
    \ = numbers.max\n  roll_max = []\n  roll_max.push(max_value)\n  roll_max.push(max_value)\n\
    \  max_index =  numbers.size - 1\n  while max_index ~= 0\n    value = numbers[max_index]\n\
    \    if value > roll_max[max_index-1]\n      roll_max[max_index-1] = value\n \
    \     max_index -= 1\n    else\n      max_index -= 1\n      roll_max.push(numbers[max_index])\n\
    \    end\n  end\n  roll_max\nend", "  # Write your code here.\n  new_list = []\n\
    \  \n  numbers.each_with_index do |n, idx|\n    if idx == 0\n      new_list <<\
    \ n\n      return\n    end\n    \n    if new_list.last.to_i > n\n      new_list\
    \ << n\n    end\n  end\n  new_list\nend", "  rolling_maxes = []\n  rolling_maxes.push(numbers[0])\n\
    \  index = 1\n  while rolling_maxes.length < numbers.size do\n    rolling_maxes.push(numbers[index])\n\
    \    if numbers[index] > rolling_maxes[-1] then\n      rolling_maxes = []\n  \
    \  end\n    index += 1\n  end\n  rolling_maxes\nend\n</code>\nThe same idea can\
    \ be applied to rolling_min and rolling_average:\n<code>", "  numbers.flatten.with_index.reduce(:max).to_a\n\
    end", "    numbers.each do |num|\n        numbers_rolling = []\n        number_rolling\
    \ = num\n        # Find the maximum of a given list of numbers\n        while\
    \ numbers_rolling.include? number_rolling\n            numbers_rolling.shift\n\
    \            numbers_rolling.push(number_rolling)\n            number_rolling\
    \ = numbers_rolling.last\n        end\n        # Return the rolling maximum list\n\
    \        return numbers_rolling\n    end\nend\nrolling_max([2,3,4,5])\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI like the rolling max approach as it is the most\
    \ efficient way to do this but what about my original solution? Does it not work?\
    \ Also, why is it slower then my solution and do you know why?\n<|/ c |>\n<| c\
    \ |>\nIt works if you understand it. If you don't, you will run into issues understanding\
    \ it. Also, the reason why it is slower is because your method goes over each\
    \ element in the list multiple times. If you look at the output for the example\
    \ you gave, your method has output `[3, 5]` while my method has output `[3,5,5,5,5]`\
    \ because you are iterating over each element in the list multiple times.\n<|/\
    \ c |>\n<| c |>\nOk, I see what you mean about the duplicates, that makes sense.\
    \ But I do not see why my method outputs [3,5,5,5,5] as the output for [2,3,4,5].\
    \ I would say it outputs [3,5,5] because my code takes the first element then\
    \ shifts the array one position left, then adds back the new value to the end\
    \ of the array.\n<|/ c |>\n<| c |>\nThat's why I said `if you understand it`.\
    \ I don't know exactly how your program is programmed and my explanation may be\
    \ incorrect. But it's pretty obvious how `rolling_max` works.\n<|/ c |>\n<| c\
    \ |>\nI think my understanding is correct. I just don't understand why my code\
    \ doesn't work. I will look into it some more. Thanks for your help!\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>\na = [1,2,3,4,5,6]", "    # return nil if given array\
    \ is empty\n    return nil if numbers.empty?\n    \n    max_length = numbers[0]\n\
    \    \n    numbers.each do |i|\n        # Check if there is any new max\n    \
    \    if i > max_length \n            max_length = i\n        end\n    end\n  \
    \  \n    # Return max number\n    return max_length\nend\n</code>\n<|/ a |>\n\
    <| c |>\nI haven't thought about it at all, but it seems very nice. :)\n<|/ c\
    \ |>\n<| a dscore=1 |>\nThis is an O(n) solution. \n<code>", "    numbers.each\
    \ do |value|\n        rolled = value.to_i + 1\n        numbers.map {|x| x if (x\
    \ > value) && (x > (value - rolled)) }\n    end\nend", "    rolling_max = numbers.shift\n\
    \    numbers.each do |i|\n        if i.to_i > rolling_max\n            rolling_max\
    \ = i.to_i\n        end\n    end\n    rolling_max\nend", "  max_elements = []\n\
    \  rolling_max_number = []\n  numbers.each do |n|\n    rolling_max_number << n\n\
    \    if n > 0\n      rolling_max_number = [rolling_max_number[-n].max]\n     \
    \ max_elements.push(rolling_max_number)\n    end\n  end\n  max_elements\nend\n\
    </code>\n<|/ a tags=arrays,ruby |>\n<| c |>\nThis fails for \"[1,2,3,5,8,13]\"\
    , where it should return [5,8,13].\n<|/ c |>\n<| c |>\nHi, indeed, sorry I made\
    \ a mistake, I have updated my answer, this works now.\n<|/ c |>\n<| c |>\nIt\
    \ works if you change the first line to `min_number = numbers[0]`, otherwise it\
    \ returns an empty array.\n<|/ c |>\n<| c |>\nYes, I noticed that as well, but\
    \ I was not sure if that was wanted behavior, so I just added `min_number` to\
    \ the return value too, I have edited my answer to include this.\n<|/ c |>\n<|\
    \ a tags=arrays,ruby dscore=2 |>\nI liked your answer, but as I needed a solution\
    \ not too slow, I wrote this one which should also have lower time complexity.\
    \ I don't know if it was what you were looking for but let me know if this isn't\
    \ what you were looking for.\n<code>", "  numbers.each do |number|\n    current_max\
    \ = number\n    numbers.each do |number|\n      current_max = number if number\
    \ > current_max\n    end\n    yield current_max\n  end\nend", "  return numbers.reduce(:max)\n\
    end\n</cell>\n<cell>", "  \n  # Initialize\n  current_max = numbers.shift", " \
    \ rolling_max = numbers.reduce(:+)\n  rolling_max >= numbers[0] ? rolling_max\
    \ : nil\nend\n</code>\n<|/ a |>\n<| a |>\nHere's an alternate solution, using\
    \ a Ruby block to do the comparison:\n<code>\n>> numbers = [1, 2, 3, 4, 5]\n=>\
    \ [1, 2, 3, 4, 5]\n>> numbers.minmax_by(&:abs)\n=> [1, 5]\n>> numbers = [1, 2,\
    \ 3, 4, 5]\n=> [1, 2, 3, 4, 5]\n>> numbers.minmax_by(&:abs)\n=> [1, 5]\n>> numbers\
    \ = [1, -2, -3, 4, 5]\n=> [1, -2, -3, 4, 5]\n>> numbers.minmax_by(&:abs)\n=> [1,\
    \ 5]\n</code>\n<|/ a dscore=0 tags=algorithm,ruby,ruby-on-rails |>\n<| c |>\n\
    Nice, but your solution assumes the numbers are always non-negative.\n<|/ c |>\n\
    <| c |>\nIn that case you can just use the [Enumerable#min](http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-min)\
    \ method instead of minmax_by.\n<|/ c |>\n<| a dscore=0 |>\nI needed to do this\
    \ and I wanted to avoid the use of the Enumerable#inject method, because I wanted\
    \ to return the last element in the sequence that had a greater value.\n<code>",
  "  numbers.each do |number|\n    if number > numbers.last\n      numbers.last\n\
    \    else\n      numbers.last\n    end\n  end\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby,max,algorithm,arrays |>\n<code>\narr = [-3,7,-3,7,4,-3,7,4,-3,7,4,-3,7,4,-3,7,-3,7]",
  "    rolling_max_numbers = []\n    numbers.each do |n|\n        rolling_max_numbers\
    \ << rolling_max(n) if rolling_max(n) > n\n    end\n    rolling_max_numbers\n\
    end", "  max_element = nil\n  rolling_max = nil\n  rolling_max = numbers.shift\n\
    \  until numbers.empty?\n    current_element = numbers.shift\n    if current_element\
    \ > rolling_max\n      max_element = current_element\n      rolling_max = current_element\n\
    \    else\n      if max_element < current_element\n        max_element = current_element\n\
    \      end\n    end\n  end\n  return max_element\nend\n</code>\n<|/ a dscore=2\
    \ tags=ruby,max |>\n<| c |>\nThis is wrong. `rolling_max(1..5)` returns 5, but\
    \ should be 4. The first call should be `rolling_max(1..4)`.\n<|/ c |>\n<| c |>\n\
    This code is wrong: rolling_max(1..5) returns 5 but should be 4.\n<|/ c |>\n<|\
    \ c |>\nIt will give you the wrong result if the array is empty and no element\
    \ in the array is greater than the current maximum value.\n<|/ c |>\n<| c |>\n\
    I have edited the code so that it correctly deals with empty arrays and arrays\
    \ with only a single element\n<|/ c |>\n<| a |>\nI agree with Ben's comment. I\
    \ think this is a good way to do it:\n<code>", "  max_element = numbers[0]\n \
    \ \n  for n in numbers[1..-1]\n    n.each do |m|\n      if m > max_element\n \
    \       max_element = m\n      end\n    end\n  end", "  numbers.inject(0) {|max,\
    \ x| x > max ? x : max }\nend", "  numbers.each { |number|\n    rolling_max =\
    \ number\n    numbers.each { |number|\n      if number > rolling_max\n       \
    \ rolling_max = number\n      end\n    }\n    puts \"max number in sequence is\
    \ #{rolling_max}\"\n  }\nend", "  maxes = [0] * numbers.size\n  numbers.each do\
    \ |i|\n    maxes[i] = maxes[i-1] || i\n  end\n  maxes\nend", "  result = numbers.max\n\
    \  rolling = numbers.max\n  numbers.each do |n|\n    result = rolling if n <=\
    \ rolling\n    rolling = n\n  end\n  result\nend", "  numbers.map {|n| max(n,\
    \ numbers[-1]) }\nend", "    rolling_max = numbers.max\n    numbers.each do |number|\n\
    \        rolling_max = number if number > rolling_max\n    end\n    rolling_max\n\
    end", "  # We start with an empty array.\n  max = []\n  # For each number we test\
    \ if it is lower than the maximum, if so, we add it to the\n  # array. Otherwise\
    \ we set the maximum to that number.\n  numbers.each do |number|\n    max = number\
    \ < max ? [number, max] : number\n  end\n  max\nend", "  numbers.each_with_index\
    \ do |number, index|\n    if number > max_number\n      max_number = number\n\
    \    end\n    number > max_number ? rolling_max(numbers[index...index+1]) : nil\n\
    \  end\nend\n</cell>\n<cell>\nrolling_max([1,2,3,4,5,6,7,8,9,10])\n</cell>\n<text>\n\
    The same idea can be applied for min function", "    rolling_max_numbers = []\n\
    \    rolling_max_index = nil\n    rolling_max_number = nil\n    rolling_max_num\
    \ = nil\n    # Find first max element.\n    rolling_max_num = numbers.shift\n\
    \    rolling_max_numbers.push rolling_max_num\n    rolling_max_index = numbers.index{|num|\
    \ num == rolling_max_num}\n    # Find max element that come after rolling_max_index.\n\
    \    rolling_max_num = numbers[rolling_max_index + 1]\n    rolling_max_numbers.push\
    \ rolling_max_num\n    rolling_max_index = numbers.index{|num| num == rolling_max_num}\n\
    \    # Find max element that come after rolling_max_index and so on.\n    until\
    \ numbers.nil?\n        if numbers.size > rolling_max_index\n            rolling_max_num\
    \ = numbers[rolling_max_index]\n            rolling_max_numbers.push rolling_max_num\n\
    \            rolling_max_index = numbers.index{|num| num == rolling_max_num}\n\
    \        else\n            # Last moment in the sequence.\n            rolling_max_num\
    \ = numbers.pop\n            rolling_max_numbers.push rolling_max_num\n      \
    \  end\n    end\n    rolling_max_numbers\nend", "  numbers.each_with_index do\
    \ |number, index|\n    current_max = number\n    index += 1\n    rolling_max[index].tap\
    \ do\n      numbers[index] = number if number > current_max\n    end\n  end\n\
    end", "  roll_max = []\n  roll_max.push(0)\n  roll_max.push(numbers[0])\n  roll_max.push(numbers[1])\n\
    \  roll_max.push(numbers[2])", "  numbers.each_with_object([]) do |number, acc|\n\
    \    max_rolling = acc.length\n    acc.each do |i|\n      max_rolling = max_rolling\
    \ if i == number\n    end\n    acc << max_rolling\n  end\nend", "    numbers.last.max\n\
    end\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code\
    \ language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\n\
    rolling_max([1,2,3])\n</cell>\n<code language=julia-0.5>\nrolling_max([1,2,3])\n\
    </cell>\n<code language=julia-0.5", "  rolling_max_array = []\n  numbers.each\
    \ do |num|\n    rolling_max_array << num if num > rolling_max_array.last\n  end\n\
    \  rolling_max_array\nend", "  # Calculate the length of the sequence.\n  length\
    \ = numbers.size\n  # Start from the second element.\n  index = 1\n  # Start accumulating\
    \ the rolling max values until the current moment.\n  rolling_max = [numbers[index]]\n\
    \  while index < length\n    # Calculate the previous element's rolling max value.\n\
    \    rolling_max = [max(numbers[index], rolling_max[0], numbers[index - 1])].max\n\
    \    # Increment the counter.\n    index += 1\n  end\n  # Return the rolling max\
    \ value.\n  rolling_max\nend\n</code>\nI tested this with a few examples and the\
    \ results seem correct.\n<code>\nnumbers = [1, 2, 3, 4, 4, 4, 5, 5, 6, 7, 7]\n\
    rolling_max(numbers)", "  return numbers.reduce(:+)\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis won't work for me since `rolling_max` returns the maximum number\
    \ of the window. My goal is to return the maximum number of the window and any\
    \ preceding numbers in the window as well. My question is more geared towards\
    \ how I can find the maximum number of a window *and* all preceding numbers in\
    \ the window.\n<|/ c |>\n<| c |>\nI added a solution returning the whole window\
    \ with the max element\n<|/ c |>\n<| c |>\nThis still doesn't solve my problem\
    \ since `rolling_max` returns a single value from the whole window. My goal is\
    \ to return both numbers of a window and the maximum number. My question is more\
    \ geared towards how I can find the maximum number of a window *and* all preceding\
    \ numbers in the window.\n<|/ c |>\n<| c |>\nI don't see how this doesn't answer\
    \ your question. Let me know if there are things that you didn't understand.\n\
    <|/ c |>\n<| a tags=ruby,enumerator dscore=0 |>\nI think this is a fairly straightforward\
    \ way to do it:\n<code>", "  max_number = numbers[-1]\n  max_indices = []\n  numbers.each_with_index\
    \ do |number, i|\n    max_number = number\n    max_indices[i] = i\n  end\n  max_indices.each_with_index\
    \ do |max_index, i|\n    if max_index <= i - 1\n      max_number = numbers[max_index]\n\
    \      max_indices[i] = i\n      break\n    end\n  end\n  max_indices\nend", " \
    \ max_number = numbers.max\n  max_index = 0\n  numbers.each do |number|\n    if\
    \ number > max_number\n      max_number = number\n      max_index = number\n \
    \   end\n  end\n  [max_number, max_index]\nend\n</code>\nAt the moment it returns\
    \ an array, so you have to remember that rolling_max returns an array and you\
    \ have to decide how to handle it: do you return the maximum as well as the index\
    \ where it was? or just return the index where it was? This answer will cover\
    \ both\n<code>", "  rolling_max_elements = []\n  rolling_max_elements_count =\
    \ 0\n  for i in 1...numbers.count\n    rolling_max_elements_count += 1\n    rolling_max_elements.push(numbers[i])\n\
    \    rolling_max_elements.unshift(numbers[(i - rolling_max_elements_count) + 1])\n\
    \  end\n  rolling_max_elements\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nHere is an example of how to do it with array's and loops:\n<code>", " \
    \ numbers.map do |number|\n    number.reduce(::Math.max) {|a, b| a < b ? a : b}\n\
    \  end\nend\n</code>\nThis returns [10, 12, 15, 16, 17]\nIf you wanted a rolling\
    \ mean of a list of integers, you could use something like this:\n<code>", " \
    \ rolling_max = numbers.shift\n  rolling_max.each do |number|\n    rolling_max\
    \ = numbers.shift if rolling_max.last <= number\n  end\n  rolling_max\nend", " \
    \   numbers.each do |number|\n        rolling_max = number\n        break if number\
    \ > rolling_max\n    end\n    rolling_max\nend", "  numbers.reduce(:*)\nend",
  "  # initialize an array to store max result\n  max_rolling_result = []\n  # initialize\
    \ a result to store current max number\n  current_max_number = 0\n  # while loop\
    \ will keep looping until no number left to loop\n  until numbers == []\n    #\
    \ add numbers to array \n    max_rolling_result << current_max_number\n    # find\
    \ the max number in the current number\n    current_max_number = numbers.max\n\
    \    # remove current number from numbers\n    numbers.shift\n  end\n  return\
    \ max_rolling_result\nend", "    # Initialize an array to store rolling maximum.\n\
    \    rolling_maxes = []\n    # Initialize a variable to store the last non-zero\
    \ value in the sequence (initially 0)\n    last_non_zero = 0\n    # Initialize\
    \ a variable for the length of numbers in sequence (initially 0)\n    length_numbers\
    \ = numbers.length\n    # While there are still items in the sequence...\n   \
    \ while (numbers.length > 0)\n        # Pop the first item\n        last = numbers.shift\n\
    \        # If the last item is non-zero...\n        if (last != 0)\n         \
    \   # Store the last non-zero item in the rolling maximum array\n            rolling_maxes.push(last)\n\
    \        # Otherwise, store the last non-zero item in the rolling maximum array\n\
    \        else\n            # Store the last non-zero item in the rolling maximum\
    \ array\n            rolling_maxes.push(last)\n        # Move the last_non_zero\
    \ variable to the last non-zero value\n        last_non_zero = last\n    # Return\
    \ the rolling maximum array\n    return rolling_maxes\nend", "  max_array = numbers.shift.(numbers)\n\
    \  max_array.each_with_index do |number,index|\n    if number > max_array[index]\n\
    \      max_array[index] = number\n    end\n  end\n  max_array\nend", "  rolling_max\
    \ = []\n  max_number = numbers.last\n  i = 0\n  while i < numbers.count\n    max_number\
    \ = numbers[i]\n    i += 1\n    if i == numbers.count\n      rolling_max << max_number\n\
    \    else\n      rolling_max << max_number if numbers[i] > max_number\n    end\n\
    \  end\n  rolling_max\nend", "  rolling_max_number = numbers.max\n  \n  rolling_max_numbers.times\
    \ do |i|\n    rolling_max_number = rolling_max_number > numbers[i] ? numbers[i]\
    \ : rolling_max_number\n  end\n  \n  rolling_max_numbers\nend", "  numbers.each_with_index.inject(0)\
    \ { |max, (number, index)| max < number ? max : number }\nend", "  max_element\
    \ = 0\n  rolling_sum = 0", "  max_numbers = []\n  numbers.each do |number|\n \
    \   if number == max_numbers[-1]\n      max_numbers << number\n      numbers.shift\n\
    \    end\n  end\n  max_numbers\nend\n</code>\n<|/ a |>\n<| c |>\nThis would not\
    \ work for negative numbers.\n<|/ c |>\n<| c |>\nYou're right. I was thinking\
    \ more of an algorithm, but I'll edit it to include negative numbers too.\n<|/\
    \ c |>\n<| c |>\nThe solution posted is correct for negative numbers, but as far\
    \ as I know, there's no `-(n+1)` term in the above formula. The formula should\
    \ be `(n+1)!/((n+1)!*(2!+3!+...))`.\n<|/ c |>\n<| a |>\n<code>", "  rolling_maxs\
    \ = []\n  numbers.each_with_index do |n, i|\n    rolling_maxs << rolling_max(i,\
    \ n)\n  end\n  rolling_maxs.each do |m|\n    if m.nil?\n      m = 0\n    end\n\
    \  end\n  return rolling_maxs\nend", "  rolling_max_list = []\n  numbers.each\
    \ do |n|\n    rolling_max_list.push n if rolling_max_list.size <= max_rolling\n\
    \    rolling_max_list.push n if rolling_max_list.size <= max_rolling\n  end\n\
    \  rolling_max_list.delete(rolling_max_list.min)\n  rolling_max_list\nend\n</code>\n\
    The output would be the list of maximum elements found until that moment. I hope\
    \ it can help you.\n<|/ a dscore=2 |>\n<| c |>\nHi, thanks for the reply. I think\
    \ this is the right approach for my problem. Would you be able to give me some\
    \ hints on how to solve my second question as stated above?\n<|/ c |>\n<| c |>\n\
    I added another solution for you on my answer. I hope it can help you on your\
    \ second question.\n<|/ c |>\n<| a |>\nA recursive function that takes in an n-element\
    \ array and returns the n-th element\n<code>", "  numbers.to_a.reverse.each_with_index\
    \ do |number, i|\n    numbers.slice!(i, i+1).max\n  end\nend", "    # Initialize\
    \ a list to save the result and return it.\n    maximum = []", "  rolling_max\
    \ = []\n  rolling_max.push(0)\n  rolling_max.push(numbers.max)\n  numbers.each_index\
    \ do |i|\n    if i+1 < numbers.length\n      rolling_max[i + 1] = numbers[i]\n\
    \    end\n  end\n  rolling_max\nend\n</code>\nYou can now easily find rolling\
    \ maximum while your current element is at index #index and store it in a list\
    \ as shown below:\n<code>\nrolling_max(numbers).each_index do |index|\n  p numbers[index].max(rolling_max(numbers)[index])\n\
    end\n</code>\nYou can also use map and reduce:\n<code>\nnumbers = [2,4,6,8,10,12]",
  "\tnumbers.shift\n\tnumbers.each do |number|\n\t\tyield number if number > max_number\n\
    \t\tmax_number = number\n\tend\nend", "  maximums = []\n  rolling_number = nil\n\
    \  numbers.each do |number|\n    rolling_number = number + rolling_number\n  \
    \  rolling_number < number ? maximums.push(rolling_number) : next\n  end\n  maximums\n\
    end", "  numbers.sort.reverse\n  numbers_sum = 0\n  result = []\n  rolling_sum\
    \ = 0\n  rolling_max = 0\n  while numbers.length > 0\n    rolling_max = numbers[0]\n\
    \    rolling_sum += numbers[0]\n    numbers.shift\n    numbers_sum += 1\n    if\
    \ numbers_sum > 100\n      numbers_sum = 0\n    end\n    numbers.each do |number|\n\
    \      rolling_max = number if rolling_sum + number > rolling_max\n      rolling_sum\
    \ += number\n      result.push(rolling_max)\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis is not correct. The OP asked for a maximum, not the minimum.\
    \ And your function returns the minimum, not the maximum.\n<|/ c |>\n<| a |>\n\
    <code>", "  numbers.each_with_object([]) do |number, acc|\n    acc << number\n\
    \    acc.last(number.size) do |e|\n      if e < number\n        acc.insert(0,\
    \ e)\n      end\n    end\n  end\nend", "  numbers.shift\n  numbers.shift while\
    \ numbers.size > 0\n  numbers.shift\nend", "  rolling_max.numbers ||= []\n  return\
    \ rolling_max.numbers << numbers.max\nend", "  numbers.each_with_index.map {|number,\
    \ index| numbers[index] > number ? numbers[index] : number} + numbers.min\nend",
  "    numbers.each_index do |i|\n        numbers[i] == numbers[i-1] ? numbers[i-1]\
    \ = numbers[i] : nil\n    end\n    numbers.max\nend\n</code>\n<|/ a dscore=2 tags=ruby\
    \ |>\n<| a tags=ruby |>\nThis may help somebody\n<code>\narray.each_index.inject(:+).max\
    \ || 0\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThat's great but I guess the OP wants\
    \ to apply it to an arbitrary range of `array` indices.\n<|/ c |>\n<| a |>\nThis\
    \ should work:\n<code>", "  rolled = 0\n  \n  while numbers.last < numbers\n \
    \   rolled = numbers.last\n    numbers = numbers[-numbers.last..-1]\n  end\n \
    \ \n  rolled\nend\n</cell>\n<text>\nAnd now let's try it!", "  max = numbers.max\n\
    \  max_index = numbers.index(max)\n  rolling_max = []\n  rolling_max.push(max)\n\
    \  max_number = numbers[max_index]\n  max_index.times do |i|\n    max = numbers[i]\n\
    \    max_index = numbers.index(max)\n    rolling_max.push(max)\n  end\n  rolling_max\n\
    end", "  max = numbers.reduce(:+)\n  numbers.each do |number|\n    max = number\
    \ > max ? number : max\n  end\n  max\nend", "  max = numbers[0]\n  max_rolling_number\
    \ = numbers[0]\n  rolling_numbers = numbers.dup\n  rolling_numbers.shift(1) #\
    \ Remove first element and shift all other elements", "    numbers.each do |number|\n\
    \        numbers.each do |number| \n            if number > number\n         \
    \       puts number\n                break\n            end\n        end\n   \
    \ end\nend\n</code>\nI believe it can help you.\n<|/ a tags=ruby |>\n<| c |>\n\
    This returns `1` and not `3` for me\n<|/ c |>\n<| a |>\nThis should work for you:\n\
    <code>", "  numbers.each_with_index.map { |e,i| i < number ? e : rolling_max(numbers[i..-1])\
    \ }\nend\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nJust to give an alternative\
    \ to Rolling Max, which I came across when I was working on a similar problem.\
    \ \n<code>", "  max_number = nil\n  numbers.each do |number|\n    if max_number.nil?\
    \ || number > max_number\n      max_number = number\n    end\n  end\n  max_number\n\
    end", "  numbers.each do |n|\n    roll_max = []\n    roll_max.push(n) if roll_max.size\
    \ == 0\n    roll_max.each do |m|\n      if m > n\n        roll_max = roll_max[roll_max.size\
    \ - 1]\n      else\n        roll_max = m\n      end\n    end\n    puts roll_max\n\
    \  end\nend", "  numbers.map(&:to_i)\n  max_rolling = numbers.reverse.first(numbers.first).last(numbers.last)\n\
    \  numbers[numbers.index(max_rolling) + 1]\nend", "  # Sort given list.\n  numbers.sort!",
  "  numbers.max_by { |n| n }\nend", "  numbers.sort_by!(&:first)\n  numbers.reverse_each{|x|\
    \ x.pop} = numbers.last\n  numbers.reverse.map {|x| x.last}\nend", "    numbers.sort.reverse.each\
    \ do |number|\n        if number > numbers.shift.to_i\n            numbers.shift.to_i\n\
    \        end\n    end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis seems to\
    \ just be the rolling_max method from the answer I accepted for this question.\
    \ It also seems to have a bug that is unrelated to the question\n<|/ c |>\n<|\
    \ a dscore=0 tags=ruby |>\nHere is another solution using Ruby's Enumerator class:\n\
    <code>", "  max_number = nil\n  numbers.each do |number|\n    max_number = number\
    \ if number > max_number\n  end\n  max_number\nend\n</code>\nThe same way, you\
    \ can calculate rolling_sum and rolling_mean easily.\n<code>", "  maximum = numbers.max\n\
    \  result = []\n  result.push(maximum)\n  numbers.each do |number|\n    next if\
    \ number > maximum\n    result.push(number)\n    maximum = number\n  end\n  result\n\
    end\n</code>\nUsing Array#<< and Array#max\n<code>", "  return numbers.compact.map\
    \ { |x| x > numbers.last ? x : numbers.last }.compact\nend", "  numbers.reduce(:+)\n\
    end\n</code>\nNow the problem becomes easy:\n<code>", "  rolled = []\n  rolling_index\
    \ = 1\n  numbers.each do |x|\n    rolled << numbers[rolling_index]\n    rolling_index\
    \ += 1\n    if rolling_index < numbers.count\n      rolled[-1] = rolled[-2] +\
    \ rolled[-1]\n    else\n      rolled.pop\n    end\n  end\n  rolled.pop\nend",
  "  rolling_max_element = []\n  i = 0\n  while i < numbers.length\n    rolling_max_element\
    \ << (numbers[i] == numbers[i + 1] ? numbers[i + 1] : numbers[i])\n    i += 2\n\
    \  end\n  rolling_max_element\nend", "  numbers.each do |n|\n    rolling_max.shift!\
    \ if rolling_max.first == nil or rolling_max[0] < n\n    rolling_max << n\n  end\n\
    \  rolling_max\nend\n</code>\nA sample run:\n<code>\nnumbers = %i{\n  1 2 3 4\
    \ 5 6 7 8 9 10\n}\nrolling_max(numbers)", "  # initialize your empty array with\
    \ the length of the list\n  rollingMaxes = []\n  rollingMaxes.push(numbers[0])\n\
    \  numbers.each_index { |index| rollingMaxes.push(rollingMaxes[-1]) if rollingMaxes[-1]\
    \ > numbers[index] }\n  return rollingMaxes\nend", "  rolling_max_numbers = []\n\
    \  rolling_max = numbers.shift\n  rolling_max_numbers.unshift(rolling_max)\n \
    \ numbers.each do |number|\n    if number > rolling_max\n      rolling_max = number\n\
    \    end\n    rolling_max_numbers.unshift(rolling_max)\n  end\n  rolling_max_numbers\n\
    end", "  rolling_max = numbers.first\n  rolling_max_index = 0\n  numbers.each\
    \ do |element|\n    if element > rolling_max\n      rolling_max = element\n  \
    \    rolling_max_index = elements.index(element)\n    end\n  end\n  rolling_max\n\
    end", "  result = Array.new(numbers.size) { |i| numbers.shift() }\n  current_max\
    \ = result.first\n  i = 0\n  while i < numbers.size do\n    result.shift\n   \
    \ current_max = [current_max, numbers[i]].max\n    i += 1\n  end\n  result\nend",
  "  rolling_max = numbers.shift\n  numbers.each do |number|\n    rolling_max = number\
    \  if rolling_max > number\n  end\n  rolling_max\nend", "  # Initialize a list\
    \ to store our rolling maximum element found\n  maximum_element_found = []\n \
    \ rolling_max = nil", "    # To return the maximum number found so far\n    max\
    \ = 0\n    # To keep track of the biggest number\n    biggest_so_far = numbers[0]\n\
    \    # To keep track of the current biggest number\n    current_biggest_so_far\
    \ = numbers[0]\n    # To keep track of the number of rolling max\n    rolling_max\
    \ = numbers[0]", "  return rolling_max(numbers.reverse).reverse\nend\n</code>\n\
    <|/ a tags=ruby,max,arrays dscore=0 |>\n<| a tags=ruby,max,arrays |>\nHere's another\
    \ simple way to do it using Enumerable#max_by :\n<code>\narr.max_by { |e| -e[arr.rindex(e,\
    \ arr.length)] }", "  rolling_max = numbers[0]\n  rolling_min = numbers[0]\n \
    \ rolling_max_idx = nil\n  rolling_min_idx = nil\n  rolling_min = numbers[0]\n\
    \  rolling_max = numbers[0]", "  max_el = numbers[0]\n  max_el_index = 0", " \
    \   # Write your code here\n    rolling_max = numbers[0]\n    rolling_max_time\
    \ = numbers[0]", "  rolling_max_count = 0\n  rolling_max_element = 0\n  rolling_max_index\
    \ = nil\n  numbers.each_with_index do |n,i|\n    if rolling_max_count <= i\n \
    \     rolling_max_count = i\n      rolling_max_element = n\n      rolling_max_index\
    \ = i\n    elsif rolling_max_count > i\n      rolling_max_count = i\n      rolling_max_element\
    \ = n\n    end\n  end\n  rolling_max_count, rolling_max_element, rolling_max_index\n\
    end\n</cell>\n<cell>\nrolling_max([2, 5, 6, 9])\n</cell>\n<text>\nExercise:\n\
    Write a method that will find all numbers in a list that are divisible by 2 or\
    \ 3, starting from a given index and rolling 2 elements at a time.", "  rolling_max.last_max\
    \ = nil\n  numbers.each do |number|\n    if rolling_max.last_max != number\n \
    \     rolling_max.last_max = number\n    end\n  end\n  rolling_max.last_max\n\
    end\n</code>\n<|/ a |>\n<| a dscore=3 |>\n<code>", "  rolling_max_list = []\n\
    \  max_number = numbers.max # Max of the given numbers\n  numbers.each do |number|\n\
    \    if number > max_number\n      rolling_max_list << max_number\n      max_number\
    \ = number\n    else\n      max_number = number\n    end\n  end\n  rolling_max_list\
    \ << max_number\n  rolling_max_list\nend\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\nAn alternate answer, for Ruby 1.9+\n<code>\n\
    numbers = 30.times.map { |n| rand(100) + 1 }\nrolling_max = numbers.inject{ |s,n|\
    \ s > n ? s : n }\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`rolling_max = [...].inject(0,\
    \ &:>)` is probably more idiomatic than `rolling_max = numbers.inject(0, &:>)`,\
    \ but both are correct.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
