name: HumanEval_59_largest_prime_factor
language: rb
prompt: "# Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  def largest_prime_factor(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_prime_factor\n\
  \    candidate = method(:largest_prime_factor)\n    assert_equal(5, candidate.call(15))\n\
  \    assert_equal(3, candidate.call(27))\n    assert_equal(7, candidate.call(63))\n\
  \    assert_equal(11, candidate.call(330))\n    assert_equal(29, candidate.call(13195))\n\
  \  end\nend\n"
completions: ["  # If n is prime, return n.\n  if n < 2\n    return n\n  # If n is\
    \ composite or even, return n.\n  if n % 2 == 0\n    return n\n  # If n is composite\
    \ and odd, skip to next even number.\n  n = 3\n  while n % 2 == 0\n    n = n/2\n\
    \  end\n  # If n is composite and odd, skip to next odd number.\n  n = 3\n  while\
    \ n % 2 == 1\n    n = n/2\n  end\n  # Return n\n  return n\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nThanks, I understand your method! I wonder if there\
    \ is a more efficient solution than mine.\n<|/ c |>\n<| c |>\nActually, the efficiency\
    \ of this method is almost the same as my recursive solution. I was wondering\
    \ if there is a better solution. Thank you for your help though! :)\n<|/ c |>\n\
    <| c |>\nYour method is recursive.  It was simply more elegant to implement it\
    \ in Ruby.\n<|/ c |>\n<| c |>\nYour method does not work for large values of n.\
    \ It is a very inefficient way to find the largest prime factor. There are many\
    \ more efficient algorithms than the one you presented. See my answer for an O(1)\
    \ algorithm that uses [the Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n\
    <|/ c |>\n<| c |>\nI did see that and saw that your solution was recursive.  I\
    \ was trying to convey that my solution was more elegant.  I wrote this answer\
    \ in an effort to teach the OP how to find the largest prime factor.  I did not\
    \ write a recursive solution.  The OP asked for a recursive solution.  I did write\
    \ my recursive solution in Ruby.  I am not trying to be mean or insulting.  I\
    \ wanted to show how you could write the algorithm as a recursive function.  I\
    \ did not write my solution.  I merely answered the OP's question.  I did not\
    \ write the code for him.  I merely answered the OP's question.  I did not give\
    \ him a code solution.\n<|/ c |>\n<| a dscore=3 |>\nThis should work:\n<code>",
  "  n = n.to_i\n  prime = prime_number(n)\n  if prime == 1\n    n\n  else\n    largest_prime_factor(n\
    \ / prime)\n  end\nend\n</code>\n<|/ a tags=ruby,sieve-of-eratosthenes |>\n<|\
    \ a dscore=2 |>\nSure, here is my take on this:\n<code>", "  i = 2\n  while i\
    \ < n do\n    i += 2\n    if n % i == 0 then return i\n  end\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a |>\nI found the best way to do this without using recursion\
    \ was to go through the numbers and check each number against a list of the prime\
    \ numbers up to sqrt(n). After checking, you can add this number to the array\
    \ if it's not already in the array. \n<code>\nfunction [primes, isPrime] = findPrimeNumbers(n)\n\
    \  primes = zeros(1,n);\n  isPrime = zeros(1,n);", "  # Write your solution here.\n\
    end\n</pre>\n<pre class=\"ruby\"><span class=\"ruby-comment\"># Test cases:\n\
    assert(largest_prime_factor(12) == 4)\nassert(largest_prime_factor(11) == 2)\n\
    assert(largest_prime_factor(10) == 2)\nassert(largest_prime_factor(9) == 2)\n\
    assert(largest_prime_factor(100) == 4)\nassert(largest_prime_factor(101) == 2)\n\
    assert(largest_prime_factor(102) == 2)\nassert(largest_prime_factor(103) == 4)\n\
    assert(largest_prime_factor(104) == 2)\nassert(largest_prime_factor(105) == 6)\n\
    assert(largest_prime_factor(200) == 6)\nassert(largest_prime_factor(201) == 4)\n\
    assert(largest_prime_factor(300) == 3)\nassert(largest_prime_factor(501) == 10)\n\
    assert(largest_prime_factor(500) == 5)\nassert(largest_prime_factor(1000) == 5)\n\
    assert(largest_prime_factor(1000) == 5)\nassert(largest_prime_factor(10000) ==\
    \ 8)\nassert(largest_prime_factor(100000) == 5)\nassert(largest_prime_factor(1000000)\
    \ == 5)\nassert(largest_prime_factor(10000000) == 5)\nassert(largest_prime_factor(100000000)\
    \ == 5)\nassert(largest_prime_factor(1000000000) == 5)\nassert(largest_prime_factor(10000000000)\
    \ == 5)\nassert(largest_prime_factor(100000000000) == 5)\nassert(largest_prime_factor(1000000000000)\
    \ == 5)\nassert(largest_prime_factor(10000000000000) == 5)\nassert(largest_prime_factor(100000000000000)\
    \ == 5)\nassert(largest_prime_factor(1000000000000000) == 5)\nassert(largest_prime_factor(10000000000000000)\
    \ == 5)\nassert(largest_prime_factor(100000000000000000) == 5)\nassert(largest_prime_factor(1000000000000000000)\
    \ == 5)\n</pre>\n<p><b class=\"alert\">Solution:</b></p>\n<pre>", "    prime_factors\
    \ = prime_factorize(n)\n    prime_factors.each do |num, prime_factor|\n      \
    \  prime_factor_found = true\n        break\n      end\n      unless prime_factor_found\n\
    \        prime_factors.delete(num)\n      end\n  end\n</code>\n<|/ a tags=ruby,primes,algorithm,time-complexity\
    \ dscore=2 |>\n<| c |>\nI didn't notice that I was checking for multiples of 2.\
    \ It should have been obvious that there were more efficient ways to do it. The\
    \ biggest issue is that I was assuming too much about the time complexity. Thank\
    \ you for the suggestion.\n<|/ c |>\n<| a dscore=1 |>\nI think this should be\
    \ pretty efficient, although it takes a bit more memory than you need:\n<code>",
  "  loop do\n    r = n / 2\n    while (r * r == n)\n      r = r / 2\n    break r\
    \ if r * r > n\n    n -= 1\n  end\nend", "  factors = factor(n).to_a\n  factors.reverse!\n\
    \  factors.each_with_index { |factor, i| return i if factor.prime? }\n  factors.length\n\
    end\n</cell>\n<cell>\nlargest_prime_factor(6)\nlargest_prime_factor(729)\n</cell>\n\
    <cell>\nlargest_prime_factor(2431)\nlargest_prime_factor(4859)\n</cell>\n<cell>\n\
    largest_prime_factor(136971)\nlargest_prime_factor(394206)\n</cell>\n<cell>\n\
    largest_prime_factor(490014941)\nlargest_prime_factor(97564479)\n</cell>\n<cell>",
  "  primes = [2, 3, 5]\n  i = 2\n  while primes.include?(i) && i*i < n\n    i +=\
    \ 1\n  end\n  \n  primes.include?(i) ? i : nil\nend", "  primes = primes(n)\n\
    \  return primes[-1] if n > 1 and n % primes.last == 0 && !primes.include?(n %\
    \ primes.last) \nend\n</code>\nNote that it returns the largest prime factor of\
    \ the number n, but you didn't specify that in your question. But I guess you\
    \ know how to adapt it for your needs.\nYou can see it running in the playground.\n\
    <|/ a dscore=2 |>\n<| c |>\nI added a description to the question. Sorry for the\
    \ confusion, I didn't realize it was very important.\n<|/ c |>\n<| a |>\nThe most\
    \ efficient way to solve this problem is to solve it as an undirected graph problem.\n\
    You can read more about this here.\nThere are a few reasons why this might help:",
  "  if n == 0\n    return 0\n  end", "  i = 1\n  while i < n do\n    i += 1\n   \
    \ j = n-1\n    while j > i and j % i == 0 do\n      j -= 1\n    end\n    if j\
    \ > i then\n      break\n    end\n  end\n  j\nend\n</code>\nBut there is a problem\
    \ with this. Suppose n = 10000000000001, then we have i = 1 and j = 10000000000000\
    \ - 1 = 10000000000002, and i is prime, therefore j can be eliminated from our\
    \ loop. Thus, we would run a loop until j < i which would take an awful long time.\
    \ \nFor this reason, we can optimize our prime-finding algorithm by only testing\
    \ every second prime and testing only odd numbers. We can do this by looping through\
    \ the range 2..n and stopping if our number is even.\n<code>", "  factors = prime_factors(n)\n\
    \  factors.each do |factor|\n    break if factors.count > factor\n    factor\n\
    \  end\nend", "  factors = []\n  (1..n).each do |i|\n    factor = i\n    (2..i).each\
    \ do |j|\n      break if j > factor\n      factor = j * factor\n    end\n    factors\
    \ << factor\n  end\n  factors.max_by{|f| f}\nend", "  if n <= 1\n    n\n  else\n\
    \    largest_prime_factor(n.divide(2))\n  end\nend", "  # Check for trivial factors\
    \ first.\n  if n == 1\n    return 1\n  \n  # Check all odd numbers up to n.\n\
    \  i = 3\n  while i <= n\n    # If n is divisible by i, n is a factor and we return\
    \ it.\n    if n % i == 0\n      return i\n    \n    i = i + 2\n  end\n  \n  #\
    \ n is composite, so return nil.\n  return nil\nend", "  i = 2\n  while i * i\
    \ < n do\n    i += 1\n  end\n  while n % i == 0 do\n    n /= i\n    i += 1\n \
    \ end\n  if n > 1\n    n\n  end\nend", "  if n == 1\n    1\n  else\n    largest\
    \ = 0\n    factor = 1\n    loop do\n      i = n / factor\n      break if i ==\
    \ n\n      largest = factor if i > largest\n      factor = i * 2\n    end\n  \
    \  largest\n  end\nend", "  for i in (1..n)\n    if n % i == 0 \n      return\
    \ i\n  raise \"no factors found\"\nend", "  prime_factors = []\n  i = 1\n  while\
    \ i * i <= n\n    prime_factors += [i * i]\n    i += 1\n  prime_factors.reverse\n\
    \  return prime_factors.max_by(&:itself).last\nend", "  primes = []\n  n.times\
    \ {\n    if n.prime? then\n      primes << n\n      n /= n\n    end\n  }\n  primes.inject(1)\
    \ {|sum, prime| sum + prime }\nend\n</code>\nWe can now test our implementation\
    \ with a few tests:\n<code>\nputs largest_prime_factor(10)\nputs largest_prime_factor(100)\n\
    puts largest_prime_factor(1000)\nputs largest_prime_factor(10000)\nputs largest_prime_factor(100000)\n\
    puts largest_prime_factor(1000000)\nputs largest_prime_factor(10000000)\n</code>\n\
    ...which outputs:\n<code>\n10\n100\n1000\n10000\n100000\n</code>\n<|/ a tags=ruby\
    \ dscore=2 |>\n<| c |>\nI think you could just `n.prime? && n.times {n /= n}`\
    \ in your loop and be done with it.\n<|/ c |>\n<| c |>\nVery clever, and a great\
    \ way to learn how to write good Ruby.\n<|/ c |>\n<| c |>\nThis is definitely\
    \ an improvement on my previous code. Thank you\n<|/ c |>\n<| a tags=ruby dscore=0\
    \ |>\nHere's a slightly different version that uses prime numbers (and also the\
    \ fact that primes are consecutive). \nIt also doesn't rely on enumerators etc.\n\
    <code>", "  n = n.to_i\n  return n if n.odd? || n == 1 || n == 2 || n % 2 == 0\
    \ || n % 3 == 0 || n % 5 == 0 ? n : n % 7 == 0 ? n : nil\nend", "  if n.even?\n\
    \    return n\n  elsif n.odd?\n    return 2\n  end\n  i = 3\n  factors = []\n\
    \  while i <= n / 2 do\n    if n % i == 0\n      factors << i\n      n /= i\n\
    \    end\n    i += 1\n  end\n  if n > 1\n    factors << n\n  end\n  return factors\n\
    end", "  primes = prime_numbers(n-1)\n  return primes.min { |a, b| (a*b) > n }\n\
    end", "  if n == 2 || n == 3 || n == 5\n    3\n  else\n    # Factor the number\
    \ to find the largest prime factor\n    n = fact_to_n_prime(n)\n    # Return the\
    \ largest prime factor of the number n\n  end\nend", "  factor = 1\n  while n\
    \ > 1\n    n /= factor\n    factor += 1\n  end\n  factor\nend", "    return n/prime_table[n]\n\
    end\n</code>\nThis could be optimized to return the largest prime factor of n\
    \ only once.\n<|/ a dscore=0 |>\n<| c |>\nThis will not work because `prime_table`\
    \ is only defined at module level and will return a `NameError` when called from\
    \ `largest_prime_factor`.\n<|/ c |>\n<| c |>\n: That's true. I've updated my answer\
    \ to define the `prime_table` variable in the `largest_prime_factor` function.\n\
    <|/ c |>\n<| c |>\nThat makes sense, thanks. I just have one question: why are\
    \ we dividing by n instead of `n`?\n<|/ c |>\n<| c |>\n: As mentioned in my answer,\
    \ `n` is not a prime. I want the largest prime factor of `n`. For example, with\
    \ `n = 13` the largest prime factor is `3`, not `13`.\n<|/ c |>\n<| c |>\n: That\
    \ is correct, but that's not my question. I'm asking why do we use `n` instead\
    \ of `n` when you define `largest_prime_factor`.\n<|/ c |>\n<| a |>\nThis is an\
    \ extension to 's answer, using prime function from Math module:\n<code>", " \
    \ # return n if n is prime\n  if n == 2\n    return n\n  # if n is greater than\
    \ 2, then n is not prime\n  return 2 if n%2 == 0\n  # If n is odd, then divide\
    \ by 2 and see if it is a prime or not\n  while n%2 == 1\n    n = n/2\n    if\
    \ n % 2 == 0\n      return n\n    # else n is odd and must be prime\n  end\n \
    \ # If n is even, then divide by 3 and see if it is prime or not\n  while n%3\
    \ == 0\n    n = n/3\n    if n % 2 == 0\n      return n\n    end\n  end\n  # If\
    \ n is not a prime number, then return nil\nend\n</code>\n<|/ a tags=algorithm,prime-factoring,ruby,primes\
    \ dscore=0 |>\n<| a |>\nHere's an implementation for finding all primes <= a given\
    \ number using sieve of Eratosthenes in Ruby. This also uses a generator to create\
    \ all primes up to a given number as that is more efficient than factoring each\
    \ prime individually.\n<code>", "  # Create a Hash to store the large prime factors\
    \ in.\n  factors = {}\n  # Check if n is prime and if so return the factor.\n\
    \  prime_check(n)\n  factors[n] = 1\n  # Now continue checking if n is not prime\
    \ by dividing n by each of the primes up to sqrt(n).\n  for i in 2..(Math.sqrt(n).to_i)\n\
    \    # Check if n is divisible by i.\n    if n % i == 0\n      # If so, store\
    \ i in the hash.\n      factors[i] = factors.has_key?(i) ? factors[i]+1 : 1 \n\
    \    end\n  end\n  # Return the largest prime factor.\n  return factors.max_by\
    \ {|k,v| v}[1]\nend\n</cell>\n<cell>\nlargest_prime_factor(5)\n</cell>\n<cell>\n\
    largest_prime_factor(100)\n</cell>\n<text>\nFactoring into smaller numbers", " \
    \ # Check whether n is a prime.\n  if n != 1 && n % 1 == 0\n    # Raise an error\
    \ if n is divisible by 2\n    raise \"This number is not a prime\"\n  end", " \
    \ primes = primes_list(n)\n  prime_max = primes.last\n  primes.shift\n  while\
    \ primes.any?\n    prime_max = [prime_max] + (primes.map {|n| n % prime_max} *\
    \ (prime_max / primes.last))\n    primes << prime_max\n  end\n  prime_max\nend",
  "  largest_prime_factor = 0\n  prime_divisor = 2\n  prime_factor = true", "  factors\
    \ = []\n  (2..(n/2)).each do |i|\n    prime = true\n    (3..i).each do |j|\n \
    \     prime = false if i**j <= n\n    end\n    factors << i if prime\n  end\n\
    \  factors\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is O(n^2), not O(n).\n\
    <|/ c |>\n<| c |>\nYes, you're right. I corrected it. I meant to say that it is\
    \ not the best way to solve this problem, but just an alternative for those who\
    \ want to implement their own.\n<|/ c |>\n<| a dscore=1 tags=ruby,primes |>\n\
    Since you asked for the Ruby way, I decided to implement the sieve of Eratosthenes\
    \ in Ruby:\n<code>", "  prime_max = n\n  2\n  break if n % prime_max\n  (2..n).each\
    \ do |prime|\n    prime_max = prime if n % prime == 0\n    break if prime_max\n\
    \  end\n  return prime_max\nend\n</cell>\n<cell>\nlargest_prime_factor(100)\n\
    </cell>\n<text>\nFactorial of 100 is notably uncommon. In the first 100 numbers,\
    \ how many numbers are greater than 100?", "  factors = []\n  for i in 2..n do\n\
    \    if n%i == 0\n      factors << i\n    end\n  end\n  if factors.size == 1\n\
    \    return factors[0]\n  else\n    factors.reduce(:*)\n  end\nend", "  # TODO:\
    \ implement the Sieve of Eratosthenes algorithm\n  return 0\nend\n</code>\nHere\
    \ is a sample run:\n<code>\n$ ruby -lrb big-primes.rb\nLoading development environment\
    \ (Rails 4.2)\n2.4.0 :001 > largest_prime_factor(37)\n => 2 \n2.4.0 :002 > largest_prime_factor(81)\n\
    \ => 7 \n2.4.0 :003 > largest_prime_factor(91)\n => 9 \n2.4.0 :004 > largest_prime_factor(101)\n\
    \ => 13 \n2.4.0 :005 > largest_prime_factor(201)\n => 21 \n2.4.0 :006 > largest_prime_factor(301)\n\
    \ => 31 \n2.4.0 :007 > largest_prime_factor(401)\n => 41 \n2.4.0 :008 > largest_prime_factor(501)\n\
    \ => 51 \n2.4.0 :009 > largest_prime_factor(601)\n => 61 \n2.4.0 :010 > largest_prime_factor(701)\n\
    \ => 71 \n2.4.0 :011 > largest_prime_factor(801)\n => 81 \n2.4.0 :012 > largest_prime_factor(901)\n\
    \ => 91 \n2.4.0 :013 > largest_prime_factor(1001)\n => 101 \n2.4.0 :014 > largest_prime_factor(2001)\n\
    \ => 201 \n2.4.0 :015 > largest_prime_factor(3001)\n => 301 \n2.4.0 :016 > largest_prime_factor(4001)\n\
    \ => 401 \n2.4.0 :017 > largest_prime_factor(5001)\n => 501 \n2.4.0 :018 > largest_prime_factor(6001)\n\
    \ => 601 \n2.4.0 :019 > largest_prime_factor(7001)\n => 701 \n2.4.0 :020 > largest_prime_factor(8001)\n\
    \ => 801 \n2.4.0 :021 > largest_prime_factor(9001)\n => 901 \n2.4.0 :022 > largest_prime_factor(10011)\n\
    \ => 101 \n2.4.0 :023 > largest_prime_factor(20011)\n => 201 \n2.4.0 :024 > largest_prime_factor(30011)\n\
    \ => 301 \n2.4.0 :025 > largest_prime_factor(400", "    i = 2\n    factors = []\n\
    \    while i <= n / 2\n        if n % i == 0\n            factors << i\n     \
    \       i += 2\n        else\n            i += 1\n    end\n    factors.sort!\n\
    \    factors[-1]\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe above answer worked\
    \ for me. I also found another way to do it by getting the first prime number\
    \ > n. Then if n is divisible by that prime number, then n is not prime and return\
    \ nil.\n<|/ c |>\n<| c |>\nGreat idea. Haven't thought of it this way. Thanks.\n\
    <|/ c |>\n<| a dscore=1 tags=algorithm,ruby |>\n<code>", "  primes = []\n  for\
    \ prime in 2..n\n    if primes.include?(prime)\n      next\n    end\n    primes\
    \ << prime\n  end\n  primes.max_by{|x| n % x}\nend", "  factors = prime_factors(n)\n\
    \  factors.reject! { |factor| n % factor == 0 }\n  factors.inject(:*)\nend", " \
    \ largest = 1\n  i = 2\n  while i*i <= n \n    if n%i == 0 \n      largest = i\n\
    \    i += 1\n  n\nend", "  return 3 unless n.even? and n.odd?\n  \n  # The largest\
    \ factor of n that's > 1 and has no divisors less than n.\n  factor = 1\n  \n\
    \  while n % factor == 0 and factor < n do\n    factor *= 2\n  end\n  \n  factor\n\
    end\n</cell>\n<cell>\nlargest_prime_factor(20)\n</cell>\n<text>\nExercise: Write\
    \ a function that returns a list of all prime factors of a given integer n, as\
    \ an array.", "  if n <= 2\n    return n\n  else\n    primes = [2..n]\n    factor\
    \ = 1\n    while factor * factor < primes.last\n      primes.delete_at(primes.last)\n\
    \      factor += 1\n    end\n    return factor\n  end\nend\n</code>\n<|/ a tags=primes,ruby\
    \ |>\n<| c |>\nI believe that Ruby has a built in function for this, called `prime?`.\
    \ It returns a boolean value of a given number prime.\n<|/ c |>\n<| c |>\nRuby\
    \ has `prime?`, but it's only efficient if you have lots of factors. As far as\
    \ I know, there's no faster way of finding the largest prime factor.\n<|/ c |>\n\
    <| c |>\nRuby has a built-in function `prime?`. I think that is what OP wants.\
    \ http://ruby-doc.org/core-1.9.3/Math.html#method-i-prime-3F\n<|/ c |>\n<| c |>\n\
    Ruby has `prime?`? Where did you see it? I only see `prime`. Where did you see\
    \ `prime?`? I only see `prime?`. I have no idea what you're talking about.\n<|/\
    \ c |>\n<| c |>\nOops, I guess I jumped the gun. The documentation says `If n\
    \ is negative or less than or equal to 1, then false is returned.` But apparently\
    \ not for `1`. The reason I was using `prime?` was because I was comparing it\
    \ with `!prime`. But this doesn't seem to be working. I'm confused at what you're\
    \ saying about `1` though. You're saying my approach is wrong. Can you explain\
    \ that?\n<|/ c |>\n<| a dscore=0 tags=primes,ruby |>\n<code>", "  m = n\n  i =\
    \ 1\n  while m > 0\n    m = m / 2\n    i += 1\n  end\n  return i\nend", "  \n\
    \  # If n is 1, then return 1.\n  return n if n == 1 else n % largest_prime_factor(n\
    \ / 2)\nend\n  ", "    # Write your code here.\n    if n == 0\n        1\n   \
    \ elsif n > 1\n        largest_prime_factor(n.div 2)\n    else\n        n\n  \
    \  end\nend\n</code>\n<|/ a tags=ruby,rubymine,primes |>\n<| c |>\nWhat does the\
    \ `elsif n > 1` do? What does the `elsif` accomplish? I feel like I'm missing\
    \ something but I can't see it.\n<|/ c |>\n<| c |>\n`if x > 1` is the same as\
    \ `if x > 0 && x < 1` so it will only be true if the value is not `0` or `1`,\
    \ thus skipping the `else`. The `elsif` block is only executed if the other condition\
    \ wasn't `true`. I find it more clear when not using an explicit `else`.\n<|/\
    \ c |>\n<| c |>\nYes, I realized that and changed my code accordingly. Thanks\
    \ for your help, though!\n<|/ c |>\n<| c |>\n`elsif x > 1` doesn't do the same\
    \ as `else x > 1`, it does `else x > 0 && x < 1`, since `0` evaluates to `false`\
    \ and `1` evaluates to `true`. So it would skip the `else` if the value was `0`.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  # Initialize max as 1\n  max = 1.0;\n\
    \  \n  # Loop for finding all the factors\n  until max > n\n    # Loop for checking\
    \ all factors of n\n    while n > 1\n      # If the current factor is greater\
    \ than max\n      if n % max == 0\n        # Update the max to n divided by that\
    \ factor\n        max = n / max;\n      # Else, if the current factor is less\
    \ than max\n      else\n        # Update the max to the product of max and the\
    \ current factor\n        max = max * max;\n      # Break the while loop\n   \
    \   end\n      # Break the while loop\n    end\n    # Return the max\n    max\n\
    \  end\nend", "    factor = 1\n    while n != 0\n        factor += 1\n       \
    \ if n % factor == 0\n            n = n / factor\n        else\n            break\n\
    \    end\n    return factor\nend\n</code>\nThe second method is much harder to\
    \ write for beginners (probably more advanced methods of programming will be required)\
    \ and can take more time to run than the first method, but is certainly more efficient\
    \ for large numbers (a prime factor is computed at most 4 times in the first method,\
    \ while in the second method it is computed up to 8 times).\n<|/ a |>\n<| c |>\n\
    You didn't mention the second method. :)\n<|/ c |>\n<| c |>\n: I did mention it\
    \ - although I didn't see it when I posted.\n<|/ c |>\n<| a dscore=2 tags=algorithm,primes\
    \ |>\nThe following is based on Eli Bendersky's \"Project Euler #3\"\n<code>",
  "  factors = []\n  if n.even?\n    factors << n\n  end\n  if n.odd?\n    factors\
    \ << 2\n  end\n  factors.each do |factor|\n    begin\n      n % factor\n    rescue\
    \ RangeError\n      next\n    end\n    return factor\n  end\nend\n</cell>\n<code\
    \ language=julia-1.5>\nlarge_prime_factor(10)\n</cell>\n<code language=julia-1.5>\n\
    large_prime_factor(15)\n</cell>\n<text>\nLet's find all prime factors and return\
    \ the largest one.", "  i = 2\n  while i * i <= n\n    i += 2\n  i\nend", "\t\
    p = 1\n\twhile n > p\n\t\tp += 2\n\tend\n\twhile p <= n\n\t\tn = n / p\n\t\tp\
    \ *= p\n\tend\n\twhile p < n\n\t\tp *= p\n\tend\n\treturn p\nend", "    primes\
    \ = primes_up_to_n(n)\n    factor = 1", "  sieve = [n] + [1]\n  while sieve.last\
    \ > 1\n    sieve.pop\n    sieve.last *=\n      sieve.inject(:+) / sieve.inject(:*)\n\
    \  end\n  sieve.last\nend\n</code>\n<|/ a |>\n<| c |>\nThis seems very elegant.\
    \ I think I understand most of it, but I'm confused by the line `primes = n.primes.first\
    \ - [n]` -- what exactly is happening here? Also, what does `.first` do?\n<|/\
    \ c |>\n<| c |>\nThe first line is building a list of primes starting from 2 to\
    \ (n / 2). Then, primes becomes the list of primes up to the first non-prime number.\
    \ (n.primes gives all the primes between 2 and n / 2, including 2 and n.) The\
    \ first line could also be: `primes = n.primes`. It's just one way to avoid needing\
    \ to check the numbers 0 to n twice.\n<|/ c |>\n<| c |>\nSorry, I was typing all\
    \ this in without testing it :) I added a version that builds primes up to n /\
    \ 2, but this may be less efficient.\n<|/ c |>\n<| c |>\nJust out of curiosity,\
    \ is there an advantage to using prime numbers?\n<|/ c |>\n<| c |>\n: Prime numbers\
    \ are just convenient. They are simple to write, and it allows the numbers to\
    \ be stored in memory in an array rather than having to call a function each time\
    \ you want to access the number. Also, if a number is prime, then it can't be\
    \ evenly divided by anything other than itself and 1. So, you can just test numbers\
    \ from 0 to n / 2 directly. Even more conveniently, if a number is prime, it can't\
    \ be evenly divided by any other number greater than itself. So you can just test\
    \ numbers from 1 to n / 2 and get all the numbers which are prime, and which are\
    \ composite. There are some small optimizations to this, but they are not important\
    \ in this case.\n<|/ c |>\n<| a tags=ruby,algorithm,ruby-on-rails |>\nThe code\
    \ below is a method I wrote in ruby a while back. It was meant to be a more efficient\
    \ version of what you were trying to do. Hope it helps! :)\n<code>", '  factors
    = []', "  primes = 2\n  factors = []\n  while primes < n\n    primes << 1\n  end\n\
    \  factors.push(primes)\n  factors.each do |prime|\n    if n % prime == 0\n  \
    \    factors.shift\n      factors.push(prime)\n      break\n    end\n  end\n \
    \ if factors.size <= 1\n    return n\n  end\n  prime = factors.shift\n  factors.each\
    \ do |factor|\n    prime = prime * factor\n  end\n  prime\nend", "  factors =\
    \ []\n  while n != 1\n    n /= 2\n    factors << n\n  end\n  factors.compact.max\n\
    end\n</code>\n<|/ a tags=ruby,primes |>\n<| c |>\nThis code was written as an\
    \ example of what would be the most efficient way to solve this problem, but it\
    \ doesn't actually work.\n<|/ c |>\n<| c |>\n, no, the code in the original question\
    \ doesn't work. It doesn't find the largest prime factor, which the code in the\
    \ question does. However, your answer shows a correct Ruby way to do this.\n<|/\
    \ c |>\n<| c |>\nIt's a good answer, but I don't believe it's correct. It doesn't\
    \ find the largest prime factor, which was the original question. I'll give you\
    \ a +1 if you fix that though.\n<|/ c |>\n<| c |>\nI upvoted this because it answers\
    \ the question \"what is the largest prime factor of a number\" and the OP's code\
    \ doesn't attempt to find the largest prime factor of the number. As such, I don't\
    \ think the answer is incorrect. Also, it is a lot more concise than my answer.\
    \ :)\n<|/ c |>\n<| c |>\nI agree with you about the efficiency of this code. I\
    \ thought that most of the time it would be a lot slower than the method I posted\
    \ here. But after a quick benchmark I saw that your algorithm is ~3 times faster\
    \ than mine even though it takes more lines of code. I'm still looking for an\
    \ algorithm that would have a significant efficiency gain though.\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>", "  n = n.to_i\n  i = 2\n  while i < n do\n    while\
    \ n % i == 0 do\n      n = n / i\n    end\n    i += 1\n  end\n  return n\nend",
  "  # Use a set for faster lookup.\n  factors = Set.new\n  factors << 2\n  # Start\
    \ with 2.\n  next_factor = 2\n  while factors.include? next_factor\n    next_factor\
    \ = 3 * next_factor\n    factors << next_factor\n  end\n  # Scan until we find\
    \ something > n, or we reach n.\n  while next_factor <= n do\n    next_factor\
    \ = 3 * next_factor\n    factors << next_factor\n  end\n  # Return the largest\
    \ factor found.\n  factors.find { |factor| factor > n ? false : true }\nend",
  "  n = n.to_i\n  if n == 1 \n    return 1\n  i = 1\n  while i <= n do\n    prime\
    \ = false\n    prime_factor = 1\n    while not prime\n      prime = n % i == 0\n\
    \      if prime\n        prime_factor = i\n      end\n      i += 1\n    end\n\
    \    return prime_factor\n  end\nend", "  if n < 2\n    return nil\n  else\n \
    \   primes = prime_numbers(n)\n    p =  primes.first\n    i = 2\n    while i <\
    \ n\n      p = primes.find_index { |a| a > i }\n      return p if p\n      i +=\
    \ 1\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThanks for the nice solution,\
    \ however the problem with that is that it's O(n^2) where I was hoping for O(n).\
    \ As I understand it, each iteration of the inner loop in the function largest_prime_factor\
    \ will take a large amount of time to run. That's why I wanted to do it iteratively.\n\
    <|/ c |>\n<| c |>\nThe `find_index` method makes it O(n).\n<|/ c |>\n<| c |>\n\
    Nice solution, but a while loop with `p += 1` would be more concise.\n<|/ c |>\n\
    <| c |>\n: Yes, that's much better than my loop.  Thanks for catching that!\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is a pure Ruby implementation.\n<code>", "  return\
    \ n if n % 2 == 0 && (n == 1 || n == 2) && ((n > 2) == is_prime?(n) ? true : false)\
    \ \n  else \n    n.to_s.chars.map(&:to_i).inject(:*)\nend", "\tfactors = factors(n)\n\
    \tfactors = factors.select(&:odd?)\n\tfactors.max_by { |f| f*f }\nend", "  if\
    \ n == 2\n    1\n  else\n    largest_prime_factor(n-1) * 3 + 1\n  end\nend", " \
    \ prime_factor = 1\n  while n > prime_factor\n    prime_factor = PrimeFactor(n)\
    \ # this returns the largest prime factor before n is raised to the power\n  \
    \  n /= prime_factor # this raises the largest prime factor to its power and removes\
    \ it from n\n  n\nend", "  factors = []\n  factor = 2\n  while n > 2\n    if n\
    \ % factor == 0\n      factors << factor\n      factor *= 2\n      n /= factor\n\
    \    else \n      factor += 1\n    end\n  end\n  factors << n if n % factor !=\
    \ 0\n  factors.reverse!\n  factors.first\nend", "  n\nend", "  candidate = 2\n\
    \  factor = 2\n  while (candidate < n)\n    if (n % candidate == 0)\n      factor\
    \ = candidate\n    else\n      candidate = candidate + 1\n  end\n  factor\nend\n\
    </cell>\n<cell>\nlargest_prime_factor(12)\n</cell>\n<cell>\nlargest_prime_factor(13)\n\
    </cell>\n<cell>", "  i = 2\n  while i <= n / 2\n    if n % i == 0\n      break\n\
    \    i += 1\n  end\n  return i\nend", "  largest_factor = 1\n  while n > largest_factor\n\
    \    largest_factor += 1\n    n /= largest_factor\n  end\n  largest_factor\nend",
  "  i = 1\n  factor = 1\n  while i <= n\n    if n % i == 0\n      factor *= i\n \
    \     break\n    i += 1\n  factor\nend", "  primes = []\n  for i in 2..n\n   \
    \ if primes.include?(i)\n      next\n    end\n    if n % i == 0\n      primes.push(i)\n\
    \      n /= i\n    end\n  end\n  return primes.last if n != 1\nend\n</code>\n\
    This function is more efficient because it does not need to perform any more expensive\
    \ tests for factorization, and it also does not perform any more expensive division\
    \ operations.\nThis approach is also very simple: just start with the largest\
    \ prime factor you can find in the first half of the range, then decrement until\
    \ you find an odd factor.\n<|/ a dscore=0 |>\n<| a |>\nHere is another option\
    \ that also works on ruby 1.8.7, but is very memory hungry:\n<code>", "    prime_fac=[]\n\
    \    i=2\n    while i<=n\n        prime_fac.push(i)\n        i=i+1\n    i=1\n\
    \    while i<n\n        prime_fac.push(i-1)\n        i=i+2\n    return prime_fac\n\
    end", "  return n if n.odd? || n == 1 || n == 2 || n % 2 == 0 || n % 3 == 0 ||\
    \ n % 5 == 0 ? n : \n            largest_prime_factor(n/3) * (n % 6 == 0 ? n//6\
    \ : largest_prime_factor(n % 6));\nend", "    if n > 1\n        prime_facs = [2,\
    \ 3]\n        while prime_facs.size < n\n            prime_facs += prime_facs_for(n)\n\
    \        return prime_facs[n]\n    end\n    return 2\nend", "  i = 2\n  factor\
    \ = 1\n  while i * i <= n\n    i += 1\n    factor = i\n  end\n  i\nend\n</code>\n\
    <|/ a dscore=0 tags=primes,prime-factoring,ruby |>\n<| c |>\nThis is more of a\
    \ comment than an answer, and it does not explain what was wrong in the original\
    \ code.\n<|/ c |>\n<| a tags=primes,prime-factoring,ruby |>\nThe first problem\
    \ with your code is that you are using the wrong variable when checking to see\
    \ if your number is a prime.\nA prime number is a number that only has factors\
    \ less than or equal to its square root.  You will notice that when iterating\
    \ over the factors of n, the last factor you see is equal to or greater than sqrt(n).\
    \  When you iterate over factors of n starting at 2, you will never be checking\
    \ whether a factor is a prime.  You also don't need a while loop here because\
    \ you only need to check factors up to sqrt(n).  Ruby makes this very easy by\
    \ providing you with a very handy method called prime?:\n<code>", "    prime =\
    \ 1\n    while n != 1 and prime < n do\n        n = n / prime\n        prime +=\
    \ 1\n    end\n    return prime\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis\
    \ is very inefficient, and fails for n = 2. For example, `largest_prime_factor(521)\
    \ == 11` but the correct answer is `13`\n<|/ c |>\n<| c |>\nGood catch, thank\
    \ you! The function was written by OP, and this was just an example of its inefficiency,\
    \ not any kind of practical application.\n<|/ c |>\n<| c |>\nYou're right. I was\
    \ thinking of how I might modify the function to fix it, so I checked if the function\
    \ always returns 2, and if it does, I made it return 1 instead. I'll update my\
    \ answer. Thank you for catching this.\n<|/ c |>\n<| a |>\nI know this question\
    \ was answered very well already, but just for reference:\nA simple way of doing\
    \ this (but probably not the fastest) would be to find the prime factorization\
    \ of a number and see if each one divides another until you hit a number greater\
    \ than 1.  \n<code>", "  factor = 1\n  while n != 1\n    if n % factor == 0\n\
    \      n = n / factor\n    else\n      factor++\n    end\n  end\n  factor\nend\n\
    </code>\n<|/ a tags=ruby,primes |>\n<| c |>\nIt seems like a lot of unnecessary\
    \ work for a program that could do it in just 5 lines with some clever math.\n\
    <|/ c |>\n<| c |>\n, good point, though this is more of an exercise in learning\
    \ about loops and recursion in ruby so I tried to do it in that way\n<|/ c |>\n\
    <| a |>\nYou could also use \n<code>", "  # Initialize a variable called \"i\"\
    \ and assign it the value 2\n  i= 2\n  # Repeat until the number \"i\" is less\
    \ than or equal to n\n  while i < n\n    # If the remainder of \"i\" is zero\n\
    \    if i % 2 == 0\n      # Assign the variable \"i\" the value of the expression\
    \ (i + 1)/2\n      i= (i + 1) /2\n      # If the remainder of \"i\" is still zero\n\
    \      while i % 2 == 0\n        # Assign the variable \"i\" the value of the\
    \ expression (i + 1)/2\n        i= (i + 1) /2\n      # Otherwise exit the loop\n\
    \    end\n    # Increment the variable \"i\"\n    i += 1\n  end\n  # Return the\
    \ variable \"i\"\n  return i\nend\n</code>\nNow that we know that it is safe to\
    \ use mathematical functions in Ruby, let's see how we can implement the solution\
    \ we were given (the one that finds the prime factors) using Ruby code.  \nFirst,\
    \ let's get the largest prime factor: \n<code>", "  largest_factor = 1\n  n.times\
    \ {\n    large_prime_factor <= n and n % large_prime_factor == 0 ? largest_factor\
    \ += large_prime_factor : nil\n  }\n  largest_factor\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis code is correct but inefficient. Try for n = 987654321000000000,\
    \ your function spits out 321. It's not clear from your post whether you want\
    \ an efficient solution or a fast one. By the way, I thought that your `largest_prime_factor`\
    \ function could be rewritten to `n.prime? ? n : largest_prime_factor(n)`.\n<|/\
    \ c |>\n<| c |>\nThe OP's question is not really about efficiency. This is actually\
    \ a good solution, although not as efficient as you'd like. You can use [this\
    \ approach](https://stackoverflow.com/a/10902765/5239030) to solve the efficiency\
    \ issue as well. I've edited my answer to include it.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  if n == 0\n    throw :exception, :nan_number\n  end\n  result\
    \ = 1\n  factors = prime_factors(n)\n  factors.each do |factor|\n    if factor\
    \ > result\n      result = factor\n    end\n  end\n  result\nend\n</pre>\n</div>",
  "    i = 2\n    factor = 1\n    while i <= n\n        if n % i == 0\n          \
    \  factor *= i\n            break\n        i += 1\n    return factor\nend\n</code>\n\
    And now we can implement the functions from earlier in this notebook:\n<code>",
  "  prime_numbers = []\n  while n != 1\n    prime_numbers << n\n    n = n / 2\n \
    \ end\n  prime_numbers.reduce(:*).to_i\nend", "  factors = []\n  (2..n).each do\
    \ |i|\n    factors.push(i) if i.remainder(n).zero?\n  end\n  factors.max_by{|i|\
    \ i}\nend", "  if n == 1 then return 1\n  i = 2\n  while i * i < n do\n    if\
    \ n % i == 0 then return i\n    i += 1\n  end\nend\n</code>\n<|/ a dscore=0 tags=ruby,primes,math\
    \ |>\n<| c |>\nOh my... I thought the ruby tag would apply to my question and\
    \ my question was tagged as ruby. Whoops. Also, thanks for the other answers.\n\
    <|/ c |>\n<| c |>\n: Ruby can do any number of things with your question. That's\
    \ a good thing.\n<|/ c |>\n<| a |>\nHere is the code I wrote in Python, which\
    \ is very efficient:\n<code>", "  prime_factor = 1\n  while n >= prime_factor\n\
    \    prime_factor = prime_factor + 1\n  end\n  return prime_factor\nend", "  candidate\
    \ = 2\n  i = 2\n  while i * candidate <= n\n    candidate = i * candidate\n  \
    \  i += 1\n  return candidate if n > 2 else 2\nend", "  return n if n <= 1 ||\
    \ !prime?(n) \n  n = next_prime(n) \n  loop do\n    if n % n == 0 \n      break\n\
    \    n /= n\n  end\n  n\nend\n</code>\nNext, we need to find primes up to n using\
    \ the sieve of Eratosthenes. A sieve is simply a list of prime numbers up to the\
    \ max number. Once we find our primes, we can return those that satisfy the conditions\
    \ we're looking for. (The other prime factors are simply the multiples of those\
    \ primes.)\n<code>", "  if n <= 1\n    n\n  else\n    largest_prime_factor(n.floor)\n\
    \  end\nend", "  if n == 1\n    1\n  elsif n % 2 == 0\n    largest_prime_factor(n\
    \ / 2)\n  else\n    largest_prime_factor(3 * n) + 1\n  end\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis is definitely a great answer, but I'd like to point\
    \ out that some optimizations are possible.  You don't need to check even numbers.\
    \  In fact, you only need to check odd numbers up to sqrt(n).  The largest prime\
    \ factor will be sqrt(n) if you start at 3 to begin with.  Also `largest_prime_factor`\
    \ should be an `if` and not an `elsif`, as far as I can tell.\n<|/ c |>\n<| c\
    \ |>\nI agree, except that in Project Euler, you only need to check up to sqrt(n),\
    \ but that doesn't mean your algorithm is correct, so I don't think it's worth\
    \ to edit your answer.\n<|/ c |>\n<| c |>\nI really like this solution, however\
    \ I think there are some small typos in the last line. `largest_prime_factor`\
    \ should be an `if`, not an `elsif`.\n<|/ c |>\n<| c |>\n: Fixed, thanks.\n<|/\
    \ c |>\n<| c |>\nHaha, no problem. I've edited my answer to reflect the change\
    \ you suggested.\n<|/ c |>\n<| a dscore=2 |>\nOne thing you could do to improve\
    \ your function is to start with a lower value than 2, since that would allow\
    \ you to avoid testing even numbers. \nThen you can use a loop to reduce the number\
    \ by 2 and test each subsequent number. \n<code>", "  sieve = [2, 3]\n  while\
    \ sieve.size < n \n    sieve.push sieve.shift.product sieve.shift.to_i\n  end",
  "  i = 2\n  while i*i <= n\n    i += 1\n  i -= 1\n  while i >= 0\n    if n % i ==\
    \ 0\n      return i\n    i -= 1\n  end\n  return n\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThe question is about finding the largest prime factor of *large* numbers.\
    \ Your code only finds the largest prime factor of *small* numbers.\n<|/ c |>\n\
    <| c |>\nAh, missed that. Updated the answer.\n<|/ c |>\n<| a dscore=2 |>\nI have\
    \ tried this solution too. But, It took too much time to find out the largest\
    \ prime factor.\n<code>", "  return nil if n.odd? or n.zero?\n  candidate = n.prime_division\
    \ do |i|\n    return n if i.prime? and i.quo(n).zero?\n  end\n  candidate = n\
    \ if candidate.prime? and candidate.quo(n).zero?\n  largest_prime_factor = candidate\n\
    \  while candidate.quo(largest_prime_factor) != 0\n    candidate = candidate.quo(largest_prime_factor)\n\
    \  end\n  largest_prime_factor\nend\n</code>\nThe above code takes advantage of\
    \ the prime_division method of the Integer class where it returns the prime factors\
    \ of an integer as a set, not an array as your program seems to do. So, you can\
    \ iterate through the factors of n by checking if n.prime_division includes the\
    \ current factor you iterate through. If yes, then you have found a factor. So,\
    \ you only need to check if the next factor is greater than the current factor\
    \ you checked or not, so you only need to check if n % current_factor == 0. This\
    \ is how you can check if n is prime, using O(1) memory and O(log(n)) time.\n\
    Now, on to the problem:\n<code>", "  nfactors = Array.new(8)\n  i = 1\n  while\
    \ i < n do\n    nfactors[i] = i\n    i = i * 2 + 1\n  end\n  nfactors.max_by{\
    \ |i| n % i }\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\n\"Nearly\"\
    \ is subjective. While it may not be correct in all cases, it is definitely not\
    \ incorrect in all cases. There are cases where this algorithm is faster. For\
    \ instance, the prime factors of 10**9 are much smaller than 10**9, so your algorithm\
    \ is guaranteed to run much faster than mine.\n<|/ c |>\n<| c |>\nYes, you're\
    \ right. It's just that when n is large and there are many prime factors, my algorithm\
    \ is faster. I'll edit my answer to say that. Thanks.\n<|/ c |>\n<| a dscore=3\
    \ tags=ruby,algorithm |>\nThis problem is not hard to solve.\nLet's begin with\
    \ the easy part: given that there are only three primes, that means that the problem\
    \ is pretty easy:\n<code>\n1. Find the highest number k that divides n", "  if\
    \ n % 2 == 0 then return 2\n  i = 2\n  while i * i <= n\n  do\n  i *= 2\n  end\
    \ \n  return i\nend", "  # Base case: n is a composite number.\n  if n == 1\n\
    \    1\n  # Recursive case: n is composite or has two factors.\n  else\n    #\
    \ Return the smaller of the two factors, and the greatest factor of n minus 1.\n\
    \    smaller_factor, largest_factor = max_prime_factor(n/2), n/2\n    # Find the\
    \ largest prime factor smaller than the smaller factor.\n    while smaller_factor\
    \ <= largest_factor\n      smaller_factor, largest_factor = max_prime_factor(largest_factor)\n\
    \    end\n    # Return the largest prime factor of the smaller factor.\n    smaller_factor\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,prime-factoring,factors dscore=1 |>\n<|\
    \ c |>\nWhat about the case that n is `2`?\n<|/ c |>\n<| c |>\nYou are right,\
    \ I have updated the answer to account for it.\n<|/ c |>\n<| a dscore=0 |>\nYou\
    \ want to find any prime number factors greater than or equal to n.\nYou want\
    \ to find the smallest prime number factor less than or equal to n.\nYou want\
    \ to find the largest prime number factor greater than or equal to n.\nI assumed\
    \ that you want to find the largest factor of the smallest factors of the prime\
    \ number factors of n.\n<code>", "    primes = primes_under(n)\n    prime = primes.first\
    \ if primes.size > 0 && (primes.first.to_i >= n) ", "  return prime_factors.max_by\
    \ { |p| p.prime? ? p.n : n }\nend\n</code>\n<|/ a |>\n<| c |>\nThis answer has\
    \ a flaw that makes it slow for large numbers. I suggest using [a more efficient\
    \ algorithm](https://en.wikipedia.org/wiki/Primality_test#Factoring_a_number_into_prime_numbers)\n\
    <|/ c |>\n<| a dscore=4 tags=ruby,primes |>\nPrimality test is a very slow test,\
    \ and in Ruby it is best to avoid it when possible since it is implemented in\
    \ a C extension (which may be written in C itself, or it may be written in C++).\n\
    The best and most efficient primality test is based on factoring - finding the\
    \ prime factors of a number, and then seeing if their product is prime. This can\
    \ be done in O(sqrt(n)) by doing (by Andrew Moore):", "  if n > 1\n    return\
    \ n\n  for i in 2..n\n    break if n % i == 0\n  end\n  i\nend", "  factors =\
    \ []\n  for i in 2..n\n    factors.push(n/i)\n  end\n  factors.sort!\n  factors.each\
    \ do |i|\n    return i if i > factors.last\n  end\n  return n\nend", "    factor\
    \ = 2\n    while factor * factor <= n and n % factor != 0\n        factor = factor\
    \ + 1\n    return factor\nend\n</cell>\n<code language=julia-1.5>\nlargest_prime_factor(1000)\n\
    </cell>\n<code language=julia-1.5>\nlargest_prime_factor(125)\n</cell>\n<text>\n\
    Prime Number Generators\nIn the previous chapter we used the Mersenne Twister\
    \ to generate random numbers. Here we show how to use the Mersenne Twister to\
    \ generate random primes.", "  factors = []\n  factor = 0\n  while n > 2\n   \
    \ factors = factors + [n/factor]\n    factor = n\n  end\n  factors\nend\n</cell>\n\
    <code language=julia-1.1>\nlargest_prime_factor(135)\n</cell>\n<text>\nLet's compare\
    \ our code to our previous code (where we used the @njit decorator) to see which\
    \ runs faster.", "  primes = prime_factors(n)\n  max_prime = primes.max\n  primes.delete(max_prime)\n\
    \  primes.each do |prime|\n    return prime if prime.is_prime? && prime < max_prime\n\
    \  end\n  return nil\nend\n</code>\nHere is a benchmark to show the efficiency\
    \ of using multiple sieves to solve this problem. \n<code>\nrequire 'prime'",
  "    prime = prime_array\n    n.to_i\n    prime_array = []\n    return n\nend",
  "  result = []\n  if n > 1 && !primal?(n)\n    primes = primes_up_to(m)\n    i =\
    \ 2\n    while i < primes.length\n      result = primes.take_while { |i| i ==\
    \ n }.take\n      i += 2\n    end\n  end\n  result\nend", "  if n == 1\n    1\n\
    \  else\n    largest_prime_factor(n/2).tap do |factor|\n      if n % factor ==\
    \ 0\n        factor\n      else\n        n\n      end\n    end\n  end\nend", " \
    \ lf = nil\n  for i in 2..n\n    if n % i == 0 then\n      lf = i\n      break\n\
    \    end\n  end\n  return lf\nend", "    if n < 2 then return nil\n    if n %\
    \ 2 == 0 then return 2\n    else return 3\n    end\nend\n</code>\n(Note that this\
    \ isn't actually an optimal solution, but I thought I would post it anyway so\
    \ that others wouldn't make the same mistake.)\nThe function largest_prime_factor()\
    \ returns the largest prime factor of n (not necessarily the largest prime factor).\n\
    The function largest_prime_factors() returns a list of all prime factors of n,\
    \ and each element in the list is a prime factor.\nThe function prime_factors()\
    \ returns a list of all the prime factors of n, and each element in the list is\
    \ a prime factor.\nThe function prime_factor(n) returns the prime factor of n,\
    \ or nil if n is prime.\nThe function prime_factor_of_list(l) returns the prime\
    \ factor of l, and nil if l is empty.\nThe function factors(n) returns a list\
    \ of the prime factors of n.\nTo check whether a number is prime, you can use\
    \ this:\n<code>", "  # Prime factors of 2 through n are 2 and n-1 -- i.e., 2 and\
    \ 3, and hence\n  # their factors are 2 and n-1.\n  factors = []\n  while n >\
    \ 2\n    factors << n\n    n /= n\n  end\n  factors << n\n  factors.uniq!\n  factors.compact.sort!\
    \ # Sort in increasing order\n  factors.first\nend", "  i = 2\n  largest_prime_factor\
    \ = 1", "    prime_candidates = 2..n\n    return prime_candidates.max { |prime|\
    \ is_prime?(prime) ? prime : nil }\nend", "  i = 2\n  factors = []\n  while (i\
    \ <= n / 2)\n    if (n % i == 0)\n      factors << i\n    i += 1\n  end\n  factors.sort!\n\
    \  factors[-1]\nend", "  factors = factors(n)\n  return factors[-1] if factors.size\
    \ > 1 else None\nend\n</code>\nAs I mentioned, this algorithm is O(N) which means\
    \ it only takes constant time to run. Although I should note that, by using the\
    \ sieve of Eratosthenes, it can take up O(log(N)) time.\n<code>", "  prime_divisors\
    \ = primes(n)\n  return prime_divisors.max { |a| n / a }\nend\n</code>\n<code>\n\
    >> largest_prime_factor(100)\n=> 14\n</code>\nThis solution is probably much slower\
    \ than a more naive algorithm. On my machine it takes about half a second to calculate\
    \ largest_prime_factor(100000000).\n<|/ a tags=ruby,primes dscore=0 |>\n<| a |>\n\
    Here's my solution:\n<code>", "    prime_fac = 2\n    while n > prime_fac\n  \
    \      prime_fac += 2\n    while prime_fac > 2\n        if prime_fac == 2 || prime_fac\
    \ == 3 || prime_fac == 5 || prime_fac == 7\n            return prime_fac\n   \
    \     prime_fac -= 2\n    return 2\nend", "  # Store all the primes less than\
    \ n.\n  primes = [nil]\n  # Check every number until prime-factors <= n <= 2n.\n\
    \  n.downto(2).each do |x|\n    # Check if x is a prime number greater than 1.\n\
    \    primes << (x if primes.any? {|p| p.prime? && p > x})\n  end\n  # Return the\
    \ largest prime factor of n.\n  primes.max_by(&:prime?)\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| a dscore=0 |>\nAs others have pointed out, it's impossible to find all\
    \ primes below a certain number in less than O(n) time, since there are O(n) primes\
    \ below a given number. This means it's impossible to find a prime in less than\
    \ O(n) time without enumerating all primes below a given number.\nHowever, it's\
    \ possible to check whether a number is prime in O(1) time, because we only need\
    \ to check whether it's a factor, not whether it's prime:\n<code>", "  if n <\
    \ 2 then return nil\n  if n == 2 then return 2\n  a = 1\n  while n > 2 do\n  \
    \  if n % a == 0 then\n      a = a / 2\n    else\n      a = a * 3 + 1\n    end\n\
    \    n /= a\n  end\n  return a\nend", "  return factors # Don't forget to put\
    \ the result of the function!\nend\n</code>\nAnd now our main program would look\
    \ like this:\n<code>", "    n = n - (n % 2 if n % 2 == 0 else 1)\n    (2..n-1).each\
    \ do |m|\n        if (n % m == 0)\n            return m\n        end\n    end\n\
    \    return n\nend", "    primes = [2, 3]\n    \n    until primes.count > n\n\
    \        primes.each do |prime|\n            if n % prime == 0\n             \
    \   primes.delete_at(primes.index(prime))\n            else\n                return\
    \ prime \n            end\n        end\n    end\n    return n\nend", "  return\
    \ 2\nend", "  primeFactors = primeFactorization.primeFactors(n)\n  largestPrimeFactor\
    \ = primeFactors.last\n  largestPrimeFactor = primeFactors[largestPrimeFactor.to_i-1]\n\
    \  return largestPrimeFactor\nend", "  if n % 2 == 0 && n > 2\n    largest_prime_factor(n\
    \ / 2)\n  else\n    n\n  end\nend", "  if n == 1 then return 1\n  else\n    i\
    \ = 2\n    while i * i <= n do\n      while n % i == 0 do\n        i ++\n    \
    \  end\n      if i == n then return n\n      end\n    end\n  end\nend", "    prime_factors\
    \ = []\n    i = 1\n    while n > 0\n        if n % i == 0\n            prime_factors.push(i)\n\
    \            i = i + 1\n        else\n            i = i + 1\n    end\n    return\
    \ prime_factors[prime_factors.length-1]\nend\n</cell>\n<code language=julia-1.5>\n\
    largest_prime_factor(10) # => 4\nlargest_prime_factor(11) # => 3\nlargest_prime_factor(100)\
    \ # => 2\nlargest_prime_factor(1000) # => 2\nlargest_prime_factor(9999999) # =>\
    \ 2\n</cell>\n<code language=julia-1.5>", "  if n == 1 then return 1\n  largest\
    \ = 1\n  i = 2\n  while i * i <= n do\n    if n % i == 0 then\n      if largest\
    \ * i <= i then return largest * i\n      largest = i\n    end\n    i = i + 1\n\
    \  end\n  largest\nend\n</code>\n<|/ a |>\n<| c |>\nThis was very helpful. Thanks\
    \ for your help!\n<|/ c |>\n<| a tags=ruby,primes,math dscore=2 |>\nFirst of all\
    \ you should learn about what is a prime number and its prime factors. Once you\
    \ understand that, here's how you can find out if a number is a prime number or\
    \ not:\n<code>", "  if n == 1 then return 2\n  if n == 2 then return 3\n  # If\
    \ we already know that the number is odd, then we know it's bigger\n  # than any\
    \ even factor, so we can skip the even factor check\n  if n % 2 == 1 then return\
    \ nil\n  # Otherwise, find the largest odd factor by dividing out all odd factors\n\
    \  # while checking for each factor if it's > 1.\n  odd_factors = []\n  while\
    \ n > 1\n    odd_factors.push(n / 2)\n    while n % 2 == 0\n      n /= 2\n   \
    \ end\n  end\n  odd_factors.reverse_each do |factor|\n    if factor > 1\n    \
    \  return factor\n    end\n  end\nend", "  factors = []\n  while n % 2 == 0\n\
    \    factors.push(2)\n    n /= 2\n  until factors.length == 1\n  return factors\n\
    end", "  primes = []\n  n2 = n\n  while n2 > 0\n    # Iterate through all primes\
    \ <= sqrt(n), appending them if they are prime.\n    # Note that this algorithm\
    \ requires O(sqrt(n)) time to run.\n    primes << 2 if n % 2 == 0\n    primes\
    \ << 3 if n % 3 == 0\n    primes << 5 if n % 5 == 0\n    primes << 7 if n % 7\
    \ == 0\n    primes << 11 if n % 11 == 0\n    primes << 13 if n % 13 == 0\n   \
    \ primes << 17 if n % 17 == 0\n    primes << 19 if n % 19 == 0\n    primes <<\
    \ 23 if n % 23 == 0\n    primes << 29 if n % 29 == 0\n    primes << 31 if n %\
    \ 31 == 0\n    primes << 37 if n % 37 == 0\n    primes << 43 if n % 43 == 0\n\
    \    primes << 47 if n % 47 == 0\n    primes << 53 if n % 53 == 0\n    primes\
    \ << 59 if n % 59 == 0\n    primes << 61 if n % 61 == 0\n    primes << 67 if n\
    \ % 67 == 0\n    primes << 71 if n % 71 == 0\n    primes << 79 if n % 79 == 0\n\
    \    primes << 81 if n % 81 == 0\n    primes << 87 if n % 87 == 0\n    primes\
    \ << 91 if n % 91 == 0\n    primes << 97 if n % 97 == 0\n    primes << 101 if\
    \ n % 101 == 0\n    primes << 107 if n % 107 == 0\n    primes << 111 if n % 111\
    \ == 0\n    primes << 117 if n % 117 == 0\n    primes << 121 if n % 121 == 0\n\
    \    primes << 127 if n % 127 == 0\n    primes << 131 if n % 131 == 0\n    primes\
    \ << 137 if n % 137 == 0\n    primes << 143 if n % 143 == 0\n    primes << 149\
    \ if n % 149 == 0\n    primes << 151 if n % 151 == 0\n    primes << 157 if n %\
    \ 157 == 0\n    primes << 163 if n % 163 == 0\n    primes << 169 if n % 169 ==\
    \ 0\n    primes << 171 if n % 171 == 0\n    primes << 177 if n % 177 == 0\n  \
    \  primes << 183 if n % 183 == 0\n    primes << 189 if n % 189 == 0\n    primes\
    \ << 191 if n % 191 == 0\n    primes << 197 if n % 197 == 0\n    primes << 203\
    \ if n % 20", "    return 2\nend", "  if n.even? \n    n / 2\n  elsif n.odd? \n\
    \    n\n  else\n    (2...n / 2).find do |prime|\n      n % prime == 0\n    end\n\
    \  end\nend\n</code>\n<code>", "    i = 2\n    prime_factors = []\n    prime_factors.push(2)\n\
    \    while i * i <= n\n        if n % i == 0\n            prime_factors.push(i)\n\
    \            n = n / i\n            i = 2\n        else\n            i += 1\n\
    \    end\n    prime_factors.push(n % i)\n    return prime_factors\nend\n</cell>\n\
    <code language=julia-1.5>\nlargest_prime_factor(19)\n</cell>\n<code language=julia-1.5>\n\
    largest_prime_factor(100)\n</cell>\n<text>\nExercise 4: Find the largest prime\
    \ factor of 13195", "  if n == 0\n    return 0\n  else\n    return n % largest_prime_factor(n/2)\n\
    \  end\nend", "  i = 2\n  while i * i <= n\n    i += 1\n  end", "  \n  # Loop\
    \ through each factor of n to find the largest.\n  factors = []\n  factor = 1\n\
    \  while factor * factor <= n\n    factors += factor\n    factor *= 2\n  factors\
    \ << n if factors == [n] # add n if it's prime\n  factors.max\nend\n</cell>\n\
    <code language=julia-1.6>\n@time largest_prime_factor(10000)\n</cell>\n<text>\n\
    Finding prime factors\nA fast prime factorization is based on the Sieve of Eratosthenes,\
    \ as proposed in Wikipedia [1].", "    return n <= 1 ? n : n % prime_fac\nend",
  "  factors = prime_factors(n)\n  factors.reverse!\n  factors.each do |f|\n    next\
    \ if f == 1\n    return f\n  end\nend", "    if n <= 1\n        n\n    else\n\
    \        p := 2 # Initialize p to 2\n        while p < n\n            if n % p\
    \ == 0\n                p := p + 2 # Update p to next potential prime\n      \
    \      else\n                break\n        end\n        p\n    end\nend\n</code>\n\
    Note that in Ruby all functions return a value, even if they don't do anything.\
    \  So the function returns nil if there are no prime factors found.\nThe next\
    \ function is an attempt to find the largest prime factor of a number.  I haven't\
    \ checked it to make sure it is correct or efficient but it's my best attempt\
    \ at the algorithm.  It returns a new array containing the largest prime factor\
    \ and the number of times it occurs.\n<code>", "    factors = []\n    i = 2\n\
    \    while i * i <= n\n        if n % i == 0\n            factors.push i\n   \
    \         n /= i\n        i += 1\n    if n == 1\n        factors.push 1\n    end\n\
    \    return factors\nend\n</cell>\n<code language=julia-1.5>\nlargest_prime_factor(10)\
    \ # => [3, 5]\nlargest_prime_factor(15) # => [3, 5, 7]\nlargest_prime_factor(11)\
    \ # => [3, 7, 11]\nlargest_prime_factor(17) # => [3, 5, 7, 11, 13]\nlargest_prime_factor(19)\
    \ # => [3, 5, 7, 11, 13, 17]\n</cell>\n<text>\nExercise: Find the first 10 numbers\
    \ of a Fibonacci sequence that are divisible by any number between 1 and 20",
  "  if n < 2\n    fail ArgumentError, \"#{n} must be > 1.\"\n  elsif n % 2 == 1\n\
    \    fail ArgumentError, \"#{n} must be odd.\"\n  else\n    i = 2\n    loop do\n\
    \      i = i * 2 if i % n == 0\n      break i if i == n\n    end\n  end\nend",
  "  return n==1 ? n : n % p % p\nend", "  largest = 1\n  factor = 2\n  while factor\
    \ * factor <= n\n    factor += 1\n    largest = factor\n  largest_prime_factor\
    \ = largest\nend", "  if n == 0\n    1\n  else\n    n = n/2 # integer division\n\
    \    largest_prime_factor(n) if n % 2 == 0\n      largest_prime_factor(n/2) if\
    \ n % 3 == 0\n        largest_prime_factor(n/3) if n % 5 == 0\n          largest_prime_factor(n/5)\
    \ # n is prime\n        end\n      end\n    end\n  end\nend", "  prime_factors\
    \ = nil\n  largest_prime_factor_so_far = nil", "  factor = 2\n  i = 2\n  while\
    \ i * factor <= n \n    factor = i * factor\n    i += 1\n  \n  return factor\n\
    end", "  if n <= 1\n    n\n  else\n    (n % 2 == 0) ? largest_prime_factor(n /\
    \ 2) : largest_prime_factor(3 * n + 1)\n  end\nend\n</cell>\n<code language=julia-1.0>\n\
    largest_prime_factor(100)\n</cell>\n<text>\nThe remainder of the code will remain\
    \ the same", "    i = 2\n    \n    while (i <= sqrt(n)) do\n        if (n % i\
    \ == 0) then\n            return i\n        end\n        \n        i = i + 2\n\
    \    end\n    \n    return n\nend", "    factor = 2\n    while n % factor != 0\n\
    \        factor = factor * 2\n    end\n    factor\nend\n</cell>\n<code language=julia-1.5>\n\
    largest_prime_factor(12)\n</cell>\n<code language=julia-1.5>\nlargest_prime_factor(10)\n\
    </cell>\n<code language=julia-1.5>", "  if n > 1 && (n % 2 == 0 || n % 3 == 0)\n\
    \    return 2\n  while n > 2\n    i = 2\n    while (i < n / 2 && n % i == 0)\n\
    \      i += 1\n    if i == n / 2\n      return n\n    n = i\n  end\n  i = 3\n\
    \  while (i < n / 3 && n % i == 0)\n    i += 1\n  if i == n / 3\n    return n\n\
    \  n\nend", "  largest = 1\n  factor = 2\n  while factor < n\n    factor = largest\
    \ += 2\n  end\n  factor\nend", "  i = 2\n  while i * i <= n\n    i += 1\n  i\n\
    end", "  i = 2\n  factors = []\n  while i <= n\n    factors << i\n    i += 2\n\
    \  end", "    primes = [2,3,5,7,11,13,17,19]\n    prime_candidate = 2\n    while\
    \ prime_candidate <= n\n        prime_candidate = primes.shift\n    end\n    return\
    \ prime_candidate\nend\n</cell>\n<code language=julia-0.6>\nlargest_prime_factor(1531)\n\
    </cell>\n<code language=julia-0.6>\nlargest_prime_factor(1532)\n</cell>\n<code\
    \ language=julia-0.6>\nlargest_prime_factor(1533)\n</cell>\n<code language=julia-0.6>\n\
    largest_prime_factor(1537)\n</cell>\n<code language=julia-0.6>\nlargest_prime_factor(1538)\n\
    </cell>\n<code language=julia-0.6>\nlargest_prime_factor(1539)\n</cell>\n<code\
    \ language=julia-0.6>\nlargest_prime_factor(1540)\n</cell>\n<code language=julia-0.6>\n\
    largest_prime_factor(1541)\n</cell>\n<code language=julia-0.6>\nlargest_prime_factor(1542)\n\
    </cell>\n<code language=julia-0.6>\nlargest_prime_factor(1543)\n</cell>\n<code\
    \ language=julia-0.6>\nlargest_prime_factor(1544)\n</cell>\n<code language=julia-0.6>\n\
    largest_prime_factor(1545)\n</cell>\n<code language=julia-0.6>\nlargest_prime_factor(1546)\n\
    </cell>\n<code language=julia-0.6>\nlargest_prime_factor(1548)\n</cell>\n<code\
    \ language=julia-0.6>\nlargest_prime_factor(1549)\n</cell>\n<code language=julia-0.6>\n\
    largest_prime_factor(1551)\n</cell>\n<code language=julia-0.6>\nlargest_prime_factor(1552)\n\
    </cell>\n<code language=julia-0.6>\nlargest_prime_factor(1553)\n</cell>\n<code\
    \ language=julia-0.6>\nlargest_prime_factor(1554)\n</cell>\n<code language=julia-0.6>\n\
    largest_prime_factor(1555)\n</cell>\n<code language=julia-0.6>\nlargest_prime_factor(1556)\n\
    </cell>\n<code language=julia-0.6>\nlargest_prime_factor(1557)\n</cell>\n<code\
    \ language=julia-0.6>\nlargest_prime_factor(1558)\n</cell>\n<code language=julia-0.6>\n\
    largest_prime_factor(1559)\n</cell>\n<code language=julia-0.6>\nlargest_prime_factor(1560)\n\
    </cell>", "    primes = prime_candidates(n)\n    max = nil\n    max = primes.max\n\
    \    primes.delete(max)\n    factors = primes.product(n-1)\n    factors.delete_if\
    \ {|f| f < max}\n    return factors\nend", "  if n.is_a? Integer\n    if n <=\
    \ 1\n      n\n    else\n      # n is odd\n      largest_prime_factor n / 2\n \
    \   else\n      # n is even\n      largest_prime_factor 3 * (n-1) + 1\n    end\n\
    \  else\n    largest_prime_factor n.to_i\n  end\nend", "  # Implement this function\
    \ in an iterative way.\nend", "  # Make n a safe integer\n  n = n.to_i\n  i =\
    \ 2\n  # Loop until we find one that isn't greater than n\n  while i * i <= n\n\
    \    # Try multiplying the number by i (up to n-1)\n    i += 1\n    factor = true\n\
    \    while factor\n      # If i is greater than n, it is not prime\n      if i\
    \ > n\n        factor = false\n        break\n      # If i is greater than n,\
    \ it is not prime\n      if i > n\n        factor = false\n        break\n   \
    \   # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # If i is greater than n, it is not prime\n  \
    \    if i > n\n        factor = false\n        break\n      # If i is greater\
    \ than n, it is not prime\n      if i > n\n        factor = false\n        break\n\
    \      # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # If i is greater than n, it is not prime\n  \
    \    if i > n\n        factor = false\n        break\n      # If i is greater\
    \ than n, it is not prime\n      if i > n\n        factor = false\n        break\n\
    \      # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # If i is greater than n, it is not prime\n  \
    \    if i > n\n        factor = false\n        break\n      # If i is greater\
    \ than n, it is not prime\n      if i > n\n        factor = false\n        break\n\
    \      # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # If i is greater than n, it is not prime\n  \
    \    if i > n\n        factor = false\n        break\n      # If i is greater\
    \ than n, it is not prime\n      if i > n\n        factor = false\n        break\n\
    \      # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # If i is greater than n, it is not prime\n  \
    \    if i > n\n        factor = false\n        break\n      # If i is greater\
    \ than n, it is not prime\n      if i > n\n        factor = false\n        break\n\
    \      # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # If i is greater than n, it is not prime\n  \
    \    if i > n\n        factor = false\n        break\n      # If i is greater\
    \ than n, it is not prime\n      if i > n\n        factor = false\n        break\n\
    \      # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # If i is greater than n, it is not prime\n  \
    \    if i > n\n        factor = false\n        break\n      # If i is greater\
    \ than n, it is not prime\n      if i > n\n        factor = false\n        break\n\
    \      # If i is greater than n, it is not prime\n      if i > n\n        factor\
    \ = false\n        break\n      # ", "  if n % 2 == 0 then\n    largest_prime_factor\
    \ = n / 2\n  else\n    largest_prime_factor = 3\n    largest_prime_factor = n\
    \ * largest_prime_factor\n  end", "  i = 2\n  factor = 1\n  while i * i <= n\n\
    \    factor *= i\n    i += 1\n  end\n  i\nend", "  a = n / 2\n  while a >= 2\n\
    \    a = a / 2\n    until a % 1 == 0\n  end\n  a\nend", "  i = 1\n  while i*i\
    \ <= n\n    i += 1\n  i\nend", "    return n if n <= 2 || n % 1 == 0 || n % 2\
    \ == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0 || n % 11 == 0 || n % 13 == 0\
    \ || n % 17 == 0 || n % 19 == 0 || n % 23 == 0 || n % 25 == 0 || n % 37 == 0 ||\
    \ n % 51 == 0 || n % 57 == 0 || n % 59 == 0 || n % 61 == 0 || n % 67 == 0 || n\
    \ % 71 == 0 || n % 73 == 0 || n % 89 == 0 || n % 97 == 1 || n % 101 == 1 || n\
    \ % 103 >= 3 || n % 105 == 0 || n % 107 == 0 || n % 109 == 0 || n % 113 >= 5 ||\
    \ n % 117 == 0 || n % 121 == 0 || n % 123 >= 7 || n % 125 >= 9 || n % 127 >= 11\
    \ || n % 129 >= 13 || n % 135 >= 17 || n % 137 >= 19 || n % 139 >= 23 || n % 143\
    \ >= 25 || n % 147 >= 29 || n % 149 >= 33 || n % 151 <= 37 || n % 153 >= 39 ||\
    \ n % 155 >= 43 || n % 157 >= 47 || n % 159 >= 51 || n % 163 >= 55 || n % 165\
    \ >= 59 || n % 167 >= 63 || n % 169 >= 67 || n % 173 >= 71 || n % 175 >= 75 ||\
    \ n % 177 >= 79 || n % 179 >= 83 || n % 181 <= 87 || n % 183 >= 89 || n % 185\
    \ == 100 || n % 187 <= 103 || n % 189 >= 105 || n % 191 <= 107 || n % 193 >= 109\
    \ || n % 195 >= 113 || n % 197 >= 117 || n % 199 >= 121 ||\n        n % 201 <=\
    \ 123 || n % 203 >= 125 || n % 205 == 128 || n % 207 >= 129 || n % 209 >= 131\
    \ || n % 211 >= 133 || n % 213 >= 135 || n % 215 >= 137 || n % 217 >= 139 ||\n\
    \        n % 219 >= 141 || n % 223 >= 143 || n % 225 >= 145 || n % 227 >= 147\
    \ || n % 229 >= 149 || n % 233 >= 151 || n % 235 >= 153 || n % 237 >= 155 || n\
    \ % 239 >= 157 || n % 241 <= 159 || n % 243 >= 161 || n % 245 >= 163 || n % 247\
    \ >= 165 || n % 249 >= 167 || n % 251 <= 169 || n % 253 >= 171 || n % 255 >= 173\
    \ || n % 257 == 175 || n % 259 == 177\n    end\nend", "  m = 2\n  while m <= n/m\n\
    \    m *= m\n  return m\nend", "  largest_prime = n # Initialize largest prime\
    \ to n\n  next_prime = 1\n  while next_prime < n\n    next_prime += 2 # Next prime\
    \ is one more than the next prime\n    next_prime %= n # Only go up to n squared,\
    \ since n cannot be evenly divided by 2\n    if next_prime > largest_prime\n \
    \     largest_prime = next_prime\n    end\n  end\n  return largest_prime\nend",
  "  while n > 1\n    factor =  n % 2\n    p =   n % factor\n    n = n / factor\n\
    \    if p == 0\n      return factor\n    end\n  end\nend", "  # Return the largest\
    \ prime factor of n.\n  if n == 1\n    1\n  elsif n % 2 == 0\n    n / 2\n  else\n\
    \    largest_prime_factor(n / 2)\n  end\nend", "  if n == 1 then return nil\n\
    \  if n % 2 == 0 then return 2\n  a = 3\n  while a <= n / 2 do\n    if n % a ==\
    \ 0 then return a\n    a = a + 2\n  end\n  nil\nend\n</code>\nThe above function\
    \ will return the largest prime factor of a number n which returns nil if n is\
    \ prime.  To improve this function further, you should consider factoring larger\
    \ numbers.\n<code>", "  primes = prime_factors(n)\n  primes.max_by { |p| p * p\
    \ }\nend\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThe sieve isn't necessary. Surely\
    \ you can just remove all the multiples of 3 or 5, for example.\n<|/ c |>\n<|\
    \ c |>\n, sure you can, but what is the point of doing the sieve if you can just\
    \ do `prime_numbers = 2 .. n-1` for the sieving?\n<|/ c |>\n<| c |>\nThe point\
    \ is that you can then do `prime_numbers.inject(:&)` rather than enumerating the\
    \ sieve explicitly. I'm not saying there's any need to do sieving at all. I'm\
    \ just saying you can do that in a much more concise way :)\n<|/ c |>\n<| c |>\n\
    : I didn't know that. Thanks for teaching me something new.\n<|/ c |>\n<| c |>\n\
    The sieve only needs to check numbers up to sqrt(n), but only numbers up to sqrt(n)\
    \ need to be checked.  All other numbers can be factored out as they are checked.\n\
    <|/ c |>\n<| a tags=ruby,primes dscore=4 |>\nIn Ruby there are several ways to\
    \ solve this problem. \nThe first one is to take advantage of Ruby's features\
    \ to create a generator of prime numbers:\n<code>\nprimes = 2 .. 100\n</code>\n\
    The second one is to simply use a recursive method:\n<code>", "  result = 0\n\
    \  while n > 1\n    if n % 2 == 0\n      result += 1\n      n /= 2\n    elsif\
    \ n % 3 == 0\n      result += 1\n      n /= 3\n    elsif n % 5 == 0\n      result\
    \ += 1\n      n /= 5\n    else\n      break\n    end\n  end\n  result\nend", " \
    \ factor = 1\n  i = 1\n  while i * i <= n\n    if n % i == 0\n      i += 1\n \
    \   else\n      factor += 1\n    end\n  end\n  return factor\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThe reason why `largest_prime_factor` is written that way is\
    \ to avoid the slow integer division that the `prime?` function uses by default.\n\
    <|/ c |>\n<| c |>\nThank you for pointing that out. I wasn't sure how it would\
    \ work without using the `prime?` method. I'll update my answer.\n<|/ c |>\n<|\
    \ a tags=ruby,primes |>\nI solved this in python with a recursive function which\
    \ basically tests every number up to and including n-1.  If n is prime it returns\
    \ n, otherwise it returns the largest prime factor of n and recurses down to n-1.\n\
    <|/ a dscore=0 |>\n<| c |>\nThe code you present above is incorrect.  A simple\
    \ test will show you that the number 1 is a prime number.  It is not clear what\
    \ you are doing here.\n<|/ c |>\n<| c |>\nNo, it doesn't test every number up\
    \ to and including n-1; it tests every number up to and including n. No number\
    \ is composite. An example of it being incorrect would be, for example, `largest_prime_factor(5)\
    \ == 3`.\n<|/ c |>\n<| c |>\nSorry I didn't mean to be confusing. I was trying\
    \ to say that in general one would have to test all numbers up to and including\
    \ n but here it is sufficient to test all numbers up to and including n-1. In\
    \ the case that the number is prime it returns it. If the number is composite\
    \ it recursively tests all the numbers up to and including n-1 and returns the\
    \ largest prime factor of n-1.\n<|/ c |>\n<| c |>\nSorry I didn't mean to be confusing.\
    \ I was trying to say that in general one would have to test all numbers up to\
    \ and including n but here it is sufficient to test all numbers up to and including\
    \ n-1. In the case that the number is prime it returns it. If the number is composite\
    \ it recursively tests all the numbers up to and including n-1 and returns the\
    \ largest prime factor of n-1.\n<|/ c |>\n<| c |>\nThank you for pointing that\
    \ out. I wasn't sure how it would work without using the `prime?` method. I'll\
    \ update my answer.\n<|/ c |>\n<| a tags=ruby,primes |>\nThe easiest approach\
    \ is to use the Sieve of Eratosthenes. It's an algorithm that does exactly what\
    \ you want, but takes much less time to implement than the nai", "    i = 2\n\
    \    while i * i <= n\n        i = i + 2\n    \n    return i\nend", "  i = 2\n\
    \  factor = nil\n  while true\n    prime = prime?(i)\n    if prime && i >= n /\
    \ factor\n      factor = i\n    end\n    return i if prime\n    i += 1\n  end\n\
    end\n</code>\n<|/ a |>\n<| a dscore=0 |>\nThis is a simple method of getting the\
    \ prime factors of an integer. First, we must check if a number is prime or not.\
    \ \n<code>", "  return n if n <= 3 else (n % 2 != 0 ? n / 2 : 3 * largest_prime_factor(n\
    \ / 2))\nend\n</code>\nThis should return you the largest prime factor of n.\n\
    <|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails |>\nHere is a Ruby program that\
    \ can do that :\n<code>\nrequire 'prime'", "  return n if n <= 1 \n  primes =\
    \ prime_factors(n)\n  largest = primes.last\n  p =  primes.take_while { |i| i\
    \ > largest }\n  largest, p if p.empty?\nend\n</cell>\n<cell>\nlargest_prime_factor(13)\n\
    </cell>\n<cell>\nlargest_prime_factor(102)\n</cell>\n<cell>\nlargest_prime_factor(9382)\n\
    </cell>\n<cell>", "  return 2 if n == 2\n  factors = []\n  i = 0\n  while n %\
    \ 2 == 0\n    i += 2\n    factors << 2\n    n = n / 2\n  end\n  while n>1\n  \
    \  i += 2\n    factors << 2\n    if n % i == 0\n      factors << i\n      n /=\
    \ i\n    end\n  end\n  if n > 1\n    factors << n\n  end\n  factors.reverse\n\
    end\n</code>\nAnd here's how you use it:\n<code>\n puts \"The largest prime factor\
    \ of #{n} is #{largest_prime_factor(n)}\"\n</code>\nHope that helps!\n<|/ a |>\n\
    <| c |>\n`i` should start at `2` instead of `1` and it should be `while n != 1`\n\
    <|/ c |>\n<| c |>\n: thanks, I didn't notice that at first. I will edit my answer.\n\
    <|/ c |>\n<| c |>\nSide note: it won't work for n=0 since it will return `nil`.\n\
    <|/ c |>\n<| c |>\n: thanks for catching that bug. I've fixed it now.\n<|/ c |>\n\
    <| a tags=ruby dscore=0 |>\n<code>", "    prime_candidates = prime_candidates(n)\n\
    \    candidate = prime_candidates.first\n    factor = 1\n    while (candidate\
    \ > 1)\n        factor *= candidate\n        candidate = prime_candidates.shift\n\
    \    return factor\nend", "  if n < 2\n    2\n  elsif n < 7\n    3\n  elsif n\
    \ < 15\n    5\n  elsif n < 31\n    7\n  elsif n < 63\n    11\n  elsif n < 127\n\
    \    13\n  else\n    n\n  end\nend\n</cell>\n<cell>\nlargest_prime_factor(122)\n\
    </cell>\n<cell>", "  max = 2 # Keep the largest\n  n.times do\n    break if (n\
    \ % max).zero?\n    max = max * 2\n  end\n  max\nend", "  i = 1\n  while i*i <=\
    \ n\n    i += 1\n  i = i-1\n  if n < i*i\n    return i\n  while n % i == 0\n \
    \   n /= i\n  i\nend", "  n.downto(2) do |prime|\n    return prime if n % prime\
    \ == 0\n  end\n  raise StopIteration\nend", "    i = 2\n    while i*i <= n\n \
    \       i += 1\n    return i\nend", "  i = 2\n  largest = i\n  while i * i <=\
    \ n\n    i += 1\n    next unless n % i == 0\n    largest = i if n > largest\n\
    \  end\n  largest\nend", "  if n<2 return 1\n  if n==2 return 2\n  if n%2 == 0\
    \ then return n\n  factors = []\n  prime = nil\n  loop do\n    prime += 1\n  \
    \  i = 2\n    loop do\n      i += 2\n      break unless n%i == 0\n    end\n  \
    \  factors << prime\n    break if prime > 2\n  end\n  factors\nend", "  primes\
    \ = []\n  i = 2\n  while i * i <= n\n    primes << i\n    i += 1\n  end\n  primes.each\
    \ do |prime|\n    break if n % prime == 0\n  end\n  if prime > n / prime\n   \
    \ return n\n  else\n    primes.reverse.find { |m| n % m == 0 }\n  end\nend", " \
    \ n = Math.ceil(n)\n  (1..n).each do |i|\n    return i if prime?(i)\n  end\n \
    \ 2\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,primes,factors dscore=1 |>\n\
    To find the factors of an integer, you can use prime factorization algorithm.\
    \ Here is an example:\n<code>", "  if n == 2 return n\n  i = 3\n  while i <= n\
    \ do\n    if n % i == 0 then return i\n    i += 2\n  end\nend", "  factors = primes(n)\n\
    \  factors.each_index { |i| break factors[i] }\nend\n</code>\n<|/ a dscore=1 tags=ruby,primes\
    \ |>\n<| a tags=ruby,primes |>\n<code>", "  if n == 1\n    puts \"1 is a prime\
    \ number.\"\n  elsif n < 2\n    puts \"%d is a not a prime number.\" % n\n  else\n\
    \    lf = 1\n    begin\n      lf = 2\n      while lf * lf <= n\n        lf +=\
    \ 1\n      end\n      n = n / lf\n    until n % lf\n    puts \"%d is a prime number.\"\
    \ % n\n  end\nend", "  i = 1\n  factor = nil\n  while i < n do\n    i += 1\n \
    \   factor = n / i\n    break unless prime? factor\n  end\n  factor\nend", " \
    \ loop do\n    f = 2\n    while f * f <= n\n      f = f * 2\n    end\n    break\
    \ f if f != n\n  end\nend", "    prime_divisors =  (1..n).to_a\n    largest =\
    \ 0\n    largest = prime_divisors.find { |i| prime_divisors.count(i) > largest\
    \ }\n    largest\nend\n</code>\nSo a more efficient way to solve this would be\n\
    <code>", "  if n.even?\n    next\n  elsif n.odd?\n    next\n  end\n  n = n.next",
  "  i = 2\n  isprime = true\n  while i <= n \n    if n % i == 0 \n      isprime =\
    \ false\n      break\n    i += 1\n  end\n  if isprime\n    i\n  else\n    largest_prime_factor(n-1)\n\
    \  end\nend\n</code>\n<|/ a dscore=0 tags=ruby,primes |>\n<| c |>\nPlease avoid\
    \ answering questions like this. The OP has asked for *help with his code, not\
    \ for others' solution*. Your answer should be a comment on the question.\n<|/\
    \ c |>\n<| c |>\n, please read the comments of other answers. The OP has asked\
    \ to help with the code. No need to be rude, just try helping him.\n<|/ c |>\n\
    <| c |>\nIf you have not read the comments then you have not read my answer. The\
    \ OP has asked for a specific help with his code. Your answer is a comment on\
    \ a specific question which does not require a full solution. Not that rude to\
    \ you.\n<|/ c |>\n<| c |>\n, I have read your comment and it seems that you are\
    \ not satisfied with my answer. The OP has asked to help with a code which has\
    \ been already given to them and they want you to help with their code. Maybe\
    \ I should have phrased my answer differently like \"Try helping someone to find\
    \ what you are looking for instead of answering the question like you did\".\n\
    <|/ c |>\n<| c |>\nWhat do you mean \"help with the code\"? The code they posted\
    \ is an infinite loop and it appears to be an attempt to implement a method that\
    \ returns prime factors iteratively. Your answer fails to address their actual\
    \ question: *What is the most efficient way of finding prime factors?* Your code\
    \ only attempts to do that. The actual question is: *What is the most efficient\
    \ way of finding prime factors?* Your code is not an attempt to do that. Your\
    \ code doesn't find prime factors at all.\n<|/ c |>\n<| a tags=ruby,primes |>\n\
    This code will work and will produce a hash of prime numbers as keys and their\
    \ factors as values. It does so by calculating the prime factorization of the\
    \ number, then seeing if it is a prime:\n<code>", "  largest_pf = 2\n  while n\
    \ > 1\n    if n % largest_pf == 0\n      largest_pf = largest_pf\n    else\n \
    \     largest_pf = largest_pf * 2\n    end\n    n = n / largest_pf\n  end\n  largest_pf\n\
    end\n</code>\nThere are still quite a lot ways to improve this. This one just\
    \ comes straight from the book.\n<|/ a tags=prime-factoring,ruby,ruby-on-rails,math,algorithm\
    \ |>\n<| c |>\nThanks, this was helpful.\n<|/ c |>\n<| c |>\nSurely your `prime_number`\
    \ method should start at `2` instead of `1`? Your `largest_prime_factor` method\
    \ could use [`#divmod`](https://ruby-doc.org/core-2.6.3/Numeric.html#method-i-divmod)\
    \ instead of `while n > 1`.\n<|/ c |>\n<| c |>\nGood points, I just copied the\
    \ code from the book. I'll fix that.\n<|/ c |>\n<| a tags=prime-factoring,ruby,ruby-on-rails,math,algorithm\
    \ |>\nThe answer is a bit late to the party, but this might be useful for those\
    \ who come across this question while reading through this question.\nThe code\
    \ provided is pretty elegant, but it has two problems:", "    i = 2\n    while\
    \ i * i <= n\n        i = i + 2\n    while n % i == 0\n        n = n / i\n   \
    \     \n    return i", "  largest_divisor = 2\n  largest_prime_divisor = 2\n \
    \ while largest_divisor < n\n    next if n % largest_divisor == 0\n    largest_divisor\
    \ = largest_divisor + 1\n  end\n  largest_prime_divisor = n\n  n\nend", "  factors\
    \ = prime_numbers(n)\n  factors.delete_if {|i| n < i}\n  return factors.last\n\
    end\n</code>\n<|/ a |>\n<| c |>\nIt should be noted that this is a very inefficient\
    \ algorithm for large primes since it uses sieve of eratosthenes.  A more efficient\
    \ way to find the largest prime factor of a number `n` is to just try all the\
    \ primes up to `n` and count how many times you've found a factor greater than\
    \ `n`.\n<|/ c |>\n<| a tags=primes,ruby,math,algorithm |>\nI've written a Ruby\
    \ prime number generator here: https://gist.github.com/mattras/8951611\nThis works\
    \ by generating all primes below sqrt(n), then selecting all factors up to sqrt(n)\
    \ that are also primes.\nFor an even number n, it just selects n itself.\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 tags=primes,ruby,math,algorithm |>\n<code>", " \
    \ factors = 1\n  while n > 1 && factors < n\n    factors = n%factors\n    n =\
    \ n / factors\n  end\n  factors\nend\n</code>\nI then call it on all prime numbers\
    \ between 2 and 10 to find the largest prime factor.\n<code>", "  return n if\
    \ n <= 1 || !prime?(n) \n  \n  # Get the prime factorization of n (a Hash mapping\
    \ primes to their multiplicities)\n  prime_factors = factors(n)\n  \n  # Get the\
    \ greatest prime factor from the factorization of n\n  greatest_prime_factor =\
    \ prime_factors.max_by {|k, v| v.first}\n  \n  # Return the largest prime factor\
    \ of n multiplied by the greatest prime factor\n  n.times {|i| n *= greatest_prime_factor.first}\n\
    \  n\nend", "\tprimes = Array.new\n\tprimes << 2", "  raise \"n must be greater\
    \ than 1.\" unless n > 1\n  raise \"n must be prime.\" unless prime?(n)\n  factors\
    \ = prime_factors(n)\n  factors.delete_if do |factor|\n    factor > n / factor\n\
    \  end.max\nend\n</code>\nAs the others mentioned, this does not take into account\
    \ the possible duplicates in the prime_factors method (as in, a number could be\
    \ prime and factor out a number for which it is not a prime).\n<|/ a tags=primes,algorithm,math,ruby\
    \ |>\n<| a tags=primes,algorithm,math,ruby |>\n<code>", "  i = 2\n  while i <=\
    \ n do\n    if n % i == 0\n      return n\n    i += 1\n  end\n  return n\nend\n\
    </cell>\n<cell>\nlarge_prime_factors(20)\n</cell>\n<text>\nSieve of Eratosthenes",
  "  # n is a prime.\n  return n"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
