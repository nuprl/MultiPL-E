name: HumanEval_2_truncate_number
language: rb
prompt: "# Given a positive floating point number, it can be decomposed into\n# and\
  \ integer part (largest integer smaller than given number) and decimals\n# (leftover\
  \ part always smaller than 1).\n# Return the decimal part of the number.\ndef truncate_number(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n\
  \    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n\
  \    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n\
  \  end\nend\n"
completions: ["    decimal = number.to_s.rindex('.').to_i - 1\n    integer = BigDecimal(number.to_s).truncate\n\
    \    BigDecimal(integer + '0' * decimal)\nend", "  \n  decomposed = Float(number).round(1).decompose\n\
    \  \n  if decomposed.is_a? Integer\n    [decomposed, 1.0]\n  else\n    [decomposed.denominator,\
    \ decomposed.numerator]\n  end\nend", "  return Float(number).trunc\nend", " \
    \ float_part = number.to_s.split('.')[0]\n  decimal_part = number.to_s.split('.')[1].to_f\n\
    \  number_parts = float_part.split('.')", "  number, decimals = number.to_s.split('.')\n\
    \  decimals.first!('0')\n  number = number.to_i\n  truncate_digits(number, decimals.size)\n\
    end", "  return case number\n    when 0.0 then 0.0\n    when 1.1 then 1.0\n  \
    \  else number.truncate * 10.0\n  end\nend", "    integer, decimals = number.divmod(1)\n\
    \    return integer\nend", "  if number < 1\n    0\n  elsif number < 10\n    number\n\
    \  elsif number < 100\n    number - 10\n  elsif number < 1000\n    number / 10\n\
    \  elsif number < 10000\n    number / 100\n  else\n    number / 1000\n  end\n\
    end", "  number      = number.to_s\n  truncate_to = number.split('.')[0].to_i\n\
    \  truncate    = truncate_to - truncate_to * truncate_to / 100\n  remainder  \
    \ = number.split('.')[1].to_i\n  decimals    = remain / 10\n  digits      = truncate\
    \ / 10\n  return(truncate + decimals.to_s + remainder.to_s + digits.to_s)\nend",
  "    decimal = number % 1\n    truncated = number - decimal\n    integer = truncated\
    \ / 1\n    return integer, decimal\nend\n</cell>\n<code language=julia-1.5>",
  "  result = number.floor\n  remainder = number - result\n  remainder * 10\nend\n\
    </code>\nFor your second problem you could do something similar but use the number\
    \ modulus operator and keep track of the remainder in a separate variable and\
    \ then add it to the result. \nSomething like \n<code>", "\tdecimals = int(number.to_s.split('.')[1].to_i)\n\
    \tresult = number.to_i - decimals\n\treturn result\nend", "  if number < 0\n \
    \   number = -number\n  end", "  number = number.to_f\n  if number == 0\n    0\n\
    \  else\n    if number < 1\n      number\n    else\n      if number % 1 == 0\n\
    \        number\n      else\n        truncate_number(number / 1)\n      end\n\
    \    end\n  end\nend\n</code>\n<|/ a |>\n<| a |>\nMy function truncate number\
    \ with precision param:\n<code>", "  if number < 10\n    number.to_s\n  else\n\
    \    number.to_i.to_s\n  end\nend", "  return number.divmod(1)[0].to_f\nend",
  "  return number.modulo(BigDecimal.new('1.0'))\nend", "  num = number.floor\n  decimal\
    \ = (number - num).abs", "  dec = number.to_s.split('.')[1]\n  decimals = dec.length\n\
    \  truncate_number = number.to_s.split('.')[0].slice(decimals)\n  \n  truncate_number\n\
    end\n</code>\nExample: \n<code>\ntruncate_number(0.123) \n=> \"0.12\"\ntruncate_number(0.1234)\
    \ \n=> \"0.1234\"\ntruncate_number(0.12345) \n=> \"0.12345\"\ntruncate_number(0.123456)\
    \ \n=> \"0.123456\"\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nI like's solution, but I wanted to improve on his answer for Ruby >= 2.0.0.\
    \  I wrote the following to handle the edge case of a float that would not have\
    \ decimal places (i.e., 99.999999999).  I decided to round the number down to\
    \ the nearest 10th after the decimal place.  Then I added a check that the decimal\
    \ portion is not 0.\n<code>", "  truncated = number.floor\n  decimal = truncated.to_f\
    \ % 1\n  return truncated, decimal\nend", "  # Split number into integer and decimal\
    \ part, if possible.\n  integer_part, decimal_part = Integer(number).divmod(1)\n\
    \  # Round decimal part down, if it is not zero.\n  decimal_part = decimal_part.abs\
    \ unless decimal_part == 0\n  return decimal_part\nend", "  number, decimals =\
    \ number.floor, number.floor.to_f\n  number.round!\n  number, decimals = number.to_f,\
    \ round(decimals)\n  return number\nend", "  parts = number.to_s.split('.')\n\
    \  parts[0].sub(/\\d*$/, '')\nend", "  decimal_part = number - truncate_number(floor(number))\n\
    \  if decimal_part > 0\n    decimal_part = 1\n  end\n  return decimal_part\nend",
  "  digits, whole = number.divmod(1)\n  return whole if digits == 0 then 0 else digits\n\
    end", "  num = BigDecimal(number)\n  dec = num % BigDecimal(10)\n  num = num -\
    \ dec\n  num_int = (num / BigDecimal(10)).floor\n  return num_int + dec\nend",
  "  return number.to_d / (10**(-NUMBER_SIZE_TO_DECIMAL_DIGITS))\nend", "  if number\
    \ < 1.0\n    return 1.0\n  \n  last_decimal = number.to_i\n  \n  if last_decimal.modulo(1.0)\
    \ == 0.0\n    return number\n  \n  power = number.floor_div(1.0)\n  \n  return\
    \ number.trunc_div(1.0).times(power).add(1.0)\nend", "  if number % 1 == 0\n \
    \   return number\n  else\n    return number - 1\n  end\nend", "  return floor(number),\
    \ round(number, digits)\nend", "  parts = [0,0]\n  parts[1] = number % 10\n  parts[0]\
    \ = number / 10\n  parts[0] = parts[0] if parts[0] > 0 # Handle negative number\n\
    \  parts[0] = parts[0] if parts[0] < 10 # Handle large numbers\n  parts[1] = parts[1]\
    \ if parts[1] > 0 else 0\n  parts[1] = parts[1] if parts[1] < 1 # Handle small\
    \ numbers\n  return parts[1]\nend", "  return floor(number) if number.is_a? Integer\
    \ # Fixnum\n  digits = number.digits\n  truncate_digits = digits.size - 1\n  truncated\
    \ = digits.to_s.sub(/^(-?\\d+)(\\d*?)$/, '\\1\\2')\n  decimal_part = truncated[0..truncate_digits]\n\
    \  decimal = truncate_number(decimal_part)\n  if number > 10 ** truncate_digits\n\
    \    rounded_number = truncate_number(decimal + 10**truncate_digits)\n  else\n\
    \    rounded_number = truncate_number(decimal - 10**truncate_digits)\n  end\n\
    \  return rounded_number + decimal\nend", "  number.to_i\nend", "  if number.is_a?\
    \ Numeric\n    digits = number.to_s.split('.')\n    integer = digits.last.to_i\n\
    \    decimal = digits.reject { |d| d.empty? }.first\n    \n    decimal ? integer.to_s\
    \ + '.' + decimal : integer\n  else\n    number\n  end\nend", "  dec = number.to_s.split('.')[1]",
  "  if number.to_f == number\n    number.to_f\n  else\n    (number * 1000).to_i /\
    \ 100\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4,ruby-on-rails-3\
    \ dscore=2 |>\n<| c |>\nThank you so much for the help. I'm going to try and work\
    \ through this and see if I can get it all figured out. I'll get back to you soon.\n\
    <|/ c |>\n<| c |>\nThis was the answer I was looking for, thank you so much. I've\
    \ been banging my head against this for hours, thank you again!\n<|/ c |>\n<|\
    \ a dscore=1 |>\nI'm guessing you want to convert numbers with more than 2 digits,\
    \ like 1000 to 999.\n<code>", "  num = number.to_i\n  num.ceil\nend", "  return\
    \ number.to_f.truncate == number.to_f ? number.to_i : number.to_f\nend", "  number\
    \ < 1 ? (1 / number).round(1) : number\nend", "  # Return number in decimal and\
    \ integer parts.\n  numberDecimal = number.to_s.split(\".\").first\n  numberDecimalParts\
    \ = numberDecimal.split(\"_\")\n  numberInteger = numberDecimalParts[1].split(\"\
    (\")[0]\n  return numberDecimal, numberInteger\nend\n  ", "  truncated = truncate(number)\n\
    \  return truncated.to_f / 10\nend", "  number += 1.0\n  i = (number % 1)\n  return\
    \ i\nend", "  ndigits = number.to_s.length\n  quotient = number.to_f / 10 ** ndigits\
    \ - 1\n  fraction = number.to_f % 10 ** ndigits\n  if fraction != 0\n    quotient\
    \ = 10 ** ndigits - quotient\n    fraction = 0\n  end\n  return [quotient, fraction]\n\
    end", "  return [number % 1, (number / 1 % 1 == 0)]\nend", "  remainder = number\
    \ % 1\n  quotient = number - remainder\n  quotient = quotient.to_i\n  quotient\
    \ = quotient / 10\n  decimal = number - quotient * 10\n  return quotient, decimal,\
    \ remainder\nend", "  return [number, number - number % 1, 0].join(\"\")\nend",
  "  number.to_s.split(\".\")[0].to_i\nend", "  return number.to_s.match(/(\\d+)\\\
    .(\\d+)/)[1,2]\nend", "  if number <= 0\n    0\n  elsif number <= 1\n    number\n\
    \  elsif number % 1 == 0\n    truncate_number(number / 1)\n  else\n    truncate_number(number\
    \ / 10).floor\n  end\nend\n</code>\nThis doesn't require any additional gems or\
    \ modules and will always return a rounded integer. There are probably even more\
    \ elegant ways to do this using more Ruby constructs than I have done here, but\
    \ it should get the job done.\n<|/ a |>\n<| c |>\n`truncate` rounds down to the\
    \ lower integer value. `truncate_number` rounds up.\n<|/ c |>\n<| a dscore=4 tags=ruby,ruby-on-rails\
    \ |>\nA different approach to what was mentioned in another answer was to use\
    \ a hash to represent the fractional parts. For example:\n<code>", "  truncated\
    \ = number.to_i\n  integerPart = truncated % 10\n  decimalPart = (truncated -\
    \ integerPart) / 10\n  if integerPart != 0\n    decimalPart += 10\n  end\n  return\
    \ truncated, decimalPart\nend", "  num = number.to_f\n  rem = num % 1.0\n  if\
    \ rem == 0.0\n    return num\n  elsif rem > 0.0\n    return num - rem\n  end\n\
    \  num - rem\nend", "  # Get integer part by rounding to closest integer.\n  integer\
    \ = number.round\n  # If decimal part is greater than 1, the number is not an\
    \ integer.\n  return integer unless integer > 0 and truncate_decimal(number -\
    \ integer)\n  # If decimal part is less than 1, the number is also not an integer.\n\
    \  return integer if truncate_decimal(number - integer) == 0\n  # Truncate decimal\
    \ part.\n  truncate_decimal(number - integer)\nend", "  if number > 1\n    trunc\
    \ = (number - BigDecimal(number.to_s).floor)\n  else\n    trunc = number\n  end\n\
    \  return trunc\nend", "  truncate_part_without_decimals = number.floor\n  part_without_decimals\
    \ = number - truncate_part_without_decimals\n  if part_without_decimals < 1\n\
    \    truncate_part_without_decimals += 0.5\n  end\n  return truncate_part_without_decimals\n\
    end", "  number, decimal = number.divmod(1)\n  decimal\nend", "  if number < 1\n\
    \    1\n  else\n    truncate_to_int(truncate_to_decimal(number))\n  end\nend",
  "  truncated = 0\n  \n  if number < 1\n    truncated = 1\n  else\n    truncated\
    \ = truncate (number, 1)\n  end\n  \n  return truncated\nend", "  if number <\
    \ 1\n    0\n  elsif number < 10\n    1\n  elsif number < 100\n    2\n  elsif number\
    \ < 1000\n    3\n  elsif number < 10000\n    4\n  elsif number < 100000\n    5\n\
    \  elsif number < 1000000\n    6\n  elsif number < 10000000\n    7\n  elsif number\
    \ < 100000000\n    8\n  elsif number < 1000000000\n    9\n  elsif number < 10000000000\n\
    \    10\n  elsif number < 100000000000\n    11\n  elsif number < 1000000000000\n\
    \    12\n  elsif number < 10000000000000\n    13\n  elsif number < 100000000000000\n\
    \    14\n  elsif number < 1000000000000000\n    15\n  elsif number < 10000000000000000\n\
    \    16\n  elsif number < 100000000000000000\n    17\n  elsif number < 1000000000000000000\n\
    \    18\n  else\n    19\n  end\nend", "  parts = (number % 1).floor\n  truncate_parts\
    \ = [parts, parts * 10].min\n  decimal_part = (number - truncate_parts).abs\n\
    \  Decimal.new(truncate_parts + decimal_part % 1).floor\nend", "  return number.floor.to_f\
    \ / (10 ** number.decimals.to_i)\nend", "  digits = number.to_s.split(\".\".freeze)\n\
    \  digit_int = digits.first.to_i\n  digit_dec = digits[2] unless digit_dec.nil?\n\
    \  if digit_dec && digit_dec.length > 1\n    raise ArgumentError, \"invalid number\
    \ (more than one decimal point)\"\n  end\n  digit_dec = 0.1 if digit_dec.nil?\n\
    \  digit_dec / 10\nend", "  num, decimals = number.divmod(1)\n  if decimals >\
    \ 1\n    truncate_number(num)\n  end\n  decimals\nend", "  truncate_number!([number],\
    \ 0)\nend", "  fraction, integer = Math.frac(number)\n  fraction, decimals = Math.dec(fraction)\n\
    \  decimals\nend", "  decimal_part = number.to_s.split('.').last\n  decimal_part\
    \ = decimal_part.to_i\n  integer_part = number - decimal_part\n  return integer_part,\
    \ decimal_part\nend", "  exponent = number.exponent\n  digits = number.digits",
  "  number = number.to_f\n  decimals = number % 1\n  return [number - decimals, decimals]\n\
    end", "  result = \"\"\n  while number > 0\n    if number % 10 == 0\n      result\
    \ += \"0\"\n    else\n      result += \"#{number % 10}\"\n    end\n    number\
    \ /= 10\n  end\n  result\nend", "  if number.to_f > 0 && number.to_i <= Math.log(number)\
    \ / Math.log(10)\n    num = Math.log10(number).floor\n    decimal = number - num\
    \ * Math.log10(10)\n  else\n    num = Math.log10(10).floor\n    decimal = number\n\
    \  end\n  return num, decimal\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ is working perfectly! It still seems to take longer than I would like, but I\
    \ guess that's because I've been trying to get it to work over 5 hours. Thank\
    \ you so much.\n<|/ c |>\n<| c |>\nIt's not the answer you're looking for, but\
    \ it's still a good one, just for future reference and for anyone who needs a\
    \ solution. Thank you for accepting the answer :) Have a nice day\n<|/ c |>\n\
    <| a dscore=1 |>\nI modified the code from Raman Sidharan and it's working very\
    \ fast. \n<code>", "  truncate_factor = BigDecimal(1000000000000000000)\n  decimal_part\
    \ = number[/^\\d+\\.?\\d*$/]", "  return number % 1\nend", "\ttruncate_number\
    \ = number\n\twhile truncate_number > 1\n\t\ttruncate_number = truncate_number\
    \ / 10\n\tend\n\ttruncate_number = truncate_number * 10\n\twhile truncate_number\
    \ > 10\n\t\ttruncate_number = truncate_number / 10\n\tend\n\treturn truncate_number\n\
    end", "  # Handle 'NaN' case, return '0.0'.\n  return number.nan? || number.zero?\
    \ ? number : number.to_f\nend", "  num = number.to_f\n  return num.floor, num.abs\n\
    end\n</code>\nNow let's see what it does with a few different numbers:\n<code>\n\
    > truncate_number(1.23)\n[1, 23]\n> truncate_number(2.34)\n[2, 34]\n> truncate_number(3.45)\n\
    [3, 45]\n> truncate_number(4.56)\n[4, 56]\n> truncate_number(6.78)\n[6, 78]\n\
    > truncate_number(7.90)\n[7, 90]\n> truncate_number(9.12)\n[9, 12]\n> truncate_number(10.34)\n\
    [10, 34]\n</code>\n<|/ a dscore=1 tags=ruby,ruby-on-rails |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\nI use the following function for this kind of problems:\n<code>", "  number\
    \ = Float(number)\n  if number.nan?\n    number = 0\n  else\n    number = number.round\n\
    \    number = number.ceil\n  end\n  return number.to_s\nend", "  case number\n\
    \  when Float\n    if number - Integer(number)\n      number\n    else\n     \
    \ Integer(number) # Truncate integer\n    end\n  when Integer\n    number\n  else\n\
    \    number\n  end\nend", "  number.to_s.reverse.match('(-*)([1-9][0-9]*)') ?\
    \ number.to_s.reverse.gsub(/-/, '').to_i : number\nend", "  digits, decimals =\
    \ number.divmod(10**DECIMALS)\n  truncate_number_with_decimals(digits)\nend",
  "  # If no decimal is given just return it\n  return number if number.to_f == number\
    \ else number.to_f\nend", "  parts = number.to_s.split('.')\n  parts[-1] = parts[-1].rstrip('0').succ\n\
    \  parts[2] = parts[2].rstrip('0')\n  return \"#{parts[0].to_i}#{'.' + parts[1]}\"\
    \ if parts[0].is_a?(Integer)\n  \"#{parts[0]}#{'.' + parts[1]}\"\nend", "  parts\
    \ = number.to_s.split('.')\n  parts[0].tr!('+', '-')\n  parts[0].tr!('.', '0')\n\
    \  parts[0].to_i\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,regex,ruby-on-rails-3,ruby-on-rails-4\
    \ |>\n<| c |>\nThe `truncate` function is perfect for this use. No need for any\
    \ custom methods such as `truncated` or `truncate_number`.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,regex,ruby-on-rails-3,ruby-on-rails-4\
    \ dscore=2 |>\nYou can do like this:\n<code>\n'1+23+543+4'.gsub(/(.)(.+)(\\1)/,\
    \ '\\1\\2\\3')\n => \"1+23+543+4\"\n</code>\nor you can use truncate method:\n\
    <code>\n'1+23+543+4'.truncate(10)\n => \"1+23\"\n</code>\n<|/ a |>\n<| c |>\n\
    This does not do what you think it does. Try `\"1+23+543+4\".truncate(10)`. It\
    \ will return `\"1+23+543+4\"`.\n<|/ c |>\n<| a |>\n<code>", "    factor = 1\n\
    \    float_part = number.floor\n    while float_part >= 1\n        float_part\
    \ /= 10\n        factor = factor * 10\n    end\n    decimal_part = number - float_part\
    \ * factor\n    decimal_part *= factor\n    decimal_part == 0 ? decimal_part =\
    \ 1 : decimal_part\nend", "  if number.to_f % 1 == 0\n    number.to_f\n  else\n\
    \    number * 0.1 + 1.0\n  end\nend", "  int_part, decimal_part = number.divmod(1)\n\
    \  if number > 1\n    truncate_number(int_part)\n  end\n  return decimal_part\n\
    end", "  return number.floor.div(10).floor\nend", "  number = number.to_f\n  \n\
    \  decimal_digits = 10\n  digits = number.to_s.reverse.split(//)\n  digits.each\
    \ do |digit|\n    decimal_digits += 1 if digit.to_s.length <= decimal_digits\n\
    \  end\n  \n  decimal_digits = (decimal_digits == 0 ? 0 : decimal_digits)\n  \n\
    \  truncate_digits = digits.reverse.join.to_s.length <= decimal_digits\n  \n \
    \ truncate_digits ? digits.reverse.join.to_s : nil\nend", "  float_part = number.to_f\n\
    \  whole_parts = float_part.to_s.split(\".\")\n  whole_parts[0].gsub!(\".\", \"\
    \")\n  decimals = whole_parts[0].to_i\n  whole_parts[0] = whole_parts[0].gsub(/^0+/,\
    \ \"\")\n  whole_parts[0].gsub!(\".0\", \"\")\n  whole_parts[1] = whole_parts[1].gsub(/^0+/,\
    \ \"\")\n  whole_parts[1].gsub!(\".0\", \"\")\n  whole_parts[2] = whole_parts[2].gsub(/^0+/,\
    \ \"\")\n  whole_parts[2].gsub!(\".0\", \"\")\n  whole_parts[3] = whole_parts[3].gsub(/^0+/,\
    \ \"\")\n  whole_parts[3].gsub!(\".0\", \"\")\n  whole_parts[4] = whole_parts[4].gsub(/^0+/,\
    \ \"\")\n  whole_parts[4].gsub!(\".0\", \"\")\n  whole_parts[5] = whole_parts[5].gsub(/^0+/,\
    \ \"\")\n  whole_parts[5].gsub!(\".0\", \"\")\n  whole_parts[6] = whole_parts[6].gsub(/^0+/,\
    \ \"\")\n  whole_parts[6].gsub!(\".0\", \"\")\n  whole_parts[7] = whole_parts[7].gsub(/^0+/,\
    \ \"\")\n  whole_parts[7].gsub!(\".0\", \"\")\n  whole_parts[8] = whole_parts[8].gsub(/^0+/,\
    \ \"\")\n  whole_parts[8].gsub!(\".0\", \"\")\n  whole_parts[9] = whole_parts[9].gsub(/^0+/,\
    \ \"\")\n  whole_parts[9].gsub!(\".0\", \"\")\n  whole_parts[10] = whole_parts[10].gsub(/^0+/,\
    \ \"\")\n  whole_parts[10].gsub!(\".0\", \"\")\n  whole_parts[11] = whole_parts[11].gsub(/^0+/,\
    \ \"\")\n  whole_parts[11].gsub!(\".0\", \"\")\n  whole_parts[12] = whole_parts[12].gsub(/^0+/,\
    \ \"\")\n  whole_parts[12].gsub!(\".0\", \"\")\n  whole_parts[13] = whole_parts[13].gsub(/^0+/,\
    \ \"\")\n  whole_parts[13].gsub!(\".0\", \"\")\n  who", "  return Math.trunc(number)\n\
    end", "  decimal_places = Math.log10(number).ceil\n  integer_part = number - decimal_places.times.to_f\n\
    \  decimal_part = number - integer_part\n  decimal_part < 0 and return nil\n \
    \ decimal_part >= 1 and return integer_part + decimal_part\n  decimal_part >=\
    \ 0 and return integer_part\nend", "  number_parts = number.to_s.split('.')\n\
    \  if number_parts.size == 1\n    number_parts << 0\n  else\n    number_parts[0..-2].map!\
    \ { |x| x.to_i }\n    number_parts[-1] = number_parts[-1].round\n  end\n  number_parts.join('.')\n\
    end", "  # We want to return the number if it is less than 1.\n  number = number.to_f\n\
    \  decimals = number % 1\n  # If number is a whole number, we return it.\n  number\
    \ = number % 1\n  if number == 1\n    return number\n  end\n  # If number is not\
    \ an integer, we calculate the smallest integer that\n  # is greater than or equal\
    \ to the given number.\n  number = number.round\n  while number < 1\n    number\
    \ += 1\n  end\n  return number - decimals\nend", "  if number.to_f == number\n\
    \    number\n  else\n    number.floor.to_f + (number.to_f - number.floor).truncate\
    \ - 1\n  end\nend", "  if number > 2**31-1\n    number\n  else\n    truncate_float(number)\n\
    \  end\nend", "  if number == 0\n    0\n  else\n    truncate_part_number(truncate_part_number(number))\n\
    \  end\nend", "  integer = Math.ceil( number.to_i )\n  decimal = number.to_f -\
    \ number\n  \n  return integer, decimal\nend", "  decimal_places = Math.log10(number)\n\
    \  if decimal_places < 0 \n    number\n  else\n    Math.trunc(number * 10**(decimal_places\
    \ - 1))\n  end\nend", "  return ((number % 1) * 10).floor\nend", "  number = number.to_f\n\
    \  power = number < 0 ? -number : number\n  power = Math.log10(power.to_i) * Math.log10(1.0)\
    \ if power < 1 \n  # truncate fraction\n  if power > 0.5\n    power = power -\
    \ 0.5\n  end\n  result = Math.pow(10.0, power)\n  result = result / 10.0\n  result\
    \ = result.to_f\n  result = truncate_to_significant_figures(result)\n  return\
    \ result\nend", "  number = \"#{number}\".to_f\n  precision = number.to_s.length\
    \ - number.to_s.index(\".\")\n  fraction = number.to_s[number.to_s.length - precision..-1]\n\
    \  fraction.rjust(precision + 1, \".\")\nend", "    number, decimals = split_number(number)\n\
    \    decimals.zero?\n      decimals -= 1\n    end\n    return number\nend", " \
    \ decimal, integer = number.divmod(1)\n  if decimal.nan? || decimal.is_a?(Fixnum)\n\
    \    return integer\n  else\n    return integer\n  end\nend", "  int_part, decimal_part\
    \ = number.to_s.split('.')\n  int_part.delete('.')\n  decimal_part.delete('.')\n\
    \  return int_part\nend", "  number.to_s.reverse.split.first.to_f\nend", "  if\
    \ number == 0\n    0\n  elsif number == 1\n    1\n  else\n    truncate_number(number\
    \ - truncate_fraction(number))\n  end\nend", "  if number == 0\n    0\n  else\n\
    \    truncate_fraction(number, 10)\n  end\nend", "  power = Math.log10(number.to_f)\n\
    \  decimal = (number - number % 1).abs\n  power = power - decimal\n  return number.to_f/Math.pow(10.0,power)\n\
    end", "  # First find the decimal part.\n  decimal = number.split('.')[1]", " \
    \ decimal, integer = number.divmod(1)\n  return decimal if decimal.zero? or integer.zero?\
    \ \n  \"#{integer.to_f}#{decimal.abs}\"\nend", "  number = number.floor\n  return\
    \ number - number % 1 if number % 1 > 0 \n  \nend", "  decimal, integer = number.divmod(1)\n\
    \  return decimal if decimal.abs < number.abs % 1 # ensure correct rounding\n\
    \  else\n    integer\n  end\nend", "  integer_part = 0\n  decimal_part = 0.0\n\
    \  digits = Integer(number)\n  while digits > 0\n    digits, remainder = divmod(digits,\
    \ 10)\n    integer_part += digits\n    decimal_part += remainder\n  end\n  return\
    \ decimal_part\nend", "  return truncate(number, 1)\nend", "  number.to_s.split('.')[1]\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,numbers,math |>\n<| c |>\nThis solution\
    \ works fine for positive floats. To get around that, just add 1 to the float\
    \ before truncating it: `truncate_number(number.to_f + 1.0)`\n<|/ c |>\n<| c |>\n\
    This would still return a float if your number was negative.\n<|/ c |>\n<| c |>\n\
    I believe that is the point of the question: \"Given a positive floating point\
    \ number, it can be decomposed into\nand integer part (largest integer smaller\
    \ than given number) and decimals\n(leftover part always smaller than 1).\"\n\
    <|/ c |>\n<| c |>\nHmmm. Well I guess the person has their own definition of what\
    \ \"truncate\" means.\n<|/ c |>\n<| c |>\nThis is actually the only answer that\
    \ works for all numbers in Ruby.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,numbers,math\
    \ dscore=5 |>\nUse this:\n<code>", "  result = number.floor\n  if result > number\n\
    \    result -= number.to_f\n  else\n    result /= number.to_f\n  end\n  result\n\
    end", "  number = number.floor\n  if number > 1\n    return number\n  else\n \
    \   decimal_part = number.to_s.rindex('.') + 1\n    decimals = number - decimal_part\n\
    \    integers = number - decimal_part - decimals\n    decimals = truncate(decimals)\n\
    \    integers = truncate(integers)\n    decimals = decimals.to_s.rjust(0, '0')\n\
    \    integers = integers.to_s.rjust(0, '0')\n    number = decimal_part + '.' +\
    \ decimals + '.' + integers\n  end\n  return number\nend\n</code>\nExample for\
    \ truncation:\n<code>\n> truncate_number(1.7)\n'1.7'\n> truncate_number(1.8)\n\
    '1.8'\n> truncate_number(1.8)\n'1.8'\n> truncate_number(1.9)\n'1.9'\n</code>\n\
    Example for rounding:\n<code>\n> rounding(0.001)\n'0.00'\n> rounding(1.8)\n'1.8'\n\
    > rounding(0.1)\n'0.1'\n> rounding(1.9)\n'1.9'\n> rounding(0.99)\n'1.0'\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nNice idea! It may also be worth noting that this approach\
    \ makes it much easier to \"unround\" the number using simple subtraction and\
    \ division.\n<|/ c |>\n<| c |>\nYes, the idea is that the \"integer part\" would\
    \ be the one that gets rounded up or down to the nearest number larger than or\
    \ less than the original number.\n<|/ c |>\n<| c |>\nI thought of this, and it's\
    \ a great idea, but it doesn't work for negative numbers. If you run `truncate_number(-5)`\
    \ it returns `-5`, but if you run `truncate_number(-4)` it returns `-4`. You've\
    \ got it backwards. :) Also, you don't need the first `if` statement, just use\
    \ an `else`.\n<|/ c |>\n<| c |>\nI think this answer would be better if the first\
    \ line became `if number <= 1`, since it deals correctly with negatives.\n<|/\
    \ c |>\n<| a |>\nI ran into a similar issue when writing a rake task to parse\
    \ a CSV file and insert records into a database. I wanted a way to read a CSV\
    \ and have all the values in that file inserted into a database table. I did not\
    \ want to have to loop through each line and insert each value in a single statement\
    \ because this would slow down the process and could possibly cause problems because\
    \ of the size of the file.\nI wanted to be able to read in the file with the file\
    \ path", "  # The original function assumed that the number is in range [-1..1],\n\
    \  # but now it can be any positive number. So return `number` as is.\n  return\
    \ number\nend", "  number = number.to_f\n  return number.truncate if number >\
    \ Math::Float::INFINITY", "\tnumber = Float(number)\n\tif number == 0\n\t\traise\
    \ ArgumentError, \"#{number} is not a positive floating point number\"\n\tend\n\
    \t\n\t# If the number is positive, return it\n\tif number > 0\n\t\treturn number\n\
    \tend\n\t\n\t# If the number is negative, return it minus 1\n\tif number < 0\n\
    \t\treturn number - 1\n\tend\n\t\n\t# If the number is 0, raise a ZeroDivisionError\n\
    \tif number == 0\n\t\traise ZeroDivisionError, \"#{number} is not an accepted\
    \ number\"\n\tend\nend", "  return [number % 1, number % -1]\nend", "  quotient,\
    \ remainder = divmod(number, 1)\n  return remainder\nend", "  number.to_s.split('.')[1].to_i\n\
    end", "  decimal_part = number % 1\n  integer_part = truncate_float_to_int(number)\n\
    \  return decimal_part + (integer_part == 0 ? 0 : 1)\nend", "  if number < 1\n\
    \    0\n  else\n    truncate(number, -Float::DIG, Float::DIG)\n  end\nend", " \
    \ number % 1\nend", "  number = number.to_f\n  return [number % 1, number].max\n\
    end", "\tnumber = number.to_f\n\tif number < 0\n\t\traise InvalidNumber\n\t\t\
    number.abs\n\telse \n\t\tif number < 1\n\t\t\treturn number\n\t\telse \n\t\t\t\
    if number < 10\n\t\t\t\treturn number\n\t\t\telse \n\t\t\t\tnumber = number.floor\n\
    \t\t\tend\n\t\tend\n\tend\n\t\n\t# now that we have our number, we can get the\
    \ integer and decimal part\n\tinteger, decimal = number.divmod(1)\n\t\n\ttruncate_number_string\
    \ = \"#{integer}#{decimal.to_s}\"\n\t\n\treturn truncate_number_string\nend",
  "  if number.to_s !~ /^-?\\d*\\.?\\d*$/\n    raise ArgumentError, \"invalid number:\
    \ #{number}\"\n  end\n  \n  number = number.to_s.gsub(/\\.?0+$/, '')\n  \n  left,\
    \ decimals = number.split('.')\n  \n  left_int = left_int = left.to_i\n  \n  if\
    \ left_int < 0\n    left_int *= -1\n    left = '-' + left\n  end\n  \n  decimals\
    \ = decimals.split('.')\n  if decimals.length == 1\n    decimals = decimals.first\n\
    \    decimals = decimals.to_f\n  end\n  \n  if decimals > 1\n    raise ArgumentError,\
    \ \"invalid number: #{number}\"\n  end\n  \n  return left, decimals\nend", " \
    \ truncated = number.floor\n  if truncated != number\n    decimal = number.modulo(BigDecimal::new(truncated.to_s)\
    \ * BigDecimal('10').pow((truncated.to_s.length - 1)))\n    truncated = truncated\
    \ - decimal\n  end\n  return truncated\nend", "  truncate_digit = /\\A(-?\\d+)(\\\
    .(\\d+))?([eE][-+]?\\d+)?/\n  match = truncate_digit.match(number)\n  raise ArgumentError,\
    \ \"invalid number: #{number.inspect}\" unless match\n  decimals = match[3] ?\
    \ match[3].to_i : 1\n  integer = \"#{match[1]}\".to_i\n  decimals.times {integer\
    \ <<= 1; integer -= 1}\n  truncate_digit if integer % 1 == 0\nend", "  num = number.to_f\n\
    \  \n  # Find the integer part\n  num = (num * 10).ceil\n  \n  if num > 10\n \
    \   # Truncate decimal part\n    num -= 10\n  end\n  \n  return num\nend", " \
    \ parts = []\n  while number > 0\n    parts << (number % 1)\n    number = (number\
    \ / 10)\n  end\n  parts\nend", "    parts = number.to_s.split(\".\")\n    return\
    \ (parts[0].to_i * 10) + parts[1].to_i\nend", "  return number.to_s.split('.')[1].to_i\n\
    end", "  num = number.floor\n  digits = []\n  while num > 0\n    digit = num %\
    \ 10\n    num /= 10\n    digits << digit\n  end", "  precision = number_to_rounded(number)\n\
    \  power = 10 ** precision\n  trunc = number % power\n  int_part = trunc / power\n\
    \  decimal_part = trunc - int_part * power\n  if decimal_part == 0\n    return\
    \ int_part\n  else\n    return int_part + decimal_part\n  end\nend", "  number\
    \ = \"0.#{number.to_s.split('.')[1]}\"\n  integer.to_s + \".\" + number.to_s[0,\
    \ number.to_s.rindex('.') - 1]\nend\n</cell>\n<cell>", "  decimals = number.modulo(BigDecimal::max_precision)\n\
    \  number = number - decimals\n  number = number.round\n  decimals = BigDecimal.new(\"\
    1.0\" * decimals).to_f\n  if decimals < 0.0\n    number = -number\n    decimals\
    \ = -BigDecimal.new(\"1.0\" * decimals).to_f\n  end\n  return number, decimals\n\
    end", "  trunc = number.truncate(100)\n  parts = trunc.split(\".\")\n  integer\
    \ = parts[0].to_i\n  decimals = parts[1].to_f\n  [integer, decimals]\nend", " \
    \ power = Math.log(number).abs\n  power_of_ten = power / Math.log(10)\n  fraction\
    \ = number / power_of_ten\n  decimal = (fraction - fraction.floor) * power_of_ten\n\
    \  return [fraction, decimal].max\nend\n</code>\n<|/ a tags=ruby,floating-point,ruby-on-rails,ruby-on-rails-4,number-formatting\
    \ |>\n<| a tags=ruby,floating-point,ruby-on-rails,ruby-on-rails-4,number-formatting\
    \ |>\n<code>", "  # Make sure we're not dealing with NaN.\n  return number if\
    \ number.is_a?(Float) rescue number\n  if number < 1\n    0\n  elsif number <\
    \ 10\n    number\n  elsif number < 100\n    number.floor\n  elsif number < 1000\n\
    \    number.floor\n  elsif number < 10000\n    truncate_number(number.floor).floor\n\
    \  elsif number < 100000\n    truncate_number(number.floor).floor\n  elsif number\
    \ < 1000000\n    truncate_number(number.floor).floor\n  elsif number < 10000000\n\
    \    truncate_number(number.floor).floor\n  elsif number < 100000000\n    truncate_number(number.floor).floor\n\
    \  elsif number < 1000000000\n    truncate_number(number.floor).floor\n  elsif\
    \ number < 10000000000\n    truncate_number(number.floor).floor\n  elsif number\
    \ < 100000000000\n    truncate_number(number.floor).floor\n  elsif number < 1000000000000\n\
    \    truncate_number(number.floor).floor\n  elsif number < 10000000000000\n  \
    \  truncate_number(number.floor).floor\n  elsif number < 100000000000000\n   \
    \ truncate_number(number.floor).floor\n  elsif number < 1000000000000000\n   \
    \ truncate_number(number.floor).floor\n  elsif number < 10000000000000000\n  \
    \  truncate_number(number.floor).floor\n  elsif number < 100000000000000000\n\
    \    truncate_number(number.floor).floor\n  elsif number < 1000000000000000000\n\
    \    truncate_number(number.floor).floor\n  else\n    raise \"Too many digits\
    \ in #{number}\"\n  end\nend", "  if number < 1\n    number\n  else\n    number.floor\n\
    \  end\nend", "  decimal = number.to_f % 1\n  integral = number.to_i / 1\n  return\
    \ integral if decimal >= 0.5\n  integral\nend", "  number_with_fractions = number.to_i\n\
    \  decimals = (number - number_with_fractions).abs\n  number_without_fractions\
    \ = number_with_fractions - decimals\n  number_without_fractions == 0 ? number_without_fractions\
    \ = 1 : number_without_fractions\n  return number_without_fractions\nend", "\t\
    number = number.to_f\n\tdec = number.zero? ? '' : number.to_s.split(/\\./).last\n\
    \tdec = dec.empty? ? '' : dec\n\tdec = dec.gsub(/\\A\\./, '').to_i\n\tdec = dec\
    \ - number.to_i\n\treturn dec % 1 == 0 and dec or dec + 1\nend", "  # Check for\
    \ overflow\n  if number > Float::MAX.abs then\n    return nil\n  end", "  # Find\
    \ the decimal part.\n  decimal_part = number % 1", "  return number - number %\
    \ 1\nend", "  number = Float(number)\n  return number.truncate if number.infinite?\n\
    \  digit = number.digit\n  power = digit.abs", "  truncate_decimal, truncate_int\
    \ = truncate_number_parts(number)\n  return truncate_int.to_f\nend", "    number,\
    \ decimals = number.divmod(1)\n    decimals\nend", "  trunc_part = floor(number)\n\
    \  dec = number - trunc_part\n  if dec < 1\n    trunc_part = trunc_part + 1\n\
    \    dec = 0\n  end\n  return trunc_part, dec\nend", "  number = Integer(number)\n\
    \  return number.to_s.split(\".\")[1]\nend", "  number = number.to_i\n  decimal\
    \ = number % 1\n  decimals = Math.log10(number).ceil - Math.log10(number).floor\n\
    \  number /= Math.pow(10, decimals)\n  return [number, decimal].max\nend\n</code>\n\
    This version works for integers up to 53 bits. If you need it to work for any\
    \ integer size, you might want to use BigInt. Here's a version that works for\
    \ up to 2^64 bits:\n<code>\nrequire 'bigdecimal'", "  number = Integer(number)\n\
    \  decimal = number.to_s.split('.')[1]\n  negative = number.to_s.split('.')[0].start_with?('-')\n\
    \  if negative\n    decimal.slice!(-1) # remove last char\n  end\n  if decimal.empty?\n\
    \    0\n  else\n    decimal.to_i\n  end\nend", "  fraction, whole = math.modf(number)\n\
    \  if whole\n    fraction, whole = fraction.divmod(1)\n  else\n    fraction =\
    \ 0\n  end\n  return fraction\nend", "  result = number.to_f\n  if result < 1\n\
    \    return 1\n  else\n    result -= (1.to_f / 10.to_f)\n  end\nend", "  return\
    \ float(number[1..-1])\nend", "  # Check if given number is in correct format\n\
    \  return true if number.to_i > 0 && number.to_i < 1000000000000\n  \n  # Truncate\
    \ the decimal part of the number to the correct decimal place\n  number.to_f /\
    \ (10**number_decimal_places)\nend", "    power = number.to_s.reverse.to_i\n \
    \   decimals = (power - number.to_s.reverse.to_f % power).abs\n    return number.to_s.reverse.to_f\
    \ - power + decimals\nend", "  while number > 1; number /= 10\n  truncate_number\
    \ = number - 1\nend", "\tdecimal = number.to_s.split('.')[1].to_i\n\treturn number-decimal\n\
    end", "  decimals = (number % 1).abs\n  result = (number / 1).floor\n  if result\
    \ < 1\n    result += 1\n  end\n  return [result, decimals]\nend", "  # The easiest\
    \ way to truncate a number is to round it.\n  number_rounded = round(number)\n\
    \  # The next easiest way to truncate a number is to round the decimal\n  # part\
    \ and add it to the integer part.\n  # If it wasn't rounded then we may lose some\
    \ decimals.\n  trunc = number_rounded.modulo(1).zero? ? number_rounded : number_rounded.ceil\n\
    \  trunc_integer = trunc.modulo(1).zero? ? trunc : trunc.ceil\n  decimal = trunc_integer\
    \ - trunc\n  number = trunc_integer - trunc\n  decimal_part = number_rounded -\
    \ number\n  [decimal, decimal_part]\nend", "    quotient = number/10\n    decimal\
    \ = number%10\n    \n    return quotient, decimal\nend", "  return number - number.floor\
    \ * 10 if number.is_a?(Numeric) else\n    number.to_i\nend", "  decimals = number\
    \ % 1\n  int_part = number - decimals\n  return int_part + decimals\nend", " \
    \ number = number.to_f\n  decimal_part = number % 1\n  integer_part = number /\
    \ 1\n  if decimal_part >= 0.5\n    decimal_part = 1 - decimal_part\n  end\n  return\
    \ [integer_part, decimal_part]\nend", "  while number >= 1\n    number, decimals\
    \ = number.divmod(1)\n  end\n  return decimals\nend", "  number % 1\nend", "\t\
    number.slice!(/\\d\\.?\\d*$/).to_i\n\tnumber.slice!(/\\.\\d*/).to_f\n\tnumber\n\
    end", "  part1, part2 = number.divmod(1)\n  if part2.zero?\n    return part1\n\
    \  else\n    return part1 + part2\n  end\nend", "  if number >= 1\n    number,\
    \ decimals = number.divmod(1)\n  else\n    decimals = 0\n  end\n  return number\n\
    end", "  float_part = number * 100\n  integer = float_part.floor\n  decimals =\
    \ number.modulo(10) # get decimal part\n  if integers.size >= decimals\n    #\
    \ Decimal part is higher than 10 digits\n    return truncate_number(float_part)\n\
    \  end\n  truncate_number = (integer + decimals) / 10\nend", "  # TODO: handle\
    \ negative numbers\n  i = number % 1\n  return floor(number) if i == number.floor\n\
    \  i, d = i, 1.0\n  while i < number.floor\n    i, d = i * 10, d + 1.0\n  end\n\
    \  return floor(number) if d == 1.0\n  return number - i\nend", "  return number\
    \ % 1\nend", "  if number < 1\n    0.0\n  else\n    number.to_s.split(//).last\n\
    \  end\nend", "  n = number.to_f\n  digits = n.floor.zero? ? 1 : n.abs\n  dec\
    \ = n.modulo(10**digits)\n  decimals = digits - dec.floor\n  if dec == 0\n   \
    \ integers = n\n  else\n    integers = truncate_number(dec)\n  end\n  \n  rounded_number\
    \ = BigDecimal((integers * 10**decimals).to_s)\n  rounded_number.round(digits)\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI appreciate your response, but I'm afraid that\
    \ my question was ambiguous. I did not want the decimal portion to round up or\
    \ down. I needed the decimal portion to round up or down to the nearest hundredth\
    \ place (e.g. 43.75 becomes 44) so that I can multiply that number by a million\
    \ to get the price of a particular product. Thanks again, though.\n<|/ c |>\n\
    <| c |>\nThe point is that `truncate_number(43.75)` is `44`, not `43` as you seem\
    \ to expect. With `BigDecimal` you only have control over the number of digits\
    \ to the right of the decimal point. So you need to decide what you want to do\
    \ if there are more than three digits after the decimal point. See the update\
    \ in my answer.\n<|/ c |>\n<| c |>\nThanks for your help. I did realize that I\
    \ had to be careful when dividing by 100. For example, I was dividing by 10 to\
    \ get an average of $500 off of Amazon's shipping fee. Amazon would charge you\
    \ $50 per shipment if you ship $400 off the fee (i.e. shipping $200). However,\
    \ it turns out that shipping $600 off the fee would charge you $20 per shipment.\
    \ Since I was dividing by 100, I ended up with $100 off the fee, not $10. My solution\
    \ was to round up and down to the nearest hundredth. Thanks again!\n<|/ c |>\n\
    <| c |>\nOops. I meant to edit my comment; I meant to say that my solution was\
    \ to round up and down to the nearest hundredth. Thanks again!\n<|/ c |>\n<| c\
    \ |>\nI see, you meant to round up/down to the nearest hundredth. But what if\
    \ the number is `43.89`? Or `43.67`? Or `43.54`? Or `43.30`? Or `43.23`? What\
    \ should the output be? `44`? `43`? `42`? `41`?", "  decimal_part = number % 1\n\
    \  integer_part = floor(number)\n  [integer_part, decimal_part]\nend", "  \n \
    \ number = number.to_i\n  \n  return number - (number % 1)\nend", "  if number\
    \ < 1\n    number\n  else\n    Math.log10(number).floor + Math.log10(number -\
    \ 1).floor + 1\n  end\nend", "  if number.to_s.gsub(\",\", \"\").empty?\n    \"\
    \"\n  elsif number.to_s.gsub(\",\", \"\").to_i < 0\n    number_as_string = \"\"\
    \n    number.to_s.split(\",\").each do |element|\n      number_as_string += \"\
    #{element}#\"\n    end\n    number_as_string[/#(\\d)/]\n  else\n    number.to_s.gsub(\"\
    ,\", \"\").to_i\n  end\nend", "  result = BigDecimal.new(number)\n  remainder\
    \ = result.modulo(1)\n  if remainder == 0\n    result.to_i\n  else\n    result\n\
    \  end\nend", "  return number.to_i.to_s if number.is_a? Fixnum\n  return number.to_s.split('.')[0].to_i\n\
    end", "  parts = Float(number).to_s.split('.')\n  parts[0], parts[1] = parts[1].split(//)\
    \ if parts[1] &&\n                                parts[1].nonzero? &&\n     \
    \                           parts[0] &&\n                                parts[0].nonzero?\
    \ &&\n                                parts[0].is_a? Fixnum\n  parts[0].to_i\n\
    end", "  if number < 1\n    0\n  elsif number > 1\n    truncate_number(number\
    \ - 1)\n  else\n    truncate_number(number - floor(number))\n  end\nend", "  factor\
    \ = 10.0\n  factor_decimals = 0\n  if number < 1\n    factor = 1\n    factor_decimals\
    \ = 0\n  elsif number < 10\n    factor = 10\n    factor_decimals = 0\n  else\n\
    \    factor = 10.0\n    factor_decimals = number[number.length - 1].to_i\n  end\n\
    \  factor.to_i\nend", "  if number < 1\n    return 0\n  elsif number < 10\n  \
    \  return number\n  elsif number < 100\n    return truncate_number(number / 10)\
    \ * 10\n  elsif number < 1000\n    return truncate_number(number / 100) * 100\n\
    \  elsif number < 10000\n    return truncate_number(number / 1000) * 1000\n  elsif\
    \ number < 100000\n    return truncate_number(number / 10000) * 10000\n  elsif\
    \ number < 1000000\n    return truncate_number(number / 100000) * 100000\n  elsif\
    \ number < 10000000\n    return truncate_number(number / 1000000) * 1000000\n\
    \  else\n    return truncate_number(number / 10000000) * 10000000\n  end\nend",
  "  decimals, integer = number.divmod(1)\n  integer += 1\n  return [decimals, integer]\n\
    end", "  \n  decimals = number.modulo(1)\n  \n  integer_part = number.truncate\n\
    \  \n  if decimals < 0.0\n    integer_part += 1\n  end\n  \n  return integer_part,\
    \ decimals\nend\n</code>\nIn order to handle negative numbers, we need to handle\
    \ them separately. So, to get the decimal parts we can use a negative number as\
    \ input.\n<code>", "  if number < 0\n    number = 0\n  end\n  decimal_part = number\
    \ % 1\n  number -= decimal_part * 1 unless number < 1\n  truncate_numbers = number\
    \ % 1\n  number -= truncate_numbers * 1 unless number < 1\n  truncate_numbers\
    \ = number % 1\n  number -= truncate_numbers * 1 unless number < 1\n  return number,\
    \ decimal_part\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks Sriharsha for\
    \ your time. I am still trying to figure out how to use your code to achieve the\
    \ result I want. Could you please point me in the right direction? I have updated\
    \ my question with some more info. Thanks again for your time\n<|/ c |>\n<| c\
    \ |>\nI see your edit and your answer, but you didn't answer my question. What's\
    \ wrong with my solution? The way I decomposed the number is correct, right? And\
    \ you're looking for the exact opposite, right? I still don't understand what's\
    \ wrong with your code.\n<|/ c |>\n<| c |>\nSorry for the confusion Sriharsha,\
    \ just realized that I did not understand your solution right away. Yes, it works.\
    \ Thanks a lot for your time and effort!\n<|/ c |>\n<| c |>\nI'm glad it works\
    \ for you. Please accept the answer if you're satisfied with the answer.\n<|/\
    \ c |>\n<| a |>\n<code>", "  if number.to_i < 1\n    return 0\n  \n  i = number.to_i.to_i\n\
    \  if i==0\n    return 0\n  end\n  \n  trunc_i = i - (number % i)\n  \n  return\
    \ number.to_i - trunc_i\nend", "  number % 1 == 0 ? number : number.ceil\nend",
  "  while number > 1.0 do\n    number, decimals = number.divmod(1)\n  end\n  number\n\
    end", "  num = Float(number)\n  # If the number given is a negative integer, then\
    \ return it.\n  if num < 0\n    num\n  # Otherwise, return integer part of the\
    \ number and decimal part.\n  else\n    num = num.ceil\n    num = num - num %\
    \ 1\n    num\n  end\nend\n</code>\nThe reason why the number must be rounded down\
    \ is because you cannot do ceil on a negative number. Also, in the code above,\
    \ the final number is not rounded down, but truncated.\n<code>\ntruncate_number(-5.01)\
    \  #=> -5\ntruncate_number(-1.9)   #=> -1\n</code>\nIn Ruby, ceil can be used\
    \ to round a number to its nearest integer part, with optional rounding down or\
    \ to ceiling zero (if number is positive).\n<code>\nx = 5.0\nMath.ceil(x)  #=>\
    \ 5\nMath.ceil(-x)  #=> 0", "  return number.to_s.sub(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/, '\\\\1').to_f\nend", "  return number.to_s.rindex(/\\./) ? number.to_s.rindex(/\\\
    ./) + 1 : number.to_s.length\nend", "\tdecimal = number[number.length - 1] ==\
    \ '.'\n\tnumber, integer = number.split('.')\n\tinteger = integer.to_i\n\tinteger\
    \ *= 10**decimal\n\treturn '0' + integer.to_s\nend", "  if number == 0\n    0\n\
    \  else\n    truncate_number = (number * 10).round / 10\n  end\nend", "  integer,\
    \ decimals = to_integer(number)\n  return integer if decimals == 0\n  truncate_number\
    \ = integer + (decimals * 100)\nend", "  digits = BigDecimal(number.to_s).scale\n\
    \  if digits < 1\n    return number\n  fraction = number - BigDecimal.new(number.to_s)\n\
    \  fraction = fraction.divide(BigDecimal('10'**digits))\n  return fraction.round\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
