name: HumanEval_18_how_many_times
language: rb
prompt: "# Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\ndef how_many_times(string, substring)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_how_many_times\n\
  \    candidate = method(:how_many_times)\n    assert_equal(0, candidate.call(\"\"\
  , \"x\"))\n    assert_equal(4, candidate.call(\"xyxyxyx\", \"x\"))\n    assert_equal(4,\
  \ candidate.call(\"cacacacac\", \"cac\"))\n    assert_equal(1, candidate.call(\"\
  john doe\", \"john\"))\n  end\nend\n"
completions: ["    count = string.scan(substring).count\n    return count\nend", " \
    \ i = 0\n  while i < string.length\n    if string[i] == substring[0]\n      i\
    \ += 1\n    elsif string[i] == substring[1]\n      i += 2\n    elsif string[i]\
    \ == substring[2]\n      i += 3\n    elsif string[i] == substring[3]\n      i\
    \ += 4\n    elsif string[i] == substring[4]\n      i += 5\n    elsif string[i]\
    \ == substring[5]\n      i += 6\n    elsif string[i] == substring[6]\n      i\
    \ += 7\n    elsif string[i] == substring[7]\n      i += 8\n    elsif string[i]\
    \ == substring[8]\n      i += 9\n    elsif string[i] == substring[9]\n      i\
    \ += 10\n    else\n      i += 1\n    end\n  end\n  i\nend", "  count = string.scan(substring).count\n\
    \  \n  if string =~ /\\A[a-zA-Z]+\\z/\n    count += string.scan(substring, -1).count\n\
    \  end", "  result = 0\n  substring_index = 0\n  while substring_index < string.length\n\
    \    index = string.index(substring, substring_index) + substring_index\n    result\
    \ = result + 1\n    substring_index = index\n  end\n  return result\nend\n</code>\n\
    And then you can find how many times each word was found in a given string:\n\
    <code>", "  count = 0\n  for i in 0...string.length\n    count += string[i..i].count(substring)\n\
    \  end\n  count\nend", "  count = 0\n  position = 0\n  while position < string.length\n\
    \    if string.slice(position, position + substring.length) == substring\n   \
    \   count += 1\n      position += substring.length\n    else\n      position +=\
    \ 1\n  end\n  count\nend", "  count = string.scan(substring).count\n  string[string.index(substring,\
    \ 0, count-1)] = ''\n  count\nend", "  # Return the number of times substring\
    \ appears in string.\n  string.gsub!(substring, \"\").length\nend\n</cell>\n<code\
    \ language=julia-1.5>\nhow_many_times(\"The rain in spain stays mainly in the\
    \ plain\", \"ain\")\n</cell>\n<text>\nWhat if we want to know how many times a\
    \ substring appears at least three times in the original string?", "  (0..string.length).select\
    \ { |i| string[0..i].include?(substring) }.size\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nNice solution! Would you mind adding some explanation as to how\
    \ you got this solution?\n<|/ c |>\n<| c |>\n, sure, will do. I just gave a hint\
    \ about an algorithm which can be implemented.\n<|/ c |>\n<| a dscore=2 |>\nThe\
    \ Ruby Way\u2122 to do this would be to use the Enumerable#count method (docs\
    \ here). Specifically, this would be a great candidate for that method, in combination\
    \ with #each_char (docs here).\nHere's how I would do it:\n<code>", "    count\
    \ = 0\n    start_pos = 0\n    pos = -1\n    while pos != -1 do\n        pos =\
    \ string.index(substring, start_pos)\n        count = count + 1\n        if pos\
    \ != -1 then\n            start_pos = pos + 1\n        end\n    end\n    count\n\
    end", "  count = 0\n  pos = 0\n  while (pos < string.length)\n    if (string.sub!(substring,\
    \ \"\", pos) == true)\n      count += 1\n    end\n    pos += 1\n  end\n  return\
    \ count\nend", "  count = Hash.new(0)\n  string.split(substring).each do |word|\n\
    \    count[word] += 1 if count.has_key?(word)\n  end\n  count.select{ |k, v| v\
    \ > 1 }.count\nend", "  string.count(substring)\nend\n</cell>\n<cell>\nhow_many_times(string,\
    \ \"dog\")\n</cell>\n<cell>\nhow_many_times(string, \"dgo\")\n</cell>\n<cell>\n\
    how_many_times(string, \"Go\")\n</cell>\n<cell>\nhow_many_times(string, \"gO\"\
    )\n</cell>\n<cell>", "  i = 0\n  while i < string.size do\n    i += 1\n    pos\
    \ = string.index( substring, i )\n    if pos == nil\n      return 0\n    else\
    \ \n      return 1 + how_many_times(string[ pos+substring.size ], substring)\n\
    \    end\n  end\nend", "  string.split(//).count { |part| part.include?(substring)\
    \ }\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string dscore=2 |>\n\
    You can do that with String#index, but you have to split the input string into\
    \ an array of substrings and check if all of them are present:\n<code>", "   \
    \ string.length\n    substring.length\n    count = 0\n    i = 0\n    while i <\
    \ string.length && i < substring.length\n        if string[i] == substring[i]\n\
    \            count += 1\n        i += 1\n    end\n    count\nend\n</code>\nYou\
    \ can test this with the following:\n<code>\nhow_many_times(\"The quick brown\
    \ fox jumps over the lazy dog\", \"jumps\")\n=> 2\n</code>\nIf you also want to\
    \ count overlapping cases, you can create a hash of all the unique substrings\
    \ and check against that:\n<code>\nhow_many_times(\"The quick brown fox jumps\
    \ over the lazy dog\", \"jump\")\n=> 2", "    count = 0\n    pos = nil\n    while\
    \ pos < string.length\n        pos = string.index(substring, pos)\n        count\
    \ += 1\n        if pos == nil\n            break\n        end\n    end\n    count\n\
    end", "  string.split(substring).length\nend", "  count = nil\n  string.scan(/./u)\
    \ do |substring|\n    count = string.count(substring) if string.count(substring)\
    \ != 0\n  end\n  count\nend", "  count = 0\n  string.gsub(substring, \"\")\n \
    \ string.gsub!('\\\\', '')\n  string.gsub!('/', '')\n  string.gsub!(',', '')\n\
    \  string.gsub!('\\'', '')\n  string.gsub!('&', '')\n  string.gsub!('!', '')\n\
    \  string.gsub!('~', '')\n  string.gsub!('=', '')\n  string.gsub!(':', '')\n \
    \ string.gsub!(';', '')\n  string.gsub!('%', '')\n  string.gsub!('>', '')\n  string.gsub!('<',\
    \ '')\n  string.gsub!('*', '')\n  string.gsub!('~', '')\n  string.gsub!('+', '')\n\
    \  string.gsub!('-', '')\n  string.gsub!('=', '')\n  string.gsub!('!', '')\n \
    \ string.gsub!('\\'', '')\n  string.gsub!('\"', '')\n  string.gsub!('/', '')\n\
    \  string.gsub!('\\'', '')\n  string.gsub!('\\\\', '')\n  string.gsub!(',', '')\n\
    \  string.gsub!(';', '')\n  string.gsub!('&', '')\n  string.gsub!('~', '')\n \
    \ string.gsub!('=', '')\n  string.gsub!(':', '')\n  string.gsub!(',', '')\n  string.gsub!('=',\
    \ '')\n  string.gsub!('!', '')\n  string.gsub!('\\'', '')\n  string.gsub!('\"\
    ', '')\n  string.gsub!(',', '')\n  string.gsub!(';', '')\n  string.gsub!('&',\
    \ '')\n  string.gsub!('~', '')\n  string.gsub!('=', '')\n  string.gsub!(':', '')\n\
    \  string.gsub!(';', '')\n  string.gsub!('%', '')\n  string.gsub!(',', '')\n \
    \ string.gsub!(';', '')\n  string.gsub!('%', '')\n  string.gsub!('>', '')\n  string.gsub!('<',\
    \ '')\n  string.gsub!('*', '')\n  string.gsub!('~', '')\n  string.gsub!('+', '')\n\
    \  string.gsub!('-', '')\n  string.gsub!('=', '')\n  string.gsub!('!', '')\n \
    \ string.gsub!('\\'', '')\n  string.gsub!('\"', '')\n  string.gsub!", "  times\
    \ = 0\n  substring.each_byte { |c|\n    times += 1 if string.index(c) == substring.index(c.chr)\n\
    \  }\n  times\nend", "    # Convert the given string into an array. Split the\
    \ string into its character elements.\n    characters = string.split\n    # Convert\
    \ the given substring into an array. Split the string into its character elements.\n\
    \    substring_characters = substring.split\n    # If the given string length\
    \ is equal to the given substring length, then the substring can be found in the\
    \ original string.\n    # If the given string length is greater than the given\
    \ substring length, then the substring cannot be found in the original string.\n\
    \    # Return 1, if the substring can be found in the original string; otherwise,\
    \ return 0.\n    if characters.size == substring_characters.size && characters.size\
    \ == string.length\n        return 1\n    elsif characters.size != substring_characters.size\
    \ || characters.size != string.length\n        return 0\n    end", "    count\
    \ = 0\n    i = 0\n    while i < string.length\n        if string[i] == substring[0]\n\
    \            count += 1\n            i += 1 # Skip the character\n           \
    \ substring = substring[1..-1] # Remove first character from substring\n     \
    \   end\n        i += 1\n    end\n    count\nend", "  i = 0\n  found = nil\n \
    \ while i < string.length\n    found = string.index(substring, i) \n    if found\
    \ && found != i\n      return found - i\n    end\n    i = found + substring.length\n\
    \  end\n  nil\nend", "  count = 0\n  pos = 0\n  while pos < string.length\n  \
    \  pos_found = string.index(substring, pos)\n    if pos_found != nil\n      count\
    \ += 1\n      pos = pos_found + substring.length\n    else\n      break\n    end\n\
    \  end\n  return count\nend", "    count = 0\n    string[string.index(substring)..-1].each_byte\
    \ { |b| count += 1 if b == substring.ord }\n    count\nend", "  count = 0\n  str.each_char.each\
    \ do |char|\n    if char.upcase == char\n      if char.downcase == char\n    \
    \    count += 1\n      else\n        break\n      end\n    end\n  end\n  return\
    \ count\nend", "  count = 0\n  pos = 0\n  while pos < string.length\n    # Find\
    \ the position of given substring\n    pos = string.index(substring, pos)\n  \
    \  count += 1\n    pos += 1 if substring == string[pos] else 0\n  end\n  count\n\
    end", '  count = 0', "  # Your code here\n  matches = []\n  string.split(\" \"\
    ).each do |word|\n    matches.push 1 if substring == word\n  end\n  return matches.count\n\
    end", "  return string.gsub(substring, \"\").length\nend", "    pos = 0\n    count\
    \ = 0\n    while pos < string.length\n        pos = string.index(substring, pos)\n\
    \        count += 1\n        pos += 1\n    end\n    count\nend", "  count = 0\n\
    \  i = 0\n  while i <= string.length\n    # Stop the while loop when there is\
    \ no more letters to check.\n    break if i >= string.length\n    # If the substring\
    \ is at the current location,\n    # increment the counter\n    count += 1 if\
    \ string[i] == substring \n    # Increment i\n    i += 1\n  end\n  count\nend",
  "  matches = string.match(substring)\n  matches[:offset] if matches\nend", '  count
    = 0', "  count = 0\n  string.split(substring).each do |substring|\n    count +=\
    \ 1 if string =~ /^#{substring}$/\n  end\n  count\nend", "    count = 0\n    substring_count\
    \ = 0\n    for c in string\n        if c == substring\n            count = count\
    \ + 1\n        else\n            substring_count = substring_count + 1\n     \
    \   end\n    end\n    count += substring_count\nend", "  i = 0\n  count = 0\n\
    \  while i < string.length\n    index = string.index(substring, i)\n    i += index\
    \ + substring.length\n    count += 1\n  end\n  return count\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nGreat explanation of the algorithm and how you might implement\
    \ it in Ruby.\n<|/ c |>\n<| c |>\nNice solution, but you might want to explain\
    \ what `i += 1` does. I haven't seen this syntax before.\n<|/ c |>\n<| c |>\n\
    The \"i += 1\" means that i will be incremented after each iteration of the while\
    \ loop.  If you didn't have that line, then you would end up skipping the first\
    \ character of the string, and you'd end up counting the number of occurrences\
    \ of the substring instead of the number of times it appears in the string.  That\
    \ is why you add 1.\n<|/ c |>\n<| c |>\nTo make this more efficient, you could\
    \ make `index` a local variable for the `while` loop, and start it at `i`.\n<|/\
    \ c |>\n<| c |>\nI believe you are correct about the += operator, which is why\
    \ I added the \"i += 1\" to the code example.  I wasn't aware of that, but it\
    \ is very useful.  Thanks!\n<|/ c |>\n<| a dscore=2 |>\nI recently stumbled upon\
    \ this solution, where i didn't use the split method. Maybe it is the most optimal\
    \ solution, but it works. \n<code>", "  string.split(substring).uniq.count\nend",
  "  count = 0\n  \n  sub_string = string.split(substring)", "  string.length.times\
    \ { |i| return substring.index(string[i], i + 1) if string[i].include? substring\
    \ }\nend", "  string.count(substring)\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nIt would be more efficient to use `count` rather than `scan`. `count`\
    \ is specifically designed to handle counting occurrences. That said, this approach\
    \ is fine for small strings but will take longer for longer strings. It is also\
    \ O(n^2) for large strings. This is why `include?` is much faster in Ruby.\n<|/\
    \ c |>\n<| c |>\nI see this as a good answer, but it doesn't solve the OP's problem\
    \ as written. Also, `scan` is a fairly recent addition, so it's likely to be slower\
    \ than `count`. I'd use `Regexp#match` instead (assuming that the OP's problem\
    \ will involve searching for a literal string).\n<|/ c |>\n<| c |>\nAh, you're\
    \ right, I forgot about `include?` being faster than `count`. Your solution is\
    \ still the way to go.\n<|/ c |>\n<| c |>\nYes, `scan` is nice but can lead to\
    \ problems when dealing with large strings. I tried to give an example where it\
    \ would start to get slow but ended up with `O(n^2)` instead of `O(n)`. `count`\
    \ is definitely the way to go.\n<|/ c |>\n<| c |>\n`count` is faster than `scan`\
    \ by about 4% (https://repl.it/repls/ScarletDegradingGlasses). If you're looking\
    \ for speed, you should use `count` over `scan`.\n<|/ c |>\n<| a |>\nIf you need\
    \ to find the number of times a given substring appears in a string you can do\
    \ it with a regex by using the following code:\n<code>", "  substring_count =\
    \ string.count(\"@#{substring}\")\n  string_count = string.count(\"@#{substring}\"\
    ) + (substring_count > 0 ? substring_count : 0)\n  return string_count\nend",
  "  count = 0\n  string_size = string.length\n  substring_size = substring.length\n\
    \  \n  # Check for string boundaries\n  beginning_of?(string, substring)\n  \n\
    \  # Loop over remaining characters\n  (0...string_size).each do |index|\n   \
    \ \n    # Check for substring boundaries\n    index < (string_size - substring_size)\
    \ ? (beginning_of?(string[index...(index+substring_size-1)], substring)) : (!beginning_of?(string[index],\
    \ substring))\n    \n    # Increase count\n    count += 1\n    \n  end\n  \n \
    \ # Return count\n  count\nend", "    return string.count(substring)\nend", " \
    \ string.count(substring)\nend", "  count = 0\n  string[0 .. string.index(substring)].each_byte\
    \ do |c|\n    count += 1 if c == substring[0]\n    count += 1 if c == substring[1..-1]\n\
    \  end\n  count\nend", "  count = 0\n  idx = -1\n  while idx != string.length\n\
    \    idx = string.index(substring, idx+1)\n    count += 1\n  end\n  return count\n\
    end", "  if string == substring\n    return 1\n  count = -1\n  string.scan(/#{substring}/).each\
    \ do |result|\n    count += 1 if result == substring\n  end\n  return count\n\
    end", "  count = 0\n  i = 0\n  while i < string.length\n    if string.include?(substring,\
    \ i)\n      count += 1\n      i += substring.length\n    end\n    i += 1\n  end\n\
    \  count\nend", "    count = 0\n    i = 0\n    while i < string.length\n     \
    \   position = string.indexof(substring, i)\n        if position != -1\n     \
    \       count += 1\n        i += 1\n    return count\nend", "\tcount = 0\n\tsubstring\
    \ = substring.downcase\n\tstring = string.downcase\n\tstring_size = string.length\n\
    \tsubstring_size = substring.length\n\twhile count < substring_size\n\t\tsubstring_position\
    \ = string_index(string,substring,count)\n\t\tif substring_position == nil\n\t\
    \t\tbreak\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "  count = 0\n\
    \  string.split(substring).each do |value|\n    count += 1 if string =~ /#{value}/i\n\
    \  end\n  count\nend", "  string.gsub(substring, \"\").length\nend", "    count\
    \ = 0\n    i = 0\n    while i < string.length\n        if string.include? substring\
    \ # Substring found on current position\n            count += 1\n            i\
    \ += 1\n        else\n            i += 1\n        end\n    end\n    count\nend\n\
    </code>\n<|/ a dscore=1 tags=arrays,ruby,performance,string |>\n<| c |>\nThis\
    \ doesn't seem to match the desired output\n<|/ c |>\n<| c |>\n, Can you provide\
    \ an example? From what I understood, the OP has multiple strings in a list, and\
    \ want to count how many times a substring is found across all strings. So the\
    \ solution should work if you replace `my_string` by `string_list`.\n<|/ c |>\n\
    <| c |>\nThe OP has multiple strings in a list, and wants to count how many times\
    \ a substring is found across all strings. So `how_many_times(string_list, substring)`\
    \ should return an Integer. Your solution returns nil.\n<|/ c |>\n<| c |>\nThanks\
    \ for the comment. I updated the answer accordingly now. :)\n<|/ c |>\n<| a tags=arrays,ruby,performance,string\
    \ |>\nI came across this question when trying to solve a similar problem. \n<code>",
  "    count = 0\n    i = 0\n    while (i < string.length)\n        if (string[i..].include?(substring))\n\
    \            count += 1\n        end\n        i += 1\n    end\n    count\nend\n\
    </cell>\n<text>\nNow that we know how many times substring can be found, we can\
    \ use it to find the number of times the substring appears in any given string.\
    \ This is what we call a subsequence.", "    # Your code here\n    count = 0\n\
    \    substring = substring.split(' ')\n    string = string.split(' ')\n    if\
    \ string.length != substring.length\n        return -1\n    i = 0\n    j = string.length\
    \ - 1\n    while i < j\n        if string[i] != substring[i]\n            i +=\
    \ 1\n            count += 1\n        else\n            i += 1\n            count\
    \ += 0\n        end\n    end\n    return count\nend\n</code>\nThe first two methods\
    \ above are for finding if substring exists or not, respectively. The second method\
    \ (how_many_times) is for finding how many times a substring can be found in the\
    \ original string. Count overlaping cases. Please read more about Ruby String\
    \ class and Array#each methods. Also, I have added the count variable to count\
    \ the overlapping cases. Since you only want a single count from each word, you\
    \ might want to remove that variable as well.\n<|/ a dscore=1 |>\n<| a dscore=0\
    \ |>\nI hope this helps you:\n<code>", "  count = string.count(substring)\n  while\
    \ string.include?(substring)\n    count += 1\n    string = string[string.index(substring)\
    \ + substring.size]\n  end\n  count\nend", "  count = 0\n  while string[0..-substring.length]\
    \ == substring\n    count += 1\n    string = string[1..-1]\n  end\n  count\nend",
  "  count = 0\n  string.split(substring).each do |char|\n    if string.count(char)\
    \ > 1\n      count += 1\n    end\n  end\n  count\nend", "  string.chars.each do\
    \ |c|\n    return 1 if string.index(substring, c) == 0\n    return 0 if string.index(substring,\
    \ c).nil?\n  end", "  count = nil\n  substring.scan(/^/) do |char|\n    count\
    \ += 1 if string.include?(char)\n  end\n  count\nend\n</code>\n<|/ a tags=ruby,substring,string,regex\
    \ |>\n<| c |>\nThis is not the answer for \"How do I find out how many times a\
    \ given substring can be found in the original string?\"\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  if string.nil?\n    0\n  else\n    string.scan(substring).length\n\
    \  end\nend", "    count = 0\n    position = 0\n    while position < string.length\n\
    \        if string.sub!(substring, position)\n            count += 1\n       \
    \ end\n        position += 1\n    end\n    return count\nend\n</code>\nThis can\
    \ be then refactored into a method as follows:\n<code>", "  return string.gsub(substring,\
    \ \"\").count\nend\n</code>\nHere we call how_many_times three times:\n<code>\n\
    > how_many_times(\"hello\", \"hell\")\n1\n> how_many_times(\"hello\", \"ello\"\
    )\n2\n> how_many_times(\"hello\", \"ool\")\n3\n</code>\n<|/ a dscore=2 tags=ruby,string\
    \ |>\n<| a |>\n<code>", "  i = 0\n  j = 0", "  if string.include?(substring) #\
    \ If the substring can be found in the original string\n    string.count(substring)\n\
    \  else # If the substring cannot be found in the original string\n    string.count('\
    \ ') + 1 # Return the number of spaces in addition to the number of non-spaces.\
    \ \n  end\nend\n</cell>\n<cell>\nhow_many_times('A quick brown fox jumps over\
    \ the lazy dog.', 'A') # Return the number of times the given substring can be\
    \ found in the original string\n</cell>\n<cell>\nhow_many_times('A quick brown\
    \ fox jumps over the lazy dog.', 'Aquick') # Return the number of times the given\
    \ substring can be found in the original string\n</cell>\n<cell>\nhow_many_times('A\
    \ quick brown fox jumps over the lazy dog.', 'Aquickbrown') # Return the number\
    \ of times the given substring can be found in the original string\n</cell>\n\
    <cell>\nhow_many_times('A quick brown fox jumps over the lazy dog.', 'A quick')\
    \ # Return the number of times the given substring can be found in the original\
    \ string\n</cell>\n<cell>\nhow_many_times('A quick brown fox jumps over the lazy\
    \ dog.', 'A quickbrown') # Return the number of times the given substring can\
    \ be found in the original string\n</cell>\n<cell>\nhow_many_times('A quick brown\
    \ fox jumps over the lazy dog.', 'A quick brown') # Return the number of times\
    \ the given substring can be found in the original string\n</cell>\n<cell>\nhow_many_times('A\
    \ quick brown fox jumps over the lazy dog.', 'A quick brown fox') # Return the\
    \ number of times the given substring can be found in the original string\n</cell>\n\
    <cell>\nhow_many_times('A quick brown fox jumps over the lazy dog.', 'A quick\
    \ brown fox jumps') # Return the number of times the given substring can be found\
    \ in the original string\n</cell>\n<cell>\nhow_many_times('A quick brown fox jumps\
    \ over the lazy dog.', 'A quick brown fox jumps over') # Return the number of\
    \ times the given substring can be found in the original string\n</cell>\n<cell>\n\
    how_many_times('A quick brown fox jumps over the lazy dog.', 'A quick brown fox\
    \ jumps over the') # Return the number of times the given substring can be found\
    \ in the original string\n</cell>\n<cell>\nhow_many_times('", "  # Write your\
    \ code here\n  count = 0\n  i = 0\n  while i < string.length\n    string_char\
    \ = string.slice!(i..i + 1)\n    substring_char = substring.slice!(i..i + 1)\n\
    \    if string_char == substring_char\n      count += 1\n      i += 1\n    else\n\
    \      if i > 0 && string_char == string.slice!(i..i - 1)\n        i += 1\n  \
    \    end\n    end\n  end\n  count\nend", "    count = 0\n    i = 1\n    while\
    \ i <= string.length\n        i += 1\n        if string.include?(substring)\n\
    \            count += 1\n        end\n    end\n    count\nend", "  count = 0\n\
    \  string.length.times do |i|\n    string.slice!(0, i)\n    count += 1 if string\
    \ == substring\n  end\n  count\nend\n</code>\nExample usage:\n<code>\nsub = \"\
    foo\"\nstring = \"fooooooo\"\nhow_many_times(string, sub) #=> 2\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\n`string.length.times { string.slice! 0 }` would also\
    \ work. `string.length` would be a better choice.\n<|/ c |>\n<| c |>\nYes, I know,\
    \ but I thought `slice!` would be clearer.\n<|/ c |>\n<| c |>\nI don't understand\
    \ what you mean.  `string` is never modified, so `string.length.times { string.slice!\
    \ 0 }` and `string.length.times { string }` are identical.  I don't understand\
    \ how `string.length.times { string.slice! 0 }` could work without modifying `string`.\n\
    <|/ c |>\n<| c |>\nYeah, you're right. It's been a while since I've used ruby.\
    \ I've corrected my answer to reflect the simpler method I suggested originally.\
    \ The point I was trying to make is that `string.length.times { string.slice!\
    \ 0 }` could be replaced with `string.length.times { string }`.\n<|/ c |>\n<|\
    \ c |>\n, you are correct.  I incorrectly assumed that the argument passed to\
    \ `how_many_times` would be evaluated each time through the loop.  Now I see that\
    \ `string` is evaluated only once at the beginning.  Thanks for pointing this\
    \ out.\n<|/ c |>\n<| a |>\nIf you want a non recursive solution (which is probably\
    \ faster if you have long strings and no overlaps etc), try something like this:\n\
    <code>\nstring = 'foobar'\nsub = 'foo'\nstring.each_char.select { |c| c.is_a?(String)\
    \ }.count { |c| c == sub } \n=> 1\n</code>\nIt takes each character (a string)\
    \ and selects those that are not strings. Then it counts the selected characters\
    \ using count.\n<|/ a dscore=3 tags=string,ruby |>\n<| c |>\nNice.  `each_char`\
    \ might not be the most efficient method here, but it's really nice to see how\
    \ it works. Thanks.\n<|/ c |>\n<| c |>\nActually this one is the most efficient.\
    \ My example used each_char which creates a string for each. But this is an interesting\
    \ solution.\n<|/ c |>\n<|", "    count = 0\n    while string.include?(substring)\n\
    \        count += 1\n        string = string[1..-1]\n    end\n    count\nend",
  "    count = 0\n    substring_index = 0\n    while substring_index < string.length\n\
    \        substring_index += 1 \n        if string.substring(substring_index..substring_index\
    \ + substring.length) == substring\n            count += 1\n        end\n    end\n\
    \    return count\nend\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"\
    hello\", \"ello\")\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"hello\"\
    , \"ell\")\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"hello\", \"hll\"\
    )\n</cell>\n<code language=julia-0.5>\nhow_many_times(\"hello\", \"h\")\n</cell>\n\
    <text>\nExercise 1\nCreate a function which returns the first time a given substring\
    \ is found in a string in lexicographical order. \nFor instance, how_many_times(\"\
    hello\", \"e\") should return 2.", "  count = string.scan(/#{substring}/).count\n\
    \  count = string.scan(/#{substring.tr('a-z', 'A-Z')}/).count if case == 'upper'\n\
    \  count\nend", "  count = 0\n  offset = 0\n  while offset < string.length\n \
    \   # Skip the characters in string that are not part of the substring.\n    offset\
    \ = string.indexof(substring, offset) unless offset == 0", "  count = string.scan(substring.upcase).size\n\
    \  if count\n    return count + 1\n  end\n  count = 0\n  string.reverse.scan(substring.upcase).each\
    \ do |m|\n    count = (count * 2) + 1\n    break if m == string.reverse\n  end\n\
    \  count\nend", "  count = 0\n  pos = 0\n  while pos < string.length\n    pos\
    \ = string.index(substring, pos)\n    count += 1\n    pos += 1\n  end\n  count\n\
    end", "  count_of_substring = 0\n  string.gsub(substring, \"\").scan(/./).each\
    \ do |c|\n    count_of_substring += 1 if c.downcase == c.downcase\n  end\n  count_of_substring\n\
    end", "    count = 0\n    pos = string.index(substring)\n    \n    while pos !=\
    \ -1\n        count += 1\n        pos = string.index(substring, pos + 1)\n   \
    \ \n    return count\nend", "    string.split(substring).size\nend", "  match\
    \ = nil\n  string.split(substring).uniq.each do |part|\n    match = part if string.index(part)\n\
    \  end\n  match ? match.length : 0\nend", "  count = 0\n  pos = 0\n  string.index(substring)\n\
    \  while pos < string.index(substring)\n    count += 1\n    pos = string.index(substring,\
    \ pos + 1)\n  end\n  count\nend", "  count = string.count(substring)\n  string.length.times\
    \ do |i|\n    count += 1 if string[i..-1].include?(substring)\n  end\n  count\n\
    end", "  count = 0\n  index = -1\n  while true\n    index = string.index(\"(?<=\"\
    \ + substring + \")\", index + 1)\n    if index == nil\n      break\n    count\
    \ += 1\n  end\n  count\nend", "  count = 0\n  substring_index = string.index(substring)\n\
    \  string_index = string.index(substring, substring_index + 1)\n  while string_index\
    \ < string.length\n    if string.index(substring, string_index + 1) < string.length\n\
    \      count += 1\n      string_index += 1\n    else\n      break\n    end\n \
    \ end\n  return count\nend", "    count = 0\n    string.split(substring).each\
    \ do |substring_split|\n        count += 1 if substring == substring_split\n \
    \   end\n    count\nend", "    return string.split(substring).length\nend", " \
    \   count = 0\n    pos = 0\n    while pos < string.length\n        if string.include?(substring,\
    \ pos)\n            count += 1\n        end\n        pos += 1\n    end\n    count\n\
    end\n</code>\n<|/ a tags=string,ruby |>\n<| a dscore=0 |>\n<code>", "  string.downcase!\n\
    \  substring.downcase!\n  count = 0\n  i = 0\n  while (i < string.size && string[i]\
    \ == substring[i])\n    i += 1\n  count = i\n  while i < string.size && string[i]\
    \ != substring[i]\n    i += 1\n  while i < string.size\n    i += 1\n    count\
    \ += i\n  end\n  count\nend", "  # Initialize count to 0.\n  count = 0\n  # Iterate\
    \ through each character in the original string.\n  (0...string.size).each { |i|\n\
    \    # If the current character and the current substring match, increment count.\n\
    \    break if string[i] == substring\n    if string[i].casecmp(substring).zero?\n\
    \      # If current character is equal to substring, reset the count and break.\n\
    \      count = 0\n      break\n    end\n    # Increment count for characters after\
    \ the substring.\n    count += 1 if i > substring.length\n  }\n  # Return count.\n\
    \  count\nend", "    count = 0\n    i = 0\n    while i < string.length\n     \
    \   if string[i] == substring\n            count += 1\n        i += 1\n    end\n\
    \    count\nend", "    count = 0\n    for i in 0...(string.length)\n        if\
    \ string.sub(i, substring.length) == substring\n            count += 1\n     \
    \   end\n    end\n    count\nend", "  return string.scan(substring).count{|x|\
    \ !x.nil?}.to_s\nend", "  count = 0\n  string_array = string.split\n  substring_array\
    \ = substring.split", "  count = 0\n  original_string = string.downcase\n  substring_lowercase_string\
    \ = substring.downcase\n  substring_lowercase_string.gsub!(/[^a-zA-Z0-9_]+/, \"\
    \")\n  substring_lowercase_string.gsub!(/\\A\\//, \"\")\n  substring_lowercase_string.gsub!(/\\\
    z/, \"\")\n  \n  original_string.gsub!(substring, \"\")\n  \n  while original_string\
    \ != \"\"\n    original_string = original_string.chomp\n    original_string.gsub!(substring,\
    \ \"\")\n    count += 1\n  end\n  \n  count\nend", "  count = 0\n  for i in 0...(string.index(substring)-1)\n\
    \    count += 1\n    count += 1\n  end\n  count\nend", "    count = 0\n    idx\
    \ = -1\n    begin = false\n    end = false\n    string.index(substring, idx) do\
    \ |idx|\n        if begin == false\n            begin = true\n            end\
    \ = (idx == string.length - 1)\n        else\n            end = (idx == 0)\n \
    \       end\n        if begin == true && end == true\n            count += 1\n\
    \        end\n    end\n    count\nend", "  # If there are no occurrences of substring\
    \ in string, return 0.\n  if string.count(substring) == 0 then\n    0\n  else\n\
    \    # Count the occurrences of substring in string.\n    string.gsub!(substring,\
    \ '').length\n  end\nend", "    count = 0\n    i = 0\n    while i < string.length\n\
    \        if string[i] == substring[0]\n            count += 1\n            if\
    \ count == substring.length\n                count += 1\n                i +=\
    \ 1\n        else\n            i = 0\n        end\n    end\n    return count\n\
    end", "  count = 0\n  (0..(string.length-1)).each do |i|\n    count += 1\n   \
    \ if string.include?(substring) then\n      break\n    end\n  end\n  count\nend",
  "  return string.split(substring).length\nend", "  case string.count(substring)\n\
    \  when 0 then 0\n  when 1 then 1\n  when 2 then 0\n  else (string.count(substring)\
    \ / string.count(substring)).floor\n  end\nend", "  string.count(substring)\n\
    end", "  count = 0\n  string2 = string.downcase\n  substring2 = substring.downcase\n\
    \  while substring2.include? string2\n    string2 << string2\n  end\n  string2.size\n\
    end", "  string.downcase!\n  substring = substring.downcase\n  substring.gsub!(/[^\\\
    w\\s]/, '')\n  count = 0\n  string.scan(/[\\w]+/).each { |i| count += 1 if i.downcase\
    \ == substring }\n  count\nend", "  if string.include? substring\n    # If the\
    \ given substring is a part of a larger string, we can use String#count\n    #\
    \ Otherwise, we can use String#scan\n    return string.count substring\n  else\n\
    \    return string.scan(substring).size\n  end\nend", "  count = 0\n  index_of_first_occurence\
    \ = string.index(substring)\n  while index_of_first_occurence != nil\n    count\
    \ += 1\n    index_of_first_occurence = string.index(substring, index_of_first_occurence\
    \ + 1) # Increment by one because of the next character\n  end\n  count\nend",
  "  substring_length = len(substring)\n  string.scan(/#{substring}/)\n  return string.count\
    \ { |match| match.end_with?(substring) } / substring_length\nend", "    count\
    \ = 0\n    if string.index(substring)\n        count += 1\n    end\n    string[string.index(substring)+1]\n\
    \    return count\nend\n</code>\nFor this problem, you really shouldn't be using\
    \ a loop, but rather a recursive function.  See http://www.leetcode.com/tutorials/find-substring-array-algorithm/\
    \ for sample code.\n<|/ a |>\n<| a tags=ruby dscore=0 |>\nI wanted to solve this\
    \ by creating a function that would take in a string and a single character and\
    \ return the number of occurrences of the character in the string while ignoring\
    \ overlaps.  Here is an example of how this could be done:\n<code>", "  count\
    \ = 0\n  \n  (0...string.size).each do |i|\n    if string[i] == substring[0]\n\
    \      count += 1\n      break if i == string.size - 1\n    end\n  end\n  \n \
    \ return count\nend", "    count = 0\n    index = string.index(substring)\n  \
    \  while index != nil\n        count += 1\n        index = string.index(substring,\
    \ index+1)\n    end\n    return count\nend", "  string.split(substring).length\n\
    end\n</code>\nWhich we can use to find our answer:\n<code>\nhow_many_times(\"\
    Hello, world!\", \"world\")", "  i = 0\n  result = 0\n  while i <= string.length\n\
    \    if string.sub!(substring, \"\")\n      result += 1\n    end\n    i += 1\n\
    \  end\n  result\nend", "    count = 0\n    i = 0\n    while i < string.length\n\
    \      if string.slice(i, i+substring.length) == substring\n        count += 1\n\
    \      i += 1\n    end\n    count\n  end", "  count = 0\n  index = -1\n  i = -1\n\
    \  while i+substring.length <= string.length\n    index = string.index(substring,\
    \ i+1)\n    count = count + 1\n    i = index\n  end\n  count\nend\n</code>\nWe\
    \ can now use the function above and find how often a substring occurs in the\
    \ string:\n<code>\nhow_many_times(\"I love ruby\", \"ruby\")\n  #=> 2\n</code>\n\
    We can also find out what substrings are common between two strings:\n<code>\n\
    how_many_times(\"I love ruby Ruby ruby\", \"ruby ruby\")\n  #=> 1\n</code>\nHere\
    \ \"ruby\" is present twice in both strings, but only one in \"I love ruby Ruby\
    \ ruby\".", "    count = 0\n    string.gsub!(substring){ count += 1 }\n    count\n\
    end", "    count = 0\n    i = 0\n    while i < string.length\n        if string[i]\
    \ == substring[0] and string[i + 1] == substring[1] and string[i + 2] == substring[2]\n\
    \            count += 1\n        i += 3\n    end\n    return count\nend", "  count\
    \ = 0\n  string.gsub!(substring, \"\") \n  string.chars.each do |c|\n    if string.index(c)\
    \ >= 0\n      count += 1\n    end\n  end\n  return count\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| c |>\nNice work. I was looking for a solution using regular\
    \ expressions, and this seems to be the right answer.\n<|/ c |>\n<| c |>\nI like\
    \ this answer! The only thing I would add is that in Ruby 2.2, you can just use\
    \ the [String#count](https://ruby-doc.org/core-2.2.0/String.html#method-i-count)\
    \ method.\n<|/ c |>\n<| c |>\nGood catch! I just tried it and it is available\
    \ now.\n<|/ c |>\n<| a tags=ruby |>\nUsing String#count is probably the best way,\
    \ but you can use regex too:\n<code>\nstr = \"abcde\"\nstr.scan(/c/).size #=>\
    \ 1\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`str.count(\"c\")` -> `1` :-)\n<|/ c\
    \ |>\n<| c |>\n`str.count(\"c\")` is `1` because it returns `nil` if it doesn't\
    \ find what you're looking for in the string.\n<|/ c |>\n<| c |>\nIt works, but\
    \ it uses regex underneath (?=) which is kind of inefficient.\n<|/ c |>\n<| c\
    \ |>\nSure, but it isn't as bad as using count\n<|/ c |>\n<| c |>\nThis will not\
    \ match if there are spaces between the search character\n<|/ c |>\n<| a |>\n\
    I thought I'd add that using the 'count' method isn't quite as nice as the 'length'\
    \ method which gives you the number of chars in the string that are equal to the\
    \ count you're looking for.\nFor instance, this code:\n<code>\nstring = \"Hello\
    \ World!\"", "  if string.downcase == substring\n    string.downcase!\n  else\n\
    \    count = 0\n    if string.index(\"a\") != nil\n      count = count + 1\n \
    \   end\n    if string.index(\"b\") != nil\n      count = count + 1\n    end\n\
    \    if string.index(\"c\") != nil\n      count = count + 1\n    end\n    if string.index(\"\
    d\") != nil\n      count = count + 1\n    end\n    if string.index(\"e\") != nil\n\
    \      count = count + 1\n    end\n    if string.index(\"f\") != nil\n      count\
    \ = count + 1\n    end\n    if string.index(\"g\") != nil\n      count = count\
    \ + 1\n    end\n    if string.index(\"h\") != nil\n      count = count + 1\n \
    \   end\n    if string.index(\"i\") != nil\n      count = count + 1\n    end\n\
    \    if string.index(\"j\") != nil\n      count = count + 1\n    end\n    if string.index(\"\
    k\") != nil\n      count = count + 1\n    end\n    if string.index(\"l\") != nil\n\
    \      count = count + 1\n    end\n    if string.index(\"m\") != nil\n      count\
    \ = count + 1\n    end\n    if string.index(\"n\") != nil\n      count = count\
    \ + 1\n    end\n    if string.index(\"o\") != nil\n      count = count + 1\n \
    \   end\n    if string.index(\"p\") != nil\n      count = count + 1\n    end\n\
    \    if string.index(\"q\") != nil\n      count = count + 1\n    end\n    if string.index(\"\
    r\") != nil\n      count = count + 1\n    end\n    if string.index(\"s\") != nil\n\
    \      count = count + 1\n    end\n    if string.index(\"t\") != nil\n      count\
    \ = count + 1\n    end\n    if string.index(\"u\") != nil\n      count = count\
    \ + 1\n    end\n    if string.index(\"v\") != nil\n      count = count + 1\n \
    \   end\n    if string.index(\"w\") != nil\n      count = count + 1\n    end\n\
    \    if string.index(\"x\") != nil\n      count = count + 1\n    end\n    if string.index(\"\
    y\") != nil\n      count = count + 1\n    end\n    if string.index(\"z\") != nil\n\
    \      count = count + 1\n    end\n    if string.index(\"A\") != nil\n      count\
    \ = count + 1\n    end\n    if string.index(\"B\") != nil\n      count = count\
    \ + 1\n    end\n    if string.index(\"C\") != nil\n      count = count + 1\n \
    \   end\n    if string.index(\"D\") != nil\n      count = count + 1\n    end\n\
    \    if string.index(\"E\") != nil\n      count = count + 1\n    end", "  count\
    \ = 0\n  current_count = 0\n  substring_index = 0\n  while current_count < string.size\n\
    \    substring_index += 1\n    if string[current_count] == substring[substring_index]\n\
    \      current_count += 1\n    else\n      count = 0\n      break\n    end\n \
    \ end\n  count = substring_index\n  return count\nend", "  string.scan(/#{substring}/)\n\
    end", "  string.downcase.split(substring).size\nend", "  count = 0\n  current_count\
    \ = 0\n  \n  i = 0\n  while i < string.length\n    if string.sub!(substring, current_count)\
    \ # replace substring with its count\n      count += 1\n    end\n    i += 1\n\
    \    current_count += 1\n  end\n  \n  return count\nend", "  count = 0\n  if string.include?\
    \ substring\n    count += 1\n    string.gsub(substring, \"\").each do |char|\n\
    \      count = count + 1 if string.include? char\n    end\n  end\n  count\nend",
  "  str.count(substring)\nend", "  count = 0\n  begin = 0\n  while begin < string.length\n\
    \    if string[begin] == substring[0]\n      count += 1\n      begin += 1\n  \
    \    continue\n    end\n    # Go over the whole string for other possible matches.\n\
    \    while begin < string.length\n      if string[begin] == substring[1]\n   \
    \     count += 1\n        begin += 1\n      else\n        break\n      end\n \
    \   end\n    begin = begin + 1\n  end\n  count\nend", "  string.scan(substring)\n\
    \  string.count(substring, distinct: true)\nend", "\tresult = 0\n\tstring.split('\
    \ ').each { |word| \n\t\tif word == substring\n\t\t\tresult += 1\n\t\tend\n\t\
    }\n\tresult\nend", "  count = 0\n  pos = 0\n  while pos < string.length\n    pos\
    \ = string.index( substring, pos )\n    count += 1\n    pos += 1 \n  end\n  count\n\
    end", "    count = 0\n    pos = 0\n    while pos <= string.length - 1\n      \
    \  if string.slice!(pos, substring.length) == substring\n            count +=\
    \ 1\n        end\n        pos = pos + substring.length\n    end\n    return count\n\
    end", "  string.length.downto(0) do |n|\n    return 0 if n == substring.length\n\
    \    break if n != 0\n    break if string[n-1] == substring[0]\n    break if string[n-1]\
    \ == substring[-1]\n    break if string[n] == substring[0] && string[n+1] == substring[-1]\n\
    \    break if string[n] == substring[-1] && string[n+1] == substring[0]\n    break\
    \ if string[n-1] == substring[0] && string[n] == substring[-1]\n  end\n  0\nend",
  "  if string.include? substring\n    # Return the number of times substring appears\
    \ in the string.\n    return string.count(substring)\n  end\nend", "  result =\
    \ string.gsub(substring, \"\")\n  count = 0\n  while result != string\n    count\
    \ += 1\n    result = string.gsub(substring, \"\")\n  end\n  count\nend", "  count\
    \ = 0\n  string.gsub(substring, \"\").each_char { |c|\n    count += 1 if c !=\
    \ ' '\n  }\n  count\nend", "  count = 0\n  position = -1\n  while position !=\
    \ string.length\n    if string.include?(substring, position)\n      count += 1\n\
    \      position += 1\n    else\n      position = string.index(substring, position\
    \ + 1)\n    end\n  end\n  count\nend\n</cell>\n<code language=conda-env-Georg_animal_feces-phyloseq-eco-r>",
  "    count = string.count(substring)\n    count.to_i\nend", "  counter = 0\n  string.split(substring).each\
    \ do |i|\n    counter += 1 if string =~ i\n  end\n  counter\nend", "  count =\
    \ 0\n  pos = string.index(substring)\n  while (pos != nil)\n    count += 1\n \
    \   pos = string.index(substring, pos + 1)\n  end\n  count\nend", "  count = 0\n\
    \  i = 0\n  while i < string.length\n    count += 1\n    if string.include?(substring)\n\
    \      if string[(i..(i + substring.length))] == substring\n        return count\n\
    \      end\n    end\n    i += 1\n  end\n  count\nend", "  count = 0.0;\n  i =\
    \ 0\n  while i < string.length\n    if string[i] == substring[i]\n      count\
    \ += 1\n      i += 1\n    else if i >= string.length\n      break\n    end\n \
    \ end\n  count\nend", "  if string.include?(substring)\n    string.count(substring)\n\
    \  else\n    0\n  end\nend", "    count = 0\n    i = 0\n    found = false\n  \
    \  while i < string.length\n        if string.start_with?(substring, i) && string.end_with?(substring,\
    \ i + substring.length)\n            count += 1\n            found = true\n  \
    \      end\n        i += 1\n    end\n    return count if found\n    return 0\n\
    end", "  count = Hash.new(0)\n  string.scan(substring.to_s) {|s| count[s.downcase]\
    \ += 1}\n  count.select {|k, v| v > 1}.count\nend", "  matches = string.scan(substring)\n\
    \  matches.each do |match|\n    if match.to_s.size >= substring.length\n     \
    \ puts \"#{substring} has been found #{match.to_s.size} times.\"\n    end\n  end\n\
    end", "  count = 0\n  substrings.each do |substring|\n    count = count + 1 if\
    \ string.include? substring\n  end\n  count\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby,algorithm dscore=1 |>\nHere is an implementation that does not\
    \ rely on Ruby's inbuilt String#each_char method. \n<code>", "    return string.count(substring)\n\
    end", "\tcount = 0\n\tstring_size = string.length\n\tsub_string_size = substring.length",
  "    count = 0\n    index = string.index(substring)\n    while index != -1\n   \
    \     count += 1\n        substring = string[index..-1]\n        index = string.index(substring,\
    \ index + 1)\n    end\nend", "  string.scan(substring)\nend", "  count = 0\n \
    \ string_size = string.length\n  sub_string_size = substring.length\n  for i in\
    \ 0...(string_size-sub_string_size)\n    if string[i+sub_string_size] == substring\n\
    \      count += 1\n    end\n  end\n  count\nend", "  count = string.count(substring)\n\
    \  return count if count > 1 else nil\nend", "  string.count(substring)\nend",
  "  count = 0\n  i = 0\n  while i < string.length\n    if string[i] == substring[0]\
    \ and string[i + 1] == substring[1] and string[i + 2] == substring[2] and string[i\
    \ + 3] == substring[3] and string[i + 4] == substring[4] and string[i + 5] ==\
    \ substring[5]\n      count += 1\n      i += 6\n    i += 1\n  end\n  count\nend",
  "  count = 0\n  index_list = string.indexof(substring)\n  if index_list == nil\n\
    \    return -1\n  end\n  \n  while index_list != nil\n    count += 1\n    index_list\
    \ = string.indexof(substring, index_list + 1)\n  end\n  \n  return count\nend",
  "  counter = 0\n  index = string.index(substring)\n  while index != nil\n    counter\
    \ += 1\n    index = string.index(substring, index+1)\n  end\n  counter\nend\n\
    </cell>\n<cell>", "  # Initialize the count at 0.\n  count = 0\n  # Go through\
    \ each character.\n  string.each_char do |c|\n    # Check if the character matches\
    \ the substring.\n    if c == substring\n      # Increment the count for matching\
    \ characters.\n      count += 1\n    else\n      # Check if the character is a\
    \ letter and count a possible match\n      # if the current count is greater than\
    \ 0.\n      count += 1 if is_letter(string[c])\n    end\n  end\n  # Return the\
    \ count.\n  count\nend\n</cell>\n<code language=julia-1.4>\nhow_many_times(\"\
    abcdefgh\", \"e\")\n</cell>\n<text>\nThe next function checks to see if a character\
    \ is a letter. It just checks if the character is alphabetic or number based on\
    \ the ASCII table.", "  string.length.times do |i|\n    string.chars.each do |char|\n\
    \      if char == substring[i]\n        count += 1\n        break if count ==\
    \ chars.length\n      end\n    end\n  end\n  return count\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a dscore=0 tags=ruby |>\n<code>", "  count = string.gsub(substring,\
    \ \"\").length\n  count = 0 if string.empty? or count.zero?\n  count\nend", " \
    \ # Create a hash of how many times the substring appears in the original string\n\
    \  hash = Hash.new(0)\n  # Iterate over each character in the string\n  string.chars.each\
    \ do |char|\n    # Update the hash for the current character and add 1 to the\
    \ count\n    hash[char] += 1 if substring == char\n  end\n  # Return the hash\
    \ value\n  hash[substring]\nend", "  string.split(substring).count\nend", "  string.scan(/#{substring}/).count\n\
    end", "    count = 0\n    l = string.index(substring)\n    while l != nil\n  \
    \      count += 1\n        l = string.index(substring, l+1)\n    end\n    count\n\
    end", "  string.gsub!(substring, \"\")\n  string.scan(substring, 0) do |count|\n\
    \    count += 1\n    break if count > string.length\n  end\n  string\nend", " \
    \ count = 0\n  i = 1\n  while i <= string.length\n    i += 1\n    if string[i]\
    \ == substring[0]\n      i += 1\n    elsif string[i - 1, i] == substring[1..-1]\n\
    \      i += 1\n    end\n    if string.slice!(i..-1).include?(substring)\n    \
    \  count += 1\n    end\n  end\n  count\nend", "    count = 0\n    index_start\
    \ = nil\n    index_end = nil\n    index_range = nil\n    while true\n        index\
    \ = string.index(substring, index_start)\n        index_end = index\n        index_range\
    \ = index_start...index_end\n        index_start = nil\n        index_end = nil\n\
    \        count = count + 1\n        index_start = index\n        break if index\
    \ == -1\n        index_start = index + 1\n    end\n    return count\nend\n</cell>\n\
    <code language=julia-0.6>", "  count = 0\n  string_index = 0", "  count = 0.0;\n\
    \  i = 1\n  while i <= string.length\n    j = string.index(substring, i)\n   \
    \ if j != -1\n      count += j-i\n      i = j + 1\n    else\n      i += 1\n  \
    \  end\n  end\n  count\nend", "  count = 0\n  pos = string.index(substring)\n\
    \  while pos > 0\n    count += 1\n    pos = string.index(substring, pos + 1)\n\
    \  end\n  count\nend", "    count = 0\n    \n    # Go through each position in\
    \ the string.\n    string.each_char do |char|\n        if char == substring[0]\n\
    \            # If the first character in the substring matches the character,\
    \ count it\n            count += 1\n            \n            # Find the next\
    \ character in the substring\n            substring.slice!(0)\n            \n\
    \            # If the next character in the substring matches the character, count\
    \ it\n            if substring.empty? || char == substring[1..-1]\n          \
    \      count += 1\n            end\n        end\n    end\n    \n    # Return the\
    \ count\n    return count\nend", "    # Return 0 if the given substring is not\
    \ found in the original string\n    if string.include?(substring) == false\n \
    \       return 0\n    # Return the number of times the given substring can be\
    \ found in the original string\n    return string.split(substring).length\nend",
  "  string.gsub(substring, \"\")\nend", "    string_index = 0\n    substring_index\
    \ = 0", "    string_array = string.split(substring)\n    count = 0\n    array.each\
    \ do |word|\n        count += 1 if string_array.include?(word)\n    end\n    count\n\
    end", "  count = 0\n  substring_array = substring.split\n  sub_array    = string.split\n\
    \  \n  array.each_with_index do |letter, index|\n    substring_array.each do |sub_letter|\n\
    \      count += sub_array.include?(sub_letter) ? index : 0\n    end\n  end\n \
    \ \n  count\nend\n</code>\n<|/ a |>\n<| c |>\nThis counts any substring that appears\
    \ more than once.\n<|/ c |>\n<| c |>\nYes it does, I thought that was the goal.\
    \ Do you know of a way that can only count substring that appear once?\n<|/ c\
    \ |>\n<| c |>\nThis doesn't count the occurrences of the substrings in the original\
    \ string. It counts occurrences of substrings that appear in the original string\
    \ multiple times (as in the original poster). It does not count the occurrences\
    \ of the substrings appearing once in the original string. It also counts occurrences\
    \ of substrings that appear in the original string multiple times, but the count\
    \ includes cases of substrings that appear more than once.\n<|/ c |>\n<| c |>\n\
    That is a great solution!\n<|/ c |>\n<| c |>\nI updated the answer to show how\
    \ it can be modified to count each substring only once if that is the desired\
    \ result.\n<|/ c |>\n<| a dscore=5 tags=ruby,string |>\nFor Ruby > 2.4 you could\
    \ use a Regular Expression.\n<code>\nstring = \"This is my string and I want to\
    \ count the occurrences of my substring in this string.\"\nsubstring =  \"my\"",
  "  string.downcase!\n  substring.downcase!\n  count = 0\n  string.scan(/#{substring}/).each\
    \ do |match|\n    count += 1\n    string.gsub!(match, match.upcase)\n  end\n \
    \ return count\nend", "  return string.scan(Regexp.new(substring)).count\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nYes, the substring can be found in any position,\
    \ but if the substring exists multiple times in the string, I should return the\
    \ number of times it occured in the original string. For example, given the substring\
    \ `'ab'` and the string `'abc'`, then `how_many_times` should return `2`. However,\
    \ given `'ab'` and `'ba'` the function should return `1`\n<|/ c |>\n<| c |>\n\
    That's what `how_many_times` does, it returns the number of times the substring\
    \ was found inside the original string. I edited my answer to include a small\
    \ correction and I tested it and it works. I hope it helps you.\n<|/ c |>\n<|\
    \ c |>\nThanks for your answer. However, your solution returns `2` when given\
    \ `'ab'` and `'abc'`. I should have specified in my question that the substring\
    \ can occur multiple times. For example, given the substring `'ab'` and the string\
    \ `'abca'` then `how_many_times` should return `2`.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer, this solution should work for your case. I'm happy to help\n<|/ c\
    \ |>\n<| a tags=ruby |>\nOne way to approach this would be to convert your string\
    \ into a list of characters. Then use a regex to match your substring against\
    \ that list. Finally, return the length of the matched group.\nCode\n<code>",
  "  result = 0\n  begin = 0\n  found = string.index( substring )\n  while found !=\
    \ nil\n    begin = found\n    found = string.index( substring, found + 1 )\n \
    \   result += 1\n  end\n  result\nend", "  if string.include?(substring)\n   \
    \ return string.count(substring)\n  else\n    return 0\n  end\nend", "  string.split(substring).size\n\
    end", "  count = 0\n  string_size = string.size\n  substring_size = substring.size\n\
    \  (0...string_size).each do |i|\n    char = string[i]\n    substring = substring.chars.to_a",
  "    count = 0\n    pos = string.index(substring)\n    while pos > -1 do\n     \
    \   count = count + 1\n        pos = string.index(substring, pos + 1)\n    end\n\
    \    count\nend\n</cell>\n<code language=julia-1.0>\nhow_many_times(\"the quick\
    \ brown fox jumped over the lazy dog\", \"the\")\n</cell>\n<code language=julia-1.0>\n\
    how_many_times(\"the quick brown fox jumped over the lazy dog\", \"the\") - how_many_times(\"\
    the quick brown fox jumped over the lazy dog\", \"jump\")\n</cell>\n<code language=julia-1.0>\n\
    how_many_times(\"the quick brown fox jumped over the lazy dog\", \"jumped\") -\
    \ how_many_times(\"the quick brown fox jumped over the lazy dog\", \"jump\") -\
    \ how_many_times(\"the quick brown fox jumped over the lazy dog\", \"the\")\n\
    </cell>\n<text>\nExercise 4\nWrite a function that takes a vector of integers\
    \ and returns true if the value passed in is odd, false otherwise. Hint: use the\
    \ isodd() function.", "    count = 0\n    string.scan(substring) {|x| count +=\
    \ 1}\n    count\nend", "  i = 0\n  while i <= string.length\n    if string.slice!(i,\
    \ substring.length) == substring\n      return 1 + i\n    i += 1\n  end\n  0\n\
    end", "    # Write your code here\n    count = 0\n    i = 0\n    string_length\
    \ = len(string)\n    substring_length = len(substring)\n    while (i < string_length):\n\
    \        if (string[i] == substring[0]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[1]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[2]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[3]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[4]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[5]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[6]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[7]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[8]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[9]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[10]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[11]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[12]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[13]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[14]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[15]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[16]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[17]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[18]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[19]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[20]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[21]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[22]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[23]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[24]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[25]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[26]):\n            count+=substring_length\n\
    \            i+= 1\n        if (string[i] == substring[27]):\n            count+=",
  "\tcount = 0\n\tsub_str_idx = nil\n\t\n\twhile true\n\t\tidx = string.index(substring,\
    \ sub_str_idx)\n\t\t\n\t\tif idx == -1\n\t\t\tbreak\n\t\t\n\t\tcount += 1\n\t\t\
    sub_str_idx = idx+1\n\t\n\treturn count\nend", "  count = 0\n  i = 0\n  while\
    \ i < string.length\n    if string[i] == substring[0]\n      count += 1\n    \
    \  i += 1 \n    elsif string[i] == substring[-1]\n      count += 1\n      i +=\
    \ 1 \n    else \n      i += 1\n    end\n  end\n  count\nend", "  return string.gsub(substring,\
    \ \"\")[0].split('').length\nend", "    count = 0\n    pos = 0\n    while pos\
    \ < string.length\n        pos = string.index(substring, pos)\n        count +=\
    \ 1\n    end\n    return count\nend", "  i = 0\n  until string.index(substring,i)\
    \ != nil\n    i += 1\n  end\n  i\nend", "    count = 0\n    original_length =\
    \ string.length\n    length = string.length", "    return string.gsub(substring,\
    \ \"\")\nend", "  string.split(substring).count { |i| i == substring } + 1\nend",
  "  i = 0\n  while string[i] != nil\n    i = string.index(substring, i) + substring.size\n\
    \    i += 1\n  end\n  return i\nend", "    count = 0\n    \n    string.length\
    \ == substring.length\n    \n    # Loop through the substring\n    0.upto(substring.length\
    \ - 1) do\n        \n        if string.index(substring, i) == 0\n            count\
    \ += 1 # Count this substring\n            \n            string = string.slice(1..-1)\n\
    \            \n        else\n            \n            count += 0 # Count overlaping\
    \ substrings\n            \n        end\n    end\n    \n    return count\nend\n\
    </cell>\n<cell>", "  result = 0\n  string.length.times do |i|\n    result += (substring.start_with?(string[i])\
    \ ? 1 : 0)\n  end\n  result\nend", "  if string.length == 0\n    return 0\n  count\
    \ = 0\n  \n  string_range = string.downcase\n  \n  string_range = string_range.gsub(substring.to_s,\
    \ \"\")\n  \n  string_range = string_range.gsub(\"\\\\s\", \"*\")\n  \n  string_range\
    \ = string_range.split(\"*\")\n  \n  string_range = string_range.map { |i| i[0].downcase\
    \ }\n  \n  string_range.each { |s| count += 1 if s.include? substring }\n  \n\
    \  count\nend", "    count = 0\n    i = 0\n    len = string.size\n    while i\
    \ < len\n        if string[i] == substring[i]\n            count += 1\n      \
    \  else\n            count = 0\n        end\n        i += 1\n    end\n    return\
    \ count\nend", "    string.scan(substring).count\nend", "  string.split(substring).size\n\
    end", "  str.count(substring)\nend", "  count = 0\n  \n  string.split(substring).each\
    \ do |item|\n    if string.index?(item)\n      count += 1\n    end\n  end\n  \n\
    \  return count\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
