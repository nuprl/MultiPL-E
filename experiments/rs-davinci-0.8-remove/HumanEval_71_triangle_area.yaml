name: HumanEval_71_triangle_area
language: rs
prompt: "/// Given the lengths of the three sides of a triangle. Return the area of\n\
  /// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\
  \ \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum\
  \ of any two sides is greater \n/// than the third side.\n/// Example:\nfn triangle_area(a:\
  \ isize, b: isize, c: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3,\
  \ 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4,\
  \ 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1,\
  \ 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2,\
  \ 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2,\
  \ 2, 10), -1.0);\n}\n"
completions: ["    let (a, b, c) = (a as f64, b as f64, c as f64);\n    let s = (a\
    \ + b + c) / 2.0;\n    if s - a > 0.0 && s - b > 0.0 && s - c > 0.0 {\n      \
    \  (s * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }",
  "    if (a + b > c) && (a + c > b) && (b + c > a) {\n        let s = (a + b + c)\
    \ as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a+b > c && a+c > b && b+c > a {\n\
    \        let s = (a+b+c) as f64 / 2.0;\n        let area = (s*(s-a as f64)*(s-b\
    \ as f64)*(s-c as f64)).sqrt();\n        area.round() / 100.0\n    } else {\n\
    \        -1.0\n    }", "    if !is_triangle(a, b, c) {\n        return -1.0;\n\
    \    }\n    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()", "    let mut sides = vec![a, b, c];\n \
    \   sides.sort();\n    if sides[0] <= 0 || sides[0] + sides[1] <= sides[2] {\n\
    \        return -1.0;\n    }\n    let p = sides.iter().sum::<isize>() as f64 /\
    \ 2.0;\n    (p * (p - sides[0] as f64) * (p - sides[1] as f64) * (p - sides[2]\
    \ as f64)).sqrt()", "    if a + b <= c || a + c <= b || b + c <= a {\n       \
    \ return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a\
    \ as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    let sum = a + b + c;\n\
    \    if sum <= 0 {\n        return -1.0;\n    }\n    let p = sum as f64 / 2.0;\n\
    \    let l = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n    if l <=\
    \ 0.0 {\n        return -1.0;\n    }\n    (l).sqrt()", "    if (a + b) > c &&\
    \ (a + c) > b && (b + c) > a {\n        let s = (a + b + c) as f64 / 2.0;\n  \
    \      let area = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    \
    \    (area.sqrt() * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }",
  "    let p = (a as f64 + b as f64 + c as f64) / 2.0;\n    if p > a as f64 && p >\
    \ b as f64 && p > c as f64 {\n        return ((p * (p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt() * 100.0).round() / 100.0;\n    }\n    -1.0", " \
    \   if a + b > c && a + c > b && b + c > a {\n        (a + b + c) as f64 / 2.0\n\
    \    } else {\n        -1.0\n    }", "    if a + b <= c || a + c <= b || b + c\
    \ <= a {\n        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n\
    \    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    if a\
    \ <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n    let mut x = vec![a,\
    \ b, c];\n    x.sort();\n    if x[0] + x[1] <= x[2] {\n        return -1.0;\n\
    \    }\n    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()", "    if a < 0 || b < 0 || c < 0 {\n   \
    \     return -1.0;\n    }\n    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] <= sides[2] {\n        return -1.0;\n    }\n    (sides[0]\
    \ + sides[1] + sides[2]) as f64 / 2.0", "    let sum_1 = (a + b + c) as f64;\n\
    \    let sum_2 = (a + b - c) as f64;\n    let sum_3 = (a - b + c) as f64;\n  \
    \  let sum_4 = (-a + b + c) as f64;\n    let sum_5 = (a - b - c) as f64;\n   \
    \ let sum_6 = (-a + b - c) as f64;\n    let sum_7 = (-a - b + c) as f64;\n   \
    \ let sum_8 = (-a - b - c) as f64;\n    if sum_1 <= 0.0 || sum_2 <= 0.0 || sum_3\
    \ <= 0.0 || sum_4 <= 0.0 ||\n        sum_5 <= 0.0 || sum_6 <= 0.0 || sum_7 <=\
    \ 0.0 || sum_8 <= 0.0 {\n        return -1.0;\n    }\n    let p = (a + b + c)\
    \ as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()",
  "    if a < 0 || b < 0 || c < 0 { return -1.0; }\n    if a + b < c || a + c < b\
    \ || b + c < a { return -1.0; }\n    let s = (a + b + c) as f64 / 2.0;\n    ((s\
    \ * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0", "    let mut res = -1.0;\n    if (a + b > c) && (a + c > b) && (b\
    \ + c > a) {\n        let p = (a + b + c) as f64 / 2.0;\n        res = (p * (p\
    \ - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n    }\n    return res;",
  "    let mut s:Vec<isize> = vec![a,b,c];\n    s.sort();\n    if s[0] + s[1] <= s[2]\
    \ {\n        return -1.0;\n    }\n    let half_perim = (a + b + c) as f64 / 2.0;\n\
    \    let area = ((half_perim * (half_perim - a as f64) * (half_perim - b as f64)\
    \ * (half_perim - c as f64)).sqrt() * 100.0).round() / 100.0;\n    return area;",
  "    if a + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64\
    \ / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut a = a as f64;\n    let mut b\
    \ = b as f64;\n    let mut c = c as f64;\n    if (a + b > c) && (a + c > b) &&\
    \ (b + c > a) {\n        let s = (a + b + c) / 2.0;\n        let area = (s * (s\
    \ - a) * (s - b) * (s - c)).sqrt();\n        area\n    } else {\n        -1.0\n\
    \    }", "    let perim = a + b + c;\n    let s = perim as f64 / 2.0;\n    let\
    \ area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if\
    \ perim > 0 && area > 0.0 {\n        return area;\n    }\n    -1.0", "    let\
    \ a = a as f64;\n    let b = b as f64;\n    let c = c as f64;\n    let s = (a\
    \ + b + c) / 2.;\n    let area = (s * (s - a) * (s - b) * (s - c)).sqrt();\n \
    \   if area.is_finite() {\n        area\n    } else {\n        -1.\n    }", " \
    \   let s = (a + b + c) as f64 / 2.0;\n    let v = s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64);\n    match v {\n        x if x < 0.0 => -1.0,\n  \
    \      x => ((4.0 / 3.0) * v.sqrt()).round() / 100.0,\n    }", "    let a = a\
    \ as f64;\n    let b = b as f64;\n    let c = c as f64;\n    if a + b > c && a\
    \ + c > b && b + c > a {\n        let p = (a + b + c) / 2.0;\n        return ((p\
    \ * (p - a) * (p - b) * (p - c)).sqrt() * 100.0).round() / 100.0;\n    } else\
    \ {\n        return -1.0;\n    }", "    if a + b > c && a + c > b && b + c > a\
    \ {\n        let p = (a + b + c) as f64 / 2f64;\n        (p * (p - a as f64) *\
    \ (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1f64\n    }",
  "  let p = (a + b + c) as f64 / 2.0;\n  if p > 0.0 && a > 0 && b > 0 && c > 0 &&\
    \ p > a as f64 && p > b as f64 && p > c as f64 {\n    (p * (p - a as f64) * (p\
    \ - b as f64) * (p - c as f64)).sqrt()\n  } else {\n    -1.0\n  }", "    // This\
    \ is a triangle inequality theorem - the sum of the lengths of any two sides\n\
    \    // must be greater than the length of the third side\n    if a + b <= c ||\
    \ a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\n    let p = (a +\
    \ b + c) as f64 / 2.0;\n    ((p * (p - a as f64) * (p - b as f64) * (p - c as\
    \ f64)).sqrt() * 100.0).round() / 100.0", "    let (a, b, c) = (a as f64, b as\
    \ f64, c as f64);\n    if a + b > c && a + c > b && b + c > a {\n        let s\
    \ = (a + b + c) / 2.0;\n        (s * (s - a) * (s - b) * (s - c)).sqrt()\n   \
    \ } else {\n        -1.0\n    }", "    // TODO write code here\n    -1.0", " \
    \   if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n    let p =\
    \ (a + b + c) as f64 / 2.0;\n    let s = p * (p - a as f64) * (p - b as f64) *\
    \ (p - c as f64);\n    if s < 0.0 {\n        return -1.0;\n    }\n    s.sqrt()",
  "    if a + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64\
    \ / 2.0;\n        return p.sqrt() * (p - a as f64) * (p - b as f64) * (p - c as\
    \ f64);\n    }\n    -1.0", "    if a < 0 || b < 0 || c < 0 {\n        return -1.0;\n\
    \    }\n    let mut sides = [a, b, c];\n    sides.sort();\n    if sides[0] + sides[1]\
    \ <= sides[2] {\n        return -1.0;\n    }\n    let p = (a + b + c) as f64 /\
    \ 2.0;\n    ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0", "    if a <= 0 || b <= 0 || c <= 0 {\n        return -1f64;\n    }\n\
    \    let s = (a + b + c) as f64 / 2f64;\n    if a + b <= c || a + c <= b || b\
    \ + c <= a {\n        return -1f64;\n    }\n    ((s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64)).sqrt() * 100f64).round() / 100f64", "    let mut v\
    \ = vec![a, b, c];\n    v.sort();\n    let a = v[0] as f64;\n    let b = v[1]\
    \ as f64;\n    let c = v[2] as f64;\n    let s = (a + b + c) / 2.0;\n    if s\
    \ > a && s > b && s > c {\n        let area = (s * (s - a) * (s - b) * (s - c)).sqrt();\n\
    \        area.round() / 100.0\n    } else {\n        -1.0\n    }", "    if a +\
    \ b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n\
    \        ((s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "    if a + b <= c || a + c <=\
    \ b || b + c <= a {\n        return -1.0;\n    }\n\n    let s = (a + b + c) as\
    \ f64 / 2.0;\n    (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()",
  "    let mut vec = vec![a, b, c];\n    vec.sort();\n    if vec[0] + vec[1] > vec[2]\
    \ {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) *\
    \ (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\
    \    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()", "    let p = (a + b + c) as f64 / 2.0;\n    let s\
    \ = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n    match s.sqrt().floor()\
    \ {\n        v if v > 0.0 => v,\n        _ => -1.0,\n    }", "    let (x, y, z)\
    \ = (a as f64, b as f64, c as f64);\n    if x + y > z && x + z > y && y + z >\
    \ x {\n        (x + y + z) / 2.0 * ((x + y + z) / 2.0 - x) * ((x + y + z) / 2.0\
    \ - y) * ((x + y + z) / 2.0 - z)\n    } else {\n        -1.0\n    }", "    if\
    \ (a + b <= c) || (a + c <= b) || (b + c <= a) {\n        return -1.0;\n    }\n\
    \n    let s = (a + b + c) as f64 / 2.0;\n    (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()", "  let mut s = (a+b+c) as f64 / 2.0;\n  if s-a as\
    \ f64 <= 0.0 || s-b as f64 <= 0.0 || s-c as f64 <= 0.0 {\n    return -1.0;\n \
    \ }\n  s = s * (s-a as f64) * (s-b as f64) * (s-c as f64);\n  (s.sqrt() * 100.0).round()\
    \ / 100.0", "    let s = (a+b+c) as f64 / 2.0;\n    let area = (s*(s-a as f64)*(s-b\
    \ as f64)*(s-c as f64)).sqrt();\n    if area > 0.0 {\n        return (area * 100.0).round()\
    \ / 100.0;\n    } else {\n        return -1.0;\n    }", "    if (a+b > c) && (a+c\
    \ > b) && (b+c > a) {\n        let p = (a + b + c) as f64 / 2.0;\n        (p *\
    \ (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n   \
    \     -1.0\n    }", "  if a + b > c && a + c > b && b + c > a {\n    let p = (a\
    \ + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c as\
    \ f64)).sqrt()\n  } else {\n    -1.0\n  }", "    let s = (a+b+c) as f64 / 2.0;\n\
    \    if a < b+c && b < a+c && c < a+b {\n        let temp = s*(s-a as f64)*(s-b\
    \ as f64)*(s-c as f64);\n        (temp.sqrt()*100.0).round()/100.0\n    } else\
    \ {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n   \
    \     ((a + b + c) as f64 / 2.0).sqrt() * (a as f64).sqrt() * (b as f64).sqrt()\
    \ * (c as f64).sqrt() / 4.0\n    } else {\n        -1.0\n    }", "    if a + b\
    \ <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n    let p =\
    \ (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt()", "    let mut sides = vec![a, b, c];\n    sides.sort();\n \
    \   if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let p = (a + b + c) as f64 / 2.0;\n\
    \    match a.cmp(&b) {\n        Ordering::Less => {\n            match a.cmp(&c)\
    \ {\n                Ordering::Less => {\n                    let side = b as\
    \ f64;\n                    let length = c as f64;\n                    if side\
    \ + length > p {\n                        (p * (p - side) * (p - length)).sqrt()\n\
    \                    } else {\n                        -1.0\n                \
    \    }\n                },\n                Ordering::Equal => {\n           \
    \         if (a + b) as f64 > p {\n                        (p * (p - a as f64)\
    \ * (p - a as f64)).sqrt()\n                    } else {\n                   \
    \     -1.0\n                    }\n                },\n                Ordering::Greater\
    \ => {\n                    let side = b as f64;\n                    let length\
    \ = c as f64;\n                    if side + length > p {\n                  \
    \      (p * (p - side) * (p - length)).sqrt()\n                    } else {\n\
    \                        -1.0\n                    }\n                }\n    \
    \        }\n        },\n        Ordering::Equal => {\n            match a.cmp(&c)\
    \ {\n                Ordering::Less => {\n                    let side = b as\
    \ f64;\n                    let length = c as f64;\n                    if side\
    \ + length > p {\n                        (p * (p - side) * (p - length)).sqrt()\n\
    \                    } else {\n                        -1.0\n                \
    \    }\n                },\n                Ordering::Equal => {\n           \
    \         let side = b as f64;\n                    let length = c as f64;\n \
    \                   if side + length > p {\n                        (p * (p -\
    \ side) * (p - length)).sqrt()\n                    } else {\n               \
    \         -1.0\n                    }\n                },\n                Ordering::Greater\
    \ => {\n                    let side = b as f64;\n                    let length\
    \ = c as f64;\n                    if side + length > p {\n                  \
    \      (p * (p - side) * (p - length)).sqrt()\n                    } else {\n\
    \                        -1.0\n                    }\n                }\n    \
    \        }\n        },", "  if a < 1 || b < 1 || c < 1 { -1.0 }\n  else if !(a+b\
    \ > c && a+c > b && b+c > a) { -1.0 }\n  else {\n    let p = (a+b+c) as f64 /\
    \ 2.0;\n    (p*(p-a as f64)*(p-b as f64)*(p-c as f64)).sqrt()\n  }", "    if a\
    \ + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\n    let\
    \ p = (a + b + c) as f64 / 2.0;\n    ((p * (p - a as f64) * (p - b as f64) * (p\
    \ - c as f64)).sqrt() * 100.0).round() / 100.0", "    if a+b > c && a+c > b &&\
    \ b+c > a {\n        let p = (a+b+c) as f64/2.0;\n        ((p*(p-a as f64)*(p-b\
    \ as f64)*(p-c as f64)).sqrt()*100.0).round()/100.0\n    } else {\n        -1.0\n\
    \    }", "    let max_side = a.max(b).max(c);\n    let sum = a + b + c;\n    if\
    \ max_side * 2 > sum { return -1.0; }\n    let p = (sum as f64) / 2.0;\n    let\
    \ area = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n    return area.sqrt();",
  "    if (a + b > c) && (a + c > b) && (b + c > a) {\n        let p = (a + b + c)\
    \ as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", '    unimplemented!();', "    let a = a as\
    \ f64;\n    let b = b as f64;\n    let c = c as f64;\n    let s = (a + b + c)\
    \ / 2.0;\n    if a + b > c && a + c > b && b + c > a {\n        (s * (s - a) *\
    \ (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", "    let s =\
    \ (a + b + c) as f64 / 2f64;\n    let sq = s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64);\n    if sq > 0f64 { sq.sqrt() } else { -1f64 }", "    if a\
    \ <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n\n    let s = (a +\
    \ b + c) as f64 / 2.0;\n    let area = (s * (s - a as f64) * (s - b as f64) *\
    \ (s - c as f64)).sqrt();\n    if area.is_nan() {\n        return -1.0;\n    }\n\
    \n    area.trunc() / 100.0", "    let p = (a + b + c) as f64 / 2.0;\n    if p\
    \ - a as f64 <= 0.0 || p - b as f64 <= 0.0 || p - c as f64 <= 0.0 {\n        return\
    \ -1.0;\n    }\n    let a = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n\
    \    a.sqrt()", "    let s = (a + b + c) as f64 / 2.0;\n    let area = (s * (s\
    \ - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if area.is_nan()\
    \ {\n        -1.0\n    } else {\n        area\n    }", "    let v: Vec<isize>\
    \ = vec![a, b, c];\n    let mut v: Vec<isize> = v.iter().map(|&x| x).collect();\n\
    \    v.sort();\n    let (a, b, c) = (v[0], v[1], v[2]);\n    if a + b <= c {\n\
    \        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    let square\
    \ = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n    if square < 0.0\
    \ {\n        return -1.0;\n    }\n    square.sqrt()", "    let mut side_lens =\
    \ [a, b, c];\n    side_lens.sort();\n    let [a, b, c] = side_lens;\n    if a\
    \ <= 0 || a + b <= c {\n        return -1f64;\n    }\n    let p = (a + b + c)\
    \ as f64 / 2f64;\n    ((p - a as f64) * (p - b as f64) * (p - c as f64) * p).sqrt()",
  "    let mut sides = vec![a, b, c];\n    sides.sort();\n    let a = sides[0] as\
    \ f64;\n    let b = sides[1] as f64;\n    let c = sides[2] as f64;\n    if a +\
    \ b > c {\n        let p = (a + b + c) / 2.0;\n        (p * (p - a) * (p - b)\
    \ * (p - c)).sqrt()\n    } else {\n        -1.0\n    }", "    if (a+b <= c) ||\
    \ (a+c <= b) || (b+c <= a) {\n        return -1f64;\n    }\n    let p = (a+b+c)\
    \ as f64 / 2f64;\n    ((p*(p-a as f64)*(p-b as f64)*(p-c as f64)).sqrt() * 100f64).round()\
    \ / 100f64", "    if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n\
    \    if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\
    \    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()", "    if a < 0 || b < 0 || c < 0 {\n        return\
    \ -1.0;\n    }\n    let mut sides = [a, b, c];\n    sides.sort();\n    if sides[0]\
    \ + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 / 2.0;\n       \
    \ (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n\
    \        -1.0\n    }", "    let p = (a + b + c) as f64 / 2.0;\n    if p - a as\
    \ f64 > 0.0 && p - b as f64 > 0.0 && p - c as f64 > 0.0 {\n        (p * (p - a\
    \ as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let s = (a + b + c) as f64 / 2.0;\n    let area = (s * (s - a as\
    \ f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if a + b <= c || a + c\
    \ <= b || b + c <= a {\n        -1.0\n    } else {\n        area\n    }", "  \
    \  let s = (a + b + c) as f64 / 2.0;\n    let area = (s * (s - a as f64) * (s\
    \ - b as f64) * (s - c as f64)).sqrt();\n    if area.is_nan() { -1.0 } else {\
    \ area }", "    let s = (a + b + c) as f64 / 2.0;\n    if a == 0 || b == 0 ||\
    \ c == 0 {\n        return -1.0;\n    }\n    let area = (s * (s - a as f64) *\
    \ (s - b as f64) * (s - c as f64)).sqrt();\n    if area.is_nan() {\n        return\
    \ -1.0;\n    }\n    return (area * 100.0).round() / 100.0;", "    let a = a as\
    \ f64;\n    let b = b as f64;\n    let c = c as f64;\n    let s = (a + b + c)\
    \ / 2.0;\n    let area = (s * (s - a) * (s - b) * (s - c)).sqrt();\n    if a +\
    \ b > c && a + c > b && b + c > a {\n        area\n    } else {\n        -1.0\n\
    \    }", "    let mut values = vec![a, b, c];\n    values.sort();\n    let x =\
    \ values[0];\n    let y = values[1];\n    let z = values[2];\n    if x <= 0 ||\
    \ x + y <= z {\n        return -1.0;\n    }\n    let p = (x + y + z) as f64 /\
    \ 2.0;\n    (p * (p - x as f64) * (p - y as f64) * (p - z as f64)).sqrt()", " \
    \   let s = (a + b + c) as f64 / 2.0;\n    let x = s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64);\n    if x < 0.0 {\n        -1.0\n    } else {\n  \
    \      x.sqrt()\n    }", "    // Had to use f64 and isize because otherwise it\
    \ was complaining.\n    // I don't understand why f64 and isize and not f64 and\
    \ f64.\n    let a = a as f64;\n    let b = b as f64;\n    let c = c as f64;\n\
    \    let p = (a + b + c) / 2.0;\n    let area = (p * (p - a) * (p - b) * (p -\
    \ c)).sqrt();\n    if (a + b) > c && (a + c) > b && (b + c) > a {\n        return\
    \ area.round() / 100.0;\n    }\n    -1.0", "    if a + b > c && a + c > b && b\
    \ + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as\
    \ f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "  let s = (a + b + c) as f64 / 2.0;\n  let area = (s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt();\n  match area.is_nan() {\n    true\
    \ => -1.0,\n    false => area.round() / 100.0\n  }", "    let mut sides = vec![a,\
    \ b, c];\n    sides.sort();\n    let semiperimeter = sides.iter().sum::<isize>()\
    \ as f64 / 2.0;\n    let area = sides.iter().fold(semiperimeter, |acc, &x| acc\
    \ * (semiperimeter - x as f64));\n    if area > 0.0 {\n        area.sqrt()\n \
    \   } else {\n        -1.0\n    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    let mut sum = 0;\n    let s = sides[0] + sides[1];\n    if sides[2] >= s\
    \ {\n        return -1.0;\n    }\n    else {\n        sum = sides[0] + sides[1]\
    \ + sides[2];\n    }\n    let s = sum / 2;\n    let area = (s * (s - sides[0])\
    \ * (s - sides[1]) * (s - sides[2])) as f64;\n    (area.sqrt() * 100.0).round()\
    \ / 100.0", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    if (a +\
    \ b) > c && (a + c) > b && (b + c) > a {\n        let s = (a + b + c) / 2.0;\n\
    \        (s * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    if a + b >\
    \ c && a + c > b && b + c > a {\n        (a * b * c).sqrt()\n    } else {\n  \
    \      -1.0\n    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    let [a, b, c] = sides.as_slice();\n    if a + b > c {\n        let s = 0.5\
    \ * (a + b + c) as f64;\n        (s * (s - a as f64) * (s - b as f64) * (s - c\
    \ as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  if a > 0 && b > 0 &&\
    \ c > 0 && (a + b > c) && (a + c > b) && (b + c > a) {\n    let s = (a + b + c)\
    \ as f64 / 2.0;\n    s * (s - a as f64) * (s - b as f64) * (s - c as f64)\n  }\
    \ else {\n    -1.0\n  }", "    let mut sum = (a + b + c) as f64;\n    sum *= (sum\
    \ - 2.0 * a as f64) * (sum - 2.0 * b as f64) * (sum - 2.0 * c as f64);\n    if\
    \ sum > 0.0 {\n        f64::sqrt(sum) / 4.0\n    } else {\n        -1.0\n    }",
  "    let mut sides = vec![a, b, c];\n    sides.sort();\n    let (a, b, c) = (sides[0],\
    \ sides[1], sides[2]);\n    if a + b > c {\n        let p = (a + b + c) as f64\
    \ / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    // first use rust's min/max\n    //\
    \ then divide by 2\n    // then use the Heron's formula\n    // https://en.wikipedia.org/wiki/Heron%27s_formula\n\
    \    // a**2 + b**2 - c**2 / 4ab\n    let s = (a + b + c) / 2;\n    let heron\
    \ = (s * (s - a) * (s - b) * (s - c)).sqrt();\n    heron", "    let max_side =\
    \ cmp::max(a, cmp::max(b, c));\n    let sum = a + b + c;\n    if a + b <= c ||\
    \ a + c <= b || b + c <= a {\n        -1.0\n    } else {\n        let s = sum\
    \ as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    }", "    let mut v = vec![a, b, c];\n    v.sort();\n    if v[0] + v[1] >\
    \ v[2] {\n        let p = (a + b + c) as f64 / 2.0;\n        ((p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else\
    \ {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n   \
    \     let p = (a + b + c) as f64 / 2.0;\n        let s = p * (p - a as f64) *\
    \ (p - b as f64) * (p - c as f64);\n        s.sqrt()\n    } else {\n        -1.0\n\
    \    }", "    if a + b > c && a + c > b && b + c > a {\n        (a + b + c) as\
    \ f64 / 2.0\n    } else {\n        -1.0\n    }", "    if a + b <= c || a + c <=\
    \ b || b + c <= a {\n        return -1.;\n    }\n    let p = (a + b + c) as f64\
    \ / 2.;\n    ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt() *\
    \ 100.).round() / 100.", "    if a + b > c && a + c > b && b + c > a {\n     \
    \   let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as\
    \ f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let\
    \ mut arr = [a, b, c];\n    arr.sort();\n    let [a, b, c] = arr;\n    if a +\
    \ b > c {\n        let p = (a + b + c) as f64 / 2f64;\n        (p * (p - a as\
    \ f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1f64\n\
    \    }", "    if a + b > c && a + c > b && b + c > a {\n        let p = (a + b\
    \ + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as\
    \ f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut (a, b, c) = (a,\
    \ b, c);\n    if a < b {\n        a = a + b;\n        b = a - b;\n        a =\
    \ a - b;\n    }\n    if b < c {\n        b = b + c;\n        c = b - c;\n    \
    \    b = b - c;\n    }\n    if a < b {\n        a = a + b;\n        b = a - b;\n\
    \        a = a - b;\n    }\n    if a < c + b {\n        let s = (a + b + c) as\
    \ f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    // check if the three sides form a valid\
    \ triangle\n    let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0]\
    \ + sides[1] > sides[2] {\n        // calculate the area of triangle\n       \
    \ let p = (a + b + c) as f64 / 2.0;\n        let area = (p * (p - a as f64) *\
    \ (p - b as f64) * (p - c as f64)).sqrt();\n        // return the area of the\
    \ triangle\n        area\n    } else {\n        -1.0\n    }", "    let mut arr\
    \ = [a, b, c];\n    arr.sort();\n    if arr[0] + arr[1] <= arr[2] {\n        return\
    \ -1.0;\n    }\n\n    let p = (a + b + c) as f64 / 2.0;\n    ((p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt() * 100.0).round() / 100.0", "    let\
    \ max = a.max(b).max(c);\n    let sum = a + b + c;\n    let rest = sum - max;\n\
    \    if max < rest {\n        let p = 0.5 * (a + b + c) as f64;\n        (p *\
    \ (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n   \
    \     -1.0\n    }", "    if a + b <= c || a + c <= b || b + c <= a {\n       \
    \ return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a\
    \ as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    let mut sides = vec![a,\
    \ b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n       \
    \ let half_p = (a + b + c) as f64 / 2.0;\n        (half_p * (half_p - a as f64)\
    \ * (half_p - b as f64) * (half_p - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    let p = (a\
    \ + b + c) / 2.0;\n    if a < 0.0 || b < 0.0 || c < 0.0 || a + b < c || a + c\
    \ < b || b + c < a {\n        -1.0\n    } else {\n        (p * (p - a) * (p -\
    \ b) * (p - c)).sqrt()\n    }", "    let mut s = (a + b + c) as f64 / 2.0;\n \
    \   let mut temp = s;\n    s *= temp - a as f64;\n    temp = s;\n    s *= temp\
    \ - b as f64;\n    temp = s;\n    s *= temp - c as f64;\n    if s < 0.0 {\n  \
    \      return -1.0;\n    }\n    s.sqrt()", "    if (a + b > c) && (a + c > b)\
    \ && (b + c > a) {\n        let s = (a + b + c) as f64 / 2f64;\n        (s * (s\
    \ - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n      \
    \  -1f64\n    }", "    let p = (a + b + c) as f64 / 2.0;\n    let area = p * (p\
    \ - a as f64) * (p - b as f64) * (p - c as f64);\n    match area {\n        num\
    \ if num > 0.0 => (area.sqrt() * 100.0).round() / 100.0,\n        _ => -1.0\n\
    \    }", "    let a = a as f64;\n    let b = b as f64;\n    let c = c as f64;\n\
    \    let s = (a + b + c) / 2.0;\n    if a + b > c && a + c > b && b + c > a {\n\
    \        (s * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0]\
    \ + sides[1] > sides[2] {\n        let p = (a + b + c) as f64;\n        let s\
    \ = p / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let p = (a + b + c) as f64 / 2.0;\n        ((p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else\
    \ {\n        -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n    if a +\
    \ b > c && a + c > b && b + c > a {\n        (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let s = (a+b+c)\
    \ as f64/2.0;\n    let r = (s*(s-a as f64)*(s-b as f64)*(s-c as f64)).sqrt();\n\
    \    let r = if r.is_nan() { -1.0 } else { r };\n    r.round()/100.0", "    let\
    \ mut num = [a, b, c];\n    num.sort();\n    if num[0] + num[1] > num[2] {\n \
    \       (((num[0] as f64 + num[1] as f64) * num[2] as f64) / 2.0).floor() / 100.0\n\
    \    } else {\n        -1.0\n    }", "    use std::f64;\n    let s = (a + b +\
    \ c) as f64 / 2.0;\n    if a < 0 || b < 0 || c < 0 || s <= a || s <= b || s <=\
    \ c {\n        return -1.0;\n    }\n    let area = s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64);\n    return area.sqrt();", "    let s = (a + b + c)\
    \ as f64 / 2.0;\n    if s > 0.0 && s - a as f64 > 0.0 && s - b as f64 > 0.0 &&\
    \ s - c as f64 > 0.0 {\n        (s * (s - a as f64) * (s - b as f64) * (s - c\
    \ as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a + b > c && a\
    \ + c > b && b + c > a {\n        let mut side = [a, b, c];\n        side.sort();\n\
    \        let p = (side[0] + side[1] + side[2]) as f64 / 2.0;\n        p.sqrt()\
    \ * (p - side[0] as f64) * (p - side[1] as f64) * (p - side[2] as f64)\n    }\
    \ else {\n        -1.0\n    }", "    let mut res = -1.0;\n    let mut args = vec![a,\
    \ b, c];\n    args.sort();\n    if args[0] + args[1] > args[2] {\n        res\
    \ = (0.5 * args[0] as f64 * args[1] as f64).sqrt();\n    }\n    res", "    if\
    \ a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n    let\
    \ s = (a + b + c) as f64 / 2.0;\n    let area = s * (s - a as f64) * (s - b as\
    \ f64) * (s - c as f64);\n    return area.sqrt();", "    let mut sides = vec![a,\
    \ b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n       \
    \ let p = (a + b + c) as f64;\n        let p = p / 2.0;\n        let mut a = p\
    \ * (p - a as f64) * (p - b as f64) * (p - c as f64);\n        a = a.sqrt();\n\
    \        a = a * 100.0;\n        a = (a + 0.5) as isize as f64;\n        a = a\
    \ / 100.0;\n        return a;\n    }\n    -1.0", "    if a <= 0 || b <= 0 || c\
    \ <= 0 {\n        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n\
    \    let area = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \    area.round() / 100.0", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    let a = sides[0] as f64;\n    let b = sides[1] as f64;\n    let c = sides[2]\
    \ as f64;\n    if a + b > c {\n        let s = (a + b + c) / 2.0;\n        (s\
    \ * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", " \
    \   if a + b <= c || a + c <= b || b + c <= a { -1.0 }\n    else {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    }", "    let (a, b, c) = (a as f64, b as f64,\
    \ c as f64);\n    let s = (a + b + c) / 2.;\n    let area = s * (s - a) * (s -\
    \ b) * (s - c);\n    if area <= 0. {\n        -1.\n    } else {\n        area.sqrt()\n\
    \    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0]\
    \ + sides[1] > sides[2] {\n        let s = (sides[0] + sides[1] + sides[2]) as\
    \ f64 / 2.0;\n        return (s * (s - sides[0] as f64) * (s - sides[1] as f64)\
    \ * (s - sides[2] as f64)).sqrt();\n    }\n    -1.0", "    if a + b > c && a +\
    \ c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2f64;\n        let\
    \ area = f64::sqrt(s * (s - a as f64) * (s - b as f64) * (s - c as f64));\n  \
    \      area.round() / 100f64\n    } else {\n        -1f64\n    }", "    // Validate\
    \ arguments\n    if a < 0 || b < 0 || c < 0 {\n        return -1.0;\n    }\n \
    \   // Validate triangle\n    if a + b <= c || a + c <= b || b + c <= a {\n  \
    \      return -1.0;\n    }\n    // Compute p\n    let p = (a + b + c) as f64 /\
    \ 2.0;\n    // Compute area\n    let area = (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt();\n    // Return value\n    area", "    // https://www.mathopenref.com/heronsformula.html\n\
    \    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as\
    \ f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a <= 0 || b <= 0 || c <= 0 {\n  \
    \      return -1.0;\n    }\n\n    if (a + b) <= c || (a + c) <= b || (b + c) <=\
    \ a {\n        return -1.0;\n    }\n\n    let p = (a + b + c) as f64 / 2.0;\n\
    \    ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0", "    if a > 0 && b > 0 && c > 0 && \n        a + b > c && a + c >\
    \ b && b + c > a {\n            let s = (a + b + c) as f64 / 2.0;\n          \
    \  let s = s.powf(2.0) - a as f64 * a as f64 - b as f64 * b as f64 - c as f64\
    \ * c as f64;\n            s.sqrt() * 0.25\n        } else {\n            -1.0\n\
    \        }", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    if a +\
    \ b > c && a + c > b && b + c > a {\n        let s = (a + b + c) / 2.0;\n    \
    \    (s * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n  \
    \  }", "    let s = (a + b + c) as f64 / 2f64;\n    let val = s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64);\n    if val > 0f64 {\n        val.sqrt()\n\
    \    } else {\n        -1f64\n    }", "    if (a + b > c) && (a + c > b) && (b\
    \ + c > a) {\n        let perimeter = (a + b + c) as f64;\n        let s = perimeter\
    \ / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    // let mut v = vec![a, b, c];\n    //\
    \ v.sort();\n    // if v[0] + v[1] <= v[2] {\n    //     return -1.0;\n    //\
    \ }\n\n    let mut v = [a, b, c];\n    v.sort();\n    if v[0] + v[1] <= v[2] {\n\
    \        return -1.0;\n    }\n\n    let p = (a + b + c) as f64;\n    (p * (p -\
    \ a as f64) * (p - b as f64) * (p - c as f64)).sqrt() / 4.0", "    let mut sides\
    \ = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] <= sides[2]\
    \ {\n        return -1.0;\n    }\n    let sq = sides[0] + sides[1] + sides[2];\n\
    \    let area = ((sq * (sq - sides[0]) * (sq - sides[1]) * (sq - sides[2])) as\
    \ f64).sqrt() / 4.0;\n    area.round() / 100.0", "    let (a, b, c) = (a as f64,\
    \ b as f64, c as f64);\n    let s = (a + b + c) / 2.0;\n    if a + b > c && a\
    \ + c > b && b + c > a {\n        return s.sqrt() * (s - a) * (s - b) * (s - c);\n\
    \    }\n    -1.0", "  let mut result = -1f64;\n  if (a + b > c) && (a + c > b)\
    \ && (b + c > a) {\n    let s = (a + b + c) as f64 / 2f64;\n    result = (s *\
    \ (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n  }\n  result", " \
    \   let s = (a + b + c) as f64 / 2.0;\n    let area = s * (s - a as f64) * (s\
    \ - b as f64) * (s - c as f64);\n    if area <= 0.0 {\n        -1.0\n    } else\
    \ {\n        area.sqrt()\n    }", "    if a + b > c && a + c > b && b + c > a\
    \ {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) *\
    \ (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    // Solution: Compute the area using Heron's formula\n    // https://en.wikipedia.org/wiki/Heron%27s_formula\n\
    \    let s = (a + b + c) as f64 / 2.0;\n    let area = ((s * (s - a as f64) *\
    \ (s - b as f64) * (s - c as f64)).sqrt()) * 100.0;\n    (area / 100.0).round()\
    \ / 100.0", "    // Given three sides of a triangle\n    let mut sides = vec![a,\
    \ b, c];\n    sides.sort();\n\n    let side_a = sides[0] as f64;\n    let side_b\
    \ = sides[1] as f64;\n    let side_c = sides[2] as f64;\n\n    // Determine if\
    \ valid triangle\n    let valid_triangle = side_a + side_b > side_c;\n\n    if\
    \ valid_triangle {\n        // Determine area of triangle\n        let s = (side_a\
    \ + side_b + side_c) / 2.0;\n        let area = (s * (s - side_a) * (s - side_b)\
    \ * (s - side_c)).sqrt();\n        area\n    } else {\n        -1.0\n    }", " \
    \   let perim = a + b + c;\n    if perim == 0 { return -1.0; }\n    let semiperim\
    \ = perim as f64 / 2.0;\n    let p = semiperim * (semiperim - a as f64) * (semiperim\
    \ - b as f64) * (semiperim - c as f64);\n    if p < 0.0 { return -1.0; }\n   \
    \ p.sqrt()", "    let mut area: f64 = -1.0;\n    let mut sides: Vec<isize> = vec![a,\
    \ b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n       \
    \ area = (f64::from(sides[0]) + f64::from(sides[1]) + f64::from(sides[2])) / 2.0;\n\
    \        area = (area * (area - f64::from(sides[0])) * (area - f64::from(sides[1]))\
    \ * (area - f64::from(sides[2]))).sqrt();\n    }\n    return area;", "    if a\
    \ + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\n    let\
    \ s = (a + b + c) as f64 / 2.0;\n    (s * (s - a as f64) * (s - b as f64) * (s\
    \ - c as f64)).sqrt()", "    if (a + b > c) && (a + c > b) && (b + c > a) {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        let s = (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt();\n        s\n    } else {\n      \
    \  -1.0\n    }", "    if (a + b > c) && (a + c > b) && (b + c > a) {\n       \
    \ (a as f64 * b as f64 * c as f64).sqrt() / 4.0\n    } else {\n        -1.0\n\
    \    }", "    let x = (a + b + c) as f64 / 2.0;\n    let a = x - a as f64;\n \
    \   let b = x - b as f64;\n    let c = x - c as f64;\n    let area = (x * a *\
    \ b * c).sqrt();\n    if area > 0.0 { area } else { -1.0 }", "    if a + b > c\
    \ && a + c > b && b + c > a {\n        let s = 0.5 * (a + b + c) as f64;\n   \
    \     (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "    let perim: isize = a + b + c;\n    let s: f64\
    \ = perim as f64 / 2.0;\n    let area: f64 = (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt();\n    if area.is_nan() { -1.0 } else { area }", " \
    \   //let v = vec![a, b, c];\n    //let mut v = vec![a, b, c];\n    //v.sort();\n\
    \    //let mut v = vec![a, b, c].sort();\n    //let v = vec![a, b, c].sort();\n\
    \    //let v = vec![a, b, c].sort_by(|a, b| a.cmp(b));\n    //let v = vec![a,\
    \ b, c].sort_by(|a, b| a.cmp(b));\n    //let mut v = vec![a, b, c].sort_by(|a,\
    \ b| a.cmp(b));\n    //let mut v = vec![a, b, c].sort_by(|a, b| a.cmp(b));\n \
    \   //let mut v = vec![a, b, c].sort_by(|a, b| a.cmp(b));\n    //let mut v = vec![a,\
    \ b, c].sort_by(|a, b| a.cmp(b));\n    //let mut v = vec![a, b, c].sort_by(|a,\
    \ b| a.cmp(b));\n    //let mut v = vec![a, b, c].sort_by(|a, b| a.cmp(b));\n \
    \   //let mut v = vec![a, b, c].sort_by(|a, b| a.cmp(b));\n    //let mut v = vec![a,\
    \ b, c].sort_by(|a, b| a.cmp(b));\n    //let mut v = vec![a, b, c].sort_by(|a,\
    \ b| a.cmp(b));\n    //let mut v = vec![a, b, c].sort_by(|a, b| a.cmp(b));\n \
    \   //let mut v = vec![a, b, c].sort_by(|a, b| a.cmp(b));\n    //let mut v = vec![a,\
    \ b, c].sort_by(|a, b| a.cmp(b));\n    //let mut v =", "    if a + b <= c || a\
    \ + c <= b || b + c <= a {\n        return -1f64;\n    }\n\n    let p = (a + b\
    \ + c) as f64 / 2f64;\n    ((p - a as f64) * (p - b as f64) * (p - c as f64) *\
    \ p).sqrt()", "    if a + b > c && a + c > b && b + c > a {\n        let s = (a\
    \ + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s -\
    \ c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let p = (a + b +\
    \ c) as f64 / 2.0;\n    if p * (p - a as f64) * (p - b as f64) * (p - c as f64)\
    \ < 0.0 {\n        -1.0\n    } else {\n        (p * (p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt()\n    }", "    let mut sides = vec![a, b, c];\n\
    \    sides.sort();\n    let (a, b, c) = (sides[0], sides[1], sides[2]);\n    if\
    \ (a + b) > c {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p -\
    \ a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let s = (a + b + c) as f64 / 2.0;\n    if s - a as f64 > 0.0 &&\
    \ s - b as f64 > 0.0 && s - c as f64 > 0.0 {\n        (s * (s - a as f64) * (s\
    \ - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", " \
    \   let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1]\
    \ <= sides[2] {\n        return -1.0;\n    }\n\n    let p = (a + b + c) as f64\
    \ / 2.0;\n    let s = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \    return s.round() / 100.0;", "    // for all a, b, c in R+,\n    // area(a,\
    \ b, c) = sqrt(s * (s - a) * (s - b) * (s - c))\n    // where s = (a + b + c)\
    \ / 2\n    let s = (a + b + c) as f64 / 2.0;\n    if a > 0 && b > 0 && c > 0 &&\
    \ s > a as f64 && s > b as f64 && s > c as f64 {\n        ((s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else\
    \ {\n        -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n    let area\
    \ = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if area.is_finite()\
    \ {\n        return area;\n    }\n    -1.0", "    let s = (a + b + c) as f64 /\
    \ 2.0;\n    let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n\
    \    if area > 0.0 { area } else { -1.0 }", "    if a > 0 && b > 0 && c > 0 &&\
    \ a + b > c && a + c > b && b + c > a {\n        (a as f64 * b as f64 / 2.0).round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "    let mut output: f64 = -1.0;\n\
    \    if a <= 0 || b <= 0 || c <= 0 {\n        return output;\n    }\n\n    let\
    \ mut max = a;\n    let mut sides = vec![a, b, c];\n    sides.sort();\n    max\
    \ = sides[2];\n    let min = sides[0];\n    let mid = sides[1];\n    if min +\
    \ mid > max {\n        let p = (min + mid + max) as f64 / 2.0;\n        output\
    \ = (p * (p - min as f64) * (p - mid as f64) * (p - max as f64)).sqrt();\n   \
    \ }\n    return output;", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n\
    \    let s = (a + b + c) / 2.0;\n    let area = (s * (s - a) * (s - b) * (s -\
    \ c)).sqrt();\n    if area > 0.0 {\n        area\n    } else {\n        -1.0\n\
    \    }", "    let sides = [a, b, c];\n    if sides.iter().any(|&x| x < 0) {\n\
    \        return -1.0;\n    }\n    let mut sides = sides.clone();\n    sides.sort();\n\
    \    let (a, b, c) = (sides[0], sides[1], sides[2]);\n    if a + b < c {\n   \
    \     return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    (p * (p\
    \ - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    let s = (a + b\
    \ + c) as f64 / 2.0;\n    let area = (s * (s - a as f64) * (s - b as f64) * (s\
    \ - c as f64)).sqrt();\n    if a + b > c && a + c > b && b + c > a {\n       \
    \ format!(\"{:.2}\", area).parse::<f64>().unwrap()\n    } else {\n        -1.0\n\
    \    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0]\
    \ + sides[1] > sides[2] {\n        let s = (sides[0] + sides[1] + sides[2]) as\
    \ f64 / 2.0;\n        (s * (s - sides[0] as f64) * (s - sides[1] as f64) * (s\
    \ - sides[2] as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let s =\
    \ (a + b + c) as f64 / 2.0;\n    let temp = s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64);\n    let area = if temp > 0.0 { temp.sqrt() } else { 0.0 };\n\
    \    return area.round() / 100.0;", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n\
    \    if a + b > c && a + c > b && b + c > a {\n        return (s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt();\n    }\n    -1.0", "    let mut sides\
    \ = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        let area = p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64);\n        area.sqrt()\n    } else {\n    \
    \    -1.0\n    }", '    unimplemented!()', "    let mut abc = vec![a, b, c];\n\
    \    abc.sort();\n    let a = abc[0] as f64;\n    let b = abc[1] as f64;\n   \
    \ let c = abc[2] as f64;\n    if a + b > c {\n        let p = (a + b + c) / 2.0;\n\
    \        (p * (p - a) * (p - b) * (p - c)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let mut result = -1f64;\n    let mut sides = vec![a, b, c];\n  \
    \  sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        result = (a\
    \ + b + c) as f64 / 2f64;\n        result = (result * (result - sides[0] as f64)\
    \ * (result - sides[1] as f64) * (result - sides[2] as f64)).sqrt();\n    }\n\
    \    result", "  let mut triangle_sides = vec![a, b, c];\n  triangle_sides.sort();\n\
    \  if triangle_sides[0] + triangle_sides[1] > triangle_sides[2] {\n    let p =\
    \ (a + b + c) as f64 / 2.0;\n    return (p * (p - a as f64) * (p - b as f64) *\
    \ (p - c as f64)).sqrt();\n  }\n  -1.0", "    let s = (a+b+c) as f64 / 2.0;\n\
    \    if s*(s-a as f64)*(s-b as f64)*(s-c as f64) > 0.0 {\n        ((s*(s-a as\
    \ f64)*(s-b as f64)*(s-c as f64)).sqrt() * 2.0 / 3.0).round() / 100.0\n    } else\
    \ {\n        -1.0\n    }", "    if a > 0 && b > 0 && c > 0 && a + b > c && a +\
    \ c > b && b + c > a {\n        let p = (a + b + c) as f64 / 2.0;\n        let\
    \ s = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n        (s.sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    let s = (a\
    \ + b + c) as f64 / 2f64;\n    let a = (s * (s - a as f64) * (s - b as f64) *\
    \ (s - c as f64)).sqrt();\n    if a.is_nan() {\n        -1f64\n    } else {\n\
    \        a\n    }", "    let p = (a + b + c) as f64 / 2.0;\n    let s = p * (p\
    \ - a as f64) * (p - b as f64) * (p - c as f64);\n    if s <= 0.0 { -1.0 } else\
    \ { s.sqrt() }", "    let mut result = -1.0;\n    let sides = [a, b, c];\n   \
    \ let mut max = 0;\n    let mut sum = 0;\n    for i in 0..3 {\n        if sides[i]\
    \ > max {\n            max = sides[i];\n        }\n        sum += sides[i];\n\
    \    }\n    if sum > 2 * max {\n        result = (sum as f64 / 2.0) * ((sum as\
    \ f64 / 2.0) - a as f64) * ((sum as f64 / 2.0) - b as f64) * ((sum as f64 / 2.0)\
    \ - c as f64);\n        result = result.sqrt();\n    }\n    result", "    if a\
    \ > 0 && b > 0 && c > 0 && a + b > c && a + c > b && b + c > a {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        let area = (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt();\n        return area.round() / 100.0;\n\
    \    }\n    -1.0", "  match (a + b > c, a + c > b, b + c > a) {\n    (true, true,\
    \ true) => {\n      let s = (a + b + c) as f64 / 2.0;\n      (s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64)).sqrt()\n    },\n    _ => -1.0\n  }", "  \
    \  let (a, b, c) = (a as f64, b as f64, c as f64);\n    let (s, p) = (a + b +\
    \ c, a * b * c);\n    if a + b > c && b + c > a && a + c > b {\n        (s * (s\
    \ - 2.0 * a) * (s - 2.0 * b) * (s - 2.0 * c)).sqrt() / 4.0\n    } else {\n   \
    \     -1.0\n    }", "    if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n\
    \    }\n\n    let mut arr = [a, b, c];\n    arr.sort();\n\n    if arr[0] + arr[1]\
    \ <= arr[2] {\n        return -1.0;\n    }\n\n    let p = (a + b + c) as f64 /\
    \ 2.0;\n    ((p - a as f64) * (p - b as f64) * (p - c as f64) * p).sqrt()", " \
    \   let h = a.max(b).max(c);\n    let mut s = (a + b + c) / 2;\n    if s - h >\
    \ h {\n        (s - h) as f64 * h as f64 * 2.0_f64.sqrt()\n    } else {\n    \
    \    -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n        let\
    \ s = (a + b + c) as f64 / 2.0;\n        let area = s * (s - a as f64) * (s -\
    \ b as f64) * (s - c as f64);\n        return (area.sqrt() * 100.0).round() /\
    \ 100.0;\n    }\n    -1.0", "    let f32_a = a as f32;\n    let f32_b = b as f32;\n\
    \    let f32_c = c as f32;\n    let p = 0.5 * (f32_a + f32_b + f32_c);\n    let\
    \ s = p * (p - f32_a) * (p - f32_b) * (p - f32_c);\n    if s <= 0.0 {\n      \
    \  -1.0\n    } else {\n        (s.sqrt() * 100.0).round() / 100.0\n    }", " \
    \   let mut sides = vec![a, b, c];\n    sides.sort();\n    let [a, b, c] = sides.as_slice();\n\
    \    if a + b <= c {\n        -1.0\n    } else {\n        let p = (a + b + c)\
    \ as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    }", "    // With Heron's formula\n    if !(a > 0 && b > 0 && c > 0) {\n \
    \       return -1.0;\n    }\n    if a + b <= c || a + c <= b || b + c <= a {\n\
    \        return -1.0;\n    }\n    let s = (a + b + c) as f64 / 2.0;\n    ((s *\
    \ (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt() * 100.0).round() /\
    \ 100.0", "    let s = (a + b + c) as f64 / 2.0;\n    let valid = s > a as f64\
    \ && s > b as f64 && s > c as f64;\n    if valid {\n        let area = s * (s\
    \ - a as f64) * (s - b as f64) * (s - c as f64);\n        return (area.sqrt()\
    \ * 100.0).round() / 100.0;\n    }\n    -1.0", "    if a <= 0 || b <= 0 || c <=\
    \ 0 {\n        return -1.0;\n    }\n    let p = (a as f64 + b as f64 + c as f64)\
    \ / 2.0;\n    ((p - a as f64) * (p - b as f64) * (p - c as f64) * p).sqrt()",
  "    let mut t = (a, b, c);\n    t.0 = t.0 * 100;\n    t.1 = t.1 * 100;\n    t.2\
    \ = t.2 * 100;\n    let mut s = (t.0 + t.1 + t.2) as f64 / 2.0;\n    if t.0 +\
    \ t.1 > t.2 && t.0 + t.2 > t.1 && t.1 + t.2 > t.0 {\n        s = (s * (s - t.0\
    \ as f64) * (s - t.1 as f64) * (s - t.2 as f64)).sqrt();\n        (s / 100.0).round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "  if (a + b) <= c || (a + c) <=\
    \ b || (b + c) <= a {\n    return -1.0;\n  }\n\n  let p = (a + b + c) as f64 /\
    \ 2.0;\n  (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "  \
    \  let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1]\
    \ > sides[2] {\n        let (a, b, c) = (sides[0] as f64, sides[1] as f64, sides[2]\
    \ as f64);\n        (a * b * c).sqrt() / 4.0\n    } else {\n        -1.0\n   \
    \ }", "    let x = a as f64;\n    let y = b as f64;\n    let z = c as f64;\n \
    \   let p = (x + y + z) / 2.0;\n    if a + b > c && a + c > b && b + c > a {\n\
    \        ((p * (p - x) * (p - y) * (p - z)).sqrt() * 100.0).round() / 100.0\n\
    \    } else {\n        -1.0\n    }", "    let sum = a + b + c;\n    if a < 0 ||\
    \ b < 0 || c < 0 || sum <= 0 {\n        return -1.0;\n    }\n\n    let p = sum\
    \ as f64 / 2.0;\n    let area = (p * (p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt();\n    area.round() / 100.0", "    if a + b > c && a + c > b\
    \ && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s -\
    \ a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let mut v = vec![a, b, c];\n    v.sort();\n    let (a, b, c) = (v[0],\
    \ v[1], v[2]);\n    if a + b <= c {\n        return -1.0;\n    }\n    let p =\
    \ (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt()", "    let s = (a + b + c) as f64 / 2.0;\n    let area = (s\
    \ * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if area.is_nan()\
    \ {\n        -1.0\n    } else {\n        area\n    }", "    let p = (a + b + c)\
    \ as f64 / 2.0;\n    if p <= a as f64 || p <= b as f64 || p <= c as f64 {\n  \
    \      return -1.0;\n    }\n    ((p * (p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt() * 100.0).round() / 100.0", "    let mut sides = vec![a, b, c];\n\
    \    sides.sort();\n    let [small, mid, large] = sides.as_slice();\n    if large\
    \ < small + mid {\n        let s = (*small + *mid + *large) as f64 / 2.0;\n  \
    \      (s * (s - *small as f64) * (s - *mid as f64) * (s - *large as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n\
    \    let x = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    if x <\
    \ 0.0 {\n        -1.0\n    } else {\n        x.sqrt()\n    }", "    let mut sides\
    \ = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  \
    \  if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n\n    let p =\
    \ (a + b + c) as f64 / 2.0;\n    let area = (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt();\n    area.round() / 100.0", "    let mut arr: [isize;\
    \ 3] = [a, b, c];\n    arr.sort();\n    if arr[0] + arr[1] > arr[2] {\n      \
    \  return ((arr[0] + arr[1] + arr[2]) as f64 / 2.0).sqrt() * ((arr[2] as f64 -\
    \ (arr[0] + arr[1]) as f64 / 2.0).abs()).sqrt() * 2.0;\n    }\n    return -1.0;",
  "    let mut len = [a, b, c];\n    len.sort();\n    if len[0] + len[1] > len[2]\
    \ {\n        let p = (len[0] + len[1] + len[2]) as f64 / 2.0;\n        (p * (p\
    \ - len[0] as f64) * (p - len[1] as f64) * (p - len[2] as f64)).sqrt()\n    }\
    \ else {\n        -1.0\n    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        let area = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n\
    \        (area.sqrt() * 100.0).round() / 100.0\n    } else {\n        -1.0\n \
    \   }"]
stop_tokens:
- "\n}"
