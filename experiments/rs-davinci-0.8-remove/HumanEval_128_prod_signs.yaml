name: HumanEval_128_prod_signs
language: rs
prompt: "/// You are given an array arr of integers and you need to return\n/// sum\
  \ of magnitudes of integers multiplied by product of all signs\n/// of each number\
  \ in the array, represented by 1, -1 or 0.\n/// Note: return None for empty arr.\n\
  /// >>> prod_signs([1, 2, 2, -4]) \n/// 9\nfn prod_signs(arr: Vec<isize>) -> Option<isize>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = prod_signs;\n    assert_eq!(candidate(vec![1,\
  \ 2, 2, -4]), Some(-9));\n    assert_eq!(candidate(vec![0, 1]), Some(0));\n    assert_eq!(candidate(vec![1,\
  \ 1, 1, 2, 3, -1, 1]), Some(-10));\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ None);\n    assert_eq!(candidate(vec![2, 4, 1, 2, -1, -1, 9]), Some(20));\n  \
  \  assert_eq!(candidate(vec![-1, 1, -1, 1]), Some(4));\n    assert_eq!(candidate(vec![-1,\
  \ 1, 1, 1]), Some(-4));\n    assert_eq!(candidate(vec![-1, 1, 1, 0]), Some(0));\n\
  }\n"
completions: ["    arr.iter().fold(None, |acc, num| {\n        let sign = num.signum();\n\
    \        Some(acc.unwrap_or(1) * sign * num.abs())\n    })", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum:\
    \ isize = 0;\n    for i in arr {\n        if i < 0 {\n            prod *= -1;\n\
    \        } else if i > 0 {\n            sum += i;\n        }\n    }\n    Some(sum\
    \ * prod)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut\
    \ sum = 0;\n    let mut product = 1;\n    for num in arr {\n        sum += num.abs();\n\
    \        product *= num.signum();\n    }\n    Some(sum * product)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for a in arr {\n        if a > 0 {\n            prod *= 1;\n        } else\
    \ if a < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += a.abs();\n    }\n    Some(sum * prod)", "    match\
    \ arr.is_empty() {\n        true => None,\n        false => {\n            let\
    \ sign_product = arr.iter().fold(1, |acc, &x| {\n                acc * match x.signum()\
    \ {\n                    1 => 1,\n                    -1 => -1,\n            \
    \        _ => 0,\n                }\n            });\n            let sum_of_magnitudes\
    \ = arr.iter().fold(0, |acc, &x| acc + x.abs());\n            Some(sign_product\
    \ * sum_of_magnitudes)\n        }\n    }", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    Some(arr.iter().fold(1, |acc, &x| acc * x.signum()) * arr.iter().map(|&x|\
    \ x.abs()).sum::<isize>())", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for elem in arr {\n \
    \       match elem.cmp(&0) {\n            Ordering::Greater => {\n           \
    \     prod *= 1;\n                sum += elem.abs();\n            },\n       \
    \     Ordering::Less => {\n                prod *= -1;\n                sum +=\
    \ elem.abs();\n            },\n            Ordering::Equal => (),\n        }\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for &i in arr.iter()\
    \ {\n        prod *= signum(i);\n        sum += abs(i);\n    }\n    Some(sum *\
    \ prod)", "    let mut sum: isize = 0;\n    let mut product: isize = 1;\n    if\
    \ arr.len() == 0 {\n        return None;\n    }\n    for i in arr {\n        if\
    \ i < 0 {\n            product *= -1;\n        }\n        sum += i.abs();\n  \
    \  }\n    Some(sum * product)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut x: isize = 0;\n    let mut y: isize = 1;\n    for i in arr\
    \ {\n        if i > 0 {\n            x += i;\n        } else if i < 0 {\n    \
    \        y *= -1;\n            x += i.abs();\n        }\n    }\n    Some(x * y)",
  '    unimplemented!()', "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let mut prod = 1;\n    let mut res = 0;\n    for elem in arr {\n        prod\
    \ *= (elem > 0) as isize - (elem < 0) as isize;\n        res += elem.abs();\n\
    \    }\n    Some(res * prod)", "    // TODO complete\n    if arr.len() == 0 {\n\
    \        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n  \
    \  for num in arr {\n        if num == 0 {\n            continue;\n        }\n\
    \        prod *= num.signum();\n        sum += num.abs();\n    }\n    Some(sum\
    \ * prod)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut\
    \ sum: isize = 0;\n    let mut sign_prod: isize = 1;\n    for x in arr {\n   \
    \     sum += x.abs();\n        sign_prod *= x.signum();\n    }\n    Some(sum *\
    \ sign_prod)", '    unimplemented!();', "    match arr.is_empty() {\n        true\
    \ => None,\n        false => {\n            Some(arr.iter().fold(1, |acc, n| acc\
    \ * n.signum()) * arr.iter().fold(0, |acc, n| acc + n.abs()))\n        }\n   \
    \ }", "    // TODO\n    None", "    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else\
    \ if i < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ { return None; }\n    let prod_of_signs = arr.iter().map(|&num| num.signum()).product();\n\
    \    Some(arr.iter().map(|&num| num.abs()).sum::<isize>() * prod_of_signs)", " \
    \   if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n\
    \    let mut sum = 0;\n    for x in arr {\n        if x == 0 {\n            prod\
    \ = 0;\n        } else {\n            prod *= x.signum();\n            sum +=\
    \ x.abs();\n        }\n    }\n    Some(sum * prod)", "    if arr.is_empty() {\n\
    \        return None;\n    }\n    let sum = arr.iter().map(|x| if *x > 0 { 1 }\
    \ else if *x < 0 { -1 } else { 0 }).fold(1, |acc, x| acc * x);\n    Some(arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * sum)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut sign_prod = 1;\n    let mut mag_sum = 0;\n    for x in arr\
    \ {\n        if x > 0 {\n            sign_prod *= 1;\n        } else if x < 0\
    \ {\n            sign_prod *= -1;\n        } else {\n            sign_prod *=\
    \ 0;\n        }\n        mag_sum += x.abs();\n    }\n    Some(sign_prod * mag_sum)",
  "    // The main problem is to find product of signs. If there is at least\n   \
    \ // one 0, then the product is 0. Otherwise, we need to count number of\n   \
    \ // positive and negative signs. If they have different parity, then the\n  \
    \  // product is -1, otherwise it is 1.\n    match arr.is_empty() {\n        true\
    \ => None,\n        false => {\n            let mut sign = 1;\n            let\
    \ mut non_zero_counter = 0;\n            for number in arr {\n               \
    \ if number < 0 {\n                    sign *= -1;\n                }\n      \
    \          if number != 0 {\n                    non_zero_counter += 1;\n    \
    \            }\n            }\n            let mut sign_product = 1;\n       \
    \     if non_zero_counter == 0 {\n                sign_product = 0;\n        \
    \    } else if non_zero_counter % 2 == 0 {\n                sign_product = -1;\n\
    \            }\n            Some(sign * sign_product)\n        }\n    }", '    arr.iter().fold(None,
    |acc, x| Some(acc.unwrap_or(1) * abs(*x)))', "    if arr.is_empty() {\n      \
    \  return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for num\
    \ in arr {\n        prod *= if num == 0 { 0 } else if num > 0 { 1 } else { -1\
    \ };\n        sum += num.abs();\n    }\n    Some(sum * prod)", "    let mut result\
    \ = 1;\n    let mut sum = 0;\n    for i in arr {\n        result *= i.signum();\n\
    \        sum += i.abs();\n    }\n    if arr.len() == 0 {\n        None\n    }\
    \ else {\n        Some(result * sum)\n    }", "    let mut sum = 0;\n    let mut\
    \ prod = 1;\n    for n in arr {\n        sum += n.abs();\n        prod *= n.signum();\n\
    \    }\n    if arr.len() > 0 {\n        Some(sum * prod)\n    } else {\n     \
    \   None\n    }", "    match arr.is_empty() {\n        true => None,\n       \
    \ false => Some(arr.iter().fold(1, |acc, &x| acc * x.signum()) * arr.iter().fold(0,\
    \ |acc, &x| acc + x.abs())),\n    }", "    // map all the elements in the vector\
    \ to signs\n    // then multiply all the signs together\n    let signs = arr.iter().map(|x|\
    \ signum(*x));\n    let sign_product = signs.fold(Some(1), |a, b| \n        match\
    \ (a, b) {\n            (Some(a), Some(b)) => Some(a * b),\n            _ => None\n\
    \        }\n    );\n    // multiply the product of the signs by the sum of the\
    \ magnitudes\n    let magnitudes = arr.iter().map(|x| abs(*x));\n    let magnitude_sum\
    \ = magnitudes.fold(Some(0), |a, b| \n        match (a, b) {\n            (Some(a),\
    \ Some(b)) => Some(a + b),\n            _ => None\n        }\n    );\n    // return\
    \ the result\n    match (sign_product, magnitude_sum) {\n        (Some(p), Some(m))\
    \ => Some(p * m),\n        _ => None\n    }", "    if arr.is_empty() {\n     \
    \   return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if i\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ { return None; }\n    let mut result = 1;\n    for i in arr {\n        result\
    \ *= i.signum();\n    }\n    Some(arr.iter().map(|&x| x.abs()).sum::<isize>()\
    \ * result)", '    unimplemented!()', "    let mut prod = 1;\n    let mut sum\
    \ = 0;\n    for i in arr {\n        match i {\n            i if i > 0 => {\n \
    \               prod *= 1;\n                sum += i;\n            }\n       \
    \     i if i < 0 => {\n                prod *= -1;\n                sum += i.abs();\n\
    \            }\n            i if i == 0 => {\n                prod *= 0;\n   \
    \             sum += 0;\n            }\n            _ => {\n                sum\
    \ += 0;\n            }\n        }\n    }\n    if sum == 0 {\n        None\n  \
    \  } else {\n        Some(sum * prod)\n    }", "    if arr.is_empty() {\n    \
    \    return None;\n    }\n    let mut total = 1;\n    for &x in arr.iter() {\n\
    \        total *= (x < 0) as isize;\n    }\n    Some(arr.iter().map(|&x| (x.abs()\
    \ as isize) * total).sum())", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut p = 1;\n    let mut s = 0;\n    for i in arr {\n        p\
    \ *= (i / i.abs() as isize);\n        s += i.abs();\n    }\n    Some(p * s)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let (prod, sum) = arr.iter().fold((1,\
    \ 0), |(prod, sum), &n| {\n        (prod * n.signum(), sum + n.abs())\n    });\n\
    \    Some(prod * sum)", "    let mut sum: isize = 0;\n    let mut prod: isize\
    \ = 1;\n    for i in arr {\n        if i < 0 {\n            prod *= -1;\n    \
    \    }\n        if i != 0 {\n            sum += i.abs();\n        }\n    }\n \
    \   if sum == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut result = 1;\n\
    \    for num in arr {\n        result *= signum(num);\n    }\n    Some(arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * result)", "    // TODO: Implement\n    None", "  \
    \  let mut value = 1;\n    let mut magnitude = 0;\n    for i in arr {\n      \
    \  if i == 0 {\n            continue;\n        }\n        value *= (i / i.abs());\n\
    \        magnitude += i.abs();\n    }\n    if magnitude == 0 {\n        return\
    \ None;\n    }\n    Some(value * magnitude)", "    if arr.is_empty() {\n     \
    \   return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        sum += i.abs();\n        prod *= (i as f64 / i.abs() as\
    \ f64).round() as isize;\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut sum: isize = 0;\n    let mut n:\
    \ isize = 1;\n    for i in arr {\n        sum += i.abs();\n        n *= i.signum();\n\
    \    }\n    return Some(sum * n);", "    // YOUR CODE HERE\n    if arr.len() ==\
    \ 0 {\n        return None;\n    }\n    let mut sum = 0;\n    let mut prod = 1;\n\
    \    for a in arr {\n        if a != 0 {\n            sum += a.abs();\n      \
    \      prod *= a.signum();\n        }\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for x in arr {\n        if x > 0 {\n            prod *= 1;\n        } else\
    \ if x < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += x.abs();\n    }\n    Some(sum * prod)", "    arr.iter().fold(None,\
    \ |sum, v| {\n        let (sign, magnitude) = sign_and_magnitude(*v);\n      \
    \  match sum {\n            None => Some(sign * magnitude),\n            Some(x)\
    \ => Some(x * sign * magnitude),\n        }\n    })", "    if arr.is_empty() {\n\
    \        return None;\n    }\n    let prod_signs = arr.iter().fold(0, |acc, &val|\
    \ if val > 0 {\n        acc + 1\n    } else if val < 0 {\n        acc - 1\n  \
    \  } else {\n        acc\n    });\n    Some(arr.iter().fold(0, |acc, &val| acc\
    \ + (val * prod_signs.abs())))", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let prod = arr.iter().map(|&x| (x.abs(), x.signum())).fold((1, 1),\
    \ |(s, p), (m, n)| (s * m, p * n));\n    return Some(prod.0 * prod.1);", "   \
    \ if arr.is_empty() {\n        return None;\n    }\n    let mut res = 1;\n   \
    \ for a in arr {\n        res *= if a < 0 { -1 } else if a > 0 { 1 } else { 0\
    \ };\n    }\n    Some(arr.iter().map(|a| a.abs()).sum::<isize>() * res)", "  \
    \  arr.iter().fold(Some(1), |acc, &n| {\n        if let Some(acc) = acc {\n  \
    \          if n == 0 {\n                Some(acc * 1)\n            } else if n\
    \ > 0 {\n                Some(acc * 1)\n            } else {\n               \
    \ Some(acc * -1)\n            }\n        } else {\n            None\n        }\n\
    \    })", "    // Your code here!\n    None", "    match arr.len() {\n       \
    \ 0 => None,\n        _ => {\n            let mut s = 0;\n            let mut\
    \ p = 1;\n            for i in arr {\n                s += i.abs();\n        \
    \        p *= i.signum();\n            }\n            Some(s * p)\n        }\n\
    \    }", "    let mut res = None;\n    if arr.len() == 0 {\n        res = None;\n\
    \    } else {\n        let mut sign_prod = 1;\n        let mut sum_magnitudes\
    \ = 0;\n        for num in arr {\n            if num < 0 {\n                sign_prod\
    \ *= -1;\n            } else if num == 0 {\n                sign_prod = 0;\n \
    \           }\n            sum_magnitudes += num.abs();\n        }\n        res\
    \ = Some(sum_magnitudes * sign_prod);\n    }\n    res", "    let mut sum = 0;\n\
    \    for x in arr {\n        sum += x.abs() * x.signum();\n    }\n    Some(sum)",
  "    let mut prod = 1;\n    let mut sum: isize = 0;\n    for item in arr {\n   \
    \     if item < 0 {\n            prod *= -1;\n        }\n        sum += item.abs();\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    Some(arr.iter().map(|&x| (x.abs() as isize) * (x.signum() as isize)).sum())",
  "    if arr.is_empty() {\n        return None;\n    }\n    let sum = arr.iter().fold(0,\
    \ |acc, x| acc + (x * x));\n    let prod = arr.iter().fold(1, |acc, x| acc * ((*x\
    \ > 0) as isize - (*x < 0) as isize));\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    Some(arr.iter().fold(1, |prod, num| prod\
    \ * num.signum())\n             * arr.iter().map(|num| num.abs()).sum::<isize>())",
  "    // your code here\n    let mut prod = 1;\n    let mut sum = 0;\n    for x in\
    \ arr {\n        prod *= x.signum();\n        sum += x.abs();\n    }\n    match\
    \ prod {\n        0 => None,\n        _ => Some(sum*prod),\n    }", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n\
    \    let prod = arr.iter().map(|x| x.signum()).product::<isize>();\n    Some(sum\
    \ * prod)", "    let mut prod = 1;\n    let mut mag = 0;\n    for x in arr {\n\
    \        if x == 0 {\n            prod *= 0;\n        } else if x > 0 {\n    \
    \        prod *= 1;\n            mag += x;\n        } else {\n            prod\
    \ *= -1;\n            mag += x.abs();\n        }\n    }\n    if arr.len() == 0\
    \ {\n        None\n    } else {\n        Some(prod * mag)\n    }", '    unimplemented!()',
  '    unimplemented!();', "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let mut n: isize = 1;\n    let mut p: isize = 0;\n    for x in arr {\n  \
    \      if x == 0 {\n            continue;\n        }\n        if x < 0 {\n   \
    \         n *= -1;\n        }\n        p += x.abs();\n    }\n    Some(p * n)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut product = 1;\n\
    \    let mut result = 0;\n    for number in arr {\n        if number > 0 {\n \
    \           product *= 1;\n        } else if number < 0 {\n            product\
    \ *= -1;\n        } else {\n            product *= 0;\n        }\n        result\
    \ += number.abs();\n    }\n    Some(result * product)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut signs: isize = 1;\n    let mut sum:\
    \ isize = 0;\n    for i in arr {\n        if i == 0 {\n            signs = 0;\n\
    \        } else if i < 0 {\n            signs *= -1;\n        }\n        sum +=\
    \ i.abs();\n    }\n    Some(sum * signs)", "    let mut prod = 1;\n    let mut\
    \ sum = 0;\n    if arr.len() == 0 {\n        return None;\n    }\n    for i in\
    \ arr {\n        if i > 0 {\n            prod *= 1;\n        } else if i < 0 {\n\
    \            prod *= -1;\n        } else {\n            prod *= 0;\n        }\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)", "    arr.iter().fold(Some(1),\
    \ |acc, &x| match (acc, x) {\n        (Some(a), b) if b != 0 => Some(a * b.signum()),\n\
    \        _ => None\n    })", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut product = 1;\n    let mut sum = 0;\n    for i in arr {\n \
    \       let s = i.signum();\n        product *= s;\n        sum += i.abs();\n\
    \    }\n    Some(sum * product)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut result = 1;\n    for i in arr {\n        if i < 0 {\n    \
    \        result *= -1;\n        } else if i == 0 {\n            result = 0;\n\
    \        }\n    }\n    Some(result * arr.iter().map(|&x| x.abs()).sum::<isize>())",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod: isize =\
    \ 1;\n    let mut sum: isize = 0;\n    for i in arr {\n        if i < 0 {\n  \
    \          prod *= -1;\n        }\n        sum += i.abs();\n    }\n    Some(sum\
    \ * prod)", "    arr.iter().fold(Some(1), |acc, x| {\n        if x == &0 { return\
    \ None; }\n        match acc {\n            Some(y) => Some(y * x.abs() * x.signum()),\n\
    \            None => None,\n        }\n    })", "    let mut sum = 0;\n    let\
    \ mut prod = 1;\n    for i in arr {\n        sum += i.abs();\n        prod *=\
    \ i.signum();\n    }\n    if sum == 0 && prod == 0 {\n        None\n    } else\
    \ {\n        Some(sum * prod)\n    }", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let magnitude_sum = arr.iter().map(|&x| x.abs()).sum();\n\
    \    let mut prod_signs = 1;\n    for num in arr {\n        prod_signs *= match\
    \ num {\n            0 => 0,\n            _ if num > 0 => 1,\n            _ =>\
    \ -1,\n        };\n    }\n    Some(magnitude_sum * prod_signs)", "    let mut\
    \ prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        match i {\n   \
    \         0 => prod *= 0,\n            _ => {\n                prod *= i / i.abs();\n\
    \                sum += i.abs();\n            }\n        }\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }", "    match\
    \ arr.len() {\n        0 => None,\n        _ => Some(arr.iter().fold(1, |acc,\
    \ &n| acc * prod_sign(n))),\n    }", '    unimplemented!();', "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    Some(arr.iter().fold(1, |acc, val| acc *\
    \ sign(*val)) *\n        arr.iter().fold(0, |acc, val| acc + val.abs()))", " \
    \   if arr.is_empty() {\n        return None;\n    }\n    let mut mult: isize\
    \ = 1;\n    let mut res: isize = 0;\n    for i in &arr {\n        mult *= if *i\
    \ == 0 { 1 } else { (*i / i.abs()) };\n        res += (*i).abs();\n    }\n   \
    \ Some(res * mult)", "    if arr.is_empty() {\n        return None;\n    }\n \
    \   let mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i\
    \ < 0 {\n            prod *= -1;\n        }\n        sum += i.abs();\n    }\n\
    \    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    Some(arr.iter().fold(1, |acc, x| acc * (*x).signum()) * arr.iter().map(|x|\
    \ x.abs()).sum::<isize>())", '    unimplemented!()', '    unimplemented!();',
  "\tmatch arr.len() {\n\t\t0 => None,\n\t\t_ => Some(arr.iter().fold(1, |acc, &x|\
    \ acc * x.signum()) * arr.iter().map(|&x| x.abs()).sum::<isize>())\n\t}", '    unimplemented!();',
  "    if arr.is_empty() {\n        return None;\n    }\n    let sum = arr.iter().map(|&x|\
    \ x.abs()).sum::<isize>();\n    let prod = arr.iter().map(|&x| if x > 0 { 1 }\
    \ else if x < 0 { -1 } else { 0 }).product::<isize>();\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n \
    \   let mut sum = 0;\n    for n in arr {\n        if n > 0 {\n            prod\
    \ *= 1;\n        } else if n < 0 {\n            prod *= -1;\n        } else {\n\
    \            prod *= 0;\n        }\n        sum += n.abs();\n    }\n    Some(sum\
    \ * prod)", "    let p = arr.iter().map(|x| if *x == 0 { 0 } else if *x > 0 {\
    \ 1 } else { -1 }).fold(1, |acc, x| acc * x);\n    let s = arr.iter().map(|x|\
    \ x.abs()).fold(0, |acc, x| acc + x);\n    if s == 0 { None } else { Some(p *\
    \ s) }", "    if arr.is_empty() { return None; }\n    // TODO: Write code here\n\
    \    unimplemented!();", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n    let mut product\
    \ = 1;\n    for x in arr {\n        if x > 0 {\n            product *= 1;\n  \
    \      } else if x < 0 {\n            product *= -1;\n        } else {\n     \
    \       product *= 0;\n        }\n    }\n    Some(sum * product)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let s: isize = arr.iter().map(|x| x.signum()).product();\n\
    \    Some(arr.iter().map(|x| x.abs()).sum::<isize>() * s)", "    let mut new_arr:\
    \ Vec<isize> = Vec::new();\n    if arr.len() == 0 {\n        return None;\n  \
    \  }\n    for i in arr {\n        new_arr.push(if i < 0 { -i } else { i });\n\
    \    }\n    Some(new_arr.iter().sum::<isize>() * arr.iter().fold(1, |acc, &num|\
    \ acc * (if num < 0 { -1 } else { 1 })))", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr\
    \ {\n        if i == 0 {\n            continue;\n        }\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)", "    let zero = 0;\n \
    \   let v = arr.iter().fold(zero, |acc, x| {\n        match x {\n            0\
    \ => 0,\n            _ => acc * x.signum()\n        }\n    });\n    match v {\n\
    \        0 => None,\n        _ => Some(arr.iter().fold(zero, |acc, x| {\n    \
    \        match x {\n                0 => acc,\n                _ => acc + x.abs()\n\
    \            }\n        }))\n    }", "    let mut prod = 1;\n    let mut sum =\
    \ 0;\n    for n in arr {\n        match n {\n            0 => prod *= 0,\n   \
    \         n if n > 0 => {\n                prod *= 1;\n                sum +=\
    \ n;\n            }\n            n if n < 0 => {\n                prod *= -1;\n\
    \                sum += -n;\n            }\n            _ => (),\n        }\n\
    \    }\n    match prod * sum {\n        0 => None,\n        p => Some(p),\n  \
    \  }", '    unimplemented!()', "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut sum = 0;\n    let mut prod = 1;\n    for i in arr {\n    \
    \    sum += i.abs();\n        prod *= i.signum();\n    }\n    Some(sum * prod)",
  '    unimplemented!()', "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let prod = arr.iter().fold(1, |acc, n| acc * n.signum());\n    Some(arr.iter().map(|n|\
    \ n.abs()).sum::<isize>() * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n    \
    \    match i.signum() {\n            1 => {\n                prod *= 1;\n    \
    \            sum += i;\n            }\n            -1 => {\n                prod\
    \ *= -1;\n                sum += i.abs();\n            }\n            _ => continue,\n\
    \        }\n    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let mut res = 1;\n    for i in arr {\n        res *= if i\
    \ > 0 {1} else if i < 0 {-1} else {0};\n    }\n    Some(arr.iter().map(|x| x.abs()).sum::<isize>()\
    \ * res)", "    let mut ret = None;\n    let mut neg = 1;\n    let mut pos = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            neg *= x;\n        } else\
    \ if x > 0 {\n            pos *= x;\n        }\n    }\n    if arr.len() != 0 {\n\
    \        ret = Some(neg * pos);\n    }\n    ret", "    let mut res = 0;\n    for\
    \ n in arr {\n        res += n.abs() as isize * n.signum() as isize;\n    }\n\
    \    return Some(res);", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let mut product: isize = 1;\n    let mut sum: isize = 0;\n    for num in\
    \ arr {\n        sum += num.abs();\n        if num != 0 {\n            product\
    \ *= num.signum();\n        }\n    }\n    Some(sum * product)", '    unimplemented!();',
  "    if arr.is_empty() { return None }\n    let sign = arr.iter().map(|x| x.signum()).product();\n\
    \    let abs = arr.iter().map(|x| x.abs()).sum();\n    Some(sign * abs)", '    unimplemented!()',
  '    unimplemented!()', "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let (sum, mut prod) = arr.iter().fold((0, 1), |(s, p), el| {\n        let\
    \ tmp = el.signum();\n        (s + el.abs(), p * tmp)\n    });\n    sum * prod",
  "    let mut sum = 0;\n    let mut mul = 1;\n    for a in arr {\n        if a >\
    \ 0 {\n            sum += a;\n            mul *= 1;\n        } else if a < 0 {\n\
    \            sum += -a;\n            mul *= -1;\n        } else {\n          \
    \  sum += 0;\n            mul *= 0;\n        }\n    }\n    return if sum == 0\
    \ { None } else { Some(sum * mul) };", "    let mut sum = 0;\n    let mut product\
    \ = 1;\n    for num in arr {\n        match num {\n            n if n > 0 => {\n\
    \                sum += n;\n                product *= 1;\n            },\n  \
    \          n if n < 0 => {\n                sum += n.abs();\n                product\
    \ *= -1;\n            },\n            _ => {\n                sum += 0;\n    \
    \            product *= 0;\n            }\n        }\n    }\n    match product\
    \ {\n        n if n == 0 => {\n            None\n        },\n        _ => {\n\
    \            Some(sum * product)\n        }\n    }", "    if arr.is_empty() {\n\
    \        return None;\n    }\n    Some(arr.iter().fold(1, |acc, x| {\n       \
    \ if *x == 0 {\n            0\n        } else {\n            acc * *x.signum()\n\
    \        }\n    }) * arr.iter().map(|x| x.abs()).sum::<isize>())", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for el in arr {\n        if el < 0 {\n            prod *= -1;\n        }\
    \ else if el > 0 {\n            sum += el;\n        }\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n \
    \   let mut sum = 0;\n    for x in arr {\n        let sign = if x > 0 { 1 } else\
    \ if x < 0 { -1 } else { 0 };\n        prod *= sign;\n        sum += x.abs();\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut product = 1;\n    let mut sum = 0;\n    for i in arr {\n \
    \       if i < 0 {\n            product *= -1;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * product)", "    arr.iter().fold(None, |res, item| {\n \
    \       match res {\n            None => Some(item.abs() * item.signum()),\n \
    \           Some(res) => Some(res * item.abs() * item.signum()),\n        }\n\
    \    })", "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod\
    \ = 1isize;\n    let mut sum = 0isize;\n    for i in arr {\n        if i < 0 {\n\
    \            prod *= -1;\n        } else if i > 0 {\n            sum += i as isize;\n\
    \        }\n    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let mut signs = 1;\n    let mut sum = 0;\n    for num in arr\
    \ {\n        let mut sign = 1;\n        if num < 0 {\n            sign = -1;\n\
    \        }\n        signs *= sign;\n        sum += num.abs();\n    }\n    return\
    \ Some(sum * signs);", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let mut res = 1;\n    for x in arr {\n        res *= x.signum();\n    }\n\
    \    Some(arr.iter().map(|x| x.abs()).sum::<isize>() * res)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut sum = 0;\n    let mut prod = 1;\n\
    \    for x in arr {\n        if x < 0 {\n            prod *= -1;\n        }\n\
    \        sum += x.abs();\n    }\n    Some(sum * prod)", "\tif arr.len() == 0 {\n\
    \t\treturn None;\n\t}\n\tlet mut prod = 1;\n\tlet mut sum = 0;\n\tfor &x in arr.iter()\
    \ {\n\t\tsum += x.abs();\n\t\tprod *= x.signum();\n\t}\n\treturn Some(sum * prod);",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut mag_sum = 0;\n\
    \    let mut prod = 1;\n    for n in arr {\n        mag_sum += n.abs();\n    \
    \    if n != 0 {\n            prod *= n.signum();\n        }\n    }\n    Some(mag_sum\
    \ * prod)", "    if arr.is_empty() {\n        return None;\n    }\n    let s =\
    \ arr.iter().map(|a| if *a < 0 {-1} else if *a > 0 {1} else {0}).product();\n\
    \    Some(arr.iter().map(|a| a.abs()).sum::<isize>() * s)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for i in &arr {\n        if *i > 0 {\n            prod *= 1;\n        } else\
    \ if *i < 0 {\n            prod *= -1;\n        } else {\n            prod *=\
    \ 0;\n        }\n        sum += i.abs();\n    }\n    Some(sum * prod)", "    let\
    \ mut prod = arr.iter().fold(1, |acc, &n| acc * sign(n));\n    let mut sum = arr.iter().fold(0,\
    \ |acc, &n| acc + n.abs());\n    Some(prod * sum)", '    unimplemented!();', '    unimplemented!();',
  "    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        match\
    \ i {\n            i if i > 0 => {\n                prod *= 1;\n             \
    \   sum += i;\n            }\n            i if i < 0 => {\n                prod\
    \ *= -1;\n                sum += -i;\n            }\n            _ => {}\n   \
    \     }\n    }\n    if arr.len() == 0 {\n        None\n    } else {\n        Some(prod\
    \ * sum)\n    }", "    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ mut product = 1;\n    let mut magnitude = 0;\n    for i in arr {\n        product\
    \ *= get_sign(i);\n        magnitude += i.abs();\n    }\n    Some(magnitude *\
    \ product)", "    if arr.is_empty() {\n        return None;\n    }\n    // let\
    \ mut sum = 0;\n    // let mut prod = 1;\n    // for x in arr {\n    //     sum\
    \ += x.abs();\n    //     prod *= x.signum();\n    // }\n    // Some(sum * prod)\n\
    \    Some(arr.iter().fold((0, 1), |(acc, p), x| (acc + x.abs(), p * x.signum())).0\
    \ * arr.iter().fold((0, 1), |(acc, p), x| (acc + x.abs(), p * x.signum())).1)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 0;\n \
    \   let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n            prod\
    \ += 1;\n        } else if i < 0 {\n            prod -= 1;\n        }\n      \
    \  sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty() {\n \
    \       return None;\n    }\n    let prod_signs: Vec<isize> = arr.iter().map(|num|\
    \ num.signum()).collect();\n    let product: isize = prod_signs.iter().product();\n\
    \    let sum_magnitudes: isize = arr.iter().map(|num| num.abs()).sum();\n    Some(product\
    \ * sum_magnitudes)", "    if arr.is_empty() { return None; }\n    let mut prod\
    \ = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i > 0 {\n       \
    \     prod *= 1;\n        } else if i < 0 {\n            prod *= -1;\n       \
    \ } else {\n            prod *= 0;\n        }\n        sum += i.abs();\n    }\n\
    \    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i\
    \ == 0 {\n            continue;\n        }\n        prod *= i.signum();\n    \
    \    sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty() {\n\
    \        return None;\n    }\n    let sum: isize = arr.iter().map(|&x| x.abs()).sum();\n\
    \    let prod: isize = arr.iter().map(|&x| {\n        if x == 0 {\n          \
    \  0\n        } else if x > 0 {\n            1\n        } else {\n           \
    \ -1\n        }\n    }).product();\n    Some(sum * prod)", "    if arr.is_empty()\
    \ { return None }\n    let mut result = 1;\n    for i in &arr {\n        result\
    \ *= i.signum();\n    }\n    let mut sum = 0;\n    for i in &arr {\n        sum\
    \ += i.abs();\n    }\n    Some(sum * result)", "    if arr.is_empty() {\n    \
    \    return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum: isize\
    \ = 0;\n    for num in arr {\n        prod *= num.signum();\n        sum += num.abs();\n\
    \    }\n    Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let len = arr.len();\n    let mut sum: isize = 0;\n    let mut prod:\
    \ isize = 1;\n    for i in 0..len {\n        let sign = arr[i].signum();\n   \
    \     sum += arr[i].abs();\n        prod *= sign;\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod = 1;\n \
    \   let mut sum = 0;\n    for i in arr {\n        prod *= match i.signum() {\n\
    \            -1 => -1,\n            1 => 1,\n            _ => 0,\n        };\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let sign_prod = arr.iter().fold(1, |acc,\
    \ x| if *x == 0 { 0 } else { acc * x.signum() as isize });\n    Some(arr.iter().fold(0,\
    \ |acc, x| acc + (*x).abs() as isize) * sign_prod)", "    if arr.is_empty() {\
    \ return None; }\n    let mut product: isize = 1;\n    let mut sum: isize = 0;\n\
    \    for n in arr {\n        if n > 0 {\n            product *= 1;\n        }\
    \ else if n < 0 {\n            product *= -1;\n        } else {\n            product\
    \ *= 0;\n        }\n        sum += n.abs();\n    }\n    Some(sum * product)",
  "    let mut sum: isize = 0;\n    let mut prod: isize = 1;\n    for elt in arr {\n\
    \        match elt {\n            0 => continue,\n            _ => {\n       \
    \         sum += elt.abs();\n                prod *= elt.signum();\n         \
    \   }\n        }\n    }\n    match arr.len() {\n        0 => None,\n        _\
    \ => Some(sum * prod),\n    }", "    let mut res = 0;\n    let mut mul = 1;\n\
    \    for i in arr {\n        if i < 0 {\n            mul *= -1;\n        }\n \
    \       res += i.abs();\n    }\n    if res == 0 {\n        None\n    } else {\n\
    \        Some(res * mul)\n    }", '    None', '    unimplemented!()', "    //\
    \ TODO\n    None", "    let mut res = 0;\n    let mut mult = 1;\n    if arr.len()\
    \ == 0 {\n        return None;\n    }\n    for el in arr {\n        if el > 0\
    \ {\n            mult *= 1;\n        } else if el < 0 {\n            mult *= -1;\n\
    \        } else {\n            mult *= 0;\n        }\n        res += el.abs();\n\
    \    }\n    Some(res * mult)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let magnitudes: Vec<isize> = arr.iter().map(|x| x.abs()).collect();\n\
    \    let signs: Vec<isize> = arr.iter().map(|x| x.signum()).collect();\n    Some(magnitudes.iter().sum::<isize>()\
    \ * signs.iter().product::<isize>())", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    Some(arr.iter().fold(1, |acc, x| acc * x.signum()) *\n   \
    \      arr.iter().fold(0, |acc, x| acc + x.abs()))", "    if arr.is_empty() {\n\
    \        return None;\n    }\n    let mut sum = 0;\n    let mut product = 1;\n\
    \    for a in arr {\n        if a == 0 {\n            continue;\n        }\n \
    \       sum += a.abs();\n        product *= a.signum();\n    }\n    Some(sum *\
    \ product)", "    let mut prod = 1;\n    let mut sum = 0;\n    for i in arr {\n\
    \        sum += i.abs();\n        prod *= i.signum();\n    }\n    if arr.len()\
    \ == 0 {\n        None\n    } else {\n        Some(sum * prod)\n    }", "    let\
    \ mut res = None;\n    let mut pos = 1;\n    let mut neg = 1;\n    for n in arr\
    \ {\n        if n > 0 {\n            pos *= n;\n        } else if n < 0 {\n  \
    \          neg *= n;\n        }\n    }\n    res = match (pos, neg) {\n       \
    \ (x, y) if x == 0 && y == 0 => Some(0),\n        (x, _) if x == 0 => Some(y),\n\
    \        (_, y) if y == 0 => Some(x),\n        (x, y) => Some(x - y),\n    };\n\
    \    res", "    // TODO: add code here!\n    match arr.len() {\n        0 => None,\n\
    \        _ => {\n            let mut sum: isize = 0;\n            let mut product:\
    \ isize = 1;\n            for n in arr {\n                match n {\n        \
    \            a if a > 0 => {\n                        sum += a;\n            \
    \            product *= 1;\n                    },\n                    a if a\
    \ < 0 => {\n                        sum += a.abs();\n                        product\
    \ *= -1;\n                    },\n                    _ => {\n               \
    \         sum += 0;\n                        product *= 0;\n                 \
    \   }\n                }\n            }\n            Some(sum * product)\n   \
    \     }\n    }", "    if arr.is_empty() {\n        return None;\n    }\n    let\
    \ s: isize = arr.iter().map(|x| sign(*x)).sum();\n    Some(arr.iter().map(|x|\
    \ x.abs()).sum::<isize>() * s)", "    let mut prod = None;\n    for i in arr {\n\
    \        match prod {\n            None => prod = Some(i.signum()),\n        \
    \    Some(i) => {\n                prod = Some(i * i.signum());\n            }\n\
    \        }\n    }\n    prod", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let mut sum: isize = 0;\n    let mut prod: isize = 1;\n    for n in\
    \ arr {\n        sum += n.abs();\n        prod *= n.signum();\n    }\n    Some(sum\
    \ * prod)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut\
    \ s = 0;\n    let mut p = 1;\n    for &n in &arr {\n        if n < 0 {\n     \
    \       p *= -1;\n        }\n        s += p * n.abs();\n    }\n    Some(s)", " \
    \   if arr.is_empty() { return None; }\n    let mut res = 1;\n    for num in arr\
    \ {\n        res *= num.signum();\n    }\n    Some(arr.iter().map(|num| num.abs()).sum::<isize>()\
    \ * res)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut\
    \ prod = 1;\n    let mut sum = 0;\n    for i in arr {\n        match i.signum()\
    \ {\n            1 => prod *= 1,\n            -1 => prod *= -1,\n            _\
    \ => prod *= 0,\n        }\n        sum += i.abs();\n    }\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    let sum = arr.iter().fold(0,\
    \ |acc, x| acc + x.abs());\n    let mul = arr.iter().fold(1, |acc, x| match x\
    \ {\n        0 => 0,\n        x if x > 0 => acc,\n        _ => acc * -1,\n   \
    \ });\n    Some(sum * mul)", '    unimplemented!()', "    if arr.is_empty() {\n\
    \        return None;\n    }\n    arr.iter().fold(Some(1), |acc, &x| {\n     \
    \   match acc {\n            Some(a) => {\n                if x > 0 {\n      \
    \              Some(a * x as isize)\n                } else if x < 0 {\n     \
    \               Some(a * -x as isize)\n                } else {\n            \
    \        Some(0)\n                }\n            }\n            None => None,\n\
    \        }\n    })", "    if arr.is_empty() {\n        return None;\n    }\n \
    \   let mut prod: isize = 1;\n    let mut sum: isize = 0;\n    for i in arr {\n\
    \        if i < 0 {\n            prod *= -1;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * prod)", "    arr.iter().fold(Some(1), |product, &num| \n\
    \        if num != 0 {\n            product.map(|p| p * num.signum())\n      \
    \  } else {\n            None\n        })\n        .map(|product| arr.iter().map(|&num|\
    \ (num * num).abs()).sum::<isize>() * product)", "    if arr.is_empty() {\n  \
    \      return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        prod *= i.signum();\n        sum += i.abs();\n    }\n  \
    \  Some(sum * prod)", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    let mut mult = 1;\n    let mut sum = 0;\n    for i in arr {\n        if i\
    \ > 0 {\n            mult *= 1;\n        } else if i < 0 {\n            mult *=\
    \ -1;\n        } else {\n            mult *= 0;\n        }\n        sum += i.abs();\n\
    \    }\n    Some(sum * mult)", "    if arr.is_empty() {\n        return None;\n\
    \    }\n    let sign = arr.iter().fold(1, |acc, x| acc * x.signum());\n    let\
    \ sum: isize = arr.iter().map(|x| x.abs()).sum();\n    Some(sign * sum)", "  \
    \  if arr.is_empty() {\n        return None;\n    }\n    let (mut sum, mut prod)\
    \ = (0, 1);\n    for elem in arr {\n        if elem > 0 {\n            sum +=\
    \ elem;\n            prod *= 1;\n        } else if elem < 0 {\n            sum\
    \ += elem.abs();\n            prod *= -1;\n        }\n    }\n    Some(sum * prod)",
  "    let mut sum: isize = 0;\n    let mut prod: isize = 1;\n    for n in arr {\n\
    \        if n > 0 {\n            sum += n;\n            prod *= 1;\n        }\
    \ else if n < 0 {\n            sum += -n;\n            prod *= -1;\n        }\
    \ else {\n            prod *= 0;\n        }\n    }\n    if prod == 0 {\n     \
    \   None\n    } else {\n        Some(sum * prod)\n    }", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let prod = arr.iter().fold(1, |acc, &x|\
    \ if x < 0 { -acc } else { acc });\n    Some(\n        arr.iter()\n          \
    \  .fold(0, |acc, &x| acc + x.abs())\n            .checked_mul(prod)\n       \
    \     .unwrap_or(0),\n    )", "    let sign_product = arr.iter().fold(1, |acc,\
    \ x| if *x > 0 { 1 } else if *x < 0 { -1 } else { 0 } * acc);\n    match arr.iter().filter(|x|\
    \ **x != 0).fold(None, |acc, x| Some(acc.unwrap_or(0) + x.abs())) {\n        Some(y)\
    \ => Some(y * sign_product),\n        None => None\n    }", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let prod = arr.iter().map(|num|\n      \
    \  if *num > 0 {\n            1\n        } else if *num < 0 {\n            -1\n\
    \        } else {\n            0\n        }\n    ).product();\n    let res = arr.iter().map(|num|\
    \ num.abs()).sum::<isize>();\n    Some(res * prod)", "    if arr.is_empty() {\n\
    \        return None;\n    }\n    let (mut prod, mut sum) = (1, 0);\n    for n\
    \ in arr {\n        if n < 0 {\n            prod *= -1;\n        } else if n ==\
    \ 0 {\n            prod = 0;\n        }\n        sum += n.abs();\n    }\n    Some(sum\
    \ * prod)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut\
    \ res = 0;\n    let mut sign = 1;\n    for n in arr {\n        if n == 0 {\n \
    \           sign = 1;\n        } else {\n            sign *= n.signum();\n   \
    \         res += n.abs();\n        }\n    }\n    Some(res * sign)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    arr.iter().fold(Some(1), |acc, &x| {\n \
    \       match (acc, x.signum()) {\n            (Some(a), b) => Some(a * b),\n\
    \            _ => None,\n        }\n    })\n    .map(|s| arr.iter().map(|&x| x.abs()).sum::<isize>()\
    \ * s)", "    if arr.is_empty() {\n        return None;\n    }\n    let mut prod\
    \ = 1;\n    let mut sum = 0;\n    for i in arr {\n        prod *= i.signum();\n\
    \        sum += i.abs();\n    }\n    Some(sum * prod)", "    let mut prod = 1;\n\
    \    let mut sum = 0;\n    for num in arr {\n        sum += num.abs();\n     \
    \   prod *= num.signum();\n    }\n    if arr.len() == 0 {\n        None\n    }\
    \ else {\n        Some(sum * prod)\n    }", "    let mut res = 1;\n    for x in\
    \ arr {\n        match x {\n            _ if x < 0 => res *= -1,\n           \
    \ _ if x > 0 => res *= 1,\n            _ => res *= 0,\n        }\n    }\n    if\
    \ arr.len() > 0 {\n        Some(res)\n    } else {\n        None\n    }", "  \
    \  arr.into_iter().fold(Some(1), |acc, x| match acc {\n        Some(acc) => {\n\
    \            if x == 0 {\n                Some(0)\n            } else {\n    \
    \            let sign = if x > 0 { 1 } else { -1 };\n                Some(acc\
    \ * sign)\n            }\n        }\n        None => None,\n    })", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for n in arr {\n        if n > 0 {\n            prod *= 1;\n        } else\
    \ if n < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += n.abs();\n    }\n    Some(sum * prod)", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut count = 1;\n    let sum = arr.iter().map(|n|\
    \ {\n        if *n < 0 {\n            count *= -1;\n        }\n        n.abs()\n\
    \    }).sum();\n    Some(sum * count)", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let sum: isize = arr.iter().map(|x| x.abs()).sum();\n    let\
    \ prod: isize = arr.iter().map(|x| x.signum()).product();\n    Some(sum * prod)",
  "    if arr.is_empty() {\n        return None;\n    }\n    // get the product of\
    \ signs\n    let prod = arr.iter().fold(1isize, |prod, x| prod * x.signum());\n\
    \    // fold over the array, adding the absolute value of the element to the running\
    \ total\n    let sum = arr.iter().fold(0isize, |sum, x| sum + x.abs());\n    Some(sum\
    \ * prod)", '    unimplemented!()', "    let mut product = 1;\n    let mut magnitude\
    \ = 0;\n    for i in arr {\n        let current = i.signum();\n        if current\
    \ != 0 {\n            product *= current;\n        }\n        magnitude += i.abs();\n\
    \    }\n    if magnitude == 0 {\n        None\n    } else {\n        Some(magnitude\
    \ * product)\n    }", "    if arr.is_empty() {\n        return None;\n    }\n\
    \    Some(arr.iter().fold(1, |acc, i| acc * (i.signum() as isize)))", '    None',
  "    arr.iter().fold(None, |acc, x| match acc {\n        None => Some(if *x < 0\
    \ { -x } else { x }),\n        Some(a) => Some(a * (if *x < 0 { -1 } else { 1\
    \ }) * x),\n    })", "    let mut res = 0;\n    let mut mult = 1;\n    for el\
    \ in arr {\n        match el {\n            0 => mult = 0,\n            el if\
    \ el > 0 => mult *= 1,\n            el if el < 0 => mult *= -1,\n            _\
    \ => mult = 0,\n        }\n        res += el.abs();\n    }\n    match res {\n\
    \        0 => None,\n        _ => Some(res * mult),\n    }", "    let mut sum\
    \ = 0;\n    let mut prod = 1;\n    for x in arr {\n        sum += x.abs();\n \
    \       prod *= x.signum();\n    }\n    match arr.len() {\n        0 => None,\n\
    \        _ => Some(sum * prod),\n    }", "    if arr.is_empty() {\n        return\
    \ None;\n    }\n    let sum = arr.iter().map(|x| x.abs()).sum::<isize>();\n  \
    \  let product = arr.iter().fold(1, |acc, x| if *x < 0 { -acc } else { acc });\n\
    \    Some(sum * product)", "    let mut prod = 1;\n    let mut sum = 0;\n    for\
    \ i in arr {\n        if i > 0 {\n            prod *= 1;\n        } else if i\
    \ < 0 {\n            prod *= -1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += i.abs();\n    }\n    sum * prod", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod = 1;\n    let mut sum = 0;\n\
    \    for x in arr {\n        prod *= if x > 0 { 1 } else if x < 0 { -1 } else\
    \ { 0 };\n        sum += x.abs();\n    }\n    Some(sum * prod)", "    match arr.is_empty()\
    \ {\n        true => None,\n        false => Some(arr.iter().fold(1, |m, &n| m\
    \ * n.signum()) * arr.iter().fold(0, |m, &n| m + n.abs())),\n    }", "\tif arr.len()\
    \ == 0 {\n\t\treturn None;\n\t}\n\tlet mut sum: isize = 0;\n\tlet mut prod: isize\
    \ = 1;\n\tfor item in arr {\n\t\tsum += item.abs();\n\t\tif item == 0 {\n\t\t\t\
    prod = 0;\n\t\t} else {\n\t\t\tprod *= item.signum();\n\t\t}\n\t}\n\tSome(sum\
    \ * prod)", "    // TODO: implement this function\n    None", "    if arr.is_empty()\
    \ {\n        return None;\n    }\n    let mut prod: isize = 1;\n    let mut sum:\
    \ isize = 0;\n    for e in arr {\n        if e == 0 {\n            continue;\n\
    \        }\n        prod *= e.signum();\n        sum += e.abs();\n    }\n    Some(sum\
    \ * prod)", "    if arr.is_empty() { return None }\n    let mut res = 1;\n   \
    \ for a in arr {\n        res *= if a > 0 { 1 } else if a < 0 { -1 } else { 0\
    \ };\n    }\n    Some(arr.iter().map(|&x| x.abs()).sum::<isize>() * res)", " \
    \   arr.iter().fold(Some(1), |acc, &x| {\n        match x {\n            x if\
    \ x > 0 => acc.map(|a| a * 1),\n            x if x < 0 => acc.map(|a| a * -1),\n\
    \            _ => acc.map(|a| a * 0),\n        }\n    }).map(|s| arr.iter().fold(0,\
    \ |acc, &x| acc + x.abs() * s))", "    let prod_signs = arr.iter().map(|x| {\n\
    \        match x {\n            x if x > &0 => 1,\n            x if x < &0 =>\
    \ -1,\n            _ => 0,\n        }\n    }).product();\n    let magnitudes =\
    \ arr.iter().map(|x| x.abs()).sum();\n    match (prod_signs, magnitudes) {\n \
    \       (x, 0) if x != 0 => Some(x),\n        (0, y) if y != 0 => Some(y),\n \
    \       _ => None,\n    }", "    if arr.is_empty() {\n        return None;\n \
    \   }\n    Some(arr.iter().map(|&x| x.abs()).product::<isize>() * arr.iter().map(|&x|\
    \ x.signum()).product::<isize>())"]
stop_tokens:
- "\n}"
