language: rs
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return\
    \ 2 * modp(n - 1, p) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut tmp\
    \ = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * tmp)\
    \ % p;\n        }\n        tmp = (tmp * tmp) % p;\n        n /= 2;\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut x = 2;\n    let mut p =\
    \ p;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n       \
    \     res = res * x % p;\n        }\n        x = x * x % p;\n        n = n / 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let a = modp(n\
    \ / 2, p);\n    let r = (a * a) % p;\n    if n % 2 == 0 {\n        return r;\n\
    \    }\n    (r * 2) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut power = n;\n    let\
    \ mut base = 2;\n    while power > 0 {\n        if power % 2 == 1 {\n        \
    \    result = (result * base) % p;\n        }\n        base = (base * base) %\
    \ p;\n        power /= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut s\
    \ = 1;\n    let mut t = 2;\n    while t <= n {\n        t *= 2;\n        s = (s\
    \ * t) % p;\n    }\n    s\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpewp7i591.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tif n == 0 {\n\t\treturn 1;\n\t}\n\tif n % 2 == 0 {\n\t\t\
    return (modp(n / 2, p) * modp(n / 2, p)) % p;\n\t}\n\t(modp(n - 1, p) * modp(n\
    \ - 1, p) * 2) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmphg0zjv9t.rs:2:32\n  |\n2 |\
    \ fn modp(n: isize, p: isize) -> isize {\n  |    ----                        ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n9 |     (modp(n - 1, p) * modp(n\
    \ - 1, p) * 2) % p;\n  |                                              - help:\
    \ consider removing this semicolon\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut k = n;\n    let mut\
    \ two = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            result = (result\
    \ * two) % p;\n        }\n        two = (two * two) % p;\n        k = k / 2;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    if n % 2 == 0 {\n        let tmp = modp(n /\
    \ 2, p);\n        return tmp * tmp % p;\n    }\n    return 2 * modp(n - 1, p)\
    \ % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut k =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            res = (res * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        n = n / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut r = 1;\n    let mut p = p;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * 2) % p;\n  \
    \      }\n        n /= 2;\n        p = (p * p) % MODULO;\n    }\n    r\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MODULO` in this scope\n  --> /tmp/tmp581aa_1n.rs:11:23\n\
    \   |\n11 |         p = (p * p) % MODULO;\n   |                       ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    let mut\
    \ p = p;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * 2) % p;\n        }\n        n /= 2;\n        p = (p * p) % p;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpe5_iri6a.rs:8:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut b = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * b) % p;\n  \
    \      }\n        k = k / 2;\n        b = (b * b) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut two = 2;\n    let mut exp\
    \ = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res = (res\
    \ * two) % p;\n        }\n        two = (two * two) % p;\n        exp /= 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut x\
    \ = modp(n / 2, p);\n    if n % 2 == 0 {\n        x = (x * x) % p;\n    } else\
    \ {\n        x = (((x * x) % p) * 2) % p;\n    }\n    if x < 0 {\n        x +=\
    \ p;\n    }\n    x\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut i = n;\n    let mut x =\
    \ 2;\n    while i > 0 {\n        if i % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        i = i / 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tlet mut result = 1;\n\tlet mut pow = n;\n\tlet mut mult\
    \ = 2;\n\twhile pow > 0 {\n\t\tif pow % 2 == 1 {\n\t\t\tresult = (result * mult)\
    \ % p;\n\t\t}\n\t\tmult = (mult * mult) % p;\n\t\tpow /= 2;\n\t}\n\tresult\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let tmp = modp(n / 2, p);\n        return tmp * tmp % p;\n    }\n\
    \    modp(n - 1, p) * 2 % p\n}\n\nfn main() {\n    let candidate = modp;\n   \
    \ assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut m = n;\n    let mut b = 2;\n\
    \    while m > 0 {\n        if m % 2 == 1 {\n            r = (r * b) % p;\n  \
    \      }\n        m = m / 2;\n        b = (b * b) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tif n == 0 {\n\t\treturn 1;\n\t}\n\tif n % 2 == 0 {\n\t\t\
    return modp(n / 2, p) * modp(n / 2, p) % p;\n\t}\n\treturn 2 * modp(n - 1, p)\
    \ % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    let half\
    \ = modp(n / 2, p);\n    half * half % p * (if n % 2 == 0 { 1 } else { 2 }) %\
    \ p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let half =\
    \ modp(n / 2, p);\n    let other_half = if n % 2 == 0 { half } else { p - half\
    \ };\n    (half * other_half) % p\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpnyal3go4.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut modp = 1;\n    for _ in 0..n {\n        modp\
    \ = (modp * 2) % p;\n    }\n    modp\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => modp(n-1, p)\
    \ * 2 % p,\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    let x = modp(n / 2, p);\n    if n % 2 == 0\
    \ {\n        return x * x % p;\n    } else {\n        return 2 * x * x % p;\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut x = 2;\n    let mut\
    \ i = n;\n    while i > 0 {\n        if i % 2 == 1 {\n            result = (result\
    \ * x) % p;\n        }\n        x = (x * x) % p;\n        i = i / 2;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n /= 2;\n        base = (base * base)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut b:\
    \ isize = 1;\n    let mut r: isize = 2;\n    for _ in 0..n {\n        b = (b *\
    \ r) % p;\n    }\n    b\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut two = 2;\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            res = (res * two) % p;\n        }\n\
    \        two = (two * two) % p;\n        n = n / 2;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpa59njtgh.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n = n / 2;\n   |   \
    \      ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut i = n;\n    while i > 0 {\n\
    \        if i % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        i =\
    \ i / 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpc9j_ox8k.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    if n % 2 == 0 {\n        let m = modp(n / 2,\
    \ p);\n        return (m * m) % p;\n    }\n    (2 * modp(n - 1, p)) % p\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut exp = n;\n    let mut base\
    \ = 2;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res = (res\
    \ * base) % p;\n        }\n        exp = exp / 2;\n        base = (base * base)\
    \ % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    assert!(p > 0);\n    if n == 0\
    \ {\n        return 1;\n    }\n    let mut x = modp(n / 2, p);\n    x = x * x\
    \ % p;\n    if n % 2 == 1 {\n        x = x * 2 % p;\n    }\n    x\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * m) % p;\n  \
    \      }\n        m = (m * m) % p;\n        k = k / 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut y = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * y) % p;\n  \
    \      }\n        y = (y * y) % p;\n        k = k / 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut result = 1;\n    let mut\
    \ b = 2;\n    let mp = p - 1;\n    while n > 0 {\n        if n & 1 == 1 {\n  \
    \          result = (result * b) % p;\n        }\n        n >>= 1;\n        b\
    \ = (b * b) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut cur = 2;\n    for bit in\
    \ (0..32).rev() {\n        if (n & (1 << bit)) != 0 {\n            res = (res\
    \ * cur) % p;\n        }\n        cur = (cur * cur) % p;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpdcl46d1m.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n & 1 ==\
    \ 0 {\n        return modp(n >> 1, p) * modp(n >> 1, p) % p;\n    }\n    return\
    \ modp(n >> 1, p) * modp(n >> 1, p) * 2 % p;\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut ans\
    \ = modp(n / 2, p);\n    ans = (ans * ans) % p;\n    if n % 2 == 1 {\n       \
    \ ans = (ans * 2) % p;\n    }\n    ans\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut n\
    \ = n;\n    let mut res = 2;\n    let mut p = p;\n    while n > 1 {\n        if\
    \ n % 2 == 1 {\n            res = (res * res) % p;\n        }\n        n /= 2;\n\
    \        res = (res * res) % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmp6n1en7md.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut n\
    \ = n;\n    let mut res = modp(n / 2, p);\n    res = res * res % p;\n    if n\
    \ % 2 == 1 {\n        res = res * 2 % p;\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp = exp / 2;\n        base = (base\
    \ * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut x = 1;\n    let mut e = n;\n    while e > 0 {\n\
    \        if e % 2 == 1 {\n            x = x * 2 % p;\n        }\n        e = e\
    \ / 2;\n        if e > 0 {\n            x = x * x % p;\n        }\n    }\n   \
    \ x\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `2`', /tmp/tmp3qck5wm5.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tif n == 0 {\n\t\treturn 1;\n\t}\n\tif n % 2 == 0 {\n\t\t\
    let t = modp(n / 2, p);\n\t\treturn (t * t) % p;\n\t}\n\treturn (2 * modp(n -\
    \ 1, p)) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut i = 1;\n    let mut j = 0;\n    let mut b = vec![0;\
    \ n as usize];\n    while i < n {\n        let mut k = 0;\n        while k < n\
    \ {\n            b[k as usize] = j % 2;\n            j /= 2;\n            k +=\
    \ 1;\n        }\n        j = i;\n        k = n - 1;\n        while k >= 0 {\n\
    \            let d = 2 * b[k as usize] + j % 2;\n            j = (j - d) / 2;\n\
    \            b[k as usize] = d;\n            k -= 1;\n        }\n        i +=\
    \ 1;\n    }\n    let mut res = 0;\n    i = n - 1;\n    while i >= 0 {\n      \
    \  res = (2 * res + b[i as usize]) % p;\n        i -= 1;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp7jddkom3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n        2 *\
    \ modp(n - 1, p) % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n   \
    \ assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n % p;\n    let mut result = 1;\n    let\
    \ mut x = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ result * x % p;\n        }\n        x = x * x % p;\n        n = n / 2;\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `29`,\n right: `2`', /tmp/tmp_rb1luen.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    // This is the actual algorithm; unfortunately, it's\
    \ a little slow.\n    // let m = (p - 1) >> 1;\n    // let mut r = 1;\n    //\
    \ for _ in 0..m {\n    //     r = (r * r) % p;\n    //     if n & 1 != 0 {\n \
    \   //         r = (r * 2) % p;\n    //     }\n    //     n >>= 1;\n    // }\n\
    \    // return r;\n\n    // Here's a fast way to do the same thing. This fails\
    \ if n >= p^2, but who cares.\n    let mut r = 1;\n    let mut n = n % p;\n  \
    \  while n > 0 {\n        if n & 1 != 0 {\n            r = (r * 2) % p;\n    \
    \    }\n        n >>= 1;\n        r = (r * r) % p;\n    }\n    return r;\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpang9vfn2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut nn = n;\n    let mut p\
    \ = p;\n    while nn > 0 {\n        if nn % 2 == 1 {\n            res = (res *\
    \ n) % p;\n        }\n        nn = nn / 2;\n        n = (n * n) % p;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpi951rr3c.rs:5:9\n\
    \  |\n5 |     let mut p = p;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmpi951rr3c.rs:11:9\n  \
    \ |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n11 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    let a = modp(n/2, p);\n    let aa = (a * a)\
    \ % p;\n    if n % 2 == 0 {\n        return aa;\n    }\n    (aa * 2) % p\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut pow = n;\n    let mut a\
    \ = 2;\n    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res\
    \ * a) % p;\n        }\n        pow /= 2;\n        a = (a * a) % p;\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpkbswku1x.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut pow = n;\n    let mut x\
    \ = 2;\n    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res\
    \ * x) % p;\n        }\n        pow = pow / 2;\n        x = (x * x) % p;\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    assert!(p > 0);\n    let mut r\
    \ = 1;\n    let mut rr = 2;\n    let mut nn = n;\n    while nn > 0 {\n       \
    \ if nn % 2 == 1 {\n            r = (r * rr) % p;\n        }\n        rr = (rr\
    \ * rr) % p;\n        nn /= 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        1 => 2,\n       \
    \ _ => {\n            // (2^n)^2 = 2^(2n) = (2^n)^2 mod p\n            let mut\
    \ b = modp(n / 2, p);\n            b = (b * b) % p;\n            if n % 2 == 1\
    \ {\n                b = (b * 2) % p;\n            }\n            b\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut s = 2;\n    let mut m = n;\n\
    \    while m > 0 {\n        if m % 2 == 1 {\n            r = (r * s) % p;\n  \
    \      }\n        s = (s * s) % p;\n        m = m / 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut p0\
    \ = 2;\n    let mut p1 = 2;\n    for _ in 1..n {\n        p1 = (p0 * p1) % p;\n\
    \        p0 = p1;\n    }\n    p1\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpnuuvh4on.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    while\
    \ n > 0 {\n        if n % 2 == 1 {\n            result = (result * base) % p;\n\
    \        }\n        base = (base * base) % p;\n        n /= 2;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp82zu9yav.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut m = 1;\n    let mut k = n;\n    let mut b = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            m = (m * b) % p;\n  \
    \      }\n        k = k / 2;\n        b = (b * b) % p;\n    }\n    m\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut sum = 1;\n    let mut m = n;\n    let mut k =\
    \ 1;\n    while m > 0 {\n        if m % 2 == 1 {\n            sum = (sum * k)\
    \ % p;\n        }\n        k = (k * k) % p;\n        m = m / 2;\n    }\n    sum\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpvvhefk8l.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n = n / 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut r = 1;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n /=\
    \ 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpw8yalc2l.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tif n == 0 {\n\t\treturn 1;\n\t}\n\tif n == 1 {\n\t\treturn\
    \ 2;\n\t}\n\tif n % 2 == 0 {\n\t\tlet m = modp(n / 2, p);\n\t\treturn (m * m)\
    \ % p;\n\t}\n\telse {\n\t\tlet m = modp(n - 1, p);\n\t\treturn (2 * m) % p;\n\t\
    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5),\
    \ 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101),\
    \ 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101),\
    \ 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5),\
    \ 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut m = 1;\n    let mut x = 2;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            m = (m * x) % p;\n        }\n        x =\
    \ (x * x) % p;\n        n /= 2;\n    }\n    m\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpbklbk0le.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tif n == 0 {\n\t\treturn 1;\n\t}\n\tif n % 2 == 0 {\n\t\t\
    let m = modp(n / 2, p);\n\t\treturn m * m % p;\n\t}\n\treturn modp(n - 1, p) *\
    \ 2 % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut s = 2;\n\
    \    while k > 0 {\n        if k % 2 == 1 {\n            r = (r * s) % p;\n  \
    \      }\n        s = (s * s) % p;\n        k = k / 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut t = 1;\n    let mut x = n;\n    let mut m = p;\n\
    \    while x > 0 {\n        if x % 2 == 1 {\n            t = (t * n) % p;\n  \
    \      }\n        x = x / 2;\n        n = (n * n) % p;\n    }\n    t\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `m`\n --> /tmp/tmp212flj95.rs:5:13\n  |\n5 |\
    \     let mut m = p;\n  |             ^ help: if this is intentional, prefix it\
    \ with an underscore: `_m`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\
    \nwarning: variable does not need to be mutable\n --> /tmp/tmp212flj95.rs:5:9\n\
    \  |\n5 |     let mut m = p;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `n`\n  --> /tmp/tmp212flj95.rs:11:9\n  \
    \ |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n11 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut b = 2;\n    for i in 0..n\
    \ {\n        if i > 0 && i % 64 == 0 {\n            r = (r * b) % p;\n       \
    \     b = 2;\n        } else {\n            b = (b * b) % p;\n        }\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpryxuu91o.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut exp = n;\n    let mut base\
    \ = 2;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res = (res\
    \ * base) % p;\n        }\n        exp /= 2;\n        base = (base * base) % p;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut ans\
    \ = modp(n / 2, p);\n    ans = (ans * ans) % p;\n    if n % 2 == 1 {\n       \
    \ ans = (ans * 2) % p;\n    }\n    ans\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822505
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let tmp = modp(n / 2, p);\n        return (tmp * tmp) % p;\n  \
    \  }\n    (modp(n - 1, p) * 2) % p\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut\
    \ sum = 1;\n    let mut add = 2;\n    let mut k = n;\n    while k > 0 {\n    \
    \    if k % 2 == 1 {\n            sum = (sum * add) % p;\n        }\n        add\
    \ = (add * add) % p;\n        k /= 2;\n    }\n    sum\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = p\
    \ - 2;\n    while m > 0 {\n        if m % 2 == 1 {\n            r = (r * k) %\
    \ p;\n        }\n        k = (k * k) % p;\n        m /= 2;\n    }\n    r\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmptaelu580.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => modp(n - 1,\
    \ p) * 2 % p,\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        n if n % 2 == 0 =>\
    \ {\n            let e = modp(n / 2, p);\n            modmul(e, e, p)\n      \
    \  }\n        _ => modmul(modp(n - 1, p), 2, p),\n    }\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `modmul` in this scope\n --> /tmp/tmpvgj847dl.rs:7:13\n\
    \  |\n7 |             modmul(e, e, p)\n  |             ^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `modmul` in this scope\n --> /tmp/tmpvgj847dl.rs:9:14\n\
    \  |\n9 |         _ => modmul(modp(n - 1, p), 2, p),\n  |              ^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut pw = n;\n    let mut n =\
    \ p - 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            r = (r * pw)\
    \ % p;\n        }\n        pw = (pw * pw) % p;\n        n /= 2;\n    }\n    r\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp3o942snh.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let (mut x, mut y) = (1, 2);\n    for _ in 0..n {\n \
    \       x = (x * y) % p;\n    }\n    x\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tlet mut r = 1;\n\tlet mut m = n;\n\tlet mut i = p - 2;\n\
    \twhile i > 0 {\n\t\tif i % 2 == 1 {\n\t\t\tr = r * m % p;\n\t\t}\n\t\tm = m *\
    \ m % p;\n\t\ti /= 2;\n\t}\n\tr\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpn9suqrbf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut d = 2;\n    let mut b = n;\n\
    \    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * d) % p;\n  \
    \      }\n        d = (d * d) % p;\n        b = b / 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return\
    \ modp(n - 1, p) * modp(n - 1, p) * 2 % p;\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmptayqa8z1.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut result = 1;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n /= 2;\n        base = (base * base)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut a = 2;\n    let mut\
    \ e = n;\n    while e > 0 {\n        if e % 2 == 1 {\n            result = (result\
    \ * a) % p;\n        }\n        a = (a * a) % p;\n        e /= 2;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut i = n;\n    let mut k =\
    \ p - 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res *\
    \ i) % p;\n        }\n        i = (i * i) % p;\n        k /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmps8o7h0fk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut k = 1;\n    let mut l = 2;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            k = (k * l) % p;\n        }\n        l =\
    \ (l * l) % p;\n        n /= 2;\n    }\n    k\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp9elj53m5.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let t = modp(n / 2, p);\n        return (t * t) % p;\n    }\n \
    \   (2 * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut res\
    \ = 1;\n    let mut p = p;\n    let mut n = n;\n    while n > 0 {\n        if\
    \ n % 2 == 1 {\n            res = (res * p) % MOD;\n        }\n        p = (p\
    \ * p) % MOD;\n        n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MOD` in this scope\n  --> /tmp/tmpl5sv2x27.rs:11:31\n\
    \   |\n11 |             res = (res * p) % MOD;\n   |                         \
    \      ^^^ not found in this scope\n\nerror[E0425]: cannot find value `MOD` in\
    \ this scope\n  --> /tmp/tmpl5sv2x27.rs:13:23\n   |\n13 |         p = (p * p)\
    \ % MOD;\n   |                       ^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut result = 1;\n    let mut\
    \ b = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * b) % p;\n        }\n        n = n / 2;\n        b = (b * b) % p;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p;\n   \
    \     }\n        n /= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpedl8ivbe.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 { return 1; }\n    let t = modp(n / 2, p);\n\
    \    t * t % p * if n % 2 == 0 { 1 } else { 2 } % p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    let mut n = n;\n    let mut res\
    \ = 1;\n    let mut base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n  \
    \          res = (res * base) % p;\n        }\n        base = (base * base) %\
    \ p;\n        n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut n = n;\n    let mut m = n\
    \ % (p - 1);\n    n = m;\n    while n > 0 {\n        if n % 2 == 1 {\n       \
    \     r = (r * m) % p;\n        }\n        m = (m * m) % p;\n        n /= 2;\n\
    \    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp12twlgd2.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n    return\
    \ modp(n - 1, p) * 2 % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut res\
    \ = 1;\n    let mut k = 1;\n    while k <= n {\n        res = (res * 2) % p;\n\
    \        k += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp /= 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let t = modp(n / 2, p);\n        return t * t % p;\n    }\n   \
    \ modp(n - 1, p) * 2 % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut ret = 1;\n    let mut n = n;\n    let mut x =\
    \ 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            ret = (ret * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        n /= 2;\n    }\n    ret\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut _n = n;\n    let mut\
    \ base = 2;\n    while _n > 0 {\n        if _n % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        _n /= 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut i = 0;\n    let mut accum = 1;\n    while i <\
    \ n {\n        accum = (accum * 2) % p;\n        i += 1;\n    }\n    accum\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res =\
    \ (res * base) % p;\n        }\n        base = (base * base) % p;\n        exp\
    \ /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut n\
    \ = n;\n    let mut r = 1;\n    let mut base = 2;\n    while n > 0 {\n       \
    \ if n % 2 == 1 {\n            r = (r * base) % p;\n        }\n        base =\
    \ (base * base) % p;\n        n /= 2;\n    }\n    r\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut d = 1;\n    let mut k = 0;\n    let mut n = n;\n\
    \    while n > 0 {\n        if n % 2 == 1 {\n            d = (d * 2) % p;\n  \
    \      }\n        n /= 2;\n        k += 1;\n    }\n    if k >= p {\n        d\
    \ = (d * modp(2, p - 2)) % p;\n    }\n    d\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpji1uujny.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    // (2^n mod\
    \ p) = ((2^(n/2) mod p)^2) mod p\n    let mut x = modp(n / 2, p);\n    x = (x\
    \ * x) % p;\n    if n % 2 == 1 {\n        x = (x * 2) % p;\n    }\n    x\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut prod = 1;\n    let mut m = n;\n    while m >\
    \ 0 {\n        if m % 2 == 1 {\n            prod = (prod * 2) % p;\n        }\n\
    \        m = m / 2;\n    }\n    prod\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmplfl0djqu.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let res = modp(n / 2, p);\n        return (res * res) % p;\n  \
    \  }\n    (modp(n - 1, p) * 2) % p\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut x = 1;\n    let mut i = 0;\n    while i < n {\n\
    \        x = (x * 2) % p;\n        i += 1;\n    }\n    x\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n < 0 {\n        panic!(\"modp() is not defined for\
    \ negative values\");\n    }\n\n    let mut result = 1;\n    let mut bin = n;\n\
    \    let mut x = 2;\n\n    while bin > 0 {\n        if bin % 2 == 1 {\n      \
    \      result = (result * x) % p;\n        }\n        bin /= 2;\n        x = (x\
    \ * x) % p;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut temp = n;\n    while temp\
    \ > 0 {\n        if temp % 2 == 1 {\n            res = res * 2 % p;\n        }\n\
    \        temp = temp / 2;\n        println!(\"{}\", res);\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpg5jee0rr.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: '2

    4

    '
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut re = 1;\n    let mut b = 2;\n    let mut i =\
    \ n;\n    while i > 0 {\n        if i % 2 == 1 {\n            re = (re * b) %\
    \ p;\n        }\n        b = (b * b) % p;\n        i = i / 2;\n    }\n    re\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut modulus = 1;\n    let mut n_tmp = n;\n    while\
    \ n_tmp != 0 {\n        if n_tmp % 2 == 1 {\n            modulus = (modulus *\
    \ 2) % p;\n        }\n        n_tmp /= 2;\n    }\n    modulus\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpw1pg_73a.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    let mut res = modp(n / 2, p);\n    res = res\
    \ * res % p;\n    if n % 2 == 1 {\n        res = res * 2 % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut ret = 1;\n    let mut base = 2;\n    let mut\
    \ pn = n;\n    while pn > 0 {\n        if pn % 2 == 1 {\n            ret = (ret\
    \ * base) % p;\n        }\n        base = (base * base) % p;\n        pn /= 2;\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = n;\n    let mut m = p\
    \ - 2;\n    while m > 0 {\n        if m % 2 == 1 {\n            r = (r * k) %\
    \ p;\n        }\n        k = (k * k) % p;\n        m /= 2;\n    }\n    r\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmptaelu580.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut res\
    \ = modp(n / 2, p);\n    res = (res * res) % p;\n    if n % 2 == 1 {\n       \
    \ res = (res * 2) % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut k = 1;\n    let mut\
    \ m = n;\n    while m > 0 {\n        if m % 2 == 1 {\n            result = (result\
    \ * k) % p;\n        }\n        k = (k * k) % p;\n        m /= 2;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpqpb32cb2.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    let mut pow2: isize = 1;\n    let\
    \ mut result: isize = 1;\n    while pow2 <= n {\n        if (n & pow2) != 0 {\n\
    \            result = result * 2 % p;\n        }\n        pow2 *= 2;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpvrq6l1u1.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    if n % 2 == 0 {\n        let half = modp(n\
    \ / 2, p);\n        return (half * half) % p;\n    }\n    let half = modp(n /\
    \ 2, p);\n    return (half * half * 2) % p;\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut res\
    \ = modp(n / 2, p);\n    res = res * res % p;\n    if n % 2 == 1 {\n        res\
    \ = res * 2 % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = res * 2 % p;\n        }\n    \
    \    n /= 2;\n        if n > 0 {\n            res = res * res % p;\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `2`', /tmp/tmppi3u9jg9.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut b: isize = 1;\n    let mut m: isize = n;\n  \
    \  while m > 0 {\n        if m % 2 == 1 {\n            b = (b * n) % p;\n    \
    \    }\n        n = (n * n) % p;\n        m = m / 2;\n    }\n    b\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp6nvz85us.rs:9:9\n\
    \  |\n2 | fn modp(n: isize, p: isize) -> isize {\n  |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n9 |         n = (n * n) % p;\n  |\
    \         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        res = (res * 2) % p;\n        n -= 1;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut m = 1;\n    let mut p2 = 2;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            m = (m * p2) % p;\n        }\n     \
    \   p2 = (p2 * p2) % p;\n        n /= 2;\n    }\n    m\n}\n\nfn main() {\n   \
    \ let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmplbcud6kv.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let half = modp(n / 2, p);\n        return (half * half) % p;\n\
    \    }\n    return (2 * modp(n - 1, p)) % p;\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n % p == 0 {\n        return 0;\n    }\n    (1 <<\
    \ (n % (p - 1))) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpmxnvi451.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut x = 1;\n    let mut y = 2;\n    for _ in 0..n\
    \ {\n        x = (x * y) % p;\n    }\n    x\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut s = 1;\n    let mut i = 0;\n    let mut t = n;\n\
    \    let mut k = 1;\n    let h = floor(ln(n as f64) / ln(2.0));\n    while i <=\
    \ h {\n        if (t / 2) * 2 == t {\n            s = (s * k) % p;\n        }\n\
    \        k = (k * k) % p;\n        t = t / 2;\n        i = i + 1;\n    }\n   \
    \ s\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `floor` in this scope\n --> /tmp/tmpfeyq47i1.rs:7:13\n\
    \  |\n7 |     let h = floor(ln(n as f64) / ln(2.0));\n  |             ^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `ln` in this scope\n\
    \ --> /tmp/tmpfeyq47i1.rs:7:19\n  |\n7 |     let h = floor(ln(n as f64) / ln(2.0));\n\
    \  |                   ^^ help: a local variable with a similar name exists: `n`\n\
    \nerror[E0425]: cannot find function `ln` in this scope\n --> /tmp/tmpfeyq47i1.rs:7:34\n\
    \  |\n7 |     let h = floor(ln(n as f64) / ln(2.0));\n  |                    \
    \              ^^ help: a local variable with a similar name exists: `n`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut fac = 2;\n    let mut exp\
    \ = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res = (res\
    \ * fac) % p;\n        }\n        fac = (fac * fac) % p;\n        exp /= 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n % p == 0 {\n        return 0;\n    }\n    let mut\
    \ result = 1;\n    for _ in 0..n {\n        result = (result * 2) % p;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmp07ypaal_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut b = 1;\n    let mut e = n;\n    let mut r = 1;\n\
    \    loop {\n        if e == 0 {\n            return r;\n        }\n        if\
    \ e % 2 == 1 {\n            r = (r * b) % p;\n        }\n        e = e / 2;\n\
    \        b = (b * b) % p;\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpq7y58niq.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut b = n;\n    while b > 0 {\n\
    \        if b % 2 == 1 {\n            r = (r * n) % p;\n        }\n        b =\
    \ b / 2;\n        n = (n * n) % p;\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsgjca0ri.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n = (n * n) % p;\n \
    \  |         ^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    if n == 0 {\n        return 1;\n\
    \    }\n    if n % 2 == 0 {\n        let t = modp(n / 2, p);\n        return (t\
    \ * t) % p;\n    }\n    return (2 * modp(n - 1, p)) % p;\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut pow = n;\n    let mut m\
    \ = p;\n    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res\
    \ * m) % p;\n        }\n        pow /= 2;\n        m = (m * m) % p;\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpb8s61ux3.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut m = n;\n    let mut x =\
    \ 2;\n    while m > 0 {\n        if m % 2 == 1 {\n            res = (res * x)\
    \ % p;\n        }\n        m /= 2;\n        x = (x * x) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n_tmp = n;\n    while n_tmp\
    \ > 0 {\n        if n_tmp % 2 == 1 {\n            res = (res * 2) % p;\n     \
    \   }\n        n_tmp = n_tmp / 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpkmvt15gx.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let n = n / 2;\n        return (modp(n, p) * modp(n, p)) % p;\n\
    \    }\n    return (2 * modp(n - 1, p)) % p;\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n < 0 {\n        panic!(\"n >= 0 required in modp,\
    \ but got {}\", n);\n    }\n    let mut r = 1;\n    let mut p = p;\n    let mut\
    \ two = 2;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n \
    \           r = (r * two) % p;\n        }\n        two = (two * two) % p;\n  \
    \      n = n / 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut k = n;\n    let mut m =\
    \ 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res * m)\
    \ % p;\n        }\n        k /= 2;\n        m = (m * m) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    if n ==\
    \ 1 {\n        return 2;\n    }\n\n    let mut m = n / 2;\n    let mut r = 1;\n\
    \    let mut x = 2;\n\n    if n % 2 == 1 {\n        r = 2;\n    }\n\n    while\
    \ m > 0 {\n        x = (x * x) % p;\n        if m % 2 == 1 {\n            r =\
    \ (r * x) % p;\n        }\n        m = m / 2;\n    }\n\n    r\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut s\
    \ = modp(n / 2, p);\n    s = (s * s) % p;\n    if n % 2 == 1 {\n        s = (s\
    \ * 2) % p;\n    }\n    return s;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut v = 1;\n    let mut s = 1;\n    while s < n {\n\
    \        s = s << 1;\n        v = (v * v) % p;\n    }\n    v\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpwiuhw0tw.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: -1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    match n {\n        0 => 1,\n        _ => modp(n / 2,\
    \ p) * modp(n - n / 2, p) % p,\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659822512
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut nn\
    \ = n;\n    let mut r = 2;\n    while nn > 1 {\n        if nn % 2 == 1 {\n   \
    \         r = (r * 2) % p;\n        }\n        nn /= 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpy41jps_r.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut a = 2;\n    let mut m = n;\n\
    \    while m > 0 {\n        if m % 2 == 1 {\n            r = (r * a) % p;\n  \
    \      }\n        a = (a * a) % p;\n        m /= 2;\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    if n % 2 == 0 {\n        let t = modp(n / 2,\
    \ p);\n        return (t * t) % p;\n    }\n    return (2 * modp(n - 1, p)) % p;\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    let mut\
    \ x = modp(n >> 1, p);\n    x = (x * x) % p;\n    if n & 1 == 1 {\n        x =\
    \ (x * 2) % p;\n    }\n    x\n}\n\nfn main() {\n    let candidate = modp;\n  \
    \  assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut n = n;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n /=\
    \ 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr3rhcoo7.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut b = 1;\n    while n > 0 {\n\
    \        b = (b * (n & 1) + b) % p;\n        n >>= 1;\n        b = (b * 2) % p;\n\
    \    }\n    b\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmpau4p4b4i.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut pwr = BigInt::from(1);\n    for _ in 0..n {\n\
    \        pwr = pwr * BigInt::from(2);\n    }\n    let pbi = BigInt::from(p);\n\
    \    pwr % pbi\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BigInt`\n -->\
    \ /tmp/tmpwrxepxka.rs:3:19\n  |\n3 |     let mut pwr = BigInt::from(1);\n  | \
    \                  ^^^^^^ use of undeclared type `BigInt`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `BigInt`\n --> /tmp/tmpwrxepxka.rs:5:21\n\
    \  |\n5 |         pwr = pwr * BigInt::from(2);\n  |                     ^^^^^^\
    \ use of undeclared type `BigInt`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `BigInt`\n --> /tmp/tmpwrxepxka.rs:7:15\n  |\n7 |     let pbi = BigInt::from(p);\n\
    \  |               ^^^^^^ use of undeclared type `BigInt`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut k = 1;\n    let mut two =\
    \ 2;\n    while k <= n {\n        if k & n != 0 {\n            r = (r * two) %\
    \ p;\n        }\n        two = (two * two) % p;\n        k = k << 1;\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut m = 1;\n    let mut x = 2;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            m = (m * x) % p;\n        }\n        x =\
    \ (x * x) % p;\n        n /= 2;\n    }\n    m\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpbklbk0le.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822505
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut n = n;\n    while n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p;\n   \
    \     }\n        n /= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpedl8ivbe.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822506
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut ret = 1;\n    let mut two = 2;\n    while n >\
    \ 0 {\n        if n % 2 == 1 {\n            ret = (ret * two) % p;\n        }\n\
    \        two = (two * two) % p;\n        n = n / 2;\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp93ia_8_8.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n = n / 2;\n   |   \
    \      ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut a = 2;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * a) % p;\n        }\n        a =\
    \ (a * a) % p;\n        n /= 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpl6_0w414.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut k = n;\n    let mut pow2\
    \ = 2;\n    while k > 0 {\n        if k % 2 == 1 {\n            res = (res * pow2)\
    \ % p;\n        }\n        pow2 = (pow2 * pow2) % p;\n        k /= 2;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 { return 1; }\n    let mut y = 1;\n    let\
    \ mut x = 2;\n    while n > 1 {\n        if n % 2 == 0 {\n            x = (x *\
    \ x) % p;\n            n /= 2;\n        } else {\n            y = (x * y) % p;\n\
    \            x = (x * x) % p;\n            n = (n - 1) / 2;\n        }\n    }\n\
    \    (x * y) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n --> /tmp/tmp0coss9bd.rs:9:13\n\
    \  |\n2 | fn modp(n: isize, p: isize) -> isize {\n  |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n9 |             n /= 2;\n  |    \
    \         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot assign\
    \ to immutable argument `n`\n  --> /tmp/tmp0coss9bd.rs:13:13\n   |\n2  | fn modp(n:\
    \ isize, p: isize) -> isize {\n   |         - help: consider making this binding\
    \ mutable: `mut n`\n...\n13 |             n = (n - 1) / 2;\n   |             ^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut cur = 2;\n    let mut exp\
    \ = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            res = (res\
    \ * cur) % p;\n        }\n        cur = (cur * cur) % p;\n        exp /= 2;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = modp(n / 2, p);\n    result = (result * result) % p;\n    if n % 2 == 1 {\n\
    \        result = (result * 2) % p;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    modp_bits(n, 0, p)\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `modp_bits` in this scope\n --> /tmp/tmpji005bgk.rs:3:5\n\
    \  |\n3 |     modp_bits(n, 0, p)\n  |     ^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut i = n;\n    let mut j =\
    \ p - 2;\n    while i > 0 {\n        if i % 2 == 1 {\n            res = (res *\
    \ j) % p;\n        }\n        i /= 2;\n        j = (j * j) % p;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpo1eif1_w.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ cur = n;\n    while cur > 0 {\n        if cur % 2 == 1 {\n            result\
    \ = result * base % p;\n        }\n        base = base * base % p;\n        cur\
    \ = cur / 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut r = 1;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n =\
    \ n / 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpkyc3rxq3.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut d = 2;\n    let mut e = n;\n\
    \    while e > 0 {\n        if e % 2 == 1 {\n            r = (r * d) % p;\n  \
    \      }\n        d = (d * d) % p;\n        e = e / 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut x = 1;\n    let mut k = n;\n    while k > 0 {\n\
    \        while k % 2 == 0 {\n            k /= 2;\n            x = (x * x) % p;\n\
    \        }\n        k -= 1;\n        x = (x * 2) % p;\n    }\n    x\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `2`', /tmp/tmpa642wh29.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut result = 1;\n    let mut\
    \ base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n            result =\
    \ (result * base) % p;\n        }\n        n /= 2;\n        base = (base * base)\
    \ % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let t = modp(n / 2, p);\n        t * t % p\n    } else {\n    \
    \    2 * modp(n - 1, p) % p\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut b = n;\n    let mut\
    \ a = 2;\n    while b > 0 {\n        if b % 2 == 1 {\n            result = (result\
    \ * a) % p;\n        }\n        b = b / 2;\n        a = (a * a) % p;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut d = 1;\n    let mut k = 0;\n    let mut q = p\
    \ - 1;\n    while q % 2 == 0 {\n        k += 1;\n        q /= 2;\n    }\n    let\
    \ mut z = modpow(n, q, p);\n    while k > 0 {\n        if z != 1 && z != p - 1\
    \ {\n            z = (z * z) % p;\n        }\n        if z != p - 1 {\n      \
    \      d = 0;\n        }\n        k -= 1;\n    }\n    if d == 0 {\n        -1\n\
    \    } else {\n        z\n    }\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `modpow` in this scope\n  --> /tmp/tmp_2i6bng7.rs:10:17\n\
    \   |\n10 |     let mut z = modpow(n, q, p);\n   |                 ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    let mut p =\
    \ p;\n    let mut exp = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n     \
    \       res = (res * exp) % p;\n        }\n        exp = (exp * exp) % p;\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut b = 2;\n    let mut e = n;\n\
    \    while e > 0 {\n        if e % 2 == 1 {\n            r = (r * b) % p;\n  \
    \      }\n        e = e / 2;\n        b = (b * b) % p;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut i = 1;\n    let mut j = 1;\n    while i < n {\n\
    \        j = (2 * j) % p;\n        i += 1;\n    }\n    j\n}\n\nfn main() {\n \
    \   let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpa4al3zlg.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exp = n;\n    while exp > 0 {\n        if exp % 2 == 1 {\n            result\
    \ = (result * base) % p;\n        }\n        exp /= 2;\n        base = (base *\
    \ base) % p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822506
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ exponent = n;\n    while exponent > 0 {\n        if exponent % 2 == 1 {\n  \
    \          result = (result * base) % p;\n        }\n        exponent = exponent\
    \ / 2;\n        base = (base * base) % p;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut x = 2;\n    let mut pow\
    \ = n;\n    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res\
    \ * x) % p;\n        }\n        x = (x * x) % p;\n        pow /= 2;\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    assert!(n >= 0);\n    assert!(p > 0);\n    let mut res\
    \ = 1;\n    let mut base = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n  \
    \          res = (res * base) % p;\n        }\n        base = (base * base) %\
    \ p;\n        n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp8zus5cun.rs:12:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n12 |         n /= 2;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    let mut result\
    \ = 1;\n    let mut x = 2;\n    let mut y = n;\n    while y > 0 {\n        if\
    \ y % 2 == 1 {\n            result = (result * x) % p;\n        }\n        x =\
    \ (x * x) % p;\n        y = y / 2;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    while n > 0\
    \ {\n        res = (res * 2) % p;\n        n -= 1;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut y = 2;\n    let mut\
    \ k = n;\n    while k > 0 {\n        if k % 2 == 1 {\n            result = (result\
    \ * y) % p;\n        }\n        y = (y * y) % p;\n        k /= 2;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut pow = n;\n    let mut base\
    \ = 2;\n    while pow > 0 {\n        if pow % 2 == 1 {\n            res = (res\
    \ * base) % p;\n        }\n        pow /= 2;\n        base = (base * base) % p;\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut ret = 1;\n    let mut cur = 2;\n    let mut p\
    \ = p;\n    let mut n = n;\n    while n > 0 {\n        if n % 2 == 1 {\n     \
    \       ret = (ret * cur) % p;\n        }\n        cur = (cur * cur) % p;\n  \
    \      n /= 2;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822507
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut n = n;\n    while n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * 2) % p;\n        }\n        n /=\
    \ 2;\n    }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpr3rhcoo7.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n <= 0 {\n        1\n    } else {\n        let mut\
    \ x = modp(n >> 1, p);\n        x = x * x % p;\n        if n & 1 == 1 {\n    \
    \        x = x * 2 % p;\n        }\n        x\n    }\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut d = 1;\n    let mut k = n;\n    while k > 0 {\n\
    \        if k % 2 == 1 {\n            d = (d * 2) % p;\n        }\n        k =\
    \ k / 2;\n    }\n    d\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmp5g4uxem7.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822508
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut n = n;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n /= 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmprr6kzsl0.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n % 2 ==\
    \ 0 {\n        let mut m = modp(n / 2, p);\n        return m * m % p;\n    }\n\
    \    let mut m = modp(n - 1, p);\n    return m * 2 % p;\n}\n\nfn main() {\n  \
    \  let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut result = 1;\n    let mut base = 2;\n    let mut\
    \ power = n;\n    while power > 0 {\n        if power % 2 == 1 {\n           \
    \ result = (result * base) % p;\n        }\n        base = (base * base) % p;\n\
    \        power /= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut a = 2;\n    let mut b =\
    \ n;\n    while b > 0 {\n        if b % 2 == 1 {\n            res = res * a %\
    \ p;\n        }\n        a = a * a % p;\n        b /= 2;\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut ret = 1;\n    let mut b = 2;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            ret = (ret * b) % p;\n        }\n  \
    \      b = (b * b) % p;\n        n = n / 2;\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2zq8cx1y.rs:10:9\n\
    \   |\n2  | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n10 |         n = n / 2;\n   |   \
    \      ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1659822507
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut base = 2;\n    let mut exponent = n;\n    let\
    \ mut result = 1;\n    while exponent > 0 {\n        if exponent % 2 == 1 {\n\
    \            result = (result * base) % p;\n        }\n        exponent /= 2;\n\
    \        base = (base * base) % p;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n < 1 {\n        panic!(\"modp(n, p) for n < 1\");\n\
    \    }\n    let mut result = 1;\n    let mut base = 2;\n    let mut d = n;\n \
    \   while d > 0 {\n        if d % 2 == 1 {\n            result = result * base\
    \ % p;\n        }\n        base = base * base % p;\n        d /= 2;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''modp(n, p) for n < 1'', /tmp/tmpe30w7s1w.rs:4:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822508
- exit_code: -1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n\n    if n % 2\
    \ == 0 {\n        return modp(n / 2, p) * modp(n / 2, p) % p;\n    }\n\n    return\
    \ modp(n - 1, p) * modp(n, p) % p;\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659822513
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1\
    \ {\n        return 2;\n    }\n    // p is prime.\n    let a = modp(n / 2, p);\n\
    \    let b = (a * a) % p;\n    if n % 2 == 0 {\n        return b;\n    }\n   \
    \ return (b * 2) % p;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut k = n;\n    let mut r = 1;\n    while k > 0 {\n\
    \        if k % 2 == 1 {\n            r = r * 2 % p;\n        }\n        k = k\
    \ / 2;\n        if k > 0 {\n            r = r * r % p;\n        }\n    }\n   \
    \ r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `2`', /tmp/tmp3bb621v2.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut p = p;\n    let mut n = n;\n    let mut res =\
    \ 1;\n    let mut b = 2;\n    while n > 0 {\n        if n % 2 == 1 {\n       \
    \     res = (res * b) % p;\n        }\n        n = n / 2;\n        b = (b * b)\
    \ % p;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut b = n;\n    let mut a = 2;\n\
    \    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * a) % p;\n  \
    \      }\n        b /= 2;\n        a = (a * a) % p;\n    }\n    r\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n\tassert!(n >= 0);\n\tassert!(p > 0);\n\tlet mut c = 1;\n\
    \tfor _ in 0..n {\n\t\tc = (c * 2) % p;\n\t}\n\tc\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut x = 2;\n    let mut n_bin\
    \ = n;\n    while n_bin > 0 {\n        if n_bin % 2 == 1 {\n            res =\
    \ (res * x) % p;\n        }\n        x = (x * x) % p;\n        n_bin /= 2;\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut k = 1;\n    let mut p = p;\n    let mut result\
    \ = 1;\n    while k <= n {\n        if k & n != 0 {\n            result = result\
    \ * p % MOD;\n        }\n        k <<= 1;\n        p = p * p % MOD;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MOD` in this scope\n --> /tmp/tmpsdcq9hnn.rs:8:35\n\
    \  |\n8 |             result = result * p % MOD;\n  |                        \
    \           ^^^ not found in this scope\n\nerror[E0425]: cannot find value `MOD`\
    \ in this scope\n  --> /tmp/tmpsdcq9hnn.rs:11:21\n   |\n11 |         p = p * p\
    \ % MOD;\n   |                     ^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822508
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut nn = n;\n    let mut ppp\
    \ = p;\n    while nn > 0 {\n        if nn % 2 == 1 {\n            r = (r * nn)\
    \ % ppp;\n        }\n        nn = nn / 2;\n        ppp = (ppp * ppp) % p;\n  \
    \  }\n    r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmpg40drds6.rs:8:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut res = 1;\n    let mut y = 2;\n    let mut m =\
    \ n;\n    while m > 0 {\n        if m % 2 == 1 {\n            res = (res * y)\
    \ % p;\n        }\n        y = (y * y) % p;\n        m /= 2;\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut n = n;\n    let mut res = 1;\n    while n > 0\
    \ {\n        if n % 2 == 1 {\n            res = (res * 2) % p;\n        }\n  \
    \      n = n / 2;\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmph4n01u8o.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822508
- exit_code: 0
  program: "/// Return 2^n modulo p (be aware of numerics).\nfn modp(n: isize, p:\
    \ isize) -> isize {\n    let mut r = 1;\n    let mut a = 2;\n    let mut b = n;\n\
    \    while b > 0 {\n        if b % 2 == 1 {\n            r = (r * a) % p;\n  \
    \      }\n        a = (a * a) % p;\n        b = b / 2;\n    }\n    r\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822508
