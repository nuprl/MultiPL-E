language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    Invalid input length\");\n    }\n\n    a.chars()\n        .zip(b.chars())\n  \
    \      .map(|(x, y)| match (x, y) {\n            ('0', '0') => '0',\n        \
    \    ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid character\"),\n        })\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut out = String::new();\n    for (i,\
    \ j) in a.bytes().zip(b.bytes()) {\n        let mut a = i - b'0';\n        let\
    \ mut b = j - b'0';\n        out.push(((a ^ b) + b'0') as char);\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    Unequal number of characters!\");\n    }\n\n    let a_bytes = a.into_bytes();\n\
    \    let b_bytes = b.into_bytes();\n\n    let mut c_bytes = vec![0; a_bytes.len()];\n\
    \n    for i in 0..a_bytes.len() {\n        c_bytes[i] = a_bytes[i] ^ b_bytes[i];\n\
    \    }\n\n    String::from_utf8(c_bytes).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmprt7atvwu.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822352
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut result = String::new();\n    for (i, &a_byte) in\
    \ a_bytes.iter().enumerate() {\n        let b_byte = b_bytes[i];\n        let\
    \ result_byte = a_byte ^ b_byte;\n        result.push(result_byte as char);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmp696vwxbc.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n  assert_eq!(a.len(), b.len());\n  a.chars()\n\
    \    .zip(b.chars())\n    .map(|(a, b)| (a == '1') ^ (b == '1'))\n    .map(|b|\
    \ if b { '1' } else { '0' })\n    .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a: Vec<char> = a.chars().collect();\n\
    \    let b: Vec<char> = b.chars().collect();\n    let mut result = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        result.push(if a[i] == b[i] { '0' } else {\
    \ '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    let mut\
    \ iter_a = a.chars();\n    let mut iter_b = b.chars();\n    loop {\n        let\
    \ ch_a = iter_a.next();\n        let ch_b = iter_b.next();\n        if ch_a.is_none()\
    \ || ch_b.is_none() {\n            break;\n        }\n        let ch_a = ch_a.unwrap();\n\
    \        let ch_b = ch_b.unwrap();\n        if ch_a == ch_b {\n            res.push('0');\n\
    \        } else {\n            res.push('1');\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes\
    \ = b.into_bytes();\n    let mut xor_bytes = Vec::new();\n    for (a_byte, b_byte)\
    \ in a_bytes.iter().zip(b_bytes.iter()) {\n        xor_bytes.push(a_byte ^ b_byte);\n\
    \    }\n    let string = String::from_utf8(xor_bytes).unwrap();\n    string\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpkjp1im3y.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822352
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a: Vec<u8> = a.into_bytes();\n    let\
    \ b: Vec<u8> = b.into_bytes();\n    if a.len() != b.len() {\n        panic!(\"\
    string xor error: string lengths must be equal\");\n    }\n    let mut c = vec![0;\
    \ a.len()];\n    for i in 0..a.len() {\n        c[i] = a[i] ^ b[i];\n    }\n \
    \   unsafe { String::from_utf8_unchecked(c) }\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmp0lev6t1g.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut xored = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        xored.push(if i == j { '0' } else\
    \ { '1' });\n    }\n    xored\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Convert to u8s in big endian (since the\
    \ 0th index of a string is the least significant bit)\n    let a_bytes = a.as_bytes();\n\
    \    let b_bytes = b.as_bytes();\n\n    // Make sure the two byte arrays are of\
    \ equal length\n    let length = a_bytes.len();\n    assert_eq!(length, b_bytes.len());\n\
    \n    // First, perform XOR between corresponding bytes\n    let mut bytes = Vec::new();\n\
    \    for i in 0..length {\n        let result = a_bytes[i] ^ b_bytes[i];\n   \
    \     bytes.push(result);\n    }\n\n    // Second, convert the result to a string\n\
    \    let strs: Vec<String> = bytes.iter().map(|b| format!(\"{:08b}\", b)).collect();\n\
    \    strs.join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"000000000000000100000000000000000000000100000000\"`,\n right: `\"010010\"\
    `', /tmp/tmpsf4lyrpj.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    assert!(a.chars().all(|x|\
    \ x == '0' || x == '1'));\n    assert!(b.chars().all(|x| x == '0' || x == '1'));\n\
    \n    a.chars()\n        .zip(b.chars())\n        .map(|(x, y)| (x, y))\n    \
    \    .map(|(x, y)| {\n            match (x, y) {\n                ('0', '0') =>\
    \ '0',\n                ('0', '1') => '1',\n                ('1', '0') => '1',\n\
    \                ('1', '1') => '0',\n                _ => panic!(\"Unknown character\"\
    ),\n            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    (0..a.len())\n        .map(|i| match (a.as_bytes()[i],\
    \ b.as_bytes()[i]) {\n            (b'0', b'0') => \"0\",\n            (b'1', b'1')\
    \ => \"0\",\n            _ => \"1\",\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| char_xor(a, b))\n        .collect()\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_xor` in this scope\n --> /tmp/tmps7rdymcs.rs:6:23\n\
    \  |\n6 |         .map(|(a, b)| char_xor(a, b))\n  |                       ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a: Vec<u8> = a.chars().map(|x| x.to_digit(10).unwrap()\
    \ as u8).collect();\n    let b: Vec<u8> = b.chars().map(|x| x.to_digit(10).unwrap()\
    \ as u8).collect();\n    let c: Vec<u8> = a.iter().zip(b.iter()).map(|(x, y)|\
    \ x ^ y).collect();\n    c.iter().map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut chars_a = a.chars();\n    let mut chars_b = b.chars();\n    loop {\n   \
    \     let char_a = chars_a.next();\n        let char_b = chars_b.next();\n   \
    \     match (char_a, char_b) {\n            (Some(a), Some(b)) => {\n        \
    \        let mut xor = '0';\n                if a == '1' && b == '0' || a == '0'\
    \ && b == '1' {\n                    xor = '1';\n                }\n         \
    \       result.push(xor);\n            }\n            (Some(a), None) => {\n \
    \               result.push(a);\n            }\n            (None, Some(b)) =>\
    \ {\n                result.push(b);\n            }\n            (None, None)\
    \ => {\n                break;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    let mut xored = vec![];\n    for i in 0..a.len() {\n        if a[i] == b[i]\
    \ {\n            xored.push(48);\n        } else {\n            xored.push(49);\n\
    \        }\n    }\n    String::from_utf8(xored).unwrap()\n}\n\nfn main() {\n \
    \   let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = \"\".to_string();\n    let\
    \ ch_a = a.chars();\n    let ch_b = b.chars();\n    for (a, b) in ch_a.zip(ch_b)\
    \ {\n        res.push(match (a, b) {\n            ('0', '0') => '0',\n       \
    \     ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"invalid input\"),\n        });\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        result.push(if a.chars().nth(i).unwrap() ==\
    \ b.chars().nth(i).unwrap() {\n            '0'\n        } else {\n           \
    \ '1'\n        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ c in a.chars().zip(b.chars()) {\n        result.push(match c {\n           \
    \ (x, y) if x == y => '0',\n            _ => '1',\n        });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.into_bytes()\n\
    \        .iter()\n        .zip(b.into_bytes().iter())\n        .map(|(x, y)| (*x\
    \ ^ *y).to_string())\n        .collect::<Vec<String>>()\n        .join(\"\")\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // a and b have equal length, otherwise\
    \ the challenge can't be solved\n    let res: String = a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| match (a, b) {\n            ('0', '0') => '0',\n      \
    \      ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Unexpected input values\"),\n        })\n\
    \        .collect();\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    Can't xor strings of different length!\");\n    }\n\n    a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822352
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(char_a, char_b)| {\n            if char_a == char_b {\n         \
    \       '0'\n            } else {\n                '1'\n            }\n      \
    \  })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_chars: Vec<char> = a.chars().collect();\n\
    \    let b_chars: Vec<char> = b.chars().collect();\n    let c_chars: Vec<char>\
    \ = a_chars\n        .iter()\n        .zip(b_chars.iter())\n        .map(|(a,\
    \ b)| xor(*a, *b))\n        .collect();\n    c_chars.iter().collect()\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpgv18wn41.rs:9:23\n\
    \  |\n9 |         .map(|(a, b)| xor(*a, *b))\n  |                       ^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let a_as_bytes\
    \ = a.into_bytes();\n    let b_as_bytes = b.into_bytes();\n    let mut result\
    \ = String::new();\n    for (a, b) in a_as_bytes.iter().zip(b_as_bytes.iter())\
    \ {\n        let mut result_i = *a ^ *b;\n        if result_i == 0 {\n       \
    \     result_i = 48;\n        } else {\n            result_i = 49;\n        }\n\
    \        result.push(result_i as char);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut ret = String::new();\n    let len\
    \ = std::cmp::min(a.len(), b.len());\n    for i in 0..len {\n        ret.push_str(&(a.chars().nth(i).unwrap()\
    \ ^ b.chars().nth(i).unwrap()).to_string());\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpsjc3xnaf.rs:7:50\n\
    \  |\n7 |         ret.push_str(&(a.chars().nth(i).unwrap() ^ b.chars().nth(i).unwrap()).to_string());\n\
    \  |                        ------------------------- ^ -------------------------\
    \ char\n  |                        |\n  |                        char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut xored = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        let a = a.to_digit(10).unwrap();\n\
    \        let b = b.to_digit(10).unwrap();\n        let xor = a ^ b;\n        xored.push_str(&xor.to_string());\n\
    \    }\n    xored\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| (a.to_digit(10).unwrap() ^ b.to_digit(10).unwrap()).to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    let a_chars\
    \ = a.chars();\n    let b_chars = b.chars();\n    for (a_char, b_char) in a_chars.zip(b_chars)\
    \ {\n        res.push(if a_char == b_char { '0' } else { '1' });\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(c, d)| match (c, d) {\n            ('0', '0') => '0',\n         \
    \   ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"impossible case\"),\n        })\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(ca, cb)| if ca == cb { '0' } else { '1' })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    XOR operands must be of the same length\");\n    }\n\n    let a_chars: Vec<char>\
    \ = a.chars().collect();\n    let b_chars: Vec<char> = b.chars().collect();\n\n\
    \    let result: String = a_chars\n        .iter()\n        .zip(b_chars.iter())\n\
    \        .map(|(a, b)| xor_chars(*a, *b))\n        .collect();\n\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor_chars` in this scope\n  --> /tmp/tmpm2wllhpt.rs:14:23\n\
    \   |\n14 |         .map(|(a, b)| xor_chars(*a, *b))\n   |                   \
    \    ^^^^^^^^^ help: a local variable with a similar name exists: `a_chars`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let b_a = a.bytes().zip(b.bytes());\n  \
    \  b_a.map(|(x, y)| (x ^ y).to_string()).collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.into_bytes()\n        .iter()\n      \
    \  .zip(b.into_bytes().iter())\n        .map(|(a, b)| if a == b { b'0' } else\
    \ { b'1' })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n --> /tmp/tmpykbv062k.rs:8:10\n  |\n8 |        \
    \ .collect()\n  |          ^^^^^^^ value of type `String` cannot be built from\
    \ `std::iter::Iterator<Item=u8>`\n  |\n  = help: the trait `FromIterator<u8>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut bytes = a.into_bytes();\n    for\
    \ (i, c) in b.into_bytes().into_iter().enumerate() {\n        bytes[i] = bytes[i]\
    \ ^ c;\n    }\n    String::from_utf8(bytes).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpcubu9ja1.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut s = String::new();\n    for (a,\
    \ b) in a.chars().zip(b.chars()) {\n        if a == b {\n            s.push('0');\n\
    \        } else {\n            s.push('1');\n        }\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes\
    \ = b.into_bytes();\n    let mut result = String::new();\n    for i in 0..a_bytes.len()\
    \ {\n        if a_bytes[i] != b_bytes[i] {\n            result.push('1');\n  \
    \      } else {\n            result.push('0');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let res = a.chars().zip(b.chars()).map(|(a,\
    \ b)| (a == b) as usize);\n    res.map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"101101\"`,\n right: `\"010010\"`', /tmp/tmpvzcgin08.rs:10:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut\
    \ result = String::with_capacity(a.len());\n    for (a_char, b_char) in a.chars().zip(b.chars())\
    \ {\n        result.push(match (a_char, b_char) {\n            ('0', '0') => '0',\n\
    \            ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            (_, _) => unreachable!(),\n        });\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut ret = String::new();\n    if a.len()\
    \ != b.len() {\n        return ret;\n    }\n    for i in 0..a.len() {\n      \
    \  let a_char = a.chars().nth(i).unwrap();\n        let b_char = b.chars().nth(i).unwrap();\n\
    \        if a_char == b_char {\n            ret.push('0');\n        } else {\n\
    \            ret.push('1');\n        }\n    }\n    ret\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for (i,\
    \ j) in a.chars().zip(b.chars()) {\n        res.push(\n            match (i, j)\
    \ {\n                ('0', '0') => '0',\n                ('0', '1') => '1',\n\
    \                ('1', '0') => '1',\n                ('1', '1') => '0',\n    \
    \            _ => unreachable!(),\n            }\n        );\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_val = match a.chars().nth(i) {\n          \
    \  Some(x) => x.to_digit(10).unwrap(),\n            None => {\n              \
    \  panic!(\"No value present at position {} in string {}\", i, a);\n         \
    \   }\n        };\n        let b_val = match b.chars().nth(i) {\n            Some(x)\
    \ => x.to_digit(10).unwrap(),\n            None => {\n                panic!(\"\
    No value present at position {} in string {}\", i, b);\n            }\n      \
    \  };\n        let res = a_val ^ b_val;\n        result.push_str(&res.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut result = Vec::new();\n    for (i, j) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        let val = (*i ^ *j) as char;\n        result.push(val);\n    }\n\
    \    result.iter().collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpo0g0zumy.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // This can be easily done using the zip\
    \ function:\n    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        if c1 == c2 {\n            result.push('0');\n        } else {\n\
    \            result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.bytes()\n        .zip(b.bytes())\n   \
    \     .map(|(a, b)| (a ^ b).to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.into_bytes();\n    let b_bytes\
    \ = b.into_bytes();\n    let mut ret = vec![];\n    for (a, b) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        ret.push(match (a, b) {\n            (b'0', b'0') => b'0',\n    \
    \        (b'1', b'1') => b'0',\n            _ => b'1',\n        });\n    }\n \
    \   String::from_utf8(ret).unwrap()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.bytes()\n        .zip(b.bytes())\n   \
    \     .map(|(a, b)| (a ^ b).to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n       \
    \ let b_char = b.chars().nth(i).unwrap();\n        result.push(match (a_char,\
    \ b_char) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n\
    \            ('1', '0') => '1',\n            ('1', '1') => '0',\n            _\
    \ => panic!(\"bad string: {:?}\", a),\n        });\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.bytes()\n\
    \        .zip(b.bytes())\n        .map(|(left, right)| left ^ right)\n       \
    \ .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_nums: Vec<_> = a.chars().map(|c| c.to_digit(10).unwrap()).collect();\n\
    \    let b_nums: Vec<_> = b.chars().map(|c| c.to_digit(10).unwrap()).collect();\n\
    \    a_nums\n        .iter()\n        .zip(b_nums.iter())\n        .map(|(a, b)|\
    \ ((a + b) % 2).to_string())\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a: Vec<_> = a.chars().collect();\n \
    \   let b: Vec<_> = b.chars().collect();\n    assert_eq!(a.len(), b.len());\n\
    \    let mut c = Vec::with_capacity(a.len());\n    for i in 0..a.len() {\n   \
    \     let a = a[i];\n        let b = b[i];\n        if a == b {\n            c.push('0');\n\
    \        } else {\n            c.push('1');\n        }\n    }\n    c.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut out = String::new();\n    let mut\
    \ iter_a = a.chars();\n    let mut iter_b = b.chars();\n    loop {\n        let\
    \ c_a = iter_a.next();\n        let c_b = iter_b.next();\n        match (c_a,\
    \ c_b) {\n            (Some(c_a), Some(c_b)) => out.push(xor(c_a, c_b)),\n   \
    \         (Some(c_a), None) => out.push(c_a),\n            (None, Some(c_b)) =>\
    \ out.push(c_b),\n            (None, None) => break,\n        }\n    }\n    out\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmpjx4uf5pr.rs:11:48\n\
    \   |\n11 |             (Some(c_a), Some(c_b)) => out.push(xor(c_a, c_b)),\n \
    \  |                                                ^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| {\n            if x == y {\n                '0'\n        \
    \    } else {\n                '1'\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // as_bytes returns a &[u8] slice\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\n    // bytes() is\
    \ an iterator that yields one byte each time\n    let xor_iter = a_bytes.iter().zip(b_bytes.iter()).map(|(a,\
    \ b)| *a ^ *b);\n\n    let result = xor_iter.map(|b| b.to_string()).collect::<Vec<String>>().join(\"\
    \");\n\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut a_bytes = a.into_bytes();\n    let\
    \ mut b_bytes = b.into_bytes();\n    let a_len = a_bytes.len();\n    let b_len\
    \ = b_bytes.len();\n    let mut buf = Vec::with_capacity(a_len);\n    if a_len\
    \ >= b_len {\n        buf.extend_from_slice(&a_bytes[..b_len]);\n        a_bytes\
    \ = a_bytes[b_len..].to_vec();\n    } else {\n        buf.extend_from_slice(&b_bytes[..a_len]);\n\
    \        b_bytes = b_bytes[a_len..].to_vec();\n    }\n    for i in 0..buf.len()\
    \ {\n        buf[i] ^= a_bytes[i] ^ b_bytes[i];\n    }\n    String::from_utf8(buf).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpna984gej.rs:17:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_chars: Vec<char> = a.chars().collect();\n\
    \    let b_chars: Vec<char> = b.chars().collect();\n    let mut xored: Vec<char>\
    \ = Vec::new();\n\n    // XOR can only be done on equal length strings\n    if\
    \ a_chars.len() != b_chars.len() {\n        panic!(\"Strings are not of equal\
    \ length\");\n    }\n\n    for i in 0..a_chars.len() {\n        if a_chars[i]\
    \ == b_chars[i] {\n            xored.push('0');\n        } else {\n          \
    \  xored.push('1');\n        }\n    }\n\n    xored.iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut\
    \ result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars()) {\n  \
    \      let c = if c1 == c2 { '0' } else { '1' };\n        result.push(c);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::with_capacity(a.len());\n\
    \    let mut chars_a = a.chars();\n    let mut chars_b = b.chars();\n    while\
    \ let (Some(c1), Some(c2)) = (chars_a.next(), chars_b.next()) {\n        result.push(char_xor(c1,\
    \ c2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_xor` in this scope\n --> /tmp/tmp7_1jfnx7.rs:8:21\n\
    \  |\n8 |         result.push(char_xor(c1, c2));\n  |                     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| format!(\"{}\", x.to_digit(10).unwrap() ^ y.to_digit(10).unwrap()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    Lengths of inputs must be equal\");\n    }\n\n    let mut output = String::new();\n\
    \    for i in 0..a.len() {\n        let a_char = a.chars().nth(i).unwrap();\n\
    \        let b_char = b.chars().nth(i).unwrap();\n        output.push(xor(a_char,\
    \ b_char));\n    }\n    output\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmpa5i4uvd2.rs:12:21\n\
    \   |\n12 |         output.push(xor(a_char, b_char));\n   |                  \
    \   ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut\
    \ result = String::with_capacity(a.len());\n    for i in 0..a.len() {\n      \
    \  let x = a.chars().nth(i).unwrap();\n        let y = b.chars().nth(i).unwrap();\n\
    \        let z = if x == y { '0' } else { '1' };\n        result.push(z);\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    let mut res = vec![];\n    for (&a, &b) in a.iter().zip(b.iter()) {\n   \
    \     let a = a - b'0';\n        let b = b - b'0';\n        res.push(b'0' + ((a\
    \ ^ b) & 1) as u8);\n    }\n    String::from_utf8(res).unwrap()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut ret = String::new();\n    for (i,\
    \ j) in a.chars().zip(b.chars()) {\n        let (a, b) = (i.to_digit(10).unwrap(),\
    \ j.to_digit(10).unwrap());\n        ret.push_str(&format!(\"{}\", a ^ b));\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut result: Vec<u8> = Vec::new();\n    for i in 0..a_bytes.len()\
    \ {\n        let a_bit = a_bytes[i] - 48;\n        let b_bit = b_bytes[i] - 48;\n\
    \        let result_bit = a_bit ^ b_bit;\n        result.push(result_bit + 48);\n\
    \    }\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = hex::decode(a).unwrap();\n\
    \    let b_bytes = hex::decode(b).unwrap();\n    let xored = a_bytes.iter().zip(b_bytes.iter()).map(|(a,\
    \ b)| a ^ b);\n    hex::encode(xored.collect::<Vec<u8>>())\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `hex`\n\
    \ --> /tmp/tmpk7azbjc7.rs:4:19\n  |\n4 |     let a_bytes = hex::decode(a).unwrap();\n\
    \  |                   ^^^ use of undeclared crate or module `hex`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `hex`\n --> /tmp/tmpk7azbjc7.rs:5:19\n\
    \  |\n5 |     let b_bytes = hex::decode(b).unwrap();\n  |                   ^^^\
    \ use of undeclared crate or module `hex`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `hex`\n --> /tmp/tmpk7azbjc7.rs:7:5\n  |\n\
    7 |     hex::encode(xored.collect::<Vec<u8>>())\n  |     ^^^ use of undeclared\
    \ crate or module `hex`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Ugly, but I couldn't find a better way\
    \ to do it.\n    let mut result = String::new();\n    for (c1, c2) in a.chars().zip(b.chars())\
    \ {\n        if c1 == c2 {\n            result.push('0');\n        } else {\n\
    \            result.push('1');\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Handle sizes difference\n    let size\
    \ = a.len() - b.len();\n    let a = if size > 0 {\n        (&a[size..]).to_string()\n\
    \    } else {\n        a\n    };\n    let b = if size < 0 {\n        (&b[..size.abs()\
    \ as usize]).to_string()\n    } else {\n        b\n    };\n\n    // XOR string\n\
    \    let result = a\n        .chars()\n        .zip(b.chars())\n        .map(|(a,\
    \ b)| {\n            if a == b {\n                '0'\n            } else {\n\
    \                '1'\n            }\n        })\n        .collect::<String>();\n\
    \n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `abs` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpo_tud4hc.rs:12:20\n   |\n12 |         (&b[..size.abs()\
    \ as usize]).to_string()\n   |                    ^^^ method not found in `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut s = String::new();\n    for i in\
    \ 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            s.push('0');\n        } else {\n            s.push('1');\n  \
    \      }\n    }\n    s\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        let c = a.chars().nth(i).unwrap();\n        let d =\
    \ b.chars().nth(i).unwrap();\n        if c == d {\n            res.push('0');\n\
    \        } else {\n            res.push('1');\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Check input lengths\n    if a.len() !=\
    \ b.len() {\n        panic!(\"Non matching string lengths\");\n    }\n\n    //\
    \ Iterate the strings\n    let mut result = String::new();\n    for (a_bit, b_bit)\
    \ in a.chars().zip(b.chars()) {\n        result.push(match (a_bit, b_bit) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Bad\
    \ chars\"),\n        });\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = str_to_u8_arr(a);\n    let b = str_to_u8_arr(b);\n\
    \    let c = xor(&a, &b);\n    arr_to_str(c)\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `str_to_u8_arr` in this scope\n -->\
    \ /tmp/tmpy9lwapub.rs:4:13\n  |\n4 |     let a = str_to_u8_arr(a);\n  |      \
    \       ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `str_to_u8_arr` in this scope\n --> /tmp/tmpy9lwapub.rs:5:13\n  |\n5 |     let\
    \ b = str_to_u8_arr(b);\n  |             ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpy9lwapub.rs:6:13\n\
    \  |\n6 |     let c = xor(&a, &b);\n  |             ^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `arr_to_str` in this scope\n --> /tmp/tmpy9lwapub.rs:7:5\n\
    \  |\n7 |     arr_to_str(c)\n  |     ^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    a.bytes()\n\
    \        .zip(b.bytes())\n        .map(|(x, y)| (x ^ y).to_string())\n       \
    \ .collect::<Vec<String>>()\n        .join(\"\")\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut i: usize = 0;\n    let mut len =\
    \ a.len();\n    if b.len() < len {\n        len = b.len();\n    }\n    let mut\
    \ output = String::with_capacity(len);\n    while i < len {\n        let xor =\
    \ a.as_bytes()[i] ^ b.as_bytes()[i];\n        output.push_str(&format!(\"{}\"\
    , xor));\n        i += 1;\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut a_bytes = a.bytes();\n    let mut b_bytes = b.bytes();\n    loop {\n   \
    \     let a_ch = a_bytes.next();\n        let b_ch = b_bytes.next();\n       \
    \ match (a_ch, b_ch) {\n            (Some(a_ch), Some(b_ch)) => {\n          \
    \      result.push(match (a_ch, b_ch) {\n                    (b'0', b'0') => '0',\n\
    \                    (b'0', b'1') => '1',\n                    (b'1', b'0') =>\
    \ '1',\n                    (b'1', b'1') => '0',\n                    _ => unreachable!(),\n\
    \                });\n            }\n            (Some(_), None) => break,\n \
    \           (None, Some(_)) => break,\n            (None, None) => break,\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(c1, c2)| match (c1, c2) {\n            ('0', '0') => '0',\n     \
    \       ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1',\
    \ '1') => '0',\n            _ => panic!(\"bad input\"),\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = str_to_byte_array(a);\n    let b\
    \ = str_to_byte_array(b);\n    let result = xor(&a, &b);\n    byte_array_to_str(&result)\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `str_to_byte_array` in this scope\n\
    \ --> /tmp/tmp8gsk75sz.rs:4:13\n  |\n4 |     let a = str_to_byte_array(a);\n \
    \ |             ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `str_to_byte_array` in this scope\n --> /tmp/tmp8gsk75sz.rs:5:13\n\
    \  |\n5 |     let b = str_to_byte_array(b);\n  |             ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `xor` in this\
    \ scope\n --> /tmp/tmp8gsk75sz.rs:6:18\n  |\n6 |     let result = xor(&a, &b);\n\
    \  |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `byte_array_to_str` in this scope\n --> /tmp/tmp8gsk75sz.rs:7:5\n \
    \ |\n7 |     byte_array_to_str(&result)\n  |     ^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut s = String::new();\n    for i in\
    \ 0..a.len() {\n        s.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a: Vec<char> = a.chars().collect();\n\
    \    let b: Vec<char> = b.chars().collect();\n    assert_eq!(a.len(), b.len());\n\
    \    assert!(a.iter().all(|x| x == &'0' || x == &'1'));\n    assert!(b.iter().all(|x|\
    \ x == &'0' || x == &'1'));\n\n    let mut result = Vec::with_capacity(a.len());\n\
    \    for (x, y) in a.iter().zip(b.iter()) {\n        if x == y {\n           \
    \ result.push('0');\n        } else {\n            result.push('1');\n       \
    \ }\n    }\n    result.iter().collect()\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Convert the strings to binary strings.\n\
    \    let a_bin = a.as_bytes();\n    let b_bin = b.as_bytes();\n\n    // If the\
    \ two input are of different lengths, use the shortest one as the length.\n  \
    \  let length = if a_bin.len() < b_bin.len() {\n        a_bin.len()\n    } else\
    \ {\n        b_bin.len()\n    };\n\n    // Perform XOR on the first length bits\
    \ of the binary strings.\n    let mut result = String::new();\n    for i in 0..length\
    \ {\n        if a_bin[i] == b_bin[i] {\n            result.push('0');\n      \
    \  } else {\n            result.push('1');\n        }\n    }\n\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        result.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut output = String::new();\n    for\
    \ (x, y) in a.bytes().zip(b.bytes()) {\n        output.push( (x ^ y) as char );\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpv2cg3mzx.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = a.chars().map(|x| x.to_digit(10).unwrap()).collect::<Vec<u32>>();\n\
    \    let b = b.chars().map(|x| x.to_digit(10).unwrap()).collect::<Vec<u32>>();\n\
    \    let max_length = std::cmp::max(a.len(), b.len());\n    let a: Vec<u32> =\
    \ a.into_iter().chain(repeat(0).take(max_length - a.len())).collect();\n    let\
    \ b: Vec<u32> = b.into_iter().chain(repeat(0).take(max_length - b.len())).collect();\n\
    \    a.iter().zip(b.iter()).map(|(x, y)| x ^ y).map(|x| x.to_string()).collect::<Vec<String>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `repeat` in this scope\n --> /tmp/tmpswrpg835.rs:7:43\n\
    \  |\n7 |     let a: Vec<u32> = a.into_iter().chain(repeat(0).take(max_length\
    \ - a.len())).collect();\n  |                                           ^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing one of these items\n\
    \  |\n1 | use std::io::repeat;\n  |\n1 | use std::iter::repeat;\n  |\n\nerror[E0425]:\
    \ cannot find function `repeat` in this scope\n --> /tmp/tmpswrpg835.rs:8:43\n\
    \  |\n8 |     let b: Vec<u32> = b.into_iter().chain(repeat(0).take(max_length\
    \ - b.len())).collect();\n  |                                           ^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing one of these items\n\
    \  |\n1 | use std::io::repeat;\n  |\n1 | use std::iter::repeat;\n  |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.bytes()\n        .zip(b.bytes())\n   \
    \     .map(|(x, y)| (x ^ y).to_string())\n        .collect::<Vec<String>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bin = String::from_utf8(a.into_bytes()).unwrap();\n\
    \    let b_bin = String::from_utf8(b.into_bytes()).unwrap();\n    let a_bytes\
    \ = a_bin.as_bytes();\n    let b_bytes = b_bin.as_bytes();\n    let mut result\
    \ = String::new();\n    for i in 0..a_bytes.len() {\n        result.push_str(if\
    \ a_bytes[i] ^ b_bytes[i] == 0 { \"0\" } else { \"1\" });\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let xored = a_bytes.iter().zip(b_bytes.iter()).map(|(a,\
    \ b)| {\n        if a == b {\n            b'0'\n        } else {\n           \
    \ b'1'\n        }\n    });\n    String::from_utf8(xored.collect()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = \"\".to_string();\n    for\
    \ i in 0..a.len() {\n        let a_ch = a.chars().nth(i).unwrap();\n        let\
    \ b_ch = b.chars().nth(i).unwrap();\n        let res_ch = match (a_ch, b_ch) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Unexpected\
    \ input\")\n        };\n        res.push(res_ch);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Convert the strings to bytes, then to\
    \ chars and xor them char by char.\n    a.into_bytes()\n        .into_iter()\n\
    \        .zip(b.into_bytes().into_iter())\n        .map(|(x, y)| (x ^ y) as char)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpqlyacw88.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // For this exercise we assume that the\
    \ inputs are the same length.\n    assert_eq!(a.len(), b.len());\n\n    // TODO\n\
    \    \"0\".to_string()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0\"`,\n right: `\"010010\"`', /tmp/tmp7w5lwob5.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut result = String::new();\n    for i in 0..std::cmp::min(a_bytes.len(),\
    \ b_bytes.len()) {\n        result.push(match (a_bytes[i], b_bytes[i]) {\n   \
    \         (b'0', b'0') => '0',\n            (b'0', b'1') => '1',\n           \
    \ (b'1', b'0') => '1',\n            (b'1', b'1') => '0',\n            _ => unreachable!(),\n\
    \        });\n    }\n    for i in std::cmp::min(a_bytes.len(), b_bytes.len())..std::cmp::max(a_bytes.len(),\
    \ b_bytes.len()) {\n        result.push(match a_bytes.get(i) {\n            Some(b'0')\
    \ => '0',\n            Some(b'1') => '1',\n            _ => unreachable!(),\n\
    \        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    xor(decode_hex(a), decode_hex(b))\n    \
    \    .into_iter()\n        .map(|x| format!(\"{:x}\", x))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmprp2h5ocp.rs:4:5\n\
    \  |\n4 |     xor(decode_hex(a), decode_hex(b))\n  |     ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `decode_hex` in this scope\n -->\
    \ /tmp/tmprp2h5ocp.rs:4:9\n  |\n4 |     xor(decode_hex(a), decode_hex(b))\n  |\
    \         ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `decode_hex` in this scope\n --> /tmp/tmprp2h5ocp.rs:4:24\n  |\n4 |     xor(decode_hex(a),\
    \ decode_hex(b))\n  |                        ^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut out = String::new();\n    for (i,\
    \ (x, y)) in a.chars().zip(b.chars()).enumerate() {\n        let x = if x == '1'\
    \ { 1 } else { 0 };\n        let y = if y == '1' { 1 } else { 0 };\n        out.push(if\
    \ x ^ y == 1 { '1' } else { '0' });\n    }\n    out\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut result = Vec::with_capacity(max(a_bytes.len(),\
    \ b_bytes.len()));\n    for (byte_a, byte_b) in a_bytes.iter().zip(b_bytes.iter())\
    \ {\n        result.push(match (byte_a, byte_b) {\n            (b'0', b'0') =>\
    \ b'0',\n            (b'1', b'1') => b'0',\n            _ => b'1',\n        });\n\
    \    }\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpdhuc85qw.rs:6:41\n\
    \  |\n6 |     let mut result = Vec::with_capacity(max(a_bytes.len(), b_bytes.len()));\n\
    \  |                                         ^^^ not found in this scope\n  |\n\
    help: consider importing this function\n  |\n1 | use std::cmp::max;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| if x == y { '0' } else { '1' })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    String::from_utf8(a.as_bytes().iter().zip(b.as_bytes().iter()).map(|(x,\
    \ y)| {\n        if x == y {\n            '0' as u8\n        } else {\n      \
    \      '1' as u8\n        }\n    }).collect()).unwrap()\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let a_len = a_bytes.len();\n    let b_len = b_bytes.len();\n\
    \    let mut result = Vec::new();\n    for i in 0..max(a_len, b_len) {\n     \
    \   let x = if i < a_len { a_bytes[i] } else { 48 };\n        let y = if i < b_len\
    \ { b_bytes[i] } else { 48 };\n        let res = x ^ y;\n        result.push(res);\n\
    \    }\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpo7z2he9y.rs:9:17\n\
    \  |\n9 |     for i in 0..max(a_len, b_len) {\n  |                 ^^^ not found\
    \ in this scope\n  |\nhelp: consider importing this function\n  |\n1 | use std::cmp::max;\n\
    \  |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        let d1 = c1.to_digit(10).unwrap();\n\
    \        let d2 = c2.to_digit(10).unwrap();\n        result.push_str(&format!(\"\
    {}\", d1 ^ d2));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Convert to integers.\n    let a = i32::from_str_radix(&a,\
    \ 2).unwrap();\n    let b = i32::from_str_radix(&b, 2).unwrap();\n\n    // XOR\
    \ inputs.\n    let result = a ^ b;\n\n    // Convert back to string.\n    format!(\"\
    {:b}\", result)\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"10010\"`,\n right: `\"010010\"`', /tmp/tmp7aensh0m.rs:17:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut output = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        let a = a.to_digit(10).unwrap()\
    \ as u8;\n        let b = b.to_digit(10).unwrap() as u8;\n        output.push_str(&(a\
    \ ^ b).to_string());\n    }\n    output\n}\n\nfn main() {\n    let candidate =\
    \ string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for (c1,\
    \ c2) in a.chars().zip(b.chars()) {\n        let c1 = c1.to_digit(10).unwrap();\n\
    \        let c2 = c2.to_digit(10).unwrap();\n        res.push_str(&(c1 ^ c2).to_string());\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::with_capacity(a.len());\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        if a == b {\n         \
    \   result.push('0');\n        } else {\n            result.push('1');\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| match (x, y) {\n            ('0', '0') => '0',\n         \
    \   ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input\"),\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| {\n            if x == y {\n                '0'\n        \
    \    } else {\n                '1'\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut xor = String::new();\n    for i\
    \ in 0..a.len() {\n        xor.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    xor\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| x.to_digit(2).unwrap() ^ y.to_digit(2).unwrap())\n       \
    \ .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_as_char = a.chars().nth(i).unwrap();\n    \
    \    let b_as_char = b.chars().nth(i).unwrap();\n        let a_as_int = a_as_char.to_digit(10).unwrap();\n\
    \        let b_as_int = b_as_char.to_digit(10).unwrap();\n        let int_result\
    \ = a_as_int ^ b_as_int;\n        result.push_str(&int_result.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // TODO: Put your code here!\n    let mut\
    \ result = String::new();\n    for i in 0..a.len() {\n        if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            result.push('0');\n        } else\
    \ {\n            result.push('1');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        result.push(match (a.as_bytes()[i], b.as_bytes()[i])\
    \ {\n            (b'0', b'0') => '0',\n            (b'1', b'1') => '0',\n    \
    \        _ => '1',\n        });\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // TODO: Implement string XOR here and remove\
    \ expect\n    panic!(\"not implemented\");\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpk56d3hli.rs:5:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.into_bytes()\n        .iter()\n      \
    \  .zip(b.into_bytes().iter())\n        .map(|(x, y)| format!(\"{}\", (*x ^ *y)\
    \ as char))\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmp2d0qa0e3.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut a = a.as_bytes();\n    let mut b\
    \ = b.as_bytes();\n    let mut r = String::new();\n    let mut i = 0;\n    while\
    \ i < a.len() {\n        let ar = a[i] - 48;\n        let br = b[i] - 48;\n  \
    \      let res = ar ^ br;\n        r.push_str(&res.to_string());\n        i +=\
    \ 1;\n    }\n    r\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        if i == j {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    (0..a.len())\n        .map(|i| if a.chars().nth(i)\
    \ == b.chars().nth(i) { '0' } else { '1' })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut b_chars = b.chars();\n    for a_char in a.chars() {\n        let b_char\
    \ = b_chars.next().unwrap();\n        result.push(match (a_char, b_char) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Character\
    \ other than 1 or 0 in input\"),\n        });\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut xored = String::new();\n    let\
    \ mut a_chars = a.chars();\n    let mut b_chars = b.chars();\n    loop {\n   \
    \     match (a_chars.next(), b_chars.next()) {\n            (Some(a_char), Some(b_char))\
    \ => {\n                xored.push(\n                    match (a_char == '1',\
    \ b_char == '1') {\n                        (true, true) => '0',\n           \
    \             (true, false) => '1',\n                        (false, true) =>\
    \ '1',\n                        (false, false) => '0',\n                    }\n\
    \                );\n            },\n            (Some(_), None) => panic!(\"\
    Strings are not of equal length\"),\n            (None, Some(_)) => panic!(\"\
    Strings are not of equal length\"),\n            (None, None) => break,\n    \
    \    }\n    }\n    xored\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    Invalid input: string a and b must be of equal length.\");\n    }\n\n    let a\
    \ = a.into_bytes();\n    let b = b.into_bytes();\n\n    let mut out = String::with_capacity(a.len());\n\
    \n    for i in 0..a.len() {\n        if a[i] == b'1' && b[i] == b'1' {\n     \
    \       out.push('0');\n        } else if a[i] == b'0' && b[i] == b'0' {\n   \
    \         out.push('0');\n        } else {\n            out.push('1');\n     \
    \   }\n    }\n\n    out\n}\n\nfn main() {\n    let candidate = string_xor;\n \
    \   assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| x.to_digit(2).unwrap() ^ y.to_digit(2).unwrap())\n       \
    \ .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (char_a, char_b) in a.chars().zip(b.chars()) {\n        let digit_a = char_a.to_digit(10).unwrap_or(0);\n\
    \        let digit_b = char_b.to_digit(10).unwrap_or(0);\n        result.push_str(&format!(\"\
    {}\", digit_a ^ digit_b));\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = a.chars().map(|x| x == '1');\n \
    \   let b = b.chars().map(|x| x == '1');\n    let x = a.zip(b).map(|(a, b)| a\
    \ ^ b);\n    x.map(|x| if x { '1' } else { '0' }).collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        let a_b = a.as_bytes()[i] == b'1';\n        let b_b\
    \ = b.as_bytes()[i] == b'1';\n        let res = if a_b ^ b_b { '1' } else { '0'\
    \ };\n        result.push(res);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    Can't perform XOR on strings of different lengths\");\n    }\n\n    let mut result\
    \ = String::new();\n    for (i, j) in a.chars().zip(b.chars()) {\n        if i\
    \ == j {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c1, c2) in a.chars().zip(b.chars()) {\n        if c1 == c2 {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut output = String::with_capacity(a.len());\n\
    \    for (a, b) in a.chars().zip(b.chars()) {\n        output.push(if a == b {\
    \ '0' } else { '1' });\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| char_xor(a, b))\n        .collect()\n}\n\nfn main() {\n  \
    \  let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_xor` in this scope\n --> /tmp/tmps7rdymcs.rs:6:23\n\
    \  |\n6 |         .map(|(a, b)| char_xor(a, b))\n  |                       ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822352
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Convert the strings to binary\n    let\
    \ a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n\n    // Iterate through\
    \ each byte and XOR them\n    let mut xor_bytes = Vec::with_capacity(a_bytes.len());\n\
    \    for (index, a_byte) in a_bytes.iter().enumerate() {\n        let b_byte =\
    \ b_bytes[index];\n        let xor_value = a_byte ^ b_byte;\n        xor_bytes.push(xor_value);\n\
    \    }\n\n    // Convert the result to a string\n    let xor_string = xor_bytes.iter().map(|b|\
    \ *b as char).collect();\n    xor_string\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmp9mefhjr1.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut a: Vec<char> = a.chars().collect();\n\
    \    let mut b: Vec<char> = b.chars().collect();\n    let mut r: Vec<char> = vec![];\n\
    \n    while a.len() > 0 || b.len() > 0 {\n        let tmp = match (a.pop(), b.pop())\
    \ {\n            (Some(x), Some(y)) => {\n                match (x, y) {\n   \
    \                 ('0', '0') => '0',\n                    ('1', '1') => '0',\n\
    \                    ('0', '1') => '1',\n                    ('1', '0') => '1',\n\
    \                    _ => panic!(\"Input binary string is invalid: {}\", a.len()),\n\
    \                }\n            }\n            (Some(x), None) => {\n        \
    \        match x {\n                    '0' => '0',\n                    '1' =>\
    \ '1',\n                    _ => panic!(\"Input binary string is invalid: {}\"\
    , a.len()),\n                }\n            }\n            (None, Some(y)) =>\
    \ {\n                match y {\n                    '0' => '0',\n            \
    \        '1' => '1',\n                    _ => panic!(\"Input binary string is\
    \ invalid: {}\", b.len()),\n                }\n            }\n            (None,\
    \ None) => '0',\n        };\n        r.push(tmp);\n    }\n    r.reverse();\n \
    \   r.iter().collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut c = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        let mut ch = a.chars().nth(i).unwrap();\n\
    \        let b_ch = b.chars().nth(i).unwrap();\n        if ch == b_ch {\n    \
    \        ch = '0';\n        } else {\n            ch = '1';\n        }\n     \
    \   c.push(ch);\n    }\n    c\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| {\n            let x = x.to_digit(10).unwrap();\n        \
    \    let y = y.to_digit(10).unwrap();\n            let res = x ^ y;\n        \
    \    res.to_string()\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    if a_bytes.len() != b_bytes.len() {\n        panic!(\"\
    Cannot XOR strings of unequal length\");\n    }\n    let mut result = String::with_capacity(a_bytes.len());\n\
    \    for i in 0..a_bytes.len() {\n        let a_byte = a_bytes[i];\n        let\
    \ b_byte = b_bytes[i];\n        result.push(\n            match (a_byte, b_byte)\
    \ {\n                (b'0', b'0') => '0',\n                (b'0', b'1') => '1',\n\
    \                (b'1', b'0') => '1',\n                (b'1', b'1') => '0',\n\
    \                _ => panic!(\"Invalid character in string XOR\"),\n         \
    \   }\n        );\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let n = a.len();\n    let mut c = String::new();\n\
    \    assert_eq!(n, b.len());\n    for i in 0..n {\n        match (a.chars().nth(i),\
    \ b.chars().nth(i)) {\n            (Some('0'), Some('0')) => c.push('0'),\n  \
    \          (Some('1'), Some('1')) => c.push('0'),\n            (Some('0'), Some('1'))\
    \ => c.push('1'),\n            (Some('1'), Some('0')) => c.push('1'),\n      \
    \      _ => panic!(\"Invalid input\"),\n        }\n    }\n    c\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // First we transform these strings into\
    \ a vector of boolean values, which\n    // is most convenient for the work we\
    \ will be doing later.\n    let as_bools = string_to_bools(a);\n    let bs_bools\
    \ = string_to_bools(b);\n\n    // Then, we do the xor operation on each index\
    \ in a and b's bools, then\n    // push it to the back of a new vector.\n    let\
    \ mut xor_bools = Vec::new();\n    for i in 0..as_bools.len() {\n        xor_bools.push(xor(as_bools[i],\
    \ bs_bools[i]));\n    }\n\n    // Finally, transform this vector of booleans back\
    \ into a string.\n    bools_to_string(xor_bools)\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `string_to_bools` in this scope\n -->\
    \ /tmp/tmp46ff7f9m.rs:6:20\n  |\n6 |     let as_bools = string_to_bools(a);\n\
    \  |                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `string_to_bools` in this scope\n --> /tmp/tmp46ff7f9m.rs:7:20\n\
    \  |\n7 |     let bs_bools = string_to_bools(b);\n  |                    ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `xor` in this\
    \ scope\n  --> /tmp/tmp46ff7f9m.rs:13:24\n   |\n13 |         xor_bools.push(xor(as_bools[i],\
    \ bs_bools[i]));\n   |                        ^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `bools_to_string` in this scope\n  --> /tmp/tmp46ff7f9m.rs:17:5\n\
    \   |\n17 |     bools_to_string(xor_bools)\n   |     ^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // first generate a & b\n    let a = a.into_bytes();\n\
    \    let b = b.into_bytes();\n    let mut result = Vec::with_capacity(a.len());\n\
    \    for (i, (x, y)) in a.iter().zip(b.iter()).enumerate() {\n        if i < b.len()\
    \ {\n            result.push(x ^ y);\n        }\n    }\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmp08ifn4tf.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    xor_crypt::xor(a, b)\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `xor_crypt`\n\
    \ --> /tmp/tmpuy386l0x.rs:4:5\n  |\n4 |     xor_crypt::xor(a, b)\n  |     ^^^^^^^^^\
    \ use of undeclared crate or module `xor_crypt`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let bytes_a = a.into_bytes();\n    let bytes_b\
    \ = b.into_bytes();\n    let mut result = String::new();\n    for i in 0..bytes_a.len()\
    \ {\n        if bytes_a[i] == bytes_b[i] {\n            result.push('0');\n  \
    \      } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut out = String::new();\n    for (ch1,\
    \ ch2) in a.chars().zip(b.chars()) {\n        out.push(match (ch1, ch2) {\n  \
    \          ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"Wrong\
    \ input, only 0 and 1 are allowed\"),\n        });\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    let a_chars\
    \ = a.chars();\n    let b_chars = b.chars();\n    for (a_char, b_char) in a_chars.zip(b_chars)\
    \ {\n        if a_char == b_char {\n            res.push('0');\n        } else\
    \ {\n            res.push('1');\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    if a_bytes.len() != b_bytes.len() {\n        panic!(\"\
    Error: Length of the two inputs must be equal.\");\n    }\n    let mut result\
    \ = String::with_capacity(a_bytes.len());\n    for i in 0..a_bytes.len() {\n \
    \       let c = if a_bytes[i] == b_bytes[i] {\n            b'0'\n        } else\
    \ {\n            b'1'\n        };\n        result.push(c as char);\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_bytes = a.as_bytes();\n    let b_bytes\
    \ = b.as_bytes();\n    let mut res = Vec::with_capacity(max(a_bytes.len(), b_bytes.len()));\n\
    \    for i in 0..max(a_bytes.len(), b_bytes.len()) {\n        res.push(if a_bytes.get(i)\
    \ == b_bytes.get(i) { b'0' } else { b'1' });\n    }\n    String::from_utf8(res).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n --> /tmp/tmpmalvsibd.rs:6:38\n\
    \  |\n6 |     let mut res = Vec::with_capacity(max(a_bytes.len(), b_bytes.len()));\n\
    \  |                                      ^^^ not found in this scope\n  |\nhelp:\
    \ consider importing this function\n  |\n1 | use std::cmp::max;\n  |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n --> /tmp/tmpmalvsibd.rs:7:17\n  |\n\
    7 |     for i in 0..max(a_bytes.len(), b_bytes.len()) {\n  |                 ^^^\
    \ not found in this scope\n  |\nhelp: consider importing this function\n  |\n\
    1 | use std::cmp::max;\n  |\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = \"\".to_string();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // TODO: Implement\n    a.chars().zip(b.chars()).map(|(ac,\
    \ bc)| {\n        if ac == bc {\n            '0'\n        } else {\n         \
    \   '1'\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        result.push(match (a, b) {\n \
    \           ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => unreachable!(),\n\
    \        });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut xor = String::new();\n    for (i,\
    \ c) in a.chars().enumerate() {\n        if c == b.chars().nth(i).unwrap() {\n\
    \            xor.push('0');\n        } else {\n            xor.push('1');\n  \
    \      }\n    }\n    xor\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| {\n            match (x, y) {\n                ('1', '1')\
    \ => '0',\n                ('0', '0') => '0',\n                _ => '1',\n   \
    \         }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_len = a.len();\n    let b_len = b.len();\n\
    \    let mut result = String::with_capacity(std::cmp::max(a_len, b_len));\n  \
    \  let mut a_iter = a.bytes();\n    let mut b_iter = b.bytes();\n    for _ in\
    \ 0..a_len {\n        let a_byte = a_iter.next().unwrap();\n        let b_byte\
    \ = b_iter.next().unwrap();\n        result.push_str(&((a_byte ^ b_byte) as char).to_string());\n\
    \    }\n    for _ in a_len..b_len {\n        let b_byte = b_iter.next().unwrap();\n\
    \        result.push_str(&((0 ^ b_byte) as char).to_string());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmp0gqj2swn.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Create Vecs from input strings.\n   \
    \ let mut a_bytes = a.bytes().collect::<Vec<u8>>();\n    let mut b_bytes = b.bytes().collect::<Vec<u8>>();\n\
    \n    // Make sure the vectors are the same length.\n    if a_bytes.len() < b_bytes.len()\
    \ {\n        a_bytes.extend(vec![b'0'; b_bytes.len() - a_bytes.len()].iter());\n\
    \    } else if b_bytes.len() < a_bytes.len() {\n        b_bytes.extend(vec![b'0';\
    \ a_bytes.len() - b_bytes.len()].iter());\n    }\n\n    // Implement XOR.\n  \
    \  let mut xor_bytes = vec![0; a_bytes.len()];\n    for i in 0..a_bytes.len()\
    \ {\n        if a_bytes[i] == b_bytes[i] {\n            xor_bytes[i] = b'0';\n\
    \        } else {\n            xor_bytes[i] = b'1';\n        }\n    }\n\n    //\
    \ Convert back to string and return.\n    let mut xor_string = String::new();\n\
    \    for i in xor_bytes {\n        xor_string.push(i as char);\n    }\n    xor_string\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    xor(a.into_bytes(), b.into_bytes())\n  \
    \      .into_iter()\n        .map(|b| format!(\"{:02x}\", b))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n --> /tmp/tmpvzn29kt9.rs:4:5\n\
    \  |\n4 |     xor(a.into_bytes(), b.into_bytes())\n  |     ^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let x = a.chars()\n        .zip(b.chars())\n\
    \        .map(|(a, b)| (a.to_digit(10), b.to_digit(10)))\n        .map(|(a, b)|\
    \ (a.unwrap(), b.unwrap()))\n        .map(|(a, b)| a ^ b)\n        .map(|x| x.to_string())\n\
    \        .collect::<Vec<String>>()\n        .join(\"\");\n    return x;\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    format!(\"{:b}\", parse_string_to_u64(&a)\
    \ ^ parse_string_to_u64(&b))\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_string_to_u64` in this scope\n\
    \ --> /tmp/tmp5lcan01n.rs:4:21\n  |\n4 |     format!(\"{:b}\", parse_string_to_u64(&a)\
    \ ^ parse_string_to_u64(&b))\n  |                     ^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `parse_string_to_u64`\
    \ in this scope\n --> /tmp/tmp5lcan01n.rs:4:47\n  |\n4 |     format!(\"{:b}\"\
    , parse_string_to_u64(&a) ^ parse_string_to_u64(&b))\n  |                    \
    \                           ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let first_vec: Vec<char> = a.chars().collect();\n\
    \    let second_vec: Vec<char> = b.chars().collect();\n    let mut res: Vec<char>\
    \ = Vec::new();\n    for i in 0..a.len() {\n        if first_vec[i] == second_vec[i]\
    \ {\n            res.push('0');\n        } else {\n            res.push('1');\n\
    \        }\n    }\n    let mut result = String::new();\n    for j in 0..res.len()\
    \ {\n        result.push(res[j]);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n  let a_b = a.chars().zip(b.chars());\n  a_b.map(|(a,\
    \ b)| {\n    if a == b {\n      '0'\n    } else {\n      '1'\n    }\n  }).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let length = a.len();\n    let mut result\
    \ = String::new();\n    for i in 0..length {\n        if a.chars().nth(i).unwrap()\
    \ == b.chars().nth(i).unwrap() {\n            result.push('0');\n        } else\
    \ {\n            result.push('1');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let a_chars:\
    \ Vec<char> = a.chars().collect();\n    let b_chars: Vec<char> = b.chars().collect();\n\
    \    let mut result = String::new();\n    for i in 0..a.len() {\n        let a_char\
    \ = a_chars[i];\n        let b_char = b_chars[i];\n        result.push(xor(a_char,\
    \ b_char));\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `xor` in this scope\n  --> /tmp/tmp5gjhy203.rs:11:21\n\
    \   |\n11 |         result.push(xor(a_char, b_char));\n   |                  \
    \   ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut bytes_a = a.into_bytes();\n    let mut bytes_b = b.into_bytes();\n    let\
    \ mut i = 0;\n    while i < bytes_a.len() {\n        result.push(char::from(bytes_a[i]\
    \ ^ bytes_b[i]));\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpmgna598m.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    if a.len() != b.len() {\n        panic!(\"String lengths not equal.\");\n\
    \    }\n    let mut res = Vec::new();\n    for i in 0..a.len() {\n        let\
    \ c = match (a[i], b[i]) {\n            (48, 48) => 48, // 48 = '0'\n        \
    \    (48, 49) => 49,\n            (49, 48) => 49,\n            (49, 49) => 48,\n\
    \            _ => panic!(\"Invalid character.\"),\n        };\n        res.push(c);\n\
    \    }\n    let res = String::from_utf8(res).unwrap();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut a = a.chars();\n    let mut b =\
    \ b.chars();\n    let mut output = String::new();\n    while let (Some(a_char),\
    \ Some(b_char)) = (a.next(), b.next()) {\n        output.push(match (a_char, b_char)\
    \ {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n        \
    \    ('1', '0') => '1',\n            ('1', '1') => '0',\n            _ => '?',\n\
    \        });\n    }\n    output\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let int_a = u8::from_str_radix(&a, 2).unwrap();\n\
    \    let int_b = u8::from_str_radix(&b, 2).unwrap();\n    let int_res = int_a\
    \ ^ int_b;\n    format!(\"{:08b}\", int_res)\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"00010010\"`,\n right: `\"010010\"`', /tmp/tmpbjfxeisv.rs:12:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n  let a = a.into_bytes();\n  let b = b.into_bytes();\n\
    \  let mut result = Vec::new();\n  let mut i = 0;\n  while i < a.len() && i <\
    \ b.len() {\n    result.push(a[i] ^ b[i]);\n    i += 1;\n  }\n  result.extend(a[i..].iter().cloned());\n\
    \  result.extend(b[i..].iter().cloned());\n  String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpltfg9uz_.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut alen = a.len();\n    let mut blen = b.len();\n    let mut achars = a.chars();\n\
    \    let mut bchars = b.chars();\n    let mut ac: char;\n    let mut bc: char;\n\
    \    while alen > 0 && blen > 0 {\n        ac = achars.next().unwrap();\n    \
    \    bc = bchars.next().unwrap();\n        if ac == bc {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n        alen -= 1;\n\
    \        blen -= 1;\n    }\n    if alen > 0 {\n        while alen > 0 {\n    \
    \        ac = achars.next().unwrap();\n            result.push(ac);\n        \
    \    alen -= 1;\n        }\n    } else if blen > 0 {\n        while blen > 0 {\n\
    \            bc = bchars.next().unwrap();\n            result.push(bc);\n    \
    \        blen -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut out = String::new();\n    for (a,\
    \ b) in a.chars().zip(b.chars()) {\n        out.push(\n            match (a, b)\
    \ {\n                ('0', '0') => '0',\n                ('0', '1') => '1',\n\
    \                ('1', '0') => '1',\n                ('1', '1') => '0',\n    \
    \            _ => 'E',\n            }\n        );\n    }\n    out\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| match (a, b) {\n            ('0', '0') => '0',\n         \
    \   ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"invalid character in string\"),\n       \
    \ })\n        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for (ai,\
    \ bi) in a.chars().zip(b.chars()) {\n        res.push(match (ai, bi) {\n     \
    \       ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => unreachable!(),\n\
    \        });\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ i in 0..a.len() {\n        if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822353
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Convert to bytes, then operate element-wise\n\
    \    let a_bytes = a.as_bytes();\n    let b_bytes = b.as_bytes();\n    let mut\
    \ result = Vec::new();\n    for (a, b) in a_bytes.iter().zip(b_bytes.iter()) {\n\
    \        result.push(a ^ b);\n    }\n    // Convert back to a string\n    String::from_utf8(result).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpa78g8at7.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = \"\".to_string();\n   \
    \ for (l, r) in a.chars().zip(b.chars()) {\n        if l == r {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        result.push(if i == j { '0' }\
    \ else { '1' });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut c = String::new();\n    for i in\
    \ 0..a.len() {\n        c.push(if a.chars().nth(i).unwrap() == b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    c\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(ai, bi)| if ai == bi { '0' } else { '1' })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(x, y)| match (x, y) {\n            ('0', '0') => '0',\n         \
    \   ('0', '1') => '1',\n            ('1', '0') => '1',\n            ('1', '1')\
    \ => '0',\n            _ => panic!(\"Invalid input!\"),\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Split a and b into bytes\n    let mut\
    \ a_bytes = a.as_bytes();\n    let mut b_bytes = b.as_bytes();\n\n    // Check\
    \ that the strings are of equal length\n    assert_eq!(a_bytes.len(), b_bytes.len());\n\
    \n    // Get the number of bytes\n    let length = a_bytes.len();\n\n    // Create\
    \ a new vector to store the xor bytes\n    let mut xor_bytes = Vec::with_capacity(length);\n\
    \n    // Perform xor\n    for i in 0..length {\n        xor_bytes.push(a_bytes[i]\
    \ ^ b_bytes[i]);\n    }\n\n    // Convert back to a string and return\n    String::from_utf8(xor_bytes).unwrap()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\\u{1}\\u{0}\\u{0}\\u{1}\\u{0}\"`,\n right: `\"010010\"`', /tmp/tmpk4dlwbz3.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n  a.chars()\n    .zip(b.chars())\n    .map(|(x,\
    \ y)| match (x, y) {\n      ('0', '0') => '0',\n      ('0', '1') => '1',\n   \
    \   ('1', '0') => '1',\n      ('1', '1') => '0',\n      _ => panic!(\"Invalid\
    \ input\"),\n    })\n    .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a_num = str_to_num(a);\n    let b_num\
    \ = str_to_num(b);\n    num_to_str(a_num ^ b_num)\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `str_to_num` in this scope\n --> /tmp/tmp9tfymfkk.rs:4:17\n\
    \  |\n4 |     let a_num = str_to_num(a);\n  |                 ^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `str_to_num` in this scope\n\
    \ --> /tmp/tmp9tfymfkk.rs:5:17\n  |\n5 |     let b_num = str_to_num(b);\n  | \
    \                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `num_to_str` in this scope\n --> /tmp/tmp9tfymfkk.rs:6:5\n  |\n6 |\
    \     num_to_str(a_num ^ b_num)\n  |     ^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    a and b must be the same length.\");\n    }\n\n    let a_as_bytes = a.into_bytes();\n\
    \    let b_as_bytes = b.into_bytes();\n\n    let mut result = String::new();\n\
    \n    for i in 0..a_as_bytes.len() {\n        if a_as_bytes[i] == b_as_bytes[i]\
    \ {\n            result.push('0');\n        } else {\n            result.push('1');\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    for\
    \ (c, d) in a.chars().zip(b.chars()) {\n        if c == d {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822355
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut ret = String::new();\n    for (a,\
    \ b) in a.chars().zip(b.chars()) {\n        let a = a.to_digit(10).unwrap();\n\
    \        let b = b.to_digit(10).unwrap();\n        ret.push_str(&format!(\"{}\"\
    , a ^ b));\n    }\n    ret\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // XOR two characters and return result\
    \ as a character\n    fn chr_xor(c1: char, c2: char) -> char {\n        assert!(c1\
    \ == '0' || c1 == '1');\n        assert!(c2 == '0' || c2 == '1');\n        if\
    \ c1 == c2 {\n            '0'\n        } else {\n            '1'\n        }\n\
    \    }\n\n    let chars_a: Vec<char> = a.chars().collect();\n    let chars_b:\
    \ Vec<char> = b.chars().collect();\n    let mut result: String = String::new();\n\
    \    for i in 0..chars_a.len() {\n        result.push(chr_xor(chars_a[i], chars_b[i]));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = a.chars().collect::<Vec<char>>();\n\
    \    let b = b.chars().collect::<Vec<char>>();\n    assert_eq!(a.len(), b.len());\n\
    \    let xor = a.iter().zip(b).map(|(a, b)| {\n        match (a.to_digit(10),\
    \ b.to_digit(10)) {\n            (Some(a), Some(b)) => a ^ b,\n            _ =>\
    \ unreachable!(),\n        }\n    });\n    xor.map(|d| d.to_string()).collect::<Vec<String>>().join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let chars_a: Vec<char> = a.chars().collect();\n\
    \    let chars_b: Vec<char> = b.chars().collect();\n    let mut c: Vec<char> =\
    \ Vec::new();\n    for i in 0..chars_a.len() {\n        c.push(match (chars_a[i],\
    \ chars_b[i]) {\n            ('0', '0') => '0',\n            ('0', '1') => '1',\n\
    \            ('1', '0') => '1',\n            ('1', '1') => '0',\n            _\
    \ => '0',\n        });\n    }\n    c.iter().collect()\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| if a == b { '0' } else { '1' })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822354
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::with_capacity(a.len());\n\
    \    for (byte_a, byte_b) in a.bytes().zip(b.bytes()) {\n        let bit_a = byte_a\
    \ as i32 - 48;\n        let bit_b = byte_b as i32 - 48;\n        let xor = (bit_a\
    \ + bit_b) % 2;\n        result.push_str(&xor.to_string());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut a = a.chars();\n    let mut b =\
    \ b.chars();\n    let mut result = String::new();\n    while let (Some(aa), Some(bb))\
    \ = (a.next(), b.next()) {\n        result.push(if aa == bb { '0' } else { '1'\
    \ });\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut xored = Vec::new();\n    for (i,\
    \ j) in a.chars().zip(b.chars()) {\n        let i = i.to_digit(10).unwrap();\n\
    \        let j = j.to_digit(10).unwrap();\n        let tmp = (i + j) % 2;\n  \
    \      xored.push(tmp);\n    }\n    xored.iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    a.chars()\n        .zip(b.chars())\n   \
    \     .map(|(a, b)| match (a == '1', b == '1') {\n            (true, true) =>\
    \ '0',\n            (false, false) => '0',\n            _ => '1',\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Return value\n    let mut result = String::new();\n\
    \n    // Take the length of the longer string to iterate over\n    let length\
    \ = std::cmp::max(a.len(), b.len());\n\n    // Iterate over the first string\n\
    \    for i in 0..length {\n        // We might have a shorter string, so just\
    \ take the shorter length\n        let x = if i < a.len() {\n            a.chars().nth(i).unwrap()\n\
    \        } else {\n            '0'\n        };\n\n        // We might have a shorter\
    \ string, so just take the shorter length\n        let y = if i < b.len() {\n\
    \            b.chars().nth(i).unwrap()\n        } else {\n            '0'\n  \
    \      };\n\n        // Compute the result\n        result.push(\n           \
    \ match (x, y) {\n                ('0', '0') => '0',\n                ('0', '1')\
    \ => '1',\n                ('1', '0') => '1',\n                ('1', '1') => '0',\n\
    \                _ => '0',\n            }\n        );\n    }\n\n    result\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 101
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n  let mut a = a.chars();\n  let mut b = b.chars();\n\
    \  let mut c = String::new();\n  for _ in 0..10 {\n    let x = a.next().unwrap();\n\
    \    let y = b.next().unwrap();\n    if x == y {\n      c.push('0');\n    } else\
    \ {\n      c.push('1');\n    }\n  }\n  c\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpvmjdnvrc.rs:8:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut result = String::new();\n    let\
    \ mut chars_a = a.chars();\n    let mut chars_b = b.chars();\n    loop {\n   \
    \     match (chars_a.next(), chars_b.next()) {\n            (Some(a), Some(b))\
    \ => {\n                let xor = if a == b { '0' } else { '1' };\n          \
    \      result.push(xor);\n            }\n            (Some(a), None) => result.push(a),\n\
    \            (None, Some(b)) => result.push(b),\n            (None, None) => break,\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // For each character in string a and b,\
    \ get the corresponding bit\n    // and perform XOR.\n    // Since the inputs\
    \ are valid strings of 1s and 0s, it is safe to\n    // assume that input a and\
    \ b are the same length.\n    a.chars()\n        .zip(b.chars())\n        .map(|(x,\
    \ y)| if x == y { '0' } else { '1' })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut out = \"\".to_string();\n    for\
    \ (i, j) in a.chars().zip(b.chars()) {\n        out.push_str(&((i.to_digit(10).unwrap()\
    \ ^ j.to_digit(10).unwrap())\n            .to_string()));\n    }\n    out\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // Do not modify this function: It is a\
    \ simple demo of string\n    // operations in Rust and has nothing to do with\
    \ cryptography.\n    assert_eq!(a.len(), b.len());\n    let mut c = String::new();\n\
    \    for (i, j) in a.chars().zip(b.chars()) {\n        let d = match (i, j) {\n\
    \            ('0', '0') => '0',\n            ('0', '1') => '1',\n            ('1',\
    \ '0') => '1',\n            ('1', '1') => '0',\n            _ => panic!(\"should\
    \ only contain 1s and 0s\"),\n        };\n        c.push(d);\n    }\n    c\n}\n\
    \nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    if a.len() != b.len() {\n        panic!(\"\
    Strings for xor should be of equal length.\");\n    }\n    a.chars()\n       \
    \ .zip(b.chars())\n        .map(|(a, b)| if a == b { \"0\" } else { \"1\" })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let mut res = String::new();\n    for i\
    \ in 0..a.len() {\n        let ca = &a[i..i+1];\n        let cb = &b[i..i+1];\n\
    \        res.push(match (ca, cb) {\n            (\"0\", \"0\") => '0',\n     \
    \       (\"0\", \"1\") => '1',\n            (\"1\", \"0\") => '1',\n         \
    \   (\"1\", \"1\") => '0',\n            _ => panic!(\"one of the arguments is\
    \ not a binary string\"),\n        });\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    assert_eq!(a.len(), b.len());\n    let mut\
    \ result = String::new();\n    for (a_bit, b_bit) in a.chars().zip(b.chars())\
    \ {\n        result.push(\n            match (a_bit, b_bit) {\n              \
    \  ('0', '0') => '0',\n                ('0', '1') => '1',\n                ('1',\
    \ '0') => '1',\n                ('1', '1') => '0',\n                _ => unreachable!(),\n\
    \            }\n        );\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    // TODO\n    a.chars().zip(b.chars()).map(|(a,\
    \ b)| if a == b {'0'} else {'1'}).collect()\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let length = min(a.len(), b.len());\n  \
    \  let mut result = String::with_capacity(length);\n    for i in 0..length {\n\
    \        if a.chars().nth(i) == b.chars().nth(i) {\n            result.push('0');\n\
    \        } else {\n            result.push('1');\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmprrg477al.rs:4:18\n\
    \   |\n4  |     let length = min(a.len(), b.len());\n   |                  ^^^\n\
    ...\n16 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n4  |     let\
    \ length = main(a.len(), b.len());\n   |                  ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822356
- exit_code: 0
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\nfn string_xor(a:\
    \ String, b: String) -> String {\n    let a = a.into_bytes();\n    let b = b.into_bytes();\n\
    \    a.iter()\n        .zip(b.iter())\n        .map(|(x, y)| *x ^ *y)\n      \
    \  .map(|x| x.to_string())\n        .collect::<Vec<String>>()\n        .join(\"\
    \")\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822356
