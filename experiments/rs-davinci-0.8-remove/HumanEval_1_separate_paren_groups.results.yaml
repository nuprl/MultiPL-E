language: rs
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut chars = paren_string.chars();\n    let mut res = vec![];\n  \
    \  while let Some(c) = chars.next() {\n        if c == '(' {\n            let\
    \ mut parens = 1;\n            let mut group = String::new();\n            while\
    \ let Some(c) = chars.next() {\n                if c == '(' {\n              \
    \      parens += 1;\n                } else if c == ')' {\n                  \
    \  parens -= 1;\n                }\n                if parens == 0 {\n       \
    \             break;\n                }\n                group.push(c);\n    \
    \        }\n            res.push(group);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()()\", \"(())\", \"\", \"(())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp9rrpkzhk.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    if paren_string.len() == 0 {\n        return vec![];\n    }\n\n    let\
    \ mut result: Vec<String> = vec![];\n    let mut last_char_index = 0;\n    let\
    \ mut last_char_count = 0;\n    let mut is_open = false;\n\n    for (index, char)\
    \ in paren_string.chars().enumerate() {\n        if char == '(' {\n          \
    \  if is_open {\n                continue;\n            }\n            is_open\
    \ = true;\n            last_char_index = index;\n            last_char_count =\
    \ 1;\n        } else if char == ')' {\n            if !is_open {\n           \
    \     continue;\n            }\n            if last_char_count == 0 {\n      \
    \          result.push(paren_string[last_char_index..index].to_string());\n  \
    \              is_open = false;\n            } else {\n                last_char_count\
    \ -= 1;\n            }\n        }\n    }\n\n    if is_open {\n        result.push(paren_string[last_char_index..].to_string());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()(\", \"((()\", \"() (((\", \"()(\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpnlr550an.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut vec = Vec::new();\n    let mut out = String::new();\n    let\
    \ mut count = 0;\n    for c in paren_string.chars() {\n        if c == ' ' {\n\
    \            continue;\n        } else if c == '(' {\n            count += 1;\n\
    \        } else if c == ')' {\n            count -= 1;\n        }\n        out.push(c);\n\
    \        if count == 0 {\n            vec.push(out);\n            out = String::new();\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut open = 0;\n    let mut last_split = 0;\n    let mut result =\
    \ Vec::new();\n    let mut chars = paren_string.chars();\n    while let Some(c)\
    \ = chars.next() {\n        match c {\n            '(' => {\n                open\
    \ += 1;\n            }\n            ')' => {\n                open -= 1;\n   \
    \             if open == 0 {\n                    result.push(chars.as_str()[last_split..].chars().take_while(|&c|\
    \ c != ')').collect());\n                    last_split = chars.as_str().len()\
    \ - chars.as_str()[last_split..].chars().take_while(|&c| c != ')').count();\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 17 is out of bounds of ` () ((())()())`'',
    /tmp/tmpsp9txef8.rs:18:33

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut in_group = false;\n\
    \    let mut curr_group = String::new();\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' => {\n                if in_group {\n    \
    \                curr_group.push(c);\n                } else {\n             \
    \       in_group = true;\n                }\n            }\n            ')' =>\
    \ {\n                if in_group {\n                    curr_group.push(c);\n\
    \                    groups.push(curr_group);\n                    curr_group\
    \ = String::new();\n                    in_group = false;\n                }\n\
    \            }\n            _ => {\n                if in_group {\n          \
    \          curr_group.push(c);\n                }\n            }\n        }\n\
    \    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \")\", \"(()\", \")\", \"(()\", \")\", \")\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmplobm9sfo.rs:38:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut last_close_paren_index = 0;\n    let mut first_open_paren_index\
    \ = paren_string.find('(').unwrap();\n    let mut last_close_paren_index_vector\
    \ = Vec::new();\n    let mut string_vector = Vec::new();\n    let mut counter\
    \ = 0;\n    let mut chars_in_string = paren_string.chars();\n    while let Some(c)\
    \ = chars_in_string.next() {\n        if c == '(' {\n            counter += 1;\n\
    \        } else if c == ')' {\n            counter -= 1;\n        }\n        if\
    \ counter == 0 {\n            last_close_paren_index = last_close_paren_index\
    \ + 2;\n            last_close_paren_index_vector.push(last_close_paren_index);\n\
    \        }\n        last_close_paren_index += 1;\n    }\n    for item in last_close_paren_index_vector\
    \ {\n        string_vector.push(paren_string[first_open_paren_index..item].to_string());\n\
    \        first_open_paren_index = item;\n    }\n    string_vector\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 28 is out of bounds of `(()())
    ((())) () ((())()())`'', /tmp/tmpdz7lf9_g.rs:25:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    let\
    \ mut str_builder = String::new();\n    let mut in_paren = false;\n\n    for paren\
    \ in paren_string.chars() {\n        if paren == '(' {\n            in_paren =\
    \ true;\n            stack.push(paren);\n        } else if paren == ')' {\n  \
    \          in_paren = false;\n            if stack.len() == 1 {\n            \
    \    str_builder.push(')');\n                result.push(str_builder);\n     \
    \           str_builder = String::new();\n            } else {\n             \
    \   str_builder.push(')');\n            }\n            stack.pop();\n        }\
    \ else if in_paren {\n            str_builder.push(paren);\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\")))\", \")))\", \")\", \")))))\"]`,\n right: `[\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]`', /tmp/tmpg6d0ajug.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_vec: Vec<String> = Vec::new();\n    let mut curr_string:\
    \ String = String::new();\n    let mut open_parens: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            open_parens += 1;\n        } else if c\
    \ == ')' {\n            open_parens -= 1;\n        }\n        if open_parens ==\
    \ 0 {\n            paren_vec.push(curr_string);\n            curr_string = String::new();\n\
    \        } else {\n            curr_string.push(c);\n        }\n    }\n    paren_vec\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpxy3eouzb.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut paren_count: u8 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n\n        if c == '(' ||\
    \ c == ')' {\n            group.push(c);\n        }\n\n        if paren_count\
    \ == 0 && group.len() > 0 {\n            groups.push(group.clone());\n       \
    \     group.clear();\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut depth: u8 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              group.push(c);\n            }\n            ')' => {\n         \
    \       depth -= 1;\n                group.push(c);\n                if depth\
    \ == 0 {\n                    groups.push(group);\n                    group =\
    \ String::new();\n                }\n            }\n            _ => {\n     \
    \           group.push(c);\n            }\n        }\n    }\n    groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpomie3dsn.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut left = 0;\n    let mut right = 0;\n    let mut groups = Vec::new();\n\
    \    let mut group = String::new();\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            left += 1;\n        } else if c == ')' {\n  \
    \          right += 1;\n        } else if c == ' ' {\n            continue;\n\
    \        }\n        group.push(c);\n        if left == right {\n            groups.push(group);\n\
    \            group = String::new();\n            left = 0;\n            right\
    \ = 0;\n        }\n    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_group\
    \ = String::new();\n    let mut paren_count = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            paren_groups.push(paren_group);\n            paren_group =\
    \ String::new();\n        } else {\n            paren_group.push(c);\n       \
    \ }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpwoo2s785.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut group_count: i8 = 0;\n\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            group_count += 1;\n        } else if\
    \ ch == ')' {\n            group_count -= 1;\n        }\n\n        current_group.push(ch);\n\
    \n        if group_count == 0 {\n            groups.push(current_group);\n   \
    \         current_group = String::new();\n        }\n    }\n\n    groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpha27ly6m.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut buffer = String::new();\n \
    \   let mut current_level = 0;\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                if current_level == 0 {\n       \
    \             buffer.clear();\n                }\n                current_level\
    \ += 1;\n                buffer.push(c);\n            }\n            ')' => {\n\
    \                current_level -= 1;\n                buffer.push(c);\n      \
    \          if current_level == 0 {\n                    result.push(buffer.clone());\n\
    \                }\n            }\n            _ => {\n                buffer.push(c);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmphogx2ri6.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO fill this out\n    let mut paren_groups: Vec<String> = Vec::new();\n\
    \    let mut paren_group: String = String::new();\n    let mut bracket_count:\
    \ i32 = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n     \
    \       bracket_count += 1;\n        } else if c == ')' {\n            bracket_count\
    \ -= 1;\n        }\n        if bracket_count == 0 {\n            paren_groups.push(paren_group);\n\
    \            paren_group = String::new();\n        } else {\n            paren_group.push(c);\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpdt64a624.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: implement this function\n    vec![]\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpjdk7qyc0.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut depth: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              current_group.push(c);\n            }\n            ')' => {\n \
    \               depth -= 1;\n                current_group.push(c);\n        \
    \        if depth == 0 {\n                    result.push(current_group);\n  \
    \                  current_group = String::new();\n                }\n       \
    \     }\n            _ => current_group.push(c),\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpxrtc5_wa.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut group = String::new();\n   \
    \ let mut groups = Vec::new();\n\n    for c in paren_string.chars() {\n      \
    \  match c {\n            '(' => {\n                stack.push(c);\n         \
    \       group.push(c);\n            }\n            ')' => {\n                stack.pop();\n\
    \                group.push(c);\n                if stack.is_empty() {\n     \
    \               groups.push(group);\n                    group = String::new();\n\
    \                }\n            }\n            _ => group.push(c),\n        }\n\
    \    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp4rh5hbfc.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut vec: Vec<String> = Vec::new();\n    let mut current_string =\
    \ String::new();\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut\
    \ is_in_group = false;\n\n    for c in paren_string.chars() {\n        match c\
    \ {\n            '(' => {\n                if is_in_group {\n                \
    \    paren_stack.push(c);\n                } else {\n                    is_in_group\
    \ = true;\n                }\n            }\n            ')' => {\n          \
    \      if paren_stack.is_empty() {\n                    is_in_group = false;\n\
    \                    vec.push(current_string);\n                    current_string\
    \ = String::new();\n                } else {\n                    paren_stack.pop();\n\
    \                }\n            }\n            _ => {\n                if is_in_group\
    \ {\n                    current_string.push(c);\n                }\n        \
    \    }\n        }\n    }\n\n    return vec;\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpe7dfypcg.rs:42:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"separate the groups of nested parentheses from string\
    \ {}\", paren_string);\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate the groups of nested
    parentheses from string (()()) ((())) () ((())()())'', /tmp/tmpw3rnq4im.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO - replace panic with your implementation\n    panic!(\"TODO\"\
    );\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''TODO'', /tmp/tmpygq542ul.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Return a list of strings with each group of parentheses\n\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpwzxzr2ii.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    let\
    \ mut group = String::new();\n\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                stack.push(c);\n                group.push(c);\n\
    \            }\n            ')' => {\n                if stack.len() > 0 {\n \
    \                   stack.pop();\n                    group.push(c);\n       \
    \         } else {\n                    panic!(\"closing brace with no opening\
    \ brace\");\n                }\n            }\n            _ => {\n          \
    \      if stack.len() > 0 {\n                    group.push(c);\n            \
    \    }\n            }\n        }\n\n        if stack.len() == 0 {\n          \
    \  result.push(group.clone());\n            group.clear();\n        }\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpx0qe_sz4.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut working = paren_string.to_string();\n    let mut ret_vec = Vec::new();\n\
    \    loop {\n        let (temp, done) = paren_group_from_string(&working);\n \
    \       working = temp;\n        if done {\n            break;\n        }\n  \
    \      ret_vec.push(temp);\n    }\n    ret_vec\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `paren_group_from_string` in this scope\n\
    \ --> /tmp/tmpm3u_iago.rs:9:28\n  |\n9 |         let (temp, done) = paren_group_from_string(&working);\n\
    \  |                            ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // start with 0 open parens\n    // we have to count the open parens\
    \ when we iterate through the string.\n    // when we hit a closing paren, we\
    \ decrement the number of open parens by 1\n    // when we hit a closing paren\
    \ and the open paren count is zero, we've hit the end of the group.\n    // we\
    \ push the string from the beginning of the group to the end of the group onto\
    \ a vector\n    // and then we reset our pointers to the start of the next group\n\
    \    let mut open_parens = 0;\n    let mut paren_groups = Vec::new();\n    let\
    \ mut start_ptr = 0;\n    let mut end_ptr = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            if open_parens == 0 {\n              \
    \  start_ptr = i;\n            }\n            open_parens += 1;\n        } else\
    \ if c == ')' {\n            open_parens -= 1;\n            if open_parens ==\
    \ 0 {\n                end_ptr = i;\n                paren_groups.push(paren_string[start_ptr..end_ptr\
    \ + 1].to_string());\n            }\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpxeg3sea0.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Use `paren_string` to return a vector of strings with\
    \ the balanced groups of \\\n                   parentheses from it\");\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Use `paren_string` to return
    a vector of strings with the balanced groups of parentheses from it'', /tmp/tmpc9f8szvm.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut group = String::new();\n  \
    \  let mut count = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            count += 1;\n        } else if c == ')' {\n            count\
    \ -= 1;\n        }\n        if count == 0 {\n            if c == ')' {\n     \
    \           group.push(c);\n                result.push(group);\n            \
    \    group = String::new();\n            }\n        } else {\n            group.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpjmxkdiqa.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    paren_string\n        .chars()\n        .filter(|c| *c != ' ')\n    \
    \    .collect::<String>()\n        .split(\"()\")\n        .map(|s| s.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"\", \")((\", \"))\", \"((\", \")\", \"\", \")\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpjetkn6zn.rs:17:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut output = Vec::new();\n    let mut group_start = 0;\n    let mut\
    \ open_counter = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n  \
    \      match c {\n            '(' => {\n                if open_counter == 0 {\n\
    \                    group_start = i;\n                }\n                open_counter\
    \ += 1;\n            }\n            ')' => {\n                open_counter -=\
    \ 1;\n                if open_counter == 0 {\n                    output.push(paren_string[group_start..=i].to_string());\n\
    \                }\n            }\n            _ => {}\n        }\n    }\n   \
    \ output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp2f387gur.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut in_group: bool = false;\n    let mut num_parens:\
    \ i32 = 0;\n\n    for character in paren_string.chars() {\n        if character\
    \ == '(' {\n            in_group = true;\n            num_parens += 1;\n     \
    \   } else if character == ')' {\n            num_parens -= 1;\n            if\
    \ num_parens == 0 {\n                in_group = false;\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if character != ' ' {\n            if in_group {\n                current_group.push(character);\n\
    \            }\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmp52kmb34l.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut output: Vec<String> = Vec::new();\n    let mut current: String\
    \ = String::new();\n    let mut last_was_close = false;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if last_was_close {\n                output.push(current);\n\
    \                current = String::new();\n            }\n            current.push(c);\n\
    \            last_was_close = false;\n        } else if c == ')' {\n         \
    \   current.push(c);\n            last_was_close = true;\n        } else if c\
    \ == ' ' {\n            continue;\n        } else {\n            panic!(\"Got\
    \ a character other than ( or ) in input.\");\n        }\n    }\n    output.push(current);\n\
    \    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmplko4mrfo.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut buf: String =\
    \ String::new();\n    let mut depth: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              buf.push(c);\n            }\n            ')' => {\n           \
    \     depth -= 1;\n                buf.push(c);\n                if depth == 0\
    \ {\n                    result.push(buf);\n                    buf = String::new();\n\
    \                }\n            }\n            _ => {\n                buf.push(c);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp8_1ve8xs.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut answer: Vec<String> = Vec::new();\n    let mut valid_paren_list:\
    \ Vec<char> = Vec::new();\n    let mut temp_paren_list: Vec<char> = Vec::new();\n\
    \    for paren in paren_string.chars() {\n        if paren == '(' {\n        \
    \    valid_paren_list.push(paren);\n            temp_paren_list.push(paren);\n\
    \        } else if paren == ')' {\n            if let Some(val) = valid_paren_list.pop()\
    \ {\n                if val == '(' {\n                    temp_paren_list.push(paren);\n\
    \                } else {\n                    valid_paren_list.push(val);\n \
    \               }\n            }\n        }\n    }\n    if valid_paren_list.len()\
    \ == 0 {\n        answer.push(temp_paren_list.iter().collect());\n    } else {\n\
    \        println!(\"{:?}\", valid_paren_list);\n    }\n    answer\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())((()))()((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmplwg0gapy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // (()())()()(())\n    // ()()\n    // ()()()()\n    // ()()()()()\n\n\
    \    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    let mut\
    \ curr_str = String::new();\n\n    for ch in paren_string.chars() {\n        if\
    \ ch == '(' {\n            stack.push(ch);\n        } else if ch == ')' {\n  \
    \          stack.pop();\n        } else {\n            curr_str.push(ch);\n  \
    \      }\n\n        if stack.is_empty() {\n            result.push(curr_str.clone());\n\
    \            curr_str.clear();\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \" \", \"\", \" \", \"\", \" \", \"\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpfh2tt__n.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut res: Vec<String> = Vec::new();\n    let mut paren_opened = 0;\n\
    \    let mut paren_string = paren_string.chars().collect::<Vec<char>>();\n   \
    \ for i in 0..paren_string.len() {\n        if paren_string[i] == '(' {\n    \
    \        paren_opened += 1;\n        } else if paren_string[i] == ')' {\n    \
    \        paren_opened -= 1;\n        }\n\n        if paren_opened == 0 {\n   \
    \         res.push(paren_string[..=i].iter().collect());\n            paren_string\
    \ = paren_string[i+1..].to_vec();\n            i = 0;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `i` is never read\n  --> /tmp/tmpp7zrwuyt.rs:19:13\n\
    \   |\n19 |             i = 0;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `i`\n  --> /tmp/tmpp7zrwuyt.rs:19:13\n\
    \   |\n9  |     for i in 0..paren_string.len() {\n   |         -\n   |       \
    \  |\n   |         first assignment to `i`\n   |         help: consider making\
    \ this binding mutable: `mut i`\n...\n19 |             i = 0;\n   |          \
    \   ^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut in_parens = false;\n    let mut paren_groups = Vec::new();\n\
    \    let mut group = String::new();\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            if in_parens {\n                group.push(c);\n\
    \            } else {\n                in_parens = true;\n            }\n    \
    \    } else if c == ')' {\n            if in_parens {\n                if group.is_empty()\
    \ {\n                    in_parens = false;\n                } else {\n      \
    \              group.push(c);\n                }\n            } else {\n     \
    \           continue;\n            }\n        } else if c == ' ' {\n         \
    \   continue;\n        } else {\n            group.push(c);\n        }\n     \
    \   if !in_parens {\n            paren_groups.push(group);\n            group\
    \ = String::new();\n        }\n    }\n    if in_parens {\n        paren_groups.push(group);\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()())((()))()((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"]`', /tmp/tmpykxr9c07.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // let mut paren_stack: Vec<char> = Vec::new();\n    let mut paren_groups:\
    \ Vec<String> = Vec::new();\n    let mut paren_group: String = String::new();\n\
    \    let mut group_depth: i8 = 0;\n    for ch in paren_string.chars() {\n    \
    \    match ch {\n            '(' => {\n                if group_depth == 0 {\n\
    \                    paren_group.push(ch);\n                }\n              \
    \  group_depth += 1;\n            }\n            ')' => {\n                group_depth\
    \ -= 1;\n                if group_depth == 0 {\n                    paren_group.push(ch);\n\
    \                    paren_groups.push(paren_group);\n                    paren_group\
    \ = String::new();\n                }\n            }\n            _ => {\n   \
    \             if group_depth > 0 {\n                    paren_group.push(ch);\n\
    \                }\n            }\n        }\n    }\n    paren_groups\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpv9v0yblb.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut res: Vec<String> = Vec::new();\n    let mut cur: String = String::new();\n\
    \    let mut count: u32 = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            count += 1;\n        } else if c == ')' {\n        \
    \    count -= 1;\n        }\n        if count == 0 {\n            cur.push(c);\n\
    \            res.push(cur);\n            cur = String::new();\n        } else\
    \ {\n            cur.push(c);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpwtzsn0zr.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut balanced_parens = String::new();\n\
    \    let mut chars = paren_string.chars();\n    let mut open_parens = 0;\n   \
    \ while let Some(c) = chars.next() {\n        match c {\n            '(' => {\n\
    \                open_parens += 1;\n                balanced_parens.push(c);\n\
    \            }\n            ')' => {\n                open_parens -= 1;\n    \
    \            balanced_parens.push(c);\n                if open_parens == 0 {\n\
    \                    result.push(balanced_parens);\n                    balanced_parens\
    \ = String::new();\n                }\n            }\n            _ => {\n   \
    \             if open_parens > 0 {\n                    balanced_parens.push(c);\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmphmaeal2d.rs:39:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut current_count = 0;\n    for c in paren_string.chars() {\n       \
    \ if c == '(' {\n            current_count += 1;\n        } else if c == ')' {\n\
    \            current_count -= 1;\n        }\n        if current_count == 0 {\n\
    \            if !current_group.is_empty() {\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ {\n            current_group.push(c);\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpyqfefoa0.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // IMPLEMENT ME\n    vec![]\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmplo2w9jer.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut temp_group: String\
    \ = String::new();\n    let mut paren_count: u8 = 0;\n\n    for (index, character)\
    \ in paren_string.chars().enumerate() {\n        if character == '(' {\n     \
    \       if paren_count == 0 {\n                temp_group.push(character);\n \
    \           }\n            paren_count += 1;\n        } else if character == ')'\
    \ {\n            paren_count -= 1;\n            if paren_count == 0 {\n      \
    \          temp_group.push(character);\n                groups.push(temp_group.clone());\n\
    \                temp_group.clear();\n            }\n        } else if paren_count\
    \ != 0 {\n            temp_group.push(character);\n        }\n    }\n\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmp5hw227ds.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut nested_count: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            nested_count += 1;\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            if nested_count == 1 {\n          \
    \      current_group.push(c);\n                paren_groups.push(current_group);\n\
    \                current_group = String::new();\n            } else {\n      \
    \          current_group.push(c);\n            }\n            nested_count -=\
    \ 1;\n        } else if c == ' ' {\n            continue;\n        } else {\n\
    \            current_group.push(c);\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut balanced = true;\n    let mut count = 0;\n   \
    \ for c in paren_string.chars() {\n        if c == '(' {\n            count +=\
    \ 1;\n        } else if c == ')' {\n            count -= 1;\n        }\n     \
    \   if c == ' ' {\n            continue;\n        } else if count == 0 {\n   \
    \         balanced = true;\n            groups.push(group);\n            group\
    \ = String::new();\n        } else if count < 0 {\n            balanced = false;\n\
    \            break;\n        } else {\n            balanced = true;\n        }\n\
    \        group.push(c);\n    }\n    if balanced {\n        groups.push(group);\n\
    \    } else {\n        groups.clear();\n    }\n    groups\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \")((())\", \")(\", \")((())()()\", \")\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp88h58j7c.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_paren_group:\
    \ String = String::new();\n    let mut total_open_paren = 0;\n    let mut total_close_paren\
    \ = 0;\n    let mut c = ' ';\n    let mut current_index = 0;\n    let mut string_chars\
    \ = paren_string.chars();\n\n    while let Some(cc) = string_chars.next() {\n\
    \        c = cc;\n        if c == '(' {\n            total_open_paren += 1;\n\
    \            current_paren_group.push(c);\n        } else if c == ')' {\n    \
    \        total_close_paren += 1;\n            current_paren_group.push(c);\n \
    \       }\n\n        if total_open_paren == total_close_paren && total_open_paren\
    \ != 0 {\n            total_open_paren = 0;\n            total_close_paren = 0;\n\
    \            current_paren_group.insert(0, '(');\n            current_paren_group.push(')');\n\
    \            paren_groups.push(current_paren_group.clone());\n            current_paren_group.clear();\n\
    \        }\n        current_index += 1;\n    }\n\n    return paren_groups;\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"((()()))\", \"(((())))\", \"(())\", \"(((())()()))\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpf8q16u8w.rs:40:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_string = paren_string;\n    let mut paren_groups = Vec::new();\n\
    \    let mut index = 0;\n    let mut open_parens = 0;\n    let mut closed_parens\
    \ = 0;\n    let mut sub_index = 0;\n    let mut to_remove = String::new();\n \
    \   for c in paren_string.chars() {\n        if c == '(' {\n            open_parens\
    \ += 1;\n        } else if c == ')' {\n            closed_parens += 1;\n     \
    \   }\n        if open_parens == closed_parens {\n            sub_index = index\
    \ + 1;\n            to_remove = paren_string.clone();\n            to_remove.remove(sub_index..sub_index\
    \ + 1);\n            paren_groups.push(to_remove);\n            to_remove = String::new();\n\
    \            open_parens = 0;\n            closed_parens = 0;\n        }\n   \
    \     index += 1;\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjtc9gu1p.rs:22:30\n   |\n\
    22 |             to_remove.remove(sub_index..sub_index + 1);\n   |           \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected type `usize`\n            found struct `std::ops::Range<{integer}>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = vec![];\n    let mut result = vec![];\n    let mut last_index\
    \ = 0;\n    for (index, c) in paren_string.chars().enumerate() {\n        if c\
    \ == '(' {\n            stack.push(index);\n        } else if c == ')' {\n   \
    \         stack.pop();\n            if stack.is_empty() {\n                let\
    \ part = &paren_string[last_index..index + 1];\n                result.push(part.to_string());\n\
    \                last_index = index + 1;\n            }\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpgue8zuw7.rs:26:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut stack: Vec<usize>\
    \ = Vec::new();\n    let mut group_start: usize = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            stack.push(i);\n        } else if c ==\
    \ ')' {\n            if stack.is_empty() {\n                continue;\n      \
    \      }\n            let index = stack.pop().unwrap();\n            if stack.is_empty()\
    \ {\n                groups.push(paren_string[index..=i].chars().filter(|&x| x\
    \ != ' ').collect());\n            }\n        }\n    }\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Implement me\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpgdg6pqgu.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_stack: Vec<String> = Vec::new();\n    let mut paren_string\
    \ = paren_string.chars().collect::<Vec<char>>();\n    let mut current_group: String\
    \ = String::new();\n    loop {\n        let ch = paren_string.pop();\n       \
    \ match ch {\n            Some(')') => {\n                current_group.push(')');\n\
    \                paren_stack.push(current_group);\n                current_group\
    \ = String::new();\n            }\n            Some('(') => {\n              \
    \  current_group.push('(');\n                paren_stack.push(current_group);\n\
    \                current_group = String::new();\n            }\n            Some(ch)\
    \ => {\n                if ch.is_alphanumeric() {\n                    current_group.push(ch);\n\
    \                }\n            }\n            None => {\n                if current_group.len()\
    \ > 0 {\n                    paren_stack.push(current_group);\n              \
    \  }\n                break;\n            }\n        }\n    }\n    let mut reverse_stack:\
    \ Vec<String> = Vec::new();\n    while paren_stack.len() > 0 {\n        reverse_stack.push(paren_stack.pop().unwrap());\n\
    \    }\n    let mut current_group: String = String::new();\n    let mut paren_groups:\
    \ Vec<String> = Vec::new();\n    let mut last_ch: Option<char> = None;\n    loop\
    \ {\n        let ch = reverse_stack.pop();\n        match ch {\n            Some(ch)\
    \ => {\n                match ch.chars().next() {\n                    Some(')')\
    \ => {\n                        current_group.push(')');\n                   \
    \     paren_groups.push(current_group);\n                        current_group\
    \ = String::new();\n                    }\n                    Some('(') => {\n\
    \                        current_group.push('(');\n                        paren_groups.push(current_group);\n\
    \                        current_group = String::new();\n                    }\n\
    \                    Some(ch) => {\n                        if ch.is_alphanumeric()\
    \ {\n                            current_group.push(ch);\n                   \
    \     }\n                    }\n                   \n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmps1y6i8e4.rs:71:3\n\
    \   |\n5  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n42 |     loop {\n   |          - unclosed delimiter\n43 |  \
    \       let ch = reverse_stack.pop();\n44 |         match ch {\n   |         \
    \         - unclosed delimiter\n45 |             Some(ch) => {\n   |         \
    \                - unclosed delimiter\n46 |                 match ch.chars().next()\
    \ {\n   |                                         - this delimiter might not be\
    \ properly closed...\n...\n63 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n71 | }\n   |   ^\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = vec![];\n    let mut groups = vec![];\n    let mut start_index\
    \ = 0;\n    let mut open_parens = 0;\n    let mut end_index = 0;\n    let mut\
    \ last_index = 0;\n    let mut last_group = String::new();\n    let mut first_time\
    \ = true;\n    for (index, ch) in paren_string.chars().enumerate() {\n       \
    \ if ch == '(' {\n            if open_parens == 0 {\n                if !first_time\
    \ {\n                    last_index = index;\n                }\n            \
    \    start_index = index;\n                first_time = false;\n            }\n\
    \            open_parens += 1;\n            stack.push(ch);\n        } else if\
    \ ch == ')' {\n            if open_parens == 1 {\n                end_index =\
    \ index;\n                last_group = paren_string[start_index..end_index + 1].to_string();\n\
    \                groups.push(last_group.clone());\n            }\n           \
    \ open_parens -= 1;\n            stack.pop();\n        }\n    }\n    if !last_group.is_empty()\
    \ {\n        groups.push(paren_string[last_index..].to_string());\n    }\n   \
    \ groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpb7dhiu8j.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Fill this in\n    unimplemented!()\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpu2sprzo1.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821378
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // let mut result = vec![];\n    // let mut chars = paren_string.chars();\n\
    \    // let mut cur_paren_str = String::new();\n    // let mut paren_count = 0;\n\
    \    // loop {\n    //     let next_ch = chars.next();\n    //     match next_ch\
    \ {\n    //         Some('(') => {\n    //             paren_count += 1;\n   \
    \ //             cur_paren_str.push(next_ch.unwrap());\n    //         }\n   \
    \ //         Some(')') => {\n    //             if paren_count == 0 {\n    //\
    \                 panic!(\"Invalid character: ')'\");\n    //             }\n\
    \    //             cur_paren_str.push(next_ch.unwrap());\n    //            \
    \ paren_count -= 1;\n    //             if paren_count == 0 {\n    //        \
    \         result.push(cur_paren_str);\n    //                 cur_paren_str =\
    \ String::new();\n    //             }\n    //         }\n    //         Some(ch)\
    \ => {\n    //             if !ch.is_whitespace() {\n    //                 cur_paren_str.push(ch);\n\
    \    //             }\n    //         }\n    //         None => {\n    //    \
    \         if paren_count != 0 {\n    //                 panic!(\"Invalid character:\
    \ ')'\");\n    //             }\n    //             break;\n    //         }\n\
    \    //     }\n    // }\n    // result\n    // following code is better\n    let\
    \ mut result = vec![];\n    let mut paren_count = 0;\n    let mut cur_paren_str\
    \ = String::new();\n    for ch in paren_string.chars() {\n        if ch == '('\
    \ {\n            paren_count += 1;\n            cur_paren_str.push(ch);\n    \
    \    } else if ch == ')' {\n            if paren_count == 0 {\n              \
    \  panic!(\"Invalid character: ')'\");\n            }\n            cur_paren_str.push(ch);\n\
    \            paren_count -= 1;\n            if paren_count == 0 {\n          \
    \      result.push(cur\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpowsz55jh.rs:66:3\n\
    \   |\n5  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n46 |     for ch in paren_string.chars() {\n   |            \
    \                        - unclosed delimiter\n...\n50 |         } else if ch\
    \ == ')' {\n   |                             - unclosed delimiter\n...\n56 | \
    \            if paren_count == 0 {\n   |                                 - this\
    \ delimiter might not be properly closed...\n57 |                 result.push(cur\n\
    58 | }\n   | - ...as it matches this but it has different indentation\n...\n66\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpowsz55jh.rs:57:28\n\
    \   |\n5  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - closing\
    \ delimiter possibly meant for this\n...\n57 |                 result.push(cur\n\
    \   |                            ^ unclosed delimiter\n58 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0425]: cannot find value `cur` in this scope\n \
    \ --> /tmp/tmpowsz55jh.rs:57:29\n   |\n57 |                 result.push(cur\n\
    \   |                             ^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpowsz55jh.rs:46:5\n   |\n5  |   fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \        ----------- expected `Vec<String>` because of return type\n...\n46 |\
    \ /     for ch in paren_string.chars() {\n47 | |         if ch == '(' {\n48 |\
    \ |             paren_count += 1;\n49 | |             cur_paren_str.push(ch);\n\
    ...  |\n65 | |     assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")),\
    \ vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n\
    66 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explana"
  stdout: ''
  timestamp: 1659821378
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // Begin by turning the input string into a char vector\n    let paren_chars:\
    \ Vec<char> = paren_string.chars().collect();\n\n    // Now find the indices of\
    \ the open braces\n    let open_paren_indices: Vec<usize> = find_chars_in_vector(&paren_chars,\
    \ '(');\n\n    // Then find the indices of the close braces\n    let close_paren_indices:\
    \ Vec<usize> = find_chars_in_vector(&paren_chars, ')');\n\n    // Now combine\
    \ the two by creating a vector of tuples of (open_paren_index, close_paren_index)\n\
    \    let mut combined_indices: Vec<(usize, usize)> = Vec::new();\n    for open_index\
    \ in open_paren_indices {\n        for close_index in close_paren_indices.iter()\
    \ {\n            if open_index < *close_index {\n                combined_indices.push((open_index,\
    \ *close_index));\n                break;\n            }\n        }\n    }\n\n\
    \    // Now traverse the string and create a vector of strings, one for each group\
    \ of parentheses\n    let mut group_strings: Vec<String> = Vec::new();\n    for\
    \ group_indices in combined_indices {\n        let mut group_string: String =\
    \ String::new();\n        for index in group_indices.0..=group_indices.1 {\n \
    \           group_string.push(paren_chars[index]);\n        }\n        group_strings.push(group_string);\n\
    \    }\n\n    group_strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_chars_in_vector` in this scope\n\
    \  --> /tmp/tmprqvlsnze.rs:10:42\n   |\n10 |     let open_paren_indices: Vec<usize>\
    \ = find_chars_in_vector(&paren_chars, '(');\n   |                           \
    \               ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `find_chars_in_vector` in this scope\n  --> /tmp/tmprqvlsnze.rs:13:43\n\
    \   |\n13 |     let close_paren_indices: Vec<usize> = find_chars_in_vector(&paren_chars,\
    \ ')');\n   |                                           ^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut output = Vec::new();\n    let mut open_count = 0;\n    let mut\
    \ current_string = String::new();\n    for c in paren_string.chars() {\n     \
    \   if c == '(' {\n            open_count += 1;\n        } else if c == ')' {\n\
    \            open_count -= 1;\n        }\n        if open_count == 0 {\n     \
    \       if !current_string.is_empty() {\n                output.push(current_string);\n\
    \                current_string = String::new();\n            }\n        } else\
    \ {\n            if c != ' ' {\n                current_string.push(c);\n    \
    \        }\n        }\n    }\n    if !current_string.is_empty() {\n        output.push(current_string);\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp6pfmnh4v.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut current_level: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                current_level +=\
    \ 1;\n                current_group.push(c);\n            }\n            ')' =>\
    \ {\n                current_level -= 1;\n                current_group.push(c);\n\
    \                if current_level == 0 {\n                    groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            ' ' => {}\n            _ => current_group.push(c),\n  \
    \      }\n    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut groups = Vec::new();\n    let\
    \ mut group = String::new();\n\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            stack.push(c);\n        } else if c == ')' {\n     \
    \       match stack.pop() {\n                Some(_) => {\n                  \
    \  group.push(c);\n                    if stack.is_empty() {\n               \
    \         groups.push(group);\n                        group = String::new();\n\
    \                    }\n                }\n                None => panic!(\"Unbalanced\
    \ parens\"),\n            }\n        } else if c != ' ' {\n            group.push(c);\n\
    \        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\")))\", \")))\", \")\", \")))))\"]`,\n right: `[\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]`', /tmp/tmph44qmc29.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"{}\", paren_string)\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: (()()) ((())) () ((())()())'',
    /tmp/tmpoulwze2g.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut vec: Vec<String> = Vec::new();\n    let mut paren_group = String::new();\n\
    \    let mut paren_balance = 0;\n    for c in paren_string.chars() {\n       \
    \ if c == '(' {\n            paren_balance += 1;\n        } else if c == ')' {\n\
    \            paren_balance -= 1;\n        }\n        if paren_balance == 0 {\n\
    \            vec.push(paren_group);\n            paren_group = String::new();\n\
    \        } else {\n            paren_group.push(c);\n        }\n    }\n    vec\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpua89z03r.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_count: u32 = 0;\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \                current_group.push(c);\n            }\n            ')' => {\n\
    \                paren_count -= 1;\n                current_group.push(c);\n \
    \           }\n            _ => current_group.push(c),\n        }\n\n        if\
    \ paren_count == 0 {\n            groups.push(current_group);\n            current_group\
    \ = String::new();\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp7bg2mkst.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut groups = Vec::new();\n    let\
    \ mut group = String::new();\n\n    for ch in paren_string.chars() {\n       \
    \ if ch == '(' {\n            stack.push(ch);\n        } else if ch == ')' {\n\
    \            if stack.is_empty() {\n                group.push(ch);\n        \
    \    } else {\n                stack.pop();\n                if stack.is_empty()\
    \ {\n                    groups.push(group.clone());\n                    group.clear();\n\
    \                }\n            }\n        } else {\n            group.push(ch);\n\
    \        }\n    }\n\n    if !group.is_empty() {\n        groups.push(group);\n\
    \    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \" \", \" \", \" \"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"\
    ((())()())\"]`', /tmp/tmp5p15zsqc.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_str: String\
    \ = String::new();\n    let mut paren_count: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count >\
    \ 0 {\n            current_str.push(c);\n        } else if paren_count == 0 {\n\
    \            current_str.push(c);\n            result.push(current_str);\n   \
    \         current_str = String::new();\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpkhde1ij4.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    paren_string\n        .split(\"()\")\n        .filter(|x| !x.is_empty())\n\
    \        .map(|x| format!(\"({})\", x))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()\", \"() (()\", \"()) )\", \"( (()\", \"())\", \"())\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpuxutmtbx.rs:15:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut result = Vec::new();\n\n    for ch in paren_string.chars() {\n  \
    \      match ch {\n            '(' => {\n                if !current_string.is_empty()\
    \ {\n                    stack.push(current_string);\n                    current_string\
    \ = String::new();\n                }\n                stack.push('(');\n    \
    \        }\n            ')' => {\n                if !current_string.is_empty()\
    \ {\n                    stack.push(current_string);\n                    current_string\
    \ = String::new();\n                }\n                // We will encounter a\
    \ ')' when the current_string becomes empty again\n                let mut current_group\
    \ = String::new();\n                while !stack.is_empty() {\n              \
    \      let popped = stack.pop().unwrap();\n                    if popped == '('\
    \ {\n                        break;\n                    } else {\n          \
    \              current_group.push_str(&popped);\n                    }\n     \
    \           }\n                current_group.push(')');\n                result.push(current_group);\n\
    \            }\n            _ => {\n                current_string.push(ch);\n\
    \            }\n        }\n    }\n\n    if !current_string.is_empty() {\n    \
    \    result.push(current_string);\n    }\n\n    result\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7_y_e5t8.rs:17:28\n   |\n\
    17 |                 stack.push('(');\n   |                            ^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `char`\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp7_y_e5t8.rs:28:31\n\
    \   |\n28 |                     if popped == '(' {\n   |                     \
    \          ^^ no implementation for `String == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_stack: Vec<String> = Vec::new();\n    let mut paren_string_group\
    \ = String::new();\n    for paren in paren_string.chars() {\n        match paren\
    \ {\n            '(' => {\n                if !paren_string_group.is_empty() {\n\
    \                    paren_stack.push(paren_string_group);\n                 \
    \   paren_string_group = String::new();\n                }\n                paren_string_group.push(paren);\n\
    \            }\n            ')' => {\n                paren_string_group.push(paren);\n\
    \                paren_stack.push(paren_string_group);\n                paren_string_group\
    \ = String::new();\n            }\n            _ => paren_string_group.push(paren),\n\
    \        }\n    }\n    if !paren_string_group.is_empty() {\n        paren_stack.push(paren_string_group);\n\
    \    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"()\", \"()\", \")\", \" \", \"(\", \"(\", \"()\", \")\", \")\", \"\
    \ \", \"()\", \" \", \"(\", \"(\", \"()\", \")\", \"()\", \"()\", \")\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpf3_6otz_.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut res = Vec::new();\n    let mut list = Vec::new();\n    let mut\
    \ count = 0;\n    for c in paren_string.chars() {\n        match c {\n       \
    \     '(' => {\n                count += 1;\n                list.push(c);\n \
    \           }\n            ')' => {\n                count -= 1;\n           \
    \     list.push(c);\n            }\n            _ => {}\n        }\n        if\
    \ count == 0 {\n            res.push(list.iter().collect());\n            list\
    \ = Vec::new();\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"\", \"((()))\", \"\", \"()\", \"\", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpjqu1lj_y.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n\
    \    let mut group_start = 0;\n    let mut group_end = 0;\n    while group_start\
    \ < paren_vec.len() {\n        while group_end < paren_vec.len() {\n         \
    \   if paren_vec[group_end] == '(' {\n                group_start = group_end;\n\
    \            }\n            if paren_vec[group_end] == ')' {\n               \
    \ group_end = group_end + 1;\n                break;\n            }\n        \
    \    group_end = group_end + 1;\n        }\n        result.push(paren_vec[group_start..group_end].iter().collect());\n\
    \        group_start = group_end;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \")\", \"()\", \")\", \")\", \"()\", \"()\", \")\", \"()\"\
    , \"()\", \")\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`',\
    \ /tmp/tmp6446q309.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_stack: Vec<char> = Vec::new();\n    let mut result: Vec<String>\
    \ = Vec::new();\n    let mut current_string: String = String::new();\n\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => {\n     \
    \           paren_stack.push(c);\n                current_string.push(c);\n  \
    \          }\n            ')' => {\n                if paren_stack.len() == 0\
    \ {\n                    return Vec::new();\n                }\n             \
    \   paren_stack.pop();\n                current_string.push(c);\n            \
    \    if paren_stack.len() == 0 {\n                    result.push(current_string);\n\
    \                    current_string = String::new();\n                }\n    \
    \        }\n            _ => {}\n        }\n    }\n\n    if paren_stack.len()\
    \ != 0 {\n        return Vec::new();\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_string_split = paren_string.split(\"(\");\n    let mut\
    \ paren_string_vec: Vec<String> = Vec::new();\n    for i in paren_string_split\
    \ {\n        let mut paren_string_split_again = i.split(\")\");\n        for x\
    \ in paren_string_split_again {\n            paren_string_vec.push(x.to_string());\n\
    \        }\n    }\n    paren_string_vec\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\", \"\", \"\", \" \", \"\", \"\", \"\", \"\", \"\", \"\
    \ \", \"\", \" \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\
    ]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpsxf_66wz.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut buf = String::new();\n    let mut groups = Vec::new();\n    let\
    \ mut open_parens = 0;\n    for c in paren_string.chars() {\n        if c == '('\
    \ {\n            if open_parens == 0 {\n                groups.push(buf);\n  \
    \              buf = String::new();\n            }\n            open_parens +=\
    \ 1;\n        } else if c == ')' {\n            open_parens -= 1;\n          \
    \  if open_parens == 0 {\n                groups.push(buf);\n                buf\
    \ = String::new();\n            }\n        } else if c != ' ' {\n            buf.push(c);\n\
    \        }\n    }\n    groups.pop();\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpyz7h85qn.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    vec![]\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpx1pwmezq.rs:11:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    paren_string\n        .chars()\n        .filter(|c| *c != ' ')\n    \
    \    .fold(\n            (0, vec![String::new()], vec![]),\n            |(open_braces,\
    \ mut group, mut groups), c| {\n                group.push(c);\n             \
    \   if c == '(' {\n                    (open_braces + 1, group, groups)\n    \
    \            } else if c == ')' {\n                    if open_braces > 1 {\n\
    \                        (open_braces - 1, group, groups)\n                  \
    \  } else {\n                        groups.push(group);\n                   \
    \     (0, vec![String::new()], groups)\n                    }\n              \
    \  } else {\n                    (open_braces, group, groups)\n              \
    \  }\n            },\n        )\n        .2\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqsxiq_99.rs:12:28\n   |\n\
    12 |                 group.push(c);\n   |                            ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqsxiq_99.rs:6:5\n   |\n5  |  \
    \ fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |      \
    \                                               ----------- expected `Vec<String>`\
    \ because of return type\n6  | /     paren_string\n7  | |         .chars()\n8\
    \  | |         .filter(|c| *c != ' ')\n9  | |         .fold(\n...  |\n26 | | \
    \        )\n27 | |         .2\n   | |__________^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<Vec<String>>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut group: String\
    \ = String::new();\n    let mut level: u32 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                level += 1;\n  \
    \              group.push(c);\n            }\n            ')' => {\n         \
    \       level -= 1;\n                group.push(c);\n                if level\
    \ == 0 {\n                    groups.push(group);\n                    group =\
    \ String::new();\n                }\n            }\n            _ => {\n     \
    \           group.push(c);\n            }\n        }\n    }\n    groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp7rih0s6w.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Return a list of separate groups of parentheses from\
    \ {}\", paren_string);\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return a list of separate
    groups of parentheses from (()()) ((())) () ((())()())'', /tmp/tmphvqrwulc.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_string = paren_string;\n    paren_string.retain(|c| c !=\
    \ ' ');\n    let mut result = Vec::new();\n    while !paren_string.is_empty()\
    \ {\n        result.push(extract_paren_group(&mut paren_string));\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `extract_paren_group` in this scope\n\
    \  --> /tmp/tmpy_nngbv0.rs:10:21\n   |\n10 |         result.push(extract_paren_group(&mut\
    \ paren_string));\n   |                     ^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    let\
    \ mut s: String = String::new();\n    let mut iter = paren_string.chars();\n \
    \   let mut prev_state = State::OutsideGroup;\n    loop {\n        match iter.next()\
    \ {\n            Some(c) => {\n                let state = determine_state(c);\n\
    \                //println!(\"{:?}\", state);\n                if state == State::FirstOpenParen\
    \ {\n                    stack.push(c);\n                    prev_state = state;\n\
    \                } else if state == State::OtherOpenParen {\n                \
    \    stack.push(c);\n                    s.push(c);\n                    prev_state\
    \ = state;\n                } else if state == State::FirstCloseParen {\n    \
    \                stack.pop();\n                    if stack.is_empty() {\n   \
    \                     // reached end of group\n                        result.push(s);\n\
    \                        s = String::new();\n                        prev_state\
    \ = state;\n                    } else {\n                        // inside a\
    \ group\n                        s.push(c);\n                        prev_state\
    \ = state;\n                    }\n                } else if state == State::OtherCloseParen\
    \ {\n                    stack.pop();\n                    s.push(c);\n      \
    \              prev_state = state;\n                } else if state == State::OutsideGroup\
    \ {\n                    if prev_state == State::FirstCloseParen {\n         \
    \               // reached end of group\n                        result.push(s);\n\
    \                        s = String::new();\n                        prev_state\
    \ = state;\n                    } else if prev_state == State::OtherCloseParen\
    \ {\n                        // inside a group\n                        s.push(c);\n\
    \                        prev_state = state;\n                    } else {\n \
    \                       // outside group\n                        prev_state =\
    \ state;\n                    }\n                }\n            }\n          \
    \  None => break,\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `State`\n  -->\
    \ /tmp/tmp4yu8qlz9.rs:10:26\n   |\n10 |     let mut prev_state = State::OutsideGroup;\n\
    \   |                          ^^^^^ use of undeclared type `State`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `State`\n  --> /tmp/tmp4yu8qlz9.rs:16:29\n\
    \   |\n16 |                 if state == State::FirstOpenParen {\n   |        \
    \                     ^^^^^ use of undeclared type `State`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `State`\n  --> /tmp/tmp4yu8qlz9.rs:19:36\n\
    \   |\n19 |                 } else if state == State::OtherOpenParen {\n   | \
    \                                   ^^^^^ use of undeclared type `State`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `State`\n  --> /tmp/tmp4yu8qlz9.rs:23:36\n\
    \   |\n23 |                 } else if state == State::FirstCloseParen {\n   |\
    \                                    ^^^^^ use of undeclared type `State`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `State`\n  --> /tmp/tmp4yu8qlz9.rs:35:36\n\
    \   |\n35 |                 } else if state == State::OtherCloseParen {\n   |\
    \                                    ^^^^^ use of undeclared type `State`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `State`\n  --> /tmp/tmp4yu8qlz9.rs:39:36\n\
    \   |\n39 |                 } else if state == State::OutsideGroup {\n   |   \
    \                                 ^^^^^ use of undeclared type `State`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `State`\n  --> /tmp/tmp4yu8qlz9.rs:40:38\n\
    \   |\n40 |                     if prev_state == State::FirstCloseParen {\n  \
    \ |                                      ^^^^^ use of undeclared type `State`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `State`\n  --> /tmp/tmp4yu8qlz9.rs:45:45\n\
    \   |\n45 |                     } else if prev_state == State::OtherCloseParen\
    \ {\n   |                                             ^^^^^ use of undeclared\
    \ type `State`\n\nerror[E0425]: cannot find function `determine_state` in this\
    \ scope\n  --> /tmp/tmp4yu8qlz9.rs:14:29\n   |\n14 |         "
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"function to separate parenthesis groups from string\
    \ {:?}\", paren_string)\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: function to separate parenthesis
    groups from string "(()()) ((())) () ((())()())"'', /tmp/tmplg3u_dty.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Return a list of strings, each of which represents a\
    \ single group of matching parentheses found in the input string: {}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return a list of strings,
    each of which represents a single group of matching parentheses found in the input
    string: (()()) ((())) () ((())()())'', /tmp/tmpws2o1zn5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut group_count = 0;\n    for character in paren_string.chars() {\n \
    \       match character {\n            '(' => {\n                group_count +=\
    \ 1;\n                current_group.push(character);\n            }\n        \
    \    ')' => {\n                group_count -= 1;\n                current_group.push(character);\n\
    \                if group_count == 0 {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                if group_count > 0 {\n        \
    \            current_group.push(character);\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpfailn7e4.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // Split the string up by character.\n    let mut paren_chars: Vec<char>\
    \ = paren_string.chars().collect();\n\n    // The characters to look for in the\
    \ list.\n    let chars_to_look_for: Vec<char> = vec!['(', ')'];\n\n    // This\
    \ will contain the groups of parens we find.\n    let mut found_paren_groups:\
    \ Vec<String> = Vec::new();\n\n    // This will contain each paren group as we\
    \ form it.\n    let mut paren_group: String = String::new();\n\n    // A loop\
    \ counter that we use to keep track of the index of the paren_chars array.\n \
    \   let mut i: usize = 0;\n\n    while i < paren_chars.len() {\n        if paren_chars[i]\
    \ == ' ' {\n            i += 1;\n            continue;\n        }\n\n        //\
    \ If we have hit one of the characters we are looking for, we add it to the current\
    \ paren\n        // group.\n        if chars_to_look_for.contains(&paren_chars[i])\
    \ {\n            paren_group.push(paren_chars[i]);\n        }\n\n        // If\
    \ we have hit a character that is not a paren and is not a space, this means we\
    \ have hit\n        // the end of the current paren group. We therefore add the\
    \ current paren group to the list\n        // of found paren groups and start\
    \ a new paren group.\n        if !chars_to_look_for.contains(&paren_chars[i])\
    \ && paren_chars[i] != ' ' {\n            found_paren_groups.push(paren_group.clone());\n\
    \            paren_group = String::new();\n        }\n\n        i += 1;\n    }\n\
    \n    // Once we have gone through the whole string, we need to add the current\
    \ paren group to the list\n    // of found paren groups.\n    found_paren_groups.push(paren_group);\n\
    \n    found_paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())((()))()((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmplgt3fvsv.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut stack: Vec<char>\
    \ = Vec::new();\n    let mut current_group: String = String::new();\n\n    for\
    \ c in paren_string.chars() {\n        match c {\n            '(' => {\n     \
    \           stack.push(c);\n                current_group.push(c);\n         \
    \   }\n            ')' => {\n                stack.pop();\n                current_group.push(c);\n\
    \                if stack.is_empty() {\n                    groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            _ => {\n                current_group.push(c);\n      \
    \      }\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp6wrpdhwt.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut group_string\
    \ = String::new();\n    let mut paren_count = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count ==\
    \ 0 {\n            paren_groups.push(group_string);\n            group_string\
    \ = String::new();\n        } else {\n            group_string.push(c);\n    \
    \    }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpmmfzvkpj.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut cur_paren: String\
    \ = String::new();\n    let mut cur_paren_level: u32 = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        match c {\n            '(' => {\n                cur_paren_level\
    \ += 1;\n                cur_paren.push(c);\n            }\n            ')' =>\
    \ {\n                cur_paren_level -= 1;\n                cur_paren.push(c);\n\
    \                if cur_paren_level == 0 {\n                    result.push(cur_paren);\n\
    \                    cur_paren = String::new();\n                }\n         \
    \   }\n            _ => cur_paren.push(c),\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpl5nuekrb.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // This is the list of balanced groups of parens you will return\n  \
    \  let mut paren_group_list: Vec<String> = Vec::new();\n\n    // This is the group\
    \ of parens you are currently building. Since groups\n    // are balanced, you\
    \ know you have a complete group when the count is 0\n    let mut current_paren_group:\
    \ String = String::new();\n    let mut paren_count: i32 = 0;\n\n    // This loop\
    \ takes apart the string by its characters.\n    for ch in paren_string.chars()\
    \ {\n        // If the character is a space, ignore it.\n        if ch == ' '\
    \ {\n            continue;\n        }\n\n        // If the character is an open\
    \ paren, add it to the group and increment the count\n        if ch == '(' {\n\
    \            current_paren_group.push(ch);\n            paren_count += 1;\n  \
    \      }\n\n        // If the character is a closed paren, add it to the group\
    \ and decrement the count\n        if ch == ')' {\n            current_paren_group.push(ch);\n\
    \            paren_count -= 1;\n        }\n\n        // If the paren count is\
    \ zero, then you know the current group is complete.\n        // Add it to the\
    \ list and clear the current group.\n        if paren_count == 0 {\n         \
    \   paren_group_list.push(current_paren_group.clone());\n            current_paren_group.clear();\n\
    \        }\n    }\n\n    // If you have any characters left in the current group,\
    \ then you never reached\n    // a balanced state. This is an error.\n    if current_paren_group.len()\
    \ > 0 {\n        panic!(\"Some groups are not balanced!\");\n    }\n\n    // Return\
    \ the list of balanced groups.\n    paren_group_list\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut num_parens: i8 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if num_parens == 0 {\n               \
    \ current_group.push(c);\n            }\n            num_parens += 1;\n      \
    \  } else if c == ')' {\n            num_parens -= 1;\n            if num_parens\
    \ == 0 {\n                current_group.push(c);\n                result.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if num_parens > 0 {\n            current_group.push(c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpdwe_5q8t.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Provide a list of separate paren groups\");\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Provide a list of separate
    paren groups'', /tmp/tmpwh2kfyxe.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut separators: Vec<usize> = Vec::new();\n    let mut current_depth\
    \ = 0;\n    let mut last_separator = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            current_depth += 1;\n        } else if\
    \ c == ')' {\n            current_depth -= 1;\n            if current_depth ==\
    \ 0 {\n                separators.push(last_separator);\n                separators.push(i);\n\
    \                last_separator = i + 1;\n            }\n        }\n    }\n  \
    \  separators.push(paren_string.len());\n    let mut separated: Vec<String> =\
    \ Vec::new();\n    for i in 0..separators.len() / 2 {\n        let start = separators[i\
    \ * 2];\n        let end = separators[i * 2 + 1];\n        separated.push(paren_string[start..end\
    \ + 1].into());\n    }\n    separated\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp8sfs71zi.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut res: Vec<String> = Vec::new();\n    let mut temp_paren_string\
    \ = paren_string.clone();\n    while temp_paren_string.contains(\"(\") {\n   \
    \     let first_idx = temp_paren_string.find(\"(\").unwrap();\n        let last_idx\
    \ = temp_paren_string.rfind(\")\").unwrap();\n        let mut paren_str: String\
    \ = String::new();\n        for i in first_idx..last_idx + 1 {\n            paren_str.push(temp_paren_string.remove(first_idx));\n\
    \        }\n        temp_paren_string = temp_paren_string.clone().trim().to_string();\n\
    \        res.push(paren_str);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()) ((())) () ((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpfci6u7sh.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut results = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count > 0 {\n      \
    \      current_group.push(c);\n        } else if paren_count == 0 {\n        \
    \    results.push(current_group);\n            current_group = String::new();\n\
    \        }\n    }\n    results\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp7941e6wc.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut results = Vec::new();\n    let mut start_index = 0;\n    let\
    \ mut bracket_count = 0;\n    for (index, ch) in paren_string.chars().enumerate()\
    \ {\n        match ch {\n            '(' => bracket_count += 1,\n            ')'\
    \ => bracket_count -= 1,\n            _ => (),\n        }\n        if bracket_count\
    \ == 0 {\n            results.push(paren_string[start_index..index + 1].to_string());\n\
    \            start_index = index + 1;\n        }\n    }\n    results\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpkjsjlvx3.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut new_group:\
    \ String = String::new();\n    let mut paren_nest_level: u32 = 0;\n    for ch\
    \ in paren_string.chars() {\n        match ch {\n            '(' => {\n      \
    \          if paren_nest_level == 0 {\n                    new_group.push(ch);\n\
    \                }\n                paren_nest_level += 1;\n            }\n  \
    \          ')' => {\n                paren_nest_level -= 1;\n                if\
    \ paren_nest_level == 0 {\n                    new_group.push(ch);\n         \
    \           paren_groups.push(new_group);\n                    new_group = String::new();\n\
    \                }\n            }\n            _ => {\n                if paren_nest_level\
    \ > 0 {\n                    new_group.push(ch);\n                }\n        \
    \    }\n        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmp8_yu88v9.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut paren_stack: Vec<char> = Vec::new();\n\n\
    \    for c in paren_string.chars() {\n        if c == '(' {\n            paren_stack.push(c);\n\
    \        } else if c == ')' {\n            paren_stack.pop();\n        }\n\n \
    \       current_group.push(c);\n\n        if paren_stack.is_empty() {\n      \
    \      result.push(current_group.clone());\n            current_group.clear();\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp623w96hg.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    if paren_string.is_empty() {\n        return vec![];\n    }\n\n    let\
    \ mut paren_slices: Vec<String> = vec![];\n    let mut start_index = 0;\n    let\
    \ mut paren_stack: Vec<usize> = vec![];\n\n    for (i, ch) in paren_string.chars().enumerate()\
    \ {\n        match ch {\n            '(' => {\n                paren_stack.push(i);\n\
    \            }\n            ')' => {\n                // An error occurred, the\
    \ stack is empty and we still have a closing paren\n                if paren_stack.is_empty()\
    \ {\n                    return vec![];\n                }\n\n               \
    \ let start_paren_index = paren_stack.pop().unwrap();\n                paren_slices.push(paren_string[start_paren_index..=i].to_string());\n\
    \            }\n            _ => {}\n        }\n    }\n\n    if !paren_stack.is_empty()\
    \ {\n        return vec![];\n    }\n\n    paren_slices\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"(()())\", \"()\", \"(())\", \"((()))\", \"()\", \"()\",\
    \ \"(())\", \"()\", \"()\", \"((())()())\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmphgkmayse.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut stack: Vec<char>\
    \ = Vec::new();\n    let mut current_str: String = String::new();\n\n    for c\
    \ in paren_string.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        }\n        else if c == ')' {\n            stack.pop();\n           \
    \ if stack.is_empty() {\n                result.push(current_str);\n         \
    \       current_str = String::new();\n            }\n        }\n        else if\
    \ c != ' ' {\n            current_str.push(c);\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpyd3mtc_1.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut group_string\
    \ = String::new();\n    let mut paren_count = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            paren_count += 1;\n        } else if c\
    \ == ')' {\n            paren_count -= 1;\n        }\n        if paren_count >\
    \ 0 {\n            group_string.push(c);\n        } else if paren_count == 0 {\n\
    \            if group_string.len() > 0 {\n                paren_groups.push(group_string);\n\
    \                group_string = String::new();\n            }\n        }\n   \
    \ }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"((())\", \"(\", \"((())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpdaovj98d.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Separate out all balanced paren groups from {:?}\",\
    \ paren_string);\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate out all balanced
    paren groups from "(()()) ((())) () ((())()())"'', /tmp/tmp5zpgpity.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut output = Vec::new();\n    let mut accum = String::new();\n  \
    \  let mut stack = Vec::new();\n    for c in paren_string.chars() {\n        match\
    \ c {\n            '(' => {\n                stack.push(c);\n                accum.push(c);\n\
    \            }\n            ')' => {\n                stack.pop();\n         \
    \       accum.push(c);\n                if stack.is_empty() {\n              \
    \      output.push(accum);\n                    accum = String::new();\n     \
    \           }\n            }\n            _ => accum.push(c),\n        }\n   \
    \ }\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpr24mlqda.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut temp_string: String\
    \ = String::new();\n    let mut counter: i32 = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            counter += 1;\n        } else if c ==\
    \ ')' {\n            counter -= 1;\n        }\n\n        if counter > 0 {\n  \
    \          temp_string.push(c);\n        } else if counter == 0 {\n          \
    \  result.push(temp_string);\n            temp_string = String::new();\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpc0vwej9d.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821378
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // First, let's remove all spaces. We can do this just by filtering out\
    \ all spaces\n    let mut no_spaces = String::new();\n    for c in paren_string.chars()\
    \ {\n        if c != ' ' {\n            no_spaces.push(c);\n        }\n    }\n\
    \n    // At this point we can look at each character and keep track of the current\
    \ group\n    let mut group = String::new();\n    let mut groups = Vec::new();\n\
    \    let mut open_parens = 0;\n    for c in no_spaces.chars() {\n        match\
    \ c {\n            '(' => {\n                open_parens += 1;\n             \
    \   group.push(c);\n            }\n            ')' => {\n                open_parens\
    \ -= 1;\n                group.push(c);\n                if open_parens == 0 {\n\
    \                    groups.push(group);\n                    group = String::new();\n\
    \                }\n            }\n            _ => {\n                group.push(c);\n\
    \            }\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut current_group = String::new();\n    let mut balanced_groups =\
    \ Vec::new();\n    let mut stack: Vec<char> = Vec::new();\n\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            stack.push(ch);\n        } else if ch\
    \ == ')' {\n            match stack.pop() {\n                Some(_) => {\n  \
    \                  if stack.is_empty() {\n                        balanced_groups.push(current_group.to_string());\n\
    \                        current_group.clear();\n                    }\n     \
    \           }\n                None => panic!(\"unbalanced\"),\n            }\n\
    \        } else if !ch.is_whitespace() {\n            current_group.push(ch);\n\
    \        }\n    }\n\n    balanced_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpc84xm4sm.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Your code here!\n    let mut paren_string = paren_string;\n\
    \    let mut v: Vec<String> = Vec::new();\n    while let Some(i) = paren_string.find('(')\
    \ {\n        let mut num_opens = 1;\n        let mut pos = i + 1;\n        while\
    \ num_opens > 0 {\n            if paren_string.chars().nth(pos).unwrap() == '('\
    \ {\n                num_opens += 1;\n            } else if paren_string.chars().nth(pos).unwrap()\
    \ == ')' {\n                num_opens -= 1;\n            }\n            pos +=\
    \ 1;\n        }\n        let slice = &paren_string[i..pos];\n        let mut string\
    \ = String::from(slice);\n        v.push(string);\n        paren_string = paren_string[pos..].to_string();\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpe1abe2ch.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: your code here\n    Vec::new()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp9nkrgkw_.rs:12:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"separate the parentheses groups from {}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: separate the parentheses
    groups from (()()) ((())) () ((())()())'', /tmp/tmpdarqmplh.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821379
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    paren_string\n        .chars()\n        .filter(|c| *c != ' ')\n    \
    \    .fold(vec![Vec::new()], |mut output, c| {\n            if c == '(' {\n  \
    \              output.push(Vec::new());\n            } else if c == ')' {\n  \
    \              if let Some(vec) = output.pop() {\n                    if let Some(vec)\
    \ = output.last_mut() {\n                        vec.extend(vec);\n          \
    \          } else {\n                        output.push(vec);\n             \
    \       }\n                }\n            } else {\n                if let Some(vec)\
    \ = output.last_mut() {\n                    vec.push(c);\n                }\n\
    \            }\n            output\n        })\n        .into_iter()\n       \
    \ .map(|vec| vec.into_iter().collect())\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Vec<_>: Extend<&mut _>` is not satisfied\n\
    \  --> /tmp/tmp3og9e9oy.rs:15:36\n   |\n15 |                         vec.extend(vec);\n\
    \   |                                    ^^^ the trait `Extend<&mut _>` is not\
    \ implemented for `Vec<_>`\n   |\n   = help: the following implementations were\
    \ found:\n             <Vec<T, A> as Extend<&'a T>>\n             <Vec<T, A> as\
    \ Extend<T>>\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Part 3: Separate nested paren groups from {}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Part 3: Separate nested
    paren groups from (()()) ((())) () ((())()())'', /tmp/tmpx22wu39f.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_vec: Vec<char> = paren_string.chars().collect();\n    let\
    \ mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut nest_count = 0;\n\n    paren_vec.retain(|c| c != &' ');\n    for\
    \ char in paren_vec {\n        if char == '(' {\n            nest_count += 1;\n\
    \        }\n        if nest_count > 0 {\n            current_group.push(char);\n\
    \        }\n        if char == ')' {\n            nest_count -= 1;\n        }\n\
    \        if nest_count == 0 && current_group.len() > 0 {\n            paren_groups.push(current_group.clone());\n\
    \            current_group.clear();\n        }\n    }\n    paren_groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Given a string `{}`, separate out the nested groups\
    \ of parentheses.\", paren_string)\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Given a string `(()()) ((()))
    () ((())()())`, separate out the nested groups of parentheses.'', /tmp/tmppc3mg3r0.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    paren_string\n        .split(|c| c == ' ')\n        .filter(|s| s.contains('(')\
    \ || s.contains(')'))\n        .map(|s| s.replace(\"()\", \"\"))\n        .filter(|s|\
    \ !s.is_empty())\n        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"(())\", \"(())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"\
    ((())()())\"]`', /tmp/tmp9s7cgwg_.rs:16:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut next_start = 0;\n    let mut\
    \ count = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if\
    \ c == '(' {\n            if count == 0 {\n                next_start = i;\n \
    \           }\n            count += 1;\n        } else if c == ')' {\n       \
    \     count -= 1;\n            if count == 0 {\n                result.push(paren_string[next_start..i\
    \ + 1].to_string());\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpuac1xbjw.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Return a vector of strings containing the separate parentheses\
    \ groups from {}\", paren_string);\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return a vector of strings
    containing the separate parentheses groups from (()()) ((())) () ((())()())'',
    /tmp/tmpl0k0hig6.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut acc = String::new();\n    let\
    \ mut count = 0;\n    for char in paren_string.chars() {\n        match char {\n\
    \            '(' => {\n                count += 1;\n                acc.push(char);\n\
    \            }\n            ')' => {\n                count -= 1;\n          \
    \      acc.push(char);\n                if count == 0 {\n                    result.push(acc);\n\
    \                    acc = String::new();\n                }\n            }\n\
    \            _ => {\n                acc.push(char);\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpe6skgsiq.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    paren_string\n        .split(\" \")\n        .collect::<Vec<&str>>()\n\
    \        .join(\"\")\n        .split(\"()\")\n        .filter(|x| x.len() > 0)\n\
    \        .map(|x| String::from(x))\n        .collect()\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \")((\", \"))\", \"((\", \")\", \")\"]`,\n right: `[\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"]`', /tmp/tmpgkqoljya.rs:18:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut stack = Vec::new();\n    let mut iter = paren_string.chars();\n \
    \   while let Some(c) = iter.next() {\n        if c == ' ' {\n            continue;\n\
    \        } else if c == '(' {\n            stack.push(c);\n            current_group.push(c);\n\
    \        } else if c == ')' {\n            if let Some(open_paren) = stack.pop()\
    \ {\n                if open_paren != '(' {\n                    panic!(\"Mismatched\
    \ parens.\");\n                }\n                current_group.push(c);\n   \
    \             if stack.is_empty() {\n                    result.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       } else {\n                panic!(\"Mismatched parens.\");\n          \
    \  }\n        } else {\n            current_group.push(c);\n        }\n    }\n\
    \    if !stack.is_empty() {\n        panic!(\"Mismatched parens.\");\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut is_group = false;\n    let mut paren_count\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '('\
    \ => {\n                paren_count += 1;\n                if !is_group {\n  \
    \                  is_group = true;\n                }\n                current_group.push(c);\n\
    \            }\n            ')' => {\n                paren_count -= 1;\n    \
    \            if paren_count < 0 {\n                    panic!(\"Too many closing\
    \ parentheses\");\n                }\n                current_group.push(c);\n\
    \                if paren_count == 0 {\n                    is_group = false;\n\
    \                    result.push(current_group.clone());\n                   \
    \ current_group.clear();\n                }\n            }\n            _ => {\n\
    \                if is_group {\n                    current_group.push(c);\n \
    \               }\n            }\n        }\n    }\n    if paren_count != 0 {\n\
    \        panic!(\"Too many opening parentheses\");\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpo5750zan.rs:49:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_result:\
    \ String = String::new();\n    let mut balance = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            balance += 1;\n        } else if c ==\
    \ ')' {\n            balance -= 1;\n        }\n        if balance == 0 {\n   \
    \         result.push(current_result);\n            current_result = String::new();\n\
    \        } else {\n            current_result.push(c);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpta6vqbf2.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp4_bnur_5.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Implement this function\n    let mut paren_groups: Vec<String>\
    \ = Vec::new();\n    let mut paren_group: String = String::new();\n    let mut\
    \ paren_stack: Vec<char> = Vec::new();\n    for c in paren_string.chars() {\n\
    \        if c == '(' {\n            paren_stack.push(c);\n        } else if c\
    \ == ')' {\n            paren_stack.pop();\n        } else if paren_stack.is_empty()\
    \ {\n            paren_groups.push(paren_group);\n            paren_group = String::new();\n\
    \        } else {\n            paren_group.push(c);\n        }\n    }\n    paren_groups.push(paren_group);\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpkvbjiykf.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut curr_group:\
    \ String = String::new();\n    let mut group_opened: bool = false;\n    let mut\
    \ group_closed: bool = false;\n    let mut group_nested: bool = false;\n    let\
    \ mut group_mismatch: bool = false;\n    let mut group_mismatch_count: u32 = 0;\n\
    \    let mut group_open_count: u32 = 0;\n    let mut group_close_count: u32 =\
    \ 0;\n    let mut paren_count: u32 = 0;\n    let mut prev_char: Option<char> =\
    \ None;\n    let mut curr_char: Option<char> = None;\n    let mut prev_group_len:\
    \ usize = 0;\n    let mut curr_group_len: usize = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        prev_char = curr_char;\n        curr_char = Some(c);\n        prev_group_len\
    \ = curr_group_len;\n        curr_group_len = curr_group.len();\n        match\
    \ c {\n            '(' => {\n                paren_count += 1;\n             \
    \   if group_opened {\n                    group_nested = true;\n            \
    \    }\n                if !group_opened {\n                    group_opened =\
    \ true;\n                }\n                if group_closed {\n              \
    \      group_closed = false;\n                }\n                if !group_mismatch\
    \ {\n                    curr_group.push('(');\n                }\n          \
    \      group_open_count += 1;\n            }\n            ')' => {\n         \
    \       paren_count -= 1;\n                if group_opened {\n               \
    \     group_closed = true;\n                }\n                if group_opened\
    \ && paren_count == 0 {\n                    group_opened = false;\n         \
    \       }\n                if paren_count < 0 {\n                    group_mismatch\
    \ = true;\n                    group_mismatch_count += 1;\n                }\n\
    \                if !group_mismatch {\n                    curr_group.push(')');\n\
    \                }\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpemkan2nl.rs:65:3\n\
    \   |\n5  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n20 |     for (i, c) in paren_string.chars().enumerate() {\n\
    \   |                                                    - unclosed delimiter\n\
    ...\n25 |         match c {\n   |                 - unclosed delimiter\n...\n\
    42 |             ')' => {\n   |                    - this delimiter might not\
    \ be properly closed...\n...\n57 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n65 | }\n   |   ^\n\nerror: expected identifier,\
    \ found keyword `fn`\n  --> /tmp/tmpemkan2nl.rs:59:1\n   |\n59 | fn main() {\n\
    \   | ^^ expected identifier, found keyword\n\nerror: expected one of `=>`, `@`,\
    \ `if`, or `|`, found `main`\n  --> /tmp/tmpemkan2nl.rs:59:4\n   |\n59 | fn main()\
    \ {\n   |    ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpemkan2nl.rs:20:5\n   |\n5  |   fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \        ----------- expected `Vec<String>` because of return type\n...\n20 |\
    \ /     for (i, c) in paren_string.chars().enumerate() {\n21 | |         prev_char\
    \ = curr_char;\n22 | |         curr_char = Some(c);\n23 | |         prev_group_len\
    \ = curr_group_len;\n...  |\n64 | |     assert_eq!(candidate(String::from(\"(\
    \ ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n65 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut brace_count: u8 = 0;\n\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            if brace_count == 0 {\n             \
    \   // start a new group\n                current_group = String::new();\n   \
    \         }\n            brace_count += 1;\n        } else if ch == ')' {\n  \
    \          brace_count -= 1;\n            if brace_count == 0 {\n            \
    \    // end the current group\n                groups.push(current_group);\n \
    \           }\n        } else if brace_count > 0 {\n            // don't add spaces\n\
    \            if ch != ' ' {\n                current_group.push(ch);\n       \
    \     }\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `current_group`\n  --> /tmp/tmpo4i6ylr6.rs:21:29\n\
    \   |\n7  |     let mut current_group: String = String::new();\n   |         -----------------\
    \ move occurs because `current_group` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n14 |                 current_group = String::new();\n\
    \   |                 ------------- this reinitialization might get skipped\n\
    ...\n21 |                 groups.push(current_group);\n   |                  \
    \           ^^^^^^^^^^^^^ value moved here, in previous iteration of loop\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut counter = 0;\n    let mut result = Vec::new();\n    let mut current_result\
    \ = String::new();\n    let paren_string_chars = paren_string.chars();\n    for\
    \ c in paren_string_chars {\n        if c == '(' {\n            counter += 1;\n\
    \        } else if c == ')' {\n            counter -= 1;\n        }\n        if\
    \ counter == 0 {\n            result.push(current_result);\n            current_result\
    \ = String::new();\n        } else {\n            current_result.push(c);\n  \
    \      }\n    }\n    if current_result.len() > 0 {\n        result.push(current_result);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpor7y8f_b.rs:31:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut string_chars =\
    \ paren_string.chars();\n    let mut current_group: String = String::new();\n\
    \    let mut nest_count: i8 = 0;\n    let mut parsed_all_chars = false;\n    while\
    \ !parsed_all_chars {\n        match string_chars.next() {\n            Some(ch)\
    \ => {\n                match ch {\n                    '(' => {\n           \
    \             if nest_count == 0 {\n                            // Starting a\
    \ new group.\n                            current_group.push(ch);\n          \
    \                  nest_count += 1;\n                        } else {\n      \
    \                      // Still in same group\n                            current_group.push(ch);\n\
    \                            nest_count += 1;\n                        }\n   \
    \                 }\n                    ')' => {\n                        //\
    \ Still in same group\n                        current_group.push(ch);\n     \
    \                   nest_count -= 1;\n                        if nest_count ==\
    \ 0 {\n                            // Just finished a group.\n               \
    \             result.push(current_group);\n                            current_group\
    \ = String::new();\n                        }\n                    }\n       \
    \             _ => {\n                        if nest_count > 0 {\n          \
    \                  // Still in same group.\n                            current_group.push(ch);\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            None => {\n                parsed_all_chars = true;\n   \
    \         }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpbmhzitpj.rs:57:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Return the list of paren group strings from {}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Return the list of paren
    group strings from (()()) ((())) () ((())()())'', /tmp/tmpf6q316k8.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    paren_string\n        .chars()\n        .filter(|x| *x != ' ')\n    \
    \    .fold(vec![vec![]], |mut groups, ch| {\n            if ch == '(' {\n    \
    \            groups.push(vec![ch]);\n            } else if ch == ')' {\n     \
    \           let mut final_group = groups.pop().unwrap();\n                final_group.push(ch);\n\
    \                groups.push(final_group);\n            } else {\n           \
    \     groups.last_mut().unwrap().push(ch);\n            }\n            groups\n\
    \        })\n        .into_iter()\n        .map(|vec| vec.into_iter().collect())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"(\", \"()\", \"())\", \"(\", \"(\", \"()))\", \"()\", \"(\", \"(\"\
    , \"())\", \"()\", \"())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmp3ma4pv0o.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut active_string\
    \ = String::new();\n    let mut bracket_count = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                if bracket_count\
    \ == 0 {\n                    active_string.push(c);\n                }\n    \
    \            bracket_count += 1;\n            }\n            ')' => {\n      \
    \          bracket_count -= 1;\n                if bracket_count == 0 {\n    \
    \                active_string.push(c);\n                    paren_groups.push(active_string);\n\
    \                    active_string = String::new();\n                }\n     \
    \       }\n            _ => {\n                if bracket_count != 0 {\n     \
    \               active_string.push(c);\n                }\n            }\n   \
    \     }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpuvszktwg.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut buffer = String::new();\n \
    \   let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            if paren_count == 0 {\n                if !buffer.is_empty()\
    \ {\n                    result.push(buffer);\n                    buffer = String::new();\n\
    \                }\n            }\n            paren_count += 1;\n        } else\
    \ if c == ')' {\n            paren_count -= 1;\n            if paren_count ==\
    \ 0 {\n                if !buffer.is_empty() {\n                    result.push(buffer);\n\
    \                    buffer = String::new();\n                }\n            }\n\
    \        } else if c == ' ' {\n            continue;\n        } else {\n     \
    \       buffer.push(c);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpnm2fro8q.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut curr_str: String\
    \ = String::new();\n    let mut curr_balance: i32 = 0;\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' => {\n                curr_balance\
    \ += 1;\n                curr_str.push(paren);\n            }\n            ')'\
    \ => {\n                curr_balance -= 1;\n                curr_str.push(paren);\n\
    \                if curr_balance == 0 {\n                    groups.push(curr_str);\n\
    \                    curr_str = String::new();\n                }\n          \
    \  }\n            _ => {\n                curr_str.push(paren);\n            }\n\
    \        }\n    }\n    return groups;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpv75kra3e.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut output = Vec::new();\n    let\
    \ mut current_s = String::new();\n    for c in paren_string.chars() {\n      \
    \  if c == '(' {\n            if !current_s.is_empty() {\n                output.push(current_s);\n\
    \                current_s = String::new();\n            }\n            stack.push(0);\n\
    \        } else if c == ')' {\n            if !current_s.is_empty() {\n      \
    \          output.push(current_s);\n                current_s = String::new();\n\
    \            }\n            stack.pop();\n        } else if c != ' ' {\n     \
    \       current_s.push(c);\n        }\n    }\n    if !current_s.is_empty() {\n\
    \        output.push(current_s);\n    }\n    output\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpp0imdyks.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut num_open_parens: u32 = 0;\n\n    // Iterate\
    \ through the string. Keep track of the number of open parentheses and start a\
    \ new\n    // group once the number of open parens is 0\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                num_open_parens\
    \ += 1;\n                current_group.push(c);\n            }\n            ')'\
    \ => {\n                num_open_parens -= 1;\n                current_group.push(c);\n\
    \            }\n            _ => {\n                current_group.push(c);\n \
    \           }\n        }\n\n        if num_open_parens == 0 {\n            paren_groups.push(current_group);\n\
    \            current_group = String::new();\n        }\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp6c93sz8_.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut group_start =\
    \ 0;\n    let mut open_parens = 0;\n    for (index, paren) in paren_string.chars().enumerate()\
    \ {\n        match paren {\n            '(' => {\n                if open_parens\
    \ == 0 {\n                    group_start = index;\n                }\n      \
    \          open_parens += 1;\n            }\n            ')' => {\n          \
    \      open_parens -= 1;\n                if open_parens == 0 {\n            \
    \        result.push(paren_string[group_start..index+1].to_string());\n      \
    \          }\n            }\n            _ => {}\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp4ng8uff0.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // parse string and collect all opening parens\n    let mut paren_stack:\
    \ Vec<usize> = Vec::new();\n    let mut paren_vec: Vec<Paren> = Vec::new();\n\
    \    for (pos, c) in paren_string.chars().enumerate() {\n        match c {\n \
    \           '(' => {\n                paren_stack.push(pos);\n               \
    \ paren_vec.push(Paren::Open);\n            }\n            ')' => {\n        \
    \        let open_pos = paren_stack.pop().unwrap();\n                paren_vec.push(Paren::Close(open_pos));\n\
    \            }\n            _ => (),\n        }\n    }\n\n    // parse all paren\
    \ groups, ignoring spaces\n    let mut paren_groups: Vec<String> = Vec::new();\n\
    \    let mut groups_start = 0;\n    let mut paren_level = 0;\n    for i in 0..paren_vec.len()\
    \ {\n        match paren_vec[i] {\n            Paren::Open => {\n            \
    \    paren_level += 1;\n            }\n            Paren::Close(open_pos) => {\n\
    \                if paren_level == 1 {\n                    paren_groups.push(paren_string[groups_start..open_pos].to_string());\n\
    \                    groups_start = open_pos + 1;\n                }\n       \
    \         paren_level -= 1;\n            }\n        }\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Paren`\n  -->\
    \ /tmp/tmp992_1y_u.rs:13:32\n   |\n13 |                 paren_vec.push(Paren::Open);\n\
    \   |                                ^^^^^ use of undeclared type `Paren`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Paren`\n  --> /tmp/tmp992_1y_u.rs:17:32\n\
    \   |\n17 |                 paren_vec.push(Paren::Close(open_pos));\n   |    \
    \                            ^^^^^ use of undeclared type `Paren`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Paren`\n  --> /tmp/tmp992_1y_u.rs:29:13\n\
    \   |\n29 |             Paren::Open => {\n   |             ^^^^^ use of undeclared\
    \ type `Paren`\n\nerror[E0433]: failed to resolve: use of undeclared type `Paren`\n\
    \  --> /tmp/tmp992_1y_u.rs:32:13\n   |\n32 |             Paren::Close(open_pos)\
    \ => {\n   |             ^^^^^ use of undeclared type `Paren`\n\nerror[E0412]:\
    \ cannot find type `Paren` in this scope\n --> /tmp/tmp992_1y_u.rs:8:28\n  |\n\
    5 | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n  |     \
    \                    - help: you might be missing a type parameter: `<Paren>`\n\
    ...\n8 |     let mut paren_vec: Vec<Paren> = Vec::new();\n  |                \
    \            ^^^^^ not found in this scope\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut v: Vec<String> = Vec::new();\n    let mut n = 0;\n    let mut\
    \ c = String::new();\n    let l = paren_string.len();\n    for i in 0..l {\n \
    \       let cn = &paren_string[i..i + 1];\n        if cn == \" \" {\n        \
    \    continue;\n        }\n        c.push_str(cn);\n        n += if cn == \"(\"\
    \ { 1 } else { -1 };\n        if n == 0 {\n            v.push(c);\n          \
    \  c = String::new();\n        }\n    }\n    v\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut count: usize =\
    \ 0;\n    let mut tmp_string: String = String::new();\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                count += 1;\n  \
    \              tmp_string.push(c);\n            }\n            ')' => {\n    \
    \            count -= 1;\n                tmp_string.push(c);\n              \
    \  if count == 0 {\n                    result.push(tmp_string);\n           \
    \         tmp_string = String::new();\n                }\n            }\n    \
    \        _ => {\n                tmp_string.push(c);\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpwmmx5fxa.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut depth = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              current_group.push(c);\n            }\n            ')' => {\n \
    \               depth -= 1;\n                current_group.push(c);\n        \
    \        if depth == 0 {\n                    groups.push(current_group);\n  \
    \                  current_group = String::new();\n                }\n       \
    \     }\n            _ => current_group.push(c),\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp194mp0g9.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Implement\n    let mut paren_list: Vec<String> = Vec::new();\n\
    \    let mut group_chars: Vec<char> = Vec::new();\n    let mut group_num = 0;\n\
    \    let mut group_char = 0;\n    for c in paren_string.chars() {\n        if\
    \ c != ' ' {\n            if c == '(' {\n                group_num += 1;\n   \
    \         } else if c == ')' {\n                group_num -= 1;\n            }\n\
    \            group_chars.push(c);\n            group_char += 1;\n            if\
    \ group_num == 0 {\n                paren_list.push(group_chars.into_iter().collect());\n\
    \                group_chars = Vec::new();\n                group_char = 0;\n\
    \            }\n        }\n    }\n    return paren_list;\n}\n\nfn main() {\n \
    \   let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut level = 0;\n    let mut res = vec![];\n    let mut last_ind =\
    \ 0;\n    let paren_string: Vec<char> = paren_string.chars().collect();\n    for\
    \ i in 0..paren_string.len() {\n        if paren_string[i] == '(' {\n        \
    \    level += 1;\n        } else if paren_string[i] == ')' {\n            level\
    \ -= 1;\n        }\n        if level == 0 {\n            res.push(paren_string[last_ind..i+1].iter().cloned().collect());\n\
    \            last_ind = i+1;\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" \", \"((()))\", \" \", \"()\", \" \", \"((())()())\"]`,\n right:\
    \ `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp96jp1fwq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut depth: i8 = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                depth += 1;\n  \
    \              current_group.push(c);\n            }\n            ')' => {\n \
    \               depth -= 1;\n                current_group.push(c);\n        \
    \        if depth == 0 {\n                    groups.push(current_group);\n  \
    \                  current_group = String::new();\n                }\n       \
    \     }\n            ' ' => {\n                // do nothing\n            }\n\
    \            _ => {\n                current_group.push(c);\n            }\n \
    \       }\n    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821379
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    /// This is a recursive function. It takes as input a string containing\
    \ a single balanced parentheses\n    /// group, as well as the index of the first\
    \ opening paren. It returns the balanced group.\n    fn sub_group(s: &str, idx:\
    \ usize) -> String {\n        let mut result = \"\".to_string();\n        let\
    \ mut num_paren = 1;\n\n        for (i, c) in s[idx..].chars().enumerate() {\n\
    \            if c == '(' {\n                num_paren += 1;\n            } else\
    \ if c == ')' {\n                num_paren -= 1;\n            }\n\n          \
    \  if num_paren == 0 {\n                return result;\n            }\n\n    \
    \        result.push(c);\n        }\n\n        result\n    }\n\n    let mut result\
    \ = Vec::new();\n    let mut idx = 0;\n\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            if idx < i {\n                result.push(paren_string[idx..i].to_string());\n\
    \            }\n\n            let sub_group = sub_group(&paren_string, i);\n \
    \           result.push(sub_group);\n            idx = i + sub_group.len() + 1;\n\
    \        }\n    }\n\n    if idx < paren_string.len() {\n        result.push(paren_string[idx..].to_string());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `i`\n  --> /tmp/tmppowqdbv1.rs:12:14\n   |\n\
    12 |         for (i, c) in s[idx..].chars().enumerate() {\n   |              ^\
    \ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]: borrow of moved\
    \ value: `sub_group`\n  --> /tmp/tmppowqdbv1.rs:40:23\n   |\n38 |            \
    \ let sub_group = sub_group(&paren_string, i);\n   |                 ---------\
    \ move occurs because `sub_group` has type `String`, which does not implement\
    \ the `Copy` trait\n39 |             result.push(sub_group);\n   |           \
    \              --------- value moved here\n40 |             idx = i + sub_group.len()\
    \ + 1;\n   |                       ^^^^^^^^^ value borrowed here after move\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens = 0;\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if open_parens == 0 {\n              \
    \  current_group.clear();\n            }\n            open_parens += 1;\n    \
    \        current_group.push(c);\n        } else if c == ')' {\n            open_parens\
    \ -= 1;\n            current_group.push(c);\n            if open_parens == 0 {\n\
    \                result.push(current_group.clone());\n            }\n        }\
    \ else if open_parens > 0 {\n            current_group.push(c);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpdag6roml.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut processed_vec: Vec<u8> = Vec::new();\n    let mut processed_str:\
    \ String = String::new();\n    let mut res: Vec<String> = Vec::new();\n    let\
    \ mut bracket_count: i32 = 0;\n    let mut skip_next: bool = false;\n\n    for\
    \ c in paren_string.bytes() {\n        if skip_next {\n            skip_next =\
    \ false;\n            continue;\n        }\n\n        if c == (b' ') {\n     \
    \       skip_next = true;\n            continue;\n        }\n\n        if c ==\
    \ (b'(') {\n            bracket_count += 1;\n        } else if c == (b')') {\n\
    \            bracket_count -= 1;\n        }\n\n        processed_vec.push(c);\n\
    \n        if bracket_count == 0 {\n            res.push(processed_vec.clone().into_iter().map(|x|\
    \ x as char).collect());\n            processed_vec.clear();\n        }\n    }\n\
    \n    res\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"(())\", \"))((\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpq1v9oaxt.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut buffer = String::new();\n \
    \   let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n  \
    \          paren_count -= 1;\n        }\n        if paren_count == 0 {\n     \
    \       result.push(buffer);\n            buffer = String::new();\n        } else\
    \ {\n            buffer.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpjya65c6v.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // variable to hold the number of parenthesis\n    let mut num_parens\
    \ = 0;\n    // variable to hold the start index of a parenthesis group\n    let\
    \ mut paren_start = 0;\n    // variable to hold the end index of a parenthesis\
    \ group\n    let mut paren_end = 0;\n    // variable to hold the complete list\
    \ of parenthesis groups\n    let mut paren_groups = Vec::new();\n    // iterate\
    \ through each character of the paren_string\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        // if the character is a space, skip it\n        if c == ' ' {\n\
    \            continue;\n        }\n        // if the character is a '(', increment\
    \ the count\n        if c == '(' {\n            num_parens += 1;\n           \
    \ // if this is the first (, then we have a starting position\n            if\
    \ num_parens == 1 {\n                paren_start = i;\n            }\n       \
    \ }\n        // if the character is a ')', decrement the count\n        if c ==\
    \ ')' {\n            num_parens -= 1;\n            // if this is the last ), then\
    \ we have a ending position\n            if num_parens == 0 {\n              \
    \  paren_end = i;\n                // add the substring to the paren_groups list\n\
    \                paren_groups.push(paren_string[paren_start..=paren_end].to_string());\n\
    \            }\n        }\n    }\n    // return the list of paren_groups\n   \
    \ paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpcz6d523j.rs:48:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut open_parens = 0;\n    let mut\
    \ last_paren_idx = 0;\n    for (idx, c) in paren_string.chars().enumerate() {\n\
    \        match c {\n            '(' => {\n                if open_parens == 0\
    \ {\n                    last_paren_idx = idx;\n                }\n          \
    \      open_parens += 1;\n            }\n            ')' => {\n              \
    \  open_parens -= 1;\n                if open_parens == 0 {\n                \
    \    result.push(paren_string[last_paren_idx..idx + 1].to_string());\n       \
    \         }\n            }\n            _ => (),\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpgubb_1p7.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut stack = vec![];\n    let mut\
    \ i = 0;\n    let mut start = 0;\n    while i < paren_string.len() {\n       \
    \ if paren_string.chars().nth(i).unwrap() == '(' {\n            stack.push('(');\n\
    \        } else if paren_string.chars().nth(i).unwrap() == ')' {\n           \
    \ stack.pop();\n            if stack.is_empty() {\n                let part =\
    \ &paren_string[start..i+1];\n                result.push(part.to_string());\n\
    \                start = i + 1;\n            }\n        }\n        i += 1;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmputovl70d.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_str = String::new();\n\
    \    let mut open_paren_cnt = 0;\n    for ch in paren_string.chars() {\n     \
    \   if ch == '(' {\n            if open_paren_cnt > 0 {\n                current_str.push(ch);\n\
    \            }\n            open_paren_cnt += 1;\n        } else if ch == ')'\
    \ {\n            open_paren_cnt -= 1;\n            if open_paren_cnt > 0 {\n \
    \               current_str.push(ch);\n            } else {\n                result.push(current_str);\n\
    \                current_str = String::new();\n            }\n        } else if\
    \ open_paren_cnt > 0 {\n            current_str.push(ch);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()()\", \"(())\", \"\", \"(())()()\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmp6pww4wxq.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821379
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut results = Vec::new();\n    let mut temp = String::new();\n  \
    \  let mut paren_count = 0;\n    for c in paren_string.chars() {\n        if c\
    \ == '(' {\n            paren_count += 1;\n        } else if c == ')' {\n    \
    \        paren_count -= 1;\n        }\n        if paren_count == 0 {\n       \
    \     results.push(temp);\n            temp = String::new();\n        } else {\n\
    \            temp.push(c);\n        }\n    }\n    results\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpht_c0h27.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Take the paren string '{}' and split it into a list\
    \ of groups of balanced parentheses\", paren_string);\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Take the paren string ''(()())
    ((())) () ((())()())'' and split it into a list of groups of balanced parentheses'',
    /tmp/tmpeazuaff3.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut stack: Vec<char>\
    \ = Vec::new();\n    let mut chars = paren_string.chars();\n    let mut curr_string\
    \ = String::new();\n\n    while let Some(ch) = chars.next() {\n        if ch ==\
    \ '(' {\n            stack.push(ch);\n        } else if ch == ')' {\n        \
    \    if let Some(_) = stack.pop() {\n                // Found a valid closing\
    \ parenthesis\n                curr_string.push(ch);\n                // Start\
    \ new group if stack is empty\n                if stack.is_empty() {\n       \
    \             groups.push(curr_string);\n                    curr_string = String::new();\n\
    \                }\n            } else {\n                // No match for current\
    \ closing parenthesis, ignore\n            }\n        } else if ch != ' ' {\n\
    \            curr_string.push(ch);\n        }\n    }\n\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\")))\", \")))\", \")\", \")))))\"]`,\n right: `[\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]`', /tmp/tmpwq23ic70.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut answer: Vec<String> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                if !current_string.is_empty()\
    \ {\n                    stack.push(current_string);\n                    current_string\
    \ = String::new();\n                }\n                stack.push(c.to_string());\n\
    \            }\n            ')' => {\n                if !current_string.is_empty()\
    \ {\n                    stack.push(current_string);\n                    current_string\
    \ = String::new();\n                }\n                let mut last_string = stack.pop().unwrap();\n\
    \                while !stack.is_empty() && last_string != \"(\" {\n         \
    \           let popped = stack.pop().unwrap();\n                    last_string\
    \ = format!(\"{}{}\", popped, last_string);\n                }\n             \
    \   if stack.is_empty() {\n                    answer.push(last_string);\n   \
    \             } else {\n                    stack.push(last_string);\n       \
    \         }\n            }\n            _ => {\n                current_string.push(c);\n\
    \            }\n        }\n    }\n\n    if !current_string.is_empty() {\n    \
    \    answer.push(current_string);\n    }\n\n    while !stack.is_empty() {\n  \
    \      let popped = stack.pop().unwrap();\n        answer.push(popped);\n    }\n\
    \n    answer\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"(\", \"(\", \"(\", \"(\", \" \", \"(\", \" \", \"(\", \"(\", \"(\"\
    , \" \", \"(\", \"(\", \"(\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"\
    ((())()())\"]`', /tmp/tmpr3j11q7f.rs:55:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut balanced_groups: Vec<String> = Vec::new();\n    let mut curr_group\
    \ = String::new();\n    let mut paren_count = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' => {\n                paren_count += 1;\n\
    \                curr_group.push(c);\n            }\n            ')' => {\n  \
    \              paren_count -= 1;\n                curr_group.push(c);\n      \
    \          if paren_count == 0 {\n                    balanced_groups.push(curr_group);\n\
    \                    curr_group = String::new();\n                }\n        \
    \    }\n            _ => curr_group.push(c),\n        }\n    }\n    return balanced_groups;\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \" ((()))\", \" ()\", \" ((())()())\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp74ucq_0r.rs:31:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result: Vec<String> = Vec::new();\n    let mut paren_iter = paren_string.chars();\n\
    \    loop {\n        let mut inner_parens = String::new();\n        loop {\n \
    \           let paren = paren_iter.next();\n            match paren {\n      \
    \          Some('(') => inner_parens.push('('),\n                Some(')') =>\
    \ {\n                    inner_parens.push(')');\n                    if inner_parens.chars().filter(|&c|\
    \ c == '(').count()\n                        == inner_parens.chars().filter(|&c|\
    \ c == ')').count()\n                    {\n                        break;\n \
    \                   }\n                }\n                Some(_) => {}\n    \
    \            None => break,\n            }\n        }\n        if inner_parens.len()\
    \ > 0 {\n            result.push(inner_parens);\n        } else {\n          \
    \  break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut acc: Vec<String> = Vec::new();\n    let mut stack: Vec<char>\
    \ = Vec::new();\n    let mut group_start = 0;\n    let mut group_end = 0;\n  \
    \  let mut i = 0;\n    for c in paren_string.chars() {\n        if c == '(' {\n\
    \            if stack.is_empty() {\n                group_start = i;\n       \
    \     }\n            stack.push(c);\n        } else if c == ')' {\n          \
    \  stack.pop();\n            if stack.is_empty() {\n                group_end\
    \ = i;\n                acc.push(paren_string[group_start..=group_end].to_string());\n\
    \            }\n        }\n        i += 1;\n    }\n    acc\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp4evj7dhw.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens = 0;\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            open_parens += 1;\n            current_group.push(ch);\n\
    \        } else if ch == ')' {\n            open_parens -= 1;\n            current_group.push(ch);\n\
    \            if open_parens == 0 {\n                groups.push(current_group);\n\
    \                current_group = String::new();\n            }\n        } else\
    \ if ch != ' ' {\n            current_group.push(ch);\n        }\n    }\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    if paren_string.is_empty() {\n        return vec![];\n    }\n\n    let\
    \ mut groups = vec![];\n    let mut current_group = String::new();\n    let mut\
    \ paren_count = 0;\n\n    for character in paren_string.chars() {\n        match\
    \ character {\n            '(' => {\n                if paren_count == 0 {\n \
    \                   current_group.push(character);\n                }\n      \
    \          paren_count += 1;\n            }\n            ')' => {\n          \
    \      paren_count -= 1;\n                if paren_count == 0 {\n            \
    \        current_group.push(character);\n                    groups.push(current_group);\n\
    \                    current_group = String::new();\n                }\n     \
    \       }\n            ' ' => {\n                continue;\n            }\n  \
    \          _ => {\n                current_group.push(character);\n          \
    \  }\n        }\n    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"()\", \"()\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]`', /tmp/tmpn02y4u__.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    //TODO\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmptqqiexf2.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: implement me!\n    unimplemented!();\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpqxjaqi7n.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut current_group = String::new();\n\
    \    let mut open_count = 0;\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            open_count += 1;\n        } else if c == ')' {\n   \
    \         open_count -= 1;\n        }\n        if open_count == 0 {\n        \
    \    result.push(current_group);\n            current_group = String::new();\n\
    \        } else {\n            current_group.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmplys2z66u.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut current_string = String::new();\n\
    \    let mut list = Vec::new();\n\n    let str_iter = paren_string.chars();\n\
    \    for c in str_iter {\n        if c == '(' {\n            if !current_string.is_empty()\
    \ {\n                stack.push(current_string);\n                current_string\
    \ = String::new();\n            }\n            stack.push(c.to_string());\n  \
    \      } else if c == ')' {\n            if !current_string.is_empty() {\n   \
    \             stack.push(current_string);\n                current_string = String::new();\n\
    \            }\n            let mut group = String::new();\n            let mut\
    \ sub_stack = Vec::new();\n            loop {\n                if stack.is_empty()\
    \ {\n                    return Vec::new();\n                }\n             \
    \   let popped = stack.pop().unwrap();\n                if popped == \"(\" {\n\
    \                    group.push_str(&sub_stack.pop().unwrap());\n            \
    \        break;\n                } else {\n                    sub_stack.push(popped);\n\
    \                }\n            }\n            list.push(group);\n        } else\
    \ if c == ' ' {\n            continue;\n        } else {\n            current_string.push(c);\n\
    \        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpe5v3nd4i.rs:31:53\n   |\n31 |                     group.push_str(&sub_stack.pop().unwrap());\n\
    \   |                                                     ^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpe5v3nd4i.rs:31:47\n   |\n31 |           \
    \          group.push_str(&sub_stack.pop().unwrap());\n   |                  \
    \                             ^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpe5v3nd4i.rs:24:33\n    |\n24  |             let mut sub_stack = Vec::new();\n\
    \    |                                 ^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by `Vec::<T>::new`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmpe5v3nd4i.rs:24:33\n    |\n24  |\
    \             let mut sub_stack = Vec::new();\n    |                         \
    \        ^^^ doesn't have a size known at compile-time\n    |\n    = help: the\
    \ trait `Sized` is not implemented for `str`\nnote: required by a bound in `Vec`\n\
    \nerror[E0599]: the method `push` exists for struct `Vec<str>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpe5v3nd4i.rs:34:31\n   |\n34 |     \
    \                sub_stack.push(popped);\n   |                               ^^^^\
    \ method cannot be called on `Vec<str>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `str: Sized`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    // TODO: Implement.  This is a good one for a regex.\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_54pqsr5.rs:7:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut groups: Vec<String> = Vec::new();\n    let mut current_group:\
    \ String = String::new();\n    let mut open_parens = 0u32;\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            if open_parens == 0 {\n             \
    \   current_group.clear();\n            }\n            open_parens += 1;\n   \
    \         current_group.push(ch);\n        } else if ch == ')' {\n           \
    \ open_parens -= 1;\n            current_group.push(ch);\n            if open_parens\
    \ == 0 {\n                groups.push(current_group.clone());\n            }\n\
    \        } else if open_parens > 0 {\n            current_group.push(ch);\n  \
    \      }\n    }\n    return groups;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpmqu3ry19.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Separate paren groups in the string {:?}\", paren_string);\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate paren groups in
    the string "(()()) ((())) () ((())()())"'', /tmp/tmpg_itbr8a.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut groups = Vec::new();\n    let\
    \ mut substr = String::new();\n    for c in paren_string.chars() {\n        if\
    \ c == '(' {\n            stack.push(c);\n        } else if c == ')' {\n     \
    \       if stack.pop().is_none() {\n                // we have a stray closing\
    \ paren - skip it\n                continue;\n            }\n            if stack.is_empty()\
    \ {\n                groups.push(substr);\n                substr = String::new();\n\
    \            }\n        } else if c == ' ' {\n            continue;\n        }\
    \ else {\n            substr.push(c);\n        }\n    }\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmpku6s2u7z.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut stack = Vec::new();\n    let mut result = Vec::new();\n    let\
    \ mut is_completed = false;\n    let mut current_substring = String::new();\n\n\
    \    for character in paren_string.chars() {\n        // Ignore spaces in the\
    \ input string\n        if character == ' ' {\n            continue;\n       \
    \ }\n\n        // When we see a new character, we add it to the stack.\n     \
    \   // If the new character is an opening parenthesis, we add a \"(\".\n     \
    \   // If the new character is a closing parenthesis, we add a \")\".\n      \
    \  if character == '(' {\n            stack.push('(');\n        } else if character\
    \ == ')' {\n            stack.push(')');\n        } else {\n            panic!(\"\
    Illegal character {}\", character);\n        }\n\n        // If the last two characters\
    \ in the stack are both closing parentheses, we can remove those\n        // from\
    \ the stack and consider this group of parentheses to be complete.\n        if\
    \ stack.len() >= 2 && stack[stack.len() - 1] == ')' && stack[stack.len() - 2]\
    \ == ')' {\n            stack.pop();\n            stack.pop();\n            is_completed\
    \ = true;\n        }\n\n        current_substring.push(character);\n\n       \
    \ // If we have a completed group of parentheses, push that to the result and\
    \ clear\n        // the current substring.\n        if is_completed {\n      \
    \      result.push(current_substring.clone());\n            current_substring.clear();\n\
    \            is_completed = false;\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(()())\", \"((())\", \")()((())\", \"()())\"]`,\n right: `[\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"]`', /tmp/tmpxognyflt.rs:52:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut paren_groups: Vec<String> = Vec::new();\n    let mut paren_buffer:\
    \ String = String::new();\n    let mut paren_count: u32 = 0;\n\n    for ch in\
    \ paren_string.chars() {\n        match ch {\n            '(' => {\n         \
    \       paren_count += 1;\n                paren_buffer.push(ch);\n          \
    \  }\n            ')' => {\n                paren_count -= 1;\n              \
    \  paren_buffer.push(ch);\n            }\n            _ => {\n               \
    \ if paren_count == 0 {\n                    if paren_buffer.len() > 0 {\n   \
    \                     paren_groups.push(paren_buffer.clone());\n             \
    \           paren_buffer.clear();\n                    }\n                } else\
    \ {\n                    paren_buffer.push(ch);\n                }\n         \
    \   }\n        }\n    }\n\n    if paren_buffer.len() > 0 {\n        paren_groups.push(paren_buffer.clone());\n\
    \    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmpvqdgzmze.rs:45:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    if paren_string.len() < 1 {\n        return vec![];\n    }\n\n    let\
    \ mut groups: Vec<String> = vec![];\n    let mut current_group: String = String::new();\n\
    \    let mut current_char_index: usize = 0;\n    let mut current_char: char;\n\
    \    let mut open_braces: i32 = 0;\n\n    // Iterate over input string\n    while\
    \ current_char_index < paren_string.len() {\n        current_char = paren_string.chars().nth(current_char_index).unwrap();\n\
    \n        // If the current character is not a space, we need to process it.\n\
    \        if current_char != ' ' {\n            // If the current character is\
    \ an open brace...\n            if current_char == '(' {\n                // If\
    \ there are no open braces, we need to create a new group and add this character\n\
    \                // to it.\n                if open_braces == 0 {\n          \
    \          groups.push(current_group);\n                    current_group = String::new();\n\
    \                    current_group.push(current_char);\n                }\n  \
    \              // Otherwise, if there are already open braces, just add the character\
    \ to the current\n                // group.\n                else {\n        \
    \            current_group.push(current_char);\n                }\n\n        \
    \        // Increment the number of open braces.\n                open_braces\
    \ += 1;\n            }\n            // If the current character is a closed brace...\n\
    \            else if current_char == ')' {\n                // Decrement the number\
    \ of open braces.\n                open_braces -= 1;\n\n                // If\
    \ the number of open braces is now 0, we need to add the character to the current\n\
    \                // group, pop the last element off the end of the groups list\
    \ and append the current\n                // group to it.\n                if\
    \ open_braces == 0 {\n                    current_group.push(current_char);\n\
    \                    let last_group = groups.pop().unwrap();\n               \
    \     groups.push(format!(\"{}{}\", last_group, current_group));\n           \
    \         current_group = String::new();\n                }\n                //\
    \ Otherwise, just add the character to the current group.\n                else\
    \ {\n                   \n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnlgr50h9.rs:65:3\n\
    \   |\n5  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n17 |     while current_char_index < paren_string.len() {\n \
    \  |                                                   - unclosed delimiter\n\
    ...\n21 |         if current_char != ' ' {\n   |                             \
    \   - unclosed delimiter\n...\n41 |             else if current_char == ')' {\n\
    \   |                                         - unclosed delimiter\n...\n55 |\
    \                 else {\n   |                      - this delimiter might not\
    \ be properly closed...\n56 |                    \n57 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n65 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnlgr50h9.rs:17:5\n   |\n5  |   fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \        ----------- expected `Vec<String>` because of return type\n...\n17 |\
    \ /     while current_char_index < paren_string.len() {\n18 | |         current_char\
    \ = paren_string.chars().nth(current_char_index).unwrap();\n19 | |\n20 | |   \
    \      // If the current character is not a space, we need to process it.\n...\
    \  |\n64 | |     assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n65 | | }\n   | |__^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut group_indexes: Vec<(usize, usize)> = Vec::new();\n    let mut\
    \ paren_count = 0;\n    let mut last_paren_start = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            if paren_count == 0 {\n              \
    \  last_paren_start = i;\n            }\n            paren_count += 1;\n     \
    \   } else if c == ')' {\n            paren_count -= 1;\n            if paren_count\
    \ == 0 {\n                group_indexes.push((last_paren_start, i));\n       \
    \     }\n        }\n    }\n    let mut result: Vec<String> = Vec::new();\n   \
    \ for (start, end) in group_indexes {\n        result.push(paren_string[start..end\
    \ + 1].to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"( )\", \"(( ))\", \"(( )( ))\"]`,\n right: `[\"()\", \"(())\", \"(()())\"\
    ]`', /tmp/tmp_w27b1s_.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut prev_paren = ' ';\n    let mut paren_group = String::new();\n\
    \    let mut groups = Vec::new();\n\n    for c in paren_string.chars() {\n   \
    \     match c {\n            '(' | ')' => {\n                if prev_paren ==\
    \ '(' && c == ')' {\n                    groups.push(paren_group);\n         \
    \           paren_group = String::new();\n                } else if c == '(' {\n\
    \                    paren_group.push(c);\n                }\n               \
    \ prev_paren = c;\n            }\n            _ => {},\n        }\n    }\n\n \
    \   groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"((\", \"(\", \"(((\", \"(\", \"(((\", \"(\", \"(\"]`,\n right: `[\"(()())\"\
    , \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpgn2odbcz.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 0
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut result = Vec::new();\n    let mut curr_str = String::new();\n\
    \    let mut count = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ ' ' {\n            continue;\n        } else if c == '(' {\n            count\
    \ += 1;\n            curr_str.push(c);\n        } else if c == ')' {\n       \
    \     count -= 1;\n            curr_str.push(c);\n            if count == 0 {\n\
    \                result.push(curr_str);\n                curr_str = String::new();\n\
    \            }\n        } else {\n            curr_str.push(c);\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    let mut open_paren_stack: Vec<char> = Vec::new();\n    let mut close_paren_stack:\
    \ Vec<char> = Vec::new();\n    let mut paren_group: Vec<char> = Vec::new();\n\
    \    let mut paren_group_list: Vec<String> = Vec::new();\n\n    let mut i = 0;\n\
    \    while i < paren_string.len() {\n        let c = paren_string.chars().nth(i).unwrap();\n\
    \        match c {\n            ' ' => (),\n            '(' => {\n           \
    \     // open paren found\n                open_paren_stack.push(c);\n       \
    \         paren_group.push(c);\n            }\n            ')' => {\n        \
    \        // close paren found\n                match open_paren_stack.pop() {\n\
    \                    Some(p) => {\n                        close_paren_stack.push(c);\n\
    \                        paren_group.push(c);\n                    }\n       \
    \             None => {\n                        // we were not expecting a close\
    \ paren here\n                        return vec![];\n                    }\n\
    \                }\n            }\n            _ => {\n                return\
    \ vec![];\n            }\n        }\n\n        if open_paren_stack.len() == 0\
    \ && close_paren_stack.len() == 0 {\n            // we have closed out a paren\
    \ group\n            paren_group_list.push(paren_group.iter().collect());\n  \
    \          paren_group = Vec::new();\n        }\n\n        i += 1;\n    }\n\n\
    \    // we ran out of chars in the string\n    if open_paren_stack.len() == 0\
    \ && close_paren_stack.len() == 0 {\n        return paren_group_list;\n    } else\
    \ {\n        return vec![];\n    }\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpspkmql0l.rs:58:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!(\"Separate paren groups: {:?}\", paren_string);\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Separate paren groups: "(()())
    ((())) () ((())()())"'', /tmp/tmpopwobk78.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821380
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the list of those.\n/// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\nfn separate_paren_groups(paren_string: String) -> Vec<String>\
    \ {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_ze8j9ew.rs:6:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821377
