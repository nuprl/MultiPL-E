language: rs
name: HumanEval_115_max_fill
results:
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut operations = 0;\n\
    \    for well in grid {\n        let sum = well.iter().sum();\n        operations\
    \ += sum / capacity;\n        operations += if sum % capacity == 0 { 0 } else\
    \ { 1 };\n    }\n    operations\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpknd6u2yc.rs:19:13\n\
    \   |\n19 |         let sum = well.iter().sum();\n   |             ^^^ consider\
    \ giving `sum` a type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    let\
    \ height = grid.len();\n    let width = grid[0].len();\n    let mut row_count\
    \ = vec![0; height];\n    let mut grid_count = vec![0; height];\n    let mut col_count\
    \ = vec![0; width];\n    let mut grid_sum = vec![0; height];\n    for r in 0..height\
    \ {\n        for c in 0..width {\n            row_count[r] += grid[r][c];\n  \
    \          col_count[c] += grid[r][c];\n            grid_count[r] += grid[r][c];\n\
    \            grid_sum[r] += grid[r][c];\n        }\n    }\n    let mut max_row\
    \ = (0, 0);\n    let mut max_col = (0, 0);\n    for r in 0..height {\n       \
    \ if row_count[r] > max_row.1 {\n            max_row = (r, row_count[r]);\n  \
    \      }\n    }\n    for c in 0..width {\n        if col_count[c] > max_col.1\
    \ {\n            max_col = (c, col_count[c]);\n        }\n    }\n    let mut max_grid\
    \ = (0, 0);\n    for r in 0..height {\n        if grid_count[r] > max_grid.1 {\n\
    \            max_grid = (r, grid_count[r]);\n        }\n    }\n    if max_grid.1\
    \ > max_row.1 && max_grid.1 > max_col.1 {\n        let mut max_grid_col = vec![0;\
    \ width];\n        for c in 0..width {\n            max_grid_col[c] = grid[max_grid.0][c];\n\
    \        }\n        while max_grid_col.iter().sum::<isize>() > 0 {\n         \
    \   let mut max_grid_row = vec![0; height];\n            for r in 0..height {\n\
    \                max_grid_row[r] = grid[r][max_grid_col.iter().position(|x| *x\
    \ == max_grid_col.iter().\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0s661ns3.rs:68:3\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n50 |     if max_grid.1 > max_row.1 && max_grid.1 > max_col.1 {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    55 |         while max_grid_col.iter().sum::<isize>() > 0 {\n   |            \
    \                                          - unclosed delimiter\n56 |        \
    \     let mut max_grid_row = vec![0; height];\n57 |             for r in 0..height\
    \ {\n   |                                - this delimiter might not be properly\
    \ closed...\n58 |                 max_grid_row[r] = grid[r][max_grid_col.iter().position(|x|\
    \ *x == max_grid_col.iter().\n59 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n68 | }\n   |   ^\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp0s661ns3.rs:58:71\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |                                          \
    \                    - closing delimiter possibly meant for this\n...\n58 |  \
    \               max_grid_row[r] = grid[r][max_grid_col.iter().position(|x| *x\
    \ == max_grid_col.iter().\n   |                                              \
    \                         ^ unclosed delimiter\n59 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: unexpected token: `)`\n  --> /tmp/tmp0s661ns3.rs:59:1\n\
    \   |\n59 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0s661ns3.rs:58:82\n\
    \   |\n58 |                 max_grid_row[r] = grid[r][max_grid_col.iter().position(|x|\
    \ *x == max_grid_col.iter().\n   |                                           \
    \                                       ^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `std::slice::Iter`\n   |\n   = note: expected type `isize`\n  \
    \          found struct `std::slice::Iter<'_, isize>`\n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmp0s661ns3.rs:58:35\n\
    \   |\n58 |                 "
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    if\
    \ n == 0 {\n        return 0;\n    }\n    let m = grid[0].len();\n    let mut\
    \ turn = 0;\n    let mut sum = 0;\n    while sum < n * m {\n        let mut empty\
    \ = vec![];\n        for r in 0..n {\n            let mut filled = false;\n  \
    \          for c in 0..m {\n                if grid[r][c] > 0 {\n            \
    \        if !filled {\n                        turn += 1;\n                  \
    \      filled = true;\n                    }\n                    sum += 1;\n\
    \                    grid[r][c] -= 1;\n                }\n            }\n    \
    \        if !filled {\n                empty.push(r);\n            }\n       \
    \ }\n        if empty.len() < m {\n            break;\n        }\n        for\
    \ r in empty {\n            turn += 1;\n            for c in 0..m {\n        \
    \        if grid[r][c] == 0 {\n                    continue;\n               \
    \ }\n                sum += 1;\n                grid[r][c] -= 1;\n           \
    \ }\n        }\n    }\n    turn\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpb49r0j94.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpb49r0j94.rs:35:21\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n35 |                     grid[r][c]\
    \ -= 1;\n   |                     ^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpb49r0j94.rs:52:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n52 |                 grid[r][c] -= 1;\n   |                 ^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    assert!(capacity >= 1);\n\
    \    assert!(grid.len() >= 1);\n    assert!(grid.len() <= 100);\n    for row in\
    \ grid.iter() {\n        assert!(row.len() >= 1);\n        assert!(row.len() <=\
    \ 100);\n        for cell in row.iter() {\n            assert!(*cell == 0 || *cell\
    \ == 1);\n        }\n    }\n    let mut capacity = capacity;\n    let mut min_filled_row\
    \ = grid[0].clone();\n    let mut n_empties = 0;\n    for row in grid.iter() {\n\
    \        let mut filled_row = row.clone();\n        for (i, cell) in row.iter().enumerate()\
    \ {\n            if *cell == 1 {\n                filled_row[i] = std::cmp::min(min_filled_row[i]\
    \ + 1, capacity);\n            }\n        }\n        min_filled_row = filled_row.clone();\n\
    \        let filled_this_row = filled_row.iter().sum::<isize>();\n        let\
    \ filled_prev_row = grid[n_empties].iter().sum::<isize>();\n        capacity =\
    \ capacity - filled_this_row + filled_prev_row;\n        if capacity == 0 {\n\
    \            capacity = filled_prev_row;\n            n_empties += 1;\n      \
    \  }\n    }\n    n_empties\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3vovlder.rs:46:5\n   |\n\
    16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n46 |     n_empties\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n46 |     n_empties.try_into().unwrap()\n\
    \   |              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let row_count = grid.len();\n\
    \    let col_count = grid[0].len();\n    let mut row_nums = vec![0; row_count];\n\
    \    for row in 0..row_count {\n        for col in 0..col_count {\n          \
    \  if grid[row][col] == 1 {\n                row_nums[row] += 1;\n           \
    \ }\n        }\n    }\n    let mut result = 0;\n    for num in row_nums {\n  \
    \      result += (num - 1) / capacity + 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmps70f_93n.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ mut counts = vec![0; n];\n    let mut max_fill = 0;\n    for j in 0..grid[0].len()\
    \ {\n        for i in 0..n {\n            if grid[i][j] == 1 {\n             \
    \   counts[i] += 1;\n                max_fill = std::cmp::max(max_fill, counts[i]);\n\
    \            } else {\n                counts[i] = 0;\n            }\n       \
    \ }\n    }\n    let bucket_trips = max_fill / capacity;\n    let extras = max_fill\
    \ % capacity;\n    bucket_trips + if extras > 0 { 1 } else { 0 }\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp7vxiwk0z.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::cmp::min;\n    let\
    \ mut result = 0;\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    for row in 0..rows {\n        for col in 0..cols {\n            let mut water\
    \ = grid[row][col];\n            if water == 0 {\n                continue;\n\
    \            }\n            result += 1;\n            grid[row][col] = 0;\n  \
    \          water -= capacity;\n            while water > 0 {\n               \
    \ let mut curr_row = row;\n                let mut curr_col = col;\n         \
    \       if curr_row < rows - 1 {\n                    curr_row += 1;\n       \
    \         } else if curr_col < cols - 1 {\n                    curr_col += 1;\n\
    \                } else {\n                    break;\n                }\n   \
    \             let cap = min(water, capacity - grid[curr_row][curr_col]);\n   \
    \             grid[curr_row][curr_col] += cap;\n                water -= cap;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpixfcyal8.rs:28:13\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n28 |             grid[row][col] = 0;\n   | \
    \            ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmpixfcyal8.rs:41:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n41 |                 grid[curr_row][curr_col] += cap;\n   |             \
    \    ^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let (height, width) = (grid.len(),\
    \ grid[0].len());\n    let mut grid = grid;\n    let mut num_of_lowers = 0;\n\
    \    let mut left = 0;\n    let mut right = width - 1;\n    while left < right\
    \ {\n        let mut current_left = capacity;\n        let mut current_right =\
    \ capacity;\n        for i in 0..height {\n            if grid[i][left] > 0 {\n\
    \                current_left -= 1;\n                grid[i][left] -= 1;\n   \
    \         }\n            if grid[i][right] > 0 {\n                current_right\
    \ -= 1;\n                grid[i][right] -= 1;\n            }\n        }\n    \
    \    if current_left > 0 {\n            left += 1;\n        }\n        if current_right\
    \ > 0 {\n            right -= 1;\n        }\n        num_of_lowers += 1;\n   \
    \ }\n    num_of_lowers\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpk2flonyg.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut last_row = vec![0;\
    \ grid[0].len()];\n    for row in grid.iter() {\n        for (i, &val) in row.iter().enumerate()\
    \ {\n            if val == 1 {\n                last_row[i] = capacity;\n    \
    \        }\n        }\n        for (i, val) in last_row.iter_mut().enumerate()\
    \ {\n            if *val > 0 {\n                if i > 0 {\n                 \
    \   *val = val.saturating_sub(1);\n                }\n                if i + 1\
    \ < last_row.len() {\n                    *val = val.saturating_sub(1);\n    \
    \            }\n            }\n        }\n    }\n    let mut result = 0;\n   \
    \ for val in last_row.iter() {\n        result += val;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `last_row` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmpxwwlp8bv.rs:29:28\n   |\n24 |         for\
    \ (i, val) in last_row.iter_mut().enumerate() {\n   |                        \
    \ -------------------------------\n   |                         |\n   |      \
    \                   mutable borrow occurs here\n   |                         mutable\
    \ borrow later used here\n...\n29 |                 if i + 1 < last_row.len()\
    \ {\n   |                            ^^^^^^^^^^^^^^ immutable borrow occurs here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let num_rows = grid.len();\n\
    \    let num_cols = grid[0].len();\n    let mut all_full = false;\n    let mut\
    \ count = 0;\n    while !all_full {\n        all_full = true;\n        for row\
    \ in 0..num_rows {\n            for col in 0..num_cols {\n                if grid[row][col]\
    \ < capacity {\n                    all_full = false;\n                    grid[row][col]\
    \ = capacity;\n                }\n            }\n        }\n        count += 1;\n\
    \    }\n    count - 1\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp6c9h6wsg.rs:27:21\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n27 |                     grid[row][col] = capacity;\n\
    \   |                     ^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    0\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpgx6unsz_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut wells = grid;\n    while !wells.iter().all(|w| w.iter().all(|&x| x == 0))\
    \ {\n        for well in &mut wells {\n            fill_well(well, capacity);\n\
    \        }\n        fill += 1;\n    }\n    fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `fill_well` in this scope\n  --> /tmp/tmp1u9hgeo4.rs:21:13\n\
    \   |\n21 |             fill_well(well, capacity);\n   |             ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let rows = grid.len();\n \
    \   let cols = grid[0].len();\n    let mut empty = vec![vec![0; cols]; rows];\n\
    \    let mut surplus = vec![0; rows];\n    let mut res = 0;\n    while !surplus.iter().all(|s|\
    \ *s == 0) {\n        for row in 0..rows {\n            for col in 0..cols {\n\
    \                if grid[row][col] > empty[row][col] {\n                    if\
    \ surplus[row] >= capacity {\n                        empty[row][col] += 1;\n\
    \                        surplus[row] -= 1;\n                    } else {\n  \
    \                      empty[row][col] += surplus[row];\n                    \
    \    surplus[row] = 0;\n                    }\n                }\n           \
    \ }\n        }\n        for row in 0..rows {\n            for col in 0..cols {\n\
    \                if grid[row][col] > empty[row][col] {\n                    surplus[row]\
    \ += grid[row][col] - empty[row][col];\n                    empty[row][col] =\
    \ grid[row][col];\n                }\n            }\n        }\n        res +=\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmplf038ji1.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut max_height = 0;\n    for i in 0..n {\n     \
    \   for j in 0..m {\n            max_height = max_height.max(grid[i][j]);\n  \
    \      }\n    }\n    let mut low = 0;\n    let mut high = max_height;\n    let\
    \ mut result = 0;\n    while low <= high {\n        let mid = low + (high - low)\
    \ / 2;\n        if can_fill(grid.clone(), mid, capacity) {\n            result\
    \ = mid;\n            low = mid + 1;\n        } else {\n            high = mid\
    \ - 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `can_fill` in this scope\n  --> /tmp/tmpr3q457lv.rs:30:12\n\
    \   |\n30 |         if can_fill(grid.clone(), mid, capacity) {\n   |         \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut buckets = HashMap::<usize,\
    \ isize>::new();\n    let mut result = 0;\n    for row in grid {\n        let\
    \ mut bucket_num = 0;\n        for cell in row {\n            if cell == 1 {\n\
    \                if let Some(value) = buckets.get_mut(&bucket_num) {\n       \
    \             *value += cell;\n                } else {\n                    buckets.insert(bucket_num,\
    \ cell);\n                }\n                if buckets[&bucket_num] > capacity\
    \ {\n                    buckets.insert(bucket_num, capacity);\n             \
    \   }\n            }\n            bucket_num += 1;\n        }\n        buckets.retain(|_,\
    \ v| *v > 0);\n        result += 1;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7v3i9uag.rs:17:23\n   |\n17 |     let mut buckets = HashMap::<usize,\
    \ isize>::new();\n   |                       ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // TODO\n    0\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpz46mv47r.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut count = 0;\n    let len = grid[0].len();\n    while grid.iter().any(|r|\
    \ r.iter().any(|&x| x > 0)) {\n        let mut lowest = std::isize::MAX;\n   \
    \     for row in grid.iter_mut() {\n            let above = std::cmp::min(len\
    \ as isize, row.iter().sum());\n            if above < lowest {\n            \
    \    lowest = above;\n            }\n        }\n        for row in grid.iter_mut()\
    \ {\n            for cell in row.iter_mut() {\n                *cell -= lowest;\n\
    \            }\n        }\n        count += lowest / capacity;\n        if lowest\
    \ % capacity > 0 {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpdsepnyqg.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut ans = 0;\n    let mut water = 0;\n    for i\
    \ in 0..n {\n        let mut row = 0;\n        for j in 0..m {\n            row\
    \ += grid[i][j];\n        }\n        if water + row > capacity {\n           \
    \ ans += water + row - capacity;\n            water = capacity - row;\n      \
    \  } else {\n            water += row;\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpzjwofke8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut row_max = vec![0;\
    \ grid.len()];\n    for r in 0..grid.len() {\n        for c in 0..grid[r].len()\
    \ {\n            row_max[r] = row_max[r].max(grid[r][c]);\n        }\n    }\n\
    \    let mut drops = 0;\n    let mut max_height = row_max[0];\n    for r in 0..grid.len()\
    \ {\n        drops += (max_height - row_max[r]).max(0);\n        max_height =\
    \ max_height.max(row_max[r]);\n    }\n    drops + (max_height - 1) / capacity\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmporph63c7.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    assert!(!grid.is_empty());\n\
    \    assert!(!grid[0].is_empty());\n    let row_count = grid.len();\n    let col_count\
    \ = grid[0].len();\n    let mut cnt = 0;\n    let mut filled = 0;\n    loop {\n\
    \        filled = 0;\n        for i in 0..row_count {\n            let col_start\
    \ = grid[i].iter().position(|x| *x > 0).unwrap();\n            let max_col = col_start\
    \ + capacity as usize;\n            let max_iter = grid[i].iter().skip(col_start).take_while(|x|\
    \ **x > 0).count();\n            let max_fill = std::cmp::min(max_col, col_start\
    \ + max_iter);\n            for j in col_start..max_fill {\n                filled\
    \ += 1;\n                grid[i][j] -= 1;\n            }\n        }\n        if\
    \ filled == 0 {\n            break;\n        }\n        cnt += 1;\n    }\n   \
    \ cnt\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `col_count`\n  --> /tmp/tmpv93lg6lt.rs:20:9\n\
    \   |\n20 |     let col_count = grid[0].len();\n   |         ^^^^^^^^^ help: if\
    \ this is intentional, prefix it with an underscore: `_col_count`\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n\nwarning: value assigned to\
    \ `filled` is never read\n  --> /tmp/tmpv93lg6lt.rs:22:13\n   |\n22 |     let\
    \ mut filled = 0;\n   |             ^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0596]:\
    \ cannot borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpv93lg6lt.rs:32:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n32 |                 grid[i][j] -= 1;\n   |                 ^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error; 2 warnings emitted\n\n\
    For more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        let min_drops = row.iter().fold(0, |memo, &x| {\n   \
    \         memo + (x + capacity - 1) / capacity\n        });\n        result =\
    \ std::cmp::max(result, min_drops);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmp4q7vcjob.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut sum = 0;\n    for\
    \ row in grid {\n        let mut filled = 0;\n        for &i in row {\n      \
    \      if i == 1 {\n                filled += 1;\n            } else {\n     \
    \           sum += filled / capacity;\n                filled = 0;\n         \
    \   }\n        }\n        sum += filled / capacity;\n    }\n    sum\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_35oytrb.rs:20:13\n   |\n\
    20 |         for &i in row {\n   |             ^^    --- this expression has type\
    \ `Option<isize>`\n   |             |\n   |             expected `isize`, found\
    \ reference\n   |             help: you can probably remove the explicit borrow:\
    \ `i`\n   |\n   = note:   expected type `isize`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut res = 0;\n    for i in 0..n {\n        let mut\
    \ fill = 0;\n        for j in 0..m {\n            if grid[i][j] == 1 {\n     \
    \           fill += 1;\n            }\n        }\n        if fill > 0 {\n    \
    \        res += (fill + capacity - 1) / capacity;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut row_full = 0;\n    let mut result = 0;\n   \
    \ while row_full < n {\n        let mut refill = false;\n        for i in 0..m\
    \ {\n            let water = grid[row_full][i];\n            if water == 1 {\n\
    \                if capacity > 1 {\n                    refill = true;\n     \
    \               result += 1;\n                    grid[row_full][i] = capacity;\n\
    \                }\n            } else if water > 1 {\n                result\
    \ += 1;\n                if water < capacity {\n                    refill = true;\n\
    \                    grid[row_full][i] = capacity;\n                } else {\n\
    \                    grid[row_full][i] -= 1;\n                }\n            }\n\
    \        }\n        if !refill {\n            row_full += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmphu_fovd5.rs:29:21\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n29 |                     grid[row_full][i] =\
    \ capacity;\n   |                     ^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmphu_fovd5.rs:35:21\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n35 |                     grid[row_full][i] = capacity;\n   |            \
    \         ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmphu_fovd5.rs:37:21\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n37 |                     grid[row_full][i] -= 1;\n   |                  \
    \   ^^^^ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    grid.iter().map(|x| match\
    \ x.iter().sum::<isize>() % capacity {\n        0 => x.len() as isize - 1,\n \
    \       _ => x.len() as isize,\n    }).sum()\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `6`', /tmp/tmpttwvkezu.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let max_height = find_max_height(&grid);\n\
    \    let mut result = 0;\n    let mut current_height = 0;\n    for height in 1..=max_height\
    \ {\n        for row in grid.iter() {\n            let current_row_fill = row.iter().filter(|x|\
    \ **x >= height).count();\n            if current_row_fill > 0 {\n           \
    \     if current_height == 0 {\n                    result += 1;\n           \
    \         current_height = capacity;\n                }\n                current_height\
    \ -= current_row_fill as isize;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_height` in this scope\n  -->\
    \ /tmp/tmps0h_tcy7.rs:17:22\n   |\n17 |     let max_height = find_max_height(&grid);\n\
    \   |                      ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // use a stack to track the\
    \ filled levels\n    let mut stack = Vec::new();\n    let mut filled = 0;\n  \
    \  for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n           \
    \ if grid[i][j] == 1 {\n                filled += 1;\n                // find\
    \ the first index of the lowest level cell filled below\n                let lowest\
    \ = (0..i).find(|&k| grid[k][j] == 1);\n                if let Some(x) = lowest\
    \ {\n                    // add the cell to the stack\n                    stack.push((x,\
    \ j));\n                }\n            }\n        }\n    }\n    // the number\
    \ of buckets to use = the number of filled cells / the capacity\n    filled /\
    \ capacity + {\n        // the number of moves is the number of filled cells that\
    \ need to be moved\n        // to the level of the lowest filled cell in the same\
    \ column\n        stack.iter().fold(0, |acc, &(i, j)| {\n            acc + grid[i..].iter().fold(0,\
    \ |acc, row| acc + row[j])\n        })\n    }\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `6`', /tmp/tmpjhcddlh5.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut rows = grid.len();\n\
    \    let mut cols = grid[0].len();\n    let mut grid = grid;\n    let mut count\
    \ = 0;\n    while rows > 0 {\n        let mut col = 0;\n        while col < cols\
    \ {\n            if grid[rows - 1][col] == 1 {\n                let mut col_plus\
    \ = col;\n                while col_plus < cols && grid[rows - 1][col_plus] ==\
    \ 1 {\n                    grid[rows - 1][col_plus] = 0;\n                   \
    \ col_plus += 1;\n                }\n                let mut row_plus = rows -\
    \ 2;\n                while row_plus >= 0 && (col_plus - col) > 0 {\n        \
    \            for i in col..col_plus {\n                        if grid[row_plus][i]\
    \ == 1 {\n                            grid[row_plus][i] = 0;\n               \
    \         }\n                    }\n                    row_plus -= 1;\n     \
    \           }\n                count += 1;\n            }\n            col +=\
    \ 1;\n        }\n        rows -= 1;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpuiem4lfw.rs:37:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut c = 0;\n    for i\
    \ in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                c += 1;\n            }\n        }\n    }\n    let mut\
    \ lowers = 0;\n    while c > 0 {\n        lowers += 1;\n        let mut added\
    \ = 0;\n        for i in 0..grid.len() {\n            for j in 0..grid[i].len()\
    \ {\n                if grid[i][j] == 1 {\n                    grid[i][j] = 0;\n\
    \                    c -= 1;\n                    added += 1;\n              \
    \      if added == capacity {\n                        break;\n              \
    \      }\n                }\n            }\n            if added == capacity {\n\
    \                break;\n            }\n        }\n    }\n    lowers\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp5paw6j2y.rs:32:21\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n32 |                     grid[i][j] = 0;\n \
    \  |                     ^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let rows = grid.len();\n \
    \   let cols = grid[0].len();\n    let mut total = 0;\n    let mut max_row = 0;\n\
    \    for row in grid {\n        for &col in row.iter() {\n            if col ==\
    \ 1 {\n                total += 1;\n            }\n        }\n        max_row\
    \ = total.max(max_row);\n        total = 0;\n    }\n    let mut bucket = capacity;\n\
    \    let mut count = 0;\n    for _ in 0..rows {\n        for _ in 0..cols {\n\
    \            if bucket == 0 {\n                bucket = capacity;\n          \
    \      count += 1;\n            }\n            bucket -= 1;\n        }\n    }\n\
    \    (count/rows as isize).max(max_row)\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpstbe8_jw.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fills = 0;\n    let\
    \ width = grid[0].len();\n    let mut wells = grid.iter().map(|row| row.iter().fold(0,\
    \ |a, &b| a + b)).collect::<Vec<isize>>();\n    for _ in 0..width {\n        let\
    \ max_well = wells.iter().max().unwrap();\n        wells = wells.iter().map(|x|\
    \ x - max_well / capacity).collect::<Vec<isize>>();\n        fills += max_well\
    \ / capacity;\n    }\n    fills\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0506]: cannot assign to `wells` because it is borrowed\n    -->\
    \ /tmp/tmp_7uszr_q.rs:22:9\n     |\n21   |         let max_well = wells.iter().max().unwrap();\n\
    \     |                        ------------ borrow of `wells` occurs here\n22\
    \   |         wells = wells.iter().map(|x| x - max_well / capacity).collect::<Vec<isize>>();\n\
    \     |         ^^^^^ assignment to borrowed `wells` occurs here\n23   |     \
    \    fills += max_well / capacity;\n     |                  -------- borrow later\
    \ used here\n     |\n     = note: borrow occurs due to deref coercion to `[isize]`\n\
    note: deref defined here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0506`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // for each row, find the\
    \ longest continuous subrange of 1s (inclusive), \n    // starting from the left\n\
    \    let mut max_ranges = vec![];\n    for row in grid {\n        let mut count\
    \ = 0;\n        let mut ranges = vec![];\n        for &cell in row.iter() {\n\
    \            if cell == 1 {\n                count += 1;\n            } else {\n\
    \                ranges.push(count);\n                count = 0;\n           \
    \ }\n        }\n        ranges.push(count);\n        max_ranges.push(ranges);\n\
    \    }\n    // for each index, find the longest subrange starting from there (inclusive)\n\
    \    let mut max_lengths = vec![];\n    for range in max_ranges {\n        let\
    \ mut max_length = 0;\n        for &length in range.iter() {\n            if length\
    \ > max_length {\n                max_length = length;\n            }\n      \
    \  }\n        max_lengths.push(max_length);\n    }\n    // a row takes one \"\
    turn\" to fill if the longest subrange starting from the left is less than capacity\n\
    \    // otherwise it takes ceil(longest/capacity) turns\n    max_lengths.iter().map(|l|\
    \ (l + capacity - 1) / capacity).sum()\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ num_rows = grid.len();\n    let num_cols = grid[0].len();\n    let mut wells\
    \ = grid;\n    // wells = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    //          [1,\
    \ 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    //          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n\
    \    //          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    //          [1, 1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1],\n    //          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    //\
    \          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    //          [1, 1, 1, 1, 1, 1,\
    \ 1, 1, 1, 1],\n    //          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    //      \
    \    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\n    while let Some(top_row) = wells.iter().find(|r|\
    \ r.iter().any(|&w| w > 0)) {\n        // top_row = [1, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1]\n        //* top_row.iter().find(|&&w| w > 0) = Some(&1)\n        result\
    \ += 1;\n        let mut bucket = capacity;\n        for (r, row) in wells.iter_mut().enumerate()\
    \ {\n            // r = 0\n            // row = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n\
    \            if r == num_rows {\n                break;\n            }\n     \
    \       if row.iter().all(|&w| w == 0) {\n                break;\n           \
    \ }\n            for (c, well) in row.iter_mut().enumerate() {\n             \
    \   // c =\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3cs40gnk.rs:56:3\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n31 |     while let Some(top_row) = wells.iter().find(|r| r.iter().any(|&w|\
    \ w > 0)) {\n   |                                                            \
    \                   - unclosed delimiter\n...\n36 |         for (r, row) in wells.iter_mut().enumerate()\
    \ {\n   |                                                      - unclosed delimiter\n\
    ...\n45 |             for (c, well) in row.iter_mut().enumerate() {\n   |    \
    \                                                     - this delimiter might not\
    \ be properly closed...\n46 |                 // c =\n47 | }\n   | - ...as it\
    \ matches this but it has different indentation\n...\n56 | }\n   |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3cs40gnk.rs:31:5\n   |\n16 |   fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                                 ----- expected `isize` because of return type\n\
    ...\n31 | /     while let Some(top_row) = wells.iter().find(|r| r.iter().any(|&w|\
    \ w > 0)) {\n32 | |         // top_row = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n33 |\
    \ |         //* top_row.iter().find(|&&w| w > 0) = Some(&1)\n34 | |         result\
    \ += 1;\n...  |\n55 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1,\
    \ 1, 1, 1]], 9), 2);\n56 | | }\n   | |__^ expected `isize`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut sum = 0;\n    for\
    \ row in grid {\n        let count = row.iter().sum::<isize>();\n        sum +=\
    \ count / capacity;\n        if count % capacity != 0 {\n            sum += 1;\n\
    \        }\n    }\n    sum\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    let\
    \ columns = grid[0].len();\n    let target = grid.iter().map(|r| r.iter().sum::<isize>()).sum::<isize>();\n\
    \    while target > 0 {\n        let col = (0..columns).filter(|&c| !grid.iter().all(|r|\
    \ r[c] == 0)).nth(0).unwrap();\n        res += 1;\n        for row in &mut grid\
    \ {\n            if row[col] > 0 {\n                row[col] -= 1;\n         \
    \       target -= 1;\n            }\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpxjvtwt8e.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpxjvtwt8e.rs:23:20\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n23 |         for row in &mut grid\
    \ {\n   |                    ^^^^^^^^^ cannot borrow as mutable\n\nerror[E0384]:\
    \ cannot assign twice to immutable variable `target`\n  --> /tmp/tmpxjvtwt8e.rs:26:17\n\
    \   |\n19 |     let target = grid.iter().map(|r| r.iter().sum::<isize>()).sum::<isize>();\n\
    \   |         ------\n   |         |\n   |         first assignment to `target`\n\
    \   |         help: consider making this binding mutable: `mut target`\n...\n\
    26 |                 target -= 1;\n   |                 ^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0384, E0596.\nFor more information\
    \ about an error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() {\n   \
    \     return 0;\n    }\n    let height = grid.len();\n    let width = grid[0].len();\n\
    \    let mut next_fill = grid.clone();\n    let mut count = 0;\n    while next_fill\
    \ != grid {\n        let mut fill = vec![vec![0; width]; height];\n        let\
    \ mut overflow = vec![vec![0; width]; height];\n        for y in 0..height {\n\
    \            for x in 0..width {\n                let water = next_fill[y][x];\n\
    \                let start = y * width + x;\n                let neighbors = vec![\n\
    \                    (start - 1, Direction::LEFT),\n                    (start\
    \ + 1, Direction::RIGHT),\n                    (start - width, Direction::UP),\n\
    \                    (start + width, Direction::DOWN),\n                ];\n \
    \               for (neighbor, dir) in neighbors {\n                    if neighbor\
    \ < 0 || neighbor >= height * width {\n                        continue;\n   \
    \                 }\n                    let (ny, nx) = (neighbor / width, neighbor\
    \ % width);\n                    let neighbor_water = next_fill[ny][nx];\n   \
    \                 if neighbor_water == capacity {\n                        continue;\n\
    \                    }\n                    if water + neighbor_water > capacity\
    \ {\n                        overflow[y][x] += capacity - neighbor_water;\n  \
    \                      overflow[ny][nx] += water - overflow[y][x];\n         \
    \               fill[ny][nx] = capacity;\n                    } else {\n     \
    \                   fill[ny][nx] = water + neighbor_water;\n                 \
    \   }\n                }\n            }\n        }\n        let mut max_fill =\
    \ 0;\n        for y in 0..height {\n            for x in 0..width {\n        \
    \        max_fill = std::cmp::max(max_fill, fill[y][x]);\n            }\n    \
    \    }\n        if max_fill == 0 {\n            break;\n        }\n        count\
    \ += 1;\n        for y in 0..height {\n            for x in 0..width {\n     \
    \           if fill[y][x] == max_fill {\n                    fill[y][x] = 0;\n\
    \                }\n            }\n        }\n        next_fill\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc43dnkmh.rs:83:3\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n24 |     while next_fill != grid {\n   |                             - this\
    \ delimiter might not be properly closed...\n...\n74 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n83 | }\n   |   ^\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpc43dnkmh.rs:32:33\n\
    \   |\n32 |                     (start - 1, Direction::LEFT),\n   |          \
    \                       ^^^^^^^^^ use of undeclared type `Direction`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpc43dnkmh.rs:33:33\n\
    \   |\n33 |                     (start + 1, Direction::RIGHT),\n   |         \
    \                        ^^^^^^^^^ use of undeclared type `Direction`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpc43dnkmh.rs:34:37\n\
    \   |\n34 |                     (start - width, Direction::UP),\n   |        \
    \                             ^^^^^^^^^ use of undeclared type `Direction`\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Direction`\n  --> /tmp/tmpc43dnkmh.rs:35:37\n\
    \   |\n35 |                     (start + width, Direction::DOWN),\n   |      \
    \                               ^^^^^^^^^ use of undeclared type `Direction`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc43dnkmh.rs:73:9\n   |\n24 | /\
    \     while next_fill != grid {\n25 | |         let mut fill = vec![vec![0; width];\
    \ height];\n26 | |         let mut overflow = vec![vec![0; width]; height];\n\
    27 | |         for y in 0..height {\n...  |\n73 | |         next_fill\n   | |\
    \         ^^^^^^^^^ expected `()`, found struct `Vec`\n74 | | }\n   | |_- expected\
    \ this to be `()`\n   |\n   = note: expected unit type `()`\n                \
    \ found struct `Vec<Vec<isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc43dnkmh.rs:16:56\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: is"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ heights = grid.iter().map(|row| {\n        let mut row_sum = 0;\n        for\
    \ i in 0..row.len() {\n            row_sum += row[i];\n        }\n        row_sum\n\
    \    }).collect::<Vec<isize>>();\n    for h in heights {\n        if h > capacity\
    \ {\n            count += h / capacity;\n            if h % capacity != 0 {\n\
    \                count += 1;\n            }\n        } else {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpbm8lbeer.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let wells_number = grid.len();\n\
    \    if wells_number == 0 {\n        return 0;\n    }\n    let row_len = grid[0].len();\n\
    \    if row_len == 0 {\n        return 0;\n    }\n    let mut max_height = std::i32::MIN;\n\
    \    for row in grid {\n        let mut max_local = std::i32::MIN;\n        for\
    \ cell in row {\n            if cell > 0 {\n                max_local = max_local.max(cell\
    \ as i32);\n            }\n        }\n        max_height = max_height.max(max_local);\n\
    \    }\n    let mut max_vol = std::i32::MIN;\n    for row in grid {\n        let\
    \ mut row_vol = 0;\n        for cell in row {\n            if cell > 0 {\n   \
    \             row_vol += capacity as i32;\n            }\n        }\n        max_vol\
    \ = max_vol.max(row_vol);\n    }\n    max_height.max(max_vol) as isize\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `grid`\n   --> /tmp/tmpj7sepv4d.rs:36:16\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n26  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n36  |     for row in grid {\n    |                ^^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `grid`\nhelp: consider iterating over a slice of the `Vec<Vec<isize>>`'s\
    \ content to avoid moving into the `for` loop\n    |\n26  |     for row in &grid\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    0\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpgx6unsz_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total_steps = 0;\n\
    \    for row in grid {\n        let mut current_level = 0;\n        for &tile\
    \ in row.iter() {\n            current_level += tile;\n            if current_level\
    \ == capacity {\n                total_steps += 1;\n                current_level\
    \ = 0;\n            }\n        }\n        if current_level > 0 {\n           \
    \ total_steps += 1;\n        }\n    }\n    total_steps\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.len() == 0 {\n   \
    \     return 0;\n    }\n    let (rows, cols) = (grid.len(), grid[0].len());\n\
    \    let mut counts = vec![0; cols];\n    let mut total = 0;\n    for c in 0..cols\
    \ {\n        for r in 0..rows {\n            if grid[r][c] == 1 {\n          \
    \      counts[c] += 1;\n                total += 1;\n            }\n        }\n\
    \    }\n    let mut fill = 0;\n    let mut count = 0;\n    while count < total\
    \ {\n        let mut max = 0;\n        let mut m = 0;\n        for i in 0..cols\
    \ {\n            if counts[i] > max {\n                max = counts[i];\n    \
    \            m = i;\n            }\n        }\n        if max == 0 {\n       \
    \     break;\n        }\n        for r in 0..rows {\n            if grid[r][m]\
    \ == 1 {\n                grid[r][m] = 0;\n                counts[m] -= 1;\n \
    \               count += 1;\n            }\n        }\n        fill += 1;\n  \
    \  }\n    fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmp7z1u8r_i.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp7z1u8r_i.rs:47:17\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n47 |                 grid[r][m]\
    \ = 0;\n   |                 ^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: -1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // number of times you need\
    \ to lower the buckets\n    let mut times = 0;\n    // how much water each well\
    \ has\n    let mut water = vec![0; grid.len()];\n    // number of wells still\
    \ not empty\n    let mut remaining = grid.len();\n    while remaining > 0 {\n\
    \        let mut i = 0;\n        while i < grid.len() {\n            if water[i]\
    \ < grid[i].len() as isize {\n                water[i] += 1;\n               \
    \ if water[i] == grid[i].len() as isize {\n                    remaining -= 1;\n\
    \                }\n            }\n            i += 1;\n        }\n        times\
    \ += 1;\n        let mut i = 0;\n        while i < grid.len() {\n            if\
    \ water[i] > capacity {\n                water[i] -= capacity;\n            }\
    \ else {\n                water[i] = 0;\n            }\n            i += 1;\n\
    \        }\n    }\n    times\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977631
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut level = 0;\n    let mut index = vec![0; grid.len()];\n    while let Some(row)\
    \ = grid.iter().enumerate().find(|(_, row)| {\n        row.iter().enumerate().any(|(j,\
    \ &v)| j > index[row.len() - 1] && v == 1)\n    }) {\n        level += 1;\n  \
    \      result += 1;\n        for &v in &row.1[index[row.0]..] {\n            if\
    \ v == 1 {\n                index[row.0] += 1;\n            } else {\n       \
    \         break;\n            }\n        }\n    }\n    if level < capacity {\n\
    \        result += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmplhrwdmgj.rs:21:50

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // TODO https://www.hackerrank.com/challenges/maximum-filling/problem\n\
    \    unimplemented!();\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp5acnzly1.rs:18:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::cmp::min;\n    let\
    \ mut grid = grid;\n    let mut n_fill = 0;\n    for well in grid.iter_mut() {\n\
    \        let mut well_full = capacity;\n        for water in well.iter_mut() {\n\
    \            let to_fill = min(well_full, *water);\n            *water -= to_fill;\n\
    \            well_full -= to_fill;\n        }\n        if well_full > 0 {\n  \
    \          n_fill += 1;\n        }\n    }\n    n_fill\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpcvyvmdod.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut wells = Vec::new();\n    let mut heights = Vec::new();\n    for row in grid\
    \ {\n        let mut row_height = 0;\n        let mut row_sum = 0;\n        for\
    \ val in row {\n            row_sum += val;\n            row_height = std::cmp::max(row_height,\
    \ val);\n        }\n        heights.push(row_height);\n        wells.push(row_sum);\n\
    \    }\n    for row in wells {\n        result += row / capacity;\n        if\
    \ row % capacity != 0 {\n            result += 1;\n        }\n    }\n    let mut\
    \ row_num = grid.len();\n    let mut additional_fills = 0;\n    for i in 0..row_num\
    \ {\n        let fill_amount = heights[i] * capacity;\n        for j in 0..row_num\
    \ {\n            if wells[j] < fill_amount {\n                additional_fills\
    \ += 1;\n            }\n        }\n    }\n    result + additional_fills\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpvzuko6rs.rs:36:9\n\
    \   |\n36 |     let mut row_num = grid.len();\n   |         ----^^^^^^^\n   |\
    \         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpvzuko6rs.rs:36:23\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n36  |     let mut row_num = grid.len();\n    |                       ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `grid`\nhelp: consider iterating over a slice\
    \ of the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n   \
    \ |\n20  |     for row in &grid {\n    |                +\n\nerror[E0382]: borrow\
    \ of moved value: `wells`\n  --> /tmp/tmpvzuko6rs.rs:41:16\n   |\n18 |     let\
    \ mut wells = Vec::new();\n   |         --------- move occurs because `wells`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n30 |\
    \     for row in wells {\n   |                ----- `wells` moved due to this\
    \ implicit call to `.into_iter()`\n...\n41 |             if wells[j] < fill_amount\
    \ {\n   |                ^^^^^ value borrowed here after move\n   |\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n   |\n30 |     for row in &wells {\n   |                +\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let wells = grid.len();\n\
    \    if wells == 0 {\n        return 0;\n    }\n    let buckets = grid[0].len();\n\
    \    let mut depth = 0;\n    let mut filled = 0;\n    let mut num_fillings = 0;\n\
    \    while filled < wells * buckets {\n        let mut filled_now = 0;\n     \
    \   for well in grid.iter() {\n            let height = well[depth % buckets];\n\
    \            filled_now += if height == 0 { 0 } else { height - 1 };\n       \
    \ }\n        let fill_depth = if filled_now + filled < capacity { filled_now }\
    \ else { capacity - filled };\n        filled += fill_depth;\n        num_fillings\
    \ += 1;\n        depth += 1;\n    }\n    num_fillings\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvqg4efqj.rs:31:42\n   |\n\
    31 |         let fill_depth = if filled_now + filled < capacity { filled_now }\
    \ else { capacity - filled };\n   |                                          ^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot add `usize` to `isize`\n\
    \  --> /tmp/tmpvqg4efqj.rs:31:40\n   |\n31 |         let fill_depth = if filled_now\
    \ + filled < capacity { filled_now } else { capacity - filled };\n   |       \
    \                                 ^ no implementation for `isize + usize`\n  \
    \ |\n   = help: the trait `Add<usize>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvqg4efqj.rs:31:93\n   |\n31 |         let fill_depth =\
    \ if filled_now + filled < capacity { filled_now } else { capacity - filled };\n\
    \   |                                                                        \
    \                     ^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract `usize` from `isize`\n  --> /tmp/tmpvqg4efqj.rs:31:91\n   |\n\
    31 |         let fill_depth = if filled_now + filled < capacity { filled_now }\
    \ else { capacity - filled };\n   |                                          \
    \                                                 ^ no implementation for `isize\
    \ - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n         "
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    grid.iter().fold(0, |acc,\
    \ row| {\n        let diff = row.iter().sum::<isize>() - capacity;\n        acc\
    \ + if diff > 0 { diff } else { 0 }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpyqkjr_ed.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // guard\n    if grid.is_empty()\
    \ {\n        return 0;\n    }\n    let mut max_fill = 0;\n    let mut current_fill\
    \ = 0;\n    for row in grid {\n        for well in row {\n            current_fill\
    \ += well;\n            if current_fill > capacity {\n                max_fill\
    \ += 1;\n                current_fill = 0;\n            }\n        }\n       \
    \ current_fill = 0;\n    }\n    max_fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmp50qz81lz.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ wells = grid.iter().map(|r| r.iter().sum::<isize>()).collect::<Vec<isize>>();\n\
    \    let mut min_water = wells.iter().min().unwrap();\n    while *min_water >\
    \ 0 {\n        *min_water -= capacity;\n        count += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpb7194j9o.rs:19:9\n\
    \   |\n19 |     let mut min_water = wells.iter().min().unwrap();\n   |       \
    \  ----^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n\
    \   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0594]: cannot assign\
    \ to `*min_water`, which is behind a `&` reference\n  --> /tmp/tmpb7194j9o.rs:21:9\n\
    \   |\n19 |     let mut min_water = wells.iter().min().unwrap();\n   |       \
    \  ------------- help: consider changing this to be a mutable reference: `&mut\
    \ isize`\n20 |     while *min_water > 0 {\n21 |         *min_water -= capacity;\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^ `min_water` is a `&` reference, so the data\
    \ it refers to cannot be written\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ mut fill = vec![0; n];\n    let mut fill_count = 0;\n    for col in 0..grid[0].len()\
    \ {\n        let mut filled = false;\n        for row in 0..n {\n            fill[row]\
    \ += grid[row][col];\n            if fill[row] > capacity {\n                fill[row]\
    \ = capacity;\n                filled = true;\n            }\n        }\n    \
    \    if filled {\n            fill_count += 1;\n        }\n    }\n    fill_count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpmzq0exqf.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut num_fill = 0;\n  \
    \  let mut cur_cap = capacity;\n    for row in grid {\n        for col in row\
    \ {\n            if col > cur_cap {\n                num_fill += 1;\n        \
    \        cur_cap = capacity;\n            }\n            cur_cap -= col;\n   \
    \     }\n    }\n    num_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpo5301h6_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() { return\
    \ 0; }\n    let mut well = vec![0; grid[0].len()];\n    let mut count = 0;\n \
    \   for row in grid {\n        for (i, bucket) in row.iter().enumerate() {\n \
    \           if *bucket == 1 {\n                well[i] += 1;\n            }\n\
    \        }\n        if well.iter().sum::<isize>() < capacity { continue; }\n \
    \       count += 1;\n        for i in 0..well.len() {\n            well[i] = std::cmp::min(well[i],\
    \ capacity);\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpw_t80t0i.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let rows = grid.len();\n \
    \   let cols = grid[0].len();\n    let mut times = 0;\n    let mut prev = vec![0;\
    \ cols];\n    for row in grid {\n        for (i, &t) in row.iter().enumerate()\
    \ {\n            if t > prev[i] {\n                let d = t - prev[i];\n    \
    \            times += d / capacity;\n                if d % capacity > 0 {\n \
    \                   times += 1;\n                }\n            }\n          \
    \  prev[i] = t;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpysy9arqp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::cmp::max;\n    let\
    \ h = grid.len();\n    let w = grid[0].len();\n    let mut grid = grid;\n    let\
    \ mut fill = 0;\n    for c in 0..w {\n        let mut max_to_fill = 0;\n     \
    \   for r in 0..h {\n            max_to_fill = max(max_to_fill, grid[r][c]);\n\
    \        }\n        for r in 0..h {\n            grid[r][c] = max_to_fill - grid[r][c];\n\
    \        }\n        fill += max_to_fill;\n    }\n    fill / capacity\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpilsgvq7h.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total = 0;\n    let\
    \ mut max_well = 0;\n    for row in grid {\n        for well in row {\n      \
    \      if well > max_well {\n                max_well = well;\n            }\n\
    \            total += well;\n        }\n    }\n    return ((total - 1) / capacity)\
    \ + 1;\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpbyj9rwtj.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let max_fill = |mut fill:\
    \ usize, mut col: usize| {\n        for row in grid.iter() {\n            if row[col]\
    \ == 1 {\n                fill += 1;\n            } else if fill > 0 {\n     \
    \           fill -= 1;\n            }\n        }\n        fill\n    };\n    let\
    \ mut steps = 0;\n    while max_fill(0, 0) > 0 {\n        steps += 1;\n      \
    \  for row in grid.iter_mut() {\n            let mut fill = 0;\n            for\
    \ col in row.iter_mut() {\n                if *col == 1 {\n                  \
    \  fill += 1;\n                } else if fill > 0 {\n                    fill\
    \ -= 1;\n                }\n            }\n            for col in row.iter_mut()\
    \ {\n                if fill > 0 {\n                    *col = 1;\n          \
    \          fill -= 1;\n                } else {\n                    *col = 0;\n\
    \                }\n            }\n        }\n    }\n    steps\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmp0f_gvu2y.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp0f_gvu2y.rs:17:38\n\
    \   |\n17 |     let max_fill = |mut fill: usize, mut col: usize| {\n   |     \
    \                                 ----^^^\n   |                              \
    \        |\n   |                                      help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0596]: cannot\
    \ borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmp0f_gvu2y.rs:30:20\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n30 |         for row in grid.iter_mut() {\n   |                    ^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `grid` as mutable because\
    \ it is also borrowed as immutable\n  --> /tmp/tmp0f_gvu2y.rs:30:20\n   |\n17\
    \ |     let max_fill = |mut fill: usize, mut col: usize| {\n   |             \
    \       --------------------------------- immutable borrow occurs here\n18 | \
    \        for row in grid.iter() {\n   |                    ---- first borrow occurs\
    \ due to use of `grid` in closure\n...\n28 |     while max_fill(0, 0) > 0 {\n\
    \   |           -------- immutable borrow later used here\n29 |         steps\
    \ += 1;\n30 |         for row in grid.iter_mut() {\n   |                    ^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror: aborting due to 2 previous errors; 2 warnings\
    \ emitted\n\nSome errors have detailed explanations: E0502, E0596.\nFor more information\
    \ about an error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    grid.iter().fold(0, |num_fills,\
    \ well| {\n        num_fills + (well.iter().filter(|&&x| x > 0).sum::<isize>()\
    \ + capacity - 1) / capacity\n    })\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let (rows, cols) = (grid.len(),\
    \ grid[0].len());\n    let mut fill = 0;\n    let mut emp = vec![capacity; cols];\n\
    \    let mut row = 0;\n    while row < rows {\n        let mut col = 0;\n    \
    \    while col < cols {\n            if grid[row][col] == 1 {\n              \
    \  if emp[col] > 0 {\n                    emp[col] -= 1;\n                } else\
    \ {\n                    fill += 1;\n                }\n            }\n      \
    \      col += 1;\n        }\n        row += 1;\n    }\n    fill\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpr44n_ty0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut buckets = vec![0;\
    \ grid[0].len()];\n    let mut res = 0;\n    for i in 0..grid.len() {\n      \
    \  let mut filled = 0;\n        for j in 0..grid[0].len() {\n            let next_filled\
    \ =\n                if grid[i][j] + buckets[j] > capacity { buckets[j] + capacity\
    \ } else { grid[i][j] + buckets[j] };\n            filled += next_filled - buckets[j];\n\
    \            buckets[j] = next_filled;\n        }\n        res += filled;\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `5`', /tmp/tmpspkci8dr.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // Fill buckets to capacity\
    \ then descend\n    // Iterate over buckets,\n    //  max(cell_depth - bucket_depth,\
    \ 0)\n    //  update bucket_depth\n    //  if bucket_depth == 0\n    //   continue\
    \ descending\n    //  if bucket_depth != capacity\n    //   loop back to bucket\n\
    \n    let mut filled = 0;\n    for bucket in 0..grid[0].len() {\n        let mut\
    \ i = 0;\n        loop {\n            // println!(\"  bucket: {}\", bucket);\n\
    \            // println!(\"    i: {}\", i);\n            // println!(\"    bucket_depth:\
    \ {}\", bucket_depth);\n            // println!(\"    filled: {}\", filled);\n\
    \            let d = (grid[i][bucket] - bucket_depth).max(0);\n            bucket_depth\
    \ += d;\n            filled += d;\n            if bucket_depth == capacity {\n\
    \                break;\n            }\n            // bucket is not full and\
    \ we ran out of well\n            if i == grid.len() - 1 {\n                bucket_depth\
    \ = 0;\n                i = 0;\n            } else {\n                i += 1;\n\
    \            }\n        }\n    }\n    filled\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bucket_depth` in this scope\n  --> /tmp/tmpso072ove.rs:34:40\n\
    \   |\n34 |             let d = (grid[i][bucket] - bucket_depth).max(0);\n   |\
    \                                        ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `bucket_depth` in this scope\n  --> /tmp/tmpso072ove.rs:35:13\n\
    \   |\n35 |             bucket_depth += d;\n   |             ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `bucket_depth` in this\
    \ scope\n  --> /tmp/tmpso072ove.rs:37:16\n   |\n37 |             if bucket_depth\
    \ == capacity {\n   |                ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `bucket_depth` in this scope\n  --> /tmp/tmpso072ove.rs:42:17\n\
    \   |\n42 |                 bucket_depth = 0;\n   |                 ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let width = grid[0].len();\n\
    \    let mut moves = 0;\n    let mut prev_row = vec![0; width];\n    for row in\
    \ grid {\n        let mut curr_row = row.clone();\n        for i in 0..width {\n\
    \            if prev_row[i] < capacity {\n                let diff = capacity\
    \ - prev_row[i];\n                if curr_row[i] >= diff {\n                 \
    \   moves += 1;\n                    curr_row[i] -= diff;\n                } else\
    \ {\n                    moves += 1;\n                    curr_row[i] = 0;\n \
    \               }\n            }\n        }\n        prev_row = curr_row;\n  \
    \  }\n    moves\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `6`', /tmp/tmp7p6c0kjs.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let h = grid.len();\n    let\
    \ w = grid[0].len();\n    let mut result = 0;\n    for row in grid {\n       \
    \ let mut remaining = capacity;\n        for v in row {\n            if v > remaining\
    \ {\n                result += 1;\n                remaining = capacity;\n   \
    \         }\n            remaining -= v;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpdl2y4mwo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let (r, c) = (grid.len(),\
    \ grid[0].len());\n    let mut buckets = vec![0; c];\n    let mut ans = 0;\n \
    \   for row in grid {\n        for (col, &elem) in row.iter().enumerate() {\n\
    \            if elem == 1 {\n                buckets[col] += 1;\n            }\n\
    \        }\n        if buckets.iter().max().unwrap() == &capacity {\n        \
    \    for i in 0..c {\n                buckets[i] = 0;\n            }\n       \
    \     ans += 1;\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpez8dw3up.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    grid.iter().map(|row| {\n\
    \        let total: isize = row.iter().sum();\n        let mut depth = 0;\n  \
    \      let mut count = 0;\n        loop {\n            if depth == total {\n \
    \               break;\n            }\n            let this_count = std::cmp::min(capacity,\
    \ total - depth);\n            depth += this_count;\n            count += 1;\n\
    \        }\n        count\n    }).max().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpt6y5xq7_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut result = 0;\n    let mut row_max = 0;\n    for\
    \ row in grid {\n        row_max = 0;\n        for col in row {\n            row_max\
    \ = col.max(row_max);\n        }\n        result += row_max;\n    }\n    let mut\
    \ col_max = vec![0; m];\n    for i in 0..n {\n        for j in 0..m {\n      \
    \      col_max[j] = grid[i][j].max(col_max[j]);\n        }\n    }\n    for i in\
    \ 0..n {\n        for j in 0..m {\n            result += capacity - row_max -\
    \ col_max[j] + grid[i][j];\n        }\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmp1f9_sbx5.rs:31:26\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n21  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n31  |             col_max[j] = grid[i][j].max(col_max[j]);\n    |       \
    \                   ^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `grid`\nhelp: consider iterating\
    \ over a slice of the `Vec<Vec<isize>>`'s content to avoid moving into the `for`\
    \ loop\n    |\n21  |     for row in &grid {\n    |                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut empty_rows: Vec<usize> = vec![];\n    let max_iter = grid.len() * grid[0].len();\n\
    \    let mut iter = 0;\n    let mut res = 0;\n    loop {\n        for i in 0..grid.len()\
    \ {\n            for j in 0..grid[i].len() {\n                if grid[i][j] ==\
    \ 1 {\n                    // fill grid\n                    if capacity > 0 {\n\
    \                        grid[i][j] -= 1;\n                        capacity -=\
    \ 1;\n                    }\n                }\n            }\n        }\n   \
    \     for i in 0..grid.len() {\n            if grid[i].iter().all(|&x| x == 0)\
    \ {\n                empty_rows.push(i);\n            }\n        }\n        if\
    \ empty_rows.len() > 0 {\n            // clean grid\n            grid.retain(|row|\
    \ !empty_rows.contains(&(row.len() - 1)));\n            // reset\n           \
    \ empty_rows = vec![];\n            capacity = grid[0].len() as isize;\n     \
    \       res += 1;\n        }\n        iter += 1;\n        if iter > max_iter {\n\
    \            break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `capacity`\n  --> /tmp/tmp00_d0x_f.rs:29:25\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    -------- help: consider making this binding\
    \ mutable: `mut capacity`\n...\n29 |                         capacity -= 1;\n\
    \   |                         ^^^^^^^^^^^^^ cannot assign to immutable argument\n\
    \nerror[E0384]: cannot assign to immutable argument `capacity`\n  --> /tmp/tmp00_d0x_f.rs:44:13\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    -------- help: consider making this binding\
    \ mutable: `mut capacity`\n...\n44 |             capacity = grid[0].len() as isize;\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut operations = 0;\n\
    \    let mut added = 0;\n    while added > 0 || max_fill_row(grid[0].iter(), capacity)\
    \ {\n        added = 0;\n        for row in grid.iter() {\n            added +=\
    \ max_fill_row(row.iter(), capacity);\n        }\n        operations += 1;\n \
    \   }\n    operations\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_fill_row` in this scope\n  -->\
    \ /tmp/tmpao4mdgy5.rs:19:24\n   |\n19 |     while added > 0 || max_fill_row(grid[0].iter(),\
    \ capacity) {\n   |                        ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `max_fill_row` in this scope\n  --> /tmp/tmpao4mdgy5.rs:22:22\n\
    \   |\n22 |             added += max_fill_row(row.iter(), capacity);\n   |   \
    \                   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let width = grid[0].len();\n\
    \    let mut current_height = vec![0; width];\n    let mut next_height = vec![0;\
    \ width];\n    let mut water_height = 0;\n    while !grid.iter().all(|row| row.iter().all(|cell|\
    \ *cell == 0)) {\n        for col in 0..width {\n            water_height += max(0,\
    \ current_height[col] - grid[water_height][col]);\n            next_height[col]\
    \ = max(0, capacity - grid[water_height][col]);\n        }\n        for col in\
    \ 0..width {\n            if current_height[col] != 0 {\n                grid[water_height\
    \ - current_height[col]][col] += current_height[col];\n            }\n       \
    \     grid[water_height][col] = next_height[col];\n        }\n        current_height\
    \ = next_height.clone();\n        next_height = vec![0; width];\n        water_height\
    \ += 1;\n    }\n    water_height\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpczu7n8ra.rs:23:29\n\
    \   |\n23 |             water_height += max(0, current_height[col] - grid[water_height][col]);\n\
    \   |                             ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmpczu7n8ra.rs:24:32\n\
    \   |\n24 |             next_height[col] = max(0, capacity - grid[water_height][col]);\n\
    \   |                                ^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpczu7n8ra.rs:28:37\n   |\n28 |              \
    \   grid[water_height - current_height[col]][col] += current_height[col];\n  \
    \ |                                     ^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpczu7n8ra.rs:28:35\n\
    \   |\n28 |                 grid[water_height - current_height[col]][col] += current_height[col];\n\
    \   |                                   ^ no implementation for `usize - isize`\n\
    \   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Sub<Rhs>`:\n             <&'a\
    \ f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128\
    \ as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as\
    \ Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpczu7n8ra.rs:36:5\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                               ----- expected `isize` because of return type\n\
    ...\n36 |     water_height\n   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n36 |     water_height.try_into().un"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        for &well in row.iter() {\n            if well == 0 {\n\
    \                continue;\n            }\n            let times = (well - 1)\
    \ / capacity + 1;\n            result += times;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpd5vr4x8g.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut water = 0;\n    let\
    \ mut fill = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            water += grid[i][j];\n        }\n        if water == 0 {\n  \
    \          continue;\n        }\n        let one_fill = min(water, capacity);\n\
    \        for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n     \
    \           grid[i][j] -= one_fill;\n            }\n        }\n        water -=\
    \ one_fill;\n        fill += 1;\n    }\n    fill\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpas31dehx.rs:26:24\n\
    \   |\n26 |         let one_fill = min(water, capacity);\n   |               \
    \         ^^^\n...\n38 | fn main() {\n   | --------- similarly named function\
    \ `main` defined here\n   |\nhelp: a function with a similar name exists\n   |\n\
    26 |         let one_fill = main(water, capacity);\n   |                     \
    \   ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::cmp::max;\n    let\
    \ mut prev = capacity;\n    let mut row_max = vec![0; grid[0].len()];\n    for\
    \ i in (0..grid.len()).rev() {\n        for j in 0..grid[i].len() {\n        \
    \    row_max[j] = max(row_max[j], grid[i][j]);\n        }\n    }\n    let mut\
    \ count = 0;\n    for i in 0..grid.len() {\n        let mut column_max = 0;\n\
    \        for j in 0..grid[i].len() {\n            column_max = max(column_max,\
    \ grid[i][j]);\n            let next = max(row_max[j], column_max);\n        \
    \    count += prev - next;\n            prev = next;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpnqa9ousw.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut i = 0;\n    while i < grid.len() {\n        let mut j = 0;\n        while\
    \ j < grid[i].len() {\n            if grid[i][j] == 1 {\n                result\
    \ += 1;\n                for row in i..min(i + capacity as usize, grid.len())\
    \ {\n                    for col in j..min(j + capacity as usize, grid[i].len())\
    \ {\n                        grid[row][col] = 0;\n                    }\n    \
    \            }\n            }\n            j += 1;\n        }\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpfok6laue.rs:24:31\n\
    \   |\n24 |                 for row in i..min(i + capacity as usize, grid.len())\
    \ {\n   |                               ^^^\n...\n37 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n24 |                 for row in i..main(i + capacity\
    \ as usize, grid.len()) {\n   |                               ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmpfok6laue.rs:25:35\n\
    \   |\n25 |                     for col in j..min(j + capacity as usize, grid[i].len())\
    \ {\n   |                                   ^^^\n...\n37 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n25 |                     for col in j..main(j + capacity\
    \ as usize, grid[i].len()) {\n   |                                   ~~~~\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() { return\
    \ 0; }\n    let mut max_fill = 0;\n    for well in grid {\n        let mut remain\
    \ = capacity;\n        for &depth in well.iter() {\n            if depth > 0 {\n\
    \                if remain >= depth {\n                    remain -= depth;\n\
    \                } else {\n                    max_fill += 1;\n              \
    \      remain = capacity - depth;\n                }\n            }\n        }\n\
    \    }\n    max_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpip3a8_ct.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut lo = 0;\n    let mut\
    \ hi = 0;\n    for i in 0..grid.len() {\n        lo = max(lo, grid[i].iter().sum());\n\
    \        for j in 0..grid[i].len() {\n            hi = max(hi, grid[i][j]);\n\
    \        }\n    }\n    let mut res = lo;\n    while lo <= hi {\n        let mid\
    \ = lo + (hi - lo) / 2;\n        if is_valid(grid.clone(), capacity, mid) {\n\
    \            res = mid;\n            hi = mid - 1;\n        } else {\n       \
    \     lo = mid + 1;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp76f9fomt.rs:20:14\n\
    \   |\n20 |         lo = max(lo, grid[i].iter().sum());\n   |              ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmp76f9fomt.rs:22:18\n   |\n22 |             hi = max(hi,\
    \ grid[i][j]);\n   |                  ^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `is_valid` in this scope\n  --> /tmp/tmp76f9fomt.rs:28:12\n\
    \   |\n28 |         if is_valid(grid.clone(), capacity, mid) {\n   |         \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let num_rows = grid.len();\n\
    \    if num_rows == 0 {\n        return 0;\n    }\n    let num_cols = grid[0].len();\n\
    \    let mut wells = vec![vec![0; num_cols]; num_rows];\n    for i in 0..num_rows\
    \ {\n        for j in 0..num_cols {\n            wells[i][j] = grid[i][j];\n \
    \       }\n    }\n    let mut total_water = 0;\n    for _ in 0..num_rows {\n \
    \       let mut new_water = 0;\n        for j in 0..num_cols {\n            if\
    \ wells[0][j] > 0 {\n                new_water += 1;\n                wells[0][j]\
    \ -= 1;\n            }\n        }\n        total_water += new_water;\n       \
    \ wells.rotate_left(1);\n    }\n    let spills = total_water / capacity;\n   \
    \ spills as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp47z5o4zu.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    let rows = grid.len();\n    let cols = grid[0].len();\n\
    \    let mut max_by_row = vec![0; rows];\n    let mut max_by_col = vec![0; cols];\n\
    \    for row in 0..rows {\n        for col in 0..cols {\n            if grid[row][col]\
    \ > max_by_row[row] {\n                max_by_row[row] = grid[row][col];\n   \
    \         }\n            if grid[row][col] > max_by_col[col] {\n             \
    \   max_by_col[col] = grid[row][col];\n            }\n        }\n    }\n    for\
    \ row in 0..rows {\n        for col in 0..cols {\n            let max = max_by_row[row].min(max_by_col[col]);\n\
    \            if grid[row][col] < max {\n                count += max - grid[row][col];\n\
    \                grid[row][col] = max;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmp4rparz97.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let m = grid.len();\n    let\
    \ n = grid[0].len();\n    let mut ans = 0;\n    for i in 0..m {\n        for j\
    \ in 0..n {\n            let mut count = 0;\n            if grid[i][j] == 1 {\n\
    \                count += 1;\n                grid[i][j] = 0;\n            }\n\
    \            if i - 1 >= 0 && grid[i - 1][j] == 1 {\n                count +=\
    \ 1;\n                grid[i - 1][j] = 0;\n            }\n            if i + 1\
    \ < m && grid[i + 1][j] == 1 {\n                count += 1;\n                grid[i\
    \ + 1][j] = 0;\n            }\n            if j - 1 >= 0 && grid[i][j - 1] ==\
    \ 1 {\n                count += 1;\n                grid[i][j - 1] = 0;\n    \
    \        }\n            if j + 1 < n && grid[i][j + 1] == 1 {\n              \
    \  count += 1;\n                grid[i][j + 1] = 0;\n            }\n         \
    \   ans += (count - 1) / capacity + 1;\n        }\n    }\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_fzg2n3k.rs:25:17\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n25 |                 grid[i][j] = 0;\n   | \
    \                ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmp_fzg2n3k.rs:29:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n29 |                 grid[i - 1][j] = 0;\n   |                 ^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmp_fzg2n3k.rs:33:17\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n33 |                 grid[i +\
    \ 1][j] = 0;\n   |                 ^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmp_fzg2n3k.rs:37:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n37 |                 grid[i][j - 1] = 0;\n   |                 ^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmp_fzg2n3k.rs:41:17\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n41 |                 grid[i][j\
    \ + 1] = 0;\n   |                 ^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        for &well in row.iter() {\n            if well > 0 {\n\
    \                result += 1;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpov9_93mm.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ row_count = grid.len();\n    let col_count = grid[0].len();\n    let mut row_index\
    \ = 0;\n    let mut col_index = 0;\n    while row_index < row_count {\n      \
    \  while col_index < col_count {\n            if grid[row_index][col_index] ==\
    \ 1 {\n                if row_index < row_count - 1 {\n                    if\
    \ grid[row_index + 1][col_index] == 0 {\n                        grid[row_index\
    \ + 1][col_index] = 1;\n                        count += 1;\n                \
    \    }\n                } else {\n                    if col_index < col_count\
    \ - 1 {\n                        if grid[row_index][col_index + 1] == 0 {\n  \
    \                          grid[row_index][col_index + 1] = 1;\n             \
    \               count += 1;\n                        }\n                    }\n\
    \                }\n            }\n            col_index += 1;\n        }\n  \
    \      col_index = 0;\n        row_index += 1;\n    }\n    return count;\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `capacity`\n  --> /tmp/tmpsgtkg9xk.rs:16:36\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                    ^^^^^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_capacity`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `grid` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpsgtkg9xk.rs:27:25\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |             ---- help: consider\
    \ changing this to be mutable: `mut grid`\n...\n27 |                         grid[row_index\
    \ + 1][col_index] = 1;\n   |                         ^^^^ cannot borrow as mutable\n\
    \nerror[E0596]: cannot borrow `grid` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpsgtkg9xk.rs:33:29\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n33 |                             grid[row_index][col_index\
    \ + 1] = 1;\n   |                             ^^^^ cannot borrow as mutable\n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut moves = 0;\n    loop {\n        // fill\n        for i in 0..grid.len()\
    \ {\n            for j in 0..grid[i].len() {\n                let mut fill = capacity\
    \ - grid[i][j];\n                if fill > 0 {\n                    // fill from\
    \ below\n                    for k in i..grid.len() {\n                      \
    \  if grid[k][j] >= fill {\n                            grid[k][j] -= fill;\n\
    \                            break;\n                        } else {\n      \
    \                      fill -= grid[k][j];\n                            grid[k][j]\
    \ = 0;\n                        }\n                    }\n                   \
    \ // fill from above\n                    if fill > 0 {\n                    \
    \    for k in (0..i).rev() {\n                            if grid[k][j] >= fill\
    \ {\n                                grid[k][j] -= fill;\n                   \
    \             break;\n                            } else {\n                 \
    \               fill -= grid[k][j];\n                                grid[k][j]\
    \ = 0;\n                            }\n                        }\n           \
    \         }\n                }\n            }\n        }\n        let mut done\
    \ = true;\n        for row in &grid {\n            for v in row {\n          \
    \      if *v > 0 {\n                    done = false;\n                    break;\n\
    \                }\n            }\n        }\n        if done {\n            break;\n\
    \        }\n        moves += 1;\n    }\n    moves\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmp3wtl2a0c.rs:69:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut fill_count = 0;\n    let mut max_height = isize::min_value();\n    for\
    \ col in 0..grid[0].len() {\n        max_height = isize::min_value();\n      \
    \  for row in 0..grid.len() {\n            if grid[row][col] == 1 {\n        \
    \        max_height = isize::max(max_height, grid[row][col]);\n            }\n\
    \        }\n        if max_height == 0 {\n            continue;\n        }\n \
    \       for row in 0..grid.len() {\n            if grid[row][col] == 0 {\n   \
    \             grid[row][col] = capacity;\n                fill_count += 1;\n \
    \           }\n        }\n    }\n    fill_count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmphav4ed5v.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    for\
    \ (i, row) in grid.iter().enumerate() {\n        let mut curr = 0;\n        for\
    \ j in row.iter() {\n            curr += j;\n            if curr == capacity {\n\
    \                fill += 1;\n                curr = 0;\n            }\n      \
    \  }\n        if curr > 0 {\n            fill += 1;\n        }\n    }\n    fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let rows = grid.len();\n \
    \   let cols = grid[0].len();\n    let mut wells = vec![vec![0isize;cols];rows];\n\
    \    for r in 0..rows {\n        for c in 0..cols {\n            wells[r][c] =\
    \ grid[r][c] as isize;\n        }\n    }\n    let mut water = 0;\n    for _ in\
    \ 0..cols {\n        for r in 0..rows {\n            if wells[r][0] == 1 {\n \
    \               water += 1;\n                wells[r][0] = 0;\n            }\n\
    \        }\n        for r in 0..rows {\n            for c in 1..cols {\n     \
    \           if wells[r][c] == 1 {\n                    if wells[r][c-1] == 0 {\n\
    \                        water += 1;\n                        wells[r][c] = 0;\n\
    \                    }\n                }\n            }\n        }\n        for\
    \ r in 0..rows {\n            if wells[r][cols-1] == 1 {\n                water\
    \ += 1;\n                wells[r][cols-1] = 0;\n            }\n        }\n   \
    \     for r in 0..rows {\n            for c in (0..cols-1).rev() {\n         \
    \       if wells[r][c] == 1 {\n                    if wells[r][c+1] == 0 {\n \
    \                       water += 1;\n                        wells[r][c] = 0;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   water / capacity\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpkyoammi7.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let len = grid.len();\n  \
    \  let column_len = grid[0].len();\n    // bucket_row[i] -> buckets in row i\n\
    \    let mut bucket_row = vec![0; len];\n    // cur_bucket -> current bucket\n\
    \    let mut cur_bucket = 0;\n    for i in 0..len {\n        for j in 0..column_len\
    \ {\n            if grid[i][j] == 1 {\n                if bucket_row[i] < capacity\
    \ {\n                    bucket_row[i] += 1;\n                } else {\n     \
    \               cur_bucket += 1;\n                }\n            }\n        }\n\
    \    }\n    cur_bucket\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpq54svq54.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut running_fill = 0;\n\
    \    let mut fill_count = 0;\n    for row in grid {\n        for col in row {\n\
    \            running_fill += col;\n            if running_fill >= capacity {\n\
    \                fill_count += 1;\n                running_fill = 0;\n       \
    \     }\n        }\n    }\n    fill_count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpwgk4fe70.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let wells_len = grid.len();\n\
    \    let buckets_len = grid[0].len();\n    let mut bucket = 0;\n    let mut times\
    \ = 0;\n    for (i, row) in grid.iter().enumerate() {\n        let mut well =\
    \ 0;\n        let mut water = 0;\n        for j in 0..buckets_len {\n        \
    \    well += row[j];\n            if well < capacity {\n                water\
    \ += 1;\n            } else {\n                well -= capacity;\n           \
    \     water = 0;\n            }\n        }\n        bucket += water;\n       \
    \ if bucket >= capacity {\n            bucket -= capacity;\n            times\
    \ += 1;\n        }\n        if i == wells_len - 1 {\n            bucket = 0;\n\
    \            times += bucket;\n        }\n    }\n    times\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpak38i0es.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut max_height = 0;\n    for i in 0..n {\n     \
    \   for j in 0..m {\n            if grid[i][j] == 1 {\n                max_height\
    \ = max_height.max(i as isize);\n            }\n        }\n    }\n    let mut\
    \ steps = 0;\n    for i in (0..=max_height).rev() {\n        let mut times = 0;\n\
    \        for j in 0..m {\n            if grid[i as usize][j] == 1 {\n        \
    \        times += 1;\n            }\n        }\n        steps += times / capacity;\n\
    \        if times % capacity != 0 {\n            steps += 1;\n        }\n    }\n\
    \    steps\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut i = 0;\n    let mut\
    \ res = 0;\n    for r in grid {\n        for (j, v) in r.iter().enumerate() {\n\
    \            if *v == 1 {\n                if j < i {\n                    res\
    \ += i - j;\n                    i = j;\n                }\n                i\
    \ += 1;\n            }\n        }\n        i = 0;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_dj4ihgi.rs:31:5\n   |\n\
    16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n31 |     res\n   |     ^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n31 |     res.try_into().unwrap()\n   |        ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let capacity = capacity as\
    \ usize;\n    let mut count = 0;\n    let mut wells = Vec::new();\n    for row\
    \ in grid {\n        let mut row_sum = 0;\n        for &col in row.iter() {\n\
    \            row_sum += col;\n        }\n        wells.push(row_sum);\n    }\n\
    \    // println!(\"{:?}\", wells);\n    loop {\n        let mut lowest = usize::max_value();\n\
    \        let mut done = true;\n        for &well in wells.iter() {\n         \
    \   if well > 0 {\n                done = false;\n            }\n            lowest\
    \ = lowest.min(well);\n        }\n        if done {\n            break;\n    \
    \    }\n        count += 1;\n        for well in wells.iter_mut() {\n        \
    \    *well -= lowest;\n        }\n        // println!(\"{:?}\", wells);\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpib2aihbr.rs:35:33\n   |\n\
    35 |             lowest = lowest.min(well);\n   |                            \
    \     ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n35 |      \
    \       lowest = lowest.min(well.try_into().unwrap());\n   |                 \
    \                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpib2aihbr.rs:42:22\n   |\n42 |             *well -= lowest;\n  \
    \ |                      ^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot subtract-assign `usize` from `isize`\n  --> /tmp/tmpib2aihbr.rs:42:19\n\
    \   |\n42 |             *well -= lowest;\n   |                   ^^ no implementation\
    \ for `isize -= usize`\n   |\n   = help: the trait `SubAssign<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    let\
    \ width = grid[0].len();\n    let max_empty = capacity * width;\n    for row in\
    \ grid {\n        let sum: isize = row.iter().sum();\n        if sum > max_empty\
    \ {\n            return -1;\n        }\n        res += max_empty - sum;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1vkvd01j.rs:19:32\n   |\n\
    19 |     let max_empty = capacity * width;\n   |                             \
    \   ^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize`\
    \ by `usize`\n  --> /tmp/tmp1vkvd01j.rs:19:30\n   |\n19 |     let max_empty =\
    \ capacity * width;\n   |                              ^ no implementation for\
    \ `isize * usize`\n   |\n   = help: the trait `Mul<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // We can deduce that the\
    \ maximum amouht of water we can extract is\n    // grid.len() * capactiy, so\
    \ it doesn't really matter.\n    let mut extracted = 0;\n    let mut i = 0;\n\
    \    while i < grid.len() {\n        let mut sum = 0;\n        while i < grid.len()\
    \ && sum + grid[i][0] <= capacity {\n            sum += grid[i][0];\n        \
    \    i += 1;\n        }\n        extracted += 1;\n    }\n    extracted\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp274muchp.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    for\
    \ row in grid {\n        let mut capacity = capacity;\n        for &w in row.iter()\
    \ {\n            capacity -= w;\n            if capacity < 0 {\n             \
    \   res += 1;\n                capacity = capacity.abs();\n            }\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpzwa7lvng.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_row = (0, 0);\n\
    \    for (i, row) in grid.iter().enumerate() {\n        let sum: isize = row.iter().sum();\n\
    \        if sum > max_row.1 {\n            max_row = (i, sum);\n        }\n  \
    \  }\n    let mut max_row = max_row.0;\n    let mut total_fill = 0;\n    let mut\
    \ last_row_fill = capacity;\n    while max_row > 0 {\n        let fill = capacity.min(grid[max_row][0]);\n\
    \        let fill = fill.min(last_row_fill);\n        grid[max_row][0] -= fill;\n\
    \        last_row_fill = capacity - fill;\n        total_fill += fill;\n     \
    \   if grid[max_row][0] == 0 {\n            max_row -= 1;\n        }\n    }\n\
    \    total_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpadi7cxu9.rs:30:9\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n30 |         grid[max_row][0] -= fill;\n   |\
    \         ^^^^ cannot borrow as mutable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let columns: usize = grid[0].len();\n\
    \    let mut total_fill = 0;\n    for column in 0..columns {\n        let mut\
    \ can_fill = capacity;\n        for row in 0..grid.len() {\n            let level\
    \ = grid[row][column];\n            if level == 1 {\n                if can_fill\
    \ == 0 {\n                    total_fill += 1;\n                    can_fill =\
    \ capacity;\n                }\n                can_fill -= 1;\n            }\n\
    \        }\n    }\n    total_fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpq7e86wrt.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::cmp::min;\n    let\
    \ max_row = *grid.iter().map(|r| r.iter().sum::<isize>()).max().unwrap();\n  \
    \  let len = grid[0].len();\n    let mut row_index = 0;\n    let mut result =\
    \ 0;\n    while row_index < grid.len() {\n        if grid[row_index].iter().sum::<isize>()\
    \ == 0 {\n            row_index += 1;\n            continue;\n        }\n    \
    \    let row = &grid[row_index];\n        let row_remaining = row.iter().sum::<isize>();\n\
    \        let row_move = min(row_remaining, capacity);\n        for i in 0..len\
    \ {\n            row[i] -= row_move;\n        }\n        result += 1;\n      \
    \  row_index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpyouaukp2.rs:18:19\n\
    \   |\n18 |     let max_row = *grid.iter().map(|r| r.iter().sum::<isize>()).max().unwrap();\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut fill = 0;\n    for i in 0..n {\n        let\
    \ mut line = vec![];\n        for j in 0..m {\n            line.push(grid[i][j]);\n\
    \        }\n        let (mut cnt, j) = fill_line(line, capacity);\n        fill\
    \ += cnt;\n        while j != m {\n            let (cnt_, _) = fill_line(line,\
    \ capacity);\n            fill += cnt_;\n            cnt = cnt_;\n        }\n\
    \    }\n    fill\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `fill_line` in this scope\n  --> /tmp/tmpu0v0yf6l.rs:25:28\n\
    \   |\n25 |         let (mut cnt, j) = fill_line(line, capacity);\n   |      \
    \                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `fill_line` in this scope\n  --> /tmp/tmpu0v0yf6l.rs:28:29\n \
    \  |\n28 |             let (cnt_, _) = fill_line(line, capacity);\n   |      \
    \                       ^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // find the biggest one\n\
    \    let mut n = 1;\n    for row in grid.iter() {\n        let mut max = 0;\n\
    \        for c in row.iter() {\n            max += c;\n        }\n        if max\
    \ > n {\n            n = max;\n        }\n    }\n    let mut lo = 0;\n    let\
    \ mut hi = n;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n  \
    \      if check(grid.clone(), capacity, mid) {\n            hi = mid;\n      \
    \  } else {\n            lo = mid + 1;\n        }\n    }\n    lo\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check` in this scope\n  --> /tmp/tmpvzw5w_s5.rs:32:12\n\
    \   |\n32 |         if check(grid.clone(), capacity, mid) {\n   |            ^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let h = grid.len();\n    let w = grid[0].len();\n    let mut result = 0;\n \
    \   for _ in 0..h {\n        for x in 0..w {\n            if grid[x][_] == 1 {\n\
    \                result += 1;\n                for y in _..h {\n             \
    \       if grid[x][y] == 1 {\n                        grid[x][y] = 0;\n      \
    \              } else {\n                        break;\n                    }\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmpykny8ngf.rs:23:24\n   |\n23 |             if grid[x][_]\
    \ == 1 {\n   |                        ^ `_` not allowed here\n\nerror: in expressions,\
    \ `_` can only be used on the left-hand side of an assignment\n  --> /tmp/tmpykny8ngf.rs:25:26\n\
    \   |\n25 |                 for y in _..h {\n   |                          ^ `_`\
    \ not allowed here\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let height = grid.len();\n\
    \    let width = grid[0].len();\n    let mut drops = 0;\n    let mut overflow\
    \ = 0;\n    for row in 0..height {\n        let mut to_drop = 0;\n        for\
    \ col in 0..width {\n            let water = grid[row][col] + overflow;\n    \
    \        let (new_water, new_overflow) = water.div_rem(&capacity);\n         \
    \   to_drop += new_water;\n            overflow = new_overflow;\n        }\n \
    \       drops += to_drop;\n    }\n    drops\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `div_rem` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp66q42v9c.rs:25:51\n   |\n25 |             let (new_water,\
    \ new_overflow) = water.div_rem(&capacity);\n   |                            \
    \                       ^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut grid = grid;\n    loop {\n        if let Some(min) = grid.iter().map(|r|\
    \ r.iter().sum::<isize>()).min() {\n            if min == 0 {\n              \
    \  break;\n            }\n            count += 1;\n            for r in &mut grid\
    \ {\n                r.iter_mut().for_each(|r| {\n                    *r = if\
    \ *r >= min { *r - min } else { 0 };\n                });\n            }\n   \
    \     } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmpzv1etw1o.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut rows = Vec::with_capacity(grid.len());\n\
    \    let mut cols = Vec::with_capacity(grid[0].len());\n    let mut counts = 0;\n\
    \    for row in grid {\n        let mut sum = 0;\n        for &col in row.iter()\
    \ {\n            sum += col;\n        }\n        rows.push(sum);\n    }\n    for\
    \ col in 0..grid[0].len() {\n        let mut sum = 0;\n        for row in 0..grid.len()\
    \ {\n            sum += grid[row][col];\n        }\n        cols.push(sum);\n\
    \    }\n    let (width, height) = (grid[0].len(), grid.len());\n    for row in\
    \ 0..height {\n        for col in 0..width {\n            let cell = grid[row][col];\n\
    \            let sum = rows[row] + cols[col] - cell;\n            let min = rows[row].min(cols[col]);\n\
    \            if min > capacity {\n                panic!(\"invalid capacity\"\
    );\n            }\n            let fill = (sum - capacity).max(0);\n         \
    \   if fill > 0 {\n                counts += 1;\n            }\n        }\n  \
    \  }\n    counts\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmpkhuhg9kx.rs:27:19\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n20  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |     for col in 0..grid[0].len() {\n    |                   ^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `grid`\nhelp: consider iterating over a slice of\
    \ the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n    |\n\
    20  |     for row in &grid {\n    |                +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() {\n   \
    \     return 0;\n    }\n    let h = grid.len();\n    let w = grid[0].len();\n\
    \    let mut filled = vec![vec![0; w]; h];\n    let mut i = 0;\n    let mut j\
    \ = 0;\n    let mut count = 0;\n    loop {\n        if i == h {\n            break;\n\
    \        }\n        if j == w {\n            i += 1;\n            j = 0;\n   \
    \         continue;\n        }\n        if filled[i][j] == capacity {\n      \
    \      j += 1;\n            continue;\n        }\n        if grid[i][j] == 0 {\n\
    \            j += 1;\n            continue;\n        }\n        count += 1;\n\
    \        for i in 0..h {\n            for j in 0..w {\n                filled[i][j]\
    \ = filled[i][j].min(capacity);\n            }\n        }\n        for i in 0..h\
    \ {\n            for j in 0..w {\n                filled[i][j] += grid[i][j];\n\
    \            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp591ho6y6.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut bucket_count = 0;\n\
    \    let mut current_level = capacity;\n    let rows = grid.len();\n    let cols\
    \ = grid[0].len();\n    for col in 0..cols {\n        let mut fill_found = false;\n\
    \        for row in 0..rows {\n            if grid[row][col] == 1 {\n        \
    \        if !fill_found {\n                    if current_level > 0 {\n      \
    \                  bucket_count += 1;\n                        current_level =\
    \ capacity;\n                    } else {\n                        current_level\
    \ = capacity;\n                        bucket_count += 2;\n                  \
    \  }\n                    fill_found = true;\n                }\n            \
    \    current_level -= 1;\n            }\n        }\n    }\n    bucket_count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmp6depytyn.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: -1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::cmp::min;\n    //\
    \ the water level of each well\n    let mut water = grid.clone();\n    // the\
    \ current level of each bucket\n    let mut buckets = vec![0; grid[0].len()];\n\
    \    let mut fill_count = 0;\n    // while some wells have water remaining\n \
    \   while water.iter().flatten().any(|&x| x > 0) {\n        // empty the buckets\n\
    \        buckets = vec![0; grid[0].len()];\n        // fill each bucket\n    \
    \    for (i, row) in grid.iter().enumerate() {\n            for (j, col) in row.iter().enumerate()\
    \ {\n                if *col == 1 {\n                    buckets[j] += 1;\n  \
    \                  water[i][j] -= 1;\n                }\n            }\n     \
    \   }\n        // empty each bucket onto the wells\n        for (i, row) in water.iter_mut().enumerate()\
    \ {\n            for (j, col) in row.iter_mut().enumerate() {\n              \
    \  *col = min(*col + buckets[j], capacity);\n            }\n        }\n      \
    \  fill_count += 1;\n    }\n    fill_count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977633
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    0\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpgx6unsz_.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977626
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut drops = 0;\n    for\
    \ row in grid {\n        let mut level = 0;\n        for well in row {\n     \
    \       level += well;\n            let target = capacity - level;\n         \
    \   if target < 0 {\n                level = capacity;\n                drops\
    \ += 1;\n            } else {\n                level = target;\n            }\n\
    \        }\n        if level > 0 {\n            drops += 1;\n        }\n    }\n\
    \    drops\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmps93gnnw9.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut col = 0;\n        while col < row.len() {\n \
    \           let start = col;\n            while col < row.len() && row[col] ==\
    \ 1 {\n                col += 1;\n            }\n            let end = col;\n\
    \            let diff = end - start;\n            count += (diff + capacity -\
    \ 1) / capacity;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2z2u8zto.rs:27:30\n   |\n\
    27 |             count += (diff + capacity - 1) / capacity;\n   |            \
    \                  ^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]: cannot\
    \ add `isize` to `usize`\n  --> /tmp/tmp2z2u8zto.rs:27:28\n   |\n27 |        \
    \     count += (diff + capacity - 1) / capacity;\n   |                       \
    \     ^ no implementation for `usize + isize`\n   |\n   = help: the trait `Add<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2z2u8zto.rs:27:46\n\
    \   |\n27 |             count += (diff + capacity - 1) / capacity;\n   |     \
    \                                         ^^^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot divide `usize` by `isize`\n  --> /tmp/tmp2z2u8zto.rs:27:44\n\
    \   |\n27 |             count += (diff + capacity - 1) / capacity;\n   |     \
    \                                       ^ no implementation for `usize / isize`\n\
    \   |\n   = help: the trait `Div<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Div<Rhs>`:\n             <&'a\
    \ f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128\
    \ as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as\
    \ Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2z2u8zto.rs:30:5\n   |\n16 | fn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n   |                         \
    \                               ----- expected `isize` because of return type\n\
    ...\n30 |     count\n   |     ^^^^^ expected `isiz"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut well = 0;\n    while !grid.iter().all(|row| row.iter().all(|&v| v == 0))\
    \ {\n        result += 1;\n        let mut bucket = capacity;\n        for i in\
    \ well..grid.len() {\n            for j in 0..grid[i].len() {\n              \
    \  if grid[i][j] > 0 {\n                    bucket -= 1;\n                   \
    \ grid[i][j] -= 1;\n                }\n                if bucket == 0 {\n    \
    \                break;\n                }\n            }\n            if bucket\
    \ == 0 {\n                break;\n            }\n        }\n        well = std::cmp::min(well\
    \ + 1, grid.len() - 1);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpnf750r7d.rs:26:21\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n26 |                     grid[i][j] -= 1;\n\
    \   |                     ^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() { return\
    \ 0; }\n    let mut fill = 0;\n    for row in grid {\n        for col in row {\n\
    \            if col > 0 {\n                fill += 1;\n            }\n       \
    \ }\n    }\n    let mut rows = grid.len();\n    let mut cols = grid[0].len();\n\
    \    while rows > 0 {\n        let mut i = 0;\n        while i < rows {\n    \
    \        if grid[i].iter().sum::<isize>() <= capacity {\n                grid.remove(i);\n\
    \                rows -= 1;\n            } else {\n                i += 1;\n \
    \           }\n        }\n        if rows == 0 { break; }\n        let mut i =\
    \ 0;\n        while i < cols {\n            let mut column = vec![];\n       \
    \     for j in 0..rows {\n                column.push(grid[j][i]);\n         \
    \   }\n            if column.iter().sum::<isize>() <= capacity {\n           \
    \     for j in 0..rows {\n                    grid[j].remove(i);\n           \
    \     }\n                cols -= 1;\n            } else {\n                i +=\
    \ 1;\n            }\n        }\n    }\n    return fill;\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `grid`\n   --> /tmp/tmp_894560g.rs:26:20\n\
    \    |\n16  | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \    |             ---- move occurs because `grid` has type `Vec<Vec<isize>>`,\
    \ which does not implement the `Copy` trait\n...\n19  |     for row in grid {\n\
    \    |                ---- `grid` moved due to this implicit call to `.into_iter()`\n\
    ...\n26  |     let mut rows = grid.len();\n    |                    ^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `grid`\nhelp: consider iterating over a slice\
    \ of the `Vec<Vec<isize>>`'s content to avoid moving into the `for` loop\n   \
    \ |\n19  |     for row in &grid {\n    |                +\n\nerror[E0596]: cannot\
    \ borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmp_894560g.rs:32:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n32 |                 grid.remove(i);\n   |                 ^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `grid` as mutable, as\
    \ it is not declared as mutable\n  --> /tmp/tmp_894560g.rs:47:21\n   |\n16 | fn\
    \ max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |          \
    \   ---- help: consider changing this to be mutable: `mut grid`\n...\n47 |   \
    \                  grid[j].remove(i);\n   |                     ^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0382, E0596.\nFor more information about an error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // use max() to find the max-filled\
    \ column\n    // if a column is max-filled, fill it first\n    // if multiple\
    \ columns are max-filled, fill the column with largest sum\n    // if there are\
    \ multiple max-filled columns with the same sum, fill the one with the lowest\
    \ row first\n    let mut fill_times = 0;\n    let mut grid = grid;\n    let max_row\
    \ = grid.len();\n    let max_col = grid[0].len();\n    let mut sum_cols = vec![0;\
    \ max_col];\n    let mut max_row_cols = vec![0; max_col];\n    loop {\n      \
    \  for row in &grid {\n            let mut max_col = 0;\n            let mut max_sum\
    \ = 0;\n            for (i, cell) in row.iter().enumerate() {\n              \
    \  if *cell > 0 {\n                    sum_cols[i] += 1;\n                   \
    \ if sum_cols[i] > max_sum {\n                        max_sum = sum_cols[i];\n\
    \                        max_col = i;\n                    }\n               \
    \ }\n            }\n            if max_sum > 0 {\n                max_row_cols[max_col]\
    \ += 1;\n            }\n        }\n        let mut sum_col = 0;\n        let mut\
    \ max_row_col = 0;\n        let mut max_fill = 0;\n        for (i, col) in sum_cols.iter().enumerate()\
    \ {\n            if *col > max_fill {\n                max_fill = *col;\n    \
    \            sum_col = i;\n                max_row_col = max_row_cols[i];\n  \
    \          } else if *col == max_fill {\n                if max_row_cols[i] <\
    \ max_row_col {\n                    sum_col = i;\n                    max_row_col\
    \ = max_row_cols[i];\n                }\n            }\n        }\n        if\
    \ max_fill == 0 {\n            break;\n        }\n        fill_times += 1;\n \
    \       for row in &mut grid {\n            if row[sum_col] > 0 {\n          \
    \      row[sum_col] -= 1;\n}\n\nfn main() {\n    let candidate = max_fill;\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpj8wvgaz_.rs:75:3\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n27 |     loop {\n   |          - unclosed delimiter\n...\n63 |         for\
    \ row in &mut grid {\n   |                              - unclosed delimiter\n\
    64 |             if row[sum_col] > 0 {\n   |                                 -\
    \ this delimiter might not be properly closed...\n65 |                 row[sum_col]\
    \ -= 1;\n66 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n75 | }\n   |   ^\n\nerror[E0434]: can't capture dynamic environment in a\
    \ fn item\n  --> /tmp/tmpj8wvgaz_.rs:69:21\n   |\n69 |     let candidate = max_fill;\n\
    \   |                     ^^^^^^^^\n   |\n   = help: use the `|| { ... }` closure\
    \ form instead\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj8wvgaz_.rs:60:13\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                        ----- expected `isize`\
    \ because of return type\n...\n60 |             break;\n   |             ^^^^^\n\
    \   |             |\n   |             expected `isize`, found `()`\n   |     \
    \        help: give it a value of the expected type: `break 42`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0434.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ len = grid.len();\n    let row_len = grid[0].len();\n    let mut water = vec![0;\
    \ len];\n    let mut i = 0;\n    while i < len {\n        let mut row = vec![];\n\
    \        let mut j = 0;\n        while j < row_len {\n            if grid[i][j]\
    \ == 1 {\n                if row.len() != 0 {\n                    row.push(1\
    \ + water[i]);\n                } else {\n                    row.push(1);\n \
    \               }\n            } else {\n                row.push(0);\n      \
    \      }\n            j += 1;\n        }\n        if row.len() == 0 {\n      \
    \      break;\n        }\n        result += max_fill_per_row(row, capacity);\n\
    \        water[i] = row.iter().max().unwrap().clone();\n        i += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_fill_per_row` in this scope\n \
    \ --> /tmp/tmpozrxritq.rs:40:19\n   |\n40 |         result += max_fill_per_row(row,\
    \ capacity);\n   |                   ^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut col_count = 0;\n        for &col in row.iter()\
    \ {\n            if col == 1 {\n                col_count += 1;\n            }\
    \ else {\n                if col_count > 0 {\n                    if col_count\
    \ <= capacity {\n                        count += 1;\n                    } else\
    \ {\n                        count += (col_count / capacity);\n              \
    \          if col_count % capacity > 0 {\n                            count +=\
    \ 1;\n                        }\n                    }\n                    col_count\
    \ = 0;\n                }\n            }\n        }\n        if col_count > 0\
    \ {\n            if col_count <= capacity {\n                count += 1;\n   \
    \         } else {\n                count += (col_count / capacity);\n       \
    \         if col_count % capacity > 0 {\n                    count += 1;\n   \
    \             }\n            }\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut sum = 0;\n    for\
    \ row in grid {\n        sum += row.iter().sum::<isize>();\n    }\n    sum / capacity\
    \ + (sum % capacity) as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `2`', /tmp/tmp_6638c6f.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        count += row.iter().filter(|cell| **cell == 1).count()\
    \ as isize / capacity;\n        if row.iter().filter(|cell| **cell == 1).count()\
    \ as isize % capacity != 0 {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() {\n   \
    \     return 0;\n    }\n    let mut fills = 0;\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut column_maxes = vec![0; m];\n    for i in 0..n\
    \ {\n        for j in 0..m {\n            if grid[i][j] > column_maxes[j] {\n\
    \                column_maxes[j] = grid[i][j];\n            }\n        }\n   \
    \ }\n    for i in 0..n {\n        for j in 0..m {\n            if grid[i][j] <\
    \ column_maxes[j] {\n                fills += column_maxes[j] - grid[i][j];\n\
    \            }\n        }\n    }\n    fills\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmp2l9htkv0.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzqnl5hzq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut sum = 0;\n        for num in row {\n        \
    \    sum += num;\n        }\n        if sum > capacity {\n            count +=\
    \ (sum - 1) / capacity;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpg7t7ktav.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: -1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let row_count = grid.len();\n\
    \    let column_count = grid[0].len();\n    let mut grid = grid;\n    let mut\
    \ position = (0, 0);\n    let mut bucket = 0;\n    let mut fill_count = 0;\n \
    \   while position.0 < row_count {\n        if grid[position.0][position.1] >\
    \ 0 {\n            let diff = (capacity - bucket).min(grid[position.0][position.1]);\n\
    \            bucket += diff;\n            grid[position.0][position.1] -= diff;\n\
    \            fill_count += 1;\n        }\n        position.0 += 1;\n        if\
    \ position.0 == row_count {\n            position.0 = 0;\n            position.1\
    \ += 1;\n        }\n        if position.1 == column_count {\n            position.1\
    \ = 0;\n            bucket = 0;\n        }\n    }\n    fill_count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659977633
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // 1. We run a DFS on the\
    \ grid. If a bucket reaches the maximum capacity,\n    //    it is emptied and\
    \ we continue the search, otherwise we continue\n    //    filling the bucket.\n\
    \    // 2. When a bucket is emptied, we repeat the algorithm until all the\n \
    \   //    wells are empty.\n\n    // First, we need to flatten the grid in a single\
    \ vector\n    let grid = grid.iter().flatten().map(|v| *v).collect::<Vec<isize>>();\n\
    \    // Then, we set the capacity of the bucket\n    let capacity = capacity as\
    \ usize;\n    // Then, we run a DFS algorithm on the grid until all the wells\
    \ are empty\n    let mut iterations = 0;\n    let mut index = 0;\n    let grid_length\
    \ = grid.len();\n    while index < grid_length {\n        // println!(\"Iterations:\
    \ {}, index: {}\", iterations, index);\n        index = dfs(&grid, capacity, index);\n\
    \        iterations += 1;\n    }\n    iterations - 1\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `dfs` in this scope\n  --> /tmp/tmp0_usf8yw.rs:33:17\n\
    \   |\n33 |         index = dfs(&grid, capacity, index);\n   |               \
    \  ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut buckets = grid[0].len()\
    \ as isize;\n    let mut result = 0;\n    for row in grid {\n        let mut units\
    \ = 0;\n        for &unit in row.iter() {\n            units += unit;\n      \
    \  }\n        if units > buckets {\n            result += units / buckets;\n \
    \           buckets = (units % buckets) + buckets;\n        } else {\n       \
    \     buckets -= units;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpfst03r45.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        result += max_row_fill(row, capacity);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_row_fill` in this scope\n  -->\
    \ /tmp/tmpyzoto310.rs:19:19\n   |\n19 |         result += max_row_fill(row, capacity);\n\
    \   |                   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let h = grid.len();\n    let\
    \ w = grid[0].len();\n    let row_sums: Vec<_> = grid.iter().map(|r| r.iter().sum()).collect();\n\
    \    let mut result = 0;\n    for l in 0..w {\n        let mut filled = 0;\n \
    \       for r in l..w {\n            filled += row_sums[r];\n            if filled\
    \ < capacity {\n                continue;\n            }\n            for i in\
    \ 0..h {\n                let mut c = 0;\n                for j in l..=r {\n \
    \                   c += grid[i][j];\n                    if c == capacity {\n\
    \                        result += 1;\n                        break;\n      \
    \              }\n                }\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<_>`\n  --> /tmp/tmplyyrmczi.rs:19:19\n\
    \   |\n19 |     let row_sums: Vec<_> = grid.iter().map(|r| r.iter().sum()).collect();\n\
    \   |         --------  ^^^^^^ cannot infer type\n   |         |\n   |       \
    \  consider giving `row_sums` the explicit type `Vec<_>`, with the type parameters\
    \ specified\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut count = 0;\n    for col in 0..m {\n        for\
    \ row in 0..n {\n            if grid[row][col] == 1 {\n                count +=\
    \ 1;\n                let mut current_capacity = capacity;\n                for\
    \ i in row..n {\n                    if grid[i][col] == 1 {\n                \
    \        current_capacity -= 1;\n                        if current_capacity <\
    \ 0 {\n                            return -1;\n                        }\n   \
    \                 }\n                }\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `6`', /tmp/tmp8dlpurhw.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() {\n   \
    \     return 0;\n    }\n    let max_fill = capacity * grid.len() as isize;\n \
    \   let mut fill_space = vec![max_fill; grid[0].len()];\n    let mut result =\
    \ 0;\n    for row in grid {\n        for i in 0..row.len() {\n            fill_space[i]\
    \ -= row[i];\n            if fill_space[i] < 0 {\n                result += fill_space[i].abs();\n\
    \                fill_space[i] = 0;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpuml_nfam.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut operations = 0;\n\
    \    let mut curr_well = vec![0; grid[0].len()];\n    for well in grid {\n   \
    \     operations += 1;\n        for i in 0..well.len() {\n            if well[i]\
    \ == 1 {\n                curr_well[i] += 1;\n            }\n        }\n     \
    \   for i in 0..curr_well.len() {\n            if curr_well[i] > capacity {\n\
    \                curr_well[i] = 0;\n                operations += 1;\n       \
    \     }\n        }\n    }\n    operations\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmp_fl73rhd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let rows = grid.len();\n \
    \   let cols = grid[0].len();\n    let mut bucket_count = 0;\n    let mut row_full\
    \ = vec![false; rows];\n    let mut col_full = vec![false; cols];\n    let mut\
    \ max_fill_per_col = vec![0; cols];\n    for row in 0..rows {\n        for col\
    \ in 0..cols {\n            if grid[row][col] == 1 {\n                max_fill_per_col[col]\
    \ += 1;\n            }\n        }\n    }\n    for col in 0..cols {\n        if\
    \ max_fill_per_col[col] > capacity {\n            col_full[col] = true;\n    \
    \    }\n    }\n    for row in 0..rows {\n        for col in 0..cols {\n      \
    \      if col_full[col] {\n                grid[row][col] = 0;\n            }\n\
    \        }\n    }\n    for row in 0..rows {\n        let mut buckets_needed =\
    \ 0;\n        for col in 0..cols {\n            buckets_needed += grid[row][col];\n\
    \        }\n        let mut buckets_to_lower = buckets_needed / capacity;\n  \
    \      if buckets_needed % capacity != 0 {\n            buckets_to_lower += 1;\n\
    \        }\n        bucket_count += buckets_to_lower;\n        row_full[row] =\
    \ buckets_to_lower > 0;\n    }\n    for row in 0..rows {\n        for col in 0..cols\
    \ {\n            if row_full[row] {\n                grid[row][col] = 0;\n   \
    \         }\n        }\n    }\n    for col in 0..cols {\n        let mut buckets_needed\
    \ = 0;\n        for row in 0..rows {\n            buckets_needed += grid[row][col];\n\
    \        }\n        let mut buckets_to_lower = buckets_needed / capacity;\n  \
    \      if buckets_needed % capacity != 0 {\n            buckets_to_lower += 1;\n\
    \        }\n        bucket_count += buckets_to_lower;\n    }\n    bucket_count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmphaaopxw9.rs:38:17\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n38 |                 grid[row][col] = 0;\n \
    \  |                 ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmphaaopxw9.rs:57:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n57 |                 grid[row][col] = 0;\n   |                 ^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut fills = 0;\n    let mut bucket = vec![0; m];\n\
    \    for row in grid {\n        for (i, x) in row.iter().enumerate() {\n     \
    \       bucket[i] += x;\n            if bucket[i] >= capacity {\n            \
    \    fills += 1;\n                bucket[i] -= capacity;\n            }\n    \
    \    }\n    }\n    fills\n}\n\nfn main() {\n    let candidate = max_fill;\n  \
    \  assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `5`', /tmp/tmpdz4vsmtt.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill = 0;\n    let\
    \ mut cols: Vec<Vec<isize>> = Vec::new();\n    for _ in 0..grid[0].len() {\n \
    \       cols.push(Vec::new());\n    }\n    for row in grid {\n        for (col,\
    \ &well) in row.iter().enumerate() {\n            cols[col].push(well);\n    \
    \    }\n    }\n    for col in cols {\n        let mut first = true;\n        let\
    \ mut old_total = 0;\n        let mut running_total = 0;\n        for well in\
    \ col {\n            if well == 1 {\n                running_total += 1;\n   \
    \         } else {\n                if running_total != 0 {\n                \
    \    if first {\n                        old_total = running_total;\n        \
    \                first = false;\n                    } else {\n              \
    \          if running_total < old_total {\n                            old_total\
    \ = running_total;\n                        }\n                    }\n       \
    \             running_total = 0;\n                }\n            }\n        }\n\
    \        if running_total != 0 {\n            if first {\n                old_total\
    \ = running_total;\n            } else {\n                if running_total < old_total\
    \ {\n                    old_total = running_total;\n                }\n     \
    \       }\n        }\n        if old_total > capacity {\n            fill += 1;\n\
    \        }\n    }\n    fill\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmppfy5redo.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut fill_count = 0;\n    let mut empty_all = true;\n    while empty_all\
    \ {\n        empty_all = false;\n        for row in grid.iter_mut() {\n      \
    \      for cell in row.iter_mut() {\n                if *cell > 0 {\n        \
    \            *cell -= capacity;\n                    if *cell < 0 {\n        \
    \                *cell = 0;\n                    }\n                    empty_all\
    \ = true;\n                    fill_count += 1;\n                }\n         \
    \   }\n        }\n    }\n    fill_count\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp7hcs0ump.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    let\
    \ mut min_height = 0;\n    for row in grid {\n        let mut height = 0;\n  \
    \      for well in row {\n            if well == 1 {\n                height +=\
    \ 1;\n            }\n        }\n        min_height = min(min_height, height);\n\
    \        res += height;\n    }\n    res -= min_height * grid.len() as isize;\n\
    \    res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp7_v24a_f.rs:26:22\n\
    \   |\n26 |         min_height = min(min_height, height);\n   |              \
    \        ^^^\n...\n33 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n26 |\
    \         min_height = main(min_height, height);\n   |                      ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut res = 0;\n    while !grid.iter().all(|row| row.iter().all(|c| *c ==\
    \ 0)) {\n        let filled = fill(&mut grid, capacity);\n        if filled.is_none()\
    \ {\n            break;\n        }\n        res += 1;\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `fill` in this scope\n  --> /tmp/tmp85okfiuj.rs:20:22\n\
    \   |\n20 |         let filled = fill(&mut grid, capacity);\n   |            \
    \          ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut water = 0;\n    let\
    \ mut fill_count = 0;\n    for row in grid {\n        for &water_in_well in row\
    \ {\n            water += water_in_well;\n            if water < capacity {\n\
    \                continue;\n            }\n            fill_count += 1;\n    \
    \        water = 0;\n        }\n    }\n    fill_count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu1y5dji_.rs:20:13\n   |\n\
    20 |         for &water_in_well in row {\n   |             ^^^^^^^^^^^^^^    ---\
    \ this expression has type `Option<isize>`\n   |             |\n   |         \
    \    expected `isize`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `water_in_well`\n   |\n   = note:   expected type\
    \ `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977627
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ r in grid {\n        for c in r {\n            if c > 0 {\n                count\
    \ += (c - 1) / capacity + 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpmikanz3r.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut total = 0;\n    let\
    \ mut depth = vec![0; grid[0].len()];\n    for row in grid {\n        for i in\
    \ 0..row.len() {\n            depth[i] += row[i];\n        }\n        total +=\
    \ max_water_row(depth.clone(), capacity);\n    }\n    total\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_water_row` in this scope\n  -->\
    \ /tmp/tmpkwkog22u.rs:23:18\n   |\n23 |         total += max_water_row(depth.clone(),\
    \ capacity);\n   |                  ^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() {\n   \
    \     return 0;\n    }\n    let mut min_lines = vec![0; grid[0].len()];\n    for\
    \ i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j]\
    \ == 1 {\n                min_lines[j] += 1;\n            }\n        }\n    }\n\
    \    let mut total = 0;\n    for amount in min_lines {\n        total += ((amount\
    \ + capacity - 1) / capacity) - 1;\n    }\n    total\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmp_0ldnqn5.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut v = Vec::new();\n\
    \    let mut h = grid.len();\n    let mut w = grid[0].len();\n    let mut total\
    \ = 0;\n    for line in grid {\n        let mut max = 0;\n        for &val in\
    \ line.iter() {\n            if val > max {\n                max = val;\n    \
    \        }\n        }\n        v.push(max);\n        total += max;\n    }\n  \
    \  let mut counter = 0;\n    while total > 0 {\n        let mut max = 0;\n   \
    \     for &val in v.iter() {\n            if val > max {\n                max\
    \ = val;\n            }\n        }\n        for i in 0..h {\n            if v[i]\
    \ == max {\n                v[i] = 0;\n                total -= max;\n       \
    \     }\n        }\n        counter += 1;\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmp9qtxgplx.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let rows = grid.len();\n \
    \   let cols = grid[0].len();\n    let mut ans = 0;\n    for j in 0..cols {\n\
    \        let mut fill = 0;\n        for i in 0..rows {\n            if grid[i][j]\
    \ == 1 {\n                fill += 1;\n            }\n        }\n        ans +=\
    \ fill / capacity;\n        if fill % capacity != 0 {\n            ans += 1;\n\
    \        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6`,\n right: `5`', /tmp/tmpckpwz8h8.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut total = 0;\n    for (i, row) in grid.iter_mut().enumerate() {\n    \
    \    let max = match row.iter().max() {\n            Some(m) => *m,\n        \
    \    None => continue,\n        };\n        if max == 0 {\n            continue;\n\
    \        }\n        for j in 0..row.len() {\n            if row[j] > 0 {\n   \
    \             row[j] = 0;\n                total += 1;\n            }\n      \
    \  }\n        // pour water to lower rows\n        // (i-1) % grid.len() == i\n\
    \        for lower_index in (0..=i).rev() {\n            let lower_row = &mut\
    \ grid[lower_index % grid.len()];\n            for j in 0..lower_row.len() {\n\
    \                if max > 0 {\n                    let prev = lower_row[j];\n\
    \                    lower_row[j] = lower_row[j].min(capacity);\n            \
    \        max -= (lower_row[j] - prev);\n                }\n            }\n   \
    \     }\n    }\n    return total;\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpo2ton1cs.rs:41:28\n\
    \   |\n41 |                     max -= (lower_row[j] - prev);\n   |          \
    \                  ^                   ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n41 -                  \
    \   max -= (lower_row[j] - prev);\n41 +                     max -= lower_row[j]\
    \ - prev;\n   | \n\nerror[E0499]: cannot borrow `grid` as mutable more than once\
    \ at a time\n  --> /tmp/tmpo2ton1cs.rs:36:34\n   |\n19 |     for (i, row) in grid.iter_mut().enumerate()\
    \ {\n   |                     ---------------------------\n   |              \
    \       |\n   |                     first mutable borrow occurs here\n   |   \
    \                  first borrow later used here\n...\n36 |             let lower_row\
    \ = &mut grid[lower_index % grid.len()];\n   |                               \
    \   ^^^^ second mutable borrow occurs here\n\nerror[E0502]: cannot borrow `grid`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpo2ton1cs.rs:36:53\n\
    \   |\n19 |     for (i, row) in grid.iter_mut().enumerate() {\n   |          \
    \           ---------------------------\n   |                     |\n   |    \
    \                 mutable borrow occurs here\n   |                     mutable\
    \ borrow later used here\n...\n36 |             let lower_row = &mut grid[lower_index\
    \ % grid.len()];\n   |                                                     ^^^^^^^^^^\
    \ immutable borrow occurs here\n\nerror[E0384]: cannot assign twice to immutable\
    \ variable `max`\n  --> /tmp/tmpo2ton1cs.rs:41:21\n   |\n20 |         let max\
    \ = match row.iter().max() {\n   |             ---\n   |             |\n   | \
    \            first assignment to `max`\n   |             help: consider making\
    \ this binding mutable: `mut max`\n...\n41 |                     max -= (lower_row[j]\
    \ - prev);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign\
    \ twice to immutable variable\n\nerror: aborting due to 3 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0384, E0499, E0502.\nFor\
    \ more informa"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_height = 0;\n\
    \    for row in grid.iter() {\n        let height = row.iter().filter(|&&x| x\
    \ == 1).count() as isize;\n        max_height = isize::max(max_height, height);\n\
    \    }\n    let bucket_capacity = capacity * max_height;\n    let num_rows = grid.len()\
    \ as isize;\n    let num_cols = grid[0].len() as isize;\n    let mut min_rows\
    \ = isize::max_value();\n    let mut min_cols = isize::max_value();\n    let mut\
    \ row_cap = isize::max_value();\n    let mut col_cap = isize::max_value();\n \
    \   for row in grid.iter() {\n        let mut total = 0;\n        for &col in\
    \ row.iter() {\n            total += col;\n        }\n        if total > 0 {\n\
    \            min_rows = isize::min(min_rows, total);\n            row_cap = isize::min(row_cap,\
    \ bucket_capacity / total);\n        }\n    }\n    for j in 0..num_cols {\n  \
    \      let mut total = 0;\n        for i in 0..num_rows {\n            total +=\
    \ grid[i as usize][j as usize];\n        }\n        if total > 0 {\n         \
    \   min_cols = isize::min(min_cols, total);\n            col_cap = isize::min(col_cap,\
    \ bucket_capacity / total);\n        }\n    }\n    let min_rows = min_rows as\
    \ isize;\n    let min_cols = min_cols as isize;\n    let row_cap = row_cap as\
    \ isize;\n    let col_cap = col_cap as isize;\n    if min_rows == max_height &&\
    \ min_cols == max_height {\n        return (num_rows / min_rows) + (num_cols /\
    \ min_cols);\n    }\n    let mut left_rows = 0;\n    let mut left_cols = 0;\n\
    \    let mut total_rows = 0;\n    let mut total_cols = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9t5rjxv4.rs:16:56\n   |\n\
    16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    --------\
    \                                            ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::collections::HashSet;\n\
    \    let mut done = HashSet::new();\n    let mut bucket_count = 0;\n    while\
    \ done.len() < grid.len() {\n        let mut fill = capacity;\n        let mut\
    \ well_count = 0;\n        while fill > 0 {\n            let mut well_index =\
    \ -1;\n            for (i, row) in grid.iter().enumerate() {\n               \
    \ if done.contains(&i) {\n                    continue;\n                }\n \
    \               if let Some(c) = row.iter().find(|&&c| c == 1) {\n           \
    \         well_index = i;\n                    fill -= 1;\n                  \
    \  break;\n                }\n            }\n            if well_index == -1 {\n\
    \                break;\n            }\n            well_count += 1;\n       \
    \     done.insert(well_index);\n        }\n        if well_count > 0 {\n     \
    \       bucket_count += 1;\n        }\n    }\n    bucket_count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpjcq43kya.rs:24:34\n\
    \   |\n24 |             let mut well_index = -1;\n   |                       \
    \           ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpjcq43kya.rs:35:30\n\
    \   |\n35 |             if well_index == -1 {\n   |                          \
    \    ^^\n   |                              |\n   |                           \
    \   cannot apply unary operator `-`\n   |                              help: you\
    \ may have meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note:\
    \ unsigned values cannot be negated\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut max_row = vec![0; n];\n    let mut max_col =\
    \ vec![0; m];\n    for i in 0..n {\n        for j in 0..m {\n            max_row[i]\
    \ = std::cmp::max(max_row[i], grid[i][j]);\n            max_col[j] = std::cmp::max(max_col[j],\
    \ grid[i][j]);\n        }\n    }\n    let mut ans = 0;\n    for i in 0..n {\n\
    \        for j in 0..m {\n            ans += std::cmp::max(max_row[i], max_col[j])\
    \ - grid[i][j];\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `5`', /tmp/tmppizl90os.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzqnl5hzq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut wells: Vec<Vec<isize>>\
    \ = grid.iter().map(|w| w.clone()).collect();\n    let mut count = 0;\n    let\
    \ mut pos = 0;\n    let row_len = wells[0].len();\n    let col_len = wells.len();\n\
    \    while pos < row_len {\n        // find a well with water\n        let mut\
    \ well_pos = 0;\n        while well_pos < col_len && wells[well_pos][pos] == 0\
    \ {\n            well_pos += 1;\n        }\n        if well_pos == col_len {\n\
    \            // next position\n            pos += 1;\n            continue;\n\
    \        }\n        // fill a bucket with water from the well\n        let mut\
    \ water = 0;\n        for w in wells.iter_mut() {\n            if w[pos] > 0 {\n\
    \                water += 1;\n                w[pos] -= 1;\n            }\n  \
    \      }\n        count += 1;\n        // spread water to the left\n        pos\
    \ = pos.saturating_sub(1);\n        let mut spread = water;\n        while spread\
    \ > 0 && pos >= 0 {\n            let mut to_spread = spread;\n            for\
    \ w in wells.iter_mut() {\n                if w[pos] == 0 {\n                \
    \    w[pos] += 1;\n                    to_spread -= 1;\n                }\n  \
    \          }\n            if to_spread == spread {\n                // stop spreading\
    \ water to the left\n                break;\n            }\n            count\
    \ += 1;\n            spread = to_spread;\n            pos = pos.saturating_sub(1);\n\
    \        }\n        // spread water to the right\n        pos = pos.saturating_add(1);\n\
    \        spread = water;\n        while spread > 0 && pos < row_len {\n      \
    \      let mut to_spread = spread;\n            for w in wells.iter_mut() {\n\
    \                if w[pos] == 0 {\n                    w[pos] += 1;\n        \
    \            to_spread -= 1;\n                }\n            }\n            if\
    \ to_spread == spread {\n                // stop spreading water to the right\n\
    \                break;\n            }\n            count += 1;\n            spread\
    \ = to\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu8h4pxdr.rs:87:3\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |                                                              - unclosed delimiter\n\
    ...\n22 |     while pos < row_len {\n   |                         - unclosed delimiter\n\
    ...\n64 |         while spread > 0 && pos < row_len {\n   |                  \
    \                         - this delimiter might not be properly closed...\n...\n\
    78 | }\n   | - ...as it matches this but it has different indentation\n...\n87\
    \ | }\n   |   ^\n\nerror[E0425]: cannot find value `to` in this scope\n  --> /tmp/tmpu8h4pxdr.rs:77:22\n\
    \   |\n77 |             spread = to\n   |                      ^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu8h4pxdr.rs:22:5\n\
    \   |\n16 |   fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n\
    \   |                                                          ----- expected\
    \ `isize` because of return type\n...\n22 | /     while pos < row_len {\n23 |\
    \ |         // find a well with water\n24 | |         let mut well_pos = 0;\n\
    25 | |         while well_pos < col_len && wells[well_pos][pos] == 0 {\n...  |\n\
    86 | |     assert_eq!(candidate(vec![vec![1, 1, 1, 1], vec![1, 1, 1, 1]], 9),\
    \ 2);\n87 | | }\n   | |__^ expected `isize`, found `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut levels = vec![0; grid.len()];\n\
    \    for row in &grid {\n        for i in 0..row.len() {\n            levels[i]\
    \ += row[i];\n        }\n    }\n    let mut fill_count = 0;\n    let mut max_level\
    \ = 0;\n    for level in &levels {\n        max_level = max_level.max(*level);\n\
    \        if max_level == capacity {\n            fill_count += 1;\n          \
    \  max_level = 0;\n        }\n    }\n    fill_count + 1\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmpygjnxn5n.rs:20:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let nrows = grid.len();\n\
    \    let ncols = grid[0].len();\n    let mut fill = Vec::with_capacity(nrows);\n\
    \    for i in 0..nrows {\n        let mut row_fill = Vec::with_capacity(ncols);\n\
    \        for j in 0..ncols {\n            if grid[i][j] == 1 {\n             \
    \   row_fill.push(capacity);\n            } else {\n                row_fill.push(0);\n\
    \            }\n        }\n        fill.push(row_fill);\n    }\n    let mut moves\
    \ = 0;\n    for i in 1..nrows {\n        for j in 0..ncols {\n            let\
    \ water = fill[i-1][j];\n            if water > 0 {\n                let bucket\
    \ = capacity - water;\n                let mut k = i;\n                while k\
    \ < nrows && fill[k][j] < bucket {\n                    fill[k][j] += water;\n\
    \                    k += 1;\n                }\n                moves += 1;\n\
    \            }\n        }\n    }\n    moves\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmp0v53qjtd.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut bucket_level = vec![0;\
    \ grid[0].len()];\n    let mut count = 0;\n    for i in 0..grid.len() {\n    \
    \    for j in 0..grid[i].len() {\n            if grid[i][j] == 1 {\n         \
    \       bucket_level[j] += 1;\n            }\n        }\n        let mut j = 0;\n\
    \        while j < bucket_level.len() {\n            if bucket_level[j] <= capacity\
    \ {\n                j += 1;\n            } else {\n                if j == 0\
    \ {\n                    bucket_level[j] -= capacity;\n                    count\
    \ += 1;\n                } else {\n                    let mut k = j;\n      \
    \              while k >= 0 && bucket_level[k] > capacity {\n                \
    \        bucket_level[k] -= capacity;\n                        k -= 1;\n     \
    \               }\n                    j = k + 1;\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpmb6jkwgq.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    let\
    \ mut copy = grid.clone();\n    while !copy.is_empty() {\n        let col_sum\
    \ = col_sum(&copy);\n        let fill_times = empty_col(&mut copy, capacity, &col_sum);\n\
    \        count += fill_times;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `col_sum` in this scope\n  --> /tmp/tmpkvuguxs0.rs:20:23\n\
    \   |\n20 |         let col_sum = col_sum(&copy);\n   |                      \
    \ ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `empty_col`\
    \ in this scope\n  --> /tmp/tmpkvuguxs0.rs:21:26\n   |\n21 |         let fill_times\
    \ = empty_col(&mut copy, capacity, &col_sum);\n   |                          ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut depths = Vec::new();\n\
    \    for row in grid {\n        let mut next_depth = 0;\n        for unit in row\
    \ {\n            next_depth += unit;\n        }\n        depths.push(next_depth);\n\
    \    }\n    depths.sort();\n    let mut water = depths.iter().sum::<isize>();\n\
    \    let mut count = 0;\n    while water > 0 {\n        water -= capacity;\n \
    \       count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpy7yzj6d0.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let (rows, cols) = (grid.len(),\
    \ grid[0].len());\n    let max_h = rows as isize;\n    let mut ans = 0;\n    let\
    \ mut col_filled = vec![0; cols];\n    for (i, row) in grid.iter().enumerate()\
    \ {\n        let max_in_row = row.iter().max().unwrap();\n        let (max_in_row,\
    \ row_filled) = if *max_in_row > capacity {\n            (capacity, 0)\n     \
    \   } else {\n            (*max_in_row, *max_in_row)\n        };\n        let\
    \ overflow = max_in_row - (col_filled[i] - capacity * i as isize);\n        ans\
    \ += overflow;\n        col_filled = col_filled.iter().map(|c| c - capacity).collect();\n\
    \        for j in 0..cols {\n            col_filled[j] += row[j] - row_filled;\n\
    \        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `11`,\n right: `6`', /tmp/tmp66bum8xu.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    for\
    \ row in grid {\n        for &elem in row.iter() {\n            if elem > 0 {\n\
    \                result += 1;\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmp5esw1u3l.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut moves = 0;\n    for r in 0..grid.len() {\n        for c in 0..grid[r].len()\
    \ {\n            if grid[r][c] > 0 {\n                if grid[r][c] > capacity\
    \ {\n                    moves += capacity;\n                    grid[r][c] -=\
    \ capacity;\n                } else {\n                    moves += grid[r][c];\n\
    \                    grid[r][c] = 0;\n                }\n            }\n     \
    \   }\n    }\n    moves\n}\n\nfn main() {\n    let candidate = max_fill;\n   \
    \ assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1,\
    \ 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0, 0,\
    \ 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpcnp5lpqq.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut num_times = 0;\n \
    \   let wells_num = grid.len();\n    for well in grid {\n        num_times +=\
    \ well.iter().sum::<isize>() / capacity;\n    }\n    num_times / wells_num\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnlr2x0kr.rs:22:17\n   |\n\
    22 |     num_times / wells_num\n   |                 ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n  --> /tmp/tmpnlr2x0kr.rs:22:15\n\
    \   |\n22 |     num_times / wells_num\n   |               ^ no implementation\
    \ for `isize / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut max_row = grid.iter().map(|row| row.iter().sum::<isize>()).max().unwrap();\n\
    \    while max_row > 0 {\n        result += 1;\n        max_row = 0;\n       \
    \ for i in 0..grid.len() {\n            for j in 0..grid[i].len() {\n        \
    \        if grid[i][j] > 0 {\n                    grid[i][j] -= capacity;\n  \
    \                  if grid[i][j] < 0 {\n                        grid[i][j] = 0;\n\
    \                    }\n                    max_row = max_row.max(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpezppjkug.rs:25:21\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n25 |                     grid[i][j] -= capacity;\n\
    \   |                     ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpezppjkug.rs:27:25\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n27 |                         grid[i][j] = 0;\n   |                      \
    \   ^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut full = vec![0; grid.len()];\n\
    \    let mut empty = vec![0; grid.len()];\n    let mut last_fill = 0;\n    let\
    \ mut last_empty = 0;\n    let mut max_fill = 0;\n    let mut max_empty = 0;\n\
    \    for (i, row) in grid.iter().enumerate() {\n        for cell in row.iter()\
    \ {\n            if *cell == 1 {\n                last_fill += 1;\n          \
    \      last_empty = 0;\n            } else {\n                last_empty += 1;\n\
    \                last_fill = 0;\n            }\n            if last_fill > max_fill\
    \ {\n                max_fill = last_fill;\n            }\n            if last_empty\
    \ > max_empty {\n                max_empty = last_empty;\n            }\n    \
    \    }\n        empty[i] = last_empty;\n        full[i] = last_fill;\n       \
    \ last_fill = 0;\n        last_empty = 0;\n    }\n    let mut result = 0;\n  \
    \  for (i, x) in full.iter().enumerate() {\n        for y in empty.iter() {\n\
    \            if *x + *y >= capacity {\n                result += 1;\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `6`', /tmp/tmp07hshhx_.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_height = 0;\n\
    \    for row in grid {\n        max_height = max_height.max(max_in_row(&row));\n\
    \    }\n    let mut row_max_heights = vec![0; grid.len()];\n    for row in 0..grid.len()\
    \ {\n        row_max_heights[row] = max_in_row(&grid[row]);\n    }\n    let mut\
    \ current_height = max_height;\n    let mut times = 0;\n    while current_height\
    \ > 0 {\n        let mut row = 0;\n        for height in &row_max_heights {\n\
    \            if *height >= current_height {\n                row += 1;\n     \
    \       }\n        }\n        let amount = min(capacity, row);\n        if amount\
    \ > 0 {\n            times += 1;\n            for row in 0..row_max_heights.len()\
    \ {\n                row_max_heights[row] -= min(amount, row_max_heights[row]);\n\
    \            }\n        }\n        current_height -= 1;\n    }\n    times\n}\n\
    \nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max_in_row` in this scope\n  --> /tmp/tmpgdrfudee.rs:19:37\n\
    \   |\n19 |         max_height = max_height.max(max_in_row(&row));\n   |     \
    \                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `max_in_row` in this scope\n  --> /tmp/tmpgdrfudee.rs:23:32\n\
    \   |\n23 |         row_max_heights[row] = max_in_row(&grid[row]);\n   |     \
    \                           ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmpgdrfudee.rs:34:22\n\
    \   |\n34 |         let amount = min(capacity, row);\n   |                   \
    \   ^^^\n...\n46 | fn main() {\n   | --------- similarly named function `main`\
    \ defined here\n   |\nhelp: a function with a similar name exists\n   |\n34 |\
    \         let amount = main(capacity, row);\n   |                      ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpgdrfudee.rs:38:41\n\
    \   |\n38 |                 row_max_heights[row] -= min(amount, row_max_heights[row]);\n\
    \   |                                         ^^^\n...\n46 | fn main() {\n   |\
    \ --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n38 |                 row_max_heights[row]\
    \ -= main(amount, row_max_heights[row]);\n   |                               \
    \          ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut state = vec![capacity;\
    \ grid[0].len()];\n    let mut n = 0;\n    for row in grid {\n        for (i,\
    \ a) in row.iter().enumerate() {\n            let b = state[i];\n            if\
    \ a == 0 && b < capacity {\n                n += 1;\n                state[i]\
    \ = capacity;\n            } else if a == 1 && b > 0 {\n                state[i]\
    \ -= 1;\n            }\n        }\n    }\n    n\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmped79q8dp.rs:22:18\n\
    \   |\n22 |             if a == 0 && b < capacity {\n   |                  ^^\
    \ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `{integer}`\n  --> /tmp/tmped79q8dp.rs:25:25\n   |\n25 |             }\
    \ else if a == 1 && b > 0 {\n   |                         ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let (n, m) = (grid.len(),\
    \ grid[0].len());\n    let mut count = 0;\n    let mut column_excess = vec![0;\
    \ m];\n    let mut row_excess = 0;\n    for i in 0..n {\n        for j in 0..m\
    \ {\n            if grid[i][j] == 1 {\n                column_excess[j] += 1;\n\
    \                row_excess += 1;\n            }\n        }\n        if column_excess[m\
    \ - 1] > capacity {\n            return -1;\n        }\n        let mut max_filled\
    \ = column_excess[m - 1];\n        for j in (0..m - 1).rev() {\n            max_filled\
    \ = min(max_filled, column_excess[j]);\n            column_excess[j] = max_filled;\n\
    \        }\n        if row_excess > capacity {\n            return -1;\n     \
    \   }\n        if row_excess < capacity {\n            count += capacity - row_excess;\n\
    \        }\n        row_excess = 0;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpmkcsf0nt.rs:33:26\n\
    \   |\n33 |             max_filled = min(max_filled, column_excess[j]);\n   |\
    \                          ^^^\n...\n47 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n33 |             max_filled = main(max_filled, column_excess[j]);\n\
    \   |                          ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut solution = 0;\n    let mut water = 0;\n    let\
    \ mut finished = vec![vec![false; m]; n];\n    let mut rows_finished = vec![false;\
    \ n];\n    loop {\n        let mut empty_row = n;\n        let mut empty_column\
    \ = n;\n        for i in 0..n {\n            if rows_finished[i] {\n         \
    \       continue;\n            }\n            let mut empty_column = n;\n    \
    \        for j in 0..m {\n                if finished[i][j] {\n              \
    \      continue;\n                }\n                if grid[i][j] == 0 {\n  \
    \                  empty_column = j;\n                    break;\n           \
    \     }\n            }\n            if empty_column == n {\n                rows_finished[i]\
    \ = true;\n                continue;\n            }\n            empty_row = i;\n\
    \            break;\n        }\n        if empty_row == n {\n            break;\n\
    \        }\n        let mut buckets = vec![0; n];\n        for i in 0..n {\n \
    \           if finished[i][empty_column] {\n                continue;\n      \
    \      }\n            if grid[i][empty_column] == 0 {\n                buckets[i]\
    \ = capacity;\n            }\n        }\n        for j in empty_column+1..m {\n\
    \            for i in 0..n {\n                if finished[i][j] {\n          \
    \          continue;\n                }\n                if buckets[i] == 0 {\n\
    \                    continue;\n                }\n                if grid[i][j]\
    \ > 0 {\n                    let mut fill = std::cmp::min(buckets[i], grid[i][j]);\n\
    \                    buckets[i] -= fill;\n                    grid[i][j] -= fill;\n\
    \                    water += fill;\n                    if grid[i][j] == 0 {\n\
    \                        finished[i][j] = true;\n                    }\n     \
    \           }\n            }\n        }\n        solution += 1;\n    }\n    solution\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `water` is assigned to, but never used\n  --> /tmp/tmpsgikceju.rs:20:13\n\
    \   |\n20 |     let mut water = 0;\n   |             ^^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_water` instead\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpsgikceju.rs:25:13\n   |\n25 |   \
    \      let mut empty_column = n;\n   |             ----^^^^^^^^^^^^\n   |    \
    \         |\n   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpsgikceju.rs:68:25\n\
    \   |\n68 |                     let mut fill = std::cmp::min(buckets[i], grid[i][j]);\n\
    \   |                         ----^^^^\n   |                         |\n   | \
    \                        help: remove this `mut`\n\nerror[E0596]: cannot borrow\
    \ `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpsgikceju.rs:70:21\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n70 |                     grid[i][j] -= fill;\n   |                     ^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error; 3 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut lowered = 0;\n   \
    \ for _ in 0..capacity {\n        let mut row_max = 0;\n        for row in &grid\
    \ {\n            let mut max = 0;\n            for value in row {\n          \
    \      if *value > max {\n                    max = *value;\n                }\n\
    \            }\n            if max > row_max {\n                row_max = max;\n\
    \            }\n        }\n        if row_max == 0 {\n            break;\n   \
    \     }\n        lowered += 1;\n        for row in &mut grid {\n            for\
    \ value in row {\n                if *value > 0 {\n                    *value\
    \ -= 1;\n                }\n            }\n        }\n    }\n    lowered\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpdvypb3k7.rs:35:20\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n35 |         for row in &mut grid {\n   |  \
    \                  ^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut max_water_level = 0;\n    for i in 0..n {\n\
    \        for j in 0..m {\n            max_water_level = std::cmp::max(max_water_level,\
    \ grid[i][j]);\n        }\n    }\n    let mut water_level = max_water_level;\n\
    \    let mut result = 0;\n    while water_level > 0 {\n        let mut unit_level\
    \ = water_level - 1;\n        while unit_level >= 0 {\n            let mut column_level\
    \ = 0;\n            for i in 0..n {\n                for j in 0..m {\n       \
    \             if grid[i][j] > unit_level {\n                        column_level\
    \ += 1;\n                    }\n                }\n                if column_level\
    \ > capacity {\n                    break;\n                }\n            }\n\
    \            if column_level <= capacity {\n                break;\n         \
    \   }\n            unit_level -= 1;\n        }\n        for i in 0..n {\n    \
    \        for j in 0..m {\n                if grid[i][j] > unit_level {\n     \
    \               grid[i][j] -= 1;\n                }\n            }\n        }\n\
    \        water_level = unit_level;\n        result += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpj76ilbp6.rs:49:21\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n49 |                     grid[i][j] -= 1;\n\
    \   |                     ^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let (rows, cols) = (grid.len(),\
    \ grid[0].len());\n    let mut result = 0;\n    for r in 0..rows {\n        for\
    \ c in 0..cols {\n            if grid[r][c] == 1 {\n                result +=\
    \ 1;\n                let mut c2 = c + 1;\n                let mut capacity =\
    \ capacity;\n                while c2 < cols && capacity > 0 {\n             \
    \       capacity -= grid[r][c2];\n                    grid[r][c2] = capacity.max(0);\n\
    \                    c2 += 1;\n                }\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpy28redg5.rs:27:21\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n27 |                     grid[r][c2] = capacity.max(0);\n\
    \   |                     ^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut depth = 0;\n    let\
    \ mut current_row = 0;\n    while current_row < grid.len() {\n        let mut\
    \ bucket = capacity;\n        let mut current_column = 0;\n        while current_column\
    \ < grid[current_row].len() {\n            bucket -= grid[current_row][current_column];\n\
    \            if bucket < 0 {\n                depth += 1;\n                bucket\
    \ = capacity;\n            }\n            current_column += 1;\n        }\n  \
    \      current_row += 1;\n    }\n    depth\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpoebwfnhs.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n_row = grid.len();\n\
    \    let n_col = grid[0].len();\n    let mut buckets = vec![capacity; n_col];\n\
    \    let mut times = 0;\n    for row in grid {\n        let mut i = 0;\n     \
    \   while i < n_col {\n            // do nothing if this bucket is empty\n   \
    \         if buckets[i] == 0 {\n                i += 1;\n                continue;\n\
    \            }\n            // fill this well if possible\n            if row[i]\
    \ == 1 {\n                buckets[i] -= 1;\n                i += 1;\n        \
    \        continue;\n            }\n            // try to find the next well to\
    \ fill\n            let mut max_well = 0;\n            let mut max_well_idx =\
    \ i;\n            while i < n_col && row[i] == 0 {\n                if buckets[i]\
    \ > max_well {\n                    max_well = buckets[i];\n                 \
    \   max_well_idx = i;\n                }\n                i += 1;\n          \
    \  }\n            // move the max_well bucket to the left\n            for j in\
    \ max_well_idx..i {\n                if j == max_well_idx {\n                \
    \    continue;\n                }\n                buckets[j] = buckets[j - 1];\n\
    \            }\n            buckets[max_well_idx] = max_well;\n            //\
    \ fill the previous well if possible\n            if row[max_well_idx - 1] ==\
    \ 1 {\n                buckets[max_well_idx - 1] -= 1;\n            }\n      \
    \  }\n        times += 1;\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpfb4vk23v.rs:54:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let max_per_row = |r: &Vec<isize>|\
    \ r.iter().fold(0, |s, &x| s + x);\n    let num_rows = grid.len();\n    let num_cols\
    \ = grid[0].len();\n    let mut current_level = 0;\n    let mut num_lowers = 0;\n\
    \    while current_level < num_rows {\n        let wells_at_level = grid.iter().filter(|r|\
    \ max_per_row(r) > current_level).count();\n        let wells_to_empty = num_rows\
    \ - wells_at_level;\n        let current_water = num_cols * (current_level + 1);\n\
    \        let empties_per_lower = capacity / current_water;\n        let num_lowers_at_level\
    \ = (wells_to_empty as f64 / empties_per_lower as f64).ceil() as isize;\n    \
    \    num_lowers += num_lowers_at_level;\n        current_level += 1;\n    }\n\
    \    num_lowers\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnuyhqv_t.rs:23:70\n   |\n\
    23 |         let wells_at_level = grid.iter().filter(|r| max_per_row(r) > current_level).count();\n\
    \   |                                                                      ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n23 |         let\
    \ wells_at_level = grid.iter().filter(|r| max_per_row(r) > current_level.try_into().unwrap()).count();\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnuyhqv_t.rs:26:44\n\
    \   |\n26 |         let empties_per_lower = capacity / current_water;\n   |  \
    \                                          ^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n  --> /tmp/tmpnuyhqv_t.rs:26:42\n\
    \   |\n26 |         let empties_per_lower = capacity / current_water;\n   |  \
    \                                        ^ no implementation for `isize / usize`\n\
    \   |\n   = help: the trait `Div<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Div<Rhs>`:\n             <&'a\
    \ f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n             <&'a i128\
    \ as Div<i128>>\n             <&'a i16 as Div<i16>>\n             <&'a i32 as\
    \ Div<i32>>\n             <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n\
    \             <&'a isize as Div<isize>>\n           and 54 others\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let row_count = grid.len();\n\
    \    let col_count = grid[0].len();\n    let mut filled = 0;\n    for row in 0..row_count\
    \ {\n        for col in 0..col_count {\n            let needed = grid[row][col];\n\
    \            if needed == 0 {\n                continue;\n            }\n    \
    \        let left = if col > 0 {\n                grid[row][col - 1]\n       \
    \     } else {\n                0\n            };\n            let above = if\
    \ row > 0 {\n                grid[row - 1][col]\n            } else {\n      \
    \          0\n            };\n            if needed <= capacity - left {\n   \
    \             grid[row][col - 1] += needed;\n            } else if needed <= capacity\
    \ - above {\n                grid[row - 1][col] += needed;\n            } else\
    \ {\n                filled += 1;\n            }\n        }\n    }\n    filled\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp2nmgda_h.rs:37:17\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n37 |                 grid[row][col - 1] += needed;\n\
    \   |                 ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmp2nmgda_h.rs:39:17\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n39 |                 grid[row - 1][col] += needed;\n   |                \
    \ ^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let rows = grid.len();\n \
    \   let mut water = 0;\n    for row in grid {\n        let mut s = 0;\n      \
    \  for cell in row {\n            if cell == 1 {\n                s += 1;\n  \
    \          } else {\n                s = 0;\n            }\n            water\
    \ += 1;\n            if s >= capacity {\n                break;\n            }\n\
    \        }\n    }\n    (water + rows - 1) / rows\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiuhm0bhm.rs:33:5\n   |\n\
    16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n   |    \
    \                                                    ----- expected `isize` because\
    \ of return type\n...\n33 |     (water + rows - 1) / rows\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n33 |     ((water\
    \ + rows - 1) / rows).try_into().unwrap()\n   |     +                        \
    \ +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzqnl5hzq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut times = 0;\n    let\
    \ mut max_height = 0;\n    let mut rows = grid.len();\n    while rows > 0 {\n\
    \        let mut max_col = 0;\n        for row in grid.iter() {\n            let\
    \ max_in_row = row.iter().max().unwrap();\n            if max_in_row > &max_height\
    \ {\n                max_height = *max_in_row;\n                max_col = row.iter().position(|x|\
    \ x == max_in_row).unwrap();\n            }\n        }\n        let mut max_row\
    \ = grid.iter().position(|x| x[max_col] == max_height).unwrap();\n        while\
    \ max_row < rows {\n            times += 1;\n            grid[max_row][max_col]\
    \ -= capacity;\n            let diff = max_height - grid[max_row][max_col];\n\
    \            if diff > 0 {\n                for row in 0..max_row {\n        \
    \            grid[row][max_col] -= diff;\n                }\n            }\n \
    \           if grid[max_row][max_col] <= 0 {\n                rows = max_row;\n\
    \            }\n            max_row += 1;\n        }\n    }\n    times\n}\n\n\
    fn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `grid` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpqdb11nh1.rs:32:13\n   |\n16 | fn max_fill(grid: Vec<Vec<isize>>,\
    \ capacity: isize) -> isize {\n   |             ---- help: consider changing this\
    \ to be mutable: `mut grid`\n...\n32 |             grid[max_row][max_col] -= capacity;\n\
    \   |             ^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `grid` as mutable, as it is not declared as mutable\n  --> /tmp/tmpqdb11nh1.rs:36:21\n\
    \   |\n16 | fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n \
    \  |             ---- help: consider changing this to be mutable: `mut grid`\n\
    ...\n36 |                     grid[row][max_col] -= diff;\n   |              \
    \       ^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        let mut filled = 0;\n        for &elem in row.iter()\
    \ {\n            if elem == 1 {\n                filled += 1;\n            }\n\
    \            if filled == capacity {\n                filled = 0;\n          \
    \      count += 1;\n            }\n        }\n        if filled > 0 {\n      \
    \      count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut drops = 0;\n    for\
    \ row in grid {\n        for (i, &well) in row.iter().enumerate() {\n        \
    \    if well == 1 {\n                if i == 0 {\n                    drops +=\
    \ 1;\n                } else if row[i - 1] == 0 {\n                    drops +=\
    \ 1;\n                }\n            }\n        }\n    }\n    drops / capacity\
    \ as isize\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpfzixxcfp.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    grid.iter().map(|row| row.iter().filter(|&&c|\
    \ c == 1).count() as isize).sum::<isize>()\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `9`,\n right: `5`', /tmp/tmpfmvnw6l_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut heights = grid.iter().map(|row|\
    \ *row.iter().max().unwrap()).collect::<Vec<isize>>();\n    let mut count = 0;\n\
    \    loop {\n        if heights.iter().max().unwrap() == &0 {\n            break;\n\
    \        }\n        let mut max_height = 0;\n        for i in 0..heights.len()\
    \ {\n            let height = heights[i];\n            if height == 0 {\n    \
    \            continue;\n            }\n            heights[i] = height - capacity;\n\
    \            max_height = height;\n        }\n        count += 1;\n        if\
    \ max_height - capacity < 0 {\n            break;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `6`', /tmp/tmppctb8pi6.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut ret = 0;\n    let\
    \ mut counter = 0;\n    let row_count = grid.len();\n    let column_count = grid[0].len();\n\
    \    let mut wells = Vec::with_capacity(row_count);\n    for row in grid {\n \
    \       let filled = capacity * column_count - row.iter().sum::<isize>();\n  \
    \      wells.push(filled);\n        counter += filled;\n    }\n    while counter\
    \ > 0 {\n        counter = 0;\n        let mut new_wells = Vec::with_capacity(row_count);\n\
    \        for i in 0..row_count {\n            let filled = capacity - wells[i];\n\
    \            if i > 0 {\n                if wells[i - 1] > filled {\n        \
    \            new_wells.push(filled);\n                    counter += wells[i -\
    \ 1] - filled;\n                } else {\n                    new_wells.push(wells[i\
    \ - 1]);\n                    counter += wells[i - 1];\n                }\n  \
    \          } else {\n                new_wells.push(filled);\n               \
    \ counter += filled;\n            }\n        }\n        wells = new_wells;\n \
    \       ret += 1;\n    }\n    ret\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphccbkyg9.rs:23:33\n   |\n\
    23 |         let filled = capacity * column_count - row.iter().sum::<isize>();\n\
    \   |                                 ^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot multiply `isize` by `usize`\n  --> /tmp/tmphccbkyg9.rs:23:31\n\
    \   |\n23 |         let filled = capacity * column_count - row.iter().sum::<isize>();\n\
    \   |                               ^ no implementation for `isize * usize`\n\
    \   |\n   = help: the trait `Mul<usize>` is not implemented for `isize`\n   =\
    \ help: the following other types implement trait `Mul<Rhs>`:\n             <&'a\
    \ f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128\
    \ as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as\
    \ Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ row in grid {\n        count += row.iter().sum::<isize>() / capacity;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpjqci3r3a.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let m = grid.len();\n    let\
    \ n = grid[0].len();\n    let mut grid = grid;\n    let mut count = 0;\n    for\
    \ i in 0..m {\n        count += fill_row(&mut grid, i, capacity);\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `fill_row` in this scope\n  --> /tmp/tmp9wnxluqt.rs:22:18\n\
    \   |\n22 |         count += fill_row(&mut grid, i, capacity);\n   |         \
    \         ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut wells = grid.clone();\n\
    \    let mut result = 0;\n    loop {\n        if wells.iter().all(|r| r.iter().all(|&w|\
    \ w == 0)) {\n            break;\n        }\n        result += 1;\n        for\
    \ row in wells.iter_mut() {\n            let empty = row.iter().filter(|&&w| w\
    \ > 0).count();\n            let mut filled = 0;\n            for x in row.iter_mut()\
    \ {\n                if *x > 0 {\n                    *x -= 1;\n             \
    \       filled += 1;\n                }\n                if filled == capacity\
    \ {\n                    break;\n                }\n            }\n          \
    \  if filled < capacity {\n                for x in row.iter_mut().rev().take(empty\
    \ - filled) {\n                    *x += 1;\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0xipqqf.rs:37:60\n   |\n\
    37 |                 for x in row.iter_mut().rev().take(empty - filled) {\n  \
    \ |                                                            ^^^^^^ expected\
    \ `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n\
    \  --> /tmp/tmpl0xipqqf.rs:37:58\n   |\n37 |                 for x in row.iter_mut().rev().take(empty\
    \ - filled) {\n   |                                                          ^\
    \ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    for\
    \ i in 0..grid.len() {\n        let mut next_row = 0;\n        for j in 0..grid[i].len()\
    \ {\n            if grid[i][j] == 1 {\n                let mut next_fill = next_row.max(grid[i][j]);\n\
    \                let mut extract_up = (next_fill - grid[i][j]).max(0);\n     \
    \           next_row += grid[i][j] - extract_up;\n                res += extract_up;\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `6`', /tmp/tmpidhres6p.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_height = 0;\n\
    \    for row in grid {\n        let max_row_height = row.iter().sum();\n     \
    \   if max_row_height > max_height {\n            max_height = max_row_height;\n\
    \        }\n    }\n    let mut num_full_buckets = max_height / capacity;\n   \
    \ let mut water_left_over = max_height % capacity;\n    while water_left_over\
    \ > 0 {\n        water_left_over -= capacity;\n        num_full_buckets += 1;\n\
    \    }\n    num_full_buckets\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmptf277fi1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    grid.iter().fold(0, |sum,\
    \ well| {\n        sum + (well.iter().sum::<isize>() / capacity) +\n        if\
    \ well.iter().sum::<isize>() % capacity > 0 { 1 } else { 0 }\n    })\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // the length of the wells\n\
    \    let mut well_len = grid[0].len();\n    let mut ans = 0;\n    while well_len\
    \ > 0 {\n        // the index to start filling\n        let mut start = 0;\n \
    \       // the index to finish filling\n        let mut end = 0;\n        for\
    \ i in 0..grid.len() {\n            // fill the wells until the first 0 is encountered\n\
    \            if grid[i][well_len - 1] == 1 {\n                end = i;\n     \
    \       } else {\n                // only keep up filling until the first 0 is\
    \ encountered\n                break;\n            }\n        }\n        // fill\
    \ from index 0\n        while start < grid.len() {\n            // we already\
    \ filled all the wells\n            if end >= grid.len() {\n                break;\n\
    \            }\n            // fill the wells between start and end\n        \
    \    // the distance between start and end should be kept at the capacity\n  \
    \          let mut j = start;\n            let mut filled = 0;\n            while\
    \ j <= end {\n                filled += grid[j][well_len - 1];\n             \
    \   j += 1;\n            }\n            if filled < capacity {\n             \
    \   end += 1;\n            } else {\n                // if the fill exceeds the\
    \ capacity, we start from a new position\n                start = end + 1;\n \
    \               end = start;\n            }\n            ans += 1;\n        }\n\
    \        well_len -= 1;\n    }\n    ans\n}\n\nfn main() {\n    let candidate =\
    \ max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `12`,\n right: `6`', /tmp/tmp_ip2insc.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut grid = grid;\n   \
    \ let mut iteration = 0;\n    let mut current_capacity = capacity;\n    let mut\
    \ last_well = grid.len() - 1;\n    for well in 0..grid.len() {\n        for wall\
    \ in 0..grid[well].len() {\n            let water = grid[well][wall];\n      \
    \      if water == 1 {\n                current_capacity -= 1;\n             \
    \   grid[well][wall] = 0;\n            }\n            if current_capacity == 0\
    \ {\n                current_capacity = capacity;\n                iteration +=\
    \ 1;\n            }\n        }\n        if well == last_well {\n            break;\n\
    \        }\n        last_well = well;\n        if grid[well] == grid[well + 1]\
    \ {\n            continue;\n        }\n        if current_capacity < capacity\
    \ {\n            iteration += 1;\n            current_capacity = capacity;\n \
    \       }\n    }\n    iteration\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp29onsk9_.rs:37:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let n = grid.len();\n    let\
    \ m = grid[0].len();\n    let mut ans = 0;\n    let mut water = vec![vec![0; m];\
    \ n];\n    for i in 0..n {\n        for j in 0..m {\n            let mut available\
    \ = capacity;\n            for k in 0..n {\n                available -= water[k][j];\n\
    \            }\n            if available < 0 {\n                return -1;\n \
    \           }\n            if available == 0 {\n                continue;\n  \
    \          }\n            let max_available = grid[i][j] - available;\n      \
    \      let full = if max_available > 0 {\n                max_available\n    \
    \        } else {\n                grid[i][j]\n            };\n            ans\
    \ += full;\n            for k in 0..n {\n                water[k][j] += full;\n\
    \            }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `6`', /tmp/tmp0_8nb3j8.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // for each row, we calculate\
    \ how much of the capacity is already filled\n    // and we add the remaining\
    \ amount to the result\n    grid.iter().map(|row| {\n        let filled = row.iter().sum::<isize>();\n\
    \        let needed = capacity - filled;\n        if needed > 0 { needed } else\
    \ { 0 }\n    }).sum()\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `6`', /tmp/tmpt5c6rejn.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut result = 0;\n    let\
    \ mut i = 0;\n    while i < grid.len() {\n        let mut j = 0;\n        while\
    \ j < grid[i].len() {\n            if grid[i][j] == 1 {\n                let mut\
    \ count = capacity;\n                let mut k = i;\n                while k <\
    \ grid.len() && count > 0 {\n                    let water = cmp::min(grid[k][j],\
    \ count);\n                    grid[k][j] -= water;\n                    count\
    \ -= water;\n                    k += 1;\n                }\n                result\
    \ += 1;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp5ifxo762.rs:26:33\n   |\n26 |                     let water = cmp::min(grid[k][j],\
    \ count);\n   |                                 ^^^ use of undeclared crate or\
    \ module `cmp`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    // fill the first row\n  \
    \  let mut rows = vec![];\n    for col in grid[0].iter() {\n        rows.push(capacity\
    \ - col);\n    }\n    // now fill the remaining rows\n    for row in grid.iter().skip(1)\
    \ {\n        // fill each bucket with the row above it\n        let mut fill =\
    \ 0;\n        for (bucket, col) in rows.iter_mut().zip(row.iter()) {\n       \
    \     // fill from the above bucket\n            let fill_from_above = std::cmp::min(*bucket,\
    \ capacity - col);\n            *bucket -= fill_from_above;\n            fill\
    \ += fill_from_above;\n        }\n        rows.push(fill);\n    }\n    // count\
    \ the final number of operations\n    rows.iter().sum()\n}\n\nfn main() {\n  \
    \  let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0],\
    \ vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmp5jk3mjob.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut num_fill: isize =\
    \ 0;\n    for row in grid {\n        for &cell in row.iter() {\n            if\
    \ cell != 0 {\n                num_fill += 1;\n            }\n        }\n    }\n\
    \    if num_fill == 0 {\n        return 0;\n    }\n    num_fill = capacity / num_fill;\n\
    \    if capacity % num_fill != 0 {\n        num_fill += 1;\n    }\n    num_fill\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to calculate the remainder with a
    divisor of zero'', /tmp/tmp3xde51wj.rs:29:8

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977629
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    use std::cmp::min;\n    let\
    \ mut result = 0;\n    let n = grid.len();\n    let m = grid[0].len();\n    for\
    \ i in 0..n {\n        for j in 0..m {\n            if grid[i][j] == 1 {\n   \
    \             result += capacity;\n            }\n        }\n    }\n    result\
    \ -= capacity * n * m;\n    for j in 0..m {\n        let mut sum = 0;\n      \
    \  for i in 0..n {\n            sum += grid[i][j];\n        }\n        result\
    \ += min(sum, capacity);\n    }\n    for i in 0..n {\n        let mut sum = 0;\n\
    \        for j in 0..m {\n            sum += grid[i][j];\n        }\n        result\
    \ += min(sum, capacity);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpysv0zo4n.rs:28:26\n   |\n\
    28 |     result -= capacity * n * m;\n   |                          ^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot multiply `isize` by `usize`\n\
    \  --> /tmp/tmpysv0zo4n.rs:28:24\n   |\n28 |     result -= capacity * n * m;\n\
    \   |                        ^ no implementation for `isize * usize`\n   |\n \
    \  = help: the trait `Mul<usize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `Mul<Rhs>`:\n             <&'a f32 as\
    \ Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n\
    \             <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n    \
    \         <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n          \
    \   <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpysv0zo4n.rs:28:30\n   |\n28 |     result -= capacity *\
    \ n * m;\n   |                              ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot multiply `isize` by `usize`\n  --> /tmp/tmpysv0zo4n.rs:28:28\n\
    \   |\n28 |     result -= capacity * n * m;\n   |                            ^\
    \ no implementation for `isize * usize`\n   |\n   = help: the trait `Mul<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 0
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let height = grid.len();\n\
    \    let width = grid[0].len();\n    let mut water = 0;\n    for i in 0..height\
    \ {\n        let mut row_water = 0;\n        for j in 0..width {\n           \
    \ row_water += grid[i][j];\n        }\n        water += (row_water + capacity\
    \ - 1) / capacity;\n    }\n    water\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659977629
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.len() == 0 {\n   \
    \     return 0;\n    }\n    let nrows = grid.len();\n    let ncols = grid[0].len();\n\
    \    let mut result = 0;\n    let mut min_level = 0;\n    for col in 0..ncols\
    \ {\n        let mut max_level = 0;\n        for row in 0..nrows {\n         \
    \   max_level = max(max_level, grid[row][col]);\n        }\n        result +=\
    \ max_level - min_level;\n        min_level = max_level;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpa3ge9k9v.rs:27:25\n\
    \   |\n27 |             max_level = max(max_level, grid[row][col]);\n   |    \
    \                     ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut res = 0;\n    let\
    \ mut fill = 0;\n    for row in grid {\n        for &water in row.iter() {\n \
    \           fill += water;\n            if fill >= capacity {\n              \
    \  res += 1;\n                fill = 0;\n            }\n        }\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpq_cssfo_.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut count = 0;\n    for\
    \ well in grid {\n        let mut skip = 0;\n        for level in well {\n   \
    \         if level == 1 {\n                if skip == 0 {\n                  \
    \  count += 1;\n                }\n                skip = capacity - 1;\n    \
    \        } else {\n                skip -= 1;\n            }\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `6`', /tmp/tmpiza8rlf1.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    if grid.is_empty() {\n   \
    \     return 0;\n    }\n    let row_len = grid[0].len();\n    let mut total_water\
    \ = 0;\n    for row in grid {\n        let mut fill = capacity;\n        for i\
    \ in 0..row_len {\n            if row[i] == 1 {\n                fill -= 1;\n\
    \            } else {\n                fill = capacity;\n            }\n     \
    \       if fill == 0 {\n                total_water += 1;\n                fill\
    \ = capacity;\n            }\n        }\n    }\n    total_water\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmp0pgy3gak.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut fill_count = 0;\n\
    \    let row_len = grid[0].len();\n    for row in grid {\n        let mut fill\
    \ = 0;\n        for j in 0..row_len {\n            if row[j] == 1 {\n        \
    \        fill += 1;\n            } else {\n                if fill > 0 {\n   \
    \                 let mut new_fill = (fill as f64 / capacity as f64).ceil() as\
    \ isize;\n                    if new_fill * capacity - fill > 0 {\n          \
    \              new_fill -= 1;\n                    }\n                    fill_count\
    \ += new_fill;\n                    fill = 0;\n                }\n           \
    \ }\n        }\n        if fill > 0 {\n            let mut new_fill = (fill as\
    \ f64 / capacity as f64).ceil() as isize;\n            if new_fill * capacity\
    \ - fill > 0 {\n                new_fill -= 1;\n            }\n            fill_count\
    \ += new_fill;\n        }\n    }\n    fill_count\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `5`', /tmp/tmpegivs_3m.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut bucket = capacity;\n\
    \    let mut total = 0;\n    for row in grid {\n        for &well in row.iter()\
    \ {\n            if well > bucket {\n                bucket = capacity;\n    \
    \            total += 1;\n            }\n            bucket -= well;\n       \
    \ }\n    }\n    total\n}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `6`', /tmp/tmpj0vfywzd.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    unimplemented!();\n}\n\nfn\
    \ main() {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpzqnl5hzq.rs:17:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659977628
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill = 0;\n  \
    \  for row in grid {\n        for cell in row {\n            if cell > 0 {\n \
    \               max_fill += cell;\n            }\n        }\n    }\n    let mut\
    \ result = max_fill / capacity;\n    if max_fill % capacity > 0 {\n        result\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = max_fill;\n\
    \    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1, 1,\
    \ 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1], vec![0, 0,\
    \ 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpdl89g6vh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut sum = 0;\n    for\
    \ row in grid {\n        sum += row.iter().sum::<isize>();\n    }\n    let bucket_count\
    \ = (sum + capacity - 1) / capacity;\n    bucket_count\n}\n\nfn main() {\n   \
    \ let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0,\
    \ 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmpda76f44g.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 1
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut max_fill_count = 0;\n\
    \    for row in grid {\n        let depth = row.iter().sum();\n        max_fill_count\
    \ += isize::max(0, depth - capacity);\n    }\n    max_fill_count\n}\n\nfn main()\
    \ {\n    let candidate = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1,\
    \ 0], vec![0, 1, 0, 0], vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 1, 1], vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n \
    \   assert_eq!(candidate(vec![vec![0, 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1,\
    \ 1, 1, 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp_lg1qmn2.rs:19:13\n\
    \   |\n19 |         let depth = row.iter().sum();\n   |             ^^^^^ consider\
    \ giving `depth` a type\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659977629
- exit_code: 101
  program: "/// You are given a rectangular grid of wells. Each row represents a single\
    \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each\
    \ well has a corresponding bucket that can be used to extract water from it, \n\
    /// and all buckets have the same capacity.\n/// Your task is to use the buckets\
    \ to empty the wells.\n/// Output the number of times you need to lower the buckets.\n\
    /// Example 1:\n/// Example 2:\n/// Example 3:\n/// Constraints:\n/// * all wells\
    \ have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfn max_fill(grid:\
    \ Vec<Vec<isize>>, capacity: isize) -> isize {\n    let mut drops = 0;\n    for\
    \ mut well in grid {\n        for i in 0..well.len() {\n            let mut needs\
    \ = well[i];\n            for j in i..well.len() {\n                needs = (well[j]\
    \ - needs).max(0);\n                well[j] = needs;\n            }\n        \
    \    drops += needs;\n        }\n    }\n    drops\n}\n\nfn main() {\n    let candidate\
    \ = max_fill;\n    assert_eq!(candidate(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0],\
    \ vec![1, 1, 1, 1]], 1), 6);\n    assert_eq!(candidate(vec![vec![0, 0, 1, 1],\
    \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2), 5);\n    assert_eq!(candidate(vec![vec![0,\
    \ 0, 0], vec![0, 0, 0]], 5), 0);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 2), 4);\n    assert_eq!(candidate(vec![vec![1, 1, 1,\
    \ 1], vec![1, 1, 1, 1]], 9), 2);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `6`', /tmp/tmpydr41syh.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659977629
