language: rs
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ distance = word.len();\n    let mut prev_was_consonant = false;\n    for (i,\
    \ ch) in word.chars().enumerate().rev() {\n        if prev_was_consonant {\n \
    \           match ch {\n                'a' | 'e' | 'i' | 'o' | 'u' => {\n   \
    \                 if i < distance {\n                        distance = i;\n \
    \                       closest_vowel = ch.to_string();\n                    }\n\
    \                },\n                _ => ()\n            }\n        }\n     \
    \   prev_was_consonant = match ch {\n            'a' | 'e' | 'i' | 'o' | 'u' =>\
    \ false,\n            _ => true\n        };\n    }\n    closest_vowel\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpd1ixo2gq.rs:11:45\n   |\n11 |     for (i, ch) in word.chars().enumerate().rev()\
    \ {\n   |                                             ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpd1ixo2gq.rs:11:20\n    |\n11  |     for (i, ch) in word.chars().enumerate().rev()\
    \ {\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rposition(|c| c.is_vowel()).map(|i| {\n\
    \        word.chars().rev().skip(word.len() - i - 1).position(|c| c.is_vowel()).map(|j|\
    \ {\n            word.chars().rev().skip(j + 1).take(i - j).collect()\n      \
    \  }).unwrap_or(String::new())\n    }).unwrap_or(String::new())\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \ --> /tmp/tmpsgxcyqeh.rs:8:18\n  |\n8 |     word.chars().rposition(|c| c.is_vowel()).map(|i|\
    \ {\n  |                  ^^^^^^^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n --> /tmp/tmpsgxcyqeh.rs:8:34\n  |\n8 |     word.chars().rposition(|c|\
    \ c.is_vowel()).map(|i| {\n  |                                  ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_vowel` found for type\
    \ `char` in the current scope\n --> /tmp/tmpsgxcyqeh.rs:9:68\n  |\n9 |       \
    \  word.chars().rev().skip(word.len() - i - 1).position(|c| c.is_vowel()).map(|j|\
    \ {\n  |                                                                    ^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res: String = \"\".to_string();\n    let vowels\
    \ = \"aeiou\";\n    let mut v_iter = vowels.chars();\n    let mut idx = word.len()\
    \ - 1;\n    let mut c_pre = ' ';\n    let mut c_post = ' ';\n    let mut v = v_iter.next();\n\
    \    while idx >= 0 {\n        c_post = c_pre;\n        c_pre = word.chars().nth(idx).unwrap();\n\
    \        if v.is_some() && v.unwrap() == c_pre {\n            res = c_pre.to_string();\n\
    \            v = v_iter.next();\n        }\n        if !vowels.contains(c_pre)\
    \ && vowels.contains(c_post) {\n            break;\n        }\n        idx -=\
    \ 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpmgr74l6x.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut found_vowel = String::new();\n    let word_vec: Vec<char> = word.chars().collect();\n\
    \    let len = word_vec.len();\n    for i in 0..len {\n        if i == 0 {\n \
    \           continue;\n        }\n        if vowels.contains(&word_vec[i]) {\n\
    \            found_vowel.push(word_vec[i]);\n            let sub_string = &word[(i\
    \ + 1)..];\n            let next_char = sub_string.chars().next();\n         \
    \   if next_char.is_some() && !vowels.contains(&next_char.unwrap()) {\n      \
    \          return found_vowel;\n            }\n        }\n    }\n    return String::new();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpsxyrwr83.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|x| !is_consonant(*x)).skip(1).take_while(|x|\
    \ !is_consonant(*x)).collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n --> /tmp/tmp8yekuick.rs:8:40\n\
    \  |\n8 |     word.chars().rev().skip_while(|x| !is_consonant(*x)).skip(1).take_while(|x|\
    \ !is_consonant(*x)).collect()\n  |                                        ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_consonant`\
    \ in this scope\n --> /tmp/tmp8yekuick.rs:8:82\n  |\n8 |     word.chars().rev().skip_while(|x|\
    \ !is_consonant(*x)).skip(1).take_while(|x| !is_consonant(*x)).collect()\n  |\
    \                                                                            \
    \      ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ right_consonant_found = false;\n    for c in word.chars().rev() {\n        if\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if right_consonant_found\
    \ {\n                closest_vowel.push(c);\n                break;\n        \
    \    }\n        } else {\n            right_consonant_found = true;\n        }\n\
    \    }\n    closest_vowel.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpduxnk5om.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for (i, c) in word.chars().enumerate() {\n       \
    \ if vowels.contains(&c) {\n            result = word[i..i + 1].to_string();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpwfbbrss7.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let cons = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k',\
    \ 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'];\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let mut distance: i32 = 100;\n    let mut\
    \ index: i32 = 0;\n    let mut i: i32 = word.len() as i32 - 1;\n    let mut j:\
    \ i32 = 0;\n    let mut count: i32 = 0;\n    let mut is_found: bool = false;\n\
    \    for x in word.chars() {\n        if !cons.contains(&x) {\n            if\
    \ !vowels.contains(&x) {\n                return String::from(\"\");\n       \
    \     }\n            if !is_found {\n                is_found = true;\n      \
    \          j = i;\n            }\n            count += 1;\n        } else {\n\
    \            if is_found {\n                let d = i - j - count;\n         \
    \       if d > 0 && d < distance {\n                    distance = d;\n      \
    \              index = j + count;\n                }\n                is_found\
    \ = false;\n                count = 0;\n            }\n        }\n        i -=\
    \ 1;\n    }\n    if distance == 100 {\n        return String::from(\"\");\n  \
    \  }\n    return word.chars().nth(index as usize).unwrap().to_string();\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpv3v7ur8i.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ last_vowel = 0;\n    let mut last_consonant = 0;\n    let mut found = false;\n\
    \    for (i, c) in word.chars().enumerate() {\n        match c {\n           \
    \ 'a' | 'e' | 'i' | 'o' | 'u' => {\n                last_vowel = i;\n        \
    \        if last_consonant != 0 {\n                    found = true;\n       \
    \             break;\n                }\n            }\n            _ => {\n \
    \               if last_vowel != 0 {\n                    last_consonant = i;\n\
    \                }\n            }\n        }\n    }\n    if found {\n        if\
    \ last_consonant < last_vowel {\n            word.chars().collect::<Vec<char>>()[last_vowel..].iter().cloned().collect()\n\
    \        } else {\n            String::new()\n        }\n    } else {\n      \
    \  String::new()\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"urt\"`,\n right: `\"u\"`', /tmp/tmpa75crl7v.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut consonants: Vec<char> = Vec::new();\n    let\
    \ mut vowel_idx: usize = 0;\n    let mut vowel: char = 'a';\n    let mut closest_vowel_idx:\
    \ usize = 0;\n    let mut closest_vowel: char = 'a';\n    let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n    let consonants_in_word: Vec<char> = word.chars().collect();\n\
    \    for (idx, ch) in consonants_in_word.iter().enumerate() {\n        if !vowels.contains(ch)\
    \ {\n            consonants.push(*ch);\n        } else {\n            vowel_idx\
    \ = idx;\n            vowel = *ch;\n            let mut temp: i32 = vowel_idx\
    \ as i32 - consonants.len() as i32;\n            if temp < 0 {\n             \
    \   temp = temp * -1;\n            }\n            if temp < (closest_vowel_idx\
    \ as i32 - consonants.len() as i32) {\n                closest_vowel_idx = vowel_idx;\n\
    \                closest_vowel = vowel;\n            }\n        }\n    }\n   \
    \ closest_vowel.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"u\"`', /tmp/tmp9bz0l8j2.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    return word;\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"yogurt\"`,\n right: `\"u\"`', /tmp/tmpp_c98aum.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut consonants = 0;\n    let mut found = false;\n\
    \    for c in word.chars().rev() {\n        if !c.is_vowel() {\n            consonants\
    \ += 1;\n        } else if consonants > 1 {\n            return c.to_string();\n\
    \        } else if !found {\n            found = true;\n        }\n    }\n   \
    \ String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpx5penyhj.rs:11:15\n   |\n11 |         if !c.is_vowel()\
    \ {\n   |               ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // iterate backwards over the characters in the word\n\
    \    // when we hit a consonant, check if the next character is a vowel\n    //\
    \ if it is, we've found the closest vowel!\n    let mut prior_character = None;\n\
    \    let mut closest_vowel = String::new();\n    for c in word.chars().rev() {\n\
    \        if prior_character.is_some() {\n            let prior_character = prior_character.unwrap();\n\
    \            if is_vowel(prior_character) {\n                break;\n        \
    \    } else if is_vowel(c) {\n                closest_vowel.push(c);\n       \
    \         break;\n            }\n        }\n        prior_character = Some(c);\n\
    \    }\n    closest_vowel.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpzlpg57xn.rs:16:16\n\
    \   |\n16 |             if is_vowel(prior_character) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmpzlpg57xn.rs:18:23\n   |\n18 |             } else if\
    \ is_vowel(c) {\n   |                       ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = String::from(\"aeiou\");\n    for i in\
    \ (0..word.len()).rev() {\n        let c = word.chars().nth(i).unwrap();\n   \
    \     if vowels.contains(c) {\n            if i + 1 < word.len() {\n         \
    \       let next = word.chars().nth(i + 1).unwrap();\n                if !vowels.contains(next)\
    \ {\n                    return word[i..=i].to_string();\n                }\n\
    \            }\n            if i > 0 {\n                let prev = word.chars().nth(i\
    \ - 1).unwrap();\n                if !vowels.contains(prev) {\n              \
    \      return word[i..=i].to_string();\n                }\n            }\n   \
    \     }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp58dpeti1.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut end = 0;\n    let mut start = 0;\n    let mut result = String::new();\n\
    \    if word.len() < 3 {\n        return result;\n    }\n    for (i, _) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&word.chars().nth(i).unwrap()) {\n           \
    \ end = i;\n            for (j, _) in word.chars().enumerate().rev() {\n     \
    \           if vowels.contains(&word.chars().nth(j).unwrap()) {\n            \
    \        start = j;\n                    break;\n                }\n         \
    \   }\n            if start != end {\n                break;\n            }\n\
    \        }\n    }\n    if start - end > 1 {\n        for i in end..start {\n \
    \           if !vowels.contains(&word.chars().nth(i).unwrap()) {\n           \
    \     result.push(word.chars().nth(i).unwrap());\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpnhxszmuw.rs:18:52\n   |\n18 |             for (j, _) in word.chars().enumerate().rev()\
    \ {\n   |                                                    ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpnhxszmuw.rs:18:27\n    |\n18  |             for (j, _) in word.chars().enumerate().rev()\
    \ {\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait\
    \ `ExactSizeIterator` is not implemented for `Chars<'_>`\n    |\n    = note: required\
    \ because of the requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ consonants = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p',\
    \ 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let chars: Vec<char> = word.chars().collect();\n\
    \    for i in 0..chars.len() {\n        if vowels.contains(&chars[i]) {\n    \
    \        if i != 0 && consonants.contains(&chars[i - 1]) {\n                if\
    \ i != chars.len() - 1 && consonants.contains(&chars[i + 1]) {\n             \
    \       return chars[i].to_string();\n                }\n            }\n     \
    \   }\n    }\n    return \"\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmph97k9dly.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.is_empty() {\n        return String::new();\n\
    \    }\n    let mut vec = word.chars().rev().collect::<Vec<char>>();\n    let\
    \ mut count = 0;\n    while vec.len() > 0 {\n        let c = vec.pop().unwrap();\n\
    \        if c.is_vowel() {\n            break;\n        }\n        count += 1;\n\
    \    }\n    if count < vec.len() {\n        return vec[count].to_string();\n \
    \   }\n    if count == vec.len() && vec.len() == 1 {\n        return vec[0].to_string();\n\
    \    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4qm5g10j.rs:15:14\n   |\n15 |         if c.is_vowel() {\n\
    \   |              ^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels: Vec<char> = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut chars: Vec<char> = word.chars().collect();\n    let mut vowel_idx:\
    \ Option<usize> = None;\n    let mut idx: usize = 0;\n    loop {\n        if idx\
    \ > chars.len() {\n            break;\n        }\n        if vowels.contains(&chars[idx])\
    \ {\n            vowel_idx = Some(idx);\n            idx += 1;\n            continue;\n\
    \        }\n        if vowel_idx != None {\n            let vowel_idx = vowel_idx.unwrap();\n\
    \            let current_vowel = chars[vowel_idx];\n            if idx > vowel_idx\
    \ + 1 {\n                return chars[vowel_idx].to_string();\n            }\n\
    \        }\n        idx += 1;\n    }\n    String::new()\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpk33o74kd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel: String = String::from(\"\");\n\
    \    let mut dist_min: usize = word.len();\n    let mut idx: usize = 0;\n    let\
    \ vowels: HashSet<char> = vec!['a', 'e', 'i', 'o', 'u'].into_iter().collect();\n\
    \    for letter in word.chars() {\n        if !vowels.contains(&letter) {\n  \
    \          continue;\n        }\n        let is_last = idx == word.len() - 1;\n\
    \        let is_first = idx == 0;\n        if is_last || is_first {\n        \
    \    idx += 1;\n            continue;\n        }\n        let letter_left = word.chars().nth(idx\
    \ - 1).unwrap();\n        let letter_right = word.chars().nth(idx + 1).unwrap();\n\
    \        if !vowels.contains(&letter_left) && !vowels.contains(&letter_right)\
    \ {\n            if idx < dist_min {\n                dist_min = idx;\n      \
    \          closest_vowel = letter.to_string();\n            }\n        }\n   \
    \     idx += 1;\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmp31kflmcb.rs:11:17\n\
    \   |\n11 |     let vowels: HashSet<char> = vec!['a', 'e', 'i', 'o', 'u'].into_iter().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code goes here\n    let vowel = String::from(\"\
    aeiou\");\n    let mut vowel_pos = 0;\n    let mut pos = 0;\n    let mut vowel_found\
    \ = false;\n    let mut count = 0;\n    let mut old_pos = 0;\n    let length =\
    \ word.len();\n    while pos < length {\n        if count == 2 {\n           \
    \ return word[old_pos..pos].to_string();\n        }\n        if vowel.contains(word.get(pos..pos+1).unwrap())\
    \ {\n            count = 0;\n            old_pos = pos;\n            vowel_found\
    \ = true;\n        } else {\n            count += 1;\n        }\n        pos +=\
    \ 1;\n    }\n    if vowel_found {\n        word[old_pos..length].to_string()\n\
    \    } else {\n        String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"urt\"`,\n right: `\"u\"`', /tmp/tmpadtznhna.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_prev_char = ' ';\n    let mut dist = 0;\n    let mut\
    \ min_dist = 0;\n    for ch in word.chars().rev() {\n        if ch == 'a' || ch\
    \ == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n            if prev_char !=\
    \ ' ' && prev_prev_char != ' ' && prev_char != 'a' &&\n               prev_char\
    \ != 'e' && prev_char != 'i' && prev_char != 'o' &&\n               prev_char\
    \ != 'u' {\n                if min_dist == 0 || dist < min_dist {\n          \
    \          min_dist = dist;\n                    result = ch.to_string();\n  \
    \              }\n            }\n        }\n        dist += 1;\n        prev_prev_char\
    \ = prev_char;\n        prev_char = ch;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpjitv5hok.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut vowel_map = HashMap::new();\n    let mut pos = word.len();\n    for c in\
    \ word.chars().rev() {\n        if vowels.contains(&c) {\n            vowel_map.insert(pos,\
    \ c);\n        }\n        pos -= 1;\n    }\n    let mut vowel_pos = word.len();\n\
    \    for (idx, ch) in word.chars().enumerate() {\n        if !vowels.contains(&ch)\
    \ {\n            for (k, v) in vowel_map.iter() {\n                if idx < *k\
    \ && *k < vowel_pos {\n                    vowel_pos = *k;\n                }\n\
    \            }\n        }\n    }\n    match vowel_map.get(&vowel_pos) {\n    \
    \    Some(v) => return v.to_string(),\n        None => return \"\".to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmp6wu43zmt.rs:9:25\n  |\n9 |     let mut vowel_map = HashMap::new();\n\
    \  |                         ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let mut char_vec = word.chars().collect::<Vec<char>>();\n\
    \  char_vec.reverse();\n  for (i, &c) in char_vec.iter().enumerate() {\n    if\
    \ is_vowel(c) {\n      if i + 1 < char_vec.len() && is_vowel(char_vec[i + 1])\
    \ {\n        continue;\n      }\n      return word[word.len() - i - 1..].to_string();\n\
    \    }\n  }\n  \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpxzt7ui43.rs:11:8\n\
    \   |\n11 |     if is_vowel(c) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpxzt7ui43.rs:12:36\n\
    \   |\n12 |       if i + 1 < char_vec.len() && is_vowel(char_vec[i + 1]) {\n \
    \  |                                    ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = \"\".to_string();\n    let mut const_found\
    \ = false;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for l in word.chars().rev()\
    \ {\n        if vowels.contains(&l) {\n            if const_found {\n        \
    \        result = l.to_string();\n                break;\n            }\n    \
    \    } else {\n            const_found = true;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp69f163_c.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aAeEiIoOuU\".to_string();\n    let mut\
    \ closest_vowel = String::new();\n    let mut last_consonant_index = 0;\n    let\
    \ mut previous_consonant_index = 0;\n    let mut result = String::new();\n   \
    \ let mut consonant_indexes = Vec::new();\n    for (i, w) in word.chars().enumerate()\
    \ {\n        if vowels.contains(w) {\n            closest_vowel = w.to_string();\n\
    \            previous_consonant_index = consonant_indexes[last_consonant_index];\n\
    \            last_consonant_index += 1;\n            if i - previous_consonant_index\
    \ - 1 == 1 {\n                result = closest_vowel;\n                break;\n\
    \            }\n        } else {\n            consonant_indexes.push(i);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp9zd903mj.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    //fill me in\n    let mut closest_vowel = \"\".to_string();\n\
    \    let mut closest_distance = word.len();\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if \"aeiou\".contains(c) {\n            let l = i;\n            let\
    \ r = word.len() - i - 1;\n            if l > 0 && \"bcdfghjklmnpqrstvwxyz\".contains(word.chars().nth(i\
    \ - 1).unwrap()) &&\n                r > 0 && \"bcdfghjklmnpqrstvwxyz\".contains(word.chars().nth(i\
    \ + 1).unwrap()) {\n                if l <= r && l < closest_distance {\n    \
    \                closest_distance = l;\n                    closest_vowel = c.to_string();\n\
    \                } else if r < closest_distance {\n                    closest_distance\
    \ = r;\n                    closest_vowel = c.to_string();\n                }\n\
    \            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmppv5ofv4n.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| \"aeiou\".contains(c)).skip(1).take_while(|&c|\
    \ \"aeiou\".contains(c)).collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpi11f28jc.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().collect::<Vec<char>>();\n \
    \   let mut result = String::new();\n    let vowels = vec!['a', 'e', 'i', 'o',\
    \ 'u'];\n    let mut consonants = 0;\n    let mut index = word.len() - 1;\n  \
    \  while consonants < 2 && index >= 0 {\n        if vowels.contains(&word[index])\
    \ {\n            result = word[index].to_string();\n            consonants = 0;\n\
    \        } else {\n            consonants += 1;\n        }\n        index -= 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpgzwbeyzl.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut distance = (word.len(), 0);\n    let mut vowel\
    \ = String::new();\n    for i in 0..word.len() {\n        let c = word.chars().nth(i).unwrap();\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       if distance.0 > i {\n                distance = (i, 1);\n            \
    \    vowel = c.to_string();\n            }\n        }\n    }\n    for i in (0..word.len()).rev()\
    \ {\n        let c = word.chars().nth(i).unwrap();\n        if c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if distance.0 < i &&\
    \ distance.1 == 1 {\n                distance = (i, 2);\n                vowel\
    \ = c.to_string();\n            }\n        }\n    }\n    vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpn8fb8wlh.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vec: Vec<char> = Vec::new();\n    let mut arr:\
    \ Vec<char> = word.chars().collect();\n    let mut count = 0;\n    let mut con\
    \ = 0;\n    let mut vow = 0;\n    let mut found = false;\n    for i in (0..arr.len()).rev()\
    \ {\n        if count == 0 {\n            if arr[i] == 'a' || arr[i] == 'e' ||\
    \ arr[i] == 'i' || arr[i] == 'o' || arr[i] == 'u' {\n                vow = 1;\n\
    \            } else {\n                vow = 0;\n            }\n        }\n  \
    \      if arr[i] == 'a' || arr[i] == 'e' || arr[i] == 'i' || arr[i] == 'o' ||\
    \ arr[i] == 'u' {\n            if con == 1 && vow == 0 {\n                found\
    \ = true;\n                break;\n            }\n            vow = 1;\n     \
    \       con = 0;\n        } else {\n            if vow == 1 && con == 0 {\n  \
    \              found = true;\n                break;\n            }\n        \
    \    vow = 0;\n            con = 1;\n        }\n        count += 1;\n    }\n \
    \   if found {\n        let res = arr[i].to_string();\n        return res;\n \
    \   } else {\n        return \"\".to_string();\n    }\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp7keebq8m.rs:40:23\n\
    \   |\n40 |         let res = arr[i].to_string();\n   |                      \
    \ ^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ last_vowel = None;\n    let mut last_consonant = None;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&c) {\n            last_vowel = Some((i, c));\n\
    \        } else {\n            last_consonant = Some((i, c));\n        }\n   \
    \     if last_vowel.is_some() && last_consonant.is_some() {\n            break;\n\
    \        }\n    }\n    match (last_vowel, last_consonant) {\n        (Some((i,\
    \ c)), Some((j, _))) if i < j => c.to_string(),\n        _ => \"\".to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp6q0uur65.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ closest = String::new();\n    let chars: Vec<char> = word.chars().collect();\n\
    \    for i in (0..word.len()).rev() {\n        if vowels.contains(&chars[i]) {\n\
    \            if i + 1 < word.len() && !vowels.contains(&chars[i + 1]) {\n    \
    \            closest = word[i..].to_string();\n                break;\n      \
    \      }\n        }\n    }\n    closest\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"urt\"`,\n right: `\"u\"`', /tmp/tmpg93mdp1m.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut min_distance = word.len();\n    let mut closest_vowel\
    \ = String::new();\n    let vowels = String::from(\"aeiou\");\n    let mut current_distance\
    \ = 0;\n    for c in word.chars().rev() {\n        if vowels.contains(c) {\n \
    \           current_distance = 0;\n        } else {\n            current_distance\
    \ += 1;\n        }\n        if current_distance < min_distance {\n           \
    \ min_distance = current_distance;\n            closest_vowel = c.to_string();\n\
    \        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpw5o4k5p2.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code here...\n    let word: Vec<char> = word.chars().collect();\n\
    \    let mut find_vowel: Vec<char> = Vec::new();\n    let mut index: usize = 0;\n\
    \    let mut index_word: usize = 0;\n    let vowels: Vec<char> = ['a', 'e', 'i',\
    \ 'o', 'u'].to_vec();\n    for (i, c) in word.iter().enumerate() {\n        for\
    \ vowel in vowels.iter() {\n            if *c == *vowel {\n                find_vowel.push(*c);\n\
    \                index = i;\n            }\n        }\n    }\n    if index ==\
    \ 0 || index == word.len() - 1 {\n        \"\".to_string()\n    } else {\n   \
    \     for (i, c) in word.iter().enumerate() {\n            for (y, vowel) in find_vowel.iter().enumerate()\
    \ {\n                if *c == *vowel {\n                    index_word = i;\n\
    \                }\n            }\n        }\n        word[index_word].to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp4qbmdfq7.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let chars = word.chars().collect::<Vec<char>>();\n\
    \    let mut res = String::new();\n    let mut vowel_pos = 0;\n    let mut vowel_dist\
    \ = word.len();\n    for i in 1..chars.len() {\n        let c = chars[i];\n  \
    \      if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n       \
    \     // Is a vowel\n            if chars[i - 1] != 'a' && chars[i - 1] != 'e'\
    \ && chars[i - 1] != 'i' &&\n                chars[i - 1] != 'o' && chars[i -\
    \ 1] != 'u' {\n                // Is between two consonants\n                if\
    \ i <= vowel_dist {\n                    vowel_dist = i;\n                   \
    \ vowel_pos = i;\n                }\n            }\n        }\n    }\n    if vowel_pos\
    \ != 0 {\n        res.push(chars[vowel_pos]);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpbj34h0ht.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel: String = String::from(\"\");\n\
    \    let mut closest_vowel_index: usize = 0;\n    let mut current_consonant_index:\
    \ usize = 0;\n    let vowels: HashSet<char> = vec!['a', 'e', 'i', 'o', 'u'].into_iter().collect();\n\
    \    // counting from the back, assign the current consonant index and get the\
    \ next vowel\n    for index in word.chars().rev().enumerate() {\n        let (i,\
    \ c) = index;\n        if !vowels.contains(&c) {\n            current_consonant_index\
    \ = i;\n        } else {\n            // if the vowel's index is greater than\
    \ the previously assigned\n            // consonant index, assign it to the closest\
    \ vowel index and break\n            if i > current_consonant_index {\n      \
    \          closest_vowel_index = i;\n                break;\n            }\n \
    \       }\n    }\n    // if the closest vowel index is the same as the length\
    \ of the string, that means\n    // there wasn't a vowel found\n    if closest_vowel_index\
    \ == word.len() {\n        return closest_vowel;\n    }\n    // because the index\
    \ was counted from the back, we need to subtract the length of the string\n  \
    \  // and the closest vowel index to get the correct index\n    closest_vowel\
    \ = word.chars().nth(word.len() - closest_vowel_index - 1).unwrap().to_string();\n\
    \    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpz7allrx7.rs:11:17\n\
    \   |\n11 |     let vowels: HashSet<char> = vec!['a', 'e', 'i', 'o', 'u'].into_iter().collect();\n\
    \   |                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ previous_char = String::new();\n    let mut previous_previous_char = String::new();\n\
    \    let mut vowel_count = 0;\n    let mut vowel_idx = 0;\n    let mut char_arr:\
    \ Vec<char> = word.chars().collect();\n    let mut word_length = char_arr.len();\n\
    \    // println!(\"{:?}\", char_arr);\n    for (i, c) in char_arr.iter().enumerate()\
    \ {\n        // println!(\"{:?}\", c);\n        // println!(\"{:?}\", *c);\n \
    \       if *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u' {\n \
    \           // println!(\"{:?}\", c);\n            vowel_count += 1;\n       \
    \     vowel_idx = i;\n            // println!(\"{:?}\", vowel_idx);\n        }\n\
    \    }\n    if vowel_count == 0 {\n        return String::from(\"Empty\");\n \
    \   }\n    if vowel_count == 1 {\n        closest_vowel.push(char_arr[vowel_idx]);\n\
    \        return closest_vowel;\n    }\n    let mut previous_char_index = word_length\
    \ - 1;\n    let mut previous_previous_char_index = word_length - 2;\n    // println!(\"\
    {:?}\", previous_char_index);\n    previous_char.push(char_arr[previous_char_index]);\n\
    \    previous_previous_char.push(char_arr[previous_previous_char_index]);\n  \
    \  loop {\n        if (previous_char != \"a\" && previous_char != \"e\" && previous_char\
    \ != \"i\" && previous_char != \"o\" && previous_char != \"u\") &&\n         \
    \   (previous_previous_char != \"a\" && previous_previous_char != \"e\" && previous_previous_char\
    \ != \"i\" && previous_previous_char != \"o\" && previous_previous_char != \"\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmprsw8zxny.rs:57:65\n\
    \   |\n57 |       assert_eq!(candidate(String::from(\"Above\")), String::from(\"\
    o\"));\n   |  _________________________________________________________________^\n\
    58 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_vowel\
    \ = false;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in word.chars().rev()\
    \ {\n        if found_vowel && !vowels.contains(&c) {\n            break;\n  \
    \      }\n        if vowels.contains(&c) {\n            result.push(c);\n    \
    \        found_vowel = true;\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ea\"`,\n right: `\"\"`', /tmp/tmpqwaiqcq7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for\
    \ (i, c) in word.chars().rev().enumerate() {\n        if vowels.contains(&c) {\n\
    \            let mut j = i + 1;\n            while j < word.len() {\n        \
    \        if !vowels.contains(&word.chars().nth(j).unwrap()) {\n              \
    \      return word.chars().nth(j - i - 1).unwrap().to_string();\n            \
    \    }\n                j += 1;\n            }\n        }\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpulaja9pw.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let chs: Vec<char> = word.chars().collect();\n\
    \    for i in 0..chs.len() {\n        if chs[i] == '_' {\n            return \"\
    \".to_string();\n        }\n        if vowels.contains(chs[i]) {\n           \
    \ if i - 1 >= 0 && vowels.contains(chs[i - 1]) {\n                continue;\n\
    \            }\n            if i + 1 < chs.len() && vowels.contains(chs[i + 1])\
    \ {\n                continue;\n            }\n            return chs[i].to_string();\n\
    \        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpidjl5gbe.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let word = word.chars().collect::<Vec<char>>();\n\
    \    let start = word.iter().enumerate().filter(|(_, c)| !vowels.contains(c)).last();\n\
    \    let start = match start {\n        Some((i, _)) => i + 1,\n        None =>\
    \ 0,\n    };\n    let end = word.iter().enumerate().rev().filter(|(_, c)| !vowels.contains(c)).last();\n\
    \    let end = match end {\n        Some((i, _)) => i - 1,\n        None => word.len()\
    \ - 1,\n    };\n    let vowels = vowels.chars().collect::<Vec<char>>();\n    let\
    \ mut min_distance = word.len();\n    let mut closest_vowel = None;\n    for (i,\
    \ c) in word.iter().enumerate() {\n        if start < i && i < end && vowels.contains(c)\
    \ {\n            let distance = (i - start).min(end - i);\n            if distance\
    \ < min_distance {\n                min_distance = distance;\n               \
    \ closest_vowel = Some(c);\n            }\n        }\n    }\n    closest_vowel.map(|c|\
    \ c.to_string()).unwrap_or_else(|| \"\".to_string())\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpdtxggiob.rs:10:74\n\
    \   |\n10 |     let start = word.iter().enumerate().filter(|(_, c)| !vowels.contains(c)).last();\n\
    \   |                                                                        \
    \  ^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n   = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&&char`\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpdtxggiob.rs:15:78\n\
    \   |\n15 |     let end = word.iter().enumerate().rev().filter(|(_, c)| !vowels.contains(c)).last();\n\
    \   |                                                                        \
    \      ^ expected an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the\
    \ trait `Fn<(char,)>` is not implemented for `char`\n   = note: required because\
    \ of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n   = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 0
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut pos = word.len();\n    for i in (0..word.len()).rev() {\n        if vowels.contains(&word.chars().nth(i).unwrap())\
    \ {\n            if i > 0 && !vowels.contains(&word.chars().nth(i - 1).unwrap())\
    \ && \n                    (i + 1 < word.len() && !vowels.contains(&word.chars().nth(i\
    \ + 1).unwrap())) {\n                pos = i;\n                break;\n      \
    \      }\n        }\n    }\n    if pos == word.len() {\n        String::new()\n\
    \    } else {\n        String::from(word.chars().nth(pos).unwrap().to_string())\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let word_vec: Vec<char> = word.chars().collect();\n \
    \ let n = word_vec.len();\n  let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n  let\
    \ mut result = String::new();\n  for i in 0..n {\n    if vowels.contains(&word_vec[i])\
    \ {\n      if i >= 1 && i < n - 1 {\n        if !vowels.contains(&word_vec[i -\
    \ 1]) && !vowels.contains(&word_vec[i + 1]) {\n          result = word_vec[i].to_string();\n\
    \          break;\n        }\n      }\n    }\n  }\n  result\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpz6qjde8i.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let vowels\
    \ = ['a', 'e', 'i', 'o', 'u'];\n    let mut previous_char = ' ';\n    let mut\
    \ previous_vowel_index = 0;\n    let mut previous_index = 0;\n    let mut vowel_index\
    \ = 0;\n    let mut closest_vowel_distance = 0;\n    let mut distance = 0;\n \
    \   let mut index = 0;\n    let mut found_vowel = false;\n    let mut found_consonant\
    \ = false;\n    let mut found_start = false;\n    let mut found_end = false;\n\
    \    let mut in_range = false;\n    let chars: Vec<char> = word.chars().collect();\n\
    \    for c in chars {\n        for vowel in vowels.iter() {\n            if c\
    \ == *vowel {\n                found_vowel = true;\n                vowel_index\
    \ = index;\n                break;\n            }\n        }\n        if previous_char\
    \ == ' ' && previous_vowel_index == 0 {\n            found_start = true;\n   \
    \     }\n        if found_vowel && found_start {\n            previous_vowel_index\
    \ = vowel_index;\n            previous_index = index;\n            previous_char\
    \ = c;\n            found_start = false;\n            found_vowel = false;\n \
    \       }\n        if found_consonant && !found_end {\n            distance =\
    \ index - previous_vowel_index;\n            if closest_vowel_distance == 0 ||\
    \ distance < closest_vowel_distance {\n                closest_vowel_distance\
    \ = distance;\n                closest_vowel = previous_char.to_string();\n  \
    \          }\n            previous_vowel_index = vowel_index;\n            previous_index\
    \ = index;\n            previous_char = c;\n            found_consonant = false;\n\
    \            found_vowel = false;\n        }\n        if found_vowel && !found_consonant\
    \ {\n            previous_vowel_index = vowel_index;\n            previous_index\
    \ = index;\n            previous_char =\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkcdouicn.rs:74:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n23 |     for c in\
    \ chars {\n   |                    - unclosed delimiter\n...\n53 |         if\
    \ found_vowel && !found_consonant {\n   |                                    \
    \        - this delimiter might not be properly closed...\n...\n57 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n74 | }\n   |  \
    \ ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpkcdouicn.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkcdouicn.rs:23:5\n   |\n7  |   fn get_closest_vowel(word: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n23 | /     for c in chars {\n24 | |         for\
    \ vowel in vowels.iter() {\n25 | |             if c == *vowel {\n26 | |      \
    \           found_vowel = true;\n...  |\n73 | |     assert_eq!(candidate(String::from(\"\
    Above\")), String::from(\"o\"));\n74 | | }\n   | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|c| !is_vowel(*c)).skip(1).take_while(|c|\
    \ is_vowel(*c)).cloned().collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n --> /tmp/tmp42oy_yyw.rs:8:40\n\
    \  |\n8 |     word.chars().rev().skip_while(|c| !is_vowel(*c)).skip(1).take_while(|c|\
    \ is_vowel(*c)).cloned().collect()\n  |                                      \
    \  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel`\
    \ in this scope\n --> /tmp/tmp42oy_yyw.rs:8:77\n  |\n8 |     word.chars().rev().skip_while(|c|\
    \ !is_vowel(*c)).skip(1).take_while(|c| is_vowel(*c)).cloned().collect()\n  |\
    \                                                                            \
    \ ^^^^^^^^ not found in this scope\n\nerror[E0271]: type mismatch resolving `<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>,\
    \ [closure@/tmp/tmp42oy_yyw.rs:8:35: 8:52]>>, [closure@/tmp/tmp42oy_yyw.rs:8:73:\
    \ 8:89]> as Iterator>::Item == &_`\n --> /tmp/tmp42oy_yyw.rs:8:91\n  |\n8 |  \
    \   word.chars().rev().skip_while(|c| !is_vowel(*c)).skip(1).take_while(|c| is_vowel(*c)).cloned().collect()\n\
    \  |                                                                         \
    \                  ^^^^^^ expected `char`, found reference\n  |\n  = note:   expected\
    \ type `char`\n          found reference `&_`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>, [closure@/tmp/tmp42oy_yyw.rs:8:35:\
    \ 8:52]>>, [closure@/tmp/tmp42oy_yyw.rs:8:73: 8:89]>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmp42oy_yyw.rs:8:100\n   |\n8  |        word.chars().rev().skip_while(|c|\
    \ !is_vowel(*c)).skip(1).take_while(|c| is_vowel(*c)).cloned().collect()\n   |\
    \                                                                            \
    \                           ^^^^^^^ method cannot be called on `Cloned<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>,\
    \ [closure@/tmp/tmp42oy_yyw.rs:8:35: 8:52]>>, [closure@/tmp/tmp42oy_yyw.rs:8:73:\
    \ 8:89]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<TakeWhile<Skip<SkipWhile<Rev<Chars<'_>>,\
    \ [closure@/tmp/tmp42oy_yyw.rs:8:35: 8:52]>>, [closure@/tmp/tmp42oy_yyw.rs:8:73:\
    \ 8:89]> a"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().collect::<Vec<char>>();\n \
    \   let mut result = String::new();\n    for i in (0..word.len()).rev() {\n  \
    \      if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n            if i == word.len() - 1 {\n                continue;\n\
    \            }\n            if word[i + 1] != 'a' && word[i + 1] != 'e' && word[i\
    \ + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' {\n                result.push(word[i]);\n\
    \                break;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpqff1crgw.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut idx = 0;\n    for i in word.len()-1..0 {\n\
    \        let l = word.chars().nth(i).unwrap();\n        if l == 'a' || l == 'e'\
    \ || l == 'i' || l == 'o' || l == 'u' {\n            idx = i;\n            break;\n\
    \        }\n    }\n    // get the next char\n    let mut cons = true;\n    for\
    \ i in idx+1..word.len() {\n        let l = word.chars().nth(i).unwrap();\n  \
    \      if l == 'a' || l == 'e' || l == 'i' || l == 'o' || l == 'u' {\n       \
    \     cons = false;\n            break;\n        }\n    }\n    if cons {\n   \
    \     idx = 0;\n    }\n    let result: String = word.chars().skip(idx).take(1).collect();\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"y\"`,\n right: `\"u\"`', /tmp/tmph04qe_8j.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_pos = 0;\n    let mut vowel_pos_chr =\
    \ 'a';\n    let mut consonant_pos = -1;\n    let mut found = false;\n    for chr\
    \ in word.chars().rev() {\n        let pos = word.len() - chr.len_utf8();\n  \
    \      let is_vowel = chr == 'a' || chr == 'e' || chr == 'i' || chr == 'o' ||\
    \ chr == 'u';\n        if consonant_pos != -1 && is_vowel {\n            found\
    \ = true;\n            vowel_pos = pos;\n            vowel_pos_chr = chr;\n  \
    \          break;\n        }\n        if !is_vowel {\n            consonant_pos\
    \ = pos;\n        }\n    }\n    if found {\n        word[vowel_pos..=vowel_pos].to_string()\n\
    \    } else {\n        \"\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpv2mzzfs3.rs:10:29\n\
    \   |\n10 |     let mut consonant_pos = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmpv2mzzfs3.rs:15:29\n   |\n\
    15 |         if consonant_pos != -1 && is_vowel {\n   |                      \
    \       ^^ the trait `Neg` is not implemented for `usize`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let result = word.rmatch_indices(|c| \"aeiou\".contains(c))\n\
    \        .filter(|(i, _)| *i != 0 && *i != word.len() - 1)\n        .map(|(_,\
    \ v)| v.to_string())\n        .next();\n    match result {\n        Some(v) =>\
    \ v,\n        None => \"\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpmkntkw7d.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    let consonants: HashSet<char>\
    \ = \"bcdfghjklmnpqrstvwxyz\".chars().collect();\n    let mut consonant_count\
    \ = 0;\n    for (i, c) in word.chars().rev().enumerate() {\n        if consonants.contains(&c)\
    \ {\n            consonant_count += 1;\n        } else {\n            if consonant_count\
    \ == 2 {\n                res = word.chars().skip(word.len() - i - 1).take(1).collect();\n\
    \                break;\n            }\n            consonant_count = 0;\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpsl8khx7y.rs:9:21\n\
    \  |\n9 |     let consonants: HashSet<char> = \"bcdfghjklmnpqrstvwxyz\".chars().collect();\n\
    \  |                     ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.to_lowercase();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut result = String::new();\n    let mut found\
    \ = false;\n    for i in 0..word.len() - 1 {\n        if vowels.contains(&word.chars().nth(i).unwrap())\
    \ {\n            if vowels.contains(&word.chars().nth(i + 1).unwrap()) {\n   \
    \             continue;\n            } else {\n                result = String::from(&word[i..i\
    \ + 1]);\n                found = true;\n            }\n        }\n    }\n   \
    \ if !found {\n        result = String::from(\"\");\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpgz8v0cq_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !c.is_alphabetic()).skip(1).take_while(|&c|\
    \ !c.is_alphabetic()).take_while(|&c| c.is_vowel()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n --> /tmp/tmpk4fhk5gg.rs:8:122\n  |\n8 | ...while(|&c| !c.is_alphabetic()).take_while(|&c|\
    \ c.is_vowel()).collect()\n  |                                               \
    \      ^^^^^^^^ method not found in `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    for (i, c) in word.char_indices().rev() {\n       \
    \ if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            return\
    \ c.to_string();\n        }\n    }\n    String::new()\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpis0awbm3.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    for (i, letter) in word.char_indices().rev() {\n  \
    \      let next_letter = word.chars().nth(i - 1);\n        if \"aeiou\".contains(letter)\
    \ && next_letter.is_some() && !\"aeiou\".contains(next_letter.unwrap()) {\n  \
    \          return letter.to_string();\n        }\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmph3wwj777.rs:9:44

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut closest_vowel = \"\".to_string();\n    let mut closest_index = std::i32::MAX;\n\
    \    let mut vowels_index = vec![];\n    for (index, &vowel) in word.as_bytes().iter().enumerate()\
    \ {\n        if vowels.contains(&(vowel as char)) {\n            vowels_index.push(index\
    \ as i32);\n        }\n    }\n    for (index, &vowel) in word.as_bytes().iter().enumerate()\
    \ {\n        if vowels.contains(&(vowel as char)) {\n            for &vowel_index\
    \ in vowels_index.iter() {\n                if (index as i32 - vowel_index).abs()\
    \ < closest_index {\n                    closest_index = (index as i32 - vowel_index).abs();\n\
    \                    closest_vowel = vowel as char.to_string();\n            \
    \    }\n            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpo574buvp.rs:22:37\n\
    \   |\n22 |                     closest_vowel = vowel as char.to_string();\n \
    \  |                                     ^^^^^^^^^^^^^\n   |\nhelp: try surrounding\
    \ the expression in parentheses\n   |\n22 |                     closest_vowel\
    \ = (vowel as char).to_string();\n   |                                     + \
    \            +\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = String::from(\"AEIOUaeiou\");\n    let\
    \ word = word.chars().collect::<Vec<char>>();\n    let mut start = word.len()\
    \ - 1;\n    let mut end = word.len() - 1;\n    while start > 0 {\n        if vowels.contains(word[start])\
    \ {\n            if vowels.contains(word[start - 1]) {\n                start\
    \ -= 1;\n            } else {\n                break;\n            }\n       \
    \ } else {\n            start -= 1;\n        }\n    }\n    while end > 0 {\n \
    \       if vowels.contains(word[end]) {\n            if vowels.contains(word[end\
    \ - 1]) {\n                end -= 1;\n            } else {\n                break;\n\
    \            }\n        } else {\n            end -= 1;\n        }\n    }\n  \
    \  if start == 0 && vowels.contains(word[start]) {\n        return String::from(\"\
    \");\n    }\n    if end == 0 && vowels.contains(word[end]) {\n        return String::from(\"\
    \");\n    }\n    if start == end {\n        word[start].to_string()\n    } else\
    \ {\n        word[start].to_string() + &word[end].to_string()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmprg7oh669.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels:\
    \ Vec<char> = word.chars().filter(|c| c.is_ascii_lowercase() && is_vowel(*c)).collect();\n\
    \    let is_empty = vowels.is_empty();\n    if is_empty {\n        return result;\n\
    \    }\n    let mut consonants: Vec<char> = word.chars().filter(|c| c.is_ascii_lowercase()\
    \ && !is_vowel(*c)).collect();\n    let max_vowel_index = vowels.len() - 1;\n\
    \    if consonants.is_empty() {\n        return vowels[max_vowel_index].to_string();\n\
    \    }\n    let mut max_consonant_index = consonants.len() - 1;\n    let mut curr_vowel_index\
    \ = max_vowel_index;\n    let mut curr_consonant_index = max_consonant_index;\n\
    \    while curr_vowel_index >= 0 && curr_consonant_index >= 0 {\n        if vowels[curr_vowel_index]\
    \ != consonants[curr_consonant_index] {\n            result = vowels[curr_vowel_index].to_string();\n\
    \            break;\n        }\n        curr_vowel_index -= 1;\n        curr_consonant_index\
    \ -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n --> /tmp/tmp7o3nzlf7.rs:9:83\n\
    \  |\n9 |     let mut vowels: Vec<char> = word.chars().filter(|c| c.is_ascii_lowercase()\
    \ && is_vowel(*c)).collect();\n  |                                           \
    \                                        ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7o3nzlf7.rs:14:88\n\
    \   |\n14 |     let mut consonants: Vec<char> = word.chars().filter(|c| c.is_ascii_lowercase()\
    \ && !is_vowel(*c)).collect();\n   |                                         \
    \                                               ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 0
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ s = word.chars().rev().collect::<Vec<char>>();\n    s.windows(3)\n        .filter(|x|\
    \ vowels.contains(&x[1]))\n        .find(|x| !vowels.contains(&x[0]) && !vowels.contains(&x[2]))\n\
    \        .map(|x| x[1].to_string())\n        .unwrap_or_else(|| \"\".to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ filtered_vowels = word.chars().filter(|c| vowels.contains(c));\n    if filtered_vowels.count()\
    \ == 0 {\n        return String::from(\"\");\n    }\n    word.chars().rev().fold(String::from(\"\
    \"), |r, c| {\n        if vowels.contains(&c) {\n            String::from(c.to_string())\n\
    \        } else {\n            r\n        }\n    })\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp0rp28uhr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let word = word.as_bytes();\n\
    \    let mut index = word.len();\n    for (i, &c) in word.iter().enumerate().rev()\
    \ {\n        if vowels.contains(c as char) {\n            if i == word.len() -\
    \ 1 {\n                break;\n            }\n            index = i;\n       \
    \     break;\n        }\n    }\n    if index == word.len() {\n        return String::new();\n\
    \    }\n    if index == 0 {\n        return String::new();\n    }\n    String::from_utf8(vec![word[index]]).unwrap()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpisr1lvh7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    use std::cmp::min;\n    let mut word = word.chars().rev().collect::<Vec<_>>();\n\
    \    let mut closest_distance = word.len();\n    let mut closest_char = '\\0';\n\
    \    let mut distance = 0;\n    let vowels = \"aeiou\";\n    while let Some(c)\
    \ = word.pop() {\n        if vowels.contains(c) {\n            distance = 0;\n\
    \            continue;\n        }\n        distance += 1;\n        if closest_distance\
    \ <= distance {\n            continue;\n        }\n        if word.len() > 0 &&\
    \ vowels.contains(word[0]) {\n            closest_distance = distance;\n     \
    \       closest_char = word[0];\n        }\n    }\n    let mut result = \"\".to_string();\n\
    \    if closest_char != '\\0' {\n        result.push(closest_char);\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp4gj14lz9.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Find all vowels from the right side of the word.\
    \ Then, choose the closest one.\n    let reversed_word: String = word.chars().rev().collect();\n\
    \    let mut reversed_ans = \"\".to_string();\n    for (i, ch) in reversed_word.chars().enumerate()\
    \ {\n        if is_vowel(ch) {\n            reversed_ans.push(ch);\n         \
    \   let next_char = reversed_word.chars().nth(i + 1);\n            if next_char\
    \ == None || !is_vowel(next_char.unwrap()) {\n                break;\n       \
    \     }\n        }\n    }\n    reversed_ans.chars().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmprmkvpw4v.rs:12:12\n\
    \   |\n12 |         if is_vowel(ch) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmprmkvpw4v.rs:15:38\n   |\n15 |             if next_char == None || !is_vowel(next_char.unwrap())\
    \ {\n   |                                      ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n\tlet vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\tlet mut\
    \ prev_char = ' ';\n\tlet mut next_char = ' ';\n\tlet mut closest_vowel = ' ';\n\
    \tlet mut is_prev_consonant = false;\n\tlet mut is_next_consonant = false;\n\t\
    let mut is_closest_vowel_found = false;\n\tlet mut closest_vowel_dist = 0;\n\t\
    let mut last_consonant_dist = 0;\n\tlet mut last_consonant_found = false;\n\t\
    let mut last_vowel_found = false;\n\tlet mut last_vowel_dist = 0;\n\tlet mut last_vowel\
    \ = ' ';\n\tfor (i, c) in word.chars().enumerate() {\n\t\tif i == 0 {\n\t\t\t\
    prev_char = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif i == word.len() - 1 {\n\t\t\tnext_char\
    \ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tnext_char = word.chars().nth(i + 1).unwrap();\n\
    \t\tprev_char = word.chars().nth(i - 1).unwrap();\n\t\tis_prev_consonant = !vowels.contains(&prev_char);\n\
    \t\tis_next_consonant = !vowels.contains(&next_char);\n\t\tif is_prev_consonant\
    \ && is_next_consonant {\n\t\t\tif last_vowel_found && !last_consonant_found {\n\
    \t\t\t\tif last_vowel_dist < last_consonant_dist {\n\t\t\t\t\tlast_consonant_dist\
    \ = last_vowel_dist;\n\t\t\t\t\tclosest_vowel = last_vowel;\n\t\t\t\t\tis_closest_vowel_found\
    \ = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif vowels.contains(&c) {\n\t\t\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpd8nqicuj.rs:61:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n21 |     for (i,\
    \ c) in word.chars().enumerate() {\n   |                                     \
    \       - unclosed delimiter\n...\n34 |         if is_prev_consonant && is_next_consonant\
    \ {\n   |                                                   - unclosed delimiter\n\
    ...\n42 |             if vowels.contains(&c) {\n   |                         \
    \           - this delimiter might not be properly closed...\n43 |         \n\
    44 | }\n   | - ...as it matches this but it has different indentation\n...\n61\
    \ | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd8nqicuj.rs:21:2\n\
    \   |\n7  |   fn get_closest_vowel(word: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n21 | /     for (i, c) in word.chars().enumerate() {\n22 | |         if i\
    \ == 0 {\n23 | |             prev_char = c;\n24 | |             continue;\n...\
    \  |\n60 | |     assert_eq!(candidate(String::from(\"Above\")), String::from(\"\
    o\"));\n61 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut found = \"\".to_string();\n    let mut witer\
    \ = word.chars().rev();\n    let mut lastc = witer.next().unwrap();\n    for c\
    \ in witer {\n        if lastc.is_alphabetic() && !lastc.is_vowel() {\n      \
    \      if c.is_vowel() {\n                found = c.to_string();\n           \
    \     break;\n            }\n        }\n        lastc = c;\n    }\n    found\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpl23exqq1.rs:12:44\n   |\n12 |         if lastc.is_alphabetic()\
    \ && !lastc.is_vowel() {\n   |                                            ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_vowel` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpl23exqq1.rs:13:18\n   |\n\
    13 |             if c.is_vowel() {\n   |                  ^^^^^^^^ method not\
    \ found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut i = 0;\n    let mut k = 0;\n    let mut j =\
    \ 0;\n    let mut h = 0;\n    let mut g = 0;\n    let mut vowels: Vec<char> =\
    \ vec!['a', 'e', 'i', 'o', 'u'];\n    let mut z: Vec<char> = vec!['a', 'e', 'i',\
    \ 'o', 'u'];\n    let mut result = String::new();\n    let mut result1 = String::new();\n\
    \    let mut result2 = String::new();\n    let mut result3 = String::new();\n\
    \    let mut result4 = String::new();\n    let word1 = word.chars().collect::<Vec<char>>();\n\
    \    //for a in word.chars() {\n    for a in word1 {\n        //println!(\"{}\"\
    , a);\n        if vowels.contains(&a) {\n            i = k;\n            let b\
    \ = a.to_string();\n            result = result + &b;\n            j = 1;\n  \
    \      }\n        else if j == 1 {\n            let b = a.to_string();\n     \
    \       result1 = result1 + &b;\n            h = 1;\n        }\n        else if\
    \ h == 1 {\n            let b = a.to_string();\n            result2 = result2\
    \ + &b;\n            g = 1;\n        }\n        else if g == 1 {\n           \
    \ let b = a.to_string();\n            result3 = result3 + &b;\n        }\n   \
    \     k = k + 1;\n    }\n    if i == 0 {\n        result4 = \"\".to_string();\n\
    \    }\n    else {\n        result4 = result.chars().rev().collect::<String>();\n\
    \    }\n    result4\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"uo\"`,\n right: `\"u\"`', /tmp/tmpqmngsf9a.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    for (i, ch) in word.chars().rev().enumerate() {\n \
    \       match ch {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n           \
    \     if i == 0 {\n                    return String::new();\n               \
    \ } else {\n                    return ch.to_string();\n                }\n  \
    \          }\n            _ => (),\n        }\n    }\n    String::new()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp_1lsigxh.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|c| !c.is_ascii_alphabetic()).skip(1).take_while(|c|\
    \ !c.is_ascii_alphabetic()).skip_while(|c| !c.is_ascii_alphabetic()).next().unwrap_or('\
    \ ').to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n \
    \   assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n  \
    \  assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" \"`,\n right: `\"u\"`', /tmp/tmp4_id3xtf.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = \"\".to_string();\n    let mut i = word.len()\
    \ - 1;\n    while i >= 0 {\n        if \"AEIOU\".contains(word.chars().nth(i).unwrap())\
    \ {\n            res = word.chars().nth(i).unwrap().to_string();\n           \
    \ i -= 1;\n            break;\n        }\n        i -= 1;\n    }\n    while i\
    \ >= 0 {\n        if \"AEIOU\".contains(word.chars().nth(i).unwrap()) {\n    \
    \        break;\n        }\n        if !\"AEIOU\".contains(word.chars().nth(i).unwrap())\
    \ {\n            return res;\n        }\n        i -= 1;\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpb5ldrbs9.rs:16:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let chars: Vec<char> = word.chars().collect();\n    let length = chars.len();\n\
    \    for i in 0..length {\n        if vowels.contains(&chars[i].to_string().as_str())\
    \ {\n            if i > 0 && i < length - 1 {\n                if !vowels.contains(&chars[i\
    \ - 1].to_string().as_str()) && !vowels.contains(&chars[i + 1].to_string().as_str())\
    \ {\n                    return chars[i].to_string();\n                }\n   \
    \         }\n        }\n    }\n    return \"\".to_string();\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp_sj0a9wn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut best_vowel = \"\";\n    let mut best_distance\
    \ = word.len();\n    for (i, ch) in word.chars().enumerate() {\n        if ch\
    \ == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n            if\
    \ i + 1 < word.len() && is_consonant(word.chars().nth(i + 1).unwrap()) {\n   \
    \             if i + 2 < word.len() && is_consonant(word.chars().nth(i + 2).unwrap())\
    \ {\n                    return String::from(\"\");\n                }\n     \
    \           let distance = word.len() - i - 1;\n                if distance <\
    \ best_distance {\n                    best_distance = distance;\n           \
    \         best_vowel = ch.to_string().as_str();\n                }\n         \
    \   }\n        }\n    }\n    return String::from(best_vowel);\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpe0j3qofe.rs:12:38\n   |\n12 |             if i + 1 < word.len() && is_consonant(word.chars().nth(i\
    \ + 1).unwrap()) {\n   |                                      ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `is_consonant` in\
    \ this scope\n  --> /tmp/tmpe0j3qofe.rs:13:42\n   |\n13 |                 if i\
    \ + 2 < word.len() && is_consonant(word.chars().nth(i + 2).unwrap()) {\n   | \
    \                                         ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = 0;\n    for (i, c) in word.chars().enumerate()\
    \ {\n        if c.is_lowercase() && c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' {\n            index = i;\n        }\n    }\n    word.chars().skip(index).take(1).collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpxhqbuolk.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ consonant_count = 0;\n    for c in word.chars().rev() {\n        if !is_vowel(c)\
    \ {\n            consonant_count += 1;\n        } else if consonant_count >= 2\
    \ {\n            closest_vowel.push(c);\n            break;\n        }\n    }\n\
    \    closest_vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpd116l_qa.rs:11:13\n\
    \   |\n11 |         if !is_vowel(c) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().collect::<Vec<char>>();\n \
    \   let mut i = word.len() - 1;\n    let mut last_cons = false;\n    let mut close_vowel\
    \ = String::new();\n    while i > 0 {\n        if is_vowel(word[i]) {\n      \
    \      if last_cons {\n                close_vowel.push(word[i]);\n          \
    \      break;\n            }\n        } else {\n            last_cons = true;\n\
    \        }\n        i -= 1;\n    }\n    close_vowel\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpppux9yeh.rs:13:12\n\
    \   |\n13 |         if is_vowel(word[i]) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().collect::<Vec<char>>();\n \
    \   for (pos, ch) in word.iter().enumerate().rev() {\n        if is_vowel(*ch)\
    \ {\n            for (pos_inner, ch_inner) in word.iter().enumerate().rev() {\n\
    \                if pos_inner <= pos {\n                    continue;\n      \
    \          }\n                if !is_vowel(*ch_inner) {\n                    return\
    \ ch.to_string();\n                }\n            }\n        }\n    }\n    \"\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpg7d_sik2.rs:10:12\n\
    \   |\n10 |         if is_vowel(*ch) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpg7d_sik2.rs:15:21\n   |\n15 |                 if !is_vowel(*ch_inner)\
    \ {\n   |                     ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = String::from(\"aeiou\");\n    let mut\
    \ result = String::new();\n    for (i, c) in word.chars().rev().enumerate() {\n\
    \        if vowels.contains(c) {\n            if i == 0 {\n                break;\n\
    \            }\n            if word.chars().rev().nth(i - 1).unwrap().is_alphabetic()\
    \ {\n                result.push(c);\n                break;\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp7dfn3d7_.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let n = word.len();\n    let word: Vec<char> = word.chars().collect();\n\
    \    for i in (0..n).rev() {\n        let c = word[i];\n        if c.is_ascii_alphabetic()\
    \ {\n            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n\
    \                if i == n - 1 {\n                    return String::new();\n\
    \                }\n                let c1 = word[i + 1];\n                if\
    \ c1.is_ascii_alphabetic() {\n                    return String::new();\n    \
    \            }\n                if i > 0 {\n                    let c2 = word[i\
    \ - 1];\n                    if c2.is_ascii_alphabetic() {\n                 \
    \       return c.to_string();\n                    }\n                }\n    \
    \        }\n        }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp8m7zk6uo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ last_vowel = String::new();\n    let mut result = String::new();\n    let mut\
    \ last_consonant = String::new();\n    let chars = word.chars().collect::<Vec<char>>();\n\
    \    let mut counter = 0;\n    for i in chars.iter().rev() {\n        if i.is_ascii_vowel()\
    \ {\n            if counter > 0 {\n                if last_vowel.is_empty() {\n\
    \                    last_vowel = i.to_string();\n                }\n        \
    \        closest_vowel = i.to_string();\n                break;\n            }\n\
    \        } else {\n            if !last_vowel.is_empty() {\n                if\
    \ !last_consonant.is_empty() {\n                    break;\n                }\n\
    \                last_consonant = i.to_string();\n            }\n            counter\
    \ += 1;\n        }\n    }\n    if !closest_vowel.is_empty() && !last_consonant.is_empty()\
    \ {\n        result = closest_vowel;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_vowel` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpqkkp4o73.rs:15:14\n   |\n15 |         if\
    \ i.is_ascii_vowel() {\n   |              ^^^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    //...\n    unimplemented!()\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp_qkauafa.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // Your code here\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpeujzhs_v.rs:7:39\n  |\n7 |\
    \ fn get_closest_vowel(word: String) -> String {\n  |    -----------------   \
    \               ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let result = word.char_indices().rev().find(|&(index,\
    \ c)| {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n  });\n\
    \  match result {\n    Some((index, c)) => {\n      if index + 1 < word.len()\
    \ {\n        if is_consonant(word.chars().nth(index + 1).unwrap()) {\n       \
    \   return c.to_string();\n        }\n      }\n      if index > 0 {\n        if\
    \ is_consonant(word.chars().nth(index - 1).unwrap()) {\n          return c.to_string();\n\
    \        }\n      }\n      return \"\".to_string();\n    },\n    None => return\
    \ \"\".to_string()\n  }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpxa8jykyv.rs:14:12\n   |\n14 |         if is_consonant(word.chars().nth(index\
    \ + 1).unwrap()) {\n   |            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_consonant` in this scope\n  --> /tmp/tmpxa8jykyv.rs:19:12\n\
    \   |\n19 |         if is_consonant(word.chars().nth(index - 1).unwrap()) {\n\
    \   |            ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.to_lowercase();\n    let mut prev_is_vowel\
    \ = true;\n    let vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let\
    \ mut closest_vowel = None;\n    for letter in word.chars() {\n        if vowels.contains(&letter.to_string().as_str())\
    \ {\n            if !prev_is_vowel {\n                return letter.to_string();\n\
    \            }\n            prev_is_vowel = true;\n        } else {\n        \
    \    prev_is_vowel = false;\n        }\n        if closest_vowel.is_none() &&\
    \ vowels.contains(&letter.to_string().as_str()) {\n            closest_vowel =\
    \ Some(letter);\n        }\n    }\n    closest_vowel.unwrap_or(' ').to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmprpu_lgxp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().find(|&c| c.is_ascii_lowercase()\
    \ && is_vowel(c)).map(|c| c.to_string()).unwrap_or(\"\".to_string())\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n --> /tmp/tmpvzs0xlj4.rs:8:60\n\
    \  |\n8 |     word.chars().rev().find(|&c| c.is_ascii_lowercase() && is_vowel(c)).map(|c|\
    \ c.to_string()).unwrap_or(\"\".to_string())\n  |                            \
    \                                ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut char_iter = word.chars().rev();\n    let mut\
    \ found = false;\n    let mut closest_vowel = String::new();\n    let mut last_char\
    \ = char_iter.next();\n    let mut current_char = char_iter.next();\n    while\
    \ let Some(c) = current_char {\n        if let Some(l) = last_char {\n       \
    \     if !l.is_alphabetic() || !c.is_alphabetic() {\n                last_char\
    \ = current_char;\n                current_char = char_iter.next();\n        \
    \        continue;\n            }\n            if l.is_lowercase() && l.is_alphabetic()\
    \ {\n                if \n                (l == 'a' || l == 'e' || l == 'i' ||\
    \ l == 'o' || l == 'u') &&\n                (c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u')\n                {\n                    closest_vowel.push(l);\n\
    \                    found = true;\n                    break;\n             \
    \   }\n            }\n            if l.is_uppercase() && l.is_alphabetic() {\n\
    \                if \n                (l == 'A' || l == 'E' || l == 'I' || l ==\
    \ 'O' || l == 'U') &&\n                (c != 'A' && c != 'E' && c != 'I' && c\
    \ != 'O' && c != 'U')\n                {\n                    closest_vowel.push(l);\n\
    \                    found = true;\n                    break;\n             \
    \   }\n            }\n        }\n        last_char = current_char;\n        current_char\
    \ = char_iter.next();\n    }\n    if found {\n        return closest_vowel;\n\
    \    }\n    return String::new();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"A\"`,\n right: `\"\"`', /tmp/tmp9ye929cu.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let is_vowel = |&c: &char| \"aeiou\".contains(c);\n\
    \    let chars: Vec<char> = word.chars().collect();\n    for i in 0..chars.len()\
    \ {\n        if is_vowel(&chars[i]) {\n            if i == 0 { continue; }\n \
    \           if i == chars.len() - 1 { continue; }\n            if !is_vowel(&chars[i\
    \ - 1]) && !is_vowel(&chars[i + 1]) {\n                return chars[i].to_string();\n\
    \            }\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n   \
    \ let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpovidrb_n.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut distance = std::usize::MAX;\n    let mut vowel\
    \ = String::new();\n    for c in word.chars() {\n        if  c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' {\n            vowel = c.to_string();\n\
    \            break;\n        }\n    }\n    let letters: Vec<_> = word.chars().collect();\n\
    \    for i in 0..letters.len() {\n        let c = letters[i];\n        if  c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            let mut check\
    \ = false;\n            for j in (i + 1)..letters.len() {\n                let\
    \ c = letters[j];\n                if c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u' {\n                    check = true;\n                    continue;\n\
    \                }\n                if check && j - i < distance {\n         \
    \           distance = j - i;\n                    vowel = letters[i].to_string();\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp70_7lzge.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // To do\n    let mut vowels = \"\";\n    let mut cons\
    \ = \"\";\n    let chars = word.as_bytes();\n    for i in 0..chars.len() {\n \
    \       if i == 0 {\n            if is_vowel(&chars[i]) {\n                vowels.push(chars[i]\
    \ as char);\n            } else {\n                cons.push(chars[i] as char);\n\
    \            }\n        } else {\n            if is_vowel(&chars[i]) {\n     \
    \           if !is_vowel(&chars[i - 1]) {\n                    vowels.push(chars[i]\
    \ as char);\n                }\n            } else {\n                if is_vowel(&chars[i\
    \ - 1]) {\n                    cons.push(chars[i] as char);\n                }\n\
    \            }\n        }\n    }\n    let mut min = 1000;\n    let mut result\
    \ = String::new();\n    let cons_chars = cons.as_bytes();\n    let vowels_chars\
    \ = vowels.as_bytes();\n    for (i, c) in cons_chars.iter().enumerate() {\n  \
    \      for (j, v) in vowels_chars.iter().enumerate() {\n            if i > j {\n\
    \                if i - j < min {\n                    min = i - j;\n        \
    \            result = (*v as char).to_string();\n                }\n         \
    \   }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpbv3yqje_.rs:14:16\n\
    \   |\n14 |             if is_vowel(&chars[i]) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmpbv3yqje_.rs:20:16\n   |\n20 |             if is_vowel(&chars[i])\
    \ {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel` in this scope\n  --> /tmp/tmpbv3yqje_.rs:21:21\n  \
    \ |\n21 |                 if !is_vowel(&chars[i - 1]) {\n   |                \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel`\
    \ in this scope\n  --> /tmp/tmpbv3yqje_.rs:25:20\n   |\n25 |                 if\
    \ is_vowel(&chars[i - 1]) {\n   |                    ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0599]: no method named `push` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpbv3yqje_.rs:15:24\n   |\n15 |             \
    \    vowels.push(chars[i] as char);\n   |                        ^^^^ method not\
    \ found in `&str`\n\nerror[E0599]: no method named `push` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpbv3yqje_.rs:17:22\n   |\n17 |   \
    \              cons.push(chars[i] as char);\n   |                      ^^^^ method\
    \ not found in `&str`\n\nerror[E0599]: no method named `push` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpbv3yqje_.rs:22:28\n   |\n22 |   \
    \                  vowels.push(chars[i] as char);\n   |                      \
    \      ^^^^ method not found in `&str`\n\nerror[E0599]: no method named `push`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpbv3yqje_.rs:26:26\n\
    \   |\n26 |                     cons.push(chars[i] as char);\n   |           \
    \               ^^^^ method not found in `&str`\n\nerror: aborting due to 8 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().filter(|&(i, c)| i > 0 &&\
    \ i < word.len() - 1).rev().find(|&(_, c)| {\n        (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') &&\n        (word.chars().nth(i - 1).unwrap()\
    \ != 'a' && word.chars().nth(i - 1).unwrap() != 'e' && word.chars().nth(i - 1).unwrap()\
    \ != 'i' && word.chars().nth(i - 1).unwrap() != 'o' && word.chars().nth(i - 1).unwrap()\
    \ != 'u') &&\n        (word.chars().nth(i + 1).unwrap() != 'a' && word.chars().nth(i\
    \ + 1).unwrap() != 'e' && word.chars().nth(i + 1).unwrap() != 'i' && word.chars().nth(i\
    \ + 1).unwrap() != 'o' && word.chars().nth(i + 1).unwrap() != 'u')\n    }).map(|(_,\
    \ c)| c.to_string()).unwrap_or(String::new())\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpoycxlui9.rs:10:27\n\
    \   |\n10 | ...   (word.chars().nth(i - 1).unwrap() != 'a' && word.chars().nth(i\
    \ - 1).unwrap() != 'e' && word.chars().nth(i - 1).unwrap() != 'i' && w...\n  \
    \ |                         ^ help: a local variable with a similar name exists:\
    \ `c`\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpoycxlui9.rs:10:70\n\
    \   |\n10 | ...   (word.chars().nth(i - 1).unwrap() != 'a' && word.chars().nth(i\
    \ - 1).unwrap() != 'e' && word.chars().nth(i - 1).unwrap() != 'i' && w...\n  \
    \ |                                                                    ^ help:\
    \ a local variable with a similar name exists: `c`\n\nerror[E0425]: cannot find\
    \ value `i` in this scope\n  --> /tmp/tmpoycxlui9.rs:10:113\n   |\n10 | ...1).unwrap()\
    \ != 'e' && word.chars().nth(i - 1).unwrap() != 'i' && word.chars().nth(i - 1).unwrap()\
    \ != 'o' && word.chars().nth(i - 1).un...\n   |                              \
    \             ^ help: a local variable with a similar name exists: `c`\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmpoycxlui9.rs:10:156\n   |\n\
    10 | ...1).unwrap() != 'i' && word.chars().nth(i - 1).unwrap() != 'o' && word.chars().nth(i\
    \ - 1).unwrap() != 'u') &&\n   |                                           ^ help:\
    \ a local variable with a similar name exists: `c`\n\nerror[E0425]: cannot find\
    \ value `i` in this scope\n  --> /tmp/tmpoycxlui9.rs:10:199\n   |\n10 | ...1).unwrap()\
    \ != 'o' && word.chars().nth(i - 1).unwrap() != 'u') &&\n   |                \
    \                           ^ help: a local variable with a similar name exists:\
    \ `c`\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpoycxlui9.rs:11:27\n\
    \   |\n11 | ...   (word.chars().nth(i + 1).unwrap() != 'a' && word.chars().nth(i\
    \ + 1).unwrap() != 'e' && word.chars().nth(i + 1).unwrap() != 'i' && w...\n  \
    \ |                         ^ help: a local variable with a similar name exists:\
    \ `c`\n\nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpoycxlui9.rs:11:70\n\
    \   |\n11 | ...   (word.chars().nth(i + 1).unwrap"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let mut word = word.chars().collect::<Vec<char>>();\n\
    \  word.reverse();\n  let mut result = String::new();\n  let mut vowel_found =\
    \ false;\n  for i in 0..word.len()-1 {\n    if (word[i].is_vowel() && word[i+1].is_consonant())\
    \ ||\n       (word[i].is_consonant() && word[i+1].is_vowel()) {\n      result.push(word[i+1]);\n\
    \      vowel_found = true;\n      break;\n    }\n  }\n  if vowel_found {\n   \
    \ result.chars().rev().collect::<String>()\n  } else {\n    result\n  }\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpr1bq9g8a.rs:13:17\n   |\n13 |     if (word[i].is_vowel()\
    \ && word[i+1].is_consonant()) ||\n   |                 ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_consonant` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpr1bq9g8a.rs:13:41\n   |\n13 |     if (word[i].is_vowel()\
    \ && word[i+1].is_consonant()) ||\n   |                                      \
    \   ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `is_consonant`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpr1bq9g8a.rs:14:17\n\
    \   |\n14 |        (word[i].is_consonant() && word[i+1].is_vowel()) {\n   |  \
    \               ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmpr1bq9g8a.rs:14:45\n\
    \   |\n14 |        (word[i].is_consonant() && word[i+1].is_vowel()) {\n   |  \
    \                                           ^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ res = String::new();\n    let mut i = 0;\n    for c in word.chars().rev() {\n\
    \        if vowels.contains(&c) {\n            res.push(c);\n            i +=\
    \ 1;\n        } else if i > 0 {\n            return res;\n        }\n    }\n \
    \   String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmpopdfqs4d.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| !(c.is_alphabetic()\
    \ && !c.is_lowercase())).skip(1).find(|&c| c.is_alphabetic() && c.is_lowercase()).unwrap_or('\\\
    0').to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\\u{0}\"`,\n right: `\"u\"`', /tmp/tmpbupmkz85.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().skip_while(|&(i, _)| i ==\
    \ 0 || i == word.len() - 1)\n        .take_while(|&(i, _)| i < word.len() - 1)\n\
    \        .fold((\"\", std::i32::MAX), |(acc, dist), (i, c)| {\n            let\
    \ j = if i == 0 { 1 } else { i - 1 };\n            if !is_vowel(c) && is_vowel(word.chars().nth(j).unwrap())\
    \ &&\n               (i - j).abs() < dist {\n                (c.to_string(), (i\
    \ - j).abs())\n            } else {\n                (acc, dist)\n           \
    \ }\n        }).0\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmps2eaj5ma.rs:12:17\n\
    \   |\n12 |             if !is_vowel(c) && is_vowel(word.chars().nth(j).unwrap())\
    \ &&\n   |                 ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_vowel` in this scope\n  --> /tmp/tmps2eaj5ma.rs:12:32\n  \
    \ |\n12 |             if !is_vowel(c) && is_vowel(word.chars().nth(j).unwrap())\
    \ &&\n   |                                ^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `abs` found for type `usize` in the current scope\n\
    \  --> /tmp/tmps2eaj5ma.rs:13:24\n   |\n13 |                (i - j).abs() < dist\
    \ {\n   |                        ^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps2eaj5ma.rs:14:18\n   |\n14 |              \
    \   (c.to_string(), (i - j).abs())\n   |                  ^^^^^^^^^^^^^\n   |\
    \                  |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&c.to_string()`\n\nerror[E0599]:\
    \ no method named `abs` found for type `usize` in the current scope\n  --> /tmp/tmps2eaj5ma.rs:14:41\n\
    \   |\n14 |                 (c.to_string(), (i - j).abs())\n   |             \
    \                            ^^^ method not found in `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps2eaj5ma.rs:8:5\n   |\n7  |   fn get_closest_vowel(word:\
    \ String) -> String {\n   |                                         ------ expected\
    \ `String` because of return type\n8  | /     word.chars().enumerate().skip_while(|&(i,\
    \ _)| i == 0 || i == word.len() - 1)\n9  | |         .take_while(|&(i, _)| i <\
    \ word.len() - 1)\n10 | |         .fold((\"\", std::i32::MAX), |(acc, dist), (i,\
    \ c)| {\n11 | |             let j = if i == 0 { 1 } else { i - 1 };\n...  |\n\
    17 | |             }\n18 | |         }).0\n   | |            ^- help: try using\
    \ a conversion method: `.to_string()`\n   | |____________|\n   |             \
    \ expected struct `String`, found `&str`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor\
    \ more"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // println!(\"input {}\", word);\n    let mut res =\
    \ String::new();\n    let mut last_vowel = String::new();\n    for c in word.chars()\
    \ {\n        if is_vowel(c) {\n            last_vowel = c.to_string();\n     \
    \   } else {\n            if !last_vowel.is_empty() {\n                res = last_vowel.clone();\n\
    \                last_vowel = String::new();\n            }\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpp3b_mpuh.rs:12:12\n\
    \   |\n12 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut result = \"\".to_string();\n\
    \    let mut current_index = 0;\n    let mut current_diff = word.len();\n    for\
    \ i in 0..word.len() - 1 {\n        if vowels.contains(&word[i]) && vowels.contains(&word[i\
    \ + 1]) {\n            let current_diff_tmp = (i + 1) - i;\n            if current_diff_tmp\
    \ < current_diff {\n                current_diff = current_diff_tmp;\n       \
    \         current_index = i;\n            }\n        }\n    }\n    if current_diff\
    \ != word.len() {\n        result = word[current_index].to_string();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp68anvur_.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  // make a vector of vowels\n  let vowels = ['a', 'e',\
    \ 'i', 'o', 'u'];\n  // convert the string to a char vector\n  let word_chars:\
    \ Vec<char> = word.chars().collect();\n  // reverse the vec\n  let mut rev_word\
    \ = word_chars.iter().rev().collect::<Vec<&char>>();\n  // iterate thru the vector\n\
    \  for i in 0..rev_word.len() {\n    // if it's a vowel\n    if vowels.contains(rev_word[i])\
    \ {\n      // if it's at the end of the word\n      if rev_word.len() - 1 == i\
    \ {\n        continue;\n      }\n      // if the next element is a vowel\n   \
    \   if vowels.contains(rev_word[i + 1]) {\n        continue;\n      }\n      //\
    \ if the previous element is a vowel\n      if vowels.contains(rev_word[i - 1])\
    \ {\n        continue;\n      }\n      // otherwise return it\n      return rev_word[i].to_string();\n\
    \    }\n  }\n  \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpoe67_mjg.rs:27:35

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.char_indices()\n        .rev()\n        .filter(|&(_,\
    \ c)| {\n            c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\
    \        })\n        .map(|(i, _)| word.chars().skip(i).take(1).collect())\n \
    \       .nth(0)\n        .unwrap_or(String::new())\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpdl2d02yn.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut last_vowel_pos = 0;\n    let mut last_consonant_pos\
    \ = 0;\n    let mut closest_vowel = String::new();\n    let mut closest_consonant\
    \ = String::new();\n    let mut word_char_iter = word.chars();\n    while let\
    \ Some(ch) = word_char_iter.next() {\n        match ch {\n            'a' | 'e'\
    \ | 'i' | 'o' | 'u' => {\n                last_vowel_pos = word_char_iter.as_str().len();\n\
    \                closest_vowel = ch.to_string();\n            },\n           \
    \ _ => {\n                last_consonant_pos = word_char_iter.as_str().len();\n\
    \                closest_consonant = ch.to_string();\n            }\n        }\n\
    \    }\n    if last_vowel_pos != 0 && last_consonant_pos != 0 && last_vowel_pos\
    \ < last_consonant_pos {\n        closest_vowel\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp4e58ksvg.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let word_chars: Vec<char> = word.chars().collect();\n\
    \  let word_len = word_chars.len();\n  let mut found = \"\".to_string();\n  for\
    \ i in 1..word_len {\n    if (word_chars[i - 1].is_ascii_alphabetic() &&\n   \
    \   !word_chars[i - 1].is_ascii_lowercase() &&\n      word_chars[i].is_ascii_lowercase())\n\
    \    {\n      found = word_chars[i].to_string();\n      break;\n    }\n  }\n \
    \ return found;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpbsqpzj4r.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word_chars: Vec<char> = word.chars().collect();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut vowel_index = word_chars.len();\n\
    \    let mut consonant_index = -1;\n    let mut min_distance = word_chars.len();\n\
    \    for (index, ch) in word_chars.iter().enumerate() {\n        if vowels.contains(ch)\
    \ {\n            vowel_index = index;\n        } else {\n            consonant_index\
    \ = index;\n        }\n        if vowel_index < consonant_index {\n          \
    \  let distance = consonant_index - vowel_index;\n            if distance < min_distance\
    \ {\n                min_distance = distance;\n            }\n        }\n    }\n\
    \    if min_distance == word_chars.len() {\n        String::from(\"\")\n    }\
    \ else {\n        String::from(word_chars[vowel_index].to_string())\n    }\n}\n\
    \nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpvlgwomsm.rs:11:31\n\
    \   |\n11 |     let mut consonant_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| is_vowel(c)).skip(1).take_while(|&c|\
    \ is_vowel(c)).collect()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n --> /tmp/tmpu3fs23rl.rs:8:40\n\
    \  |\n8 |     word.chars().rev().skip_while(|&c| is_vowel(c)).skip(1).take_while(|&c|\
    \ is_vowel(c)).collect()\n  |                                        ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n --> /tmp/tmpu3fs23rl.rs:8:77\n  |\n8 |     word.chars().rev().skip_while(|&c|\
    \ is_vowel(c)).skip(1).take_while(|&c| is_vowel(c)).collect()\n  |           \
    \                                                                  ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let mut result = String::new();\n  let mut first_consonant_found\
    \ = false;\n  let mut closest_vowel_found = false;\n  let mut closest_vowel_position\
    \ = 0;\n  let mut consonant_position = 0;\n  let mut word_length = word.len();\n\
    \  let mut word_chars = word.chars();\n  let mut word_iter = word_chars.rev();\n\
    \  while word_length > 0 {\n    word_length -= 1;\n    match word_iter.next()\
    \ {\n      Some(v) => {\n        if closest_vowel_found {\n          if is_consonant(v)\
    \ {\n            result = word[consonant_position + 1..closest_vowel_position\
    \ + 1].to_string();\n            break;\n          }\n        } else {\n     \
    \     if is_consonant(v) {\n            if first_consonant_found {\n         \
    \     closest_vowel_found = true;\n              closest_vowel_position = word_length;\n\
    \            } else {\n              first_consonant_found = true;\n         \
    \     consonant_position = word_length;\n            }\n          } else {\n \
    \           if first_consonant_found {\n              closest_vowel_found = true;\n\
    \              closest_vowel_position = word_length;\n            }\n        \
    \  }\n        }\n      },\n      None => {\n        break;\n      }\n    }\n \
    \ }\n  result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmpkgteqqqw.rs:21:14\n   |\n21 |           if is_consonant(v) {\n   | \
    \             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_consonant` in this scope\n  --> /tmp/tmpkgteqqqw.rs:26:14\n   |\n\
    26 |           if is_consonant(v) {\n   |              ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word_chars: Vec<char> = word.chars().collect();\n\
    \    let mut iter_chars = word_chars.iter();\n    let mut prev_char: Option<char>\
    \ = None;\n    let mut result = None;\n    while let Some(c) = iter_chars.next()\
    \ {\n        if let Some(prev) = prev_char {\n            if !is_vowel(*c) &&\
    \ is_vowel(*prev) {\n                result = Some(*prev);\n                break;\n\
    \            }\n        }\n        prev_char = Some(*c);\n    }\n    result.map(|x|\
    \ x.to_string()).unwrap_or(\"\".to_string())\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpro138zzl.rs:14:17\n\
    \   |\n14 |             if !is_vowel(*c) && is_vowel(*prev) {\n   |          \
    \       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_vowel` in this scope\n  --> /tmp/tmpro138zzl.rs:14:33\n   |\n14 |      \
    \       if !is_vowel(*c) && is_vowel(*prev) {\n   |                          \
    \       ^^^^^^^^ not found in this scope\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmpro138zzl.rs:14:42\n   |\n14 |             if !is_vowel(*c)\
    \ && is_vowel(*prev) {\n   |                                          ^^^^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpro138zzl.rs:15:31\n\
    \   |\n15 |                 result = Some(*prev);\n   |                      \
    \         ^^^^^\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word_vec: Vec<char> = word.chars().collect();\n\
    \    let mut vowels = String::new();\n    let mut pos = -1;\n    for (i, c) in\
    \ word_vec.iter().enumerate() {\n        match c {\n            'a' | 'e' | 'i'\
    \ | 'o' | 'u' => {\n                vowels.push(*c);\n                pos = i;\n\
    \            }\n            _ => continue,\n        }\n    }\n    if pos == -1\
    \ {\n        return String::new();\n    }\n    String::from_utf8(vec![word_vec[pos]\
    \ as u8]).unwrap()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpy9264awr.rs:10:19\n\
    \   |\n10 |     let mut pos = -1;\n   |                   ^^ the trait `Neg` is\
    \ not implemented for `usize`\n\nerror[E0600]: cannot apply unary operator `-`\
    \ to type `usize`\n  --> /tmp/tmpy9264awr.rs:20:15\n   |\n20 |     if pos == -1\
    \ {\n   |               ^^\n   |               |\n   |               cannot apply\
    \ unary operator `-`\n   |               help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_vowel\
    \ = false;\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    for c in word.chars().rev()\
    \ {\n        if found_vowel && !vowels.contains(&c) {\n            break;\n  \
    \      }\n        if vowels.contains(&c) {\n            result.push(c);\n    \
    \        found_vowel = true;\n        }\n    }\n    result.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ea\"`,\n right: `\"\"`', /tmp/tmpqwaiqcq7.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    let mut result = String::new();\n    for c in word.chars().rev() {\n    \
    \    if vowels.contains(&c.to_string().as_str()) {\n            result = c.to_string();\n\
    \            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp93ab7wvf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ word_split: Vec<char> = word.chars().collect();\n    let mut result = String::new();\n\
    \    let mut counter = word_split.len() - 1;\n    while counter >= 0 {\n     \
    \   if vowels.contains(&word_split[counter]) {\n            if counter == 0 {\n\
    \                break;\n            }\n            if !vowels.contains(&word_split[counter\
    \ - 1]) {\n                result = word_split[counter].to_string();\n       \
    \         break;\n            }\n        }\n        counter -= 1;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp3rv8mjvk.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = Vec::new();\n    let mut chars = word.chars().peekable();\n\
    \    while let Some(c) = chars.next() {\n        if \"aeiou\".contains(c) {\n\
    \            vowels.push(c);\n        }\n        if let Some(&cc) = chars.peek()\
    \ {\n            if \"aeiou\".contains(cc) {\n                vowels.pop();\n\
    \            }\n        }\n    }\n    vowels.pop().unwrap_or(' ').to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpvuyojf3w.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut pos: i32 = -1;\n    let mut min: i32 = 1000;\n\
    \    let word = word.as_bytes();\n    for i in 0..word.len() {\n        let mut\
    \ found = false;\n        match word[i] {\n            b'a' | b'e' | b'i' | b'o'\
    \ | b'u' => {\n                for j in i+1..word.len() {\n                  \
    \  match word[j] {\n                        b'a' | b'e' | b'i' | b'o' | b'u' =>\
    \ {\n                            found = true;\n                            break;\n\
    \                        },\n                        _ => ()\n               \
    \     }\n                }\n                if !found {\n                    if\
    \ min > i as i32 {\n                        min = i as i32;\n                \
    \        pos = i as i32;\n                    }\n                }\n         \
    \   },\n            _ => ()\n        }\n    }\n    if pos == -1 {\n        return\
    \ String::from(\"\")\n    }\n    word[pos as usize] as char.to_string()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpek47a_bn.rs:37:5\n\
    \   |\n37 |     word[pos as usize] as char.to_string()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\nhelp: try surrounding the expression in parentheses\n   |\n37 |     (word[pos\
    \ as usize] as char).to_string()\n   |     +                          +\n\nerror:\
    \ aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut found_vowel = String::new();\n    let mut found_consonant = false;\n   \
    \ let mut start_searching = false;\n    for c in word.chars().rev() {\n      \
    \  if vowels.contains(&c) {\n            if start_searching {\n              \
    \  found_vowel.push(c);\n                break;\n            }\n        } else\
    \ {\n            if found_consonant {\n                found_vowel.push(c);\n\
    \                start_searching = true;\n            } else {\n             \
    \   found_consonant = true;\n            }\n        }\n    }\n    found_vowel.chars().rev().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ur\"`,\n right: `\"u\"`', /tmp/tmp8d9njt8p.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut chars = word.chars().rev().peekable();\n  \
    \  if let Some(c) = chars.next() {\n        if is_vowel(c) {\n            return\
    \ String::new();\n        }\n    }\n    loop {\n        if let Some(c) = chars.next()\
    \ {\n            if is_vowel(c) {\n                return chars.peek().map_or(String::new(),\
    \ |c| {\n                    if is_vowel(*c) {\n                        String::new()\n\
    \                    } else {\n                        c.to_string()\n       \
    \             }\n                });\n            }\n        } else {\n      \
    \      return String::new();\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp4tw221el.rs:10:12\n\
    \   |\n10 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp4tw221el.rs:16:16\n   |\n16 |             if is_vowel(c) {\n   |   \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_vowel` in this scope\n  --> /tmp/tmp4tw221el.rs:18:24\n   |\n18 |      \
    \               if is_vowel(*c) {\n   |                        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<char>>();\n\
    \    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut l = None;\n    let mut\
    \ r = None;\n    for i in 0..word.len() {\n        if vowels.contains(&word[i])\
    \ {\n            r = Some(i);\n            break;\n        }\n    }\n    for i\
    \ in 0..word.len() {\n        if vowels.contains(&word[i]) {\n            l =\
    \ Some(i);\n        }\n        if l.is_some() && r.is_some() {\n            break;\n\
    \        }\n    }\n    match (l, r) {\n        (Some(l), Some(r)) => if r > l\
    \ {\n            return word[l..r].iter().collect();\n        } else {\n     \
    \       return word[r..l].iter().collect();\n        },\n        (Some(l), None)\
    \ => return word[l..].iter().collect(),\n        (None, Some(r)) => return word[r..].iter().collect(),\n\
    \        _ => \"\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp_f11c72a.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    let mut word = word.chars().collect::<Vec<char>>();\n    word.reverse();\n\
    \    let mut found = false;\n    let mut before_vowel = String::from(\"\");\n\
    \    let mut after_vowel = String::from(\"\");\n    let mut previous_char = '\
    \ ';\n    for (i, x) in word.iter().enumerate() {\n        if found && is_consonant(x)\
    \ {\n            before_vowel = after_vowel.clone();\n            after_vowel\
    \ = String::from(\"\");\n        }\n        if is_vowel(x) {\n            found\
    \ = true;\n            after_vowel.push(*x);\n        }\n        previous_char\
    \ = *x;\n    }\n    if after_vowel.len() > 0 {\n        return after_vowel;\n\
    \    }\n    if before_vowel.len() > 0 {\n        return before_vowel;\n    }\n\
    \    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_consonant` in this scope\n  -->\
    \ /tmp/tmp4n6yim0g.rs:18:21\n   |\n18 |         if found && is_consonant(x) {\n\
    \   |                     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmp4n6yim0g.rs:22:12\n\
    \   |\n22 |         if is_vowel(x) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ chars: Vec<char> = word.chars().collect();\n    let mut output = vec![];\n \
    \   let mut vowel_output = vec![];\n    let mut vowel_index = 0;\n    for (index,\
    \ &char) in chars.iter().enumerate() {\n        if !vowels.contains(&char) {\n\
    \            output.push(char);\n        } else {\n            vowel_output.push(char);\n\
    \            vowel_index = index;\n        }\n    }\n    if output.len() == 0\
    \ {\n        return \"\".to_string();\n    }\n    vowel_output.remove(0);\n  \
    \  if vowel_output.len() == 0 {\n        return \"\".to_string();\n    }\n   \
    \ let mut vowel_position = 0;\n    for (index, &char) in output.iter().enumerate()\
    \ {\n        if char == chars[vowel_index] {\n            vowel_position = index;\n\
    \        }\n    }\n    return output[vowel_position].to_string();\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"y\"`,\n right: `\"u\"`', /tmp/tmpkgjifjyu.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let chars: Vec<char> =\
    \ word.chars().collect();\n    for i in (0..chars.len() - 1).rev() {\n       \
    \ if vowels.contains(chars[i]) && !vowels.contains(chars[i + 1]) {\n         \
    \   return chars[i].to_string();\n        }\n    }\n    \"\".to_string()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpkjl7lkrp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.match_indices(is_vowel)\n        .filter(|(idx,\
    \ _)| is_consonant(&word[..*idx]) && is_consonant(&word[*idx + 1..]))\n      \
    \  .map(|(_, vowel)| vowel.to_string())\n        .last()\n        .unwrap_or_else(||\
    \ \"\".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `is_vowel` in this scope\n --> /tmp/tmp9xtrxm32.rs:8:24\n\
    \  |\n8 |     word.match_indices(is_vowel)\n  |                        ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_consonant`\
    \ in this scope\n --> /tmp/tmp9xtrxm32.rs:9:28\n  |\n9 |         .filter(|(idx,\
    \ _)| is_consonant(&word[..*idx]) && is_consonant(&word[*idx + 1..]))\n  |   \
    \                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_consonant` in this scope\n --> /tmp/tmp9xtrxm32.rs:9:59\n\
    \  |\n9 |         .filter(|(idx, _)| is_consonant(&word[..*idx]) && is_consonant(&word[*idx\
    \ + 1..]))\n  |                                                           ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut prev_vowel_idx = word.len();\n    for (idx,\
    \ ch) in word.char_indices().rev() {\n        match ch {\n            'a' | 'e'\
    \ | 'i' | 'o' | 'u' => {\n                if (idx + 1) < prev_vowel_idx {\n  \
    \                  prev_vowel_idx = idx;\n                }\n            }\n \
    \           _ => continue,\n        }\n    }\n    if prev_vowel_idx == word.len()\
    \ {\n        return String::new();\n    }\n\n    let mut next_vowel_idx = word.len();\n\
    \    for (idx, ch) in word.char_indices().rev() {\n        match ch {\n      \
    \      'a' | 'e' | 'i' | 'o' | 'u' => {\n                if idx > prev_vowel_idx\
    \ && idx < next_vowel_idx {\n                    next_vowel_idx = idx;\n     \
    \           }\n            }\n            _ => continue,\n        }\n    }\n \
    \   if next_vowel_idx == word.len() {\n        return String::new();\n    }\n\n\
    \    let mut prev_vowel_dist = 0;\n    let mut next_vowel_dist = 0;\n    for (idx,\
    \ ch) in word.char_indices().rev() {\n        match ch {\n            'a' | 'e'\
    \ | 'i' | 'o' | 'u' => {\n                if idx == prev_vowel_idx {\n       \
    \             prev_vowel_dist = word.len() - idx;\n                }\n       \
    \         if idx == next_vowel_idx {\n                    next_vowel_dist = word.len()\
    \ - idx;\n                }\n            }\n            _ => continue,\n     \
    \   }\n    }\n\n    if prev_vowel_dist <= next_vowel_dist {\n        return word[prev_vowel_idx..prev_vowel_idx\
    \ + 1].to_string();\n    } else {\n       \n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuv5jyuht.rs:75:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n56 |     } else {\n\
    \   |            - this delimiter might not be properly closed...\n57 |      \
    \  \n58 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    75 | }\n   |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpuv5jyuht.rs:7:39\n\
    \  |\n7 | fn get_closest_vowel(word: String) -> String {\n  |    -----------------\
    \                  ^^^^^^ expected struct `String`, found `()`\n  |    |\n  |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index: usize = word.len();\n    let chars:\
    \ Vec<char> = word.chars().collect();\n    let mut i: usize = chars.len() - 1;\n\
    \    let mut answer: String = String::new();\n    let mut distance: i32 = 0;\n\
    \    let mut temp: i32 = 0;\n    for j in i..chars.len() {\n        if is_vowel(chars[j])\
    \ {\n            continue;\n        } else {\n            index = j - 1;\n   \
    \         break;\n        }\n    }\n    for i in (0..index).rev() {\n        if\
    \ is_vowel(chars[i]) {\n            if distance == 0 {\n                distance\
    \ = index as i32 - i as i32;\n                answer = chars[i].to_string();\n\
    \            } else {\n                temp = index as i32 - i as i32;\n     \
    \           if temp < distance {\n                    distance = temp;\n     \
    \               answer = chars[i].to_string();\n                }\n          \
    \  }\n        }\n    }\n    return answer;\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpc9al_f53.rs:15:12\n\
    \   |\n15 |         if is_vowel(chars[j]) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpc9al_f53.rs:23:12\n   |\n23 |         if is_vowel(chars[i]) {\n\
    \   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // get the reversed string, first\n    let mut reversed_str\
    \ = word.chars().rev().collect::<String>();\n    let mut flag = false;\n    let\
    \ mut new_str = String::new();\n    let mut vowel_map = HashMap::new();\n    vowel_map.insert('a',\
    \ 0);\n    vowel_map.insert('e', 0);\n    vowel_map.insert('i', 0);\n    vowel_map.insert('o',\
    \ 0);\n    vowel_map.insert('u', 0);\n    let mut j = 0;\n    // get the indexes\
    \ of vowels\n    for (i, c) in reversed_str.chars().enumerate() {\n        if\
    \ vowel_map.contains_key(&c) {\n            if flag {\n                flag =\
    \ false;\n                new_str.push(c);\n                j = i;\n         \
    \       break;\n            }\n            flag = true;\n        }\n    }\n  \
    \  // get the substring\n    let str_slice = &reversed_str[j..];\n    // reverse\
    \ it\n    let new_str = str_slice.chars().rev().collect::<String>();\n    new_str\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpi20t05md.rs:12:25\n   |\n12 |     let mut vowel_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let chars: Vec<char> = word.chars().collect();\n  \
    \  for i in (0..word.len()).rev() {\n        if !is_vowel(chars[i]) {\n      \
    \      if i < word.len() - 1 && is_vowel(chars[i + 1]) {\n                return\
    \ chars[i + 1].to_string();\n            } else if i >= 1 && is_vowel(chars[i\
    \ - 1]) {\n                return chars[i - 1].to_string();\n            }\n \
    \       }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpnpd6mgkv.rs:10:13\n\
    \   |\n10 |         if !is_vowel(chars[i]) {\n   |             ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpnpd6mgkv.rs:11:38\n   |\n11 |             if i < word.len() - 1\
    \ && is_vowel(chars[i + 1]) {\n   |                                      ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmpnpd6mgkv.rs:13:33\n   |\n13 |             } else if\
    \ i >= 1 && is_vowel(chars[i - 1]) {\n   |                                 ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"AEIOU\";\n    let consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\
    ;\n    let chars = word.chars().collect::<Vec<char>>();\n    let mut chars = chars.iter().rev();\n\
    \    let mut prev = ' ';\n    let mut next = ' ';\n    let mut i = 0;\n    let\
    \ mut vowel = ' ';\n    while let Some(ch) = chars.next() {\n        if !vowels.contains(*ch)\
    \ {\n            if !consonants.contains(*ch) {\n                if !vowels.contains(prev)\
    \ {\n                    prev = *ch;\n                    vowel = ' ';\n     \
    \           }\n            } else {\n                next = *ch;\n           \
    \     vowel = ' ';\n            }\n        } else {\n            if consonants.contains(prev)\
    \ && consonants.contains(next) {\n                break;\n            } else {\n\
    \                vowel = *ch;\n            }\n        }\n        i += 1;\n   \
    \ }\n    let mut res = String::new();\n    if i < word.len() {\n        res.push(vowel);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpua3aaig3.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = HashSet::new();\n    vowels.insert('a');\n\
    \    vowels.insert('e');\n    vowels.insert('i');\n    vowels.insert('o');\n \
    \   vowels.insert('u');\n    let mut chars = word.chars().collect::<Vec<char>>();\n\
    \    chars.reverse();\n    let mut first_vowel = ' ';\n    let mut first_consonant\
    \ = ' ';\n    for c in chars {\n        if vowels.contains(&c) {\n           \
    \ first_vowel = c;\n        } else {\n            if first_vowel != ' ' {\n  \
    \              first_consonant = c;\n                break;\n            }\n \
    \       }\n    }\n    if first_vowel == ' ' {\n        return String::new();\n\
    \    }\n    if first_consonant == ' ' {\n        first_consonant = chars[0];\n\
    \    }\n    let mut output = String::new();\n    output.push(first_vowel);\n \
    \   output.push(first_consonant);\n    output\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmprjlgk72m.rs:8:22\n  |\n8 |     let mut vowels = HashSet::new();\n  |\
    \                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let letters:\
    \ Vec<char> = word.chars().collect();\n    let mut vowel_positions: Vec<usize>\
    \ = Vec::new();\n    let mut consonant_positions: Vec<usize> = Vec::new();\n \
    \   for (i, &letter) in letters.iter().enumerate() {\n        if vowels.contains(&letter)\
    \ {\n            vowel_positions.push(i);\n        } else {\n            consonant_positions.push(i);\n\
    \        }\n    }\n    if vowel_positions.len() == 0 || consonant_positions.len()\
    \ == 0 {\n        return String::from(\"\");\n    }\n    let consonant_positions_len\
    \ = consonant_positions.len();\n    let mut temp_list: Vec<usize> = Vec::new();\n\
    \    for vowel_pos in vowel_positions {\n        for con_pos in consonant_positions.iter().rev()\
    \ {\n            if *con_pos < vowel_pos {\n                temp_list.push(vowel_pos);\n\
    \                break;\n            }\n        }\n    }\n    if temp_list.len()\
    \ == 0 {\n        return String::from(\"\");\n    }\n    let mut closest_vowel_pos\
    \ = temp_list[0];\n    let mut min_distance = closest_vowel_pos - consonant_positions[consonant_positions_len\
    \ - 1];\n    for temp_vowel_pos in temp_list {\n        let temp_distance = temp_vowel_pos\
    \ - consonant_positions[consonant_positions_len - 1];\n        if temp_distance\
    \ < min_distance {\n            min_distance = temp_distance;\n            closest_vowel_pos\
    \ = temp_vowel_pos;\n        }\n    }\n    return letters[closest_vowel_pos].to_string();\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpq9v2wv2o.rs:36:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut ret = \"\".to_string();\n\
    \    let mut was_con = false;\n    let mut out = 0;\n    for (i, ch) in word.chars().rev().enumerate()\
    \ {\n        if vowels.contains(ch) {\n            if was_con {\n            \
    \    ret = format!(\"{}{}\", ch, &word[i..]);\n                break;\n      \
    \      }\n        } else {\n            was_con = true;\n            out = i;\n\
    \        }\n    }\n    if ret.is_empty() { ret = word; }\n    ret[out..].to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"gurt\"`,\n right: `\"u\"`', /tmp/tmp45mm42s9.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ distance = word.len();\n    let mut closest_vowel = ' ';\n    for (i, ch) in\
    \ word.chars().enumerate() {\n        if vowels.contains(&ch) {\n            let\
    \ dis = word.len() - i - 1;\n            if dis < distance {\n               \
    \ distance = dis;\n                closest_vowel = ch;\n            }\n      \
    \  }\n    }\n    if closest_vowel == ' ' {\n        return String::from(\"\");\n\
    \    }\n    return closest_vowel.to_string();\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp4sxyve37.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let mut distance\
    \ = 0;\n    let mut closest_vowel = ' ';\n    for (i, c) in word.chars().rev().enumerate()\
    \ {\n        if vowels.contains(c) {\n            distance = i;\n            closest_vowel\
    \ = c;\n            continue;\n        }\n        if distance > 0 {\n        \
    \    break;\n        }\n    }\n    closest_vowel.to_string()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"e\"`,\n right: `\"\"`', /tmp/tmpkzfafy3e.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut found = \"\".to_string();\n\
    \    let chars = word.chars().rev().collect::<Vec<char>>();\n    for (i, c) in\
    \ chars.iter().enumerate() {\n        if vowels.contains(*c) {\n            if\
    \ i < chars.len() - 1 && !vowels.contains(chars[i + 1]) {\n                found\
    \ = (*c).to_string();\n                break;\n            }\n        }\n    }\n\
    \    found\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"i\"`,\n right: `\"\"`', /tmp/tmp1b01lf6w.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut prev_cons = true;\n    let mut closest_vowel\
    \ = \"\";\n    let mut prev_vowel = \"\";\n    let mut i = word.len() - 1;\n \
    \   while i >= 0 {\n        let c = word.chars().nth(i).unwrap();\n        if\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            if prev_cons\
    \ {\n                closest_vowel = c.to_string().as_str();\n               \
    \ prev_cons = false;\n            }\n            prev_vowel = c.to_string().as_str();\n\
    \        } else {\n            if !prev_cons {\n                return closest_vowel.to_string();\n\
    \            }\n            prev_cons = true;\n        }\n        i -= 1;\n  \
    \  }\n    prev_vowel.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmppvrd3j74.rs:16:33\n\
    \   |\n16 |                 closest_vowel = c.to_string().as_str();\n   |    \
    \                             ^^^^^^^^^^^^^         - temporary value is freed\
    \ at the end of this statement\n   |                                 |\n   | \
    \                                creates a temporary which is freed while still\
    \ in use\n...\n22 |                 return closest_vowel.to_string();\n   |  \
    \                      ------------- borrow later used here\n   |\n   = note:\
    \ consider using a `let` binding to create a longer lived value\n\nerror[E0716]:\
    \ temporary value dropped while borrowed\n  --> /tmp/tmppvrd3j74.rs:19:26\n  \
    \ |\n19 |             prev_vowel = c.to_string().as_str();\n   |             \
    \             ^^^^^^^^^^^^^         - temporary value is freed at the end of this\
    \ statement\n   |                          |\n   |                          creates\
    \ a temporary which is freed while still in use\n...\n28 |     prev_vowel.to_string()\n\
    \   |     ---------- borrow later used here\n   |\n   = note: consider using a\
    \ `let` binding to create a longer lived value\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0716`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().collect::<Vec<char>>();\n \
    \   let l = word.len();\n    let mut found = false;\n    let mut result = String::new();\n\
    \    for i in (0..l).rev() {\n        if is_vowel(word[i]) {\n            if found\
    \ {\n                result.push(word[i]);\n                break;\n         \
    \   }\n        } else {\n            found = true;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpphyaefz0.rs:13:12\n\
    \   |\n13 |         if is_vowel(word[i]) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823697
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut words\
    \ = word.chars().collect::<Vec<char>>();\n    words.reverse();\n    let mut prev_char\
    \ = ' ';\n    let mut prev_vowel = ' ';\n    for (i, &w) in words.iter().enumerate()\
    \ {\n        if !w.is_vowel() {\n            if prev_char.is_vowel() {\n     \
    \           result = prev_vowel.to_string();\n                break;\n       \
    \     }\n        } else {\n            prev_vowel = w;\n        }\n        prev_char\
    \ = w;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3s1tcghi.rs:14:15\n   |\n14 |         if !w.is_vowel()\
    \ {\n   |               ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no\
    \ method named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmp3s1tcghi.rs:15:26\n\
    \   |\n15 |             if prev_char.is_vowel() {\n   |                      \
    \    ^^^^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\".chars().collect::<Vec<char>>();\n\
    \    let mut len = 0;\n    let mut len2 = 0;\n    let mut last_vowel = ' ';\n\
    \    let mut first_vowel = ' ';\n    let mut ans = \"\".to_string();\n    let\
    \ mut last_len = 0;\n    let mut first_len = 0;\n    for (i, v) in word.chars().enumerate()\
    \ {\n        if vowels.contains(&v) {\n            len = i;\n            last_vowel\
    \ = v;\n            break;\n        }\n    }\n    for (i, v) in word.chars().rev().enumerate()\
    \ {\n        if vowels.contains(&v) {\n            len2 = i;\n            first_vowel\
    \ = v;\n            break;\n        }\n    }\n    if word.len() - len - len2 <\
    \ word.len() - len {\n        last_len = word.len() - len - len2;\n        ans\
    \ = last_vowel.to_string();\n    } else {\n        first_len = word.len() - len;\n\
    \        ans = first_vowel.to_string();\n    }\n    ans\n}\n\nfn main() {\n  \
    \  let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpob2qoe_d.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut found_first_vowel\
    \ = false;\n    let mut found_second_vowel = false;\n    let mut index = word.len()\
    \ - 1;\n    for character in word.chars().rev() {\n        if !found_first_vowel\
    \ && is_vowel(character) {\n            found_first_vowel = true;\n        } else\
    \ if found_first_vowel && !found_second_vowel && !is_vowel(character) {\n    \
    \        found_second_vowel = true;\n        } else if found_first_vowel && found_second_vowel\
    \ && is_vowel(character) {\n            result = word[index..index + 1].to_string();\n\
    \            break;\n        }\n        index -= 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7gx66ojp.rs:13:34\n\
    \   |\n13 |         if !found_first_vowel && is_vowel(character) {\n   |     \
    \                             ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_vowel` in this scope\n  --> /tmp/tmp7gx66ojp.rs:15:64\n\
    \   |\n15 |         } else if found_first_vowel && !found_second_vowel && !is_vowel(character)\
    \ {\n   |                                                                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_vowel` in\
    \ this scope\n  --> /tmp/tmp7gx66ojp.rs:17:62\n   |\n17 |         } else if found_first_vowel\
    \ && found_second_vowel && is_vowel(character) {\n   |                       \
    \                                       ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut best_idx = word.len();\n    let mut new_word\
    \ = String::new();\n    let vowels = \"aeiou\";\n    let consonants = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n    let mut last_con = 'a';\n    for (i, c) in word.chars().rev().enumerate()\
    \ {\n        if vowels.contains(c) {\n            if consonants.contains(last_con)\
    \ {\n                best_idx = i;\n                break;\n            }\n  \
    \      } else {\n            last_con = c;\n        }\n    }\n    if best_idx\
    \ != word.len() {\n        for (i, c) in word.chars().enumerate() {\n        \
    \    if i >= best_idx {\n                new_word.push(c);\n            }\n  \
    \      }\n    }\n    new_word\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"gurt\"`,\n right: `\"u\"`', /tmp/tmpv100z_7e.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let b = word.as_bytes();\n    for i in (0..b.len()).rev()\
    \ {\n        if b[i] == b'a' || b[i] == b'e' || b[i] == b'i' || b[i] == b'o' ||\
    \ b[i] == b'u' {\n            return String::from_utf8(b[i..i+1].to_vec()).unwrap();\n\
    \        }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpg7sa03vm.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_distance = std::usize::MAX;\n    let\
    \ mut closest_vowel = String::new();\n    for (pos, c) in word.chars().enumerate()\
    \ {\n        if c.is_ascii_alphabetic() {\n            if is_vowel(c) {\n    \
    \            if closest_distance == std::usize::MAX {\n                    closest_distance\
    \ = 0;\n                    closest_vowel = c.to_string();\n                }\
    \ else {\n                    closest_distance = pos;\n                    closest_vowel\
    \ = c.to_string();\n                }\n            } else {\n                if\
    \ closest_distance < std::usize::MAX {\n                    if pos > closest_distance\
    \ {\n                        break;\n                    }\n                }\n\
    \            }\n        }\n    }\n    closest_vowel\n}\n\nfn main() {\n    let\
    \ candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")),\
    \ String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"\
    o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\"\
    )), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpxu8e36kt.rs:12:16\n\
    \   |\n12 |             if is_vowel(c) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    fn find_vowel(word: &str) -> Option<usize> {\n    \
    \    word.rmatch_indices(char::is_vowel)\n            .map(|(idx, _)| idx)\n \
    \           .next()\n    }\n\n    fn find_consonant(word: &str) -> Option<usize>\
    \ {\n        word.rmatch_indices(|c| !char::is_vowel(c))\n            .map(|(idx,\
    \ _)| idx)\n            .next()\n    }\n\n    word.chars()\n        .rev()\n \
    \       .take_while(|&c| !char::is_vowel(c))\n        .skip_while(|&c| char::is_vowel(c))\n\
    \        .fold((String::new(), String::new()), |(mut v, mut c), x| {\n       \
    \     v.push(x);\n            c.push(x);\n            (v, c)\n        })\n   \
    \     .1\n        .chars()\n        .rev()\n        .skip_while(|&c| char::is_vowel(c))\n\
    \        .skip_while(|&c| !char::is_vowel(c))\n        .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `is_vowel` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpkrk9gldp.rs:22:33\n   |\n22\
    \ |         .take_while(|&c| !char::is_vowel(c))\n   |                       \
    \          ^^^^^^^^ function or associated item not found in `char`\n\nerror[E0599]:\
    \ no function or associated item named `is_vowel` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpkrk9gldp.rs:23:32\n   |\n23 |         .skip_while(|&c|\
    \ char::is_vowel(c))\n   |                                ^^^^^^^^ function or\
    \ associated item not found in `char`\n\nerror[E0599]: no function or associated\
    \ item named `is_vowel` found for type `char` in the current scope\n  --> /tmp/tmpkrk9gldp.rs:32:32\n\
    \   |\n32 |         .skip_while(|&c| char::is_vowel(c))\n   |                \
    \                ^^^^^^^^ function or associated item not found in `char`\n\n\
    error[E0599]: no function or associated item named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpkrk9gldp.rs:33:33\n   |\n33 |         .skip_while(|&c|\
    \ !char::is_vowel(c))\n   |                                 ^^^^^^^^ function\
    \ or associated item not found in `char`\n\nerror[E0599]: no function or associated\
    \ item named `is_vowel` found for type `char` in the current scope\n --> /tmp/tmpkrk9gldp.rs:9:35\n\
    \  |\n9 |         word.rmatch_indices(char::is_vowel)\n  |                   \
    \                ^^^^^^^^ function or associated item not found in `char`\n\n\
    error[E0599]: no function or associated item named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpkrk9gldp.rs:15:40\n   |\n15 |         word.rmatch_indices(|c|\
    \ !char::is_vowel(c))\n   |                                        ^^^^^^^^ function\
    \ or associated item not found in `char`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n \
    \ for (i, ch) in word.chars().rev().enumerate() {\n    let prev = if i == 0 {\n\
    \      None\n    } else {\n      Some(word.chars().rev().nth(i - 1).unwrap())\n\
    \    };\n    if vowels.contains(&ch.to_string().as_str()) {\n      match prev\
    \ {\n        Some(prev) => {\n          if !vowels.contains(&prev.to_string().as_str())\
    \ {\n            return ch.to_string();\n          }\n        }\n        None\
    \ => {},\n      }\n    }\n  }\n  \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpy6vfjb2c.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let mut closest = String::new();\n  let mut consonant_count\
    \ = 0;\n  let mut closest_index = 0;\n  let mut char_index = 0;\n  for c in word.chars()\
    \ {\n    char_index += 1;\n    match c {\n      'a' | 'e' | 'i' | 'o' | 'u' =>\
    \ {\n        if consonant_count > 1 {\n          return c.to_string();\n     \
    \   }\n        if consonant_count == 1 {\n          closest = c.to_string();\n\
    \          closest_index = char_index;\n        }\n      },\n      _ => {\n  \
    \      consonant_count += 1;\n      }\n    }\n  }\n  if consonant_count == 1 {\n\
    \    closest\n  } else {\n    String::new()\n  }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpn15_dy5v.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // create pattern to find vowels\n    let vowels =\
    \ regex::Regex::new(r\"[aeiou]\").unwrap();\n    // turn string into a vector\
    \ of chars\n    let mut chars: Vec<char> = word.chars().collect();\n    // iterate\
    \ through chars backwards\n    for i in (0..chars.len()).rev() {\n        // find\
    \ first consonant\n        if !vowels.is_match(&chars[i].to_string()) {\n    \
    \        // check if the next char is a vowel\n            if vowels.is_match(&chars[i\
    \ - 1].to_string()) {\n                // return vowel\n                return\
    \ chars[i - 1].to_string();\n            }\n        }\n    }\n    // return nothing\n\
    \    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \ --> /tmp/tmpv23t8g56.rs:9:18\n  |\n9 |     let vowels = regex::Regex::new(r\"\
    [aeiou]\").unwrap();\n  |                  ^^^^^ use of undeclared crate or module\
    \ `regex`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res: Vec<char> = vec![];\n    let vowels =\
    \ ['a', 'e', 'i', 'o', 'u'];\n    let mut vowel_ch: char = ' ';\n    let mut prev_ch:\
    \ char = ' ';\n    let mut pos = 0;\n    for ch in word.chars() {\n        if\
    \ vowels.contains(&ch) {\n            if prev_ch != ' ' && prev_ch != ch {\n \
    \               if vowel_ch == ' ' {\n                    vowel_ch = ch;\n   \
    \                 pos = res.len();\n                } else if pos + 1 == res.len()\
    \ {\n                    break;\n                }\n            }\n        }\n\
    \        res.push(ch);\n        prev_ch = ch;\n    }\n    if vowel_ch == ' ' {\n\
    \        return String::from(\"\");\n    }\n    res.remove(pos);\n    res.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"ygurt\"`,\n right: `\"u\"`', /tmp/tmpskauv2yu.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let chars: Vec<char> = word.chars().collect();\n  \
    \  let mut output: String = String::new();\n    let mut found_a_consonant = false;\n\
    \    let mut chars_iter = chars.iter().rev();\n    for character in chars_iter\
    \ {\n        let c = *character;\n        if c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' {\n            if found_a_consonant {\n            \
    \    output.push(c);\n                break;\n            }\n        } else {\n\
    \            found_a_consonant = true;\n        }\n    }\n    output\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmplmmza03m.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().collect::<Vec<char>>().windows(3).find(|ch|\
    \ {\n        ch[0].is_consonant() && ch[1].is_vowel() && ch[2].is_consonant()\n\
    \    }).map(|ch| ch[1].to_string()).unwrap_or(String::new())\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n --> /tmp/tmp8iqa7s5v.rs:9:15\n  |\n9 |         ch[0].is_consonant()\
    \ && ch[1].is_vowel() && ch[2].is_consonant()\n  |               ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_vowel` found\
    \ for type `char` in the current scope\n --> /tmp/tmp8iqa7s5v.rs:9:39\n  |\n9\
    \ |         ch[0].is_consonant() && ch[1].is_vowel() && ch[2].is_consonant()\n\
    \  |                                       ^^^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n --> /tmp/tmp8iqa7s5v.rs:9:59\n  |\n9 |         ch[0].is_consonant()\
    \ && ch[1].is_vowel() && ch[2].is_consonant()\n  |                           \
    \                                ^^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut index: Option<usize>\
    \ = None;\n    let mut min = word.len();\n    let mut i = word.len();\n    while\
    \ i > 0 {\n        if vowels.contains(word.as_bytes()[i - 1] as char) {\n    \
    \        if let Some(j) = index {\n                if j - i < min {\n        \
    \            min = j - i;\n                    index = Some(i - 1);\n        \
    \        }\n            }\n        } else {\n            index = Some(i);\n  \
    \      }\n        i -= 1;\n    }\n    match index {\n        Some(index) => word.chars().skip(index).take(1).collect(),\n\
    \        None => String::new(),\n    }\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp4ln1uxzn.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n \
    \   vowels.sort_by(|a, b| b.cmp(a));\n    let mut consonants = Vec::new();\n \
    \   for char in word.chars() {\n        if vowels.contains(&char) {\n        \
    \    continue;\n        }\n        consonants.push(char);\n    }\n    vowels.sort();\n\
    \    let mut offset = 0;\n    let mut counter = 0;\n    let mut chosen_vowel =\
    \ ' ';\n    loop {\n        let search_term = consonants.get(counter).map(|&c|\
    \ c);\n        if search_term.is_none() {\n            break;\n        }\n   \
    \     if let Some(term) = search_term {\n            match word.find(term) {\n\
    \                Some(index) => {\n                    offset = index;\n     \
    \               chosen_vowel = word.chars().skip(index + 1).take(1).next().unwrap();\n\
    \                    break;\n                }\n                None => {}\n \
    \           }\n        }\n        counter += 1;\n    }\n    if offset == 0 {\n\
    \        return String::new();\n    }\n    let result = word.chars().skip(offset\
    \ + 1).take(1).collect::<String>();\n    match result.chars().next() {\n     \
    \   Some(char) => {\n            if vowels.contains(&char) {\n               \
    \ chosen_vowel = char;\n            }\n        }\n        None => {}\n    }\n\
    \    chosen_vowel.to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp0igfwhsy.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut nearest_vowel = String::new();\n    let mut\
    \ result = String::new();\n    let mut last_consonant = String::new();\n    let\
    \ mut nearest_consonant = String::new();\n    let vowel = \"aeiou\";\n    let\
    \ consonant = \"bcdfghjklmnpqrstvwxyz\";\n    for character in word.chars() {\n\
    \        match character {\n            'a' | 'e' | 'i' | 'o' | 'u' => {\n   \
    \             if nearest_vowel == \"\" {\n                    nearest_vowel =\
    \ character.to_string();\n                }\n                if nearest_consonant\
    \ != \"\" {\n                    if last_consonant == \"\" {\n               \
    \         last_consonant = nearest_consonant.clone();\n                    }\n\
    \                    let mut distance = 0;\n                    let mut vowel_distance\
    \ = 0;\n                    let mut consonant_distance = 0;\n                \
    \    for i in 0..last_consonant.len() {\n                        if vowel.contains(last_consonant.get(i..i+1).unwrap())\
    \ {\n                            vowel_distance = i;\n                       \
    \ }\n                    }\n                    for i in 0..nearest_consonant.len()\
    \ {\n                        if consonant.contains(nearest_consonant.get(i..i+1).unwrap())\
    \ {\n                            consonant_distance = i;\n                   \
    \     }\n                    }\n                    distance = vowel_distance\
    \ - consonant_distance;\n                    if distance > 0 {\n             \
    \           if result == \"\" {\n                            result = nearest_vowel.clone();\n\
    \                        } else {\n                            if distance < result.len()\
    \ {\n                                result = nearest_vowel.clone();\n       \
    \                     }\n                        }\n                    }\n  \
    \                  nearest_consonant = \"\".to_string();\n                }\n\
    \            },\n            _ => {\n                if nearest_consonant == \"\
    \" {\n                    nearest_consonant = character.to_string();\n       \
    \         } else {\n                    nearest_consonant = format!(\"{}{}\",\
    \ nearest_consonant, character);\n                }\n            }\n        }\n\
    \    }\n    result\n\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpf6g5ntay.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_idx = None;\n    let mut consonant_idx\
    \ = None;\n    for i in (0..word.len()).rev() {\n        let ch = word.chars().nth(i).unwrap();\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            vowel_idx = Some(i);\n        } else {\n            consonant_idx\
    \ = Some(i);\n        }\n        if vowel_idx.is_some() && consonant_idx.is_some()\
    \ {\n            break;\n        }\n    }\n    match (vowel_idx, consonant_idx)\
    \ {\n        (Some(vidx), Some(cidx)) => {\n            let v = word.chars().nth(vidx).unwrap();\n\
    \            if cidx > vidx {\n                String::new()\n            } else\
    \ {\n                v.to_string()\n            }\n        },\n        _ => String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp1zw24k9t.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() <= 1 { return String::new(); }\n    if\
    \ word.chars().next().unwrap().is_alphabetic() && word.chars().last().unwrap().is_alphabetic()\
    \ {\n        let mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n        let word_vec:\
    \ Vec<char> = word.chars().collect();\n        let mut vowel = String::new();\n\
    \        for i in 0..word_vec.len() {\n            if vowels.contains(&word_vec[i])\
    \ {\n                vowel = word_vec[i].to_string();\n                if (word_vec[i-1].is_alphabetic()\
    \ && !vowels.contains(&word_vec[i-1])) && (word_vec[i+1].is_alphabetic() && !vowels.contains(&word_vec[i+1]))\
    \ {\n                    return vowel;\n                }\n            }\n   \
    \     }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpqqpvaa4d.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.to_lowercase();\n    let mut chars\
    \ = word.chars();\n    let mut last_cons = None;\n    for ch in chars.rev() {\n\
    \        if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n\
    \            last_cons = None;\n        } else {\n            if last_cons.is_none()\
    \ {\n                last_cons = Some(ch);\n            } else {\n           \
    \     return ch.to_string();\n            }\n        }\n    }\n    String::new()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"r\"`,\n right: `\"u\"`', /tmp/tmpjmk3w2lz.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let chars: Vec<char> = word.chars().collect();\n  \
    \  for i in (0..chars.len()).rev() {\n        if !is_vowel(chars[i]) {\n     \
    \       if i != 0 && is_vowel(chars[i - 1]) {\n                return chars[i\
    \ - 1].to_string();\n            } else if i != chars.len() - 1 && is_vowel(chars[i\
    \ + 1]) {\n                return chars[i + 1].to_string();\n            }\n \
    \       }\n    }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpm25kpaza.rs:10:13\n\
    \   |\n10 |         if !is_vowel(chars[i]) {\n   |             ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n\
    \  --> /tmp/tmpm25kpaza.rs:11:26\n   |\n11 |             if i != 0 && is_vowel(chars[i\
    \ - 1]) {\n   |                          ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpm25kpaza.rs:13:47\n\
    \   |\n13 |             } else if i != chars.len() - 1 && is_vowel(chars[i + 1])\
    \ {\n   |                                               ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let voewls = ['a', 'e', 'i', 'o', 'u'];\n    let mut\
    \ min = word.len();\n    let mut res = \"\".to_string();\n    for i in 0..word.len()\
    \ {\n        if voewls.contains(&word.chars().nth(i).unwrap()) {\n           \
    \ if i > 0 && i < word.len() - 1 {\n                if !voewls.contains(&word.chars().nth(i\
    \ - 1).unwrap()) && !voewls.contains(&word.chars().nth(i + 1).unwrap()) {\n  \
    \                  if min > i {\n                        min = i;\n          \
    \              res = word.chars().nth(i).unwrap().to_string();\n             \
    \       }\n                }\n            }\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpkt5xiox5.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let consonants = \"bcdfghjklmnpqrstvwxyz\";\n    let\
    \ vowels = \"aeiou\";\n    let mut left_consonant_boundary: Option<usize> = None;\n\
    \    let mut vowel_index: Option<usize> = None;\n    let mut min_length = word.len();\n\
    \    for (index, character) in word.chars().enumerate() {\n        if consonants.contains(character)\
    \ {\n            left_consonant_boundary = Some(index);\n        }\n        if\
    \ vowels.contains(character) {\n            if let Some(left_consonant_boundary)\
    \ = left_consonant_boundary {\n                if index - left_consonant_boundary\
    \ < min_length {\n                    min_length = index - left_consonant_boundary;\n\
    \                    vowel_index = Some(index);\n                }\n         \
    \   }\n        }\n    }\n    match vowel_index {\n        Some(vowel_index) =>\
    \ word.chars().nth(vowel_index).unwrap().to_string(),\n        None => \"\".to_string(),\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpi93mqvsv.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut vowel_pos:Vec<usize> = vec![];\n    let mut\
    \ current_pos = word.len();\n    let letters = \"bcdfghjklmnpqrstvwxyz\";\n  \
    \  for (i, c) in word.chars().enumerate().rev() {\n        if letters.contains(c)\
    \ {\n            current_pos = i;\n        } else {\n            vowel_pos.push(current_pos);\n\
    \        }\n    }\n    for (i, c) in word.chars().enumerate() {\n        if vowel_pos.contains(&i)\
    \ {\n            return c.to_string();\n        }\n    }\n    \"\".to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpmbxb4nhh.rs:11:44\n   |\n11 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpmbxb4nhh.rs:11:19\n    |\n11  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    // unimplemented!()\n    let str = word.chars().rev().collect::<String>();\n\
    \    let mut result = None;\n    let mut index = -1;\n    let mut flag = false;\n\
    \    for i in 0..str.len() {\n        if is_vowel(str.chars().nth(i).unwrap())\
    \ {\n            if flag {\n                result = Some(str.chars().nth(i).unwrap());\n\
    \                index = i;\n                break;\n            }\n        }\
    \ else {\n            flag = true;\n        }\n    }\n    if let Some(ch) = result\
    \ {\n        if index == -1 {\n            return String::new();\n        }\n\
    \        str.chars().skip(index).collect::<String>()\n    } else {\n        String::new()\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp4w8wltf4.rs:14:12\n\
    \   |\n14 |         if is_vowel(str.chars().nth(i).unwrap()) {\n   |         \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmp4w8wltf4.rs:11:21\n   |\n11 |     let mut\
    \ index = -1;\n   |                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmp4w8wltf4.rs:25:21\n   |\n25 |         if index == -1 {\n   |  \
    \                   ^^\n   |                     |\n   |                     cannot\
    \ apply unary operator `-`\n   |                     help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.bytes().rev().filter(|&c| c != b'a' && c != b'e'\
    \ && c != b'i' && c != b'o' && c != b'u').map(|c| {\n        if c == b'a' || c\
    \ == b'e' || c == b'i' || c == b'o' || c == b'u' {\n            c\n        } else\
    \ {\n            0\n        }\n    }).filter(|&c| c != 0).map(|c| c as char).collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp3yd6669x.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = None;\n    let vowels = \"aeiou\";\n\
    \    let mut index_diff = word.len();\n    for (i, ch) in word.chars().enumerate().rev()\
    \ {\n        if vowels.contains(ch) {\n            index = Some(i);\n        \
    \    break;\n        }\n        index_diff -= 1;\n    }\n    match index {\n \
    \       Some(i) => {\n            let slice = &word[i..];\n            let chars:\
    \ Vec<char> = slice.chars().collect();\n            if index_diff > 1 && index_diff\
    \ < slice.len() && chars[index_diff - 1] != 'a' {\n                return String::from(\"\
    \");\n            }\n            slice.to_string()\n        }\n        None =>\
    \ String::from(\"\"),\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpps3ofzgs.rs:11:45\n   |\n11 |     for (i, ch) in word.chars().enumerate().rev()\
    \ {\n   |                                             ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmpps3ofzgs.rs:11:20\n    |\n11  |     for (i, ch) in word.chars().enumerate().rev()\
    \ {\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest = String::new();\n    let ltrs: Vec<_>\
    \ = word.chars().rev().collect();\n    let mut i = 0;\n    while i < ltrs.len()\
    \ {\n        if i + 1 < ltrs.len() && is_vowel(ltrs[i + 1]) && is_consonant(ltrs[i])\
    \ {\n            closest.push(ltrs[i + 1]);\n            break;\n        }\n \
    \       i += 1;\n    }\n    closest.chars().rev().collect()\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpdo4eyr1p.rs:12:34\n\
    \   |\n12 |         if i + 1 < ltrs.len() && is_vowel(ltrs[i + 1]) && is_consonant(ltrs[i])\
    \ {\n   |                                  ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmpdo4eyr1p.rs:12:59\n\
    \   |\n12 |         if i + 1 < ltrs.len() && is_vowel(ltrs[i + 1]) && is_consonant(ltrs[i])\
    \ {\n   |                                                           ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let vowels = String::from(\"\
    aeiou\");\n    let chars: Vec<char> = word.chars().collect();\n    let mut found_consonant\
    \ = false;\n    let mut c_index = chars.len() - 1;\n    for c in chars.iter().rev()\
    \ {\n        if vowels.contains(*c) {\n            if found_consonant {\n    \
    \            result.push(*c);\n                break;\n            }\n       \
    \ } else {\n            found_consonant = true;\n        }\n        c_index -=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpth_1ix4h.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word = word.chars().rev().collect::<Vec<_>>();\n\
    \    for i in 1..word.len() {\n        if word[i].is_consonant() && word[i - 1].is_vowel()\
    \ {\n            return word[i - 1].to_string();\n        }\n    }\n    return\
    \ \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpyzrbye6m.rs:10:20\n   |\n10 |         if word[i].is_consonant()\
    \ && word[i - 1].is_vowel() {\n   |                    ^^^^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `is_vowel` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpyzrbye6m.rs:10:50\n   |\n10 |         if\
    \ word[i].is_consonant() && word[i - 1].is_vowel() {\n   |                   \
    \                               ^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let s = word.chars().rev().collect::<Vec<char>>();\n\
    \    let (mut cons_pos, mut i) = (0, 1);\n    while i < s.len() {\n        match\
    \ (s[i], s[i - 1]) {\n            ('a', _) | ('e', _) | ('i', _) | ('o', _) |\
    \ ('u', _) => {\n                return word[..word.len() - i].to_string();\n\
    \            }\n            (_, 'a') | (_, 'e') | (_, 'i') | (_, 'o') | (_, 'u')\
    \ => {\n                cons_pos = i;\n            }\n            _ => {}\n  \
    \      }\n        i += 1;\n    }\n    if cons_pos > 0 {\n        word[..word.len()\
    \ - cons_pos].to_string()\n    } else {\n        \"\".to_string()\n    }\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"yogu\"`,\n right: `\"u\"`', /tmp/tmpcel43kxx.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut vowels\
    \ = Vec::new();\n    for i in word.chars() {\n        if is_vowel(i) {\n     \
    \       vowels.push(i);\n        }\n    }\n    if vowels.len() > 0 {\n       \
    \ if vowels.len() == 1 {\n            result.push(vowels[0]);\n        } else\
    \ {\n            let mut j = vowels.len() - 1;\n            while j > 0 {\n  \
    \              if vowels[j] != vowels[j - 1] {\n                    result.push(vowels[j]);\n\
    \                    break;\n                }\n                j -= 1;\n    \
    \        }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmploxiw60_.rs:11:12\n\
    \   |\n11 |         if is_vowel(i) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    use std::collections::HashSet;\n    let mut fv = String::new();\n\
    \    let mut fc = String::new();\n    let word = word.as_bytes();\n    let vowels\
    \ = HashSet::from_iter(vec!['a','e','i','o','u','A','E','I','O','U'].iter().map(|&i|\
    \ i));\n    for i in 0..word.len() {\n        if vowels.contains(&word[i]) {\n\
    \            fv = fv + &String::from_utf8(vec![word[i]]).unwrap();\n        }\
    \ else {\n            fc = fc + &String::from_utf8(vec![word[i]]).unwrap();\n\
    \        }\n    }\n    if fc.len() == word.len() {\n        return String::new();\n\
    \    }\n    if fc.len() == 0 {\n        return fv.chars().next().unwrap().to_string();\n\
    \    }\n    if vowels.contains(&word[word.len()-1]) {\n        return String::new();\n\
    \    }\n    fv.chars().rev().next().unwrap().to_string()\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `HashSet` in the current scope\n  --> /tmp/tmpyqq8q56i.rs:12:27\n   |\n\
    12 |     let vowels = HashSet::from_iter(vec!['a','e','i','o','u','A','E','I','O','U'].iter().map(|&i|\
    \ i));\n   |                           ^^^^^^^^^ function or associated item not\
    \ found in `HashSet<_, _>`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut pos = word.len();\n    let mut dist = 0;\n    for v in word.chars().rev()\
    \ {\n        if vowels.contains(&v) {\n            break;\n        }\n       \
    \ dist += 1;\n        pos -= 1;\n    }\n    if pos == word.len() {\n        return\
    \ String::new();\n    }\n    for c in word.chars().rev().skip(dist) {\n      \
    \  if !vowels.contains(&c) {\n            break;\n        }\n        dist += 1;\n\
    \        pos -= 1;\n    }\n    if pos < word.len() {\n        word.chars().skip(pos).next().unwrap().to_string()\n\
    \    } else {\n        String::new()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"e\"`,\n right: `\"\"`', /tmp/tmpo3wbuk_6.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    word.chars().rev().fold(String::new(),\
    \ |vowel, c| match c {\n        c if vowels.contains(&c) => {\n            if\
    \ vowel.is_empty() {\n                c.to_string()\n            } else {\n  \
    \              vowel\n            }\n        }\n        _ => vowel,\n    })\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpdhnnb7_s.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut index\
    \ = word.len() - 1;\n    let last_vowel = word.chars().rev().position(|x| \"aeiou\"\
    .contains(x));\n    let mut word_to_search = word.clone();\n    if last_vowel\
    \ != None {\n        word_to_search = word_to_search.chars().take(word.len() -\
    \ last_vowel.unwrap() - 1).collect();\n    }\n    for c in word_to_search.chars().rev()\
    \ {\n        if \"aeiou\".contains(c) {\n            result = word.chars().skip(index\
    \ + 1).collect();\n            break;\n        }\n        index -= 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"t\"`,\n right: `\"u\"`', /tmp/tmpa53naaf6.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().enumerate().fold((None, None), |(acc_vowel,\
    \ prev_consonant), (i, c)| {\n        let is_vowel = match c {\n            'a'\
    \ | 'e' | 'i' | 'o' | 'u' => true,\n            _ => false,\n        };\n    \
    \    match (acc_vowel, prev_consonant, is_vowel) {\n            (Some(acc_vowel),\
    \ Some(prev_consonant), _) => (Some(acc_vowel), Some(i)),\n            (Some(acc_vowel),\
    \ None, true) => (Some(acc_vowel), Some(i)),\n            (Some(acc_vowel), None,\
    \ false) => (Some(acc_vowel), None),\n            (None, Some(prev_consonant),\
    \ true) => (Some(i), Some(i)),\n            (None, Some(prev_consonant), false)\
    \ => (None, Some(i)),\n            (None, None, true) => (Some(i), Some(i)),\n\
    \            (None, None, false) => (None, None),\n        }\n    }).0.map(|i|\
    \ word.chars().nth(i).unwrap().to_string()).unwrap_or(String::new())\n}\n\nfn\
    \ main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmphftedila.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut last_found_vowel_pos = 0;\n    let mut last_found_vowel\
    \ = ' ';\n    let mut closest_consonant_pos = word.len();\n    let mut closest_consonant\
    \ = ' ';\n    let mut i = word.len() - 1;\n    while i > 0 {\n        let c =\
    \ word.chars().nth(i).unwrap();\n        if is_vowel(c) {\n            last_found_vowel_pos\
    \ = i;\n            last_found_vowel = c;\n        } else if last_found_vowel_pos\
    \ > 0 {\n            closest_consonant_pos = i;\n            closest_consonant\
    \ = c;\n            break;\n        }\n        i -= 1;\n    }\n    if last_found_vowel_pos\
    \ > 0 && last_found_vowel_pos < closest_consonant_pos {\n        return String::from(last_found_vowel.to_string());\n\
    \    }\n    String::from(\"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp5jvo7oyv.rs:15:12\n\
    \   |\n15 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut res = String::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut current_index = None;\n    let mut prev_index\
    \ = None;\n    let mut current_letter = None;\n    let word_size = word.len();\n\
    \    for (i, current_letter) in word.chars().enumerate() {\n        if vowels.contains(&current_letter)\
    \ {\n            current_index = Some(i);\n            break;\n        }\n   \
    \ }\n    if let Some(current_index) = current_index {\n        for (i, current_letter)\
    \ in word.chars().enumerate() {\n            if i <= current_index {\n       \
    \         continue;\n            }\n            if vowels.contains(&current_letter)\
    \ {\n                prev_index = Some(i);\n                break;\n         \
    \   }\n        }\n        if let Some(prev_index) = prev_index {\n           \
    \ if prev_index - current_index < word_size - prev_index {\n                res.push(current_letter.clone());\n\
    \            } else {\n                res.push(word.chars().nth(prev_index).unwrap());\n\
    \            }\n        } else {\n            res.push(current_letter.clone());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpipdga7ao.rs:32:26\n   |\n\
    32 |                 res.push(current_letter.clone());\n   |                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n\
    \   = note: expected type `char`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpipdga7ao.rs:37:22\n   |\n37 |             res.push(current_letter.clone());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index = word.len();\n    while index > 0 {\n\
    \        let char_at_index = word.chars().nth(index - 1).unwrap();\n        let\
    \ char_at_index_minus_one = word.chars().nth(index - 2).unwrap();\n        if\
    \ char_at_index.is_vowel() && char_at_index_minus_one.is_consonant() {\n     \
    \       return char_at_index.to_string();\n        }\n        index -= 1;\n  \
    \  }\n    String::new()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpujeicudh.rs:12:26\n   |\n12 |         if char_at_index.is_vowel()\
    \ && char_at_index_minus_one.is_consonant() {\n   |                          ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_consonant` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpujeicudh.rs:12:64\n   |\n\
    12 |         if char_at_index.is_vowel() && char_at_index_minus_one.is_consonant()\
    \ {\n   |                                                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut ret = String::new();\n    let mut flag = false;\n\
    \    for c in word.chars().rev() {\n        if is_vowel(c) {\n            ret.push(c);\n\
    \            flag = true;\n        } else if flag {\n            break;\n    \
    \    }\n    }\n    ret.chars().rev().collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmptcq1hhxl.rs:11:12\n\
    \   |\n11 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \"aeiou\".chars().map(|c| c.to_string()).find(|c| {\n\
    \        let pos = word.rfind(c);\n        pos.is_some() && pos < word.rfind(|ch|\
    \ \"bcdfghjklmnpqrstvwxyz\".contains(ch))\n    }).unwrap_or(\"\".to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpb44rx905.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  // Find the closest vowel from the last consonant to\
    \ the right\n  let mut consonant = false;\n  let mut vowel = false;\n  let mut\
    \ distance = 0;\n  let mut index = 0;\n  for (i, c) in word.chars().rev().enumerate()\
    \ {\n    if is_vowel(c) {\n      vowel = true;\n      distance = i;\n      index\
    \ = word.len() - i - 1;\n    }\n    if is_consonant(c) {\n      consonant = true;\n\
    \    }\n    if consonant && vowel {\n      break;\n    }\n  }\n  if !consonant\
    \ || !vowel {\n    return String::new();\n  }\n  if distance > 1 {\n    String::new()\n\
    \  } else {\n    word.chars().nth(index).unwrap().to_string()\n  }\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpcmmas8ab.rs:14:8\n\
    \   |\n14 |     if is_vowel(c) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmpcmmas8ab.rs:19:8\n\
    \   |\n19 |     if is_consonant(c) {\n   |        ^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `consonant`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().filter(|&c| is_vowel(c)).take(1).collect()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n --> /tmp/tmp1wa7vfsi.rs:8:36\n\
    \  |\n8 |     word.chars().rev().filter(|&c| is_vowel(c)).take(1).collect()\n\
    \  |                                    ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return \"\".to_string();\n\
    \    }\n    for (i, c) in word.chars().rev().enumerate() {\n        if (i == 0\
    \ || !c.is_vowel()) && c.is_vowel() {\n            return c.to_string();\n   \
    \     }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp13l6o5iw.rs:12:26\n   |\n12 |         if (i == 0 || !c.is_vowel())\
    \ && c.is_vowel() {\n   |                          ^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `is_vowel` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp13l6o5iw.rs:12:43\n   |\n12 |         if (i\
    \ == 0 || !c.is_vowel()) && c.is_vowel() {\n   |                             \
    \              ^^^^^^^^ method not found in `char`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word_chars: Vec<char> = word.chars().collect();\n\
    \    let word_rev: Vec<char> = word_chars.iter().rev().collect();\n    let mut\
    \ output = String::new();\n    let mut first_consonant = false;\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    for (i, c) in word_rev.iter().enumerate()\
    \ {\n        if first_consonant && vowels.contains(c) {\n            output =\
    \ c.to_string();\n            break;\n        }\n        if !vowels.contains(c)\
    \ {\n            first_consonant = true;\n        }\n    }\n    output\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<char>` cannot be built from an iterator\
    \ over elements of type `&char`\n --> /tmp/tmpo_r6xsli.rs:9:55\n  |\n9 |     let\
    \ word_rev: Vec<char> = word_chars.iter().rev().collect();\n  |              \
    \                                         ^^^^^^^ value of type `Vec<char>` cannot\
    \ be built from `std::iter::Iterator<Item=&char>`\n  |\n  = help: the trait `FromIterator<&char>`\
    \ is not implemented for `Vec<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp8lbja98z.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823696
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut curr_vowel_index = -1;\n    let mut curr_vowel_dist\
    \ = usize::max_value();\n    let mut result = String::new();\n    for (index,\
    \ ch) in word.chars().enumerate() {\n        match ch {\n            'a' | 'e'\
    \ | 'i' | 'o' | 'u' => {\n                if curr_vowel_index != -1 {\n      \
    \              if curr_vowel_dist > index - curr_vowel_index {\n             \
    \           curr_vowel_dist = index - curr_vowel_index;\n                    \
    \    result = ch.to_string();\n                    }\n                }\n    \
    \            curr_vowel_index = index;\n            }\n            _ => {}\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp0mvg60c_.rs:8:32\n\
    \  |\n8 |     let mut curr_vowel_index = -1;\n  |                            \
    \    ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmp0mvg60c_.rs:14:40\n   |\n\
    14 |                 if curr_vowel_index != -1 {\n   |                       \
    \                 ^^ the trait `Neg` is not implemented for `usize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let consonants: Vec<char> = \"bcdfghjklmnpqrstvwxyz\"\
    .chars().collect();\n  let vowels: Vec<char> = \"aeiou\".chars().collect();\n\
    \  word.char_indices().rev().skip_while(|(_, c)| consonants.contains(c)).filter(|(_,\
    \ c)| vowels.contains(c)).map(|(i, _)| (i, word.char_at(i))).next().map(|(_, c)|\
    \ c.to_string()).unwrap_or(\"\".to_string())\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `char_at` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpak7aqwnq.rs:10:131\n   |\n10 | ..._, c)| vowels.contains(c)).map(|(i,\
    \ _)| (i, word.char_at(i))).next().map(|(_, c)| c.to_string()).unwrap_or(\"\"\
    .to_string())\n   |                                                     ^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpygt5trgn.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut v = ' ';\n    let mut p = ' ';\n    let mut\
    \ v_index = word.len();\n    let mut p_index = word.len();\n    for (i, c) in\
    \ word.chars().enumerate() {\n        if is_vowel(c) {\n            v = c;\n \
    \           v_index = i;\n        } else if is_vowel(v) {\n            return\
    \ v.to_string();\n        }\n        if !is_vowel(c) {\n            p = c;\n \
    \           p_index = i;\n        } else if !is_vowel(p) {\n            return\
    \ v.to_string();\n        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n \
    \   let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1vsogfrl.rs:13:12\n\
    \   |\n13 |         if is_vowel(c) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmp1vsogfrl.rs:16:19\n   |\n16 |         } else if is_vowel(v) {\n   |\
    \                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_vowel` in this scope\n  --> /tmp/tmp1vsogfrl.rs:19:13\n   |\n19\
    \ |         if !is_vowel(c) {\n   |             ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmp1vsogfrl.rs:22:20\n\
    \   |\n22 |         } else if !is_vowel(p) {\n   |                    ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ char_vec: Vec<char> = word.chars().collect();\n    let length = char_vec.len();\n\
    \    let mut vowel_index: Option<usize> = None;\n    let mut cons_index: Option<usize>\
    \ = None;\n    if length > 1 {\n        for i in 0..length - 1 {\n           \
    \ if !vowels.contains(&char_vec[i]) && vowels.contains(&char_vec[i + 1]) {\n \
    \               vowel_index = Some(i + 1);\n                break;\n         \
    \   }\n        }\n        if vowel_index.is_some() {\n            for i in (0..vowel_index.unwrap()).rev()\
    \ {\n                if !vowels.contains(&char_vec[i]) {\n                   \
    \ cons_index = Some(i);\n                    break;\n                }\n     \
    \       }\n        }\n    }\n    if vowel_index.is_some() && cons_index.is_some()\
    \ {\n        return char_vec[vowel_index.unwrap()].to_string();\n    }\n    return\
    \ \"\".to_string();\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmp_jla8b9m.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 2 { return \"\".to_string(); }\n  \
    \  let mut dist = 0;\n    let mut idx = 0;\n    for (i, v) in word.chars().enumerate().rev()\
    \ {\n        if i == 0 { break; }\n        if is_vowel(v) {\n            let prev\
    \ = word.chars().nth(i - 1).unwrap();\n            if !is_vowel(prev) {\n    \
    \            if dist == 0 {\n                    dist = i;\n                 \
    \   idx = i;\n                } else if i > dist {\n                    dist =\
    \ i;\n                    idx = i;\n                }\n            }\n       \
    \ }\n    }\n    if idx == 0 {\n        return \"\".to_string();\n    }\n    word.chars().nth(idx).unwrap().to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpzvpai64m.rs:13:12\n\
    \   |\n13 |         if is_vowel(v) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_vowel` in this scope\n  -->\
    \ /tmp/tmpzvpai64m.rs:15:17\n   |\n15 |             if !is_vowel(prev) {\n   |\
    \                 ^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait\
    \ bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmpzvpai64m.rs:11:44\n\
    \   |\n11 |     for (i, v) in word.chars().enumerate().rev() {\n   |         \
    \                                   ^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = note: required because of the requirements on the\
    \ impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\nerror[E0277]: the\
    \ trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n   --> /tmp/tmpzvpai64m.rs:11:19\n\
    \    |\n11  |     for (i, v) in word.chars().enumerate().rev() {\n    |      \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is\
    \ not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let pos = word.rfind(|c| match c {\n        'a' | 'e'\
    \ | 'i' | 'o' | 'u' => true,\n        _ => false,\n    });\n    if let Some(index)\
    \ = pos {\n        let slice = &word[index..];\n        if let Some(index) = slice.find(|c|\
    \ match c {\n            'a' | 'e' | 'i' | 'o' | 'u' => false,\n            _\
    \ => true,\n        }) {\n            String::from(&slice[..index])\n        }\
    \ else {\n            String::from(slice)\n        }\n    } else {\n        String::from(\"\
    \")\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp7ze6wusv.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let word_chars: Vec<char> = word.chars().collect();\n\
    \    let mut consonant_count = 0;\n    let mut prev_character = word_chars[0];\n\
    \    let mut closest_vowel = \"\".to_string();\n    let vowels = vec!['a', 'e',\
    \ 'i', 'o', 'u'];\n    let consonants = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j',\
    \ 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n   \
    \ for (index, character) in word_chars.iter().enumerate() {\n        if consonants.contains(character)\
    \ {\n            consonant_count += 1;\n        } else if vowels.contains(character)\
    \ {\n            if consonant_count == 2 {\n                if index + 1 < word_chars.len()\
    \ {\n                    if vowels.contains(&word_chars[index + 1]) {\n      \
    \                  if consonants.contains(&prev_character) {\n               \
    \             return character.to_string();\n                        }\n     \
    \               }\n                }\n            }\n            consonant_count\
    \ = 0;\n        }\n        prev_character = *character;\n    }\n    closest_vowel\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp5p7r61bu.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut str_vowels = String::new();\n    let length = word.len();\n    let mut first_consonant\
    \ = String::new();\n    let mut vowel = String::new();\n    let mut second_consonant\
    \ = String::new();\n    let mut result = String::new();\n    let mut counter =\
    \ 0;\n    let mut flag = true;\n    let mut i = 0;\n    while i < length {\n \
    \       if vowels.contains(&word.chars().nth(i).unwrap()) {\n            str_vowels.push(word.chars().nth(i).unwrap());\n\
    \        }\n        i += 1;\n    }\n    let str_vowels_length = str_vowels.len();\n\
    \    i = 0;\n    while i < str_vowels_length {\n        if counter == 0 {\n  \
    \          vowel.push(str_vowels.chars().nth(i).unwrap());\n            counter\
    \ += 1;\n        } else if counter == 1 {\n            second_consonant.push(str_vowels.chars().nth(i).unwrap());\n\
    \            counter += 1;\n        } else if counter == 2 {\n            flag\
    \ = false;\n            first_consonant.push(str_vowels.chars().nth(i).unwrap());\n\
    \            break;\n        }\n        i += 1;\n    }\n    if flag {\n      \
    \  return String::from(\"\");\n    }\n    i = 0;\n    while i < length {\n   \
    \     if first_consonant.chars().nth(0).unwrap() == word.chars().nth(i).unwrap()\
    \ {\n            result.push(vowel.chars().nth(0).unwrap());\n            break;\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmpdb9ocpur.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    word.chars().rev().skip_while(|&c| {\n        c.is_whitespace()\
    \ || !c.is_alphabetic()\n    }).skip_while(|&c| {\n        c.is_whitespace() ||\
    \ !c.is_alphabetic()\n    }).skip_while(|&c| {\n        c.is_whitespace() || !c.is_alphabetic()\n\
    \    }).skip_while(|&c| {\n        c.is_whitespace() || !c.is_alphabetic()\n \
    \   }).take_while(|&c| {\n        c.is_whitespace() || !c.is_alphabetic()\n  \
    \  }).collect::<String>()\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n\
    \    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n \
    \   assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"u\"`', /tmp/tmp4d99tbp1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n  let vowels = \"aeiou\";\n  let mut closest_vowel = None;\n\
    \  let chars = word.chars().collect::<Vec<char>>();\n  for (i,c) in chars.iter().enumerate()\
    \ {\n    if i == 0 { continue; }\n    if i == chars.len() - 1 { break; }\n   \
    \ if !vowels.contains(*c) { continue; }\n    if vowels.contains(chars[i+1]) {\
    \ continue; }\n    closest_vowel = Some(c);\n    break;\n  }\n  closest_vowel.map(|x|x.to_string()).unwrap_or(\"\
    \".to_string())\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n  \
    \  assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n   \
    \ assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"\
    easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n\
    \    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n   \
    \ assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"o\"`,\n right: `\"u\"`', /tmp/tmpughm57tm.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut index: usize = 0;\n    let mut first_vowel_index:\
    \ usize = 0;\n    let mut last_vowel_index: usize = 0;\n    let mut last_consonant_index:\
    \ usize = 0;\n    let mut vowel: String = String::new();\n    let mut consonant:\
    \ String = String::new();\n    let mut vowel_idx: usize = 0;\n    let mut vowel_start_idx:\
    \ usize = 0;\n    let mut vowel_end_idx: usize = 0;\n    let mut consonant_idx:\
    \ usize = 0;\n    let mut consonant_end_idx: usize = 0;\n    let mut consonant_start_idx:\
    \ usize = 0;\n    for c in word.chars() {\n        if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n            vowel = c.to_string();\n   \
    \         vowel_idx = index;\n            if vowel_start_idx == 0 {\n        \
    \        vowel_start_idx = index;\n            }\n            vowel_end_idx =\
    \ index;\n        } else {\n            consonant = c.to_string();\n         \
    \   consonant_idx = index;\n            if consonant_start_idx == 0 {\n      \
    \          consonant_start_idx = index;\n            }\n            consonant_end_idx\
    \ = index;\n        }\n        index += 1;\n    }\n    if vowel_end_idx > consonant_end_idx\
    \ &&\n        vowel_start_idx < consonant_start_idx {\n        first_vowel_index\
    \ = vowel_start_idx;\n        last_vowel_index = vowel_end_idx;\n        last_consonant_index\
    \ = consonant_end_idx;\n    } else {\n        return String::new();\n    }\n \
    \   if last_vowel_index - first_vowel_index > last_consonant_index - last_vowel_index\
    \ {\n        return consonant;\n    } else {\n        return vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp7l3xtoo.rs:67:3\n\
    \   |\n7  | fn get_closest_vowel(word: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n39 |         vowel_start_idx\
    \ < consonant_start_idx {\n   |                                              \
    \ - this delimiter might not be properly closed...\n...\n43 |     } else {\n \
    \  |     - ...as it matches this but it has different indentation\n...\n67 | }\n\
    \   |   ^\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659823698
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut stack: Vec<char> = vec![];\n    let vowels\
    \ = vec!['a', 'e', 'i', 'o', 'u'];\n    let mut min_index = 0;\n    let mut min_char\
    \ = ' ';\n    for (i, c) in word.chars().enumerate() {\n        stack.push(c);\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       let mut index = 0;\n            for j in (0..stack.len()).rev() {\n  \
    \              let ch = stack[j];\n                if ch == 'a' || ch == 'e' ||\
    \ ch == 'i' || ch == 'o' || ch == 'u' {\n                    index = j;\n    \
    \                break;\n                }\n            }\n            if stack.len()\
    \ - index < min_index {\n                min_index = stack.len() - index;\n  \
    \              min_char = c;\n            }\n        }\n    }\n    min_char.to_string()\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" \"`,\n right: `\"u\"`', /tmp/tmp9u1940n5.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    if word.len() < 3 {\n        return String::new();\n\
    \    }\n    let mut result = String::new();\n    let mut previous_letter = '\\\
    0';\n    let mut current_letter = '\\0';\n    let mut i = word.len() - 1;\n  \
    \  while i > 0 {\n        current_letter = word.chars().nth(i).unwrap();\n   \
    \     if previous_letter.is_vowel() && current_letter.is_consonant() {\n     \
    \       result = current_letter.to_string();\n            break;\n        }\n\
    \        previous_letter = current_letter;\n        i -= 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmph589tlfx.rs:17:28\n   |\n17 |         if previous_letter.is_vowel()\
    \ && current_letter.is_consonant() {\n   |                            ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_consonant` found\
    \ for type `char` in the current scope\n  --> /tmp/tmph589tlfx.rs:17:57\n   |\n\
    17 |         if previous_letter.is_vowel() && current_letter.is_consonant() {\n\
    \   |                                                         ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = \"aeiou\";\n    let mut left_idx = word.len();\n\
    \    let mut right_idx = 0;\n    let mut result: Option<String> = None;\n    for\
    \ (idx, c) in word.chars().enumerate() {\n        if !vowels.contains(c) {\n \
    \           if left_idx > idx {\n                left_idx = idx;\n           \
    \ }\n            if right_idx < idx {\n                right_idx = idx;\n    \
    \        }\n        }\n    }\n    for (idx, c) in word.chars().enumerate() {\n\
    \        if vowels.contains(c) {\n            let left_dist = (idx - left_idx).abs();\n\
    \            let right_dist = (idx - right_idx).abs();\n            if left_dist\
    \ != 0 && right_dist != 0 {\n                if result.is_none() {\n         \
    \           result = Some(c.to_string());\n                } else {\n        \
    \            let distance = (idx - result.as_ref().unwrap().len()).abs();\n  \
    \                  if distance < left_dist && distance < right_dist {\n      \
    \                  result = Some(c.to_string());\n                    }\n    \
    \            }\n            }\n        }\n    }\n    result.unwrap_or(\"\".to_string())\n\
    }\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `abs` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpejpid0da.rs:24:46\n   |\n24 |             let left_dist\
    \ = (idx - left_idx).abs();\n   |                                            \
    \  ^^^ method not found in `usize`\n\nerror[E0599]: no method named `abs` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpejpid0da.rs:25:48\n   |\n\
    25 |             let right_dist = (idx - right_idx).abs();\n   |             \
    \                                   ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `abs` found for type `usize` in the current scope\n  --> /tmp/tmpejpid0da.rs:30:75\n\
    \   |\n30 |                     let distance = (idx - result.as_ref().unwrap().len()).abs();\n\
    \   |                                                                        \
    \   ^^^ method not found in `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut closest_vowel = String::new();\n    let mut\
    \ right_counter = 0;\n    let mut right_distance = 0;\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut chars = word.chars().rev();\n    while let\
    \ Some(c) = chars.next() {\n        if vowels.contains(&c) {\n            closest_vowel\
    \ = c.to_string();\n            break;\n        }\n        right_counter += 1;\n\
    \    }\n    chars = word.chars();\n    while let Some(c) = chars.next() {\n  \
    \      if vowels.contains(&c) {\n            let distance = (word.len() - right_counter)\
    \ - c.len_utf8();\n            if distance < right_distance || right_distance\
    \ == 0 {\n                closest_vowel = c.to_string();\n                right_distance\
    \ = distance;\n            }\n        }\n    }\n    closest_vowel\n}\n\nfn main()\
    \ {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_6m70dhf.rs:20:13\n   |\n\
    20 |     chars = word.chars();\n   |             ^^^^^^^^^^^^ expected struct\
    \ `Rev`, found struct `Chars`\n   |\n   = note: expected struct `Rev<Chars<'_>>`\n\
    \              found struct `Chars<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 1
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut rightmost = -1;\n    for (i, c) in word.chars().enumerate().rev() {\n  \
    \      if vowels.contains(&c) {\n            rightmost = i;\n            break;\n\
    \        }\n    }\n    for (i, c) in word.chars().enumerate().rev() {\n      \
    \  if !vowels.contains(&c) && i < rightmost {\n            return word[i + 1..=rightmost].to_string();\n\
    \        }\n    }\n    \"\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"\
    u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n\
    \    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"\
    a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n\
    \    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"\
    i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmp0lcpep4r.rs:10:44\n   |\n10 |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n   |                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n   |\n   = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \   --> /tmp/tmp0lcpep4r.rs:10:19\n    |\n10  |     for (i, c) in word.chars().enumerate().rev()\
    \ {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\
    \    = note: required because of the requirements on the impl of `Iterator` for\
    \ `Rev<Enumerate<Chars<'_>>>`\n    = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<Enumerate<Chars<'_>>>`\nnote: required\
    \ by `into_iter`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \ --> /tmp/tmp0lcpep4r.rs:9:25\n  |\n9 |     let mut rightmost = -1;\n  |    \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n  --> /tmp/tmp0lcpep4r.rs:16:44\n\
    \   |\n16 |     for (i, c) in word.chars().enumerate().rev() {\n   |         \
    \                                   ^^^ the trait `ExactSizeIterator` is not implemented\
    \ for `Chars<'_>`\n   |\n   = note: required because of the requirements on the\
    \ impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\n\nerror[E0277]: the\
    \ trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n   --> /tmp/tmp0lcpep4r.rs:16:19\n\
    \    |\n16  |     for (i, c) in word.chars().enumerate().rev() {\n    |      \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `ExactSizeIterator` is\
    \ not implemented for `Chars<'_>`\n    |\n    = note: required because of the\
    \ requirements on the impl of `Doub"
  stdout: ''
  timestamp: 1659823699
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let mut rev_iter = word.chars().rev();\n    let mut\
    \ prev = None;\n    let mut next = rev_iter.next();\n    let mut res = None;\n\
    \    let vowels = \"aeiouAEIOU\";\n    while let Some(ch) = next {\n        if\
    \ res.is_none() && vowels.contains(ch) {\n            res = Some(ch);\n      \
    \  }\n        if res.is_some() && (prev.is_none() || !vowels.contains(prev.unwrap()))\
    \ && (vowels.contains(ch)) {\n            break;\n        }\n        prev = next;\n\
    \        next = rev_iter.next();\n    }\n    match res {\n        Some(ch) =>\
    \ ch.to_string(),\n        None => \"\".to_string(),\n    }\n}\n\nfn main() {\n\
    \    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmp50t1fqxp.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
- exit_code: 101
  program: "/// You are given a word. Your task is to find the closest vowel that\
    \ stands between \n/// two consonants from the right side of the word (case sensitive).\n\
    /// Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n/// find any vowel met the above condition. \n/// You may assume that\
    \ the given string contains English letter only.\n/// Example:\nfn get_closest_vowel(word:\
    \ String) -> String {\n    let l = word.len();\n    let mut i = 0;\n    let mut\
    \ j = l;\n    while i < l {\n        if word.chars().nth(i).unwrap().is_ascii_lowercase()\
    \ && \n            word.chars().nth(i).unwrap().is_alphabetic() {\n          \
    \  break;\n        }\n        i += 1;\n    }\n    while j > 0 {\n        if word.chars().nth(j-1).unwrap().is_ascii_lowercase()\
    \ && \n            word.chars().nth(j-1).unwrap().is_alphabetic() {\n        \
    \    break;\n        }\n        j -= 1;\n    }\n    let mut k = j;\n    let mut\
    \ vowel = \"\";\n    for _ in 0..j {\n        if word.chars().nth(k-1).unwrap().is_ascii_lowercase()\
    \ && \n            word.chars().nth(k-1).unwrap().is_alphabetic() {\n        \
    \    if word.chars().nth(k-1).unwrap() == 'a' ||\n                word.chars().nth(k-1).unwrap()\
    \ == 'e' ||\n                word.chars().nth(k-1).unwrap() == 'i' ||\n      \
    \          word.chars().nth(k-1).unwrap() == 'o' ||\n                word.chars().nth(k-1).unwrap()\
    \ == 'u' {\n                vowel = &word[(k-1)..k];\n                break;\n\
    \            }\n        }\n        k -= 1;\n    }\n    vowel.to_string()\n}\n\n\
    fn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"\
    yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\"\
    )), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\"\
    )), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n\
    \    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n   \
    \ assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"\
    Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\"\
    )), String::from(\"o\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"a\"`,\n right: `\"\"`', /tmp/tmpomv1xu2s.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823699
