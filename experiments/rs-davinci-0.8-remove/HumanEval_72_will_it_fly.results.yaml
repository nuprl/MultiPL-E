language: rs
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    if sum <= w &&\
    \ is_palindrome(&q) {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmclci1jk.rs:12:20\n   |\n12 |     if sum <= w && is_palindrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() == 1 || (q.len() > 1 && is_balanced(q.clone())\
    \ && q.iter().sum::<isize>() <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpwzmn0o3y.rs:11:37\n\
    \   |\n11 |     q.len() == 1 || (q.len() > 1 && is_balanced(q.clone()) && q.iter().sum::<isize>()\
    \ <= w)\n   |                                     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    let sum = q.iter().sum::<isize>();\n    sum <= w && q == q_rev\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let length = q.len();\n    if length == 0 { return\
    \ true; }\n    if length == 1 { return q[0] <= w; }\n    if length == 2 { return\
    \ q[0] + q[1] <= w; }\n    let mid = length / 2;\n    let left = &q[0..mid];\n\
    \    let right = &q[mid..length];\n    let right_rev = right.iter().rev();\n \
    \   let sum: isize = left.iter().chain(right_rev).sum();\n    sum <= w && left\
    \ == right_rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmphs_bipti.rs:20:22\n   |\n20 |     sum <= w && left == right_rev\n\
    \   |                      ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() < 2 {\n        return q.len() == 1 && q[0]\
    \ <= w;\n    }\n    if q.len() % 2 == 0 {\n        let mut half = q.len() / 2;\n\
    \        while half > 0 {\n            if q[half - 1] != q[q.len() - half] {\n\
    \                return false;\n            }\n            half -= 1;\n      \
    \  }\n    } else {\n        let mut half = q.len() / 2;\n        while half >\
    \ 0 {\n            if q[half - 1] != q[q.len() - half] {\n                return\
    \ false;\n            }\n            half -= 1;\n        }\n    }\n    let mut\
    \ sum = 0;\n    for i in q {\n        sum += i;\n    }\n    return sum <= w;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpnlysqls0.rs:11:39\n\
    \   |\n11 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() % 2 == 0 && q.iter().sum::<isize>() > w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqmv9zvxk.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut q_iter\
    \ = q.iter();\n    let mut q_iter_rev = q.iter().rev();\n    let mut is_balanced\
    \ = true;\n    for _ in 0..q.len()/2 {\n        if q_iter.next() != q_iter_rev.next()\
    \ {\n            is_balanced = false;\n            break;\n        }\n    }\n\
    \    sum <= w && is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut w_sum = 0;\n    let len = q.len();\n    let\
    \ half = len / 2;\n    for (i, n) in q.iter().enumerate() {\n        if i < half\
    \ {\n            w_sum += n;\n        } else if i > half {\n            w_sum\
    \ -= n;\n        }\n    }\n    if w_sum <= w {\n        true\n    } else {\n \
    \       false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4z9_6wgh.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let s = q.iter().sum::<isize>();\n    let r = q.iter().rev().collect::<Vec<_>>();\n\
    \    s <= w && q == r\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpahrq_dx_.rs:13:17\n\
    \   |\n13 |     s <= w && q == r\n   |                 ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum: isize = 0;\n    for i in q.iter() {\n\
    \        sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n  \
    \  let mut rev = q.clone();\n    rev.reverse();\n    return q == rev;\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    if sum <= w\
    \ {\n        let mut queue = VecDeque::new();\n        for i in q {\n        \
    \    queue.push_back(i);\n        }\n        let mut check = VecDeque::new();\n\
    \        while !queue.is_empty() {\n            let front = queue.pop_front().unwrap();\n\
    \            let back = queue.pop_back().unwrap();\n            if front != back\
    \ {\n                return false;\n            }\n            check.push_back(front);\n\
    \        }\n        let sum = check.iter().sum::<isize>();\n        sum <= w\n\
    \    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpru_mesov.rs:13:25\n   |\n13 |         let mut queue = VecDeque::new();\n\
    \   |                         ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  --> /tmp/tmpru_mesov.rs:17:25\n\
    \   |\n17 |         let mut check = VecDeque::new();\n   |                   \
    \      ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::VecDeque;\n   |\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    let is_palindrome = q.iter().rev().eq(q.iter());\n   \
    \ return is_palindrome && sum <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut s = 0;\n    for i in q.iter() {\n        s\
    \ += i;\n    }\n    let l = q.len();\n    if l == 0 {\n        return false;\n\
    \    }\n    let mut p = q.clone();\n    p.reverse();\n    if s <= w && q == p\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let balanced = q.iter().rev().eq(q.iter());\n    let\
    \ sum: isize = q.iter().sum();\n    balanced && sum <= w\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut first = 0;\n    let mut last = q.len() - 1;\n\
    \    let mut weight = 0;\n    while first <= last {\n        if q[first] + q[last]\
    \ > w {\n            return false;\n        }\n        if q[first] != q[last]\
    \ {\n            return false;\n        }\n        weight += q[first];\n     \
    \   first += 1;\n        last -= 1;\n    }\n    weight <= w\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp42tvmf07.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let mut sum = 0;\n  for i in q.iter() {\n    sum += i;\n\
    \  }\n  if sum <= w {\n    return true;\n  }\n  false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5m3jc9ch.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // Try it online!\n    // https://tio.run/##@/55Q0DGBbCD8BAjEIyOmFwUPD@bhDxP8oXZhkLZdKWS1lFyaW8tJceSAoKjQ2v3s3sW8QXKkMZkzE@T73eR1LUgDdKrYT97oSwtotJiGxhgkDpjtLZJFv1h8Gsc13HTOyQftAdy3/i3Q\
    \ \"Try it online!\"\n    if q.len() < 2 {\n        return false;\n    }\n   \
    \ let sum: isize = q.iter().sum();\n    if sum > w {\n        return false;\n\
    \    }\n    let left: isize = q[0];\n    let right: isize = q[q.len() - 1];\n\
    \    if left > right {\n        return false;\n    }\n    if left < right {\n\
    \        let mut new_q: Vec<isize> = q.clone();\n        new_q.pop();\n      \
    \  return will_it_fly(new_q, w);\n    }\n    let mut new_q: Vec<isize> = q.clone();\n\
    \    new_q.pop();\n    new_q.remove(0);\n    will_it_fly(new_q, w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9vzzauco.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum: isize = 0;\n    for i in &q {\n      \
    \  sum += i;\n    }\n    let mut i: usize = 0;\n    let mut j: usize = q.len()\
    \ - 1;\n    while i <= j {\n        if q[i] != q[j] {\n            return false;\n\
    \        }\n        i += 1;\n        j -= 1;\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpqh461yj3.rs:22:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return true;\n    }\n  \
    \  q.iter().take(q.len() / 2).fold(0, |acc, n| acc + n) == q.iter().skip(q.len()\
    \ / 2 + 1).fold(0, |acc, n| acc + n) && q.iter().sum::<isize>() <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let middle\
    \ = q.len() / 2;\n    let front = &q[..middle];\n    let end = &q[middle + q.len()\
    \ % 2..];\n    front == end.iter().rev() && sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmpjogfz_x6.rs:15:11\n   |\n15 |     front == end.iter().rev() &&\
    \ sum <= w\n   |           ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let q_is_palindrome = is_palindrome(&q);\n    let q_total\
    \ = q.iter().sum::<isize>();\n    q_is_palindrome && q_total <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmprxf23p1t.rs:11:27\n   |\n11 |     let q_is_palindrome = is_palindrome(&q);\n\
    \   |                           ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_637frvw.rs:11:37\n   |\n11 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut i = 0;\n    let mut s = q.len() - 1;\n    let\
    \ mut sum = 0;\n    while i <= s {\n        sum += q[i];\n        if sum > w {\n\
    \            return false;\n        }\n        if q[i] != q[s] {\n           \
    \ return false;\n        }\n        i += 1;\n        s -= 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmplk9zfdcx.rs:23:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let left =\
    \ q.iter().rev().take(q.len() / 2).sum::<isize>();\n    let right = q.iter().skip(q.len()\
    \ / 2).sum::<isize>();\n    sum <= w && left == right\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4psyw7j3.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.reverse();\n    let sum = q.iter().fold(0,\
    \ |acc, &x| acc + x);\n    if sum <= w && is_palidrome(&q) {\n        true\n \
    \   } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palidrome` in this scope\n  -->\
    \ /tmp/tmpy8zlklp5.rs:14:20\n   |\n14 |     if sum <= w && is_palidrome(&q) {\n\
    \   |                    ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    let mut sum = 0;\n    for i in\
    \ q.iter() {\n        sum += i;\n    }\n    if sum <= w {\n        let mut r:\
    \ Vec<isize> = Vec::new();\n        while q.len() > 0 {\n            let last\
    \ = q.pop().unwrap();\n            r.push(last);\n        }\n        if r == q\
    \ {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp3nl4ea9u.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut list = q.clone();\n    if list.len() == 1 {\n\
    \        return true;\n    }\n    let mid_idx = list.len() / 2;\n    if list.len()\
    \ % 2 == 0 {\n        list.remove(mid_idx);\n    }\n    let first_half = list.get(0..mid_idx).unwrap();\n\
    \    let second_half = list.get(mid_idx..list.len()).unwrap();\n    if list.len()\
    \ == 2 {\n        return first_half == second_half;\n    }\n    let mut weight:\
    \ isize = 0;\n    for (x, y) in first_half.iter().zip(second_half.iter()) {\n\
    \        weight += x + y;\n    }\n    weight <= w && first_half == second_half.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp2ahbdw06.rs:28:31\n\
    \   |\n28 |     weight <= w && first_half == second_half.iter().rev().collect::<Vec<_>>()\n\
    \   |                               ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `&[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let balance = q.iter().collect::<Vec<_>>() == q.iter().rev().collect::<Vec<_>>();\n\
    \    let weight = q.iter().sum::<isize>();\n    balance && weight <= w\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpufmpvbq4.rs:11:39\n\
    \   |\n11 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let reverse\
    \ = q.iter().rev().cloned().collect::<Vec<isize>>();\n    sum <= w && q == reverse\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut total = 0;\n    for i in q.iter() {\n     \
    \   total += i;\n    }\n    if total <= w && is_palindrome(&q) {\n        return\
    \ true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp25j2nirj.rs:15:22\n   |\n15 |     if total <= w && is_palindrome(&q)\
    \ {\n   |                      ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut qc\
    \ = q.clone();\n    qc.reverse();\n    let balanced = q == qc;\n    sum <= w &&\
    \ balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let mut list:\
    \ Vec<isize> = q.clone();\n    list.reverse();\n    q == list && sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return true;\n    }\n  \
    \  let sum = q.iter().sum();\n    let left = &q[0..(q.len() / 2)];\n    let right\
    \ = &q[(q.len() / 2 + q.len() % 2)..];\n    if sum <= w && left == right.iter().rev()\
    \ {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmpahbhh94u.rs:17:25\n   |\n17 |     if sum <= w && left == right.iter().rev()\
    \ {\n   |                         ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum <= w {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprg4pltz2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    sum <= w &&\
    \ q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpr9t85ofe.rs:12:19\n\
    \   |\n12 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    sum <= w &&\
    \ q == q.iter().rev().collect::<Vec<&isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpr9t85ofe.rs:12:19\n\
    \   |\n12 |     sum <= w && q == q.iter().rev().collect::<Vec<&isize>>()\n   |\
    \                   ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut a = 0;\n    let mut b = q.len() - 1;\n    while\
    \ a < b {\n        if q[a] != q[b] {\n            return false;\n        }\n \
    \       a += 1;\n        b -= 1;\n    }\n    return q.iter().sum::<isize>() <=\
    \ w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 { return true; }\n    if q.len() %\
    \ 2 == 0 { return false; }\n    let mut i = 0;\n    let mut j = q.len() - 1;\n\
    \    while i < j {\n        if q[i] != q[j] { return false; }\n        i += 1;\n\
    \        j -= 1;\n    }\n    let sum: isize = q.iter().sum();\n    if sum <= w\
    \ { return true; }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.is_empty() { return true; }\n    let mut wt =\
    \ w;\n    let mut qq = q.clone();\n    let mut has_one = false;\n    while qq.len()\
    \ > 1 {\n        let mut i = 0;\n        let mut j = qq.len() - 1;\n        let\
    \ (mut sum, mut palin) = (0, true);\n        loop {\n            if i >= j { break;\
    \ }\n            if qq[i] == qq[j] {\n                sum += qq[i] + qq[j];\n\
    \                i += 1;\n                j -= 1;\n            } else {\n    \
    \            palin = false;\n                break;\n            }\n        }\n\
    \        if qq.len() % 2 == 1 { sum += qq[i]; }\n        if wt < sum {\n     \
    \       return false;\n        } else {\n            if qq.len() % 2 == 1 {\n\
    \                has_one = true;\n            }\n            wt -= sum;\n    \
    \        if wt <= 0 { return true; }\n            qq = qq.iter().filter(|x| **x\
    \ != qq[i]).cloned().collect();\n        }\n    }\n    if qq.len() == 1 && has_one\
    \ && wt >= qq[0] { return true; }\n    qq.len() == 1 && wt > 0 && wt - qq[0] >=\
    \ 0\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprsgvwb2n.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let is_balanced = is_palindrome(&q);\n    let total_weight\
    \ = q.iter().fold(0, |acc, &x| acc + x);\n    is_balanced && total_weight <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpfpglhotm.rs:11:23\n   |\n11 |     let is_balanced = is_palindrome(&q);\n\
    \   |                       ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if is_balanced(q.clone()) && q.iter().sum::<isize>()\
    \ <= w {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp_og6u1ln.rs:11:8\n\
    \   |\n11 |     if is_balanced(q.clone()) && q.iter().sum::<isize>() <= w {\n\
    \   |        ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut m = 0;\n    let mut q = q;\n    let l = q.len();\n\
    \    while q.len() > 0 {\n        m += q.pop().unwrap();\n        if m > w {\n\
    \            return false;\n        }\n        if q.len() == 0 {\n           \
    \ return true;\n        }\n        m += q.remove(0);\n        if m > w {\n   \
    \         return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprkdiak9z.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let sum = q.iter().sum();\n  if sum > w { return false;\
    \ }\n  let mut q2 = q.clone();\n  q2.reverse();\n  q == q2\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp2n8_k0d6.rs:11:7\n\
    \   |\n11 |   let sum = q.iter().sum();\n   |       ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let is_palindrome\
    \ = q.windows(2).all(|w| w[0] == w[1]);\n    return is_palindrome && sum <= w;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpw9aqpfrf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() % 2 == 0 {\n        false\n    } else {\n\
    \        let half = q.len() / 2;\n        let f = &q[..half];\n        let s =\
    \ &q[half + 1..];\n        if f == s.iter().rev() {\n            f.iter().fold(0,\
    \ |acc, x| acc + x) <= w\n        } else {\n            false\n        }\n   \
    \ }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmpzw612pwt.rs:17:14\n   |\n17 |         if f == s.iter().rev() {\n\
    \   |              ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let is_palindrome:\
    \ bool = q.iter().zip(q.iter().rev()).all(|(a, b)| a == b);\n    is_palindrome\
    \ && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut s: isize = 0;\n    for n in q.iter() {\n  \
    \      s += n;\n    }\n    if s > w {\n        return false;\n    }\n    let mut\
    \ r = q.clone();\n    r.reverse();\n    r == q\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // Your code here.\n    let sum: isize = q.iter().sum();\n\
    \    if sum > w {\n        return false;\n    }\n    let mut vec = q.clone();\n\
    \    vec.reverse();\n    if q == vec {\n        return true;\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let (head, tail) = q.split_at(q.len() / 2);\n    let\
    \ sum = head.iter().sum::<isize>() + tail.iter().sum::<isize>();\n    sum <= w\
    \ && head == tail.iter().rev()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&[isize]` with `Rev<std::slice::Iter<'_, isize>>`\n\
    \  --> /tmp/tmpu0d265he.rs:13:22\n   |\n13 |     sum <= w && head == tail.iter().rev()\n\
    \   |                      ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  if sum_of_q(q) > w {\n    return false;\n  }\n  if q.len()\
    \ == 1 {\n    return true;\n  }\n  if (q.len() % 2 == 0) {\n    return false;\n\
    \  }\n  let half = q.len() / 2;\n  let i = q.iter().take(half).zip(q.iter().rev().take(half)).all(|(x,\
    \ y)| x == y);\n  return i;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_of_q` in this scope\n  --> /tmp/tmpp4114txx.rs:11:6\n\
    \   |\n11 |   if sum_of_q(q) > w {\n   |      ^^^^^^^^ not found in this scope\n\
    \nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp4114txx.rs:17:6\n\
    \   |\n17 |   if (q.len() % 2 == 0) {\n   |      ^^^^^^^^^^^^^^^^^^ help: remove\
    \ these parentheses\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.reverse();\n \
    \   let mut right = 0;\n    let mut left = 0;\n    for i in 0..q.len() {\n   \
    \     if i % 2 == 0 {\n            right += q[i];\n        } else {\n        \
    \    left += q[i];\n        }\n    }\n    let sum = right + left;\n    let left_right\
    \ = left - right;\n    sum <= w && left_right == 0\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpca2xdcbf.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum: isize = 0;\n    for i in q.iter() {\n\
    \        sum += i;\n    }\n    if sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for c in q.clone() {\n      \
    \  sum += c;\n    }\n    if sum <= w {\n        let mut left = 0;\n        let\
    \ mut right = q.len() - 1;\n        let mut is_palindrome = true;\n        while\
    \ left < right {\n            if q[left] != q[right] {\n                is_palindrome\
    \ = false;\n                break;\n            }\n            left += 1;\n  \
    \          right -= 1;\n        }\n        is_palindrome\n    } else {\n     \
    \   false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut b =\
    \ q.clone();\n    b.reverse();\n    sum <= w && q == b\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut left = 0;\n    let mut right = q.len() - 1;\n\
    \    while left < right {\n        if q[left] != q[right] {\n            return\
    \ false;\n        }\n        left += 1;\n        right -= 1;\n    }\n    q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let mut copy_q\
    \ = q.clone();\n    copy_q.reverse();\n    return sum <= w && q == copy_q;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let total_weight = q.iter().sum();\n    return (q ==\
    \ q.iter().rev().collect::<Vec<_>>()) && (total_weight <= w);\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmppz35l05i.rs:12:15\n\
    \   |\n12 |     return (q == q.iter().rev().collect::<Vec<_>>()) && (total_weight\
    \ <= w);\n   |               ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() == 1 || (q.len() > 2 && q.iter().sum::<isize>()\
    \ <= w && q.iter().zip(q.iter().rev()).all(|(x, y)| x == y))\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().cloned().sum::<isize>() <= w && q == q.iter().cloned().rev().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpufmpvbq4.rs:11:39\n\
    \   |\n11 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgt30q_7f.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // The weight of the object is less than the maximum\
    \ possible weight.\n    let current_weight = q.iter().sum::<isize>();\n    if\
    \ current_weight > w {\n        return false;\n    }\n    // The object q is balanced,\
    \ i.e. it is a palindromic list.\n    let len = q.len();\n    let (left, right)\
    \ = q.split_at(len / 2);\n    let left = left.to_vec();\n    let right = right.to_vec();\n\
    \    // Remove the last element if len is odd.\n    let right = if len % 2 ==\
    \ 0 {\n        right\n    } else {\n        let last = right.last().unwrap();\n\
    \        let mut right = right.to_vec();\n        right.pop();\n        right\n\
    \    };\n    left == right.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpi4d7hs4x.rs:30:10\n\
    \   |\n30 |     left == right.iter().rev().collect::<Vec<_>>()\n   |         \
    \ ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() <= 1 {\n        return true;\n    }\n  \
    \  let mut sum = 0;\n    for x in q.iter() {\n        sum += x;\n    }\n    if\
    \ sum > w {\n        return false;\n    }\n    for x in q.iter() {\n        let\
    \ mut new_q = q.clone();\n        new_q.remove_item(x);\n        if will_it_fly(new_q,\
    \ w) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_item` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpz8hrbws_.rs:23:15\n   |\n23 |         new_q.remove_item(x);\n\
    \   |               ^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let q_len = q.len();\n    let mut sum: isize = 0;\n\
    \    let mut q_new = Vec::new();\n    for i in 0..q_len {\n        if q[i] < 0\
    \ {\n            break;\n        }\n        q_new.push(q[i]);\n        sum +=\
    \ q[i];\n    }\n    if sum > w {\n        return false;\n    }\n    if q_new.len()\
    \ == 0 {\n        return true;\n    }\n    let mut q_rev = q_new.clone();\n  \
    \  q_rev.reverse();\n    if q_new == q_rev {\n        return true;\n    }\n  \
    \  return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if w < 0 {\n        false\n    } else if q.len() ==\
    \ 0 {\n        true\n    } else if q.len() == 1 {\n        q[0] <= w\n    } else\
    \ {\n        let len = q.len();\n        let m = len / 2;\n        let mut sum\
    \ = 0;\n        for i in 0..m {\n            if q[i] != q[len - i - 1] {\n   \
    \             return false;\n            }\n            sum += q[i];\n       \
    \ }\n        if len % 2 == 1 {\n            sum += q[m];\n        }\n        sum\
    \ <= w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if !is_balanced(&q) {\n        return false;\n    }\n\
    \n    let sum = q.iter().sum();\n    sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpvmxlxawa.rs:11:9\n\
    \   |\n11 |     if !is_balanced(&q) {\n   |         ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() >= 2 && q.iter().sum::<isize>() <= w && q ==\
    \ q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5drj4uwk.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    fn balanced(v: &Vec<isize>) -> bool {\n        // fix\
    \ for a \"borrow of moved value\" error\n        let mut new_v = v.clone();\n\
    \        new_v.reverse();\n        v == &new_v\n    }\n    q.iter().sum::<isize>()\
    \ <= w && balanced(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut my_vec: Vec<isize> = q.clone();\n    my_vec.sort();\n\
    \    let mut accumulator: isize = 0;\n    while my_vec.len() > 0 {\n        accumulator\
    \ += my_vec.pop().unwrap();\n        if accumulator > w {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpetdifgm4.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.is_empty() { return true; }\n    if q.len() ==\
    \ 1 { return q[0] <= w; }\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut r: Vec<isize> = q.clone();\n    r.reverse();\n\
    \    q == r && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    //let q: Vec<isize> = vec![3, 2, 3];\n    let mut left\
    \ = 0;\n    let mut right = q.len() - 1;\n    let mut left_sum = 0;\n    let mut\
    \ right_sum = 0;\n    let mut palindrome = true;\n    let mut total = 0;\n   \
    \ for i in q.iter() {\n        total += i;\n    }\n    while left < right {\n\
    \        if q[left] != q[right] {\n            palindrome = false;\n         \
    \   break;\n        }\n        left_sum += q[left];\n        right_sum += q[right];\n\
    \        left += 1;\n        right -= 1;\n    }\n    if palindrome && total <=\
    \ w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    (q.len() == 1 || q == q.iter().rev().collect()) &&\
    \ q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmp4_i8xtnt.rs:11:24\n\
    \   |\n11 |     (q.len() == 1 || q == q.iter().rev().collect()) && q.iter().sum::<isize>()\
    \ <= w\n   |                        ^^ cannot infer type\n   |\n   = note: cannot\
    \ satisfy `Vec<isize>: PartialEq<_>`\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n11 |     (q.len() == 1 || q == q.iter().rev().collect::<B>())\
    \ && q.iter().sum::<isize>() <= w\n   |                                      \
    \           +++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0283`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return false;\n    }\n \
    \   let mut reversed = Vec::new();\n    for item in q.iter().rev() {\n       \
    \ reversed.push(*item);\n    }\n    if q == reversed {\n        let mut sum =\
    \ 0;\n        for item in q.iter() {\n            sum += *item;\n        }\n \
    \       if sum <= w {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() > 0 {\n        if q.len() == 1 {\n     \
    \       return q[0] <= w;\n        } else {\n            let mut q_clone = q.clone();\n\
    \            let h = q_clone.remove(0);\n            let t = q_clone.remove(q_clone.len()\
    \ - 1);\n            if h == t {\n                return will_it_fly(q_clone,\
    \ w - h);\n            } else {\n                return false;\n            }\n\
    \        }\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return false;\n    }\n\n\
    \    let mut i = 0;\n    let mut j = q.len() - 1;\n    let mut sum = 0;\n    while\
    \ i < j {\n        if q[i] != q[j] {\n            return false;\n        }\n \
    \       sum += q[i];\n        sum += q[j];\n        i += 1;\n        j -= 1;\n\
    \    }\n    if i == j {\n        sum += q[i];\n    }\n    sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() == 1 && q[0] <= w || q.len() > 1 && q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpbsk300sh.rs:11:83\n\
    \   |\n11 |     q.len() == 1 && q[0] <= w || q.len() > 1 && q.iter().sum::<isize>()\
    \ <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |                      \
    \                                                             ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = note: required because of the requirements on\
    \ the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().fold(0, |acc, x| acc + x) <= w && is_palindrome(&q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp49ltdiw8.rs:11:48\n   |\n11 |     q.iter().fold(0, |acc, x| acc + x)\
    \ <= w && is_palindrome(&q)\n   |                                            \
    \    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for i in q.iter() {\n       \
    \ sum += i;\n    }\n    if sum > w {\n        return false;\n    }\n    let mut\
    \ first = 0;\n    let mut last = q.len() - 1;\n    while first < last {\n    \
    \    if q[first] != q[last] {\n            return false;\n        }\n        first\
    \ += 1;\n        last -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut s: Vec<isize> = Vec::new();\n    let mut p:\
    \ Vec<isize> = Vec::new();\n    let mut sum = 0;\n    for i in q {\n        sum\
    \ += i;\n        s.push(i);\n        p.push(i);\n    }\n    p.reverse();\n   \
    \ p == s && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let len = q.len();\n\
    \    if len % 2 == 0 {\n        return false;\n    }\n    if sum <= w {\n    \
    \    let mid = len / 2;\n        let left = &q[0..mid];\n        let right = &q[mid\
    \ + 1..len];\n        let reversed: Vec<isize> = right.iter().rev().map(|x| *x).collect();\n\
    \        return left == &reversed[..];\n    }\n    false\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum: isize = 0;\n    let mut t = q.clone();\n\
    \    t.reverse();\n    //println!(\"{:?}\", q);\n    if t == q {\n        for\
    \ x in q {\n            sum += x;\n        }\n        if sum <= w {\n        \
    \    return true;\n        }\n    }\n    return false;\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut total: isize = 0;\n    for c in q.iter() {\n\
    \        total += c;\n    }\n    if total > w {\n        return false;\n    }\n\
    \    for (i, j) in q.iter().zip(q.iter().rev()) {\n        if i != j {\n     \
    \       return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 { return true; }\n    let sum = q.iter().fold(0,\
    \ |acc, &x| acc + x);\n    sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpa5ui99gp.rs:13:19\n\
    \   |\n13 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut a = 0;\n    let mut b = q.len() - 1;\n    let\
    \ mut flag = true;\n    while a < b {\n        if q[a] != q[b] {\n           \
    \ flag = false;\n            break;\n        }\n        a += 1;\n        b -=\
    \ 1;\n    }\n    let qsum: isize = q.iter().sum();\n    flag && qsum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() % 2 == 0 {\n        return false;\n    }\n\
    \    let q_len = q.len();\n    let count = (q_len / 2) + 1;\n    let mut q_iter\
    \ = q.iter();\n    let mut q_iter_rev = q.iter().rev();\n    let mut sub_total\
    \ = 0;\n    for _ in 0..count {\n        let value = q_iter.next().unwrap();\n\
    \        let value_rev = q_iter_rev.next().unwrap();\n        if value != value_rev\
    \ {\n            return false;\n        }\n        sub_total += value;\n    }\n\
    \    if sub_total > w {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return true;\n    }\n  \
    \  if q.len() % 2 == 0 {\n        return false;\n    }\n    let mid = q.len()\
    \ / 2;\n    if q[0..mid] != q[mid+1..].iter().rev().collect::<Vec<_>>() {\n  \
    \      return false;\n    }\n    let sum = q.iter().fold(0, |sum, x| sum + x);\n\
    \    sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpx03f9osd.rs:18:18\n\
    \   |\n18 |     if q[0..mid] != q[mid+1..].iter().rev().collect::<Vec<_>>() {\n\
    \   |                  ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() <= 1 {\n        return true;\n    }\n  \
    \  let mut q = q;\n    let mut l = 0;\n    let mut r = q.len() - 1;\n    while\
    \ l < r {\n        if q[l] + q[r] > w {\n            return false;\n        }\n\
    \        if q[l] == q[r] {\n            l += 1;\n            r -= 1;\n       \
    \ } else if q[l] < q[r] {\n            q[l + 1] += q[l];\n            l += 1;\n\
    \        } else {\n            q[r - 1] += q[r];\n            r -= 1;\n      \
    \  }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpy0qs59l2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return false;\n    }\n \
    \   if q.len() == 1 {\n        return true;\n    }\n    if q == q.iter().rev().collect::<Vec<&isize>>()\
    \ {\n        if q.iter().sum::<isize>() <= w {\n            return true;\n   \
    \     }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpx7csrz07.rs:17:10\n\
    \   |\n17 |     if q == q.iter().rev().collect::<Vec<&isize>>() {\n   |      \
    \    ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>`\
    \ is not implemented for `isize`\n   = note: required because of the requirements\
    \ on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() < 2 {\n        return q.iter().sum::<isize>()\
    \ <= w;\n    }\n    let (mut first, mut last) = (0isize, 0isize);\n    for i in\
    \ 0..q.len()/2 {\n        first += q[i];\n        last += q[q.len()-1-i];\n  \
    \      if first > w || last > w {\n            return false;\n        }\n    }\n\
    \    return first <= w && last <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcmpqf7hx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() < 2 { return true; }\n    if q.iter().sum::<isize>()\
    \ > w { return false; }\n    let mut i = 0;\n    let mut j = q.len() - 1;\n  \
    \  while i < j {\n        if q[i] != q[j] { return false; }\n        i += 1;\n\
    \        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let b = q.len() / 2;\n    let sum = q.iter().take(b).sum::<isize>()\
    \ * 2;\n    if q.len() % 2 == 1 {\n        sum += q[b];\n    }\n    sum <= w &&\
    \ q == q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp998lq38x.rs:16:19\n\
    \   |\n16 |     sum <= w && q == q.iter().rev().collect::<Vec<_>>()\n   |    \
    \               ^^ no implementation for `isize == &isize`\n   |\n   = help: the\
    \ trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for elem in q.iter() {\n    \
    \    sum += elem;\n    }\n    if sum <= w {\n        let mut q_rev = q.clone();\n\
    \        q_rev.reverse();\n        for (v1, v2) in q.iter().zip(q_rev.iter())\
    \ {\n            if v1 != v2 {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut acc = 0;\n    for i in q.iter() {\n       \
    \ acc += i;\n    }\n    acc <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let total_weight = q.iter().sum();\n    total_weight\
    \ <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpajihj_n7.rs:12:26\n   |\n12 |     total_weight <= w && is_palindrome(&q)\n\
    \   |                          ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() <= 1 || (q.iter().sum::<isize>() <= w && q\
    \ == q.iter().rev().collect::<Vec<&isize>>())\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp0eq786w_.rs:11:56\n\
    \   |\n11 |     q.len() <= 1 || (q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<&isize>>())\n\
    \   |                                                        ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = note: required because of the requirements on\
    \ the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.reverse();\n    let sum: isize\
    \ = q.iter().sum();\n    return q == q.iter().rev().cloned().collect::<Vec<isize>>()\
    \ && sum <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() <= 1 {\n        return true;\n    }\n  \
    \  if q.len() % 2 == 0 {\n        return false;\n    }\n    let mut left: Vec<isize>\
    \ = Vec::new();\n    let mut right: Vec<isize> = Vec::new();\n    let mut sum\
    \ = 0;\n    for (i, e) in q.iter().enumerate() {\n        if i < q.len() / 2 {\n\
    \            left.push(*e);\n        } else if i > q.len() / 2 {\n           \
    \ right.push(*e);\n        }\n        sum += e;\n    }\n    left == right && sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  if q.len() % 2 == 0 {\n    return false;\n  }\n\n  let\
    \ mut s = 0;\n  for i in 0..q.len()/2 {\n    s += q[i] + q[q.len()-1-i];\n  }\n\
    \  s += q[q.len()/2];\n\n  return s <= w;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4tr0htm1.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // TODO - Add your code here!\n    unimplemented!();\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmp08fohqh0.rs:12:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let s = q.len();\n    for i in\
    \ 0..s {\n        sum += q[i];\n        if sum > w {\n            return false;\n\
    \        }\n    }\n    for i in 0..s / 2 {\n        if q[i] != q[s - i - 1] {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut will_fly = false;\n    let mut weight = 0;\n\
    \    let mut is_balanced = true;\n    if q.len() > 1 {\n        let mut a = q.clone();\n\
    \        let mut b = q.clone();\n        a.reverse();\n        for i in 0..q.len()\
    \ {\n            if a[i] != b[i] {\n                is_balanced = false;\n   \
    \             break;\n            }\n        }\n        for i in 0..q.len() {\n\
    \            weight += q[i];\n        }\n        if weight <= w && is_balanced\
    \ {\n            will_fly = true;\n        }\n    }\n    return will_fly;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptbn366vo.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    if sum > w {\n\
    \        return false;\n    }\n    if q.len() % 2 == 0 {\n        return false;\n\
    \    }\n    let mut left = 0;\n    let mut right = q.len() - 1;\n    while left\
    \ < right {\n        if q[left] != q[right] {\n            return false;\n   \
    \     }\n        left += 1;\n        right -= 1;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let mut q_copy\
    \ = q.clone();\n    q_copy.reverse();\n    sum <= w && q == q_copy\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpufvp7b49.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let (left, right) = q.split_at(q.len() / 2);\n    let\
    \ is_palindrome = (left == right.iter().rev());\n    let is_under_weight = (left.iter().sum::<isize>()\
    \ + right.iter().sum::<isize>() <= w);\n    return is_palindrome && is_under_weight;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp6mgcdn06.rs:12:25\n\
    \   |\n12 |     let is_palindrome = (left == right.iter().rev());\n   |      \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove these parentheses\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\n\nwarning: unnecessary\
    \ parentheses around assigned value\n  --> /tmp/tmp6mgcdn06.rs:13:27\n   |\n13\
    \ |     let is_under_weight = (left.iter().sum::<isize>() + right.iter().sum::<isize>()\
    \ <= w);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove these parentheses\n\nerror[E0277]: can't compare `&[isize]` with\
    \ `Rev<std::slice::Iter<'_, isize>>`\n  --> /tmp/tmp6mgcdn06.rs:12:31\n   |\n\
    12 |     let is_palindrome = (left == right.iter().rev());\n   |             \
    \                  ^^ no implementation for `&[isize] == Rev<std::slice::Iter<'_,\
    \ isize>>`\n   |\n   = help: the trait `PartialEq<Rev<std::slice::Iter<'_, isize>>>`\
    \ is not implemented for `&[isize]`\n\nerror: aborting due to previous error;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpufmpvbq4.rs:11:39\n\
    \   |\n11 |     q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                       ^^ no implementation for `isize ==\
    \ &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented for\
    \ `isize`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let r: isize\
    \ = q.iter().rev().sum();\n    if sum <= w && sum == r {\n        return true;\n\
    \    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvo9tfw58.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    if sum <= w\
    \ {\n        if q.iter().rev().eq(q.iter()) {\n            return true;\n    \
    \    }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    sum <= w &&\
    \ q == q.iter().rev().cloned().collect::<Vec<isize>>()\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    for i in 0..q.len() {\n        let tmp: isize = q[0..i].iter().sum();\n\
    \        if tmp <= w && q[0..i] == q[i..].iter().rev().collect::<Vec<_>>() {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpheiu77w8.rs:13:32\n\
    \   |\n13 |         if tmp <= w && q[0..i] == q[i..].iter().rev().collect::<Vec<_>>()\
    \ {\n   |                                ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgt30q_7f.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823211
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpufvp7b49.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let len = q.len();\n    let mut left = 0;\n    let\
    \ mut right = len - 1;\n    let mut sum = 0;\n    for &el in q.iter() {\n    \
    \    sum += el;\n    }\n    if sum > w {\n        return false;\n    }\n    while\
    \ left < right {\n        if q[left] != q[right] {\n            return false;\n\
    \        }\n        left += 1;\n        right -= 1;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut reverse_q = q.clone();\n    reverse_q.reverse();\n\
    \    q == reverse_q && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut v = q.clone();\n    v.sort();\n    v.reverse();\n\
    \    let total = v.iter().fold(0, |acc, &x| acc + x);\n    if total <= w {\n \
    \       let rev = q.clone();\n        let rev = rev.iter().rev().collect::<Vec<&isize>>();\n\
    \        if q == rev {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpjda85by1.rs:18:14\n\
    \   |\n18 |         if q == rev {\n   |              ^^ no implementation for\
    \ `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return true;\n    }\n  \
    \  let sum: isize = q.iter().sum();\n    if sum > w {\n        return false;\n\
    \    }\n    if q.len() % 2 == 0 {\n        return false;\n    }\n    let mut left:\
    \ isize = 0;\n    let mut right: isize = 0;\n    let half: usize = q.len() / 2;\n\
    \    let mut i: usize = 0;\n    while i < half {\n        left += q[i];\n    \
    \    right += q[q.len() - 1 - i];\n        if left < right {\n            return\
    \ false;\n        }\n        i += 1;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // Your code here\n    let mut s = 0;\n    let mut\
    \ r = Vec::new();\n    for i in q.iter() {\n        s += i;\n        r.push(*i);\n\
    \    }\n    return s <= w && r == r.iter().rev().collect::<Vec<isize>>();\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n  --> /tmp/tmp6y5kg5ip.rs:18:42\n   |\n18 |\
    \     return s <= w && r == r.iter().rev().collect::<Vec<isize>>();\n   |    \
    \                                      ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=&isize>`\n   |\n   = help: the trait\
    \ `FromIterator<&isize>` is not implemented for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // let sum: isize = q.iter().sum();\n    // let (a,\
    \ b) = q.split_at(q.len() / 2);\n    // a == b && sum <= w\n    let sum: isize\
    \ = q.iter().sum();\n    let n = q.len();\n    let (a, b) = q.split_at(n / 2);\n\
    \    a == b && sum <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpu1joct3s.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return false;\n    }\n \
    \   if q.len() == 1 {\n        return q[0] <= w;\n    }\n    if q.len() == 2 {\n\
    \        return q[0] + q[1] <= w;\n    }\n    let mut i = 0;\n    let mut j =\
    \ q.len() - 1;\n    while i < j {\n        if q[i] != q[j] {\n            return\
    \ false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    return q.iter().sum::<isize>()\
    \ <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpckjt4gu_.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut arr = q.clone();\n    arr.sort();\n    let\
    \ sum = arr.iter().sum::<isize>();\n    if sum <= w {\n        let l = q.len();\n\
    \        let half = l / 2;\n        let left = &q[..half];\n        let right\
    \ = &q[l - half..];\n        left == right\n    } else {\n        false\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let reverse_q = q.clone();\n    let mut reverse_q =\
    \ reverse_q.into_iter().rev().collect::<Vec<isize>>();\n    let mut initial_q\
    \ = q.into_iter().collect::<Vec<isize>>();\n    let mut sum = 0;\n    while !initial_q.is_empty()\
    \ {\n        let mut i = initial_q.pop().unwrap();\n        let mut r = reverse_q.pop().unwrap();\n\
    \        if i != r {\n            return false;\n        }\n        sum += i;\n\
    \    }\n    return sum <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let mut lhs =\
    \ q.clone();\n    let mut rhs = q.clone();\n    lhs.pop();\n    rhs.remove(0);\n\
    \    return sum <= w && (lhs == rhs || q.len() == 1 || will_it_fly(lhs, w) ||\
    \ will_it_fly(rhs, w));\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxc9hb8hw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() % 2 == 0 {\n        return false;\n    }\n\
    \    let sum = q.iter().sum();\n    let mid = q.len() / 2;\n    if q[0..mid] !=\
    \ q[mid+1..].iter().rev().collect::<Vec<&isize>>() {\n        return false;\n\
    \    }\n    if sum <= w {\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpeiwspm9o.rs:16:18\n\
    \   |\n16 |     if q[0..mid] != q[mid+1..].iter().rev().collect::<Vec<&isize>>()\
    \ {\n   |                  ^^ no implementation for `isize == &isize`\n   |\n\
    \   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   =\
    \ note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    let mut length = q.len();\n \
    \   let half = length / 2;\n    for i in 0..half {\n        sum += q[i];\n   \
    \     if sum > w {\n            return false;\n        }\n        sum += q[length\
    \ - i - 1];\n        if sum > w {\n            return false;\n        }\n    }\n\
    \    if sum > w {\n        return false;\n    }\n    if length % 2 == 1 {\n  \
    \      sum += q[half];\n        if sum > w {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa7ic50d8.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut v = q.clone();\n    v.sort();\n    let mut\
    \ balance = true;\n    let mut sum = 0;\n    for i in 0..v.len()/2{\n        if\
    \ v[i] != v[v.len()-1-i]{\n            balance = false;\n            break;\n\
    \        }\n        sum += v[i];\n    }\n    if v.len()%2 == 1{\n        sum +=\
    \ v[v.len()/2];\n    }\n    return balance && sum <= w;\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpjjk6zzw3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_637frvw.rs:11:37\n   |\n11 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mid: usize = q.len() / 2;\n    q[..mid] == q[q.len()\
    \ - 1..mid - 1].iter().rev().collect::<Vec<_>>() &&\n        q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpz416r4j_.rs:12:14\n\
    \   |\n12 |     q[..mid] == q[q.len() - 1..mid - 1].iter().rev().collect::<Vec<_>>()\
    \ &&\n   |              ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    for i in 1..q.len()+1 {\n        if q[..i].iter().sum::<isize>()\
    \ == w {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphk9bnibn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let (mut sum, mut bal) = (0, true);\n    for x in q.iter()\
    \ {\n        sum += x;\n        if sum > w {\n            bal = false;\n     \
    \       break;\n        }\n    }\n    if !is_palindrome(&q) {\n        bal = false;\n\
    \    }\n    bal\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpb7nnr4vf.rs:19:9\n   |\n19 |     if !is_palindrome(&q) {\n   |     \
    \    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut flag = false;\n    let sum = sum_q(&q);\n \
    \   if sum < w {\n        flag = flag || is_palindrome(&q);\n    }\n    flag\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum_q` in this scope\n  --> /tmp/tmp3rge7faf.rs:12:15\n\
    \   |\n12 |     let sum = sum_q(&q);\n   |               ^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_palindrome` in this scope\n\
    \  --> /tmp/tmp3rge7faf.rs:14:24\n   |\n14 |         flag = flag || is_palindrome(&q);\n\
    \   |                        ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut s = 0;\n    for i in &q {\n        s += i;\n\
    \    }\n    if s <= w {\n        if q == q.iter().rev().collect::<Vec<_>>() {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpyop526du.rs:16:14\n\
    \   |\n16 |         if q == q.iter().rev().collect::<Vec<_>>() {\n   |       \
    \       ^^ no implementation for `isize == &isize`\n   |\n   = help: the trait\
    \ `PartialEq<&isize>` is not implemented for `isize`\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // Your code here!\n    if q.len() <= 1 {\n       \
    \ return true;\n    }\n    if q.len() % 2 == 0 {\n        return false;\n    }\n\
    \    let middle = q.len() / 2;\n    if q[0..middle].iter().sum::<isize>() <= w\
    \ && q[middle..q.len() - 1].iter().sum::<isize>() <= w {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc8xgnwzx.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut left: isize = 0;\n    let mut right: isize\
    \ = q.len() as isize - 1;\n    let mut sum: isize = 0;\n    while left <= right\
    \ {\n        sum += q[left as usize];\n        sum += q[right as usize];\n   \
    \     if sum > w {\n            return false;\n        }\n        left += 1;\n\
    \        right -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5fu7mkbq.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    if sum > w {\n\
    \        return false;\n    }\n\n    if let Err(_) = is_palindrome(q) {\n    \
    \    return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpyd64mt16.rs:16:21\n   |\n16 |     if let Err(_) = is_palindrome(q) {\n\
    \   |                     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.reverse();\n \
    \   let s: isize = q.iter().sum();\n    let b = q.iter().rev().eq(q.iter());\n\
    \    if s <= w && b {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0jvntgcc.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return true;\n    }\n  \
    \  let q_sum: isize = q.iter().sum();\n    if q_sum > w {\n        return false;\n\
    \    }\n    let mut q_idx = 0;\n    let mut q_vec = q.clone();\n    q_vec.reverse();\n\
    \    for (q, q_rev) in q.iter().zip(q_vec.iter()) {\n        if q != q_rev {\n\
    \            return false;\n        }\n        q_idx += 1;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let is_palindrome\
    \ = is_palindrome(&q);\n    sum <= w && is_palindrome\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmplrnt8emg.rs:12:25\n   |\n12 |     let is_palindrome = is_palindrome(&q);\n\
    \   |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_637frvw.rs:11:37\n   |\n11 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823210
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum: isize = 0;\n    let mut rev_q: Vec<isize>\
    \ = Vec::new();\n    for elem in q.iter() {\n        sum += elem;\n        rev_q.push(*elem);\n\
    \    }\n    rev_q.reverse();\n    if q != rev_q {\n        return false;\n   \
    \ }\n    if sum <= w {\n        return true;\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let mut elem = q.clone();\n  elem.sort();\n  let mut\
    \ rev_elem = q.clone();\n  rev_elem.sort();\n  rev_elem.reverse();\n  elem ==\
    \ rev_elem && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwa2xh00q.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let len = q.len();\n    if len == 0 {\n        return\
    \ true;\n    }\n    if len == 1 {\n        return q[0] <= w;\n    }\n    let mut\
    \ head = 0;\n    let mut tail = len - 1;\n    while head < tail {\n        if\
    \ q[head] != q[tail] {\n            return false;\n        }\n        head +=\
    \ 1;\n        tail -= 1;\n    }\n    return q.iter().sum::<isize>() <= w;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    if sum <= w &&\
    \ is_balanced(q) {\n        true\n    } else {\n        false\n    }\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpywiwuop1.rs:12:20\n\
    \   |\n12 |     if sum <= w && is_balanced(q) {\n   |                    ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return false;\n    }\n \
    \   if q.len() % 2 == 0 {\n        return false;\n    }\n    let mut left = q.len()\
    \ / 2;\n    let mut right = q.len() / 2;\n    let mut sum = 0;\n    while left\
    \ > 0 {\n        if q[left - 1] != q[right] {\n            return false;\n   \
    \     }\n        sum += q[left - 1] + q[right];\n        left -= 1;\n        right\
    \ += 1;\n    }\n    if sum > w {\n        return false;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgivzhbm8.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let result = (w >= q.iter().sum()) && q.is_palindrome();\n\
    \  println!(\"{}\", result);\n  result\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindrome` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp8v1twc1l.rs:11:43\n   |\n11 |   let result\
    \ = (w >= q.iter().sum()) && q.is_palindrome();\n   |                        \
    \                   ^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // may this be a hint to use a closure? :)\n    let\
    \ balanced = |mut q: Vec<isize>| -> bool {\n        q.reverse();\n        q ==\
    \ q\n    };\n    // can we skip the method-like closure style?\n    let balanced\
    \ = |q: Vec<isize>| q == q.iter().rev().cloned().collect();\n    let balanced\
    \ = |q: Vec<isize>| q == q.iter().rev().collect();\n    let balanced = |q: Vec<isize>|\
    \ q == q.iter().cloned().rev().collect();\n    let balanced = |q: Vec<isize>|\
    \ q == q.iter().rev().map(|x| x).collect();\n    let balanced = |q: Vec<isize>|\
    \ q == q.iter().rev().map(|x| *x).collect();\n    let balanced = |q: Vec<isize>|\
    \ q == q.iter().rev().map(|&x| x).collect();\n    let balanced = |q: Vec<isize>|\
    \ q == q.iter().rev().map(|x| x.clone()).collect();\n    let balanced = |q: Vec<isize>|\
    \ q == q.iter().rev().map(|x| x.to_owned()).collect();\n    let balanced = |q:\
    \ Vec<isize>| q == q.iter().cloned().rev().collect();\n    let balanced = |q:\
    \ Vec<isize>| q == q.iter().rev().collect();\n    let balanced = |q: Vec<isize>|\
    \ q == q.iter().rev().cloned().collect();\n    // but without iterators?\n   \
    \ let balanced = |q: Vec<isize>| q == q.into_iter().rev().collect();\n    let\
    \ balanced = |q: Vec<isize>| q == q.into_iter().rev().cloned().collect();\n  \
    \  let balanced = |q: Vec<isize>| q == q.into_iter().cloned().rev().collect();\n\
    \    let balanced = |q: Vec<isize>| q == q.into_iter().map(|x| x).rev().collect();\n\
    \    let balanced = |q\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `:`, `@`, or `|`, found `}`\n  --> /tmp/tmp_4b0zlz0.rs:34:1\n\
    \   |\n33 |     let balanced = |q\n   |                      - expected one of\
    \ `:`, `@`, or `|`\n34 | }\n   | ^ unexpected token\n\nerror[E0271]: type mismatch\
    \ resolving `<Rev<std::vec::IntoIter<isize>> as Iterator>::Item == &_`\n  -->\
    \ /tmp/tmp_4b0zlz0.rs:30:61\n   |\n30 |     let balanced = |q: Vec<isize>| q ==\
    \ q.into_iter().rev().cloned().collect();\n   |                              \
    \                               ^^^^^^ expected `isize`, found reference\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<Rev<std::vec::IntoIter<isize>>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp_4b0zlz0.rs:30:70\n \
    \  |\n30 |       let balanced = |q: Vec<isize>| q == q.into_iter().rev().cloned().collect();\n\
    \   |                                                                        ^^^^^^^\
    \ method cannot be called on `Cloned<Rev<std::vec::IntoIter<isize>>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Rev<std::vec::IntoIter<isize>> as Iterator>::Item = &_`\n      \
    \     which is required by `Cloned<Rev<std::vec::IntoIter<isize>>>: Iterator`\n\
    \           `Cloned<Rev<std::vec::IntoIter<isize>>>: Iterator`\n           which\
    \ is required by `&mut Cloned<Rev<std::vec::IntoIter<isize>>>: Iterator`\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp_4b0zlz0.rs:31:55\n   |\n31 |     let balanced = |q: Vec<isize>|\
    \ q == q.into_iter().cloned().rev().collect();\n   |                         \
    \                              ^^^^^^ expected `isize`, found reference\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ the method `rev` exists for struct `Cloned<std::vec::IntoIter<isize>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmp_4b0zlz0.rs:31:64\n   |\n\
    31 |       let balanced = |q: Vec<isize>| q == q.into_iter().cloned().rev().collect("
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut sum = 0;\n    for item in q.iter() {\n    \
    \    sum += item;\n    }\n    if sum <= w {\n        if q.len() == 1 {\n     \
    \       return true;\n        }\n        let mut reversed_q = q.clone();\n   \
    \     reversed_q.reverse();\n        if q == reversed_q {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let is_balanced\
    \ = q.iter().rev().eq(q.iter());\n    sum <= w && is_balanced\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let mut items = q.iter();\n  let mut left = 0;\n  let\
    \ mut right = 0;\n  loop {\n    match items.next() {\n      Some(x) => left +=\
    \ x,\n      None => break,\n    }\n    match items.next_back() {\n      Some(x)\
    \ => right += x,\n      None => break,\n    }\n  }\n  left == right && left <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp1iearvgj.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 { return true }\n    let mut sum =\
    \ 0;\n    for v in q.iter() {\n        sum += v;\n    }\n    if sum > w { return\
    \ false }\n    if q != q.iter().rev().cloned().collect::<Vec<isize>>() { return\
    \ false }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    q.iter().sum::<isize>()\
    \ <= w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp67y_hr0y.rs:13:37\n   |\n13 |     q.iter().sum::<isize>() <= w && is_palindrome(&q)\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let mut sum = 0;\n  for v in q.iter() {\n    sum += v;\n\
    \  }\n  if sum > w {\n    return false;\n  }\n  let is_palindrome = match q.len()\
    \ {\n    1 => true,\n    2 => q[0] == q[1],\n    3 => q[0] == q[2],\n    _ =>\
    \ q[0] == q[q.len() - 1] && will_it_fly(q[1..q.len() - 1].to_vec(), w),\n  };\n\
    \  return is_palindrome;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut new_q = q.clone();\n    if new_q.is_empty()\
    \ {\n        return true;\n    }\n    let mut sum = 0;\n    while new_q.len()\
    \ > 1 {\n        let mut first = new_q.remove(0);\n        let last = new_q.pop().unwrap();\n\
    \        if first != last {\n            return false;\n        }\n        sum\
    \ += first + last;\n    }\n    sum += new_q.pop().unwrap();\n    sum <= w\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        return false;\n    }\n\n\
    \    let mut sum = 0;\n    for e in q.iter() {\n        sum += e;\n    }\n\n \
    \   if sum > w {\n        return false;\n    }\n\n    // check if it's a palindrome\n\
    \    let mut i = 0;\n    let mut j = q.len() - 1;\n    while i < j {\n       \
    \ if q[i] != q[j] {\n            return false;\n        }\n        i += 1;\n \
    \       j -= 1;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    return sum <=\
    \ w && q == q.iter().rev().collect::<Vec<isize>>();\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n  --> /tmp/tmpjgpp9gxc.rs:12:44\n   |\n12 |\
    \     return sum <= w && q == q.iter().rev().collect::<Vec<isize>>();\n   |  \
    \                                          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n   |\n   = help: the\
    \ trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let mut front = 0;\n  let mut back = q.len() - 1;\n \
    \ let mut sum = 0;\n  while front < back {\n    if q[front] != q[back] {\n   \
    \   return false;\n    }\n    front += 1;\n    back -= 1;\n  }\n  for n in q {\n\
    \    sum += n;\n  }\n  return sum <= w;\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.is_empty() {\n        return true;\n    }\n  \
    \  if q.len() == 1 {\n        return q[0] <= w;\n    }\n    if q.len() % 2 ==\
    \ 0 {\n        return false;\n    }\n    let n = q.len() / 2;\n    if q[0..n]\
    \ != q[(n + 1)..].iter().rev().collect::<Vec<_>>() {\n        return false;\n\
    \    }\n    q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpwicjgmub.rs:21:16\n\
    \   |\n21 |     if q[0..n] != q[(n + 1)..].iter().rev().collect::<Vec<_>>() {\n\
    \   |                ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<Vec<&isize>>` for `[isize]`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().cloned().sum::<isize>() <= w && q == q.iter().cloned().rev().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    let sum = q.iter().sum::<isize>();\n    q == q_rev && sum <= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut s: isize = 0;\n    for i in q.iter() {\n  \
    \      s += i;\n    }\n    if s <= w {\n        if q.len() % 2 == 0 {\n      \
    \      let mut i = 0;\n            let mut j = q.len() - 1;\n            while\
    \ i < j {\n                if q[i] != q[j] {\n                    return false;\n\
    \                }\n                i += 1;\n                j -= 1;\n       \
    \     }\n            return true;\n        } else {\n            let mut i = 0;\n\
    \            let mut j = q.len() - 1;\n            while i < j {\n           \
    \     if q[i] != q[j] {\n                    return false;\n                }\n\
    \                i += 1;\n                j -= 1;\n            }\n           \
    \ return true;\n        }\n    } else {\n        return false;\n    }\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q1 = q.clone();\n    let mut q2 = q.clone();\n\
    \    q1.sort();\n    q2.sort();\n    q2.reverse();\n    let mut f = 0;\n    if\
    \ q1 == q2 {\n        for i in q {\n            f += i;\n        }\n        if\
    \ f <= w {\n            return true;\n        }\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp19aghgcp.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    // ...\n    if (q.len() % 2) == 0 {\n        return\
    \ false;\n    }\n    let v: Vec<_> = q.iter().zip(q.iter().rev()).collect();\n\
    \    for (a, b) in v {\n        if a != b {\n            return false;\n     \
    \   }\n    }\n    return q.iter().sum::<isize>() <= w;\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    let mut palindrome\
    \ = q.clone();\n    palindrome.reverse();\n    if q == palindrome && sum <= w\
    \ {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.iter().fold(0, |acc, x| acc + x) <= w && is_palindrome(&q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp49ltdiw8.rs:11:48\n   |\n11 |     q.iter().fold(0, |acc, x| acc + x)\
    \ <= w && is_palindrome(&q)\n   |                                            \
    \    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let s = q.iter().sum::<isize>();\n    let mut r = q.clone();\n\
    \    r.reverse();\n    q == r && s <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut res: bool = false;\n    let len: usize = q.len();\n\
    \    let mut weight: isize = 0;\n    for i in 0..len {\n        weight += q[i];\n\
    \    }\n    if weight <= w {\n        let mut half: usize = len / 2;\n       \
    \ let mut k: usize = len - 1;\n        let mut find_palindromic: bool = true;\n\
    \        while half > 0 {\n            if q[half] != q[k] {\n                find_palindromic\
    \ = false;\n                break;\n            }\n            half -= 1;\n  \
    \          k -= 1;\n        }\n        if find_palindromic {\n            res\
    \ = true;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7d5r5w5z.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut iter = q.iter();\n    let mut middle = q.len()\
    \ / 2;\n    let mut i = 0;\n    let mut sum = 0;\n    while i < middle {\n   \
    \     if iter.next() != iter.next_back() {\n            return false;\n      \
    \  }\n        i += 1;\n    }\n    for x in q {\n        sum += x;\n    }\n   \
    \ if sum <= w {\n        return true;\n    }\n    false\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let s = q.iter().sum::<isize>();\n    let mut q2 =\
    \ q.clone();\n    q2.reverse();\n    s <= w && q == q2\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    let is_palindrome\
    \ = q.iter().zip(q.iter().rev()).all(|(a, b)| a == b);\n    is_palindrome && sum\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q = q;\n    q.sort();\n    let mut s = 0;\n\
    \    while !q.is_empty() {\n        s += q.pop().unwrap();\n        if !q.is_empty()\
    \ {\n            let j = q.pop().unwrap();\n            if j != *q.last().unwrap()\
    \ {\n                return false;\n            }\n            s += j;\n     \
    \   }\n    }\n    s <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbjrne8_x.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let w_ = w.clone();\n    if q.len() % 2 == 0 {\n  \
    \      return false;\n    }\n    let mut sum = 0;\n    for i in q.iter() {\n \
    \       sum += i;\n    }\n    if sum <= w_ {\n        return true;\n    }\n  \
    \  false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzn74dfht.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  if q.is_empty() { return true; }\n  if q.len() == 1 {\
    \ return q[0] <= w; }\n  if q.iter().sum::<isize>() > w { return false; }\n  if\
    \ q[0] != q[q.len()-1] { return false; }\n  will_it_fly(q[1..q.len()-1].to_vec(),\
    \ w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpgt30q_7f.rs:11:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659823211
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut i = 0;\n    let mut j = q.len() - 1;\n    let\
    \ mut sum = 0;\n    while i < j {\n        if q[i] != q[j] {\n            return\
    \ false;\n        }\n        sum += q[i];\n        sum += q[j];\n        i +=\
    \ 1;\n        j -= 1;\n    }\n    if q.len() % 2 == 1 {\n        sum += q[i];\n\
    \    }\n    return sum <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum();\n    let mut flag = false;\n\
    \    if q.len() % 2 == 0 {\n        flag = true;\n    }\n    if flag && sum <=\
    \ w {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp1lghpx69.rs:11:9\n\
    \   |\n11 |     let sum = q.iter().sum();\n   |         ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut s: isize = 0;\n    for e in q.iter() {\n  \
    \      s += e;\n    }\n    if s <= w {\n        for (i, e) in q.iter().enumerate()\
    \ {\n            if *e != q[q.len() - i - 1] {\n                return false;\n\
    \            }\n        }\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  let check = |v: Vec<isize>| -> bool {\n    let mut sum\
    \ = 0;\n    for n in v {\n      sum += n;\n    }\n    (sum <= w) && (v == v.iter().rev().collect::<Vec<isize>>())\n\
    \  };\n  check(q) || check(q[1..].to_vec()) || check(q[..q.len()-1].to_vec())\
    \ || check(q[1..q.len()-1].to_vec())\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n  --> /tmp/tmpzjp8xkq_.rs:16:40\n   |\n16 |\
    \     (sum <= w) && (v == v.iter().rev().collect::<Vec<isize>>())\n   |      \
    \                                  ^^^^^^^ value of type `Vec<isize>` cannot be\
    \ built from `std::iter::Iterator<Item=&isize>`\n   |\n   = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() <= 1 {\n        return true;\n    }\n\n\
    \    let mut first = 0;\n    let mut last = q.len() - 1;\n    while first < last\
    \ {\n        if q[first] != q[last] {\n            return false;\n        }\n\
    \        first += 1;\n        last -= 1;\n    }\n\n    return q.iter().sum::<isize>()\
    \ <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut left = 0;\n    let mut right = q.len() - 1;\n\
    \    while left < right {\n        if q[left] != q[right] {\n            return\
    \ false;\n        }\n        left += 1;\n        right -= 1;\n    }\n    return\
    \ q.iter().sum::<isize>() <= w;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let (mut m, mut sum) = (0, 0);\n    for i in q.iter()\
    \ {\n        m = std::cmp::max(m, *i);\n        sum += *i;\n    }\n    if m *\
    \ 2 > sum {\n        false\n    } else {\n        let mut count = 0;\n       \
    \ let mut i = 0;\n        let mut j = q.len() - 1;\n        while i < j {\n  \
    \          if q[i] != q[j] {\n                count += 1;\n            }\n   \
    \         i += 1;\n            j -= 1;\n        }\n        if count > 1 {\n  \
    \          false\n        } else {\n            sum <= w\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9ywwh1pu.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut cargo: Vec<isize> = Vec::new();\n    let mut\
    \ weight: isize = 0;\n    for item in q {\n        cargo.push(item);\n       \
    \ weight += item;\n        if weight > w {\n            cargo.pop();\n       \
    \     break;\n        }\n    }\n    cargo == cargo.iter().rev().collect::<Vec<&isize>>()\
    \ && weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp7kofebu8.rs:21:11\n\
    \   |\n21 |     cargo == cargo.iter().rev().collect::<Vec<&isize>>() && weight\
    \ <= w\n   |           ^^ no implementation for `isize == &isize`\n   |\n   =\
    \ help: the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note:\
    \ required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut tmp = q.clone();\n    let mut sum = 0;\n  \
    \  for i in 0..tmp.len() {\n        sum += tmp[i];\n        tmp[i] = -tmp[i];\n\
    \    }\n    let rev = tmp.iter().cloned().collect::<Vec<isize>>();\n    sum <=\
    \ w && q == rev\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphjjimqx_.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() == 1 && q[0] <= w || is_palindrome(&q) && q.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpv6azzwn8.rs:11:34\n   |\n11 |     q.len() == 1 && q[0] <= w || is_palindrome(&q)\
    \ && q.iter().sum::<isize>() <= w\n   |                                  ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum();\n    sum <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpjh4rl6bu.rs:11:9\n\
    \   |\n11 |     let sum = q.iter().sum();\n   |         ^^^ consider giving `sum`\
    \ a type\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659823212
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let s: isize = q.iter().sum();\n    let l: usize =\
    \ q.len();\n    let m: usize = l/2;\n    if l == 0 { return true; }\n    if l\
    \ == 1 { return q[0] <= w; }\n    if l%2 == 0 {\n        return (s <= w) && (q[..m]\
    \ == q[l-1..m-1].iter().rev().collect::<Vec<_>>());\n    } else {\n        return\
    \ (s <= w) && (q[..m] == q[l-1..m].iter().rev().collect::<Vec<_>>());\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp9oa7rxg9.rs:17:36\n\
    \   |\n17 |         return (s <= w) && (q[..m] == q[l-1..m-1].iter().rev().collect::<Vec<_>>());\n\
    \   |                                    ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp9oa7rxg9.rs:19:36\n\
    \   |\n19 |         return (s <= w) && (q[..m] == q[l-1..m].iter().rev().collect::<Vec<_>>());\n\
    \   |                                    ^^ no implementation for `isize == &isize`\n\
    \   |\n   = help: the trait `PartialEq<&isize>` is not implemented for `isize`\n\
    \   = note: required because of the requirements on the impl of `PartialEq<Vec<&isize>>`\
    \ for `[isize]`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    if q.len() == 0 {\n        true\n    } else {\n   \
    \     q.iter().fold(0, |sum, x| sum + x) <= w && q == q.iter().rev().cloned().collect::<Vec<isize>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum: isize = q.iter().sum();\n    if sum > w {\n\
    \        return false;\n    }\n    let n: usize = q.len();\n    for i in 0..(n\
    \ / 2) {\n        if q[i] != q[n - i - 1] {\n            return false;\n     \
    \   }\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    q.len() == 0 || q.iter().sum::<isize>() <= w && q ==\
    \ q.iter().rev().collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmplpjginp1.rs:11:55\n\
    \   |\n11 |     q.len() == 0 || q.iter().sum::<isize>() <= w && q == q.iter().rev().collect::<Vec<_>>()\n\
    \   |                                                       ^^ no implementation\
    \ for `isize == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not\
    \ implemented for `isize`\n   = note: required because of the requirements on\
    \ the impl of `PartialEq<Vec<&isize>>` for `Vec<isize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let q_len = q.len();\n    if q_len == 0 {\n       \
    \ return true;\n    }\n    if q_len == 1 {\n        return q[0] <= w;\n    }\n\
    \    let mut q_iter = q.iter();\n    let head = q_iter.next().unwrap();\n    let\
    \ tail = q_iter.collect::<Vec<_>>();\n    tail == tail.iter().rev().collect::<Vec<_>>()\
    \ && q.iter().sum::<isize>() <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp_ftqljxg.rs:21:10\n\
    \   |\n21 |     tail == tail.iter().rev().collect::<Vec<_>>() && q.iter().sum::<isize>()\
    \ <= w\n   |          ^^ no implementation for `isize == &isize`\n   |\n   = help:\
    \ the trait `PartialEq<&isize>` is not implemented for `isize`\n   = note: required\
    \ because of the requirements on the impl of `PartialEq<&&isize>` for `&isize`\n\
    \   = note: 1 redundant requirements hidden\n   = note: required because of the\
    \ requirements on the impl of `PartialEq<Vec<&&isize>>` for `Vec<&isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n  return balanced(&q) && q.iter().sum::<isize>() <= w;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `balanced` in this scope\n  --> /tmp/tmpe30emvqg.rs:11:10\n\
    \   |\n11 |   return balanced(&q) && q.iter().sum::<isize>() <= w;\n   |     \
    \     ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let total = q.iter().fold(0, |acc, &x| acc + x);\n\
    \    let reverse = q.iter().rev().fold(Vec::new(), |mut acc, &x| {\n        acc.push(x);\n\
    \        acc\n    });\n    q == reverse && total <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let weight = q.iter().sum::<isize>();\n    weight <=\
    \ w && is_palindrome(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp3elor45n.rs:12:20\n   |\n12 |     weight <= w && is_palindrome(&q)\n\
    \   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 0
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut q_rev = q.clone();\n    q_rev.reverse();\n\
    \    if q == q_rev && q.iter().sum::<isize>() <= w {\n        true\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659823213
- exit_code: 101
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let r: Vec<isize> = q.clone();\n    let sum: isize\
    \ = q.iter().sum();\n    q == r && sum <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpa19692gy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let sum = q.iter().sum::<isize>();\n    if sum <= w\
    \ {\n        let mut check = Vec::new();\n        for i in q.iter() {\n      \
    \      check.push(i);\n        }\n        for i in check.iter().rev() {\n    \
    \        if *i != check.pop().unwrap() {\n                return false;\n    \
    \        }\n        }\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `check` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpohp7kftd.rs:18:22\n   |\n17 |         for i in check.iter().rev()\
    \ {\n   |                  ------------------\n   |                  |\n   | \
    \                 immutable borrow occurs here\n   |                  immutable\
    \ borrow later used here\n18 |             if *i != check.pop().unwrap() {\n \
    \  |                      ^^^^^^^^^^^ mutable borrow occurs here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659823213
- exit_code: 1
  program: "/// Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly([1, 2], 5) \n/// False \n/// #\
    \ 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// # it's\
    \ balanced, but 3+2+3 is more than the maximum possible weight.\n/// # 3+2+3 is\
    \ less than the maximum possible weight, and it's balanced.\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n    let mut n = q.len();\n    let mut sum = 0;\n    for\
    \ x in q {\n        sum += x;\n    }\n    if sum > w {\n        return false;\n\
    \    }\n    let mut k = 0;\n    while k < n / 2 {\n        if q[k] != q[n - k\
    \ - 1] {\n            return false;\n        }\n        k += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpy_gqpdf4.rs:11:9\n\
    \   |\n11 |     let mut n = q.len();\n   |         ----^\n   |         |\n   |\
    \         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by\
    \ default\n\nerror[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpy_gqpdf4.rs:21:12\n\
    \    |\n10  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n13  |     for x in q {\n    |              -\n    | \
    \             |\n    |              `q` moved due to this implicit call to `.into_iter()`\n\
    \    |              help: consider borrowing to avoid moving into the for loop:\
    \ `&q`\n...\n21  |         if q[k] != q[n - k - 1] {\n    |            ^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\n\nerror: aborting due to previous error; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659823213
