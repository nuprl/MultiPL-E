name: HumanEval_120_maximum
language: rs
prompt: "/// Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ Example 2:\n/// Example 3:\n/// Note:\n/// 1. The length of the array will be\
  \ in the range of [1, 1000].\n/// 2. The elements in the array will be in the range\
  \ of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfn maximum(arr: Vec<isize>, k: isize)\
  \ -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = maximum;\n    assert_eq!(candidate(vec![-3,\
  \ -4, 5], 3), vec![-4, -3, 5]);\n    assert_eq!(candidate(vec![4, -4, 4], 2), vec![4,\
  \ 4]);\n    assert_eq!(candidate(vec![-3, 2, 1, 2, -1, -2, 1], 1), vec![2]);\n \
  \   assert_eq!(candidate(vec![123, -123, 20, 0, 1, 2, -3], 3), vec![2, 20, 123]);\n\
  \    assert_eq!(candidate(vec![-123, 20, 0, 1, 2, -3], 4), vec![0, 1, 2, 20]);\n\
  \    assert_eq!(candidate(vec![5, 15, 0, 3, -13, -8, 0], 7), vec![-13, -8, 0, 0,\
  \ 3, 5, 15]);\n    assert_eq!(candidate(vec![-1, 0, 2, 5, 3, -10], 2), vec![3, 5]);\n\
  \    assert_eq!(candidate(vec![1, 0, 5, -7], 1), vec![5]);\n    assert_eq!(candidate(vec![4,\
  \ -4], 2), vec![-4, 4]);\n    assert_eq!(candidate(vec![-10, 10], 2), vec![-10,\
  \ 10]);\n    assert_eq!(candidate(vec![1, 2, 3, -23, 243, -400, 0], 0), Vec::<isize>::new());\n\
  }\n"
completions: ["    let mut res = arr.clone();\n    res.sort();\n    res.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut maxs = Vec::new();\n    for x in\
    \ arr {\n        match maxs.iter().position(|&y| y < x) {\n            Some(i)\
    \ => {\n                maxs.insert(i, x);\n                if maxs.len() > k\
    \ as usize {\n                    maxs.pop();\n                }\n           \
    \ },\n            None => {\n                if maxs.len() < k as usize {\n  \
    \                  maxs.push(x);\n                }\n            },\n        }\n\
    \    }\n    maxs", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    let mut\
    \ result = Vec::new();\n    for _ in 0..k {\n        result.push(arr.pop().unwrap());\n\
    \    }\n    result", "    let mut max_k = Vec::with_capacity(k as usize);\n  \
    \  for &n in arr.iter() {\n        if max_k.len() < k as usize {\n           \
    \ max_k.push(n);\n            max_k.sort();\n        } else if n > max_k[0] {\n\
    \            max_k[0] = n;\n            max_k.sort();\n        }\n    }\n    max_k",
  "    let mut result = Vec::with_capacity(k as usize);\n    for num in arr {\n  \
    \      result.push(num);\n        let last = result.len() - 1;\n        if last\
    \ == 0 {\n            continue;\n        }\n        let mut i = last;\n      \
    \  while i > 0 && result[i] > result[i - 1] {\n            result.swap(i, i -\
    \ 1);\n            i -= 1;\n        }\n        if last >= k as usize {\n     \
    \       result.pop();\n        }\n    }\n    result", "    let mut k = k as usize;\n\
    \    let mut heap = BinaryHeap::new();\n    for &x in arr.iter() {\n        if\
    \ heap.len() < k {\n            heap.push(x);\n        } else if x > *heap.peek().unwrap()\
    \ {\n            heap.pop();\n            heap.push(x);\n        }\n    }\n  \
    \  heap.into_sorted_vec()", "    let k = k as usize;\n    let mut result = vec![0;\
    \ k];\n    let mut min_idx = 0;\n    for (i, &x) in arr.iter().enumerate() {\n\
    \        if i < k {\n            result[i] = x;\n            if result[min_idx]\
    \ > x {\n                min_idx = i;\n            }\n        } else if x > result[min_idx]\
    \ {\n            result[min_idx] = x;\n            min_idx = 0;\n            for\
    \ (j, &y) in result.iter().enumerate() {\n                if y < result[min_idx]\
    \ {\n                    min_idx = j;\n                }\n            }\n    \
    \    }\n    }\n    result", "    let mut heap = BinaryHeap::with_capacity(k as\
    \ usize);\n    let mut ret = Vec::with_capacity(k as usize);\n    for &num in\
    \ arr.iter() {\n        heap.push(num);\n        if heap.len() > k as usize {\n\
    \            heap.pop();\n        }\n    }\n    while !heap.is_empty() {\n   \
    \     ret.push(heap.pop().unwrap());\n    }\n    ret.reverse();\n    ret", " \
    \   let mut result = arr.clone();\n    result.sort();\n    result.reverse();\n\
    \    result.into_iter().take(k as usize).collect()", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n  \
    \  for i in 0..k {\n        result.push(arr[i as usize]);\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut heap = BinaryHeap::<isize>::new();\n\
    \    for &num in arr.iter() {\n        heap.push(num);\n        if heap.len()\
    \ > k as usize {\n            heap.pop();\n        }\n    }\n    let mut res =\
    \ Vec::with_capacity(k as usize);\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let len = arr.len();\n    let mut arr\
    \ = arr;\n    arr.sort();\n    let mut res = Vec::new();\n    for i in (len -\
    \ k as usize)..len {\n        res.push(arr[i]);\n    }\n    res", "    let mut\
    \ heap = BinaryHeap::<isize>::new();\n    for i in 0..k {\n        heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        let top =\
    \ heap.peek_mut().unwrap();\n        if *top < arr[i as usize] {\n           \
    \ *top = arr[i as usize];\n        }\n    }\n    let mut res = Vec::<isize>::new();\n\
    \    for i in 0..k {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n\
    \    res", '    arr.into_iter().rev().take(k as usize).collect()', "    let mut\
    \ result = arr.clone();\n    result.sort();\n    result.iter().rev().take(k as\
    \ usize).cloned().collect()", '    ', "    let mut res = vec![];\n    for &v in\
    \ arr.iter() {\n        if res.len() < k as usize {\n            res.push(v);\n\
    \            if res.len() == k as usize {\n                res.sort();\n     \
    \       }\n        } else {\n            if v > res[0] {\n                res[0]\
    \ = v;\n                res.sort();\n            }\n        }\n    }\n    res",
  "    let mut result = arr.clone();\n    result.sort();\n    result.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut result = arr.clone();\n    result.sort();\n\
    \    result.into_iter().rev().take(k as usize).collect()", "    let mut vec =\
    \ vec![];\n    for i in arr {\n        if vec.len() < k as usize {\n         \
    \   vec.push(i);\n            vec.sort();\n        } else if i > vec[0] {\n  \
    \          vec.remove(0);\n            vec.push(i);\n            vec.sort();\n\
    \        }\n    }\n    vec", "    let len = arr.len();\n    let mut ret = Vec::with_capacity(k\
    \ as usize);\n    let mut heap = BinaryHeap::new();\n    for i in 0..len {\n \
    \       if i < k as usize {\n            heap.push(std::cmp::Reverse(arr[i]));\n\
    \        } else {\n            if arr[i] > *heap.peek().unwrap().0 {\n       \
    \         heap.pop();\n                heap.push(std::cmp::Reverse(arr[i]));\n\
    \            }\n        }\n    }\n    for _ in 0..k {\n        let val = heap.pop().unwrap().0;\n\
    \        ret.push(val);\n    }\n    ret", "    if k == 0 {\n        return vec![];\n\
    \    }\n    let mut result = arr[0..k as usize].to_vec();\n    let mut n = k as\
    \ usize;\n    for i in k as usize..arr.len() {\n        let mut j = i - 1;\n \
    \       while j > 0 && arr[j] < arr[i] {\n            j -= 1;\n        }\n   \
    \     if j < n {\n            result.insert(j, arr[i]);\n            result.pop();\n\
    \        }\n    }\n    result", "    let mut result = Vec::with_capacity(k as\
    \ usize);\n    for i in 0..k {\n        result.push(arr[i as usize]);\n    }\n\
    \    result.sort();\n    for i in k..arr.len() as isize {\n        let mut j =\
    \ k-1;\n        while j >= 0 && arr[i as usize] > result[j as usize] {\n     \
    \       j -= 1;\n        }\n        if j+1 < k {\n            result.remove(k\
    \ as usize);\n            result.insert(j as usize + 1, arr[i as usize]);\n  \
    \      }\n    }\n    result", "    let len = arr.len();\n    if len == 0 {\n \
    \       return vec![];\n    }\n\n    if k > len as isize {\n        return arr;\n\
    \    }\n\n    let mut arr: Vec<_> = arr.into_iter().enumerate().collect();\n \
    \   arr.sort_by_key(|&(_, val)| -val);\n    arr.into_iter().take(k as usize).map(|(_,\
    \ val)| val).collect()", "    let mut heap = arr[..k as usize].to_vec();\n   \
    \ for v in arr[k as usize..].iter() {\n        if *v > heap[0] {\n           \
    \ heap[0] = *v;\n            heap.sort();\n        }\n    }\n    heap", "    if\
    \ k <= 0 {\n        return vec![];\n    }\n    let mut heap = BinaryHeap::new();\n\
    \    let mut r = Vec::new();\n    let mut cnt = 0;\n    for a in arr {\n     \
    \   if cnt < k {\n            heap.push(-a);\n            cnt += 1;\n        }\
    \ else if heap.peek().unwrap() < &(-a) {\n            heap.pop();\n          \
    \  heap.push(-a);\n        }\n    }\n    while !heap.is_empty() {\n        r.push(-heap.pop().unwrap());\n\
    \    }\n    r", "    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().take(k as usize).cloned().collect()", "    let mut q = BinaryHeap::new();\n\
    \    for i in 0..k {\n        q.push((arr[i] * -1, i));\n    }\n    for i in k..arr.len()\
    \ {\n        if arr[i] > q.peek().unwrap().0 * -1 {\n            q.pop();\n  \
    \          q.push((arr[i] * -1, i));\n        }\n    }\n    let mut result = Vec::new();\n\
    \    while !q.is_empty() {\n        result.push(q.pop().unwrap().0 * -1);\n  \
    \  }\n    result.reverse();\n    result", "    let mut heap = BinaryHeap::new();\n\
    \    for v in arr {\n        heap.push(v);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", " \
    \   let mut max_nums = vec![];\n    let mut min_heap = MinHeap::new();\n    for\
    \ num in arr {\n        min_heap.push(num);\n        if max_nums.len() as isize\
    \ < k {\n            max_nums.push(min_heap.pop());\n        }\n    }\n    max_nums",
  "    // build a max heap with arr\n    let mut heap = arr.clone();\n    heap.sort_by(|a,\
    \ b| b.cmp(a));\n    heap.resize(k as usize, 0);\n    heap", "    let mut result\
    \ = Vec::with_capacity(k as usize);\n    let mut curr_max = None;\n    let mut\
    \ curr_max_idx = None;\n    let mut i = arr.len() - 1;\n    while result.len()\
    \ < k as usize {\n        curr_max = None;\n        curr_max_idx = None;\n   \
    \     for j in 0..=i {\n            if let Some(m) = curr_max {\n            \
    \    if arr[j] > m {\n                    curr_max = Some(arr[j]);\n         \
    \           curr_max_idx = Some(j);\n                }\n            } else {\n\
    \                curr_max = Some(arr[j]);\n                curr_max_idx = Some(j);\n\
    \            }\n        }\n        if let Some(m) = curr_max {\n            result.push(m);\n\
    \        }\n        if let Some(midx) = curr_max_idx {\n            i = midx -\
    \ 1;\n        }\n    }\n    result", "    let mut max_heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        max_heap.push(MaxHeapElement { val: arr[i as usize],\
    \ index: i });\n    }\n    for i in k..arr.len() as isize {\n        let top =\
    \ max_heap.peek().unwrap();\n        if arr[i as usize] > top.val {\n        \
    \    max_heap.pop();\n            max_heap.push(MaxHeapElement { val: arr[i as\
    \ usize], index: i });\n        }\n    }\n    let mut result = vec![];\n    while\
    \ !max_heap.is_empty() {\n        result.push(max_heap.pop().unwrap().val);\n\
    \    }\n    result.reverse();\n    result", "    let mut result = vec![];\n  \
    \  let mut indices = arr.iter().enumerate().collect::<Vec<_>>();\n    indices.sort_by_key(|&(_,\
    \ &v)| -v);\n    for i in 0..k {\n        let (_, &v) = indices[i as usize];\n\
    \        result.push(v);\n    }\n    result", "    let mut res = vec![-1001; k\
    \ as usize];\n    let k = k as usize;\n    for num in arr {\n        let i = (0..k).find(|&i|\
    \ res[i] < num).unwrap_or(k);\n        if i == k { continue; }\n        res[i]\
    \ = num;\n        for j in (0..i).rev() {\n            if res[j] > res[j + 1]\
    \ {\n                res.swap(j, j + 1);\n            } else {\n             \
    \   break;\n            }\n        }\n    }\n    res", "    if k < 1 {\n     \
    \   Vec::new()\n    } else {\n        let mut result = arr.clone();\n        let\
    \ l = result.len();\n        result.sort();\n        result.iter().rev().take(k\
    \ as usize).cloned().collect()\n    }", "    let mut max_set = std::collections::BTreeSet::new();\n\
    \    for v in arr {\n        if max_set.len() < k as usize {\n            max_set.insert(v);\n\
    \        } else {\n            let min = *max_set.iter().next().unwrap();\n  \
    \          if v > min {\n                max_set.remove(&min);\n             \
    \   max_set.insert(v);\n            }\n        }\n    }\n    let mut result =\
    \ Vec::new();\n    for v in max_set {\n        result.push(v);\n    }\n    result",
  "    let mut max = arr.iter().max().unwrap();\n    let mut result = Vec::new();\n\
    \    for x in arr {\n        if x < *max {\n            continue;\n        }\n\
    \        if result.is_empty() {\n            result.push(x);\n        } else {\n\
    \            let mut pos = 0;\n            while pos < result.len() && result[pos]\
    \ < x {\n                pos += 1;\n            }\n            result.insert(pos,\
    \ x);\n            if result.len() > k as usize {\n                result.pop();\n\
    \            }\n        }\n        max = result.last().unwrap();\n    }\n    result",
  "    let mut kmax = vec![0; k as usize];\n    let mut kmax_idx = 0;\n    for num\
    \ in arr {\n        if kmax_idx < k as usize {\n            kmax[kmax_idx] = num;\n\
    \            kmax_idx += 1;\n        } else {\n            let mut i = 0;\n  \
    \          while i < kmax_idx && kmax[i] > num {\n                i += 1;\n  \
    \          }\n            if i < kmax_idx {\n                let mut j = kmax_idx\
    \ - 1;\n                while j > i {\n                    kmax[j] = kmax[j -\
    \ 1];\n                    j -= 1;\n                }\n                kmax[i]\
    \ = num;\n            }\n        }\n    }\n    kmax", "    let mut heap = BinaryHeap::new();\n\
    \    for a in arr {\n        heap.push(Reverse(a));\n        if heap.len() > k\
    \ as usize {\n            heap.pop();\n        }\n    }\n    heap.into_sorted_vec().into_iter().map(|Reverse(a)|\
    \ a).collect()", "    let mut result = Vec::with_capacity(k as usize);\n    for\
    \ i in 0..k {\n        let mut max = std::isize::MIN;\n        let mut index =\
    \ 0;\n        for j in 0..arr.len() {\n            if arr[j] > max {\n       \
    \         max = arr[j];\n                index = j;\n            }\n        }\n\
    \        result.push(max);\n        arr[index] = std::isize::MIN;\n    }\n   \
    \ result", "    let mut v = arr;\n    v.sort();\n    v.reverse();\n    v.into_iter().take(k\
    \ as usize).collect()", "    let mut output = vec![];\n    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    sorted.reverse();\n    for i in 0..k {\n        output.push(sorted[i\
    \ as usize]);\n    }\n    output", "    let mut arr = arr;\n    arr.sort();\n\
    \    let len = arr.len();\n    let mut res = vec![];\n    for i in len - k as\
    \ usize..len {\n        res.push(arr[i]);\n    }\n    res", "    let n = arr.len();\n\
    \    let mut heap = Heap::new(Ordering::Greater);\n    for i in 0..k {\n     \
    \   heap.push(arr[i as usize]);\n    }\n    for i in k..n as isize {\n       \
    \ let min = heap.top().unwrap();\n        if arr[i as usize] > min {\n       \
    \     heap.pop();\n            heap.push(arr[i as usize]);\n        }\n    }\n\
    \    heap.into_sorted_vec()", "    let mut max_nums = Vec::with_capacity(k as\
    \ usize);\n    let mut min_heap = BinaryHeap::new();\n    for i in 0..k {\n  \
    \      min_heap.push(arr[i as usize]);\n    }\n    for i in k..arr.len() as isize\
    \ {\n        if arr[i as usize] > min_heap.peek().unwrap() {\n            min_heap.pop();\n\
    \            min_heap.push(arr[i as usize]);\n        }\n    }\n    while !min_heap.is_empty()\
    \ {\n        max_nums.push(min_heap.pop().unwrap());\n    }\n    max_nums.reverse();\n\
    \    max_nums", "    let mut result = Vec::with_capacity(k as usize);\n    for\
    \ _ in 0..k {\n        let x = arr.iter().max().unwrap();\n        result.push(*x);\n\
    \        for v in arr.iter_mut() {\n            if *v == *x {\n              \
    \  *v = -1_000_000_001;\n                break;\n            }\n        }\n  \
    \  }\n    result", "    let mut result = vec![];\n    for x in arr {\n       \
    \ result.push(x);\n        result.sort();\n        if result.len() > k as usize\
    \ {\n            result.remove(0);\n        }\n    }\n    result", "    let mut\
    \ res = Vec::with_capacity(k as usize);\n    let mut n = arr.len();\n    for i\
    \ in 0..n {\n        while !res.is_empty() && n - i + res.len() as isize > k &&\
    \ res[res.len() - 1] < arr[i] {\n            res.pop();\n        }\n        if\
    \ res.len() < k as usize {\n            res.push(arr[i]);\n        }\n    }\n\
    \    res", "    let mut k = k as usize;\n    let mut arr = arr;\n    let mut res\
    \ = Vec::new();\n    while k > 0 {\n        let max = arr.iter().cloned().max().unwrap();\n\
    \        let index = arr.iter().position(|x| x == &max).unwrap();\n        res.push(max);\n\
    \        arr.remove(index);\n        k -= 1;\n    }\n    res", "    let n = arr.len();\n\
    \    let mut v = vec![0isize; k as usize];\n    for i in 0..n {\n        if i\
    \ < k as usize {\n            v[i] = arr[i];\n        } else {\n            let\
    \ mut j = 0;\n            for j in 0..k as usize {\n                if v[j] <=\
    \ arr[i] {\n                    break;\n                }\n            }\n   \
    \         let mut l = k as usize - 1;\n            while l > j {\n           \
    \     v[l] = v[l - 1];\n                l -= 1;\n            }\n            v[j]\
    \ = arr[i];\n        }\n    }\n    v", "    let mut max_heap = BinaryHeap::new();\n\
    \    for num in arr {\n        max_heap.push(num);\n        if max_heap.len()\
    \ > k as usize {\n            max_heap.pop();\n        }\n    }\n    max_heap.into_sorted_vec()",
  "    let mut res = arr[0..k as usize].to_vec();\n    res.sort();\n    let mut i\
    \ = k;\n    while i < arr.len() as isize {\n        if arr[i as usize] > res[0]\
    \ {\n            res.push(arr[i as usize]);\n            res.sort();\n       \
    \     res.remove(0);\n        }\n        i += 1;\n    }\n    res", "    let len\
    \ = arr.len();\n    let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.into_iter().skip(len\
    \ - k as usize).collect()", "    let n = arr.len();\n    let mut h = MaxHeap::new(n);\n\
    \    for x in arr {\n        h.insert(x);\n    }\n    let mut out = Vec::new();\n\
    \    while out.len() < k as usize {\n        out.push(h.max());\n        h.remove_max();\n\
    \    }\n    out", "    if k == 0 {\n        return vec![];\n    }\n    let mut\
    \ arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut indexes = BinaryHeap::new();\n\
    \    for i in 0..k {\n        indexes.push(Index {\n            value: arr[i as\
    \ usize],\n            index: i as usize,\n        });\n    }\n    for i in k..arr.len()\
    \ as isize {\n        if arr[i as usize] > indexes.peek().unwrap().value {\n \
    \           indexes.pop();\n            indexes.push(Index {\n               \
    \ value: arr[i as usize],\n                index: i as usize,\n            });\n\
    \        }\n    }\n    while let Some(index) = indexes.pop() {\n        result.push(index.value);\n\
    \    }\n    result.reverse();\n    result", "    if k >= arr.len() as isize {\n\
    \        return arr;\n    }\n    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut result = Vec::with_capacity(k as\
    \ usize);\n    let mut arr = arr;\n    for _ in 0..k {\n        let mut idx =\
    \ 0;\n        for i in 1..arr.len() {\n            if arr[i] > arr[idx] {\n  \
    \              idx = i;\n            }\n        }\n        result.push(arr[idx]);\n\
    \        arr.remove(idx);\n    }\n    result", '    ', "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let mut end = arr.len();\n    let mut begin = 0;\n    while\
    \ begin < end {\n        let pivot = partition(&mut arr, begin, end);\n      \
    \  if pivot < k {\n            begin = pivot + 1;\n        } else if pivot > k\
    \ {\n            end = pivot;\n        } else {\n            end = pivot;\n  \
    \          break;\n        }\n    }\n    for i in 0..end {\n        result.push(arr[i]);\n\
    \    }\n    result", "    let mut arr = arr;\n    arr.sort();\n    arr.iter().rev().take(k\
    \ as usize).cloned().collect()", "    let mut heap = BinaryHeap::with_capacity(k\
    \ as usize);\n    for &x in arr.iter() {\n        if heap.len() == k as usize\
    \ {\n            heap.push(x);\n            heap.pop();\n        } else {\n  \
    \          heap.push(x);\n        }\n    }\n    heap.into_sorted_vec()", "   \
    \ let mut result = vec![0; k as usize];\n    let mut n = arr.len();\n    let mut\
    \ i = 0;\n    while i < k as usize {\n        let mut j = 0;\n        while j\
    \ < n {\n            if arr[j] > result[i] {\n                result[i] = arr[j];\n\
    \                if j < n - 1 {\n                    arr[j] = arr[n - 1];\n  \
    \              }\n                n -= 1;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    result", "    let mut arr = arr;\n   \
    \ arr.sort();\n    arr.iter().skip(arr.len() - k as usize).cloned().collect()",
  "    let mut min_heap = MinHeap::from_vec(arr);\n    let mut result = Vec::new();\n\
    \    while k > 0 {\n        result.push(min_heap.pop().unwrap());\n        k -=\
    \ 1;\n    }\n    result", "    let mut heap = Vec::with_capacity(k as usize);\n\
    \    for &num in arr.iter() {\n        if heap.len() < k as usize {\n        \
    \    heap.push(num);\n            // println!(\"push {} to heap {:?}\", num, heap);\n\
    \            sift_up(&mut heap, heap.len() - 1);\n        } else if num > heap[0]\
    \ {\n            heap[0] = num;\n            // println!(\"pop {} from heap {:?}\"\
    , num, heap);\n            sift_down(&mut heap, 0);\n        }\n    }\n    heap",
  "    let mut arr = arr;\n    let mut result = Vec::new();\n    for _ in 0..k {\n\
    \        let max = arr.iter().enumerate().max_by_key(|(_, val)| *val).unwrap();\n\
    \        result.push(*max.1);\n        arr.remove(max.0);\n    }\n    result",
  "    let mut m = BinaryHeap::new();\n    for &num in arr.iter() {\n        m.push(num);\n\
    \        if m.len() > k as usize {\n            m.pop();\n        }\n    }\n \
    \   m.into_sorted_vec()", "    let mut heap = MinHeap::from(arr.iter().copied().take(k\
    \ as usize).collect());\n    for x in arr.iter().skip(k as usize) {\n        if\
    \ *x > heap.peek().unwrap() {\n            heap.poll();\n            heap.offer(*x);\n\
    \        }\n    }\n    heap.into_iter().collect()", "    assert!(0 <= k && k <=\
    \ arr.len() as isize);\n    let mut q = BinaryHeap::new();\n    for n in arr {\n\
    \        q.push(n);\n        if q.len() > k as usize {\n            q.pop();\n\
    \        }\n    }\n    let mut res = vec![];\n    while !q.is_empty() {\n    \
    \    res.push(q.pop().unwrap());\n    }\n    res.reverse();\n    res", "    let\
    \ k = k as usize;\n    if k == 0 {\n        return vec![];\n    }\n    let mut\
    \ ans = arr.iter().take(k).cloned().collect::<Vec<_>>();\n    ans.sort();\n  \
    \  for i in k..arr.len() {\n        let mut j = k - 1;\n        while j > 0 &&\
    \ ans[j - 1] < arr[i] {\n            j -= 1;\n        }\n        if j < k - 1\
    \ {\n            ans.remove(j);\n            ans.insert(j, arr[i]);\n        }\n\
    \    }\n    ans", "    if k == 0 {\n        return vec![];\n    }\n    let mut\
    \ min_heap = std::collections::BinaryHeap::with_capacity(k as usize);\n    for\
    \ (i, v) in arr.iter().enumerate() {\n        if i < k as usize {\n          \
    \  min_heap.push(v.clone());\n        } else {\n            let tmp = min_heap.peek().unwrap().clone();\n\
    \            if tmp < *v {\n                min_heap.pop();\n                min_heap.push(v.clone());\n\
    \            }\n        }\n    }\n    let mut ret = vec![];\n    for v in min_heap.into_sorted_vec()\
    \ {\n        ret.push(v);\n    }\n    ret", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.into_iter().take(k as usize).collect()", "    if\
    \ k <= 0 { return vec![]; }\n    let mut arr = arr;\n    let mut k = k as usize;\n\
    \    let mut l = 0;\n    let mut r = arr.len() - 1;\n    while l < r {\n     \
    \   let mut j = partition(&mut arr, l, r);\n        if j == k { break; }\n   \
    \     if j < k {\n            l = j + 1;\n        } else {\n            r = j\
    \ - 1;\n        }\n    }\n    arr[..k].to_vec()", "    let mut arr = arr;\n  \
    \  let k = k as usize;\n    arr.sort();\n    arr.iter().rev().take(k).cloned().collect()",
  "    let mut arr = arr;\n    let mut k = k as usize;\n    let mut result = Vec::new();\n\
    \    while k > 0 {\n        let n = arr.len();\n        if n == k {\n        \
    \    result.append(&mut arr);\n            break;\n        }\n        if n ==\
    \ k + 1 {\n            result.push(arr[0]);\n            arr.remove(0);\n    \
    \        result.append(&mut arr);\n            break;\n        }\n        let\
    \ i = partition(&mut arr);\n        if i == k - 1 {\n            result.append(&mut\
    \ arr[..k].to_vec());\n            break;\n        } else if i > k - 1 {\n   \
    \         arr.truncate(i);\n        } else {\n            k -= i + 1;\n      \
    \      result.append(&mut arr[..i + 1].to_vec());\n            arr.drain(..i +\
    \ 1);\n        }\n    }\n    result", "    let k = k as usize;\n    let arr =\
    \ arr.into_iter().collect::<BinaryHeap<_>>();\n    arr.into_sorted_vec().into_iter().rev().take(k).collect()",
  "    if k <= 0 {\n        return vec![];\n    }\n    let mut arr = arr;\n    arr.sort();\n\
    \    if k as usize >= arr.len() {\n        return arr;\n    }\n    arr.split_off(arr.len()\
    \ - k as usize)", "    if k == 0 {\n        return vec![];\n    }\n    let mut\
    \ max_heap = BinaryHeap::new();\n    for item in arr {\n        max_heap.push(item);\n\
    \        if max_heap.len() > k as usize {\n            max_heap.pop();\n     \
    \   }\n    }\n    max_heap.into_sorted_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    let mut ans = Vec::new();\n    for i in (0..k).rev() {\n        ans.push(arr[i\
    \ as usize]);\n    }\n    ans", "    let k = k as usize;\n    let mut res = Vec::with_capacity(k);\n\
    \    let mut max = isize::min_value();\n    for i in 0..k {\n        let mut max_index\
    \ = 0;\n        for j in 1..arr.len() {\n            if arr[j] > arr[max_index]\
    \ {\n                max_index = j;\n            }\n        }\n        res.push(arr[max_index]);\n\
    \        arr[max_index] = max;\n    }\n    res", "    let k = k as usize;\n  \
    \  if k == 0 {\n        return vec![];\n    }\n    if k == arr.len() {\n     \
    \   return arr;\n    }\n    let mut heap = MaxHeap::with_capacity(k);\n    for\
    \ item in arr {\n        if heap.len() < k {\n            heap.push(item);\n \
    \       } else if item > heap.peek().unwrap() {\n            heap.pop();\n   \
    \         heap.push(item);\n        }\n    }\n    let mut res = vec![];\n    while\
    \ let Some(item) = heap.pop() {\n        res.push(item);\n    }\n    res.reverse();\n\
    \    res", "    let n = arr.len();\n    let k = k as usize;\n    let mut sorted\
    \ = arr.clone();\n    sorted.sort();\n    sorted.into_iter().rev().take(k).collect()",
  "    let mut result = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.reverse();\n    for i in 0..k {\n        result.push(arr[i\
    \ as usize]);\n    }\n    result", '    unimplemented!()', "    //let mut nums\
    \ = arr.clone();\n    //nums.sort();\n    //nums.into_iter().rev().take(k as usize).collect()\n\
    \    let mut ans = Vec::with_capacity(k as usize);\n    for &n in arr.iter() {\n\
    \        if ans.len() < k as usize {\n            ans.push(n);\n            ans.sort();\n\
    \        } else if n > ans[0] {\n            ans[0] = n;\n            ans.sort();\n\
    \        }\n    }\n    ans", "    let mut max_indexes = vec![];\n    let mut max_values\
    \ = vec![];\n    for i in 0..k {\n        max_indexes.push(i);\n        max_values.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        for j in 0..k\
    \ {\n            if arr[i as usize] > max_values[j as usize] {\n             \
    \   max_indexes.insert(j as usize, i);\n                max_values.insert(j as\
    \ usize, arr[i as usize]);\n                max_indexes.pop();\n             \
    \   max_values.pop();\n                break;\n            }\n        }\n    }\n\
    \    let mut sorted_values = vec![];\n    for index in max_indexes {\n       \
    \ sorted_values.push(arr[index as usize]);\n    }\n    sorted_values", "    let\
    \ mut v = vec![];\n    let mut s = Vec::new();\n    let n = arr.len();\n    let\
    \ j = k as usize;\n    if k < 0 || k > n as isize {\n        return v;\n    }\n\
    \    for i in 0..n {\n        if s.len() == 0 {\n            s.push(arr[i]);\n\
    \        } else {\n            while s.len() > 0 && s[s.len() - 1] < arr[i] {\n\
    \                s.pop();\n            }\n            s.push(arr[i]);\n      \
    \  }\n        if s.len() > j {\n            s.remove(0);\n        }\n    }\n \
    \   for i in 0..j {\n        v.push(s[i]);\n    }\n    v", "    let mut arr =\
    \ arr;\n    let mut res = Vec::new();\n    for i in 0..k {\n        let j = (0..arr.len()).max_by_key(|x|\
    \ arr[*x]).unwrap();\n        res.push(arr[j]);\n        arr.remove(j);\n    }\n\
    \    res", "    let mut r = Vec::new();\n    for &v in arr.iter() {\n        if\
    \ r.len() == k as usize {\n            let i = (0..k).filter(|&i| r[i as usize]\
    \ < v).next().unwrap();\n            r.remove(i as usize);\n        }\n      \
    \  r.push(v);\n    }\n    r", "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut sorted = arr.clone();\n    sorted.sort();\n\
    \    sorted.into_iter().rev().take(k as usize).collect()", "    if k == 0 {\n\
    \        return vec![];\n    }\n    if k as usize >= arr.len() {\n        return\
    \ arr;\n    }\n    let mut result = arr[..k as usize].to_vec();\n    result.sort();\n\
    \    for i in k as usize..arr.len() {\n        if result[0] < arr[i] {\n     \
    \       let mut j = 0;\n            while j < k as usize - 1 && result[j + 1]\
    \ < arr[i] {\n                j += 1;\n            }\n            result.remove(j);\n\
    \            result.insert(j, arr[i]);\n        }\n    }\n    result", "    let\
    \ k = k as usize;\n    let mut res = arr.iter().take(k).cloned().collect::<Vec<_>>();\n\
    \    res.sort_unstable();\n    for i in k..arr.len() {\n        if arr[i] > res[0]\
    \ {\n            res[0] = arr[i];\n            res.sort_unstable();\n        }\n\
    \    }\n    res", "    // \u53D6\u6700\u5927\u7684 K \u4E2A\u6570\n    let mut\
    \ ans = arr.clone();\n    ans.sort_unstable_by(|a, b| b.cmp(a));\n    ans.resize(k\
    \ as usize, 0);\n    ans", "    let mut res = Vec::with_capacity(k as usize);\n\
    \    let mut i = 0;\n    while i < k {\n        let mut max = isize::min_value();\n\
    \        let mut j = 0;\n        let mut k = 0;\n        for (idx, val) in arr.iter().enumerate()\
    \ {\n            if idx > res.len() {\n                break;\n            }\n\
    \            if *val > max {\n                max = *val;\n                j =\
    \ idx;\n                k = 1;\n            } else if *val == max {\n        \
    \        k += 1;\n            }\n        }\n        res.push(max);\n        i\
    \ += k;\n    }\n    res", "    let mut res = Vec::with_capacity(k as usize);\n\
    \    for &num in arr.iter() {\n        if res.len() < k as usize {\n         \
    \   // Use binary search to insert num into res.\n            // Use if let to\
    \ handle empty.\n            if let Ok(i) = res.binary_search(&num) {\n      \
    \          res.insert(i, num);\n            } else {\n                let (i,\
    \ _) = res.binary_search_by(|&i| i.cmp(&num).reverse()).unwrap();\n          \
    \      res.insert(i, num);\n            }\n        } else {\n            if let\
    \ Ok(i) = res.binary_search(&num) {\n                res.insert(i, num);\n   \
    \         } else {\n                let (i, _) = res.binary_search_by(|&i| i.cmp(&num).reverse()).unwrap();\n\
    \                if i < k as usize {\n                    res.insert(i, num);\n\
    \                    res.pop();\n                }\n            }\n        }\n\
    \    }\n    res", "    let mut maxes = Vec::new();\n    let mut max_indices =\
    \ Vec::new();\n    let mut next_max_index = 0;\n    // Iterate over each row in\
    \ the array, and keep a track of max\n    // element's indices.\n    for i in\
    \ 0..arr.len() {\n        if arr[i] > arr[next_max_index] {\n            next_max_index\
    \ = i;\n        }\n        max_indices.push(next_max_index);\n    }\n    // Collect\
    \ the first max and reduce number of elements to find.\n    for _ in 0..k {\n\
    \        maxes.push(arr[max_indices[max_indices.len() - 1]]);\n        max_indices.pop();\n\
    \    }\n    // Using the pre-computed `max_indices` array, pick the next max\n\
    \    // values.\n    let mut i = max_indices.len() - 1;\n    while max_indices.len()\
    \ > 0 {\n        // If the maximum value in this row is not already present, then\
    \ pick it.\n        if maxes.len() < k as usize && !maxes.contains(&arr[max_indices[i]])\
    \ {\n            maxes.push(arr[max_indices[i]]);\n        }\n        i -= 1;\n\
    \    }\n    maxes.sort();\n    maxes", "    if k == 0 {\n        return vec![];\n\
    \    }\n    let mut arr = arr;\n    let mut k = k as usize;\n    arr.sort();\n\
    \    arr.reverse();\n    arr.truncate(k);\n    arr", "    if k == arr.len() as\
    \ isize {\n        return arr;\n    }\n    let mut heap = BinaryHeap::new();\n\
    \    for num in arr {\n        heap.push(num);\n        if heap.len() > k as usize\
    \ {\n            heap.pop();\n        }\n    }\n    let mut v = Vec::new();\n\
    \    while let Some(x) = heap.pop() {\n        v.push(x);\n    }\n    v.reverse();\n\
    \    v", "    // 1 \u2264 k \u2264 len(arr)\n    assert!(k > 0 && k <= arr.len()\
    \ as isize);\n    let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut arr = arr;\n    arr.sort();\n    arr.truncate(k\
    \ as usize);\n    arr", "    let mut tmp = arr.clone();\n    tmp.sort();\n   \
    \ tmp.into_iter().rev().take(k as usize).collect()", "    let mut arr = arr;\n\
    \    let mut res = Vec::new();\n    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n\
    \        res.push(*max);\n        arr.remove_item(max);\n    }\n    res", "  \
    \  let mut target = k as usize;\n    let mut stack = Vec::new();\n    for &n in\
    \ arr.iter() {\n        while target > 0 && !stack.is_empty() && stack[stack.len()\
    \ - 1] < n {\n            stack.pop();\n            target -= 1;\n        }\n\
    \        stack.push(n);\n    }\n    stack.truncate(target as usize);\n    stack",
  "    let mut heap = BinaryHeap::new();\n    for &num in arr.iter() {\n        heap.push(Reverse(num));\n\
    \        if heap.len() > k as usize {\n            heap.pop();\n        }\n  \
    \  }\n    heap.into_sorted_vec().into_iter().map(|Reverse(num)| num).collect()",
  "    let mut res = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n   \
    \ for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n        res.push(*max);\n\
    \        arr.remove(arr.iter().position(|&x| x == *max).unwrap());\n    }\n  \
    \  res", "    let (mut min, mut max) = (0, arr.len() - k as usize);\n    let mut\
    \ result = Vec::new();\n    while min <= max {\n        let mid = (min + max)\
    \ / 2;\n        if check(&arr, mid, k as usize) {\n            result = &arr[mid..];\n\
    \            min = mid + 1;\n        } else {\n            max = mid - 1;\n  \
    \      }\n    }\n    result.truncate(k as usize);\n    result", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).map(|&x| x).collect()",
  "    let mut res = arr[0..k as usize].to_vec();\n    res.sort();\n    for i in k\
    \ as usize..arr.len() {\n        for j in 0..k as usize {\n            if arr[i]\
    \ > res[j] {\n                res.remove(j);\n                res.insert(j, arr[i]);\n\
    \                break;\n            }\n        }\n    }\n    res", "    let n\
    \ = arr.len();\n    let mut result = Vec::with_capacity(k as usize);\n    if n\
    \ == 0 {\n        return result;\n    }\n    for i in 0..n {\n        if result.len()\
    \ == 0 {\n            result.push(arr[i]);\n        } else {\n            let\
    \ mut j = result.len() - 1;\n            while j > 0 && result[j - 1] < arr[i]\
    \ {\n                j -= 1;\n            }\n            if j == k as usize {\n\
    \                break;\n            }\n            if j < result.len() {\n  \
    \              result.insert(j, arr[i]);\n                result.pop();\n    \
    \        }\n        }\n    }\n    result", "    let mut arr = arr;\n    arr.sort();\n\
    \    let mut k = k as usize;\n    let n = arr.len();\n    if k > n {\n       \
    \ k = n;\n    }\n    arr[n - k..].to_vec()", "    let mut heap = BinaryHeap::new();\n\
    \    for i in 0..k {\n        heap.push(arr[i as usize]);\n    }\n    for i in\
    \ k..arr.len() as isize {\n        if heap.peek().unwrap() < &arr[i as usize]\
    \ {\n            heap.pop();\n            heap.push(arr[i as usize]);\n      \
    \  }\n    }\n    let mut res = vec![];\n    while !heap.is_empty() {\n       \
    \ res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n    res", "    let\
    \ n = arr.len();\n    let mut result = vec![0; k as usize];\n    let mut max_pos\
    \ = 0;\n    let mut max_val = arr[0];\n    result[0] = max_val;\n    for i in\
    \ 1..k {\n        max_val = std::isize::MIN;\n        for j in (i as usize)..n\
    \ {\n            if arr[j] > max_val {\n                max_val = arr[j];\n  \
    \              max_pos = j;\n            }\n        }\n        result[i as usize]\
    \ = max_val;\n        arr[max_pos] = std::isize::MIN;\n    }\n    result", " \
    \   let n = arr.len();\n    let mut result = vec![0; k as usize];\n    let mut\
    \ i = 0;\n    let mut j = 0;\n    while i < n {\n        while j > 0 && j < k\
    \ as usize && i < n && result[j - 1] < arr[i] {\n            j -= 1;\n       \
    \ }\n        if j < k as usize {\n            result[j] = arr[i];\n          \
    \  j += 1;\n        }\n        i += 1;\n    }\n    result", "    let mut result\
    \ = vec![];\n    for &v in arr.iter() {\n        if result.len() == k as usize\
    \ {\n            if v <= result[0] {\n                continue;\n            }\n\
    \            result.remove(0);\n        }\n        result.push(v);\n        result.sort();\n\
    \    }\n    result", "    let mut a = arr;\n    let mut res = Vec::new();\n  \
    \  a.sort();\n    for i in (0..k).rev() {\n        res.push(a[i as usize]);\n\
    \    }\n    res", "    let n = arr.len();\n    let mut heap = Heap::new(cmp::Ordering::Greater);\n\
    \    for i in 0..cmp::min(n, k as usize) {\n        heap.push(arr[i]);\n    }\n\
    \    for i in k as usize..n {\n        if arr[i] > heap.peek().unwrap() {\n  \
    \          heap.pop();\n            heap.push(arr[i]);\n        }\n    }\n   \
    \ heap.into_sorted_vec()", "    let mut v = arr;\n    let mut i = k - 1;\n   \
    \ while i >= 0 {\n        let mut j = i - 1;\n        while j >= 0 {\n       \
    \     if v[j as usize] > v[(j + 1) as usize] {\n                v.swap(j as usize,\
    \ (j + 1) as usize);\n            }\n            j -= 1;\n        }\n        i\
    \ -= 1;\n    }\n    v[0..k as usize].to_vec()", "    let k = k as usize;\n   \
    \ let mut v = Vec::with_capacity(k);\n    for i in 0..k {\n        v.push(arr[i]);\n\
    \    }\n    v.sort();\n    for i in k..arr.len() {\n        if v[0] < arr[i] {\n\
    \            let mut j = 0;\n            while j < k {\n                if v[j]\
    \ > arr[i] {\n                    j += 1;\n                } else {\n        \
    \            break;\n                }\n            }\n            v.insert(j,\
    \ arr[i]);\n            v.remove(0);\n        }\n    }\n    v", "    if k <= 0\
    \ {\n        return vec![];\n    }\n\n    let mut nums = arr;\n    nums.sort_by(|a,\
    \ b| b.cmp(a));\n    nums.truncate(k as usize);\n    nums", "    let k = k as\
    \ usize;\n    if k >= arr.len() {\n        return arr;\n    }\n    let mut left\
    \ = 0;\n    let mut right = arr.len() - 1;\n    let mut partition = 0;\n    while\
    \ partition != k {\n        let new_partition = partition(arr.as_slice(), left,\
    \ right);\n        if new_partition < k {\n            left = new_partition +\
    \ 1;\n        } else {\n            right = new_partition - 1;\n        }\n  \
    \      partition = new_partition;\n    }\n    return arr[..k].to_vec();", "  \
    \  // let mut min_pq = BinaryHeap::with_capacity(k as usize);\n    // for n in\
    \ arr {\n    //     if min_pq.len() < k as usize {\n    //         min_pq.push(n);\n\
    \    //     } else if let Some(top) = min_pq.peek() {\n    //         if n > *top\
    \ {\n    //             min_pq.pop();\n    //             min_pq.push(n);\n  \
    \  //         }\n    //     }\n    // }\n    // let mut result = min_pq.into_sorted_vec();\n\
    \    // result.reverse();\n    // result\n    let mut result = arr;\n    result.sort();\n\
    \    result.iter().rev().take(k as usize).map(|&n| n).collect()", "    let mut\
    \ result = Vec::with_capacity(k as usize);\n    let mut arr = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    for i in 0..k {\n        result.push(arr[i as usize]);\n\
    \    }\n    result", "    let mut heap = BinaryHeap::new();\n    for &num in arr.iter()\
    \ {\n        heap.push(num);\n        if heap.len() > k as usize {\n         \
    \   heap.pop();\n        }\n    }\n    let mut ans = Vec::new();\n    while let\
    \ Some(num) = heap.pop() {\n        ans.push(num);\n    }\n    ans.reverse();\n\
    \    ans", "    let mut res = Vec::with_capacity(k as usize);\n    let mut arr\
    \ = arr;\n    while res.len() < k as usize {\n        let i = find_max_index(&arr);\n\
    \        res.push(arr[i]);\n        arr.remove(i);\n    }\n    res", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  "    if k == 0 {\n        return vec![];\n    }\n    if k == arr.len() as isize\
    \ {\n        return arr;\n    }\n    let mut result = Vec::with_capacity(k as\
    \ usize);\n    for i in 0..k {\n        result.push(arr[i as usize]);\n    }\n\
    \    result.sort();\n    for i in k..arr.len() as isize {\n        let mut lo\
    \ = 0;\n        let mut hi = result.len() - 1;\n        while lo <= hi {\n   \
    \         let mid = lo + (hi - lo) / 2;\n            if result[mid] == arr[i as\
    \ usize] {\n                lo = mid;\n                break;\n            } else\
    \ if result[mid] < arr[i as usize] {\n                lo = mid + 1;\n        \
    \    } else {\n                hi = mid - 1;\n            }\n        }\n     \
    \   result.insert(lo, arr[i as usize]);\n        result.pop();\n    }\n    result",
  "    let mut heap = BinaryHeap::<isize>::new();\n    for &num in arr.iter() {\n\
    \        heap.push(num);\n        if heap.len() > k as usize {\n            heap.pop();\n\
    \        }\n    }\n    heap.into_sorted_vec()", "    let k = k as usize;\n   \
    \ let mut mh = MinHeap::new(k);\n    for &a in arr.iter() {\n        mh.add(a);\n\
    \    }\n    mh.drain()", "    if k >= arr.len() as isize {\n        return arr;\n\
    \    }\n    let mut pq = std::collections::BinaryHeap::new();\n    for v in arr\
    \ {\n        if pq.len() as isize < k {\n            pq.push(v);\n        } else\
    \ if v > *pq.peek().unwrap() {\n            pq.pop();\n            pq.push(v);\n\
    \        }\n    }\n    let mut ret = Vec::new();\n    while let Some(n) = pq.pop()\
    \ {\n        ret.push(n);\n    }\n    ret.reverse();\n    ret", "    let mut arr\
    \ = arr;\n    let mut heap = BinaryHeap::with_capacity(k as usize);\n    for item\
    \ in arr.drain(..k as usize) {\n        heap.push(item);\n    }\n    for item\
    \ in arr {\n        if item > *heap.peek().unwrap() {\n            heap.pop();\n\
    \            heap.push(item);\n        }\n    }\n    heap.into_sorted_vec()",
  "    let mut max: Vec<isize> = Vec::new();\n    let mut max_index: Vec<usize> =\
    \ Vec::new();\n    let mut min_index: Vec<usize> = Vec::new();\n    let mut arr\
    \ = arr;\n    let len = arr.len();\n    let mut n = k as usize;\n    let mut i\
    \ = 0;\n    while n > 0 {\n        let mut max_i = 0;\n        let mut min_i =\
    \ 0;\n        for j in i..len {\n            if arr[j] > arr[max_i] {\n      \
    \          max_i = j;\n            }\n            if arr[j] < arr[min_i] {\n \
    \               min_i = j;\n            }\n        }\n        if max_i != min_i\
    \ {\n            max.push(arr[max_i]);\n            max_index.push(max_i);\n \
    \           min_index.push(min_i);\n            i = max_i + 1;\n            n\
    \ -= 1;\n        } else {\n            break;\n        }\n    }\n    let min_arr\
    \ = min_index.iter().filter(|&i| *i >= i).collect::<Vec<&usize>>();\n    for i\
    \ in min_arr {\n        max.push(arr[*i]);\n    }\n    return max;", "    if k\
    \ == 0 {\n        return vec![];\n    }\n    let mut pq = BinaryHeap::new();\n\
    \    for x in arr {\n        pq.push(x);\n        if pq.len() > k as usize {\n\
    \            pq.pop();\n        }\n    }\n    let mut res = vec![];\n    while\
    \ let Some(x) = pq.pop() {\n        res.push(x);\n    }\n    res.reverse();\n\
    \    res", "    let mut tmp = arr;\n    tmp.sort();\n    tmp.into_iter().rev().take(k\
    \ as usize).collect()", "    let mut heap = BinaryHeap::new();\n    for (i, x)\
    \ in arr.iter().enumerate() {\n        heap.push((*x, i));\n        if heap.len()\
    \ > k as usize {\n            heap.pop();\n        }\n    }\n    let mut res =\
    \ Vec::new();\n    while let Some((x, _)) = heap.pop() {\n        res.push(x);\n\
    \    }\n    res.reverse();\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.truncate(k as usize);\n    arr", "    let mut result = Vec::with_capacity(k\
    \ as usize);\n    let len = arr.len();\n    for i in 0..len {\n        while !result.is_empty()\
    \ && result.len() as isize + len as isize - i as isize > k &&\n              result[result.len()\
    \ - 1] < arr[i] {\n            result.pop();\n        }\n        if result.len()\
    \ < k as usize {\n            result.push(arr[i]);\n        }\n    }\n    result",
  "    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()",
  '    arr.into_iter().take(k as usize).collect()', "    let mut result = arr[0..k\
    \ as usize].to_vec();\n    result.sort();\n    for i in k..arr.len() as isize\
    \ {\n        let n = arr[i as usize];\n        if n < result[0] {\n          \
    \  continue;\n        }\n        let mut j = 0;\n        while j < k && result[j\
    \ as usize] < n {\n            j += 1;\n        }\n        result.remove(j as\
    \ usize);\n        result.insert(j as usize, n);\n    }\n    result", "    let\
    \ mut res = vec![0; k as usize];\n    for e in arr {\n        if res[0] < e {\n\
    \            res[0] = e;\n            res.sort();\n        }\n    }\n    res",
  "    let mut ret = vec![0; k as usize];\n    let mut st = vec![];\n    for i in\
    \ 0..arr.len() {\n        while st.len() > 0 && arr[st[st.len() - 1] as usize]\
    \ < arr[i] {\n            st.pop();\n        }\n        st.push(i as isize);\n\
    \        if i >= k as usize {\n            while st.len() > 0 && st[0] <= i as\
    \ isize - k {\n                st.remove(0);\n            }\n        }\n     \
    \   if i >= k as usize - 1 {\n            ret[i - (k as usize - 1)] = arr[st[0]\
    \ as usize];\n        }\n    }\n    ret", "    let mut result = vec![];\n    let\
    \ mut max = 0;\n    for i in 0..k {\n        max = 0;\n        for j in 1..(arr.len()\
    \ - i as usize) {\n            if arr[j] > arr[max] {\n                max = j;\n\
    \            }\n        }\n        result.push(arr[max]);\n        arr.swap(max,\
    \ arr.len() - i as usize - 1);\n    }\n    result", '    // TODO', "    let mut\
    \ min_heap = MinHeap::new();\n    for n in arr {\n        min_heap.insert(n);\n\
    \        if min_heap.len() > k as usize {\n            min_heap.remove_min();\n\
    \        }\n    }\n    // reverse order\n    let mut result = vec![];\n    while\
    \ let Some(n) = min_heap.remove_min() {\n        result.push(n);\n    }\n    result.reverse();\n\
    \    result", "    let mut res = arr[0..k as usize].to_vec();\n    res.sort();\n\
    \    for i in k..arr.len() as isize {\n        let mut j = k - 1;\n        while\
    \ j >= 0 && res[j as usize] < arr[i as usize] {\n            res[j as usize] =\
    \ arr[i as usize];\n            j -= 1;\n        }\n    }\n    res", "    let\
    \ mut heap = Heap::new(arr);\n    heap.heap_sort_k(k as usize)", "    let mut\
    \ q = BinaryHeap::new();\n    for &num in arr.iter() {\n        q.push(num);\n\
    \        if q.len() > k as usize {\n            q.pop();\n        }\n    }\n \
    \   q.into_sorted_vec()", "    if k <= 0 {\n        return vec![];\n    }\n  \
    \  let mut heap = BinaryHeap::new();\n    for i in 0..arr.len() {\n        if\
    \ i < k as usize {\n            heap.push(arr[i]);\n        } else {\n       \
    \     if arr[i] > *heap.peek().unwrap() {\n                heap.pop();\n     \
    \           heap.push(arr[i]);\n            }\n        }\n    }\n    let mut result\
    \ = vec![];\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result.reverse();\n    result", "    let mut result = vec![];\n  \
    \  for &x in arr.iter() {\n        let mut left = 0;\n        let mut right =\
    \ result.len();\n        while left < right {\n            let mid = (left + right)\
    \ / 2;\n            if result[mid] >= x {\n                right = mid;\n    \
    \        } else {\n                left = mid + 1;\n            }\n        }\n\
    \        if result.len() < k as usize {\n            result.insert(left, x);\n\
    \        } else if left == k as usize {\n            result.insert(left, x);\n\
    \            result.remove(0);\n        }\n    }\n    result", "    let mut res\
    \ = arr[0..k as usize].to_vec();\n    res.sort();\n    for i in k..arr.len() as\
    \ isize {\n        let mut index = 0;\n        while index < k as usize && res[index]\
    \ < arr[i as usize] {\n            index += 1;\n        }\n        if index <\
    \ k as usize {\n            res.insert(index, arr[i as usize]);\n            res.pop();\n\
    \        }\n    }\n    res", "    let mut heap = BinaryHeap::new();\n    for num\
    \ in arr {\n        heap.push(num);\n        if heap.len() > k as usize {\n  \
    \          heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "    let\
    \ mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().take(k\
    \ as usize).collect()", "    let mut result = Vec::with_capacity(k as usize);\n\
    \    for i in 0..k {\n        let max = arr.iter().max().unwrap();\n        result.push(*max);\n\
    \        arr.retain(|&x| x != *max);\n    }\n    result", "    let k = k as usize;\n\
    \    let mut heap = BinaryHeap::with_capacity(k);\n    for &i in arr.iter() {\n\
    \        if heap.len() == k {\n            if let Some(v) = heap.peek() {\n  \
    \              if *v < i {\n                    heap.pop();\n                \
    \    heap.push(i);\n                }\n            }\n        } else {\n     \
    \       heap.push(i);\n        }\n    }\n    heap.into_sorted_vec()", "    let\
    \ mut res = vec![];\n    for i in 0..k {\n        let mut x = -1000;\n       \
    \ let mut index = -1;\n        for j in 0..arr.len() {\n            if arr[j]\
    \ >= x && !res.contains(&j) {\n                x = arr[j];\n                index\
    \ = j;\n            }\n        }\n        res.push(index);\n    }\n    res.iter().map(|x|\
    \ arr[*x]).collect()", "    let mut heap = BinaryHeap::new();\n    for i in 0..arr.len()\
    \ {\n        if heap.len() < k as usize {\n            heap.push(HeapNode::new(arr[i],\
    \ i));\n        } else {\n            let top = heap.peek_mut().unwrap();\n  \
    \          if top.value < arr[i] {\n                top.value = arr[i];\n    \
    \            top.index = i;\n                heap.pop();\n                heap.push(HeapNode::new(arr[i],\
    \ i));\n            }\n        }\n    }\n    let mut res = Vec::new();\n    while\
    \ let Some(v) = heap.pop() {\n        res.push(v.value);\n    }\n    res.reverse();\n\
    \    res", "    let mut arr = arr;\n    let mut res = Vec::new();\n    let size\
    \ = arr.len();\n    let n = k as usize;\n    if n == 0 {\n        return res;\n\
    \    }\n    if n >= size {\n        return arr.sort_unstable();\n    }\n    //\
    \ create a max-heap with the first k elements\n    for i in (0..n).rev() {\n \
    \       heapify_max(&mut arr, i, n);\n    }\n    // replace the max if necessary\n\
    \    for i in n..size {\n        if arr[i] > arr[0] {\n            arr.swap(0,\
    \ i);\n            heapify_max(&mut arr, 0, n);\n        }\n    }\n    // the\
    \ heap contains the k largest elements\n    for i in (0..n).rev() {\n        res.push(arr[0]);\n\
    \        arr.swap(0, i);\n        heapify_max(&mut arr, 0, i);\n    }\n    res",
  "    // 1. Priority Queue\n    // PriorityQueue::new(|a, b| b.cmp(a))\n    //  \
    \   .iter()\n    //     .take(k as usize)\n    //     .cloned()\n    //     .collect()\n\
    \n    // 2. Slice Sort\n    let mut arr = arr;\n    arr.sort();\n    arr.into_iter().rev().take(k\
    \ as usize).collect()", "    let k = k as usize;\n    assert!(k <= arr.len());\n\
    \    let mut pq = BinaryHeap::new();\n    for v in arr {\n        if pq.len()\
    \ < k {\n            pq.push(v);\n        } else if pq.peek().unwrap() < &v {\n\
    \            pq.pop();\n            pq.push(v);\n        }\n    }\n    pq.into_sorted_vec()",
  "    if k == 0 {\n        return vec![];\n    }\n    let mut res = vec![];\n   \
    \ for i in arr {\n        if res.len() == k as usize {\n            if i > res[0]\
    \ {\n                res.remove(0);\n                res.push(i);\n          \
    \  }\n        } else {\n            res.push(i);\n        }\n        res.sort();\n\
    \    }\n    res", "    let n = arr.len();\n    let mut res = Vec::with_capacity(k\
    \ as usize);\n    for i in 0..k {\n        let mut max = std::isize::MIN;\n  \
    \      let mut max_index = 0;\n        for j in 0..n - i as usize {\n        \
    \    if arr[j] > max {\n                max = arr[j];\n                max_index\
    \ = j;\n            }\n        }\n        res.push(max);\n        arr.swap(max_index,\
    \ n - i as usize - 1);\n    }\n    res", "    let mut result = vec![];\n    let\
    \ mut max_heap = BinaryHeap::<isize>::new();\n    for i in 0..k {\n        max_heap.push(arr[i\
    \ as usize]);\n    }\n    for i in k..arr.len() as isize {\n        if arr[i as\
    \ usize] > max_heap.peek().unwrap() {\n            max_heap.pop();\n         \
    \   max_heap.push(arr[i as usize]);\n        }\n    }\n    for _ in 0..k {\n \
    \       result.push(max_heap.pop().unwrap());\n    }\n    result.reverse();\n\
    \    result", "    let mut heap = BinaryHeap::new();\n    let mut arr = arr;\n\
    \    while arr.len() > k as usize {\n        heap.push(arr.pop().unwrap());\n\
    \    }\n    while let Some(v) = heap.pop() {\n        arr.push(v);\n    }\n  \
    \  arr", "    if k == 0 {\n        return vec![];\n    }\n    let mut arr = arr;\n\
    \    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()", "   \
    \ let mut max = arr.clone();\n    let mut r = Vec::new();\n    for _ in 0..k {\n\
    \        let x = max.pop().unwrap();\n        r.push(x);\n        if max.is_empty()\
    \ {\n            break;\n        }\n    }\n    r.reverse();\n    r", "    if k\
    \ == 0 {\n        return vec![];\n    }\n    let mut result = Vec::with_capacity(k\
    \ as usize);\n    for i in arr {\n        if result.len() < k as usize {\n   \
    \         result.push(i);\n        } else {\n            // bubble sort\n    \
    \        for j in 0..k as usize {\n                if result[j] < i {\n      \
    \              for x in (j..result.len() - 1).rev() {\n                      \
    \  result[x + 1] = result[x];\n                    }\n                    result[j]\
    \ = i;\n                    break;\n                }\n            }\n       \
    \ }\n    }\n    result", "    if k == 0 {\n        return vec![];\n    }\n   \
    \ let mut arr = arr;\n    let heap = Heap::from_slice(&mut arr);\n    let mut\
    \ result = Vec::with_capacity(k as usize);\n    for _ in 0..k {\n        result.push(heap.pop().unwrap());\n\
    \    }\n    result", "    let mut arr = arr;\n    let mut result = Vec::new();\n\
    \    for _ in 0..k {\n        let max = arr.iter().max().unwrap();\n        result.push(*max);\n\
    \        arr.remove_item(max);\n    }\n    result", "    let mut result = arr[0..k\
    \ as usize].to_vec();\n    result.sort();\n    for i in k..arr.len() as isize\
    \ {\n        let mut j = k - 1;\n        while j >= 0 && result[j as usize] <\
    \ arr[i as usize] {\n            j -= 1;\n        }\n        if j < k - 1 {\n\
    \            result.remove(j as usize + 1);\n            result.insert(j as usize\
    \ + 1, arr[i as usize]);\n        }\n    }\n    result", "    let mut arr = arr;\n\
    \    arr.sort();\n    arr.into_iter().rev().take(k as usize).collect()", '    //
    TODO', "    let k = k as usize;\n    let mut arr = arr;\n    arr.sort_unstable();\n\
    \    arr.reverse();\n    arr.into_iter().take(k).collect()", "    let mut arr\
    \ = arr;\n    let mut res = Vec::new();\n    arr.sort();\n    arr.reverse();\n\
    \    for i in 0..k {\n        res.push(arr[i as usize]);\n    }\n    res", " \
    \   // 2-3-4 heap\n    let mut heap = Vec::new();\n    let mut res = Vec::new();\n\
    \    // 1. push the first k elements into the heap\n    for i in 0..k {\n    \
    \    heap.push(arr[i as usize]);\n    }\n    // 2. heapify, build max heap\n \
    \   for i in (0..k / 2).rev() {\n        heapify(i, k, &mut heap);\n    }\n  \
    \  // 3. compare with the remaining elements of arr, and re-heapify.\n    for\
    \ i in k..arr.len() as isize {\n        if arr[i as usize] > heap[0] {\n     \
    \       heap[0] = arr[i as usize];\n            heapify(0, k, &mut heap);\n  \
    \      }\n    }\n    // 4. extract the root\n    while k > 0 {\n        res.push(heap[0]);\n\
    \        // swap the last element of the heap to the root\n        heap[0] = heap[k\
    \ as usize - 1];\n        // heapify\n        heapify(0, k - 1, &mut heap);\n\
    \        k -= 1;\n    }\n    res", "    if k == 0 {\n        return vec![];\n\
    \    }\n    let mut k = k as usize;\n    let mut i = 0;\n    let mut j = 1;\n\
    \    while j < arr.len() {\n        if arr[j] > arr[i] {\n            if i !=\
    \ 0 {\n                arr.swap(i, j);\n            }\n            if j - i >=\
    \ k {\n                i += 1;\n            }\n        }\n        j += 1;\n  \
    \  }\n    arr[0..k].to_vec()", "    let mut res = arr[0..k as usize].to_vec();\n\
    \    res.sort();\n    for i in k as usize..arr.len() {\n        for j in 0..k\
    \ as usize {\n            if arr[i] > res[j] {\n                res.remove(j);\n\
    \                res.insert(j, arr[i]);\n                break;\n            }\n\
    \        }\n    }\n    res", "    let n = arr.len();\n    let mut heap = BinaryHeap::with_capacity(n);\n\
    \    for i in 0..n {\n        heap.push(Reverse(arr[i]));\n        if heap.len()\
    \ > k as usize {\n            heap.pop();\n        }\n    }\n    let mut result\
    \ = Vec::with_capacity(n);\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap().0);\n\
    \    }\n    result.reverse();\n    result", '    // TODO', "    let n = arr.len();\n\
    \    let mut res = vec![0; k as usize];\n    for i in 0..k as usize {\n      \
    \  let mut idx = i;\n        for j in i+1..n {\n            if arr[j] > arr[idx]\
    \ {\n                idx = j;\n            }\n        }\n        res[i] = arr[idx];\n\
    \        arr.swap(i, idx);\n    }\n    res", "    let n = arr.len();\n    let\
    \ mut nums = vec![0; n];\n    for i in 0..n {\n        let val = arr[i];\n   \
    \     nums[i] = (val, val >= 0);\n    }\n    nums.sort_by(|a, b| if a.1 == b.1\
    \ {\n        (b.0).cmp(&a.0)\n    } else {\n        a.1.cmp(&b.1)\n    });\n \
    \   let mut ans = vec![];\n    for i in 0..k {\n        ans.push(nums[i].0);\n\
    \    }\n    ans", "    let mut bh = BinaryHeap::new();\n    for a in arr {\n \
    \       bh.push(a);\n        if bh.len() > k as usize {\n            bh.pop();\n\
    \        }\n    }\n    bh.into_sorted_vec()", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.into_iter().rev().take(k as usize).collect()", "    let n = arr.len();\n\
    \    let k = k as usize;\n    let mut result = arr[..k].to_vec();\n    result.sort();\n\
    \    for i in k..n {\n        let j = result.binary_search(&arr[i]).unwrap_or_else(|x|\
    \ x);\n        if j == 0 {\n            continue;\n        }\n        result.remove(j);\n\
    \        result.insert(j - 1, arr[i]);\n    }\n    result", "    let len = arr.len();\n\
    \    if len == 0 {\n        return vec![];\n    }\n    if k > len as isize {\n\
    \        return arr;\n    }\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().take(k as usize).collect()", "    let mut v = arr;\n    let\
    \ end = v.len() - k as usize;\n    v.sort();\n    v.truncate(end);\n    v", " \
    \   let mut result = arr[0..k as usize].to_vec();\n    for i in k as usize..arr.len()\
    \ {\n        let j = result.iter().position(|&x| x < arr[i]).unwrap();\n     \
    \   result[j] = arr[i];\n    }\n    result.sort();\n    result.reverse();\n  \
    \  result", "    if k >= arr.len() as isize {\n        return arr;\n    }\n  \
    \  let mut res = vec![isize::MIN; k as usize];\n    for num in arr {\n       \
    \ if num > res[0] {\n            let mut i = 0;\n            while i < k - 1 &&\
    \ num > res[i as usize + 1] {\n                res[i as usize] = res[i as usize\
    \ + 1];\n                i += 1;\n            }\n            res[i as usize] =\
    \ num;\n        }\n    }\n    res", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.iter().rev().take(k as usize).map(|x| *x).collect()", "    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.iter().rev().take(k as usize).cloned().collect()",
  "    let n = arr.len();\n    if n <= k as usize {\n        arr.sort();\n       \
    \ return arr;\n    }\n    let mut heap = BinaryHeap::new();\n    for x in arr\
    \ {\n        heap.push(x);\n        if heap.len() > k as usize {\n           \
    \ heap.pop();\n        }\n    }\n    heap.into_sorted_vec()", "    let n = arr.len();\n\
    \    if n == 0 {\n        return vec![];\n    }\n\n    let mut res = vec![];\n\
    \    for i in 0..k {\n        let mut j = n - 1 - i as usize;\n        while j\
    \ > 0 && arr[j - 1] > arr[j] {\n            let tmp = arr[j - 1];\n          \
    \  arr[j - 1] = arr[j];\n            arr[j] = tmp;\n            j -= 1;\n    \
    \    }\n        res.push(arr[j]);\n    }\n    res", "    let k = k as usize;\n\
    \    let mut q = BinaryHeap::new();\n    let mut res = Vec::with_capacity(k);\n\
    \    for i in 0..k {\n        q.push(arr[i]);\n    }\n    for i in k..arr.len()\
    \ {\n        if arr[i] > q.peek().unwrap() {\n            q.pop();\n         \
    \   q.push(arr[i]);\n        }\n    }\n    while !q.is_empty() {\n        res.push(q.pop().unwrap());\n\
    \    }\n    res.reverse();\n    res", "    let mut arr = arr;\n    let len = arr.len();\n\
    \    arr.sort_unstable();\n    let mut res = Vec::with_capacity(k as usize);\n\
    \    for i in (len - k as usize)..len {\n        res.push(arr[i]);\n    }\n  \
    \  res", "    // Counting sort: O(N + K) time, O(N + K) space\n    let n = arr.len();\n\
    \    let mut counts = vec![0isize; 2001];\n    for &x in &arr {\n        counts[x\
    \ as usize + 1000] += 1;\n    }\n    let mut res = Vec::with_capacity(k as usize);\n\
    \    for i in (0..2001).rev() {\n        for _ in 0..counts[i] {\n           \
    \ res.push(i as isize - 1000);\n            if res.len() == k as usize {\n   \
    \             return res;\n            }\n        }\n    }\n    res"]
stop_tokens:
- "\n}"
