language: rs
name: HumanEval_124_valid_date
results:
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    let m: i32 = v[0].parse().unwrap();\n\
    \    let d: i32 = v[1].parse().unwrap();\n    let y: i32 = v[2].parse().unwrap();\n\
    \    let days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if m\
    \ < 1 || m > 12 {\n        return false;\n    }\n    if (y % 4 == 0 && y % 100\
    \ != 0) || y % 400 == 0 {\n        if d < 1 || d > days[m as usize] + 1 {\n  \
    \          return false;\n        }\n    } else {\n        if d < 1 || d > days[m\
    \ as usize] {\n            return false;\n        }\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let date_strs: Vec<_> = date.split(\"-\").collect();\n  \
    \  if date_strs.len() != 3 {\n        return false;\n    }\n    let m = date_strs[0].parse::<u32>().unwrap();\n\
    \    let d = date_strs[1].parse::<u32>().unwrap();\n    let y = date_strs[2].parse::<u32>().unwrap();\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    if d < 1 || d > 31\
    \ {\n        return false;\n    }\n    match m {\n        1 | 3 | 5 | 7 | 8 |\
    \ 10 | 12 => (),\n        4 | 6 | 9 | 11 => {\n            if d > 30 {\n     \
    \           return false;\n            }\n        }\n        2 => {\n        \
    \    if y % 4 == 0 {\n                if d > 29 {\n                    return\
    \ false;\n                }\n            } else {\n                if d > 28 {\n\
    \                    return false;\n                }\n            }\n       \
    \ }\n        _ => (),\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut temp = date.split(\"-\");\n\
    \    match (temp.next(), temp.next(), temp.next()) {\n        (Some(mon), Some(day),\
    \ Some(year)) => {\n            if mon.len() > 2 || day.len() > 2 || year.len()\
    \ > 4 {\n                return false;\n            }\n            let mon: i32\
    \ = match mon.parse() {\n                Ok(v) => v,\n                Err(_) =>\
    \ return false,\n            };\n            let day: i32 = match day.parse()\
    \ {\n                Ok(v) => v,\n                Err(_) => return false,\n  \
    \          };\n            let year: i32 = match year.parse() {\n            \
    \    Ok(v) => v,\n                Err(_) => return false,\n            };\n  \
    \          let leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n\
    \            match mon {\n                1 | 3 | 5 | 7 | 8 | 10 | 12 => day >=\
    \ 1 && day <= 31,\n                4 | 6 | 9 | 11 => day >= 1 && day <= 30,\n\
    \                2 => if leap {\n                    day >= 1 && day <= 29\n \
    \               } else {\n                    day >= 1 && day <= 28\n        \
    \        },\n                _ => false,\n            }\n        }\n        _\
    \ => false,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if !(date.contains(\"-\") && date.len()\
    \ == 10) {\n        return false;\n    }\n    let months = [31, 28, 31, 30, 31,\
    \ 30, 31, 31, 30, 31, 30, 31];\n    let date_s = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    let day = date_s[1].parse::<i32>().unwrap();\n    let month = date_s[0].parse::<i32>().unwrap();\n\
    \    let year = date_s[2].parse::<i32>().unwrap();\n    if year < 0 {\n      \
    \  return false;\n    }\n    if month < 1 || month > 12 {\n        return false;\n\
    \    }\n    if month == 2 && year % 4 == 0 {\n        if day < 1 || day > 29 {\n\
    \            return false;\n        }\n    } else if day < 1 || day > months[(month\
    \ - 1) as usize] {\n        return false;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    match Regex::new(r\"(\\d{2})-(\\d{2})-(\\\
    d{4})\") {\n        Ok(re) => {\n            let caps = re.captures(&date).unwrap();\n\
    \            let month = caps.get(1).unwrap().as_str().parse::<u32>().unwrap();\n\
    \            let day = caps.get(2).unwrap().as_str().parse::<u32>().unwrap();\n\
    \            let year = caps.get(3).unwrap().as_str().parse::<u32>().unwrap();\n\
    \            (day <= 31 && day >= 1) &&\n            (month <= 12 && month >=\
    \ 1) &&\n            (year >= 1) &&\n            ((month == 1 || month == 3 ||\
    \ month == 5 || month == 7 || month == 8 || month == 10 || month == 12) ||\n \
    \           (month == 4 || month == 6 || month == 9 || month == 11 && day <= 30)\
    \ ||\n            (month == 2 && day <= 28))\n        },\n        Err(_) => false\n\
    \    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpea2reh5h.rs:9:11\n\
    \  |\n9 |     match Regex::new(r\"(\\d{2})-(\\d{2})-(\\d{4})\") {\n  |       \
    \    ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut parts = date.split(\"-\");\n    let month: i32\
    \ = parts.next().unwrap().parse().unwrap();\n    let day: i32 = parts.next().unwrap().parse().unwrap();\n\
    \    let year: i32 = parts.next().unwrap().parse().unwrap();\n\n    if (1..13).contains(&month)\
    \ &&\n       (1..32).contains(&day) &&\n       (1..32).contains(&year) {\n   \
    \     return true;\n    }\n\n    false\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9e9n_oek.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^([1-9]|0[1-9]|1[0-2])\\\
    -([1-9]|0[1-9]|[1-2][0-9]|3[0-1])\\-\\d{4}$\").unwrap();\n    if re.is_match(&date)\
    \ {\n        let d_v: Vec<&str> = date.split(\"-\").collect();\n        if d_v[1].parse::<i32>().unwrap()\
    \ > 31 {\n            return false;\n        } else if d_v[1].parse::<i32>().unwrap()\
    \ > 30 && (d_v[0].parse::<i32>().unwrap() == 4 || d_v[0].parse::<i32>().unwrap()\
    \ == 6 || d_v[0].parse::<i32>().unwrap() == 9 || d_v[0].parse::<i32>().unwrap()\
    \ == 11) {\n            return false;\n        } else if d_v[1].parse::<i32>().unwrap()\
    \ > 29 && d_v[0].parse::<i32>().unwrap() == 2 {\n            return false;\n \
    \       } else {\n            return true;\n        }\n    } else {\n        return\
    \ false;\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpj8t2r53m.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^([1-9]|0[1-9]|1[0-2])\\-([1-9]|0[1-9]|[1-2][0-9]|3[0-1])\\\
    -\\d{4}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let splitted: Vec<String> = date.split('-').map(|x|\
    \ x.to_string()).collect();\n    if splitted.len() != 3 {\n        return false;\n\
    \    }\n    let day: usize = splitted[1].parse().unwrap();\n    let month: usize\
    \ = splitted[0].parse().unwrap();\n    let year: usize = splitted[2].parse().unwrap();\n\
    \    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 ||\
    \ month == 10 || month == 12) && (day < 1 || day > 31) {\n        return false;\n\
    \    }\n    if (month == 4 || month == 6 || month == 9 || month == 11) && (day\
    \ < 1 || day > 30) {\n        return false;\n    }\n    if month == 2 && (day\
    \ < 1 || day > 29) {\n        return false;\n    }\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n \
    \   let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() < 2 {\n        return\
    \ false;\n    }\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_split.len() != 3 {\n        return false;\n    }\n    let month:\
    \ i64 = date_split[0].parse().unwrap();\n    let day: i64 = date_split[1].parse().unwrap();\n\
    \    let year: i64 = date_split[2].parse().unwrap();\n    if !(0 < month && month\
    \ < 13) {\n        return false;\n    }\n    if !(0 < year && year < 9999) {\n\
    \        return false;\n    }\n    if !(0 < day && day < 32) {\n        return\
    \ false;\n    }\n    if month == 2 {\n        if year % 4 == 0 {\n           \
    \ if !(0 < day && day < 30) {\n                return false;\n            }\n\
    \        } else {\n            if !(0 < day && day < 29) {\n                return\
    \ false;\n            }\n        }\n    }\n    if month == 4 || month == 6 ||\
    \ month == 9 || month == 11 {\n        if !(0 < day && day < 31) {\n         \
    \   return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // Check if the format is valid\n \
    \   if !date.contains(\"-\") || date.len() < 9 {\n        return false;\n    }\n\
    \n    // Get each of the fields\n    let mut fields = date.split('-');\n    let\
    \ month: i32 = fields.next().unwrap().parse().unwrap();\n    let day: i32 = fields.next().unwrap().parse().unwrap();\n\
    \    let year: i32 = fields.next().unwrap().parse().unwrap();\n\n    // Check\
    \ for valid month\n    if month < 1 || month > 12 {\n        return false;\n \
    \   }\n\n    // Check for valid day\n    match month {\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n                return\
    \ false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n            if\
    \ day < 1 || day > 30 {\n                return false;\n            }\n      \
    \  }\n        2 => {\n            if day < 1 || day > 29 {\n                return\
    \ false;\n            }\n        }\n        _ => {\n            return false;\n\
    \        }\n    }\n\n    // Check for valid year\n    if year < 1 {\n        return\
    \ false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let m: Vec<&str> = date.split('-').collect();\n\
    \    //1\n    if m.len() != 3 {\n        return false;\n    }\n    let m1: Vec<&str>\
    \ = m[1].split_whitespace().collect();\n    let m2: Vec<&str> = m[2].split_whitespace().collect();\n\
    \    //2\n    let mut max_value: i32 = 0;\n    if m1[0] == \"1\" || m1[0] == \"\
    3\" || m1[0] == \"5\" || m1[0] == \"7\" || m1[0] == \"8\" || m1[0] == \"10\" ||\
    \ m1[0] == \"12\" {\n        max_value = 31;\n    } else if m1[0] == \"4\" ||\
    \ m1[0] == \"6\" || m1[0] == \"9\" || m1[0] == \"11\" {\n        max_value = 30;\n\
    \    } else if m1[0] == \"2\" {\n        max_value = 29;\n    } else {\n     \
    \   return false;\n    }\n    if m2[0].parse::<i32>().unwrap() > max_value {\n\
    \        return false;\n    }\n    //3\n    if m1[0].parse::<i32>().unwrap() >\
    \ 12 {\n        return false;\n    }\n    //4\n    if date.len() != 10 {\n   \
    \     return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmporayxu0a.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date = date.as_bytes();\n    if\
    \ date.len() < 10 {\n        return false;\n    }\n    let separator = date[2];\n\
    \    let day = ((date[0] - 48) * 10) + (date[1] - 48);\n    let month = ((date[3]\
    \ - 48) * 10) + (date[4] - 48);\n    let year = ((date[6] - 48) * 1000) + ((date[7]\
    \ - 48) * 100) + ((date[8] - 48) * 10) + (date[9] - 48);\n    if separator !=\
    \ 45 {\n        return false;\n    }\n    if month > 12 || month < 1 {\n     \
    \   return false;\n    }\n    if day > 31 || day < 1 {\n        return false;\n\
    \    }\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {},\n      \
    \  2 => {\n            if day > 29 {\n                return false;\n        \
    \    }\n        },\n        4 | 6 | 9 | 11 => {\n            if day > 30 {\n \
    \               return false;\n            }\n        },\n        _ => {\n   \
    \         return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `year`\n  --> /tmp/tmpuuy2nnoh.rs:16:9\n   |\n\
    16 |     let year = ((date[6] - 48) * 1000) + ((date[7] - 48) * 100) + ((date[8]\
    \ - 48) * 10) + (date[9] - 48);\n   |         ^^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_year`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror: literal out of range for `u8`\n  --> /tmp/tmpuuy2nnoh.rs:16:34\n\
    \   |\n16 |     let year = ((date[6] - 48) * 1000) + ((date[7] - 48) * 100) +\
    \ ((date[8] - 48) * 10) + (date[9] - 48);\n   |                              \
    \    ^^^^\n   |\n   = note: `#[deny(overflowing_literals)]` on by default\n  \
    \ = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let list: Vec<&str> = date.split(\"\
    -\").collect();\n    if list.len() != 3 {\n        return false;\n    }\n    if\
    \ list[0].len() != 2 || list[1].len() != 2 || list[2].len() != 4 {\n        return\
    \ false;\n    }\n    let month: u32 = list[0].parse().unwrap();\n    let day:\
    \ u32 = list[1].parse().unwrap();\n    if (month < 1 || month > 12) || (day <\
    \ 1 || day > 31) {\n        return false;\n    }\n    let invalid_dates: Vec<u32>\
    \ = vec![4, 6, 9, 11];\n    if invalid_dates.contains(&month) && day > 30 {\n\
    \        return false;\n    }\n    if month == 2 && day > 29 {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let v: Vec<_> = date.split('-').collect();\n\
    \    let year = v[2].parse::<u32>().unwrap();\n    let day = v[1].parse::<u32>().unwrap();\n\
    \    let month = v[0].parse::<u32>().unwrap();\n    match month {\n        1 |\
    \ 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n        4 | 6 | 9 | 11 => day <= 30,\n\
    \        2 => year % 4 == 0 && year % 100 != 0 || year % 400 == 0,\n        _\
    \ => false,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp4lma0bj8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let d = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    if d.len() != 3 {\n        return false;\n    }\n    if d[0].len() != 2 ||\
    \ d[1].len() != 2 || d[2].len() != 4 {\n        return false;\n    }\n    let\
    \ m = match d[0].parse::<i32>() {\n        Ok(val) => val,\n        Err(_) =>\
    \ return false,\n    };\n    let d = match d[1].parse::<i32>() {\n        Ok(val)\
    \ => val,\n        Err(_) => return false,\n    };\n    let y = match d[2].parse::<i32>()\
    \ {\n        Ok(val) => val,\n        Err(_) => return false,\n    };\n    if\
    \ m < 1 || m > 12 {\n        return false;\n    }\n    if d < 1 || d > 31 {\n\
    \        return false;\n    }\n    if m == 2 && d > 29 {\n        return false;\n\
    \    }\n    if m == 4 || m == 6 || m == 9 || m == 11 {\n        if d > 30 {\n\
    \            return false;\n        }\n    }\n    if y < 1000 || y > 9999 {\n\
    \        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `i32`\n  --> /tmp/tmpc3sd_ft5.rs:24:19\n\
    \   |\n24 |     let y = match d[2].parse::<i32>() {\n   |                   ^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    //return true if valid and false if\
    \ invalid\n    //check if the string is not empty\n    if date.len() == 0 {\n\
    \        return false;\n    }\n    //split the string into three parts\n    let\
    \ mut parts: Vec<&str> = date.split(\"-\").collect();\n    //check if the parts\
    \ are valid\n    if parts.len() != 3 {\n        return false;\n    }\n    //check\
    \ if the months are valid\n    match parts[0].parse::<u32>() {\n        Ok(v)\
    \ => {\n            if v < 1 || v > 12 {\n                return false;\n    \
    \        }\n        }\n        Err(_) => return false,\n    }\n    //check if\
    \ the days are valid\n    match parts[1].parse::<u32>() {\n        Ok(v) => {\n\
    \            //for the months 1,3,5,7,8,10,12\n            if parts[0] == \"1\"\
    \ || parts[0] == \"3\" || parts[0] == \"5\" || parts[0] == \"7\" || parts[0] ==\
    \ \"8\" || parts[0] == \"10\" || parts[0] == \"12\" {\n                if v <\
    \ 1 || v > 31 {\n                    return false;\n                }\n      \
    \      }\n            //for the months 4,6,9,11\n            else if parts[0]\
    \ == \"4\" || parts[0] == \"6\" || parts[0] == \"9\" || parts[0] == \"11\" {\n\
    \                if v < 1 || v > 30 {\n                    return false;\n   \
    \             }\n            }\n            //for the month 2\n            else\
    \ if parts[0] == \"2\" {\n                if v < 1 || v > 29 {\n             \
    \       return false;\n                }\n            }\n        }\n        Err(_)\
    \ => return false,\n    }\n    //check if the year is valid\n    match parts[2].parse::<u32>()\
    \ {\n        Ok(v) => {\n            if v < 1 {\n                return false;\n\
    \            }\n        }\n        Err(_) => return false,\n    }\n    //if all\
    \ the parts are valid, then return true\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi7ddoumw.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let v: Vec<&str> = date.split('-').collect();\n    if v.len()\
    \ != 3 {\n        return false;\n    }\n\n    let month: i32 = v[0].parse().unwrap();\n\
    \    let day: i32 = v[1].parse().unwrap();\n    let year: i32 = v[2].parse().unwrap();\n\
    \n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if\
    \ day < 1 || day > 31 {\n                return false;\n            }\n      \
    \  }\n        4 | 6 | 9 | 11 => {\n            if day < 1 || day > 30 {\n    \
    \            return false;\n            }\n        }\n        2 => {\n       \
    \     if year % 4 == 0 {\n                if day < 1 || day > 29 {\n         \
    \           return false;\n                }\n            } else {\n         \
    \       if day < 1 || day > 28 {\n                    return false;\n        \
    \        }\n            }\n        }\n        _ => {\n            return false;\n\
    \        }\n    }\n\n    if month < 1 || month > 12 {\n        return false;\n\
    \    }\n\n    if year < 1 {\n        return false;\n    }\n\n    true\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    let mut ds: Vec<&str>\
    \ = v[2].split('.').collect();\n    if ds.len() != 2 {\n        return false;\n\
    \    }\n    let m = match v[0].parse::<i32>() {\n        Ok(m) => m,\n       \
    \ Err(_) => return false,\n    };\n    let d = match v[1].parse::<i32>() {\n \
    \       Ok(d) => d,\n        Err(_) => return false,\n    };\n    let y = match\
    \ ds[0].parse::<i32>() {\n        Ok(y) => y,\n        Err(_) => return false,\n\
    \    };\n    match m {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => if d > 31 || d\
    \ < 1 {\n            return false;\n        },\n        4 | 6 | 9 | 11 => if d\
    \ > 30 || d < 1 {\n            return false;\n        },\n        2 => if d >\
    \ 29 || d < 1 {\n            return false;\n        },\n        _ => return false,\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl63anhww.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_vec: Vec<_> = date.split(\"\
    -\").collect();\n    if date_vec.len() != 3 {\n        return false;\n    }\n\
    \    let day = date_vec[1].parse::<u32>().unwrap();\n    let month = date_vec[0].parse::<u32>().unwrap();\n\
    \    let year = date_vec[2].parse::<u32>().unwrap();\n    if month > 12 || month\
    \ < 1 {\n        return false;\n    }\n    if !(day < 32 && day > 0) {\n     \
    \   return false;\n    }\n    if month == 2 {\n        if is_leap_year(year) {\n\
    \            if day > 29 {\n                return false;\n            }\n   \
    \     } else {\n            if day > 28 {\n                return false;\n   \
    \         }\n        }\n    } else if month == 4 || month == 6 || month == 9 ||\
    \ month == 11 {\n        if day > 30 {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_leap_year` in this scope\n  -->\
    \ /tmp/tmp4zvzg7y3.rs:23:12\n   |\n23 |         if is_leap_year(year) {\n   |\
    \            ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_vec.len() != 3 {\n        return false;\n    }\n\n    let (month,\
    \ day, year) = (date_vec[0].parse::<i32>().unwrap(), date_vec[1].parse::<i32>().unwrap(),\
    \ date_vec[2].parse::<i32>().unwrap());\n    if month < 1 || month > 12 {\n  \
    \      return false;\n    }\n\n    if (month == 2 && (day < 1 || day > 29)) ||\n\
    \        (month % 2 == 0 && month < 8 && (day < 1 || day > 30)) ||\n        (month\
    \ % 2 == 1 && month >= 8 && (day < 1 || day > 30)) ||\n        (month % 2 == 1\
    \ && month < 8 && (day < 1 || day > 31)) ||\n        (month % 2 == 0 && month\
    \ >= 8 && (day < 1 || day > 31)) {\n        return false;\n    }\n\n    if year\
    \ < 0 {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_vec: Vec<&str> = date.split(\"\
    -\").collect();\n    let date_vec: Vec<u32> = date_vec.iter().map(|&x| x.parse::<u32>().unwrap()).collect();\n\
    \    let year = date_vec[2];\n    let month = date_vec[0];\n    let day = date_vec[1];\n\
    \    let date_vec: Vec<u32> = date.split(\"-\").map(|x| x.parse::<u32>().unwrap()).collect();\n\
    \    if date_vec.len() != 3 {\n        return false;\n    }\n    if !is_valid_month(month)\
    \ {\n        return false;\n    }\n    if !is_valid_year(year) {\n        return\
    \ false;\n    }\n    if !is_valid_day(day, month, year) {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_valid_month` in this scope\n  -->\
    \ /tmp/tmp7__cnomw.rs:18:9\n   |\n18 |     if !is_valid_month(month) {\n   | \
    \        ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_valid_year` in this scope\n  --> /tmp/tmp7__cnomw.rs:21:9\n   |\n21 |  \
    \   if !is_valid_year(year) {\n   |         ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_valid_day` in this scope\n  --> /tmp/tmp7__cnomw.rs:24:9\n\
    \   |\n24 |     if !is_valid_day(day, month, year) {\n   |         ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let split: Vec<_> = date.split(\"-\"\
    ).collect();\n    if split.len() != 3 {\n        return false;\n    }\n    let\
    \ day = split[1].parse::<u32>().unwrap();\n    let month = split[0].parse::<u32>().unwrap();\n\
    \    let year = split[2].parse::<u32>().unwrap();\n    match month {\n       \
    \ 1 | 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n        4 | 6 | 9 | 11 => day <=\
    \ 30,\n        2 => {\n            if year % 4 == 0 {\n                day <=\
    \ 29\n            } else {\n                day <= 28\n            }\n       \
    \ }\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpohim_eyd.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date = date.trim();\n    let (mut\
    \ month, mut day, mut year) = (0, 0, 0);\n    let (m, d, y) = date.split('-').collect::<Vec<&str>>();\n\
    \    if m.len() != 2 || d.len() != 2 || y.len() != 4 {\n        return false;\n\
    \    }\n    match (m.parse::<u8>(), d.parse::<u8>(), y.parse::<u32>()) {\n   \
    \     (Ok(month_parsed), Ok(day_parsed), Ok(year_parsed)) => {\n            month\
    \ = month_parsed;\n            day = day_parsed;\n            year = year_parsed;\n\
    \        }\n        _ => {\n            return false;\n        }\n    }\n    if\
    \ !(month > 0 && month < 13) {\n        return false;\n    }\n    let days_in_month\
    \ = match month {\n        2 => {\n            if year % 4 == 0 {\n          \
    \      if year % 100 == 0 {\n                    if year % 400 == 0 {\n      \
    \                  29\n                    } else {\n                        28\n\
    \                    }\n                } else {\n                    29\n   \
    \             }\n            } else {\n                28\n            }\n   \
    \     }\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,\n        _ => 30,\n    };\n\
    \    if !(day > 0 && day <= days_in_month) {\n        return false;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4zhzlf6m.rs:11:9\n   |\n\
    11 |     let (m, d, y) = date.split('-').collect::<Vec<&str>>();\n   |       \
    \  ^^^^^^^^^   -------------------------------------- this expression has type\
    \ `Vec<&str>`\n   |         |\n   |         expected struct `Vec`, found tuple\n\
    \   |\n   = note: expected struct `Vec<&str>`\n               found tuple `(_,\
    \ _, _)`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut split = date.split(\"-\");\n\
    \    let mut valid = true;\n    let dd = split.next().unwrap();\n    let mm =\
    \ split.next().unwrap();\n    let yyyy = split.next().unwrap();\n    let is_leap\
    \ = yyyy.parse::<i32>().unwrap() % 4 == 0;\n    if dd.len() == 0 || mm.len() ==\
    \ 0 || yyyy.len() == 0 {\n        valid = false;\n    }\n    let days = [31, 28,\
    \ 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if mm.parse::<i32>().unwrap()\
    \ < 1 || mm.parse::<i32>().unwrap() > 12 {\n        valid = false;\n    }\n  \
    \  if days[mm.parse::<i32>().unwrap() - 1] < dd.parse::<i32>().unwrap() {\n  \
    \      valid = false;\n    }\n    if mm.parse::<i32>().unwrap() == 2 && !is_leap\
    \ && dd.parse::<i32>().unwrap() > 28 {\n        valid = false;\n    }\n    valid\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[{integer}]` cannot be indexed by `i32`\n  -->\
    \ /tmp/tmpg8s5ab8n.rs:22:8\n   |\n22 |     if days[mm.parse::<i32>().unwrap()\
    \ - 1] < dd.parse::<i32>().unwrap() {\n   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `i32`\n   = note: required\
    \ because of the requirements on the impl of `Index<i32>` for `[{integer}]`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // Check date is not empty\n    if\
    \ date.is_empty() {\n        return false;\n    }\n\n    // Check date has the\
    \ right format\n    let mut parts = date.split(\"-\");\n    let len = parts.clone().count();\n\
    \    if len != 3 {\n        return false;\n    }\n\n    // Check month is valid\n\
    \    let month: usize = parts.next().unwrap().parse().unwrap();\n    if month\
    \ > 12 || month < 1 {\n        return false;\n    }\n\n    // Check day is valid\n\
    \    let day: usize = parts.next().unwrap().parse().unwrap();\n    if day > 31\
    \ || day < 1 {\n        return false;\n    }\n\n    // Check day is valid for\
    \ the month\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n   \
    \         if day > 31 {\n                return false;\n            }\n      \
    \  }\n        4 | 6 | 9 | 11 => {\n            if day > 30 {\n               \
    \ return false;\n            }\n        }\n        2 => {\n            if day\
    \ > 29 {\n                return false;\n            }\n        }\n        _ =>\
    \ return false,\n    }\n\n    // Check year is valid\n    let year: usize = parts.next().unwrap().parse().unwrap();\n\
    \    if year > 9999 || year < 1 {\n        return false;\n    }\n\n    // Check\
    \ day is valid for the month in a leap year\n    if month == 2 && day == 29 {\n\
    \        if !is_leap_year(year) {\n            return false;\n        }\n    }\n\
    \n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_leap_year` in this scope\n  -->\
    \ /tmp/tmpl2ulbiif.rs:61:13\n   |\n61 |         if !is_leap_year(year) {\n   |\
    \             ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut v: Vec<&str> = date.split(\"\
    -\").collect();\n    if v.len() != 3 {\n        return false;\n    }\n    let\
    \ dd = v.pop().unwrap().parse::<i32>().unwrap();\n    let mm = v.pop().unwrap().parse::<i32>().unwrap();\n\
    \    if dd == 0 || mm == 0 {\n        return false;\n    }\n    if dd < 1 || dd\
    \ > 31 {\n        return false;\n    }\n    if mm < 1 || mm > 12 {\n        return\
    \ false;\n    }\n    match mm {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n  \
    \          if dd > 31 {\n                return false;\n            }\n      \
    \  }\n        4 | 6 | 9 | 11 => {\n            if dd > 30 {\n                return\
    \ false;\n            }\n        }\n        2 => {\n            if dd > 29 {\n\
    \                return false;\n            }\n        }\n        _ => panic!(\"\
    Invalid day of month\"),\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp5pg7_g78.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let pattern = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n    if pattern.is_match(&date) {\n        let mut tokens = date.split(\"\
    -\");\n        let mut date_tokens: Vec<&str> = Vec::new();\n        for i in\
    \ tokens {\n            date_tokens.push(i);\n        }\n        let m = date_tokens[0].parse::<u8>().unwrap();\n\
    \        let d = date_tokens[1].parse::<u8>().unwrap();\n        let y = date_tokens[2].parse::<u16>().unwrap();\n\
    \        if m < 1 || m > 12 {\n            return false;\n        }\n        match\
    \ m {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => if d < 1 || d > 31 {\n     \
    \           return false;\n            },\n            4 | 6 | 9 | 11 => if d\
    \ < 1 || d > 30 {\n                return false;\n            },\n           \
    \ 2 => if d < 1 || d > 29 {\n                return false;\n            },\n \
    \           _ => false,\n        }\n        return true;\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpur3xkpul.rs:9:19\n\
    \  |\n9 |     let pattern = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n  |                   ^^^^^ use of undeclared type `Regex`\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmpur3xkpul.rs:32:18\n   |\n\
    22 |           match m {\n   |           ------- `match` arms have incompatible\
    \ types\n23 |               1 | 3 | 5 | 7 | 8 | 10 | 12 => if d < 1 || d > 31\
    \ {\n   |  ____________________________________________-\n24 | |             \
    \    return false;\n25 | |             },\n   | |_____________- this is found\
    \ to be of type `()`\n26 |               4 | 6 | 9 | 11 => if d < 1 || d > 30\
    \ {\n   |  _______________________________-\n27 | |                 return false;\n\
    28 | |             },\n   | |_____________- this is found to be of type `()`\n\
    29 |               2 => if d < 1 || d > 29 {\n   |  __________________-\n30 |\
    \ |                 return false;\n31 | |             },\n   | |_____________-\
    \ this is found to be of type `()`\n32 |               _ => false,\n   |     \
    \               ^^^^^ expected `()`, found `bool`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // month: 1-12\n    // day: 1-31\n\
    \    // year: 4 digit number\n    let mut split_date = date.split(\"-\");\n  \
    \  let month = split_date.next().unwrap();\n    let day = split_date.next().unwrap();\n\
    \    let year = split_date.next().unwrap();\n    if month.len() == 2 && day.len()\
    \ == 2 && year.len() == 4 {\n        let m = month.parse::<u32>().unwrap();\n\
    \        let d = day.parse::<u32>().unwrap();\n        let y = year.parse::<u32>().unwrap();\n\
    \        match m {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n           \
    \     if d > 0 && d <= 31 {\n                    true\n                } else\
    \ {\n                    false\n                }\n            }\n           \
    \ 4 | 6 | 9 | 11 => {\n                if d > 0 && d <= 30 {\n               \
    \     true\n                } else {\n                    false\n            \
    \    }\n            }\n            2 => {\n                if d > 0 && d <= 29\
    \ {\n                    true\n                } else {\n                    false\n\
    \                }\n            }\n            _ => false,\n        }\n    } else\
    \ {\n        false\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpotiimvi0.rs:14:33

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let len = date.len();\n    let date_split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    let date_split_len = date_split.len();\n\
    \    if len == 0 {\n        return false;\n    }\n    if date_split_len != 3 {\n\
    \        return false;\n    }\n    let mm = date_split[0].parse::<i32>().unwrap();\n\
    \    let dd = date_split[1].parse::<i32>().unwrap();\n    let yyyy = date_split[2].parse::<i32>().unwrap();\n\
    \    if mm < 1 || mm > 12 {\n        return false;\n    }\n    if dd < 1 || dd\
    \ > 31 {\n        return false;\n    }\n    if yyyy < 1 {\n        return false;\n\
    \    }\n    if (mm == 1 || mm == 3 || mm == 5 || mm == 7 || mm == 8 || mm == 10\
    \ || mm == 12) && dd > 31 {\n        return false;\n    }\n    if (mm == 4 ||\
    \ mm == 6 || mm == 9 || mm == 11) && dd > 30 {\n        return false;\n    }\n\
    \    if mm == 2 && dd > 29 {\n        return false;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821432
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut mm_dd_yyyy = date.split(\"\
    -\");\n    let mut yyyy = mm_dd_yyyy.next_back().unwrap();\n    let mut dd = mm_dd_yyyy.next_back().unwrap();\n\
    \    let mut mm = mm_dd_yyyy.next_back().unwrap();\n\n    let mut mm_int = mm.parse::<i64>().unwrap();\n\
    \    let mut dd_int = dd.parse::<i64>().unwrap();\n    let mut yyyy_int = yyyy.parse::<i64>().unwrap();\n\
    \n    if mm.len() != 2 || dd.len() != 2 || yyyy.len() != 4 {\n        return false;\n\
    \    }\n    match mm_int {\n        1|3|5|7|8|10|12 => {\n            if dd_int\
    \ < 1 || dd_int > 31 {\n                return false;\n            }\n       \
    \ },\n        4|6|9|11 => {\n            if dd_int < 1 || dd_int > 30 {\n    \
    \            return false;\n            }\n        },\n        2 => {\n      \
    \      if dd_int < 1 || dd_int > 29 {\n                return false;\n       \
    \     }\n        },\n        _ => {\n            return false;\n        }\n  \
    \  }\n    if mm_int < 1 || mm_int > 12 {\n        return false;\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `next_back` exists for struct `std::str::Split<'_,\
    \ &str>`, but its trait bounds were not satisfied\n   --> /tmp/tmpuxbaphdl.rs:10:31\n\
    \    |\n10  |       let mut yyyy = mm_dd_yyyy.next_back().unwrap();\n    |   \
    \                              ^^^^^^^^^ method cannot be called on `std::str::Split<'_,\
    \ &str>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `StrSearcher<'_, '_>: DoubleEndedSearcher<'_>`\n\
    \            which is required by `std::str::Split<'_, &str>: DoubleEndedIterator`\n\
    \nerror[E0599]: the method `next_back` exists for struct `std::str::Split<'_,\
    \ &str>`, but its trait bounds were not satisfied\n   --> /tmp/tmpuxbaphdl.rs:11:29\n\
    \    |\n11  |       let mut dd = mm_dd_yyyy.next_back().unwrap();\n    |     \
    \                          ^^^^^^^^^ method cannot be called on `std::str::Split<'_,\
    \ &str>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `StrSearcher<'_, '_>: DoubleEndedSearcher<'_>`\n\
    \            which is required by `std::str::Split<'_, &str>: DoubleEndedIterator`\n\
    \nerror[E0599]: the method `next_back` exists for struct `std::str::Split<'_,\
    \ &str>`, but its trait bounds were not satisfied\n   --> /tmp/tmpuxbaphdl.rs:12:29\n\
    \    |\n12  |       let mut mm = mm_dd_yyyy.next_back().unwrap();\n    |     \
    \                          ^^^^^^^^^ method cannot be called on `std::str::Split<'_,\
    \ &str>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `StrSearcher<'_, '_>: DoubleEndedSearcher<'_>`\n\
    \            which is required by `std::str::Split<'_, &str>: DoubleEndedIterator`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let parts: Vec<&str> = date.split(\"\
    -\").collect();\n    if parts.len() != 3 {\n        return false;\n    }\n   \
    \ let (month, day, year) = (parts[0].parse::<i32>().unwrap(), parts[1].parse::<i32>().unwrap(),\
    \ parts[2].parse::<i32>().unwrap());\n    match month {\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => day <= 31 && day >= 1,\n        4 | 6 | 9 | 11 => day <= 30\
    \ && day >= 1,\n        2 => day <= 29 && day >= 1,\n        _ => false,\n   \
    \ }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let date_parts: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_parts.len() != 3 {\n        return false;\n    }\n\n    let year\
    \ = date_parts[2].parse::<u32>().unwrap();\n    let month = date_parts[0].parse::<u32>().unwrap();\n\
    \    let day = date_parts[1].parse::<u32>().unwrap();\n\n    if month > 12 ||\
    \ month < 1 {\n        return false;\n    }\n\n    match month {\n        1 |\
    \ 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day > 31 || day < 1 {\n       \
    \         return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n\
    \            if day > 30 || day < 1 {\n                return false;\n       \
    \     }\n        }\n        2 => {\n            if day > 29 || day < 1 {\n   \
    \             return false;\n            }\n        }\n        _ => {}\n    }\n\
    \n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ re: Regex = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n    }\n    re.is_match(&date)\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpczxu4o93.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `re` in this scope\n  --> /tmp/tmpczxu4o93.rs:12:5\n   |\n12 |     re.is_match(&date)\n\
    \   |     ^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821432
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut m: u32 = 0;\n    let mut d:\
    \ u32 = 0;\n    let mut y: u32 = 0;\n    for (index, c) in date.chars().enumerate()\
    \ {\n        if c == '-' {\n            if index == 1 {\n                if date.chars().next().unwrap()\
    \ == '0' {\n                    m = date[1..2].parse::<u32>().unwrap();\n    \
    \            } else {\n                    m = date[0..2].parse::<u32>().unwrap();\n\
    \                }\n            } else if index == 4 {\n                if date.chars().nth(3).unwrap()\
    \ == '0' {\n                    d = date[4..5].parse::<u32>().unwrap();\n    \
    \            } else {\n                    d = date[3..5].parse::<u32>().unwrap();\n\
    \                }\n            }\n        }\n    }\n    y = date[6..10].parse::<u32>().unwrap();\n\
    \    if date.len() == 10 && y > 0 && y < 10000 && m > 0 && m < 13 && d > 0 &&\
    \ d < 32 {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpqel0rhgr.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let tokens: Vec<_> = date.split(\"\
    -\").collect();\n    if tokens.len() != 3 {\n        return false;\n    }\n  \
    \  let month = tokens[0].parse::<i32>().unwrap();\n    let day = tokens[1].parse::<i32>().unwrap();\n\
    \    let year = tokens[2].parse::<i32>().unwrap();\n    let mut is_valid = true;\n\
    \    if year == 0 {\n        is_valid = false;\n    }\n    if month == 0 || month\
    \ > 12 {\n        is_valid = false;\n    }\n    if (month == 1 || month == 3 ||\
    \ month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && (day\
    \ == 0 || day > 31) {\n        is_valid = false;\n    }\n    if (month == 4 ||\
    \ month == 6 || month == 9 || month == 11) && (day == 0 || day > 30) {\n     \
    \   is_valid = false;\n    }\n    if month == 2 && year % 4 == 0 && (day == 0\
    \ || day > 29) {\n        is_valid = false;\n    }\n    if month == 2 && year\
    \ % 4 != 0 && (day == 0 || day > 28) {\n        is_valid = false;\n    }\n   \
    \ is_valid\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_split.len() != 3 {\n        return false;\n    }\n    let (m, d,\
    \ y) = (date_split[0].parse::<i32>().unwrap(), date_split[1].parse::<i32>().unwrap(),\
    \ date_split[2].parse::<i32>().unwrap());\n    if m > 12 || m < 1 {\n        return\
    \ false;\n    }\n    if d > 31 || d < 1 {\n        return false;\n    }\n    if\
    \ m == 2 && d > 29 {\n        return false;\n    }\n    if (m % 2 == 0) && m <\
    \ 8 && d > 30 {\n        return false;\n    }\n    if (m % 2 == 0) && m > 7 &&\
    \ d > 31 {\n        return false;\n    }\n    if (m % 2 != 0) && m < 7 && d >\
    \ 31 {\n        return false;\n    }\n    if (m % 2 != 0) && m > 7 && d > 30 {\n\
    \        return false;\n    }\n    if y < 0 {\n        return false;\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() != 10 {\n        return\
    \ false;\n    }\n    let months: Vec<i32> = date\n        .split('-')\n      \
    \  .map(|c| c.parse::<i32>().unwrap())\n        .collect();\n    if !date.contains('-')\
    \ || months.len() != 3 {\n        return false;\n    }\n    let day = months[1];\n\
    \    let month = months[0];\n    let year = months[2];\n    if year < 0 {\n  \
    \      return false;\n    }\n    if month < 1 || month > 12 {\n        return\
    \ false;\n    }\n    if day < 1 || day > 31 {\n        return false;\n    }\n\
    \    if (month == 4 || month == 6 || month == 9 || month == 11) && day > 30 {\n\
    \        return false;\n    }\n    if month == 2 && day > 29 {\n        return\
    \ false;\n    }\n    if month == 2 && day == 29 && !is_leap_year(year) {\n   \
    \     return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_leap_year` in this scope\n  -->\
    \ /tmp/tmpkua2m40o.rs:37:36\n   |\n37 |     if month == 2 && day == 29 && !is_leap_year(year)\
    \ {\n   |                                    ^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let d = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    if d.len() != 3 {\n        return false;\n    }\n    if let (Ok(m), Ok(d),\
    \ Ok(y)) = (d[0].parse::<u8>(), d[1].parse::<u8>(), d[2].parse::<u16>()) {\n \
    \       let m_ok = (1..=12).contains(&m);\n        let d_ok = match m {\n    \
    \        2 => (1..=29).contains(&d),\n            1 | 3 | 5 | 7 | 8 | 10 | 12\
    \ => (1..=31).contains(&d),\n            _ => (1..=30).contains(&d),\n       \
    \ };\n        let y_ok = y >= 1583;\n        if m_ok && d_ok && y_ok {\n     \
    \       return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let values: Vec<&str> = date.split(\"-\").collect();\n\
    \    if values.len() != 3 {\n        return false;\n    }\n\n    let m: u32 =\
    \ values[0].parse().unwrap();\n    let d: u32 = values[1].parse().unwrap();\n\
    \    let y: u32 = values[2].parse().unwrap();\n\n    if m > 12 || d > 31 || y\
    \ > 9999 {\n        return false;\n    }\n\n    match m {\n        2 => {\n  \
    \          if d > 29 {\n                return false;\n            }\n       \
    \ }\n        4 | 6 | 9 | 11 => {\n            if d > 30 {\n                return\
    \ false;\n            }\n        }\n        _ => {}\n    }\n\n    return true;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp14k4rsn3.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ RE: Regex = Regex::new(r\"^([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n    }\n    RE.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpfbo57zrd.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpfbo57zrd.rs:12:5\n   |\n12 |     RE.is_match(&date)\n\
    \   |     ^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    if !valid_format(date.as_str()) {\n        return false;\n\
    \    }\n\n    let mut split = date.split(\"-\");\n    let month = split.next().unwrap().parse::<i32>().unwrap();\n\
    \    let day = split.next().unwrap().parse::<i32>().unwrap();\n    let year =\
    \ split.next().unwrap().parse::<i32>().unwrap();\n\n    if month > 12 || month\
    \ < 1 {\n        return false;\n    }\n\n    if month == 2 {\n        if year\
    \ % 4 == 0 {\n            if day > 29 || day < 1 {\n                return false;\n\
    \            }\n        } else {\n            if day > 28 || day < 1 {\n     \
    \           return false;\n            }\n        }\n    } else if month == 4\
    \ || month == 6 || month == 9 || month == 11 {\n        if day > 30 || day < 1\
    \ {\n            return false;\n        }\n    } else {\n        if day > 31 ||\
    \ day < 1 {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `valid_format` in this scope\n  -->\
    \ /tmp/tmprvu2dn1d.rs:13:9\n   |\n13 |     if !valid_format(date.as_str()) {\n\
    \   |         ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ RE: Regex = Regex::new(r\"(?:(?<month>0[1-9]|1[0-2])-(?<day>0[1-9]|[12][0-9]|3[01])-(?<year>\\\
    d{4}))\").unwrap();\n    }\n    if RE.is_match(&date) {\n        let caps = RE.captures(&date).unwrap();\n\
    \        let month = caps.name(\"month\").unwrap().as_str().parse::<i64>().unwrap();\n\
    \        let day = caps.name(\"day\").unwrap().as_str().parse::<i64>().unwrap();\n\
    \        let year = caps.name(\"year\").unwrap().as_str().parse::<i64>().unwrap();\n\
    \        if year >= 0 {\n            if month >= 1 && month <= 12 {\n        \
    \        if (month == 1 || month == 3 || month == 5 || month == 7 || month ==\
    \ 8 || month == 10 || month == 12) && day >= 1 && day <= 31 {\n              \
    \      return true;\n                } else if (month == 4 || month == 6 || month\
    \ == 9 || month == 11) && day >= 1 && day <= 30 {\n                    return\
    \ true;\n                } else if month == 2 && day >= 1 && day <= 29 {\n   \
    \                 return true;\n                }\n            }\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpt36_r144.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpt36_r144.rs:12:8\n   |\n12 |     if\
    \ RE.is_match(&date) {\n   |        ^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `RE` in this scope\n  --> /tmp/tmpt36_r144.rs:13:20\n   |\n\
    13 |         let caps = RE.captures(&date).unwrap();\n   |                   \
    \ ^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date = date.trim().to_string();\n\
    \    if date.is_empty() {\n        return false;\n    }\n    let split_date: Vec<&str>\
    \ = date.split(\"-\").collect();\n    if split_date.len() != 3 {\n        return\
    \ false;\n    }\n    let mut month: u32 = split_date[0].parse().unwrap();\n  \
    \  let mut day: u32 = split_date[1].parse().unwrap();\n    let mut year: u32 =\
    \ split_date[2].parse().unwrap();\n    if month < 1 || month > 12 {\n        return\
    \ false;\n    }\n    if year < 1 {\n        return false;\n    }\n    if day <\
    \ 1 {\n        return false;\n    }\n    match month {\n        1 | 3 | 5 | 7\
    \ | 8 | 10 | 12 => {\n            if day > 31 {\n                return false;\n\
    \            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day > 30\
    \ {\n                return false;\n            }\n        }\n        2 => {\n\
    \            if day > 29 {\n                return false;\n            }\n   \
    \     }\n        _ => {}\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut days_of_month = vec![31, 0,\
    \ 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut date_list: Vec<&str> =\
    \ date.split(\"-\").collect();\n    if date_list.len() != 3 {\n        return\
    \ false;\n    }\n    let month = date_list[0].parse::<i32>().unwrap();\n    let\
    \ days = date_list[1].parse::<i32>().unwrap();\n    let year = date_list[2].parse::<i32>().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if year <\
    \ 1 {\n        return false;\n    }\n    if month == 2 {\n        if year % 4\
    \ == 0 {\n            days_of_month[1] = 29;\n        } else {\n            days_of_month[1]\
    \ = 28;\n        }\n    }\n    if days < 1 || days > days_of_month[(month - 1)\
    \ as usize] {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    use regex::Regex;\n    let regex =\
    \ Regex::new(r\"^([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[1-2][0-9]|3[0-1])-\\d{4}$\"\
    ).unwrap();\n    regex.is_match(&date)\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `regex`\n --> /tmp/tmp7stle7or.rs:9:9\n\
    \  |\n9 |     use regex::Regex;\n  |         ^^^^^ maybe a missing crate `regex`?\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let vec: Vec<&str> = date.split(\"\
    -\").collect();\n    if vec.len() != 3 {\n        return false;\n    }\n    let\
    \ day = match vec[1].parse::<u32>() {\n        Ok(day) => day,\n        Err(_)\
    \ => return false,\n    };\n    let month = match vec[0].parse::<u32>() {\n  \
    \      Ok(month) => month,\n        Err(_) => return false,\n    };\n    let year\
    \ = match vec[2].parse::<u32>() {\n        Ok(year) => year,\n        Err(_) =>\
    \ return false,\n    };\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12\
    \ => {\n            if day >= 1 && day <= 31 {\n                return true;\n\
    \            }\n        }\n        4 | 6 | 9 | 11 => {\n            if day >=\
    \ 1 && day <= 30 {\n                return true;\n            }\n        }\n \
    \       2 => {\n            if day >= 1 && day <= 29 {\n                return\
    \ true;\n            }\n        }\n        _ => {}\n    }\n    false\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_split: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_split.len() != 3 {\n        return false;\n    }\n\
    \    let months: Vec<&str> = vec![\"\", \"01\", \"02\", \"03\", \"04\", \"05\"\
    , \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"];\n    if months.contains(&date_split[0])\
    \ == false {\n        return false;\n    }\n    if date_split[0] == \"02\" {\n\
    \        if date_split[1].parse::<u32>().unwrap() > 29 {\n            return false;\n\
    \        }\n    } else if date_split[0] == \"04\" || date_split[0] == \"06\" ||\
    \ date_split[0] == \"09\" || date_split[0] == \"11\" {\n        if date_split[1].parse::<u32>().unwrap()\
    \ > 30 {\n            return false;\n        }\n    } else {\n        if date_split[1].parse::<u32>().unwrap()\
    \ > 31 {\n            return false;\n        }\n    }\n    if date_split[2].parse::<u32>().unwrap()\
    \ < 1000 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp78_4z781.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let days = vec![31, 29, 31, 30, 31,\
    \ 30, 31, 31, 30, 31, 30, 31];\n    let r = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\"\
    ).unwrap();\n    if !r.is_match(&date) {\n        return false;\n    }\n    let\
    \ d: Vec<&str> = date.split('-').collect();\n    let day = d[1].parse::<usize>().unwrap();\n\
    \    let month = d[0].parse::<usize>().unwrap();\n    let year = d[2].parse::<usize>().unwrap();\n\
    \    if month > 12 || month < 1 {\n        return false;\n    }\n    if month\
    \ == 2 && day > 29 {\n        return false;\n    }\n    if month < 8 && month\
    \ % 2 == 0 && month != 2 && day > 30 {\n        return false;\n    }\n    if month\
    \ > 7 && month % 2 == 1 && day > 30 {\n        return false;\n    }\n    if month\
    \ < 8 && month % 2 == 1 && day > 31 {\n        return false;\n    }\n    if month\
    \ > 7 && month % 2 == 0 && day > 31 {\n        return false;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp4upygs7r.rs:10:13\n   |\n10 |     let r = Regex::new(r\"^\\d{2}-\\d{2}-\\\
    d{4}$\").unwrap();\n   |             ^^^^^ use of undeclared type `Regex`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // Check if date is empty\n    if date.is_empty()\
    \ {\n        return false;\n    }\n\n    // Check if the format of the date is\
    \ correct\n    let split_date: Vec<&str> = date.split(\"-\").collect();\n    if\
    \ split_date.len() != 3 {\n        return false;\n    }\n\n    // Parse the date\
    \ into integers and check if they are within bounds\n    let month: u32 = split_date[0].parse().unwrap();\n\
    \    let day: u32 = split_date[1].parse().unwrap();\n    let year: u32 = split_date[2].parse().unwrap();\n\
    \n    if !(month >= 1 && month <= 12) {\n        return false;\n    }\n\n    if\
    \ month == 2 {\n        // Check if leap year\n        if year % 4 == 0 {\n  \
    \          if !(day >= 1 && day <= 29) {\n                return false;\n    \
    \        }\n        } else {\n            if !(day >= 1 && day <= 28) {\n    \
    \            return false;\n            }\n        }\n    } else if month == 1\
    \ || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month\
    \ == 12 {\n        if !(day >= 1 && day <= 31) {\n            return false;\n\
    \        }\n    } else {\n        if !(day >= 1 && day <= 30) {\n            return\
    \ false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut split = date.split('-');\n\
    \    let mut months = vec![1,3,5,7,8,10,12];\n    let mut is_valid = true;\n \
    \   let mut month: u32 = 0;\n    let mut day: u32 = 0;\n    let mut year: u32\
    \ = 0;\n\n    if date.is_empty() {\n        is_valid = false;\n    }\n\n    if\
    \ let Some(m) = split.next() {\n        if let Ok(mm) = m.parse::<u32>() {\n \
    \           month = mm;\n        } else {\n            is_valid = false;\n   \
    \     }\n    } else {\n        is_valid = false;\n    }\n\n    if let Some(d)\
    \ = split.next() {\n        if let Ok(dd) = d.parse::<u32>() {\n            day\
    \ = dd;\n        } else {\n            is_valid = false;\n        }\n    } else\
    \ {\n        is_valid = false;\n    }\n\n    if let Some(y) = split.next() {\n\
    \        if let Ok(yy) = y.parse::<u32>() {\n            year = yy;\n        }\
    \ else {\n            is_valid = false;\n        }\n    } else {\n        is_valid\
    \ = false;\n    }\n\n    if month > 12 || month < 1 {\n        is_valid = false;\n\
    \    }\n\n    if months.contains(&month) {\n        if day > 31 || day < 1 {\n\
    \            is_valid = false;\n        }\n    } else if month == 2 {\n      \
    \  if day > 29 || day < 1 {\n            is_valid = false;\n        }\n    } else\
    \ {\n        if day > 30 || day < 1 {\n            is_valid = false;\n       \
    \ }\n    }\n\n    if year < 1 {\n        is_valid = false;\n    }\n\n    is_valid\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_pattern = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n    if !date_pattern.is_match(&date) {\n        return false;\n\
    \    }\n    let mut dt: Vec<&str> = date.split(\"-\").collect();\n    dt[0] =\
    \ dt[0].trim_start_matches('0');\n    dt[1] = dt[1].trim_start_matches('0');\n\
    \    let month: u32 = dt[0].parse().unwrap();\n    let day: u32 = dt[1].parse().unwrap();\n\
    \    let year: u32 = dt[2].parse().unwrap();\n    let days_in_month = [31, 28,\
    \ 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let is_leap_year = year % 4 ==\
    \ 0 && (year % 100 != 0 || year % 400 == 0);\n    if month < 1 || month > 12 {\n\
    \        return false;\n    }\n    let max_days = if month == 2 && is_leap_year\
    \ {\n        29\n    } else {\n        days_in_month[month as usize - 1]\n   \
    \ };\n    if day < 1 || day > max_days {\n        return false;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpcu_77xhf.rs:9:24\n\
    \  |\n9 |     let date_pattern = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n  |                        ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_split.len() != 3 {\n        return false;\n    }\n\n    let month:\
    \ i32 = date_split[0].parse().unwrap();\n    let day: i32 = date_split[1].parse().unwrap();\n\
    \    let year: i32 = date_split[2].parse().unwrap();\n\n    if year <= 0 {\n \
    \       return false;\n    }\n\n    if month < 1 || month > 12 {\n        return\
    \ false;\n    }\n\n    if day < 1 || day > 31 {\n        return false;\n    }\n\
    \n    if month == 2 {\n        if day > 29 {\n            return false;\n    \
    \    }\n    } else if month == 4 || month == 6 || month == 9 || month == 11 {\n\
    \        if day > 30 {\n            return false;\n        }\n    }\n\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let (month, day, year) = date.split(\"\
    -\").map(|x| x.parse::<u32>().unwrap()).collect_tuple().unwrap();\n    let days_in_month\
    \ = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let is_leap_year\
    \ = |year: u32| (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n    //\
    \ Check for empty input\n    if date.is_empty() {\n        return false;\n   \
    \ }\n    // Check for valid input\n    if !date.chars().all(|x| x.is_ascii_digit()\
    \ || x == '-') {\n        return false;\n    }\n    // Check for months\n    if\
    \ month < 1 || month > 12 {\n        return false;\n    }\n    // Check for days\n\
    \    if day < 1 || day > days_in_month[(month - 1) as usize] {\n        return\
    \ false;\n    }\n    // Check for leap year february\n    if month == 2 && day\
    \ == 29 && !is_leap_year(year) {\n        return false;\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `collect_tuple` found for struct `Map` in\
    \ the current scope\n --> /tmp/tmpkv_fqks_.rs:9:81\n  |\n9 |     let (month, day,\
    \ year) = date.split(\"-\").map(|x| x.parse::<u32>().unwrap()).collect_tuple().unwrap();\n\
    \  |                                                                         \
    \        ^^^^^^^^^^^^^ method not found in `Map<std::str::Split<'_, &str>, [closure@/tmp/tmpkv_fqks_.rs:9:50:\
    \ 9:79]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n    if !date_regex.is_match(&date) {\n        return false;\n   \
    \ }\n    let month: i32 = date_regex.captures(&date).unwrap()[1].parse().unwrap();\n\
    \    let day: i32 = date_regex.captures(&date).unwrap()[2].parse().unwrap();\n\
    \    let year: i32 = date_regex.captures(&date).unwrap()[3].parse().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    match month\
    \ {\n        1|3|5|7|8|10|12 => day <= 31 && day >= 1,\n        4|6|9|11 => day\
    \ <= 30 && day >= 1,\n        2 => year % 4 == 0 && day <= 29 && day >= 1 || day\
    \ <= 28 && day >= 1,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpu71bt4ve.rs:9:22\n\
    \  |\n9 |     let date_regex = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n  |                      ^^^^^ use of undeclared type `Regex`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let numbers: Vec<&str> = date.split(\"-\").collect();\n\
    \    if numbers.len() != 3 {\n        return false;\n    }\n\n    let month: u32\
    \ = numbers[0].parse().unwrap();\n    let day: u32 = numbers[1].parse().unwrap();\n\
    \    let year: u32 = numbers[2].parse().unwrap();\n\n    let limit = if [1, 3,\
    \ 5, 7, 8, 10, 12].contains(&month) {\n        31\n    } else if [4, 6, 9, 11].contains(&month)\
    \ {\n        30\n    } else if month == 2 {\n        29\n    } else {\n      \
    \  return false;\n    };\n\n    if day < 1 || day > limit {\n        return false;\n\
    \    }\n\n    if month < 1 || month > 12 {\n        return false;\n    }\n\n \
    \   if year < 1 {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n    re.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmplr0sgj14.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let (month, day, year) = match date.split(\"\
    -\").collect::<Vec<&str>>().as_slice() {\n        [m, d, y] => (m.parse::<u8>().unwrap(),\
    \ d.parse::<u8>().unwrap(), y.parse::<u16>().unwrap()),\n        _ => (0, 0, 0)\n\
    \    };\n    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n\
    \        4 | 6 | 9 | 11 => day <= 30,\n        2 => day <= 29,\n        _ => false\n\
    \    } && month <= 12 && year > 0\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjjlftnk3.rs:13:5\n   |\n\
    13 | /     match month {\n14 | |         1 | 3 | 5 | 7 | 8 | 10 | 12 => day <=\
    \ 31,\n15 | |         4 | 6 | 9 | 11 => day <= 30,\n16 | |         2 => day <=\
    \ 29,\n17 | |         _ => false\n18 | |     } && month <= 12 && year > 0\n  \
    \ | |     ^- help: consider using a semicolon here\n   | |_____|\n   |       expected\
    \ `()`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjjlftnk3.rs:18:19\n\
    \   |\n18 |     } && month <= 12 && year > 0\n   |                   ^^ expected\
    \ `&&u8`, found integer\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n    re.is_match(&date)\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp0nebeyev.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let chars: Vec<char> = date.chars().collect();\n\
    \    if chars.len() != 10 {\n        return false;\n    }\n    let months = vec![31,\
    \ 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let mut count = 0;\n    for\
    \ c in chars {\n        if c.is_alphabetic() {\n            return false;\n  \
    \      }\n        if c == '-' {\n            count += 1;\n        }\n    }\n \
    \   if count != 2 {\n        return false;\n    }\n    let m: String = chars[0..2].iter().collect();\n\
    \    let d: String = chars[3..5].iter().collect();\n    let y: String = chars[6..10].iter().collect();\n\
    \    let month: u32 = m.parse().unwrap();\n    let day: u32 = d.parse().unwrap();\n\
    \    let year: u32 = y.parse().unwrap();\n    if month < 1 || month > 12 {\n \
    \       return false;\n    }\n    if year < 1 {\n        return false;\n    }\n\
    \    if day < 1 || day > months[month as usize - 1] {\n        return false;\n\
    \    }\n    if month == 2 && day == 29 {\n        if year % 4 == 0 {\n       \
    \     return true;\n        }\n        return false;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `chars`\n   --> /tmp/tmph66r681v.rs:26:21\n\
    \    |\n9   |     let chars: Vec<char> = date.chars().collect();\n    |      \
    \   ----- move occurs because `chars` has type `Vec<char>`, which does not implement\
    \ the `Copy` trait\n...\n15  |     for c in chars {\n    |              -----\n\
    \    |              |\n    |              `chars` moved due to this implicit call\
    \ to `.into_iter()`\n    |              help: consider borrowing to avoid moving\
    \ into the for loop: `&chars`\n...\n26  |     let m: String = chars[0..2].iter().collect();\n\
    \    |                     ^^^^^ value borrowed here after move\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `chars`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    println!(\"{}\", date);\n    let (day,\
    \ month, year) = match date.split('-').map(|s| s.parse::<u8>().unwrap()).collect::<Vec<u8>>()[..]\
    \ {\n        [d, m, y] => (d, m, y),\n        _ => return false,\n    };\n   \
    \ println!(\"{}/{}/{}\", day, month, year);\n    if day < 1 || month < 1 || year\
    \ < 0 {\n        return false;\n    }\n    let res = match month {\n        1\
    \ | 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n        4 | 6 | 9 | 11 => day <= 30,\n\
    \        2 => {\n            if year % 400 == 0 || (year % 4 == 0 && year % 100\
    \ != 0) {\n                day <= 29\n            } else {\n                day\
    \ <= 28\n            }\n        }\n        _ => false,\n    };\n    res\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: comparison is useless due to type limits\n  --> /tmp/tmp2_b18qo1.rs:15:32\n\
    \   |\n15 |     if day < 1 || month < 1 || year < 0 {\n   |                  \
    \              ^^^^^^^^\n   |\n   = note: `#[warn(unused_comparisons)]` on by\
    \ default\n\nerror: literal out of range for `u8`\n  --> /tmp/tmp2_b18qo1.rs:22:23\n\
    \   |\n22 |             if year % 400 == 0 || (year % 4 == 0 && year % 100 !=\
    \ 0) {\n   |                       ^^^\n   |\n   = note: `#[deny(overflowing_literals)]`\
    \ on by default\n   = note: the literal `400` does not fit into the type `u8`\
    \ whose range is `0..=255`\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_split.len() != 3 {\n        return false;\n    }\n    let days =\
    \ date_split[1].parse::<u32>().unwrap();\n    let months = date_split[0].parse::<u32>().unwrap();\n\
    \    let years = date_split[2].parse::<u32>().unwrap();\n    if months > 12 ||\
    \ months < 1 {\n        return false;\n    }\n    match months {\n        1 |\
    \ 3 | 5 | 7 | 8 | 10 | 12 => {\n            if days > 31 || days < 1 {\n     \
    \           return false;\n            }\n        }\n        4 | 6 | 9 | 11 =>\
    \ {\n            if days > 30 || days < 1 {\n                return false;\n \
    \           }\n        }\n        2 => {\n            if days > 29 || days < 1\
    \ {\n                return false;\n            }\n        }\n        _ => {}\n\
    \    }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ RE: Regex = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-(19|20)\\\
    d{2}$\").unwrap();\n    }\n    RE.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpvjdlxov_.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpvjdlxov_.rs:12:5\n   |\n12 |     RE.is_match(&date)\n\
    \   |     ^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let d: Vec<&str> = date.split(\"-\"\
    ).collect();\n    if d.len() != 3 {\n        return false;\n    }\n    let m =\
    \ d[0].parse::<i32>().unwrap();\n    let d = d[1].parse::<i32>().unwrap();\n \
    \   let y = d[2].parse::<i32>().unwrap();\n    if d <= 0 || d > 31 || m <= 0 ||\
    \ m > 12 || y <= 0 {\n        return false;\n    }\n    match m {\n        1 |\
    \ 3 | 5 | 7 | 8 | 10 | 12 => d <= 31,\n        4 | 6 | 9 | 11 => d <= 30,\n  \
    \      2 => d <= 29,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `i32`\n  --> /tmp/tmp8yyjrk8r.rs:15:13\n\
    \   |\n15 |     let y = d[2].parse::<i32>().unwrap();\n   |             ^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ RE: Regex = Regex::new(r\"(0?[1-9]|1[0-2])-(0?[1-9]|[12][0-9]|3[01])-(19|20)?[0-9]{2}\"\
    ).unwrap();\n    }\n    let caps = RE.captures(&date);\n    if let Some(caps)\
    \ = caps {\n        let month = caps.get(1).unwrap().as_str().parse::<i32>().unwrap();\n\
    \        let day = caps.get(2).unwrap().as_str().parse::<i32>().unwrap();\n  \
    \      let year = caps.get(3).unwrap().as_str().parse::<i32>().unwrap();\n   \
    \     return match month {\n            1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n   \
    \             if day > 0 && day <= 31 {\n                    true\n          \
    \      } else {\n                    false\n                }\n            }\n\
    \            4 | 6 | 9 | 11 => {\n                if day > 0 && day <= 30 {\n\
    \                    true\n                } else {\n                    false\n\
    \                }\n            }\n            2 => {\n                if day\
    \ > 0 && day <= 28 {\n                    true\n                } else if day\
    \ == 29 && year % 4 == 0 {\n                    true\n                } else {\n\
    \                    false\n                }\n            }\n            _ =>\
    \ false,\n        };\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmp3ev11adr.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmp3ev11adr.rs:12:16\n   |\n12 |     let\
    \ caps = RE.captures(&date);\n   |                ^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // We can't possibly have a valid date\
    \ if the string is empty\n    if date.is_empty() {\n        return false;\n  \
    \  }\n\n    // The input string can only be broken up into 3 parts by . or -\n\
    \    let parts: Vec<&str> = date.split(|c| c == '.' || c == '-').collect();\n\
    \    if parts.len() != 3 {\n        return false;\n    }\n\n    // Months cannot\
    \ be negative or more than 12\n    let month: i32 = parts[0].parse().unwrap();\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n\n    // Check\
    \ days for months 1,3,5,7,8,10,12\n    if month == 1 || month == 3 || month ==\
    \ 5 || month == 7 || month == 8 || month == 10 || month == 12 {\n        let day:\
    \ i32 = parts[1].parse().unwrap();\n        if day < 1 || day > 31 {\n       \
    \     return false;\n        }\n    }\n\n    // Check days for months 4,6,9,11\n\
    \    if month == 4 || month == 6 || month == 9 || month == 11 {\n        let day:\
    \ i32 = parts[1].parse().unwrap();\n        if day < 1 || day > 30 {\n       \
    \     return false;\n        }\n    }\n\n    // Check days for month 2\n    if\
    \ month == 2 {\n        let day: i32 = parts[1].parse().unwrap();\n        if\
    \ day < 1 || day > 29 {\n            return false;\n        }\n    }\n\n    //\
    \ Check the year\n    let year: i32 = parts[2].parse().unwrap();\n    if year\
    \ < 1000 || year > 3000 {\n        return false;\n    }\n\n    // If all checks\
    \ pass, return true\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // date string is not empty\n    let\
    \ mut date_vec: Vec<&str> = date.split(\"-\").collect();\n    let date_len = date_vec.len();\n\
    \    if date_len != 3 {\n        return false;\n    }\n    // date string is in\
    \ the format: mm-dd-yyyy\n    let month: i32 = date_vec[0].parse().unwrap();\n\
    \    let day: i32 = date_vec[1].parse().unwrap();\n    let year: i32 = date_vec[2].parse().unwrap();\n\
    \    if year < 1 {\n        return false;\n    }\n    if month < 1 || month >\
    \ 12 {\n        return false;\n    }\n    // months should not be less than 1\
    \ or higher than 12\n    if day < 1 || day > 31 {\n        return false;\n   \
    \ }\n    // the number of days is not less than 1 or higher than 31 days for months\
    \ 1,3,5,7,8,10,12\n    if month == 2 {\n        if day > 29 {\n            return\
    \ false;\n        }\n    }\n    // the number of days is not less than 1 or higher\
    \ than 29 for the month 2\n    if day > 30 {\n        if month == 4 || month ==\
    \ 6 || month == 9 || month == 11 {\n            return false;\n        }\n   \
    \ }\n    // the number of days is not less than 1 or higher than 30 days for months\
    \ 4,6,9,11\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let parts: Vec<&str> = date.split(\"\
    -\").collect();\n    if parts.len() == 3 {\n        let y: u32 = parts[2].parse().unwrap();\n\
    \        let m: u32 = parts[0].parse().unwrap();\n        let d: u32 = parts[1].parse().unwrap();\n\
    \        let max_day: u32 = match m {\n            1 | 3 | 5 | 7 | 8 | 10 | 12\
    \ => 31,\n            4 | 6 | 9 | 11 => 30,\n            2 => if y % 4 == 0 {\
    \ 29 } else { 28 },\n            _ => 0,\n        };\n        if y > 0 && m >\
    \ 0 && m < 13 && d > 0 && d <= max_day {\n            return true;\n        }\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut split = date.split(\"-\");\n    let year = split.next().unwrap();\n\
    \    let month = split.next().unwrap();\n    let day = split.next().unwrap();\n\
    \n    let days_in_month = || {\n        let day = day.parse::<u32>().unwrap();\n\
    \        match month.parse::<u32>().unwrap() {\n            1 | 3 | 5 | 7 | 8\
    \ | 10 | 12 => day <= 31,\n            4 | 6 | 9 | 11 => day <= 30,\n        \
    \    2 => day <= 29,\n            _ => false,\n        }\n    };\n\n    year.parse::<u32>().is_ok()\
    \ && month.parse::<u32>().is_ok() && days_in_month()\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdgtw6j74.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date = date.as_str();\n    let\
    \ date_len = date.len();\n    if date_len == 0 {\n        return false;\n    }\n\
    \    let date_vec: Vec<&str> = date.split(\"-\").collect();\n    if date_vec.len()\
    \ != 3 {\n        return false;\n    }\n    let (day, month, year) = (date_vec[1].parse::<u8>().unwrap(),\
    \ date_vec[0].parse::<u8>().unwrap(), date_vec[2].parse::<u8>().unwrap());\n \
    \   if month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month\
    \ == 10 || month == 12 {\n        if day < 1 || day > 31 {\n            return\
    \ false;\n        }\n    } else if month == 4 || month == 6 || month == 9 || month\
    \ == 11 {\n        if day < 1 || day > 30 {\n            return false;\n     \
    \   }\n    } else if month == 2 {\n        if day < 1 || day > 29 {\n        \
    \    return false;\n        }\n    } else {\n        return false;\n    }\n  \
    \  return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: PosOverflow }'', /tmp/tmpxd73n14q.rs:18:129

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut date = date.split(\"-\");\n\
    \    let month = date.next().unwrap();\n    let day = date.next().unwrap();\n\
    \    let year = date.next().unwrap();\n    println!(\"month is {}\", month);\n\
    \    println!(\"day is {}\", day);\n    println!(\"year is {}\", year);\n    let\
    \ mut valid = true;\n    if month.len() != 2 || day.len() != 2 || year.len() !=\
    \ 4 {\n        valid = false;\n    } else {\n        if month.parse::<i32>().unwrap()\
    \ < 1 || month.parse::<i32>().unwrap() > 12 {\n            valid = false;\n  \
    \      } else {\n            if month.parse::<i32>().unwrap() == 2 {\n       \
    \         if day.parse::<i32>().unwrap() < 1 || day.parse::<i32>().unwrap() >\
    \ 29 {\n                    valid = false;\n                }\n            } else\
    \ if month.parse::<i32>().unwrap() == 4 || month.parse::<i32>().unwrap() == 6\
    \ || month.parse::<i32>().unwrap() == 9 || month.parse::<i32>().unwrap() == 11\
    \ {\n                if day.parse::<i32>().unwrap() < 1 || day.parse::<i32>().unwrap()\
    \ > 30 {\n                    valid = false;\n                }\n            }\
    \ else {\n                if day.parse::<i32>().unwrap() < 1 || day.parse::<i32>().unwrap()\
    \ > 31 {\n                    valid = false;\n                }\n            }\n\
    \        }\n    }\n    valid\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp909o153b.rs:11:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: 'month is 03

    day is 11

    year is 2000

    month is 15

    day is 01

    year is 2012

    month is 04

    day is 0

    year is 2040

    month is 06

    day is 04

    year is 2020

    month is 01

    day is 01

    year is 2007

    month is 03

    day is 32

    year is 2011

    '
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut split_date = date.split(\"\
    -\");\n    let days = match split_date.next() {\n        Some(x) => {\n      \
    \      if x.parse::<i32>().is_err() {\n                return false;\n       \
    \     } else {\n                x.parse::<i32>().unwrap()\n            }\n   \
    \     }\n        None => return false,\n    };\n    let months = match split_date.next()\
    \ {\n        Some(x) => {\n            if x.parse::<i32>().is_err() {\n      \
    \          return false;\n            } else {\n                x.parse::<i32>().unwrap()\n\
    \            }\n        }\n        None => return false,\n    };\n    let years\
    \ = match split_date.next() {\n        Some(x) => {\n            if x.parse::<i32>().is_err()\
    \ {\n                return false;\n            } else {\n                x.parse::<i32>().unwrap()\n\
    \            }\n        }\n        None => return false,\n    };\n    if years\
    \ < 0 {\n        return false;\n    }\n    if months < 1 || months > 12 {\n  \
    \      return false;\n    }\n    match months {\n        1 | 3 | 5 | 7 | 8 | 10\
    \ | 12 => {\n            if days < 1 || days > 31 {\n                return false;\n\
    \            }\n        }\n        4 | 6 | 9 | 11 => {\n            if days <\
    \ 1 || days > 30 {\n                return false;\n            }\n        }\n\
    \        2 => {\n            if days < 1 || days > 29 {\n                return\
    \ false;\n            }\n        }\n        _ => return false,\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprcdksxt3.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let date_parts: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_parts.len() != 3 {\n        return false;\n    }\n\n    let days\
    \ = date_parts[1].parse::<u32>().unwrap();\n    let months = date_parts[0].parse::<u32>().unwrap();\n\
    \    let years = date_parts[2].parse::<u32>().unwrap();\n\n    if months > 12\
    \ || months < 1 {\n        return false;\n    }\n\n    if (1..31 + 1).contains(&days)\n\
    \        && (1..12 + 1).contains(&months)\n        && (1..99999 + 1).contains(&years)\n\
    \    {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmprxljs3e5.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if !date.contains('-') {\n        return\
    \ false;\n    }\n    let mut parts = date.split('-');\n    if let Ok(month) =\
    \ parts.next().unwrap().parse::<i32>() {\n        if !(1..=12).contains(&month)\
    \ {\n            return false;\n        }\n        if let Ok(day) = parts.next().unwrap().parse::<i32>()\
    \ {\n            if let Some(year) = parts.next() {\n                let days_in_month\
    \ = match month {\n                    2 => if year.parse::<i32>().unwrap() %\
    \ 4 == 0 {\n                        29\n                    } else {\n       \
    \                 28\n                    },\n                    1 | 3 | 5 |\
    \ 7 | 8 | 10 | 12 => 31,\n                    _ => 30,\n                };\n \
    \               if !(1..=days_in_month).contains(&day) {\n                   \
    \ return false;\n                }\n                if year.len() != 4 {\n   \
    \                 return false;\n                }\n                return true;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // Not Empty\n    if date.is_empty()\
    \ {\n        return false;\n    }\n\n    // convert to chars\n    let chars: Vec<char>\
    \ = date.chars().collect();\n\n    // Check for mm-dd-yyyy format\n    if chars.len()\
    \ != 10 {\n        return false;\n    }\n    let mut iter = chars.iter();\n  \
    \  if !iter.next().unwrap().is_digit(10) {\n        return false;\n    }\n   \
    \ if !iter.next().unwrap().is_digit(10) {\n        return false;\n    }\n    if\
    \ *iter.next().unwrap() != '-' {\n        return false;\n    }\n    if !iter.next().unwrap().is_digit(10)\
    \ {\n        return false;\n    }\n    if !iter.next().unwrap().is_digit(10) {\n\
    \        return false;\n    }\n    if *iter.next().unwrap() != '-' {\n       \
    \ return false;\n    }\n    if !iter.next().unwrap().is_digit(10) {\n        return\
    \ false;\n    }\n    if !iter.next().unwrap().is_digit(10) {\n        return false;\n\
    \    }\n    if !iter.next().unwrap().is_digit(10) {\n        return false;\n \
    \   }\n    if !iter.next().unwrap().is_digit(10) {\n        return false;\n  \
    \  }\n\n    // convert to string\n    let mut chars: Vec<String> = Vec::new();\n\
    \    for i in date.split('-') {\n        chars.push(i.to_string());\n    }\n\n\
    \    // Convert to numbers\n    let mut numbers: Vec<u32> = Vec::new();\n    for\
    \ i in chars {\n        match i.parse::<u32>() {\n            Ok(x) => numbers.push(x),\n\
    \            Err(_) => return false,\n        }\n    }\n\n    // validate month\n\
    \    if numbers[0] < 1 || numbers[0] > 12 {\n        return false;\n    }\n\n\
    \    // validate day\n    match numbers[0] {\n        1 | 3 | 5 | 7 | 8\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_09md_v7.rs:96:3\n\
    \   |\n8  | fn valid_date(date: String) -> bool {\n   |                      \
    \               - unclosed delimiter\n...\n74 |     match numbers[0] {\n   | \
    \                     - this delimiter might not be properly closed...\n75 | \
    \        1 | 3 | 5 | 7 | 8\n76 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n96 | }\n   |   ^\n\nerror: expected one of `...`, `..=`, `..`,\
    \ `=>`, `if`, or `|`, found `}`\n  --> /tmp/tmp_09md_v7.rs:76:1\n   |\n75 |  \
    \       1 | 3 | 5 | 7 | 8\n   |                          - expected one of `...`,\
    \ `..=`, `..`, `=>`, `if`, or `|`\n76 | }\n   | ^ unexpected token\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let slice = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    if slice.len() != 3 {\n        return false;\n    }\n    let day = slice[1].parse::<u32>().unwrap();\n\
    \    let month = slice[0].parse::<u32>().unwrap();\n    let year = slice[2].parse::<u32>().unwrap();\n\
    \    let days_in_month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n \
    \   let max_days = days_in_month[(month - 1) as usize];\n    if day > 0 && day\
    \ <= max_days && month > 0 && month <= 12 && year > 0 {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 12 but the
    index is 14'', /tmp/tmpk1ca817_.rs:17:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    re.is_match(&date)\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpqeuev25a.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() < 10 {\n        return\
    \ false;\n    }\n    let split: Vec<&str> = date.split(\"-\").collect();\n   \
    \ let mm = split[0].parse::<i32>().unwrap();\n    let dd = split[1].parse::<i32>().unwrap();\n\
    \    let yyyy = split[2].parse::<i32>().unwrap();\n    if !(1 <= dd && dd <= 31)\
    \ {\n        return false;\n    }\n    if !(1 <= mm && mm <= 12) {\n        return\
    \ false;\n    }\n    if !(1000 <= yyyy && yyyy <= 9999) {\n        return false;\n\
    \    }\n    if dd == 31 && (mm == 2 || mm == 4 || mm == 6 || mm == 9 || mm ==\
    \ 11) {\n        return false;\n    }\n    if dd == 30 && mm == 2 {\n        return\
    \ false;\n    }\n    if dd == 29 && mm == 2 && !(yyyy % 4 == 0 && (yyyy % 100\
    \ != 0 || yyyy % 400 == 0)) {\n        return false;\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut date_split = date.split(\"-\");\n    let date_split:\
    \ Vec<_> = date_split.collect();\n\n    if date_split.len() != 3 {\n        return\
    \ false;\n    }\n\n    let month: u32 = match date_split[0].parse() {\n      \
    \  Ok(num) => num,\n        Err(_) => return false,\n    };\n\n    let day: u32\
    \ = match date_split[1].parse() {\n        Ok(num) => num,\n        Err(_) =>\
    \ return false,\n    };\n\n    let year: u32 = match date_split[2].parse() {\n\
    \        Ok(num) => num,\n        Err(_) => return false,\n    };\n\n    if month\
    \ < 1 || month > 12 {\n        return false;\n    }\n\n    if day < 1 || day >\
    \ 31 {\n        return false;\n    }\n\n    if (month == 4 || month == 6 || month\
    \ == 9 || month == 11) && day > 30 {\n        return false;\n    }\n\n    if month\
    \ == 2 && day > 29 {\n        return false;\n    }\n\n    if month == 2 && day\
    \ == 29 {\n        if year % 4 != 0 {\n            return false;\n        }\n\
    \        if year % 100 == 0 && year % 400 != 0 {\n            return false;\n\
    \        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9fhnvj5s.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n    if !re.is_match(&date) {\n        return false;\n    }\n\
    \    let parts: Vec<&str> = date.split(\"-\").collect();\n    let month = match\
    \ parts[0].parse::<u32>() {\n        Ok(m) => m,\n        Err(_) => return false,\n\
    \    };\n    let day = match parts[1].parse::<u32>() {\n        Ok(d) => d,\n\
    \        Err(_) => return false,\n    };\n    if month == 2 {\n        if day\
    \ > 29 {\n            return false;\n        }\n    } else if [4, 6, 9, 11].contains(&month)\
    \ {\n        if day > 30 {\n            return false;\n        }\n    } else if\
    \ day > 31 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpl2x4th3s.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let split: Vec<&str> = date.split(\"\
    -\").collect();\n    let mut is_valid = false;\n    if split.len() == 3 {\n  \
    \      let m: i32 = split[0].parse().unwrap();\n        let d: i32 = split[1].parse().unwrap();\n\
    \        let y: i32 = split[2].parse().unwrap();\n        let mut valid_month\
    \ = false;\n        if m >= 1 && m <= 12 {\n            valid_month = true;\n\
    \        }\n        let mut valid_day = false;\n        if m == 2 {\n        \
    \    if d >= 1 && d <= 29 {\n                valid_day = true;\n            }\n\
    \        } else if m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 ||\
    \ m == 12 {\n            if d >= 1 && d <= 31 {\n                valid_day = true;\n\
    \            }\n        } else {\n            if d >= 1 && d <= 30 {\n       \
    \         valid_day = true;\n            }\n        }\n        let mut valid_year\
    \ = false;\n        if y >= 1000 && y <= 9999 {\n            valid_year = true;\n\
    \        }\n        if valid_month && valid_day && valid_year {\n            is_valid\
    \ = true;\n        }\n    }\n    is_valid\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^\\d{2}-\\d{2}-\\\
    d{4}$\").unwrap();\n    if !re.is_match(&date) {\n        return false;\n    }\n\
    \    let date_split: Vec<_> = date.split(\"-\").collect();\n    let year = date_split[2].parse::<u32>().unwrap();\n\
    \    let month = date_split[0].parse::<u32>().unwrap();\n    let day = date_split[1].parse::<u32>().unwrap();\n\
    \    if month > 12 || month < 1 {\n        return false;\n    }\n    if month\
    \ == 2 {\n        if year % 4 == 0 && year % 100 != 0 || year % 400 == 0 {\n \
    \           if day > 29 || day < 1 {\n                return false;\n        \
    \    }\n        } else {\n            if day > 28 || day < 1 {\n             \
    \   return false;\n            }\n        }\n    } else if month == 4 || month\
    \ == 6 || month == 9 || month == 11 {\n        if day > 30 || day < 1 {\n    \
    \        return false;\n        }\n    } else {\n        if day > 31 || day <\
    \ 1 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpq_7814m6.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n  |\
    \              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let rule1 = date.len() != 0;\n    let\
    \ rule2 = valid_day_of_month(date.clone());\n    let rule3 = valid_month(date.clone());\n\
    \    let rule4 = valid_format(date.clone());\n    rule1 && rule2 && rule3 && rule4\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `valid_day_of_month` in this scope\n\
    \  --> /tmp/tmpmq_hbe0x.rs:10:17\n   |\n10 |     let rule2 = valid_day_of_month(date.clone());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `valid_month` in this scope\n  --> /tmp/tmpmq_hbe0x.rs:11:17\n\
    \   |\n11 |     let rule3 = valid_month(date.clone());\n   |                 ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `valid_format`\
    \ in this scope\n  --> /tmp/tmpmq_hbe0x.rs:12:17\n   |\n12 |     let rule4 = valid_format(date.clone());\n\
    \   |                 ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let split: Vec<&str> = date.split(\"-\").collect();\n \
    \   if split.len() != 3 {\n        return false;\n    }\n\n    if split[0].len()\
    \ != 2 || split[1].len() != 2 || split[2].len() != 4 {\n        return false;\n\
    \    }\n\n    let mut mm: u32 = split[0].parse().unwrap();\n    let mut dd: u32\
    \ = split[1].parse().unwrap();\n    let mut yyyy: u32 = split[2].parse().unwrap();\n\
    \n    if mm < 1 || mm > 12 {\n        return false;\n    }\n\n    if dd < 1 {\n\
    \        return false;\n    }\n\n    if mm == 2 {\n        if dd > 29 {\n    \
    \        return false;\n        }\n    } else if mm % 2 == 0 {\n        if dd\
    \ > 30 {\n            return false;\n        }\n    } else {\n        if dd >\
    \ 31 {\n            return false;\n        }\n    }\n\n    if yyyy > 2100 || yyyy\
    \ < 1900 {\n        return false;\n    }\n\n    if mm == 2 && dd == 29 {\n   \
    \     if yyyy % 400 == 0 {\n            return true;\n        }\n\n        if\
    \ yyyy % 100 == 0 {\n            return false;\n        }\n\n        if yyyy %\
    \ 4 == 0 {\n            return true;\n        }\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ DATE_REGEX: Regex = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    }\n\n    if !DATE_REGEX.is_match(&date) {\n        return false;\n\
    \    }\n\n    let split: Vec<&str> = date.split(\"-\").collect();\n    let month\
    \ = split[0].parse::<u32>().unwrap();\n    let day = split[1].parse::<u32>().unwrap();\n\
    \    let year = split[2].parse::<u32>().unwrap();\n\n    if year < 1000 || year\
    \ > 9999 {\n        return false;\n    }\n\n    match month {\n        1 | 3 |\
    \ 5 | 7 | 8 | 10 | 12 => day > 0 && day <= 31,\n        4 | 6 | 9 | 11 => day\
    \ > 0 && day <= 30,\n        2 => {\n            let is_leap_year = year % 4 ==\
    \ 0 && (year % 100 != 0 || year % 400 == 0);\n            day > 0 && day <= if\
    \ is_leap_year { 29 } else { 28 }\n        }\n        _ => false,\n    }\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmppery9ueh.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `DATE_REGEX` in this scope\n  --> /tmp/tmppery9ueh.rs:13:9\n   |\n13 |\
    \     if !DATE_REGEX.is_match(&date) {\n   |         ^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_split: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_split.len() != 3 {\n        return false;\n    }\n\
    \    let day = date_split[1].parse::<i32>().unwrap();\n    let month = date_split[0].parse::<i32>().unwrap();\n\
    \    let year = date_split[2].parse::<i32>().unwrap();\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n    if year < 1 {\n        return false;\n\
    \    }\n    if day < 1 {\n        return false;\n    }\n    if month == 2 {\n\
    \        if year % 4 == 0 {\n            if day > 29 {\n                return\
    \ false;\n            }\n        } else {\n            if day > 28 {\n       \
    \         return false;\n            }\n        }\n    } else if month == 4 ||\
    \ month == 6 || month == 9 || month == 11 {\n        if day > 30 {\n         \
    \   return false;\n        }\n    } else {\n        if day > 31 {\n          \
    \  return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = regex::Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\").unwrap();\n    if date_regex.is_match(&date)\
    \ {\n        let days_of_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,\
    \ 31];\n        let mut split_date = date.split(\"-\");\n        let mm = split_date.next().unwrap().parse::<i64>().unwrap();\n\
    \        let dd = split_date.next().unwrap().parse::<i64>().unwrap();\n      \
    \  let yyyy = split_date.next().unwrap().parse::<i64>().unwrap();\n        if\
    \ mm < 1 || mm > 12 {\n            return false;\n        }\n        if dd < 1\
    \ || dd > days_of_months[(mm - 1) as usize] {\n            return false;\n   \
    \     }\n        if yyyy < 1 {\n            return false;\n        }\n       \
    \ if mm == 2 && dd == 29 {\n            if yyyy % 400 == 0 || (yyyy % 4 == 0 &&\
    \ yyyy % 100 != 0) {\n                return true;\n            }\n          \
    \  return false;\n        }\n        return true;\n    }\n    return false;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \ --> /tmp/tmp80ofz9dn.rs:9:22\n  |\n9 |     let date_regex = regex::Regex::new(r\"\
    ^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\").unwrap();\n  |      \
    \                ^^^^^ use of undeclared crate or module `regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    //! Validate date string\n    let date_split:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if date_split.len() != 3 {\n \
    \       return false;\n    }\n    let days = date_split[1].parse::<u32>().unwrap();\n\
    \    let months = date_split[0].parse::<u32>().unwrap();\n    let years = date_split[2].parse::<u32>().unwrap();\n\
    \    if months < 1 || months > 12 {\n        return false;\n    }\n    if days\
    \ < 1 || days > 31 {\n        return false;\n    }\n    if days > 30 && (months\
    \ == 4 || months == 6 || months == 9 || months == 11) {\n        return false;\n\
    \    }\n    if days > 29 && months == 2 {\n        return false;\n    }\n    if\
    \ years < 0 {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ DATE_RE: Regex = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n \
    \   }\n\n    let caps = DATE_RE.captures(&date).unwrap();\n    let month = caps[1].parse::<u32>().unwrap();\n\
    \    let day = caps[2].parse::<u32>().unwrap();\n    let year = caps[3].parse::<u32>().unwrap();\n\
    \n    if month > 12 || day > 31 || year < 1 {\n        return false;\n    }\n\n\
    \    match month {\n        2 => {\n            if (year % 4 == 0 && year % 100\
    \ != 0) || year % 400 == 0 {\n                return day <= 29;\n            }\
    \ else {\n                return day <= 28;\n            }\n        }\n      \
    \  4 | 6 | 9 | 11 => return day <= 30,\n        _ => return day <= 31,\n    }\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpi6v74q9t.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `DATE_RE` in this scope\n  --> /tmp/tmpi6v74q9t.rs:13:16\n   |\n13 | \
    \    let caps = DATE_RE.captures(&date).unwrap();\n   |                ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let parts: Vec<&str> = date.split(\"-\").collect();\n \
    \   if parts.len() != 3 {\n        return false;\n    }\n\n    let month = parts[0].parse::<i32>().unwrap();\n\
    \    let day = parts[1].parse::<i32>().unwrap();\n    let year = parts[2].parse::<i32>().unwrap();\n\
    \n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    let days_in_month\
    \ = get_days_in_month(month, year);\n    if day < 1 || day > days_in_month {\n\
    \        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_days_in_month` in this scope\n\
    \  --> /tmp/tmpkmkz_vyx.rs:26:25\n   |\n26 |     let days_in_month = get_days_in_month(month,\
    \ year);\n   |                         ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // Your code here!\n    if date.is_empty()\
    \ {\n        return false;\n    }\n    let date_split: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_split.len() != 3 {\n        return false;\n    }\n\
    \    let month: i32 = date_split[0].parse().unwrap();\n    let day: i32 = date_split[1].parse().unwrap();\n\
    \    let year: i32 = date_split[2].parse().unwrap();\n    match month {\n    \
    \    1|3|5|7|8|10|12 => {\n            if day < 1 || day > 31 {\n            \
    \    return false;\n            }\n        },\n        4|6|9|11 => {\n       \
    \     if day < 1 || day > 30 {\n                return false;\n            }\n\
    \        },\n        2 => {\n            if day < 1 || day > 29 {\n          \
    \      return false;\n            }\n        },\n        _ => {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut month = 0;\n    let mut day = 0;\n    let mut year\
    \ = 0;\n\n    for (i, token) in date.split('-').enumerate() {\n        match i\
    \ {\n            0 => {\n                if token.len() != 2 {\n             \
    \       return false;\n                }\n                match token.parse::<i32>()\
    \ {\n                    Ok(m) => month = m,\n                    Err(_) => return\
    \ false,\n                }\n            }\n            1 => {\n             \
    \   if token.len() != 2 {\n                    return false;\n               \
    \ }\n                match token.parse::<i32>() {\n                    Ok(d) =>\
    \ day = d,\n                    Err(_) => return false,\n                }\n \
    \           }\n            2 => {\n                if token.len() != 4 {\n   \
    \                 return false;\n                }\n                match token.parse::<i32>()\
    \ {\n                    Ok(y) => year = y,\n                    Err(_) => return\
    \ false,\n                }\n            }\n            _ => return false,\n \
    \       }\n    }\n\n    if !(month >= 1 && month <= 12) {\n        return false;\n\
    \    }\n\n    if !(year >= 1900 && year <= 2100) {\n        return false;\n  \
    \  }\n\n    if month == 2 {\n        if (year % 4 == 0 && day >= 1 && day <= 29)\
    \ || (year % 4 != 0 && day >= 1 && day <= 28) {\n            return true;\n  \
    \      }\n    } else if (month == 1 || month == 3 || month == 5 || month == 7\
    \ || month == 8 || month == 10 || month == 12) && (day >= 1 && day <= 31) {\n\
    \        return true;\n    } else if (month == 4 || month == 6 || month == 9 ||\
    \ month == 11) && (day >= 1 && day <= 30) {\n        return true;\n    }\n\n \
    \   false\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_format = Regex::new(r\"^\\\
    d{2}-\\d{2}-\\d{4}$\").unwrap();\n    if !date_format.is_match(&date) {\n    \
    \    return false;\n    }\n    let splitted_date: Vec<&str> = date.split(\"-\"\
    ).collect();\n    let days = splitted_date[1].parse::<u32>().unwrap();\n    let\
    \ months = splitted_date[0].parse::<u32>().unwrap();\n    if months < 1 || months\
    \ > 12 {\n        return false;\n    }\n    match months {\n        1 | 3 | 5\
    \ | 7 | 8 | 10 | 12 => days < 1 || days > 31,\n        4 | 6 | 9 | 11 => days\
    \ < 1 || days > 30,\n        2 => days < 1 || days > 29,\n        _ => false,\n\
    \    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpomdn7oqs.rs:9:23\n\
    \  |\n9 |     let date_format = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n\
    \  |                       ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    //Split the string by '-'\n    let\
    \ d = date.split('-').collect::<Vec<&str>>();\n    //If there are not 3 elements\
    \ or any element is empty\n    if d.len() != 3 || d.iter().any(|&x| x.len() ==\
    \ 0) {\n        //Fails\n        return false;\n    }\n    //Convert the elements\
    \ to u32\n    let d: Vec<u32> = d.iter().map(|&x| x.parse::<u32>().unwrap()).collect();\n\
    \    //Check if the month is < 1 || > 12\n    if d[0] < 1 || d[0] > 12 {\n   \
    \     //Fails\n        return false;\n    }\n    //Check if the month is February\n\
    \    if d[0] == 2 {\n        //Check if the days are < 1 || > 29\n        if d[1]\
    \ < 1 || d[1] > 29 {\n            //Fails\n            return false;\n       \
    \ }\n    }\n    //Check if the days are < 1 || > 31\n    if d[1] < 1 || d[1] >\
    \ 31 {\n        //Fails\n        return false;\n    }\n    //Check if the month\
    \ is 4,6,9,11\n    if d[0] == 4 || d[0] == 6 || d[0] == 9 || d[0] == 11 {\n  \
    \      //Check if the days are > 30\n        if d[1] > 30 {\n            //Fails\n\
    \            return false;\n        }\n    }\n    //Returns True if it passes\
    \ all of the conditions\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    use regex::Regex;\n    let pattern\
    \ = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\").unwrap();\n    if !pattern.is_match(&date)\
    \ {\n        return false;\n    }\n    let v: Vec<&str> = date.split(\"-\").collect();\n\
    \    let month: u32 = v[0].parse().unwrap();\n    let day: u32 = v[1].parse().unwrap();\n\
    \    let year: u32 = v[2].parse().unwrap();\n    let leap_year = year % 4 == 0\
    \ && (year % 100 != 0 || year % 400 == 0);\n    if month > 12 || month < 1 {\n\
    \        return false;\n    }\n    if month == 2 {\n        if leap_year {\n \
    \           if day > 29 || day < 1 {\n                return false;\n        \
    \    }\n        } else {\n            if day > 28 || day < 1 {\n             \
    \   return false;\n            }\n        }\n    } else if month == 4 || month\
    \ == 6 || month == 9 || month == 11 {\n        if day > 30 || day < 1 {\n    \
    \        return false;\n        }\n    } else {\n        if day > 31 || day <\
    \ 1 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `regex`\n --> /tmp/tmpnwu95ufg.rs:9:9\n\
    \  |\n9 |     use regex::Regex;\n  |         ^^^^^ maybe a missing crate `regex`?\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // TODO: Code the function here\n \
    \   false\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptp9110yr.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let parts: Vec<&str> = date.split(\"-\").collect();\n \
    \   if parts.len() != 3 {\n        return false;\n    }\n\n    let month = match\
    \ parts[0].parse::<i32>() {\n        Ok(num) => num,\n        Err(_) => return\
    \ false,\n    };\n\n    let day = match parts[1].parse::<i32>() {\n        Ok(num)\
    \ => num,\n        Err(_) => return false,\n    };\n\n    let year = match parts[2].parse::<i32>()\
    \ {\n        Ok(num) => num,\n        Err(_) => return false,\n    };\n\n    if\
    \ year < 0 {\n        return false;\n    }\n\n    if month < 1 || month > 12 {\n\
    \        return false;\n    }\n\n    let days_in_month = match month {\n     \
    \   1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,\n        4 | 6 | 9 | 11 => 30,\n      \
    \  2 => {\n            if year % 4 == 0 {\n                29\n            } else\
    \ {\n                28\n            }\n        }\n        _ => return false,\n\
    \    };\n\n    day >= 1 && day <= days_in_month\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    if !date.contains(\"-\") {\n        return false;\n    }\n\
    \    let split_date: Vec<&str> = date.split(\"-\").collect();\n    if split_date.len()\
    \ != 3 {\n        return false;\n    }\n    let yyyy = match split_date[2].parse::<u32>()\
    \ {\n        Ok(num) => num,\n        Err(_) => return false,\n    };\n    let\
    \ mm = match split_date[0].parse::<u32>() {\n        Ok(num) => num,\n       \
    \ Err(_) => return false,\n    };\n    let dd = match split_date[1].parse::<u32>()\
    \ {\n        Ok(num) => num,\n        Err(_) => return false,\n    };\n    if\
    \ mm < 1 || mm > 12 {\n        return false;\n    }\n    if mm == 2 {\n      \
    \  if dd < 1 || dd > 29 {\n            return false;\n        }\n    } else if\
    \ mm == 1 || mm == 3 || mm == 5 || mm == 7 || mm == 8 || mm == 10 || mm == 12\
    \ {\n        if dd < 1 || dd > 31 {\n            return false;\n        }\n  \
    \  } else {\n        if dd < 1 || dd > 30 {\n            return false;\n     \
    \   }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    date.len() == 10 && date[2..4].parse::<i32>().unwrap()\
    \ > 0 && date[0..2].parse::<i32>().unwrap() > 0 && date[5..9].parse::<i32>().unwrap()\
    \ > 0 && ((date[2..4].parse::<i32>().unwrap() <= 7 && date[2..4].parse::<i32>().unwrap()\
    \ % 2 == 1) || (date[2..4].parse::<i32>().unwrap() > 7 && date[2..4].parse::<i32>().unwrap()\
    \ % 2 == 0)) && date[2..4].parse::<i32>().unwrap() <= 12 && date[0..2].parse::<i32>().unwrap()\
    \ <= 31 && date[0..2].parse::<i32>().unwrap() <= 30 && date[0..2].parse::<i32>().unwrap()\
    \ <= 28\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpj3psz7aq.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ RE: Regex = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\").unwrap();\n\
    \    }\n    match RE.captures(&date) {\n        Some(caps) => {\n            let\
    \ m = caps[1].parse::<u32>().unwrap();\n            let d = caps[2].parse::<u32>().unwrap();\n\
    \            let y = caps[3].parse::<u32>().unwrap();\n            if y < 1800\
    \ || y > 2100 {\n                return false;\n            }\n            if\
    \ m == 2 {\n                if d > 29 {\n                    return false;\n \
    \               }\n                if d > 28 && !(y % 4 == 0 && (y % 100 != 0\
    \ || y % 400 == 0)) {\n                    return false;\n                }\n\
    \            } else if (m == 4 || m == 6 || m == 9 || m == 11) && d > 30 {\n \
    \               return false;\n            } else if d > 31 {\n              \
    \  return false;\n            }\n            true\n        }\n        None =>\
    \ false,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpkjhq78s7.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpkjhq78s7.rs:12:11\n   |\n12 |     match\
    \ RE.captures(&date) {\n   |           ^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    date.is_empty()\n        || date\n\
    \            .split(\"-\")\n            .filter_map(|s| s.parse::<u32>().ok())\n\
    \            .collect::<Vec<u32>>()\n            .len()\n            != 3\n  \
    \      || ![1, 3, 5, 7, 8, 10, 12].contains(&date.split(\"-\").next().unwrap().parse::<u32>().unwrap())\n\
    \            && [2, 4, 6, 9, 11].contains(&date.split(\"-\").next().unwrap().parse::<u32>().unwrap())\n\
    \            && date.split(\"-\").nth(1).unwrap().parse::<u32>().unwrap() < 1\n\
    \            || ![1, 3, 5, 7, 8, 10, 12].contains(&date.split(\"-\").next().unwrap().parse::<u32>().unwrap())\n\
    \                && [2, 4, 6, 9, 11].contains(&date.split(\"-\").next().unwrap().parse::<u32>().unwrap())\n\
    \                && date.split(\"-\").nth(1).unwrap().parse::<u32>().unwrap()\
    \ > 30\n            || ![1, 3, 5, 7, 8, 10, 12].contains(&date.split(\"-\").next().unwrap().parse::<u32>().unwrap())\n\
    \                && date.split(\"-\").next().unwrap().parse::<u32>().unwrap()\
    \ == 2\n                && date.split(\"-\").nth(1).unwrap().parse::<u32>().unwrap()\
    \ < 1\n            || ![1, 3, 5, 7, 8, 10, 12].contains(&date.split(\"-\").next().unwrap().parse::<u32>().unwrap())\n\
    \                && date.split(\"-\").next().unwrap().parse::<u32>().unwrap()\
    \ == 2\n                && date.split(\"-\").nth(1).unwrap().parse::<u32>().unwrap()\
    \ > 29\n            || date.split(\"-\").next().unwrap().parse::<u32>().unwrap()\
    \ < 1\n            || date.split(\"-\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpthlb7r72.rs:49:47\n\
    \   |\n49 |       assert_eq!(candidate(String::from(\"04-2003\")), false);\n \
    \  |  _______________________________________________^\n50 | | }\n   | |__^\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let parts: Vec<&str> = date.split(\"\
    -\").collect();\n    if parts.len() != 3 {\n        return false;\n    }\n   \
    \ if parts[0].len() != 2 || parts[1].len() != 2 || parts[2].len() != 4 {\n   \
    \     return false;\n    }\n    let month: i32 = parts[0].parse().unwrap();\n\
    \    let day: i32 = parts[1].parse().unwrap();\n    if month < 1 || month > 12\
    \ {\n        return false;\n    }\n    if day < 1 || day > 31 {\n        return\
    \ false;\n    }\n    if month == 2 && day > 29 {\n        return false;\n    }\n\
    \    if (month == 4 || month == 6 || month == 9 || month == 11) && day > 30 {\n\
    \        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let valid_date_regex =\n        Regex::new(r\"\
    ^([1-9]|1[0-2])-([1-9]|[12][0-9]|3[01])-(201[0-9]|202[0-9])$\").unwrap();\n  \
    \  valid_date_regex.is_match(&date)\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmphq42ygrr.rs:10:9\n   |\n10 |         Regex::new(r\"^([1-9]|1[0-2])-([1-9]|[12][0-9]|3[01])-(201[0-9]|202[0-9])$\"\
    ).unwrap();\n   |         ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n    if re.is_match(&date) {\n        let parts: Vec<&str> = date.split(\"\
    -\").collect();\n        let days = parts[1].parse::<i32>().unwrap();\n      \
    \  let month = parts[0].parse::<i32>().unwrap();\n        let year = parts[2].parse::<i32>().unwrap();\n\
    \        if month == 2 {\n            if year % 4 == 0 {\n                if days\
    \ <= 29 {\n                    return true;\n                }\n            }\
    \ else {\n                if days <= 28 {\n                    return true;\n\
    \                }\n            }\n        } else if (month == 1 || month == 3\
    \ || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) &&\
    \ days <= 31 {\n            return true;\n        } else if (month == 4 || month\
    \ == 6 || month == 9 || month == 11) && days <= 30 {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpz8imihsk.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let date_split: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_split.len() != 3 {\n        return false;\n    }\n\n    let month\
    \ = date_split[0].parse::<i32>().unwrap();\n    let day = date_split[1].parse::<i32>().unwrap();\n\
    \    let year = date_split[2].parse::<i32>().unwrap();\n\n    if month < 1 ||\
    \ month > 12 {\n        return false;\n    }\n\n    if day < 1 || day > 31 {\n\
    \        return false;\n    }\n\n    if month == 2 && day > 29 {\n        return\
    \ false;\n    }\n\n    if day > 30 && (month == 4 || month == 6 || month == 9\
    \ || month == 11) {\n        return false;\n    }\n\n    if year < 1 {\n     \
    \   return false;\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    date_regex.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpjscqzwxb.rs:9:22\n\
    \  |\n9 |     let date_regex = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n  |                      ^^^^^ use of undeclared type `Regex`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821433
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if !date.is_empty() {\n        let\
    \ mut s = date.split(\"-\");\n        let m: i32 = s.next().unwrap().parse().unwrap();\n\
    \        let d: i32 = s.next().unwrap().parse().unwrap();\n        let y: i32\
    \ = s.next().unwrap().parse().unwrap();\n        match m {\n            1 => {\n\
    \                if d > 0 && d < 32 {\n                    return true;\n    \
    \            }\n            }\n            2 => {\n                if d > 0 &&\
    \ d < 30 {\n                    return true;\n                }\n            }\n\
    \            3 => {\n                if d > 0 && d < 32 {\n                  \
    \  return true;\n                }\n            }\n            4 => {\n      \
    \          if d > 0 && d < 31 {\n                    return true;\n          \
    \      }\n            }\n            5 => {\n                if d > 0 && d < 32\
    \ {\n                    return true;\n                }\n            }\n    \
    \        6 => {\n                if d > 0 && d < 31 {\n                    return\
    \ true;\n                }\n            }\n            7 => {\n              \
    \  if d > 0 && d < 32 {\n                    return true;\n                }\n\
    \            }\n            8 => {\n                if d > 0 && d < 32 {\n   \
    \                 return true;\n                }\n            }\n           \
    \ 9 => {\n                if d > 0 && d < 31 {\n                    return true;\n\
    \                }\n            }\n            10 => {\n                if d >\
    \ 0 && d < 32 {\n                    return true;\n                }\n       \
    \     }\n            11 => {\n                if d > 0 && d < 31 {\n         \
    \           return true;\n                }\n            }\n            12 =>\
    \ {\n                if d > 0 && d < 32 {\n                    return true;\n\
    \                }\n            }\n            _ => {\n                return\
    \ false;\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp24okvqoa.rs:12:31

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut s = String::from(date);\n \
    \   if s.len() == 0 {\n        return false;\n    }\n    s.pop();\n    s.pop();\n\
    \    let y = s.parse::<i32>().unwrap();\n    s.pop();\n    s.pop();\n    let d\
    \ = s.parse::<i32>().unwrap();\n    s.pop();\n    s.pop();\n    let m = s.parse::<i32>().unwrap();\n\
    \    if m <= 0 || m > 12 {\n        return false;\n    }\n    if y < 0 {\n   \
    \     return false;\n    }\n    if m == 2 {\n        if d <= 0 || d > 29 {\n \
    \           return false;\n        }\n    } else if m == 1 || m == 3 || m == 5\
    \ || m == 7 || m == 8 || m == 10 || m == 12 {\n        if d <= 0 || d > 31 {\n\
    \            return false;\n        }\n    } else {\n        if d <= 0 || d >\
    \ 30 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpytsiu_16.rs:15:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    const DAYS_31: [u8; 7] = [1, 3, 5,\
    \ 7, 8, 10, 12];\n    const DAYS_30: [u8; 4] = [4, 6, 9, 11];\n\n    let parts:\
    \ Vec<&str> = date.split('-').collect();\n    if parts.len() != 3 {\n        return\
    \ false;\n    }\n\n    let mut parts_iter = parts.iter();\n    let month = parts_iter.next().unwrap();\n\
    \    let day = parts_iter.next().unwrap();\n    let year = parts_iter.next().unwrap();\n\
    \n    let d_month = month.parse::<u8>().unwrap();\n    let d_day = day.parse::<u8>().unwrap();\n\
    \    let d_year = year.parse::<u16>().unwrap();\n\n    if d_month < 1 || d_month\
    \ > 12 {\n        return false;\n    }\n\n    let max_days = if DAYS_31.contains(&d_month)\
    \ {\n        31\n    } else if DAYS_30.contains(&d_month) {\n        30\n    }\
    \ else {\n        if d_year % 4 == 0 {\n            29\n        } else {\n   \
    \         28\n        }\n    };\n\n    if d_day < 1 || d_day > max_days {\n  \
    \      return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: PosOverflow }'', /tmp/tmp0l92xxfk.rs:22:39

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut splitted = date.split('-');\n\
    \    let mm = splitted.next().unwrap().parse::<u8>().unwrap();\n    let dd = splitted.next().unwrap().parse::<u8>().unwrap();\n\
    \    let yyyy = splitted.next().unwrap().parse::<u16>().unwrap();\n    if mm >\
    \ 12 || dd < 1 || dd > 31 || yyyy < 1 {\n        return false;\n    }\n    if\
    \ mm == 2 {\n        if dd > 29 {\n            return false;\n        }\n    }\
    \ else if mm == 4 || mm == 6 || mm == 9 || mm == 11 {\n        if dd > 30 {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmpckhq_lc9.rs:10:53

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let split_date: Vec<&str> = date.split(\"\
    -\").collect();\n    let month: u32 = split_date[0].parse().unwrap();\n    let\
    \ day: u32 = split_date[1].parse().unwrap();\n    let year: u32 = split_date[2].parse().unwrap();\n\
    \n    match month {\n        1 => {\n            if day > 31 {\n             \
    \   return false;\n            }\n        }\n        2 => {\n            if day\
    \ > 29 {\n                return false;\n            }\n        }\n        3 =>\
    \ {\n            if day > 31 {\n                return false;\n            }\n\
    \        }\n        4 => {\n            if day > 30 {\n                return\
    \ false;\n            }\n        }\n        5 => {\n            if day > 31 {\n\
    \                return false;\n            }\n        }\n        6 => {\n   \
    \         if day > 30 {\n                return false;\n            }\n      \
    \  }\n        7 => {\n            if day > 31 {\n                return false;\n\
    \            }\n        }\n        8 => {\n            if day > 31 {\n       \
    \         return false;\n            }\n        }\n        9 => {\n          \
    \  if day > 30 {\n                return false;\n            }\n        }\n  \
    \      10 => {\n            if day > 31 {\n                return false;\n   \
    \         }\n        }\n        11 => {\n            if day > 30 {\n         \
    \       return false;\n            }\n        }\n        12 => {\n           \
    \ if day > 31 {\n                return false;\n            }\n        }\n   \
    \     _ => return false,\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6bm292j3.rs:85:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut parts = date.split(\"-\");\n\
    \    if parts.clone().count() != 3 {\n        return false;\n    }\n    let year\
    \ = u32::from_str(parts.next().unwrap()).unwrap();\n    let month = u32::from_str(parts.next().unwrap()).unwrap();\n\
    \    let day = u32::from_str(parts.next().unwrap()).unwrap();\n    let mut max_days\
    \ = 31;\n    if month == 2 {\n        max_days = 28;\n        if year % 4 == 0\
    \ {\n            max_days = 29;\n        }\n    } else if month == 4 || month\
    \ == 6 || month == 9 || month == 11 {\n        max_days = 30;\n    }\n    if month\
    \ < 1 || month > 12 || day < 1 || day > max_days {\n        return false;\n  \
    \  }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_str` found for\
    \ type `u32` in the current scope\n  --> /tmp/tmpet5z5sa5.rs:13:21\n   |\n13 |\
    \     let year = u32::from_str(parts.next().unwrap()).unwrap();\n   |        \
    \             ^^^^^^^^ function or associated item not found in `u32`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function or\
    \ associated item named `from_str` found for type `u32` in the current scope\n\
    \  --> /tmp/tmpet5z5sa5.rs:14:22\n   |\n14 |     let month = u32::from_str(parts.next().unwrap()).unwrap();\n\
    \   |                      ^^^^^^^^ function or associated item not found in `u32`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function\
    \ or associated item named `from_str` found for type `u32` in the current scope\n\
    \  --> /tmp/tmpet5z5sa5.rs:15:20\n   |\n15 |     let day = u32::from_str(parts.next().unwrap()).unwrap();\n\
    \   |                    ^^^^^^^^ function or associated item not found in `u32`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut parts = date.split(\"-\");\n    let month = parts.next().unwrap().parse::<u32>().unwrap();\n\
    \    let day = parts.next().unwrap().parse::<u32>().unwrap();\n    let year =\
    \ parts.next().unwrap().parse::<u32>().unwrap();\n\n    match month {\n      \
    \  1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n  \
    \              return false;\n            }\n        }\n        4 | 6 | 9 | 11\
    \ => {\n            if day < 1 || day > 30 {\n                return false;\n\
    \            }\n        }\n        2 => {\n            if day < 1 || day > 29\
    \ {\n                return false;\n            }\n        }\n        _ => {\n\
    \            return false;\n        }\n    }\n\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpzn8bp6_e.rs:15:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    use std::str::FromStr;\n    use std::num::ParseIntError;\n\
    \n    if date.len() == 0 {\n        return false;\n    }\n\n    let parts: Vec<&str>\
    \ = date.split('-').collect();\n    if parts.len() != 3 {\n        return false;\n\
    \    }\n\n    let month: Result<i32, ParseIntError> = FromStr::from_str(parts[0]);\n\
    \    let day: Result<i32, ParseIntError> = FromStr::from_str(parts[1]);\n    let\
    \ year: Result<i32, ParseIntError> = FromStr::from_str(parts[2]);\n\n    if month.is_err()\
    \ || day.is_err() || year.is_err() {\n        return false;\n    }\n\n    if day.unwrap()\
    \ <= 0 || day.unwrap() > 31 {\n        return false;\n    }\n\n    if month.unwrap()\
    \ < 1 || month.unwrap() > 12 {\n        return false;\n    }\n\n    if month.unwrap()\
    \ == 2 && day.unwrap() > 29 {\n        return false;\n    }\n\n    if (month.unwrap()\
    \ == 4 || month.unwrap() == 6 || month.unwrap() == 9 || month.unwrap() == 11)\
    \ && day.unwrap() > 30 {\n        return false;\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `day`\n    --> /tmp/tmpxdydehws.rs:29:29\n\
    \     |\n22   |     let day: Result<i32, ParseIntError> = FromStr::from_str(parts[1]);\n\
    \     |         --- move occurs because `day` has type `Result<i32, ParseIntError>`,\
    \ which does not implement the `Copy` trait\n...\n29   |     if day.unwrap() <=\
    \ 0 || day.unwrap() > 31 {\n     |            --------         ^^^ value used\
    \ here after move\n     |            |\n     |            `day` moved due to this\
    \ method call\n     |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `day`\nhelp: consider calling `.as_ref()` to borrow the type's contents\n\
    \     |\n29   |     if day.as_ref().unwrap() <= 0 || day.unwrap() > 31 {\n   \
    \  |            +++++++++\n\nerror[E0382]: use of moved value: `month`\n  -->\
    \ /tmp/tmpxdydehws.rs:33:30\n   |\n21 |     let month: Result<i32, ParseIntError>\
    \ = FromStr::from_str(parts[0]);\n   |         ----- move occurs because `month`\
    \ has type `Result<i32, ParseIntError>`, which does not implement the `Copy` trait\n\
    ...\n33 |     if month.unwrap() < 1 || month.unwrap() > 12 {\n   |           \
    \   --------        ^^^^^ value used here after move\n   |              |\n  \
    \ |              `month` moved due to this method call\n   |\nhelp: consider calling\
    \ `.as_ref()` to borrow the type's contents\n   |\n33 |     if month.as_ref().unwrap()\
    \ < 1 || month.unwrap() > 12 {\n   |              +++++++++\n\nerror[E0382]: use\
    \ of moved value: `month`\n  --> /tmp/tmpxdydehws.rs:37:8\n   |\n21 |     let\
    \ month: Result<i32, ParseIntError> = FromStr::from_str(parts[0]);\n   |     \
    \    ----- move occurs because `month` has type `Result<i32, ParseIntError>`,\
    \ which does not implement the `Copy` trait\n...\n33 |     if month.unwrap() <\
    \ 1 || month.unwrap() > 12 {\n   |              --------              --------\
    \ `month` moved due to this method call\n   |              |\n   |           \
    \   `month` moved due to this method call\n...\n37 |     if month.unwrap() ==\
    \ 2 && day.unwrap() > 29 {\n   |        ^^^^^ value used here after move\n   |\n\
    help: consider calling `.as_ref()` to bor"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut result = true;\n    let month_days\
    \ = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    let v: Vec<&str> =\
    \ date.split('-').collect();\n    let month: u8 = v[0].parse().unwrap();\n   \
    \ let day: u8 = v[1].parse().unwrap();\n    let year: u16 = v[2].parse().unwrap();\n\
    \    let mut leap_year = false;\n    if (year % 4 == 0 && year % 100 != 0) ||\
    \ year % 400 == 0 {\n        leap_year = true;\n    }\n    if month < 1 || month\
    \ > 12 {\n        result = false;\n    } else if day < 1 || day > month_days[(month\
    \ - 1) as usize] {\n        result = false;\n    } else if month == 2 && day ==\
    \ 29 && !leap_year {\n        result = false;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmp2byjnb74.rs:12:34

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    unimplemented!(\"Determine if the date\
    \ {} is valid.\", date);\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: Determine if the date 03-11-2000
    is valid.'', /tmp/tmpaneb6azi.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ RE: Regex = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n    }\n    RE.is_match(&date)\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpmk355hi6.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmpmk355hi6.rs:12:5\n   |\n12 |     RE.is_match(&date)\n\
    \   |     ^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let split: Vec<&str> = date.split(\"-\").collect();\n   \
    \ let (m, d, y) = (split[0].parse::<i32>().unwrap(), split[1].parse::<i32>().unwrap(),\
    \ split[2].parse::<i32>().unwrap());\n    if m < 1 || m > 12 {\n        return\
    \ false;\n    }\n    if d < 1 || d > 31 {\n        return false;\n    }\n    if\
    \ m == 4 || m == 6 || m == 9 || m == 11 {\n        if d > 30 {\n            return\
    \ false;\n        }\n    }\n    if m == 2 {\n        if d > 29 {\n           \
    \ return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpkcrq7tvr.rs:13:56

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    if v[0].len() != 2 ||\
    \ v[1].len() != 2 || v[2].len() != 4 {\n        return false;\n    }\n    let\
    \ month: u32 = v[0].parse().unwrap();\n    let day: u32 = v[1].parse().unwrap();\n\
    \    let year: u32 = v[2].parse().unwrap();\n    if (month == 1 || month == 3\
    \ || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) &&\
    \ (day > 31 || day < 1) {\n        return false;\n    }\n    if (month == 4 ||\
    \ month == 6 || month == 9 || month == 11) && (day > 30 || day < 1) {\n      \
    \  return false;\n    }\n    if month == 2 && year % 4 == 0 && day > 29 {\n  \
    \      return false;\n    }\n    if month == 2 && year % 4 != 0 && day > 28 {\n\
    \        return false;\n    }\n    if month > 12 || month < 1 {\n        return\
    \ false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n    re.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpghy6vk0l.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = regex::Regex::new(r\"\
    (0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}\").unwrap();\n    let matched\
    \ = date_regex.is_match(&date);\n    if !matched {\n        return false;\n  \
    \  }\n    let split_date: Vec<&str> = date.split(\"-\").collect();\n    let month:\
    \ u32 = split_date[0].parse().unwrap();\n    let day: u32 = split_date[1].parse().unwrap();\n\
    \    if month == 2 {\n        if day > 29 {\n            return false;\n     \
    \   }\n    } else if month <= 7 {\n        if month % 2 == 0 && day > 30 {\n \
    \           return false;\n        } else if month % 2 != 0 && day > 31 {\n  \
    \          return false;\n        }\n    } else if month > 7 {\n        if month\
    \ % 2 == 0 && day > 31 {\n            return false;\n        } else if month %\
    \ 2 != 0 && day > 30 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \ --> /tmp/tmp1v8zoiyb.rs:9:22\n  |\n9 |     let date_regex = regex::Regex::new(r\"\
    (0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}\").unwrap();\n  |        \
    \              ^^^^^ use of undeclared crate or module `regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    if date.len() != 10 {\n        return false;\n    }\n\n\
    \    let mut date_nums: Vec<u32> = Vec::new();\n    let mut tmp_str = String::new();\n\
    \    for c in date.chars() {\n        if c == '-' {\n            date_nums.push(tmp_str.parse::<u32>().unwrap());\n\
    \            tmp_str = String::new();\n        } else {\n            tmp_str.push(c);\n\
    \        }\n    }\n    date_nums.push(tmp_str.parse::<u32>().unwrap());\n\n  \
    \  if date_nums.len() != 3 {\n        return false;\n    }\n\n    if date_nums[0]\
    \ < 1 || date_nums[0] > 12 {\n        return false;\n    }\n\n    if date_nums[1]\
    \ < 1 || date_nums[1] > 31 {\n        return false;\n    }\n\n    match date_nums[0]\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => if date_nums[1] > 31 {\n         \
    \   return false;\n        },\n        4 | 6 | 9 | 11 => if date_nums[1] > 30\
    \ {\n            return false;\n        },\n        2 => if date_nums[1] > 29\
    \ {\n            return false;\n        },\n        _ => return false,\n    }\n\
    \n    if date_nums[2] < 1000 || date_nums[2] > 9999 {\n        return false;\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut iter = date.split(\"-\");\n\
    \    let mut nums = vec![];\n    for s in iter {\n        match s.parse::<i32>()\
    \ {\n            Ok(i) => nums.push(i),\n            Err(_) => return false,\n\
    \        }\n    }\n    if nums.len() != 3 {\n        return false;\n    }\n  \
    \  let mut max_day = 31;\n    match nums[0] {\n        2 => max_day = 29,\n  \
    \      4 | 6 | 9 | 11 => max_day = 30,\n        _ => {}\n    }\n    if nums[1]\
    \ < 1 || nums[1] > max_day {\n        return false;\n    }\n    if nums[2] < 1\
    \ || nums[2] > 31 {\n        return false;\n    }\n    if nums[0] < 1 || nums[0]\
    \ > 12 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpoj1uhttn.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut split = date.split('-');\n\
    \    let mm: i32 = split.next().unwrap().parse().unwrap();\n    let dd: i32 =\
    \ split.next().unwrap().parse().unwrap();\n    let yyyy: i32 = split.next().unwrap().parse().unwrap();\n\
    \    match mm {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            dd <= 31\
    \ && dd >= 1\n        },\n        4 | 6 | 9 | 11 => {\n            dd <= 30 &&\
    \ dd >= 1\n        },\n        2 => {\n            dd <= 29 && dd >= 1\n     \
    \   },\n        _ => false\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmpon3jswi1.rs:10:49

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_vec.len() != 3 {\n        return false;\n    }\n\n    let year =\
    \ date_vec[2].parse::<i32>().unwrap();\n    let month = date_vec[0].parse::<i32>().unwrap();\n\
    \    let day = date_vec[1].parse::<i32>().unwrap();\n\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n\n    if day < 1 || day > 31 {\n     \
    \   return false;\n    }\n\n    if month == 2 {\n        if day > 29 {\n     \
    \       return false;\n        }\n    } else if month == 4 || month == 6 || month\
    \ == 9 || month == 11 {\n        if day > 30 {\n            return false;\n  \
    \      }\n    }\n\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut date_iter = date.split(\"-\");\n    let month =\
    \ date_iter.next().unwrap().parse::<u8>().unwrap();\n    let day = date_iter.next().unwrap().parse::<u8>().unwrap();\n\
    \    let year = date_iter.next().unwrap().parse::<u16>().unwrap();\n\n    if year\
    \ < 1000 || year > 9999 {\n        return false;\n    }\n\n    if month < 1 ||\
    \ month > 12 {\n        return false;\n    }\n\n    if day < 1 || day > 31 {\n\
    \        return false;\n    }\n\n    match month {\n        2 => {\n         \
    \   if day > 29 {\n                return false;\n            }\n        }\n \
    \       4 | 6 | 9 | 11 => {\n            if day > 30 {\n                return\
    \ false;\n            }\n        }\n        _ => {}\n    }\n\n    true\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: PosOverflow }'', /tmp/tmpmx5hptpr.rs:14:57

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_parts: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_parts.len() != 3 {\n        return false;\n    }\n\
    \    let day = date_parts[1].parse::<i32>().unwrap();\n    let month = date_parts[0].parse::<i32>().unwrap();\n\
    \    let year = date_parts[2].parse::<i32>().unwrap();\n    if day < 1 || month\
    \ < 1 || year < 1 {\n        return false;\n    }\n    match month {\n       \
    \ 1 | 3 | 5 | 7 | 8 | 10 | 12 => day > 31,\n        4 | 6 | 9 | 11 => day > 30,\n\
    \        2 => {\n            if year % 400 == 0 || (year % 4 == 0 && year % 100\
    \ != 0) {\n                day > 29\n            } else {\n                day\
    \ > 28\n            }\n        }\n        _ => false,\n    }\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbqdrx6k1.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if !date.is_empty() {\n        let\
    \ new_date: Vec<&str> = date.split(\"-\").collect();\n        if new_date.len()\
    \ == 3 {\n            let year: i32 = new_date[2].parse().unwrap();\n        \
    \    let month: i32 = new_date[0].parse().unwrap();\n            let day: i32\
    \ = new_date[1].parse().unwrap();\n            if month > 0 && month < 13 {\n\
    \                if month == 1 || month == 3 || month == 5 || month == 7 || month\
    \ == 8 || month == 10 || month == 12 {\n                    if day > 0 && day\
    \ < 32 {\n                        return true;\n                    }\n      \
    \          } else if month == 4 || month == 6 || month == 9 || month == 11 {\n\
    \                    if day > 0 && day < 31 {\n                        return\
    \ true;\n                    }\n                } else if month == 2 {\n     \
    \               if year % 4 == 0 && year % 100 != 0 || year % 400 == 0 {\n   \
    \                     if day > 0 && day < 30 {\n                            return\
    \ true;\n                        }\n                    } else {\n           \
    \             if day > 0 && day < 29 {\n                            return true;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // TODO: Complete this function\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmptkjdu_2e.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut iter = date.split('-');\n \
    \   let month: u8 = iter.next().unwrap().parse().unwrap();\n    let day: u8 =\
    \ iter.next().unwrap().parse().unwrap();\n    let year: u16 = iter.next().unwrap().parse().unwrap();\n\
    \    if month > 12 || month < 1 {\n        return false;\n    }\n    match month\
    \ {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day > 31 || day\
    \ < 1 {\n                return false;\n            }\n        }\n        4 |\
    \ 6 | 9 | 11 => {\n            if day > 30 || day < 1 {\n                return\
    \ false;\n            }\n        }\n        2 => {\n            if day > 29 ||\
    \ day < 1 {\n                return false;\n            }\n        }\n       \
    \ _ => (),\n    }\n    if year < 1900 || year > 2100 {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmpi88wjxyf.rs:10:50

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n    if re.is_match(&date) {\n        let (month, day, year) = get_date_parts(&date);\n\
    \        if year >= 1000 && year <= 9999 {\n            match month {\n      \
    \          1 | 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n                4 | 6 |\
    \ 9 | 11 => day <= 30,\n                2 => day <= 29,\n                _ =>\
    \ false,\n            }\n        } else {\n            false\n        }\n    }\
    \ else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmprg2m9syy.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror[E0425]:\
    \ cannot find function `get_date_parts` in this scope\n  --> /tmp/tmprg2m9syy.rs:11:34\n\
    \   |\n11 |         let (month, day, year) = get_date_parts(&date);\n   |    \
    \                              ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_vector: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_vector.len() != 3 {\n        return false;\n    }\n\
    \    let day: u32 = match date_vector[1].parse() {\n        Ok(day) => day,\n\
    \        Err(_) => return false,\n    };\n    let month: u32 = match date_vector[0].parse()\
    \ {\n        Ok(month) => month,\n        Err(_) => return false,\n    };\n  \
    \  let year: u32 = match date_vector[2].parse() {\n        Ok(year) => year,\n\
    \        Err(_) => return false,\n    };\n    if year < 1582 || month < 1 || month\
    \ > 12 || day < 1 {\n        return false;\n    }\n    match month {\n       \
    \ 1 | 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n        4 | 6 | 9 | 11 => day <=\
    \ 30,\n        2 => {\n            if year % 4 == 0 {\n                day <=\
    \ 29\n            } else {\n                day <= 28\n            }\n       \
    \ }\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut split = date.split('-');\n\
    \    if let Some(month) = split.next() {\n        if let Some(day) = split.next()\
    \ {\n            if let Some(year) = split.next() {\n                if split.next().is_none()\
    \ {\n                    return month.parse::<u32>().ok().and_then(|m| {\n   \
    \                     Some(m >= 1 && m <= 12).and_then(|m| {\n               \
    \             Some(m && day.parse::<u32>().ok().and_then(|d| {\n             \
    \                   Some(d >= 1 && d <= 31).and_then(|d| {\n                 \
    \                   Some(d && year.parse::<u32>().ok().is_some())\n          \
    \                      })\n                            }))\n                 \
    \       })\n                    }).unwrap_or(false);\n                }\n    \
    \        }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph0efxxsm.rs:16:39\n   |\n\
    16 |   ...                   Some(m && day.parse::<u32>().ok().and_then(|d| {\n\
    \   |  _________________________________^\n17 | | ...                       Some(d\
    \ >= 1 && d <= 31).and_then(|d| {\n18 | | ...                           Some(d\
    \ && year.parse::<u32>().ok().is_some())\n19 | | ...                       })\n\
    20 | | ...                   }))\n   | |________________________^ expected `bool`,\
    \ found enum `Option`\n   |\n   = note: expected type `bool`\n              found\
    \ enum `Option<bool>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut parts = date.split(\"-\");\n\
    \    if parts.clone().count() != 3 {\n        return false;\n    }\n    let month\
    \ = parts.next().unwrap().parse::<u8>().unwrap();\n    let day = parts.next().unwrap().parse::<u8>().unwrap();\n\
    \    let year = parts.next().unwrap().parse::<u16>().unwrap();\n    if month <\
    \ 1 || month > 12 {\n        return false;\n    }\n    if year < 1000 || year\
    \ > 9999 {\n        return false;\n    }\n    match month {\n        1 | 3 | 5\
    \ | 7 | 8 | 10 | 12 => {\n            if day < 1 || day > 31 {\n             \
    \   return false;\n            }\n        }\n        4 | 6 | 9 | 11 => {\n   \
    \         if day < 1 || day > 30 {\n                return false;\n          \
    \  }\n        }\n        2 => {\n            if day < 1 || day > 29 {\n      \
    \          return false;\n            }\n        }\n        _ => return false,\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: PosOverflow }'', /tmp/tmpvzpequgk.rs:13:53

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let months = [31, 28, 31, 30, 31, 30,\
    \ 31, 31, 30, 31, 30, 31];\n    let parts: Vec<&str> = date.split('-').collect();\n\
    \    if parts.len() != 3 {\n        return false;\n    }\n    let year: i32 =\
    \ match parts[2].parse() {\n        Ok(n) => n,\n        Err(_) => return false,\n\
    \    };\n    let month: i32 = match parts[0].parse() {\n        Ok(n) => n,\n\
    \        Err(_) => return false,\n    };\n    let day: i32 = match parts[1].parse()\
    \ {\n        Ok(n) => n,\n        Err(_) => return false,\n    };\n    if year\
    \ < 1 {\n        return false;\n    }\n    if month < 1 || month > 12 {\n    \
    \    return false;\n    }\n    if day < 1 || day > months[(month - 1) as usize]\
    \ {\n        return false;\n    }\n    if month == 2 && day == 29 && year % 4\
    \ != 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = regex::Regex::new(r\"\
    ([0-9]{2})-([0-9]{2})-([0-9]{4})\").unwrap();\n    let date_captures = date_regex.captures(&date).unwrap();\n\
    \    let month = date_captures[1].parse::<u32>().unwrap();\n    let day = date_captures[2].parse::<u32>().unwrap();\n\
    \    let year = date_captures[3].parse::<u32>().unwrap();\n    match month {\n\
    \        1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            return day <= 31 && month\
    \ <= 12 && day > 0 && month > 0 && day <= 31\n        }\n        4 | 6 | 9 | 11\
    \ => {\n            return day <= 30 && month <= 12 && day > 0 && month > 0 &&\
    \ day <= 30\n        }\n        2 => {\n            if is_leap_year(year) {\n\
    \                return day <= 29 && month <= 12 && day > 0 && month > 0 && day\
    \ <= 29\n            } else {\n                return day <= 28 && month <= 12\
    \ && day > 0 && month > 0 && day <= 28\n            }\n        }\n        _ =>\
    \ return false,\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n  \
    \  assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \ --> /tmp/tmp99o2a0a5.rs:9:22\n  |\n9 |     let date_regex = regex::Regex::new(r\"\
    ([0-9]{2})-([0-9]{2})-([0-9]{4})\").unwrap();\n  |                      ^^^^^\
    \ use of undeclared crate or module `regex`\n\nerror[E0425]: cannot find function\
    \ `is_leap_year` in this scope\n  --> /tmp/tmp99o2a0a5.rs:22:16\n   |\n22 |  \
    \           if is_leap_year(year) {\n   |                ^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_vec: Vec<&str> = date.split(\"\
    -\").collect();\n    match date_vec.len() {\n        3 => {\n            let month\
    \ = date_vec[0].parse::<i32>().unwrap();\n            let day = date_vec[1].parse::<i32>().unwrap();\n\
    \            let year = date_vec[2].parse::<i32>().unwrap();\n            return\
    \ month >= 1 && month <= 12 && day >= 1 && day <= 31 && year >= 1000 && year <=\
    \ 3000;\n        }\n        _ => return false,\n    }\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0_42oxfe.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let pattern = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    pattern.is_match(&date)\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmplv0bjnws.rs:9:19\n\
    \  |\n9 |     let pattern = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n  |                   ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    unimplemented!(\"is the string '{}'\
    \ a valid date?\", date);\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented: is the string ''03-11-2000''
    a valid date?'', /tmp/tmpwdyxy2dv.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^\\d{2}-\\d{2}-\\\
    d{4}$\").unwrap();\n    if !re.is_match(&date) {\n        return false;\n    }\n\
    \    let arr: Vec<&str> = date.split(\"-\").collect();\n    let days = arr[1].parse::<u32>().unwrap();\n\
    \    let months = arr[0].parse::<u32>().unwrap();\n    let years = arr[2].parse::<u32>().unwrap();\n\
    \    match months {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => days <= 31,\n    \
    \    4 | 6 | 9 | 11 => days <= 30,\n        2 => days <= 29,\n        _ => false,\n\
    \    } && (months > 0 && months <= 12) && years > 0\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpej75vx5b.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n  |\
    \              ^^^^^ use of undeclared type `Regex`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpej75vx5b.rs:17:5\n   |\n17 | /     match months {\n18 |\
    \ |         1 | 3 | 5 | 7 | 8 | 10 | 12 => days <= 31,\n19 | |         4 | 6 |\
    \ 9 | 11 => days <= 30,\n20 | |         2 => days <= 29,\n21 | |         _ =>\
    \ false,\n22 | |     } && (months > 0 && months <= 12) && years > 0\n   | |  \
    \   ^- help: consider using a semicolon here\n   | |_____|\n   |       expected\
    \ `()`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpej75vx5b.rs:22:7\n\
    \   |\n22 |     } && (months > 0 && months <= 12) && years > 0\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `&&bool`\n   |\nhelp: parentheses are required to parse\
    \ this as an expression\n   |\n17 ~     (match months {\n18 |         1 | 3 |\
    \ 5 | 7 | 8 | 10 | 12 => days <= 31,\n19 |         4 | 6 | 9 | 11 => days <= 30,\n\
    20 |         2 => days <= 29,\n21 |         _ => false,\n22 ~     }) && (months\
    \ > 0 && months <= 12) && years > 0\n   |\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut elements = date.split('-');\n\
    \    let month = match elements.next() {\n        Some(month) => match month.parse::<i32>()\
    \ {\n            Ok(month) => month,\n            Err(_) => return false,\n  \
    \      },\n        None => return false,\n    };\n    let day = match elements.next()\
    \ {\n        Some(day) => match day.parse::<i32>() {\n            Ok(day) => day,\n\
    \            Err(_) => return false,\n        },\n        None => return false,\n\
    \    };\n    let year = match elements.next() {\n        Some(year) => match year.parse::<i32>()\
    \ {\n            Ok(year) => year,\n            Err(_) => return false,\n    \
    \    },\n        None => return false,\n    };\n    if year < 0 {\n        return\
    \ false;\n    }\n    if month < 1 || month > 12 {\n        return false;\n   \
    \ }\n    if day < 1 {\n        return false;\n    }\n    if month == 2 {\n   \
    \     if year % 4 == 0 {\n            if day > 29 {\n                return false;\n\
    \            }\n        } else {\n            if day > 28 {\n                return\
    \ false;\n            }\n        }\n    } else if month == 4 || month == 6 ||\
    \ month == 9 || month == 11 {\n        if day > 30 {\n            return false;\n\
    \        }\n    } else {\n        if day > 31 {\n            return false;\n \
    \       }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3[0-1]))-((19|20)[0-9]{2})$\"\
    ).unwrap();\n    let matched = re.is_match(&date);\n    matched\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp9kkfdsha.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^((0[1-9])|(1[0-2]))-((0[1-9])|([1-2][0-9])|(3[0-1]))-((19|20)[0-9]{2})$\"\
    ).unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let components: Vec<&str> = date.split(\"\
    -\").collect();\n    if components.len() != 3 {\n        return false;\n    }\n\
    \    let day = components[1].parse::<u32>().unwrap();\n    let month = components[0].parse::<u32>().unwrap();\n\
    \    if month == 0 || month > 12 {\n        return false;\n    }\n    if day ==\
    \ 0 {\n        return false;\n    }\n    if month == 2 {\n        if day > 29\
    \ {\n            return false;\n        }\n    } else if month == 4 || month ==\
    \ 6 || month == 9 || month == 11 {\n        if day > 30 {\n            return\
    \ false;\n        }\n    } else {\n        if day > 31 {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}\"\
    ).unwrap();\n    let date_in_year_regex = Regex::new(r\"(0[13578]|1[02])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}\"\
    ).unwrap();\n    let date_in_month_regex = Regex::new(r\"(0[469]|11)-(0[1-9]|[1-2][0-9]|30)-[0-9]{4}\"\
    ).unwrap();\n    let date_in_feb_regex = Regex::new(r\"02-(0[1-9]|1[0-9]|2[0-8])-[0-9]{4}\"\
    ).unwrap();\n    let date_in_leap_year_regex = Regex::new(r\"02-29-[0-9]{4}\"\
    ).unwrap();\n    let date_in_non_leap_year_regex = Regex::new(r\"02-29-[0-9]{4}\"\
    ).unwrap();\n\n    match date_regex.is_match(&date) {\n        true => {\n   \
    \         match date_in_year_regex.is_match(&date) {\n                true =>\
    \ true,\n                false => {\n                    match date_in_month_regex.is_match(&date)\
    \ {\n                        true => true,\n                        false => {\n\
    \                            match date_in_feb_regex.is_match(&date) {\n     \
    \                           true => true,\n                                false\
    \ => {\n                                    match date_in_leap_year_regex.is_match(&date)\
    \ {\n                                        true => {\n                     \
    \                       let y: Vec<&str> = date.split(\"-\").collect();\n    \
    \                                        let year: i32 = y[2].parse().unwrap();\n\
    \                                            if year % 4 == 0 {\n\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpln8p6f9p.rs:53:3\n\
    \   |\n8  | fn valid_date(date: String) -> bool {\n   |                      \
    \               - unclosed delimiter\n...\n16 |     match date_regex.is_match(&date)\
    \ {\n   |                                      - unclosed delimiter\n17 |    \
    \     true => {\n   |                 - unclosed delimiter\n18 |             match\
    \ date_in_year_regex.is_match(&date) {\n   |                                 \
    \                     - unclosed delimiter\n19 |                 true => true,\n\
    20 |                 false => {\n   |                          - unclosed delimiter\n\
    21 |                     match date_in_month_regex.is_match(&date) {\n   |   \
    \                                                            - unclosed delimiter\n\
    22 |                         true => true,\n23 |                         false\
    \ => {\n   |                                  - unclosed delimiter\n24 |     \
    \                        match date_in_feb_regex.is_match(&date) {\n   |     \
    \                                                                - unclosed delimiter\n\
    25 |                                 true => true,\n26 |                     \
    \            false => {\n   |                                          - unclosed\
    \ delimiter\n27 |                                     match date_in_leap_year_regex.is_match(&date)\
    \ {\n   |                                                                    \
    \               - unclosed delimiter\n28 |                                   \
    \      true => {\n   |                                                 - unclosed\
    \ delimiter\n...\n31 |                                             if year % 4\
    \ == 0 {\n   |                                                              -\
    \ this delimiter might not be properly closed...\n32 | \n33 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n53 | }\n   |   ^\n\n\
    error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpln8p6f9p.rs:9:22\n\
    \  |\n9 |     let date_regex = Regex::new(r\"(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let year = date[6..].parse::<i32>().unwrap();\n\
    \    let month = date[0..2].parse::<i32>().unwrap();\n    let day = date[3..5].parse::<i32>().unwrap();\n\
    \    if year >= 0 && year <= 3000 &&\n       month >= 1 && month <= 12 &&\n  \
    \     day >= 1 &&\n       ((month == 1 || month == 3 || month == 5 || month ==\
    \ 7 || month == 8 || month == 10 || month == 12) && day <= 31) ||\n       ((month\
    \ == 4 || month == 6 || month == 9 || month == 11) && day <= 30) ||\n       (month\
    \ == 2 && day <= 29)\n    {\n        return true;\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmptrfd1ie3.rs:11:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    match date.split(\"-\").collect::<Vec<&str>>().as_slice()\
    \ {\n        [month, day, year] => {\n            if year.len() != 4 {\n     \
    \           return false;\n            }\n            let month = match month.parse::<u32>()\
    \ {\n                Ok(v) => v,\n                Err(_) => return false,\n  \
    \          };\n            let day = match day.parse::<u32>() {\n            \
    \    Ok(v) => v,\n                Err(_) => return false,\n            };\n  \
    \          match month {\n                1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n \
    \                   if day < 1 || day > 31 {\n                        return false;\n\
    \                    }\n                }\n                4 | 6 | 9 | 11 => {\n\
    \                    if day < 1 || day > 30 {\n                        return\
    \ false;\n                    }\n                }\n                2 => {\n \
    \                   if day < 1 || day > 29 {\n                        return false;\n\
    \                    }\n                }\n                _ => return false,\n\
    \            }\n            true\n        }\n        _ => false,\n    }\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() != 10 {\n        return\
    \ false;\n    }\n    let re = Regex::new(r\"(\\d{2})-(\\d{2})-(\\d{4})\").unwrap();\n\
    \    if !re.is_match(&date) {\n        return false;\n    }\n    let v: Vec<&str>\
    \ = date.split(\"-\").collect();\n    let month: i32 = v[0].parse().unwrap();\n\
    \    let day: i32 = v[1].parse().unwrap();\n    let year: i32 = v[2].parse().unwrap();\n\
    \    if year < 0 {\n        return false;\n    }\n    if month > 12 || month <\
    \ 1 {\n        return false;\n    }\n    if month == 2 {\n        if day > 29\
    \ || day < 1 {\n            return false;\n        }\n    } else if month == 4\
    \ || month == 6 || month == 9 || month == 11 {\n        if day > 30 || day < 1\
    \ {\n            return false;\n        }\n    } else {\n        if day > 31 ||\
    \ day < 1 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmp88u9t3wo.rs:12:14\n   |\n12 |     let re = Regex::new(r\"(\\d{2})-(\\\
    d{2})-(\\d{4})\").unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // #1\n    if date.len() == 0 {\n \
    \       return false;\n    }\n\n    // #2\n    let split: Vec<&str> = date.split(\"\
    -\").collect();\n    if split.len() != 3 {\n        return false;\n    }\n\n \
    \   let month = split[0].parse::<u32>().unwrap();\n    let day = split[1].parse::<u32>().unwrap();\n\
    \    let year = split[2].parse::<u32>().unwrap();\n\n    if year < 1000 || year\
    \ > 9999 {\n        return false;\n    }\n\n    if !(1..=12).contains(&month)\
    \ {\n        return false;\n    }\n\n    if month == 2 {\n        return (1..=29).contains(&day);\n\
    \    }\n\n    if (1..=7).contains(&month) {\n        if month % 2 == 0 {\n   \
    \         return (1..=30).contains(&day);\n        } else {\n            return\
    \ (1..=31).contains(&day);\n        }\n    }\n\n    if (7..=12).contains(&month)\
    \ {\n        if month % 2 == 0 {\n            return (1..=31).contains(&day);\n\
    \        } else {\n            return (1..=30).contains(&day);\n        }\n  \
    \  }\n\n    return false;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let split_date: Vec<&str> = date.split(\"-\").collect();\n\
    \    if split_date.len() != 3 {\n        return false;\n    }\n\n    let year:\
    \ u32 = split_date[2].parse().unwrap();\n    let month: u32 = split_date[0].parse().unwrap();\n\
    \    let day: u32 = split_date[1].parse().unwrap();\n\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n\n    if month == 2 {\n        if day\
    \ < 1 || day > 29 {\n            return false;\n        }\n    } else if month\
    \ == 4 || month == 6 || month == 9 || month == 11 {\n        if day < 1 || day\
    \ > 30 {\n            return false;\n        }\n    } else {\n        if day <\
    \ 1 || day > 31 {\n            return false;\n        }\n    }\n\n    return true;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let words: Vec<&str> = date.split('-').collect();\n\
    \    match words.len() {\n        3 => match (words[0].parse::<i32>(), words[1].parse::<i32>(),\
    \ words[2].parse::<i32>()) {\n            (Ok(month), Ok(day), Ok(year)) => match\
    \ month {\n                2 => day >= 1 && day <= 29,\n                4 | 6\
    \ | 9 | 11 => day >= 1 && day <= 30,\n                1 | 3 | 5 | 7 | 8 | 10 |\
    \ 12 => day >= 1 && day <= 31,\n                _ => false,\n            },\n\
    \            _ => false,\n        },\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_vec: Vec<_> = date.split(\"\
    -\").collect();\n    let month: u32 = date_vec[0].parse().unwrap();\n    let day:\
    \ u32 = date_vec[1].parse().unwrap();\n    let year: u32 = date_vec[2].parse().unwrap();\n\
    \    match month {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => if day < 1 || day >\
    \ 31 {\n            return false;\n        },\n        4 | 6 | 9 | 11 => if day\
    \ < 1 || day > 30 {\n            return false;\n        },\n        2 => if day\
    \ < 1 || day > 29 {\n            return false;\n        },\n        _ => return\
    \ false,\n    }\n    if month < 1 || month > 12 {\n        return false;\n   \
    \ }\n    if year < 1000 || year > 9999 {\n        return false;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmpmb2nsi7p.rs:10:42

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpedv_wueo.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_iter = date.split('-');\n\
    \    let mut date_splitted = Vec::new();\n    for item in date_iter {\n      \
    \  match item.parse::<i32>() {\n            Ok(num) => date_splitted.push(num),\n\
    \            Err(_) => return false,\n        }\n    }\n    if date_splitted.len()\
    \ != 3 {\n        return false;\n    }\n    let (month, day, year) = (date_splitted[0],\
    \ date_splitted[1], date_splitted[2]);\n    if month < 1 || month > 12 {\n   \
    \     return false;\n    }\n    match month {\n        4 | 6 | 9 | 11 => {\n \
    \           if day < 1 || day > 30 {\n                return false;\n        \
    \    }\n        }\n        2 => {\n            if day < 1 || day > 29 {\n    \
    \            return false;\n            }\n        }\n        _ => {\n       \
    \     if day < 1 || day > 31 {\n                return false;\n            }\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    use regex::Regex;\n    let re = Regex::new(r\"\
    (\\d{2})-(\\d{2})-(\\d{4})\").unwrap();\n    if !re.is_match(&date) {\n      \
    \  return false;\n    }\n    let caps = re.captures(&date).unwrap();\n    let\
    \ month = caps[1].parse::<u8>().unwrap();\n    let day = caps[2].parse::<u8>().unwrap();\n\
    \    let year = caps[3].parse::<u16>().unwrap();\n    // println!(\"{} {} {}\"\
    , month, day, year);\n    if year < 1000 || year > 9999 {\n        return false;\n\
    \    }\n    if month < 1 || month > 12 {\n        return false;\n    }\n    if\
    \ month == 2 {\n        if day < 1 || day > 29 {\n            return false;\n\
    \        }\n    } else if (month % 2 == 1 && month < 8) || (month % 2 == 0 &&\
    \ month > 7) {\n        if day < 1 || day > 31 {\n            return false;\n\
    \        }\n    } else {\n        if day < 1 || day > 30 {\n            return\
    \ false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `regex`\n --> /tmp/tmpzkzubtno.rs:9:9\n\
    \  |\n9 |     use regex::Regex;\n  |         ^^^^^ maybe a missing crate `regex`?\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0432`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut date_arr: Vec<_> = date.split(\"\
    -\").collect();\n    if date_arr.len() != 3 {\n        return false;\n    }\n\
    \    let mut year = date_arr.pop().unwrap().parse::<i32>().unwrap();\n    let\
    \ mut month = date_arr.pop().unwrap().parse::<i32>().unwrap();\n    let mut day\
    \ = date_arr.pop().unwrap().parse::<i32>().unwrap();\n    if day < 1 || month\
    \ < 1 || year < 1 {\n        return false;\n    }\n    if year < 100 {\n     \
    \   year += 2000;\n    } else if year < 1000 {\n        year += 1000;\n    }\n\
    \    let months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if month\
    \ > 12 {\n        return false;\n    }\n    if (year % 4 == 0 && year % 100 !=\
    \ 0) || year % 400 == 0 {\n        months[1] = 29;\n    }\n    if day > months[month\
    \ as usize - 1] {\n        return false;\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp3mx9g4u_.rs:14:9\n\
    \   |\n14 |     let mut month = date_arr.pop().unwrap().parse::<i32>().unwrap();\n\
    \   |         ----^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does\
    \ not need to be mutable\n  --> /tmp/tmp3mx9g4u_.rs:15:9\n   |\n15 |     let mut\
    \ day = date_arr.pop().unwrap().parse::<i32>().unwrap();\n   |         ----^^^\n\
    \   |         |\n   |         help: remove this `mut`\n\nerror[E0594]: cannot\
    \ assign to `months[_]`, as `months` is not declared as mutable\n  --> /tmp/tmp3mx9g4u_.rs:29:9\n\
    \   |\n24 |     let months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\
    \   |         ------ help: consider changing this to be mutable: `mut months`\n\
    ...\n29 |         months[1] = 29;\n   |         ^^^^^^^^^^^^^^ cannot assign\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_split: Vec<&str> = date.split(\"\
    -\").collect();\n    let day = date_split[1].parse::<i32>().unwrap();\n    let\
    \ month = date_split[0].parse::<i32>().unwrap();\n    let year = date_split[2].parse::<i32>().unwrap();\n\
    \    // TODO: year check\n    if day < 1 || month < 1 || day > 31 || month > 12\
    \ {\n        return false;\n    }\n    if month == 2 && day > 29 {\n        return\
    \ false;\n    }\n    if month == 4 || month == 6 || month == 9 || month == 11\
    \ {\n        if day > 30 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpf_1wqung.rs:10:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let parts: Vec<i32> = date\n      \
    \  .split('-')\n        .map(|s| s.parse::<i32>().unwrap())\n        .collect();\n\
    \    if parts.len() != 3 {\n        return false;\n    }\n    let month = parts[0];\n\
    \    let day = parts[1];\n    if month < 1 || month > 12 {\n        return false;\n\
    \    }\n    if day < 1 {\n        return false;\n    }\n    match month {\n  \
    \      1 | 3 | 5 | 7 | 8 | 10 | 12 => day <= 31,\n        4 | 6 | 9 | 11 => day\
    \ <= 30,\n        2 => day <= 29,\n        _ => false,\n    }\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmppu6aswtx.rs:11:35

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = Regex::new(r\"^\\\
    d{2}-\\d{2}-\\d{4}$\").unwrap();\n    if !date_regex.is_match(&date) {\n     \
    \   return false;\n    }\n    let mut parts = date.split(\"-\");\n    let m =\
    \ parts.next().unwrap().parse::<u32>().unwrap();\n    let d = parts.next().unwrap().parse::<u32>().unwrap();\n\
    \    let y = parts.next().unwrap().parse::<u32>().unwrap();\n    if m < 1 || m\
    \ > 12 {\n        return false;\n    }\n    let max_day = match m {\n        1\
    \ | 3 | 5 | 7 | 8 | 10 | 12 => 31,\n        4 | 6 | 9 | 11 => 30,\n        2 =>\
    \ {\n            if y % 4 == 0 {\n                29\n            } else {\n \
    \               28\n            }\n        }\n        _ => 0,\n    };\n    if\
    \ d < 1 || d > max_day {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpgpvys_n3.rs:9:22\n\
    \  |\n9 |     let date_regex = Regex::new(r\"^\\d{2}-\\d{2}-\\d{4}$\").unwrap();\n\
    \  |                      ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^([0-1]?[0-9])-([0-3]?[0-9])-([0-9]{4})$\"\
    ).unwrap();\n    re.is_match(&date)\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpi16f6leu.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^([0-1]?[0-9])-([0-3]?[0-9])-([0-9]{4})$\"\
    ).unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821434
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut it = date.split('-');\n   \
    \ let mut arr = [0; 3];\n    for i in 0..3 {\n        if let Some(x) = it.next()\
    \ {\n            if let Ok(x) = x.parse::<u8>() {\n                arr[i] = x;\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n    if arr[0] < 1 || arr[0]\
    \ > 12 {\n        return false;\n    }\n    if (arr[0] == 1 || arr[0] == 3 ||\
    \ arr[0] == 5 || arr[0] == 7 || arr[0] == 8 || arr[0] == 10 || arr[0] == 12) &&\
    \ (arr[1] < 1 || arr[1] > 31) {\n        return false;\n    }\n    if (arr[0]\
    \ == 4 || arr[0] == 6 || arr[0] == 9 || arr[0] == 11) && (arr[1] < 1 || arr[1]\
    \ > 30) {\n        return false;\n    }\n    if arr[0] == 2 && (arr[1] < 1 ||\
    \ arr[1] > 29) {\n        return false;\n    }\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg26f5d7v.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut result = true;\n    let strs:\
    \ Vec<&str> = date.split(\"-\").collect();\n    if strs.len() == 3 {\n       \
    \ let month = strs[0].parse::<i32>().unwrap();\n        let day = strs[1].parse::<i32>().unwrap();\n\
    \        let year = strs[2].parse::<i32>().unwrap();\n        if year >= 1900\
    \ && year <= 2200 {\n            if month >= 1 && month <= 12 {\n            \
    \    if day >= 1 && day <= 31 {\n                    if !(month == 2 && day ==\
    \ 29) {\n                        if !(month == 4 || month == 6 || month == 9 ||\
    \ month == 11) {\n                            if day == 31 {\n               \
    \                 result = false;\n                            }\n           \
    \             } else {\n                            if day > 30 {\n          \
    \                      result = false;\n                            }\n      \
    \                  }\n                    } else {\n                        if\
    \ !(year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {\n                 \
    \           result = false;\n                        }\n                    }\n\
    \                } else {\n                    result = false;\n             \
    \   }\n            } else {\n                result = false;\n            }\n\
    \        } else {\n            result = false;\n        }\n    } else {\n    \
    \    result = false;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let format_regex = Regex::new(r\"^(\\\
    d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n    let date_regex = Regex::new(r\"^([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n    if !format_regex.is_match(&date) {\n        return false;\n\
    \    }\n    if !date_regex.is_match(&date) {\n        return false;\n    }\n \
    \   return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp9uwokn1y.rs:9:24\n\
    \  |\n9 |     let format_regex = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\"\
    ).unwrap();\n  |                        ^^^^^ use of undeclared type `Regex`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Regex`\n  --> /tmp/tmp9uwokn1y.rs:10:22\n\
    \   |\n10 |     let date_regex = Regex::new(r\"^([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[1-2][0-9]|3[0-1])-\\\
    d{4}$\").unwrap();\n   |                      ^^^^^ use of undeclared type `Regex`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let dates = date.split(\"-\").collect::<Vec<&str>>();\n\
    \    if dates.len() != 3 {\n        return false;\n    }\n    let month = dates[0].parse::<u32>().unwrap();\n\
    \    let day = dates[1].parse::<u32>().unwrap();\n    let year = dates[2].parse::<u32>().unwrap();\n\
    \    if !is_valid_month(month) {\n        return false;\n    }\n    if !is_valid_day(day,\
    \ month) {\n        return false;\n    }\n    if !is_valid_year(year) {\n    \
    \    return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_valid_month` in this scope\n  -->\
    \ /tmp/tmpoejhlcng.rs:16:9\n   |\n16 |     if !is_valid_month(month) {\n   | \
    \        ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_valid_day` in this scope\n  --> /tmp/tmpoejhlcng.rs:19:9\n   |\n19 |   \
    \  if !is_valid_day(day, month) {\n   |         ^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_valid_year` in this scope\n\
    \  --> /tmp/tmpoejhlcng.rs:22:9\n   |\n22 |     if !is_valid_year(year) {\n  \
    \ |         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let mut date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_vec.len() != 3 {\n        return false;\n    }\n    let day: i32\
    \ = date_vec[1].parse().unwrap();\n    let month: i32 = date_vec[0].parse().unwrap();\n\
    \    let year: i32 = date_vec[2].parse().unwrap();\n    if month < 1 || month\
    \ > 12 {\n        return false;\n    }\n    if day < 1 || day > 31 {\n       \
    \ return false;\n    }\n    if day > 30 && month == 4 {\n        return false;\n\
    \    }\n    if day > 30 && month == 6 {\n        return false;\n    }\n    if\
    \ day > 30 && month == 9 {\n        return false;\n    }\n    if day > 30 && month\
    \ == 11 {\n        return false;\n    }\n    if day > 29 && month == 2 {\n   \
    \     return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    // Your code here\n    if date.is_empty()\
    \ {\n        return false;\n    }\n    let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n    if !re.is_match(&date) {\n        return false;\n    }\n    let\
    \ vec: Vec<&str> = date.split(\"-\").collect();\n    let month = vec[0].parse::<u32>().unwrap();\n\
    \    let day = vec[1].parse::<u32>().unwrap();\n    let year = vec[2].parse::<u32>().unwrap();\n\
    \    if year % 4 == 0 && year % 100 != 0 || year % 400 == 0 {\n        if month\
    \ == 2 && day > 29 {\n            return false;\n        }\n    } else {\n   \
    \     if month == 2 && day > 28 {\n            return false;\n        }\n    }\n\
    \    if month == 1 || month == 3 || month == 5 || month == 7 || month == 8 ||\
    \ month == 10 || month == 12 {\n        if day > 31 {\n            return false;\n\
    \        }\n    } else if month == 4 || month == 6 || month == 9 || month == 11\
    \ {\n        if day > 30 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n  -->\
    \ /tmp/tmpp9hkkk55.rs:13:14\n   |\n13 |     let re = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-[0-9]{4}$\"\
    ).unwrap();\n   |              ^^^^^ use of undeclared type `Regex`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let days = vec![31, 29, 31, 30, 31,\
    \ 30, 31, 31, 30, 31, 30, 31];\n    let error = |_| false;\n    let res = date.split('-').collect::<Vec<&str>>();\n\
    \    if res.len() != 3 {\n        return false;\n    }\n    let year = res[2].parse::<i32>().unwrap_or_else(error);\n\
    \    let month = res[0].parse::<i32>().unwrap_or_else(error);\n    let day = res[1].parse::<i32>().unwrap_or_else(error);\n\
    \    if year < 1 || day < 1 || month < 1 || day > days[(month - 1) as usize] {\n\
    \        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpz8fplrbg.rs:10:17:\
    \ 10:26] as FnOnce<(ParseIntError,)>>::Output == i32`\n  --> /tmp/tmpz8fplrbg.rs:15:38\n\
    \   |\n15 |     let year = res[2].parse::<i32>().unwrap_or_else(error);\n   |\
    \                                      ^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\
    \nerror[E0271]: type mismatch resolving `<[closure@/tmp/tmpz8fplrbg.rs:10:17:\
    \ 10:26] as FnOnce<(ParseIntError,)>>::Output == i32`\n  --> /tmp/tmpz8fplrbg.rs:16:39\n\
    \   |\n16 |     let month = res[0].parse::<i32>().unwrap_or_else(error);\n   |\
    \                                       ^^^^^^^^^^^^^^ expected `bool`, found\
    \ `i32`\n\nerror[E0271]: type mismatch resolving `<[closure@/tmp/tmpz8fplrbg.rs:10:17:\
    \ 10:26] as FnOnce<(ParseIntError,)>>::Output == i32`\n  --> /tmp/tmpz8fplrbg.rs:17:37\n\
    \   |\n17 |     let day = res[1].parse::<i32>().unwrap_or_else(error);\n   | \
    \                                    ^^^^^^^^^^^^^^ expected `bool`, found `i32`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_regex = Regex::new(r\"^(\\\
    d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n    let date_match = date_regex.captures(&date);\n\
    \    if date_match.is_none() {\n        return false;\n    }\n    let date_match\
    \ = date_match.unwrap();\n    let (m, d, y) = (date_match[1].parse::<u32>().unwrap(),\n\
    \                     date_match[2].parse::<u32>().unwrap(),\n               \
    \      date_match[3].parse::<u32>().unwrap());\n    // 1.\n    if m == 0 || d\
    \ == 0 || y == 0 {\n        return false;\n    }\n    // 2.\n    if (m == 1 ||\
    \ m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && d > 31 {\n  \
    \      return false;\n    }\n    if (m == 4 || m == 6 || m == 9 || m == 11) &&\
    \ d > 30 {\n        return false;\n    }\n    if m == 2 && d > 29 {\n        return\
    \ false;\n    }\n    // 3.\n    if m > 12 {\n        return false;\n    }\n  \
    \  true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpv35wjrj_.rs:9:22\n\
    \  |\n9 |     let date_regex = Regex::new(r\"^(\\d{2})-(\\d{2})-(\\d{4})$\").unwrap();\n\
    \  |                      ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut components = date.split(\"\
    -\");\n    let month = components.next().unwrap();\n    let day = components.next().unwrap();\n\
    \    let year = components.next().unwrap();\n\n    let month: u32 = match month.parse()\
    \ {\n        Ok(month) => month,\n        Err(_) => return false,\n    };\n\n\
    \    let day: u32 = match day.parse() {\n        Ok(day) => day,\n        Err(_)\
    \ => return false,\n    };\n\n    let year: u32 = match year.parse() {\n     \
    \   Ok(year) => year,\n        Err(_) => return false,\n    };\n\n    if month\
    \ > 12 || month < 1 {\n        return false;\n    }\n\n    if day > 31 || day\
    \ < 1 {\n        return false;\n    }\n\n    if (month == 1 || month == 3 || month\
    \ == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day > 31\
    \ {\n        return false;\n    }\n\n    if (month == 4 || month == 6 || month\
    \ == 9 || month == 11) && day > 30 {\n        return false;\n    }\n\n    if month\
    \ == 2 && day > 29 {\n        return false;\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmph2i51jcg.rs:11:33

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut data = date.split(\"-\");\n    let m: u32 = data.next().unwrap().parse().unwrap();\n\
    \    let d: u32 = data.next().unwrap().parse().unwrap();\n    let y: u32 = data.next().unwrap().parse().unwrap();\n\
    \n    if m > 12 || d > 31 || y < 1 {\n        return false;\n    }\n\n    match\
    \ m {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => d <= 31,\n        4 | 6 | 9 | 11\
    \ => d <= 30,\n        2 => {\n            // if it's not leap year\n        \
    \    if y % 4 != 0 {\n                d <= 28\n            } else {\n        \
    \        d <= 29\n            }\n        }\n        _ => false,\n    }\n}\n\n\
    fn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpoz3hgp_s.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let v: Vec<&str> = date.split(\"-\").collect();\n    if v.len()\
    \ != 3 {\n        return false;\n    }\n    let m = v[0].parse::<i32>().unwrap();\n\
    \    let d = v[1].parse::<i32>().unwrap();\n    let y = v[2].parse::<i32>().unwrap();\n\
    \    if m < 1 || m > 12 {\n        return false;\n    }\n    if (m == 1 || m ==\
    \ 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) && (d < 1 || d > 31)\
    \ {\n        return false;\n    }\n    if (m == 4 || m == 6 || m == 9 || m ==\
    \ 11) && (d < 1 || d > 30) {\n        return false;\n    }\n    if m == 2 && (d\
    \ < 1 || d > 29) {\n        return false;\n    }\n    if m == 2 && (d == 29 &&\
    \ y % 4 != 0) {\n        return false;\n    }\n    true\n}\n\nfn main() {\n  \
    \  let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() < 8 {\n        return\
    \ false;\n    }\n    let mut iter = date.split('-');\n    let month = iter.next().unwrap().parse::<u8>().unwrap();\n\
    \    let day = iter.next().unwrap().parse::<u8>().unwrap();\n    let year = iter.next().unwrap().parse::<u16>().unwrap();\n\
    \    if year < 1900 || year > 2020 {\n        return false;\n    }\n    if month\
    \ < 1 || month > 12 {\n        return false;\n    }\n    if month == 2 {\n   \
    \     return day <= 29;\n    }\n    if month % 2 == 0 {\n        return day <=\
    \ 30;\n    }\n    return day <= 31;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: PosOverflow }'', /tmp/tmp3txfdxl6.rs:13:52

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut valid = false;\n    let parts:\
    \ Vec<&str> = date.split(\"-\").collect();\n    let mut month: u8 = 0;\n    let\
    \ mut day: u8 = 0;\n    let mut year: u16 = 0;\n    if date.len() == 10 {\n  \
    \      if let Ok(m) = parts[0].parse::<u8>() {\n            month = m;\n     \
    \   }\n        if let Ok(d) = parts[1].parse::<u8>() {\n            day = d;\n\
    \        }\n        if let Ok(y) = parts[2].parse::<u16>() {\n            year\
    \ = y;\n        }\n        if month != 0 && day != 0 && year != 0 {\n        \
    \    if month > 0 && month < 13 {\n                match month {\n           \
    \         1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n                        if day > 0\
    \ && day < 32 {\n                            valid = true;\n                 \
    \       }\n                    }\n                    4 | 6 | 9 | 11 => {\n  \
    \                      if day > 0 && day < 31 {\n                            valid\
    \ = true;\n                        }\n                    }\n                \
    \    2 => {\n                        if year % 4 == 0 {\n                    \
    \        if day > 0 && day < 30 {\n                                valid = true;\n\
    \                            }\n                        } else {\n           \
    \                 if day > 0 && day < 29 {\n                                valid\
    \ = true;\n                            }\n                        }\n        \
    \            }\n                    _ => {\n                        valid = false;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   valid\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let months: [i32; 12] = [1, 3, 5, 7,\
    \ 8, 10, 12, 4, 6, 9, 11, 2];\n    let days: [i32; 12] = [31, 31, 30, 31, 30,\
    \ 31, 31, 30, 31, 30, 31, 29];\n    let mut x = 0;\n    let mut day = 0;\n   \
    \ let mut month = 0;\n    let mut year = 0;\n    let mut valid = false;\n    let\
    \ mut flag = true;\n    let mut tokens: Vec<&str> = date.split(\"-\").collect();\n\
    \    if tokens.len() != 3 {\n        return false;\n    }\n    month = tokens[0].parse::<i32>().unwrap();\n\
    \    day = tokens[1].parse::<i32>().unwrap();\n    year = tokens[2].parse::<i32>().unwrap();\n\
    \    if month < 1 || month > 12 {\n        flag = false;\n    }\n    if day <\
    \ 1 || day > 31 {\n        flag = false;\n    }\n    if month < 1 || month > 12\
    \ {\n        flag = false;\n    }\n    for i in months.iter() {\n        if *i\
    \ == month {\n            if day <= days[x] {\n                valid = true;\n\
    \            }\n        }\n        x += 1;\n    }\n    if year < 0 {\n       \
    \ valid = false;\n    }\n    if valid && flag {\n        true\n    } else {\n\
    \        false\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n   \
    \ assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut result = false;\n    let regex\
    \ = regex::Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\").unwrap();\n   \
    \ let parts: Vec<&str> = date.split(\"-\").collect();\n    if parts.len() == 3\
    \ {\n        let day: i32 = parts[1].parse().unwrap();\n        let month: i32\
    \ = parts[0].parse().unwrap();\n        let year: i32 = parts[2].parse().unwrap();\n\
    \        if (1..=12).contains(&month) {\n            if (1..=31).contains(&day)\
    \ {\n                if month == 2 {\n                    if (1..=29).contains(&day)\
    \ {\n                        result = true;\n                    }\n         \
    \       } else if month == 4 || month == 6 || month == 9 || month == 11 {\n  \
    \                  if (1..=30).contains(&day) {\n                        result\
    \ = true;\n                    }\n                } else {\n                 \
    \   result = true;\n                }\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \  --> /tmp/tmp9oae8c2f.rs:10:17\n   |\n10 |     let regex = regex::Regex::new(r\"\
    ^([0-9]{2})-([0-9]{2})-([0-9]{4})$\").unwrap();\n   |                 ^^^^^ use\
    \ of undeclared crate or module `regex`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    match date.split('-').map(|x| x.parse::<u32>().unwrap()).collect::<Vec<u32>>().as_slice()\
    \ {\n        [month, day, year] => {\n            if year < 1901 || year > 2999\
    \ {\n                return false;\n            }\n            if month < 1 ||\
    \ month > 12 {\n                return false;\n            }\n            if day\
    \ < 1 || day > 31 {\n                return false;\n            }\n          \
    \  if month == 2 && day > 29 {\n                return false;\n            }\n\
    \            if month == 4 || month == 6 || month == 9 || month == 11 {\n    \
    \            if day > 30 {\n                    return false;\n              \
    \  }\n            }\n            return true;\n        },\n        _ => false\n\
    \    }\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4n9e16nf.rs:11:23\n   |\n\
    11 |             if year < 1901 || year > 2999 {\n   |                       ^^^^\n\
    \   |                       |\n   |                       expected `&u32`, found\
    \ integer\n   |                       help: consider borrowing here: `&1901`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4n9e16nf.rs:11:38\n   |\n11 |\
    \             if year < 1901 || year > 2999 {\n   |                          \
    \            ^^^^\n   |                                      |\n   |         \
    \                             expected `&u32`, found integer\n   |           \
    \                           help: consider borrowing here: `&2999`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4n9e16nf.rs:14:24\n   |\n14 |             if\
    \ month < 1 || month > 12 {\n   |                        ^\n   |             \
    \           |\n   |                        expected `&u32`, found integer\n  \
    \ |                        help: consider borrowing here: `&1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4n9e16nf.rs:14:37\n   |\n14 |             if\
    \ month < 1 || month > 12 {\n   |                                     ^^\n   |\
    \                                     |\n   |                                \
    \     expected `&u32`, found integer\n   |                                   \
    \  help: consider borrowing here: `&12`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4n9e16nf.rs:17:22\n   |\n17 |             if day < 1 || day > 31 {\n\
    \   |                      ^\n   |                      |\n   |              \
    \        expected `&u32`, found integer\n   |                      help: consider\
    \ borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4n9e16nf.rs:17:33\n\
    \   |\n17 |             if day < 1 || day > 31 {\n   |                       \
    \          ^^\n   |                                 |\n   |                  \
    \               expected `&u32`, found integer\n   |                         \
    \        help: consider borrowing here: `&31`\n\nerror[E0277]: can't compare `&u32`\
    \ with `{integer}`\n  --> /tmp/tmp4n9e16nf.rs:20:22\n   |\n20 |             if\
    \ month"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ DATE_FORMAT: Regex = Regex::new(r\"^(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])-([0-9]{4})$\"\
    ).unwrap();\n    }\n\n    match DATE_FORMAT.captures(&date) {\n        Some(captures)\
    \ => {\n            let mm = captures.get(1).unwrap().as_str().parse::<u32>().unwrap();\n\
    \            let dd = captures.get(2).unwrap().as_str().parse::<u32>().unwrap();\n\
    \            let yyyy = captures.get(3).unwrap().as_str().parse::<u32>().unwrap();\n\
    \n            let valid_months = vec![1, 3, 5, 7, 8, 10, 12];\n            let\
    \ invalid_months = vec![4, 6, 9, 11];\n\n            if mm == 2 {\n          \
    \      // leap year\n                if yyyy % 4 == 0 && yyyy % 100 != 0 || yyyy\
    \ % 400 == 0 {\n                    return dd <= 29;\n                } else {\n\
    \                    return dd <= 28;\n                }\n            } else if\
    \ valid_months.contains(&mm) {\n                return dd <= 31;\n           \
    \ } else if invalid_months.contains(&mm) {\n                return dd <= 30;\n\
    \            }\n            false\n        }\n        None => false,\n    }\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmpv1bt06b5.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `DATE_FORMAT` in this scope\n  --> /tmp/tmpv1bt06b5.rs:13:11\n   |\n13\
    \ |     match DATE_FORMAT.captures(&date) {\n   |           ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut month = -1;\n    let mut day\
    \ = -1;\n    let mut year = -1;\n    let mut return_value = false;\n    let mut\
    \ months_with_31_days = vec![1, 3, 5, 7, 8, 10, 12];\n    let mut months_with_30_days\
    \ = vec![4, 6, 9, 11];\n    let m_d_y: Vec<&str> = date.split(\"-\").collect();\n\
    \    if m_d_y.len() == 3 {\n        if m_d_y[0].parse::<i32>().is_ok() {\n   \
    \         month = m_d_y[0].parse::<i32>().unwrap();\n        }\n        if m_d_y[1].parse::<i32>().is_ok()\
    \ {\n            day = m_d_y[1].parse::<i32>().unwrap();\n        }\n        if\
    \ m_d_y[2].parse::<i32>().is_ok() {\n            year = m_d_y[2].parse::<i32>().unwrap();\n\
    \        }\n        if month > 0 && month < 13 && day > 0 && day < 32 && year\
    \ > 0 {\n            if month == 2 {\n                if day > 0 && day < 30 {\n\
    \                    return_value = true;\n                }\n            } else\
    \ if months_with_31_days.contains(&month) {\n                if day > 0 && day\
    \ < 32 {\n                    return_value = true;\n                }\n      \
    \      } else if months_with_30_days.contains(&month) {\n                if day\
    \ > 0 && day < 31 {\n                    return_value = true;\n              \
    \  }\n            }\n        }\n    }\n    return_value\n}\n\nfn main() {\n  \
    \  let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    match date.parse::<Date<Utc>>() {\n\
    \        Ok(_) => true,\n        Err(_) => false,\n    }\n}\n\nfn main() {\n \
    \   let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Date` in this scope\n --> /tmp/tmplzgl6c_z.rs:9:24\n\
    \  |\n9 |     match date.parse::<Date<Utc>>() {\n  |                        ^^^^\
    \ not found in this scope\n\nerror[E0412]: cannot find type `Utc` in this scope\n\
    \ --> /tmp/tmplzgl6c_z.rs:9:29\n  |\n8 | fn valid_date(date: String) -> bool {\n\
    \  |              - help: you might be missing a type parameter: `<Utc>`\n9 |\
    \     match date.parse::<Date<Utc>>() {\n  |                             ^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    //parse string\n    let mut iter =\
    \ date.split(\"-\");\n    let mut v: Vec<i32> = Vec::new();\n    loop {\n    \
    \    match iter.next() {\n            Some(x) => v.push(x.parse::<i32>().unwrap()),\n\
    \            None => break,\n        }\n    }\n    let mut i = 0;\n    for &x\
    \ in v.iter() {\n        if i == 0 {\n            if x > 12 || x < 1 {\n     \
    \           return false;\n            }\n        } else if i == 1 {\n       \
    \     if x > 31 || x < 1 {\n                return false;\n            }\n   \
    \     } else if i == 2 {\n            if x < 1900 || x > 3000 {\n            \
    \    return false;\n            }\n        }\n        i += 1;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmpnt5v_59j.rs:14:48

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let parts: Vec<&str> = date.split(\"\
    -\").collect();\n    let month: u8 = match parts[0].parse() {\n        Ok(n) =>\
    \ n,\n        Err(_) => return false,\n    };\n    let day: u8 = match parts[1].parse()\
    \ {\n        Ok(n) => n,\n        Err(_) => return false,\n    };\n    let year:\
    \ u16 = match parts[2].parse() {\n        Ok(n) => n,\n        Err(_) => return\
    \ false,\n    };\n    let mut num_days = day;\n    match month {\n        2 =>\
    \ num_days = 29,\n        4 | 6 | 9 | 11 => num_days = 30,\n        _ => (),\n\
    \    }\n    if day < 1 || day > num_days || month < 1 || month > 12 || year <\
    \ 1 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5gijf2_f.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let matches = RE.captures(date.as_str());\n\
    \    match matches {\n        Some(caps) => {\n            let days: usize = caps[1].parse().unwrap();\n\
    \            let month: usize = caps[2].parse().unwrap();\n            let year:\
    \ usize = caps[3].parse().unwrap();\n            match month {\n             \
    \   1 | 3 | 5 | 7 | 8 | 10 | 12 => days <= 31,\n                4 | 6 | 9 | 11\
    \ => days <= 30,\n                2 => days <= 28,\n                _ => false,\n\
    \            }\n        }\n        None => false,\n    }\n}\n\nfn main() {\n \
    \   let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `RE` in this scope\n --> /tmp/tmp0psgyr3x.rs:9:19\n\
    \  |\n9 |     let matches = RE.captures(date.as_str());\n  |                 \
    \  ^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    date.is_empty()\n        || date.len()\
    \ != 10\n        || !date.contains('-')\n        || !date.split('-').all(|val|\
    \ val.parse::<u32>().is_ok())\n        || !valid_day(date.split('-').collect::<Vec<&str>>())\n\
    \        || !valid_month(date.split('-').collect::<Vec<&str>>())\n        || !valid_year(date.split('-').collect::<Vec<&str>>())\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `valid_day` in this scope\n  --> /tmp/tmpil5749ir.rs:13:13\n\
    \   |\n13 |         || !valid_day(date.split('-').collect::<Vec<&str>>())\n  \
    \ |             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `valid_month` in this scope\n  --> /tmp/tmpil5749ir.rs:14:13\n   |\n\
    14 |         || !valid_month(date.split('-').collect::<Vec<&str>>())\n   |   \
    \          ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `valid_year` in this scope\n  --> /tmp/tmpil5749ir.rs:15:13\n   |\n15 |    \
    \     || !valid_year(date.split('-').collect::<Vec<&str>>())\n   |           \
    \  ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    lazy_static! {\n        static ref\
    \ RE: Regex = Regex::new(r\"(?P<month>\\d{1,2})-(?P<day>\\d{1,2})-(?P<year>\\\
    d{4})\").unwrap();\n    }\n    let caps = RE.captures(&date);\n    match caps\
    \ {\n        Some(m) => {\n            let month = m.name(\"month\").unwrap().as_str().parse::<i32>().unwrap();\n\
    \            let day = m.name(\"day\").unwrap().as_str().parse::<i32>().unwrap();\n\
    \            let year = m.name(\"year\").unwrap().as_str().parse::<i32>().unwrap();\n\
    \            if (month < 1 || month > 12) ||\n                (day < 1 ||\n  \
    \               day > match month {\n                         1 | 3 | 5 | 7 |\
    \ 8 | 10 | 12 => 31,\n                         4 | 6 | 9 | 11 => 30,\n       \
    \                  2 => 29,\n                         _ => 0,\n              \
    \       }) ||\n                (year < 1) {\n                return false;\n \
    \           }\n            true\n        }\n        None => false,\n    }\n}\n\
    \nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n --> /tmp/tmp211ip7mq.rs:9:5\n\
    \  |\n9 |     lazy_static! {\n  |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `RE` in this scope\n  --> /tmp/tmp211ip7mq.rs:12:16\n   |\n12 |     let\
    \ caps = RE.captures(&date);\n   |                ^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_split: Vec<_> = date.split(\"\
    -\").collect();\n    match date_split.len() {\n        3 => match date_split[0].parse::<u32>()\
    \ {\n            Ok(m) => match date_split[1].parse::<u32>() {\n             \
    \   Ok(d) => match date_split[2].parse::<u32>() {\n                    Ok(y) =>\
    \ match m {\n                        2 => {\n                            if y\
    \ % 4 == 0 {\n                                (1..=29).contains(&d)\n        \
    \                    } else {\n                                (1..=28).contains(&d)\n\
    \                            }\n                        }\n                  \
    \      4 | 6 | 9 | 11 => (1..=30).contains(&d),\n                        1 | 3\
    \ | 5 | 7 | 8 | 10 | 12 => (1..=31).contains(&d),\n                        _ =>\
    \ false,\n                    },\n                    _ => false,\n          \
    \      },\n                _ => false,\n            },\n            _ => false,\n\
    \        },\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let date_vec: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_vec.len() != 3 {\n        return false;\n    }\n    let dd: i32 =\
    \ date_vec[1].parse().unwrap();\n    let mm: i32 = date_vec[0].parse().unwrap();\n\
    \    let yyyy: i32 = date_vec[2].parse().unwrap();\n    if dd < 1 || dd > 31 ||\
    \ mm < 1 || mm > 12 || yyyy < 1 {\n        return false;\n    }\n    if (mm ==\
    \ 4 || mm == 6 || mm == 9 || mm == 11) && dd > 30 {\n        return false;\n \
    \   }\n    if mm == 2 && dd > 29 {\n        return false;\n    }\n    return true;\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    let month: u32 = v[0].parse().unwrap();\n\
    \    let day: u32 = v[1].parse().unwrap();\n    if day == 0 || month == 0 {\n\
    \        return false;\n    }\n    if (1..=12).find(|&x| x == month).is_none()\
    \ {\n        return false;\n    }\n    if month == 2 {\n        if day > 29 {\n\
    \            return false;\n        }\n    } else if (1..=7).find(|&x| x == month\
    \ % 2).is_none() {\n        if day > 30 {\n            return false;\n       \
    \ }\n    } else {\n        if day > 31 {\n            return false;\n        }\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let re = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\"\
    ).unwrap();\n    let caps = re.captures(&date).unwrap();\n    let year = caps.get(3).unwrap().as_str().parse::<i32>().unwrap();\n\
    \    let month = caps.get(1).unwrap().as_str().parse::<i32>().unwrap();\n    let\
    \ day = caps.get(2).unwrap().as_str().parse::<i32>().unwrap();\n    // println!(\"\
    {}-{}-{}\", year, month, day);\n    if year <= 0 || (month > 12 || month <= 0)\
    \ || day > 31 || day <= 0 {\n        return false;\n    }\n    if (month == 4\
    \ || month == 6 || month == 9 || month == 11) && day == 31 {\n        return false;\n\
    \    }\n    if month == 2 && day > 29 {\n        return false;\n    }\n    if\
    \ month == 2 && day == 29 && year % 4 != 0 {\n        return false;\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmprgb2vt3d.rs:9:14\n\
    \  |\n9 |     let re = Regex::new(r\"^([0-9]{2})-([0-9]{2})-([0-9]{4})$\").unwrap();\n\
    \  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let pats = [\"-\", \"/\", \".\"];\n    let date_splitted:\
    \ Vec<&str> = pats\n        .iter()\n        .fold(date, |acc, &x| acc.replace(x,\
    \ \"-\"))\n        .split(\"-\")\n        .collect();\n    if date_splitted.len()\
    \ != 3 {\n        return false;\n    }\n    let mut days = 0;\n    let mut month\
    \ = 0;\n    let mut year = 0;\n    for (i, x) in date_splitted.iter().enumerate()\
    \ {\n        if i == 0 {\n            month = x.parse::<i32>().unwrap();\n   \
    \     } else if i == 1 {\n            days = x.parse::<i32>().unwrap();\n    \
    \    } else {\n            year = x.parse::<i32>().unwrap();\n        }\n    }\n\
    \    if month < 1 || month > 12 {\n        return false;\n    }\n    if month\
    \ == 2 {\n        if days < 1 || days > 29 {\n            return false;\n    \
    \    }\n    } else if month == 1 || month == 3 || month == 5 || month == 7 ||\
    \ month == 8 || month == 10\n        || month == 12\n    {\n        if days <\
    \ 1 || days > 31 {\n            return false;\n        }\n    } else {\n     \
    \   if days < 1 || days > 30 {\n            return false;\n        }\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `year` is assigned to, but never used\n  --> /tmp/tmp7brt4iyv.rs:23:13\n\
    \   |\n23 |     let mut year = 0;\n   |             ^^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_year` instead\n\nwarning: value assigned\
    \ to `year` is never read\n  --> /tmp/tmp7brt4iyv.rs:30:13\n   |\n30 |       \
    \      year = x.parse::<i32>().unwrap();\n   |             ^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0716]: temporary value dropped while borrowed\n\
    \  --> /tmp/tmp7brt4iyv.rs:13:36\n   |\n13 |       let date_splitted: Vec<&str>\
    \ = pats\n   |  ____________________________________^\n14 | |         .iter()\n\
    15 | |         .fold(date, |acc, &x| acc.replace(x, \"-\"))\n   | |__________________________________________________^\
    \ creates a temporary which is freed while still in use\n16 |           .split(\"\
    -\")\n17 |           .collect();\n   |                     - temporary value is\
    \ freed at the end of this statement\n18 |       if date_splitted.len() != 3 {\n\
    \   |          ------------- borrow later used here\n   |\n   = note: consider\
    \ using a `let` binding to create a longer lived value\n\nerror: aborting due\
    \ to previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0716`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut valid_date: bool = true;\n\
    \    let parsed_date: Vec<&str> = date.split(\"-\").collect();\n    if parsed_date.len()\
    \ != 3 {\n        valid_date = false;\n    } else {\n        let parsed_day: i32\
    \ = parsed_date[1].parse().unwrap();\n        let parsed_month: i32 = parsed_date[0].parse().unwrap();\n\
    \        let parsed_year: i32 = parsed_date[2].parse().unwrap();\n        if parsed_day\
    \ < 1 || parsed_month < 1 || parsed_year < 1 {\n            valid_date = false;\n\
    \        } else {\n            match parsed_month {\n                1 | 3 | 5\
    \ | 7 | 8 | 10 | 12 => if parsed_day > 31 {\n                    valid_date =\
    \ false;\n                },\n                4 | 6 | 9 | 11 => if parsed_day\
    \ > 30 {\n                    valid_date = false;\n                },\n      \
    \          2 => if parsed_day > 29 {\n                    valid_date = false;\n\
    \                },\n                _ => {}\n            }\n        }\n    }\n\
    \    valid_date\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7wdxmj4w.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let date_vec: Vec<&str> = date.split(\"\
    -\").collect();\n    if date_vec.len() != 3 {\n        return false;\n    }\n\
    \    let mut month = date_vec[0].parse::<i32>().unwrap();\n    let mut day = date_vec[1].parse::<i32>().unwrap();\n\
    \    let mut year = date_vec[2].parse::<i32>().unwrap();\n    if (month > 12)\
    \ || (month < 1) {\n        return false;\n    }\n    if (day > 31) || (day <\
    \ 1) {\n        return false;\n    }\n    if (month == 4) || (month == 6) || (month\
    \ == 9) || (month == 11) {\n        if day > 30 {\n            return false;\n\
    \        }\n    }\n    if month == 2 {\n        if day > 29 {\n            return\
    \ false;\n        }\n    }\n    if year < 0 {\n        return false;\n    }\n\
    \    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 1
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let date_parts: Vec<&str> = date.split(\"-\").collect();\n\
    \    if date_parts.len() != 3 {\n        return false;\n    }\n\n    let month\
    \ = date_parts[0].parse::<u32>().unwrap();\n    let day = date_parts[1].parse::<u32>().unwrap();\n\
    \    let year = date_parts[2].parse::<u32>().unwrap();\n\n    if month < 1 ||\
    \ month > 12 {\n        return false;\n    }\n\n    if year < 1 {\n        return\
    \ false;\n    }\n\n    if !valid_day(day, month) {\n        return false;\n  \
    \  }\n\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `valid_day` in this scope\n  --> /tmp/tmpcnz9ku4l.rs:30:9\n\
    \   |\n30 |     if !valid_day(day, month) {\n   |         ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let split_date: Vec<&str> = date.split(\"\
    -\").collect();\n    if split_date.len() != 3 {\n        return false;\n    }\n\
    \    let day = split_date[1].parse::<u32>().unwrap();\n    let month = split_date[0].parse::<u32>().unwrap();\n\
    \    let year = split_date[2].parse::<u32>().unwrap();\n    match month {\n  \
    \      1 | 3 | 5 | 7 | 8 | 10 | 12 => {\n            if day >= 1 && day <= 31\
    \ {\n                true\n            } else {\n                false\n     \
    \       }\n        }\n        4 | 6 | 9 | 11 => {\n            if day >= 1 &&\
    \ day <= 30 {\n                true\n            } else {\n                false\n\
    \            }\n        }\n        2 => {\n            if day >= 1 && day <= 29\
    \ {\n                true\n            } else {\n                false\n     \
    \       }\n        }\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n\
    \    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n   \
    \ assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\
    \")), false);\n    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"\
    21-31-2000\")), false);\n    assert_eq!(candidate(String::from(\"04-12-2003\"\
    )), true);\n    assert_eq!(candidate(String::from(\"04122003\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"20030412\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04\")), false);\n    assert_eq!(candidate(String::from(\"2003-04-12\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-2003\")), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut days = 0;\n    let mut months\
    \ = 0;\n    let mut years = 0;\n    let month_array = vec![31, 30, 29, 31, 30,\
    \ 31, 30, 31, 31, 30, 31, 30];\n    if date.is_empty() {\n        return false;\n\
    \    }\n    let date_v: Vec<&str> = date.split(\"-\").collect();\n    if date_v.len()\
    \ != 3 {\n        return false;\n    }\n    for i in date_v {\n        match i.parse::<u32>()\
    \ {\n            Ok(i) => {\n                if days == 0 {\n                \
    \    days = i;\n                } else if months == 0 {\n                    months\
    \ = i;\n                } else if years == 0 {\n                    years = i;\n\
    \                }\n            }\n            Err(_) => return false,\n     \
    \   }\n    }\n    if months > 12 || months < 1 {\n        return false;\n    }\n\
    \    if days < 1 || days > month_array[(months - 1) as usize] {\n        return\
    \ false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6pz8sy57.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    const MONTH_DETAILS: [(i32, i32); 12]\
    \ = [\n        (1, 31),\n        (2, 28),\n        (3, 31),\n        (4, 30),\n\
    \        (5, 31),\n        (6, 30),\n        (7, 31),\n        (8, 31),\n    \
    \    (9, 30),\n        (10, 31),\n        (11, 30),\n        (12, 31),\n    ];\n\
    \n    let date_split: Vec<&str> = date.split('-').collect();\n    if date_split.len()\
    \ != 3 {\n        return false;\n    }\n\n    let month = date_split[0].parse::<i32>().unwrap();\n\
    \    let day = date_split[1].parse::<i32>().unwrap();\n    let year = date_split[2].parse::<i32>().unwrap();\n\
    \n    if month < 1 || month > 12 {\n        return false;\n    }\n\n    if day\
    \ < 1 || day > MONTH_DETAILS[(month - 1) as usize].1 {\n        return false;\n\
    \    }\n\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let date_string = date.as_str();\n    let date_array: Vec<&str>\
    \ = date_string.split(\"-\").collect();\n    let (month, day, year) = (date_array[0],\
    \ date_array[1], date_array[2]);\n    let month_num = month.parse::<u32>().unwrap();\n\
    \    let day_num = day.parse::<u32>().unwrap();\n    let year_num = year.parse::<u32>().unwrap();\n\
    \    if month_num < 1 || month_num > 12 {\n        return false;\n    }\n    if\
    \ (month_num == 1 || month_num == 3 || month_num == 5 || month_num == 7 || month_num\
    \ == 8 || month_num == 10 || month_num == 12) && (day_num < 1 || day_num > 31)\
    \ {\n        return false;\n    }\n    if (month_num == 4 || month_num == 6 ||\
    \ month_num == 9 || month_num == 11) && (day_num < 1 || day_num > 30) {\n    \
    \    return false;\n    }\n    if month_num == 2 && (day_num < 1 || day_num >\
    \ 29) {\n        return false;\n    }\n    if year_num < 1 {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmpwcnzw4_4.rs:14:46

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let (d, m, y) = (date[3..5].parse::<u8>().unwrap(),\
    \ date[0..2].parse::<u8>().unwrap(), date[6..].parse::<u16>().unwrap());\n   \
    \ match m {\n        1 | 3 | 5 | 7 | 8 | 10 | 12 => d >= 1 && d <= 31,\n     \
    \   4 | 6 | 9 | 11 => d >= 1 && d <= 30,\n        2 => d >= 1 && d <= 29,\n  \
    \      _ => false\n    }\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpgichyms1.rs:9:47

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.is_empty() {\n        return\
    \ false;\n    }\n\n    let mut date_parsed = Vec::new();\n    for s in date.split('-')\
    \ {\n        date_parsed.push(s.parse::<u32>().unwrap());\n    }\n\n    let year\
    \ = date_parsed[2];\n    let month = date_parsed[0];\n    let day = date_parsed[1];\n\
    \n    if (1..13).contains(&month) == false {\n        return false;\n    }\n\n\
    \    if (1..32).contains(&day) == false {\n        return false;\n    }\n\n  \
    \  if (1..32).contains(&day) == false {\n        return false;\n    }\n\n    let\
    \ days_for_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day\
    \ > days_for_month[month as usize - 1] {\n        return false;\n    }\n\n   \
    \ if month == 2 && day == 29 {\n        if year % 4 == 0 {\n            if year\
    \ % 100 == 0 {\n                if year % 400 == 0 {\n                    return\
    \ true;\n                }\n                return false;\n            }\n   \
    \         return true;\n        }\n        return false;\n    }\n\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 2'', /tmp/tmpa9aqv1dz.rs:18:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let mut parts = date.split('-');\n\
    \    let month = parts.next().unwrap().parse::<u32>().unwrap();\n    let day =\
    \ parts.next().unwrap().parse::<u32>().unwrap();\n    let year = parts.next().unwrap().parse::<u32>().unwrap();\n\
    \n    if month > 12 || month < 1 {\n        return false;\n    }\n\n    let max_days\
    \ = match month {\n        2 => if year % 4 == 0 { 29 } else { 28 },\n       \
    \ 4 | 6 | 9 | 11 => 30,\n        _ => 31,\n    };\n\n    if day > max_days ||\
    \ day < 1 {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let\
    \ candidate = valid_date;\n    assert_eq!(candidate(String::from(\"03-11-2000\"\
    )), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"01-01-2007\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: Empty }'', /tmp/tmp_v28fj1j.rs:10:54

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 101
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    if date.len() == 0 {\n        return\
    \ false;\n    }\n    let split_date: Vec<&str> = date.split(\"-\").collect();\n\
    \    let month = split_date[0].parse::<i32>().unwrap();\n    let day = split_date[1].parse::<i32>().unwrap();\n\
    \    let year = split_date[2].parse::<i32>().unwrap();\n    if (month >= 1 &&\
    \ month <= 12) && (year >= 1) {\n        if (month == 1) || (month == 3) || (month\
    \ == 5) || (month == 7) || (month == 8) || (month == 10) || (month == 12) {\n\
    \            if (day >= 1) && (day <= 31) {\n                return true;\n  \
    \          }\n        } else if (month == 4) || (month == 6) || (month == 9) ||\
    \ (month == 11) {\n            if (day >= 1) && (day <= 30) {\n              \
    \  return true;\n            }\n        } else if month == 2 {\n            if\
    \ (day >= 1) && (day <= 29) {\n                return true;\n            }\n \
    \       }\n    }\n    false\n}\n\nfn main() {\n    let candidate = valid_date;\n\
    \    assert_eq!(candidate(String::from(\"03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"\
    15-01-2012\")), false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"\
    03-32-2011\")), false);\n    assert_eq!(candidate(String::from(\"\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"\
    06-06-2005\")), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n  \
    \  assert_eq!(candidate(String::from(\"04122003\")), false);\n    assert_eq!(candidate(String::from(\"\
    20030412\")), false);\n    assert_eq!(candidate(String::from(\"2003-04\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-2003\")), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 1 but the
    index is 1'', /tmp/tmprqonsurr.rs:14:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821435
- exit_code: 0
  program: "/// You have to write a function which validates a given date string and\n\
    /// returns True if the date is valid otherwise False.\n/// The date is valid\
    \ if all of the following rules are satisfied:\n/// 1. The date string is not\
    \ empty.\n/// 2. The number of days is not less than 1 or higher than 31 days\
    \ for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher\
    \ than 30 days for months 4,6,9,11. And, the number of days is not less than 1\
    \ or higher than 29 for the month 2.\n/// 3. The months should not be less than\
    \ 1 or higher than 12.\n/// 4. The date should be in the format: mm-dd-yyyy\n\
    fn valid_date(date: String) -> bool {\n    let v: Vec<&str> = date.split('-').collect();\n\
    \    if v.len() != 3 {\n        return false;\n    }\n    let y = v[2].parse::<i32>().unwrap();\n\
    \    let m = v[0].parse::<i32>().unwrap();\n    let d = v[1].parse::<i32>().unwrap();\n\
    \    if y < 0 || m < 1 || m > 12 || d < 1 {\n        return false;\n    }\n  \
    \  if d > 31 {\n        return false;\n    }\n    if d > 30 && (m == 4 || m ==\
    \ 6 || m == 9 || m == 11) {\n        return false;\n    }\n    if d > 29 && m\
    \ == 2 {\n        return false;\n    }\n    if d == 29 && m == 2 && (y % 4 !=\
    \ 0 || (y % 100 == 0 && y % 400 != 0)) {\n        return false;\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = valid_date;\n    assert_eq!(candidate(String::from(\"\
    03-11-2000\")), true);\n    assert_eq!(candidate(String::from(\"15-01-2012\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"04-0-2040\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"06-04-2020\")), true);\n    assert_eq!(candidate(String::from(\"\
    01-01-2007\")), true);\n    assert_eq!(candidate(String::from(\"03-32-2011\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"\")), false);\n    assert_eq!(candidate(String::from(\"\
    04-31-3000\")), false);\n    assert_eq!(candidate(String::from(\"06-06-2005\"\
    )), true);\n    assert_eq!(candidate(String::from(\"21-31-2000\")), false);\n\
    \    assert_eq!(candidate(String::from(\"04-12-2003\")), true);\n    assert_eq!(candidate(String::from(\"\
    04122003\")), false);\n    assert_eq!(candidate(String::from(\"20030412\")), false);\n\
    \    assert_eq!(candidate(String::from(\"2003-04\")), false);\n    assert_eq!(candidate(String::from(\"\
    2003-04-12\")), false);\n    assert_eq!(candidate(String::from(\"04-2003\")),\
    \ false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821435
