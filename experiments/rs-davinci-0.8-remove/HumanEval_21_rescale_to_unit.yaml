name: HumanEval_21_rescale_to_unit
language: rs
prompt: "/// Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n/// such that the smallest number will become 0 and the largest\
  \ will become 1\nfn rescale_to_unit(numbers: Vec<f64>) -> Vec<f64> {\n"
tests: "}\n\nfn main() {\n    let candidate = rescale_to_unit;\n    assert_eq!(candidate(vec![2.0,\
  \ 49.9]), vec![0.0, 1.0]);\n    assert_eq!(candidate(vec![100.0, 49.9]), vec![1.0,\
  \ 0.0]);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0]), vec![0.0, 0.25,\
  \ 0.5, 0.75, 1.0]);\n    assert_eq!(candidate(vec![2.0, 1.0, 5.0, 3.0, 4.0]), vec![0.25,\
  \ 0.0, 1.0, 0.5, 0.75]);\n    assert_eq!(candidate(vec![12.0, 11.0, 15.0, 13.0,\
  \ 14.0]), vec![0.25, 0.0, 1.0, 0.5, 0.75]);\n}\n"
completions: ["    let max = numbers.iter().fold(std::f64::NEG_INFINITY, |a, b| a.max(*b));\n\
    \    let min = numbers.iter().fold(std::f64::INFINITY, |a, b| a.min(*b));\n  \
    \  let diff = max - min;\n    let multiplier = 1.0 / diff;\n    numbers.iter().map(|x|\
    \ (x - min) * multiplier).collect()", "    let (min, max) = if let Some(m) = numbers.iter().min()\
    \ {\n        if let Some(M) = numbers.iter().max() {\n            (*m, *M)\n \
    \       } else {\n            panic!(\"No max!\");\n        }\n    } else {\n\
    \        panic!(\"No min!\");\n    };\n\n    let mut new_numbers = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        new_numbers.push((number - min) / (max -\
    \ min));\n    }\n\n    new_numbers", "    // Find the maximum and minimum\n  \
    \  let mut numbers = numbers;\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    let min = numbers[0];\n    let max = numbers[numbers.len() - 1];\n\n    let\
    \ numbers: Vec<f64> = numbers.iter().map(|&n| (n - min) / (max - min)).collect();\n\
    \    numbers", "    let mut result = Vec::new();\n    let (min, max) = (\n   \
    \     numbers.iter().cloned().fold(f64::INFINITY, f64::min),\n        numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max),\n    );\n    let scale = max - min;\n    for x in numbers {\n   \
    \     result.push((x - min) / scale);\n    }\n    result", "    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let (min,\
    \ max) = numbers.iter().fold((std::f64::MAX, std::f64::MIN), |(a, b), &x| {\n\
    \        (cmp::min(a, x), cmp::max(b, x))\n    });\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()", "    let smallest = numbers.iter().min().unwrap();\n\
    \    let largest = numbers.iter().max().unwrap();\n    let diff = *largest - *smallest;\n\
    \    numbers.iter().map(|x| {\n        if diff == 0.0 {\n            0.0\n   \
    \     } else {\n            (*x - *smallest) / diff\n        }\n    }).collect()",
  "    let lv = numbers.iter().min().unwrap();\n    let rv = numbers.iter().max().unwrap();\n\
    \    let delta = rv - lv;\n    numbers.iter().map(|v| (*v - lv) / delta).collect()",
  "    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let delta = max - min;\n\
    \    let new_max = 1.0;\n    let new_min = 0.0;\n    let new_delta = new_max -\
    \ new_min;\n    numbers.iter().map(|x| {\n        new_min + (x - min) * new_delta\
    \ / delta\n    }).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let diff = max - min;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for x in numbers {\n        result.push((x - min) / diff);\n    }\n    result",
  "    let mut rescaled = numbers.clone();\n    let smallest = rescaled.iter().fold(1e20,\
    \ |a, x| a.min(*x));\n    let largest = rescaled.iter().fold(-1e20, |a, x| a.max(*x));\n\
    \    for el in rescaled.iter_mut() {\n        *el = (*el - smallest) / (largest\
    \ - smallest);\n    }\n    rescaled", "    let (min, max) = (numbers.iter().cloned().min().unwrap(),\
    \ numbers.iter().cloned().max().unwrap());\n    let mut scaled_numbers = Vec::with_capacity(numbers.len());\n\
    \    let (a, b) = if min == max {\n        warn!(\"Cannot rescale to unit, min\
    \ and max are equal: {}\", min);\n        (0.0, 1.0)\n    } else {\n        (1.0\
    \ / (max - min), -min / (max - min))\n    };\n    for number in numbers {\n  \
    \      scaled_numbers.push(a * number + b);\n    }\n    scaled_numbers", "   \
    \ let min_number = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let\
    \ max_number = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let rescale_factor\
    \ = 1.0 / (max_number - min_number);\n    numbers.iter().map(|n| (*n - min_number)\
    \ * rescale_factor).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x -\
    \ min) / (max - min)).collect()", "    // find the smallest and largest number\
    \ in the list\n    let min = numbers.iter().fold(f64::INFINITY, |acc, &x| acc.min(x));\n\
    \    let max = numbers.iter().fold(f64::NEG_INFINITY, |acc, &x| acc.max(x));\n\
    \n    // then, for each number in the list, rescale it according to the formula\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    // error\
    \ here:\n    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let mut result = vec![];\n    for num in numbers {\n        result.push((num\
    \ - min) / (max - min));\n    }\n    result", "    let min = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let scale = (max - min).recip();\n    numbers.iter().map(|&x| scale * (x\
    \ - min)).collect()", "    let min_number = numbers.iter().min().unwrap();\n \
    \   let max_number = numbers.iter().max().unwrap();\n    numbers.iter().map(|x|\
    \ (x - min_number) / (max_number - min_number)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|&x| (x\
    \ - min) / (max - min)).collect()", "    let max = numbers.iter().fold(f64::NEG_INFINITY,\
    \ |prev, curr| if prev > *curr { prev } else { *curr });\n    let min = numbers.iter().fold(f64::INFINITY,\
    \ |prev, curr| if prev < *curr { prev } else { *curr });\n    let scale = max\
    \ - min;\n    numbers.iter().map(|n| (n - min) / scale).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let diff = max - min;\n    numbers.iter().map(|x| (*x - min) / diff).collect()",
  "    let min = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|number| (number - min) /\
    \ range).collect()", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    let size = max - min;\n    numbers.iter().map(|&x|\
    \ (x - min) / size).collect()", "    let mut clone = numbers.clone();\n    let\
    \ mut max = clone[0];\n    let mut min = clone[0];\n    for n in &mut clone {\n\
    \        if *n > max {\n            max = *n;\n        }\n        if *n < min\
    \ {\n            min = *n;\n        }\n    }\n    for n in &mut clone {\n    \
    \    *n = (*n - min) / (max - min);\n    }\n    clone", "    assert!(numbers.len()\
    \ >= 2);\n    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(min,\
    \ max), &x| {\n        (min.min(x), max.max(x))\n    });\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()", "    assert!(numbers.len() >= 2);\n   \
    \ let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(min, max),\
    \ x| {\n        (min.min(*x), max.max(*x))\n    });\n    let factor = 1.0 / (max\
    \ - min);\n    numbers.iter().map(|&x| (x - min) * factor).collect()", "    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    numbers.iter().map(|x| (x - min) / delta).collect()",
  "    let max_number = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let\
    \ min_number = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n    let dist\
    \ = max_number - min_number;\n    let mut ret = Vec::new();\n    for n in numbers\
    \ {\n        ret.push((n - min_number) / dist);\n    }\n    ret", "    let max\
    \ = numbers.iter().cloned().fold(0./0., f64::max);\n    let min = numbers.iter().cloned().fold(0./0.,\
    \ f64::min);\n    let diff = max - min;\n    numbers.iter().map(|&n| (n - min)\
    \ / diff).collect()", "    if numbers.len() < 2 {\n        panic!(\"List length\
    \ must be at least 2\")\n    }\n\n    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \n    if min == max {\n        panic!(\"Numbers are all the same\")\n    }\n\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let (min,\
    \ max) = numbers.iter().fold((numbers[0], numbers[0]), |acc, x| {\n        (acc.0.min(*x),\
    \ acc.1.max(*x))\n    });\n    let factor = 1.0 / (max - min);\n    numbers.iter().map(|x|\
    \ (x - min) * factor).collect()", "    let (min, max) = numbers.iter().fold((numbers[0],\
    \ numbers[0]), |(min, max), &n| {\n        (\n            if n < min { n } else\
    \ { min },\n            if n > max { n } else { max },\n        )\n    });\n \
    \   let scale = 1.0 / (max - min);\n    numbers.iter().map(|&n| (n - min) * scale).collect()",
  "    let mut numbers_rescaled = numbers.clone();\n    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    for i in 0..numbers.len() {\n        numbers_rescaled[i] = (numbers[i] -\
    \ min) / (max - min);\n    }\n    numbers_rescaled", "    let min_n = numbers.iter().min().unwrap();\n\
    \    let max_n = numbers.iter().max().unwrap();\n    let scale = 1.0 / (max_n\
    \ - min_n);\n    let offset = -min_n;\n    numbers.iter().map(|n| (n + offset)\
    \ * scale).collect()", "    // find the smallest and largest number\n    let (min,\
    \ max) = numbers.iter().fold((*numbers.first().unwrap(), *numbers.first().unwrap()),\
    \ |acc, v| (acc.0.min(*v), acc.1.max(*v)));\n    numbers.iter().map(|v| (*v -\
    \ min) / (max - min)).collect()", "    let min = numbers.iter().cloned().fold(0.0\
    \ / 0.0, f64::min);\n    let max = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n\
    \    let diff = max - min;\n    if diff < 0.00001 {\n        numbers\n    } else\
    \ {\n        numbers.iter().map(|x| (x - min) / diff).collect()\n    }", "   \
    \ let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&n| (n - min) / (max - min)).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (*n - min) / (max - min)).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let min\
    \ = *numbers.iter().min().unwrap();\n    let max = *numbers.iter().max().unwrap();\n\
    \    let len = numbers.len() as f64;\n    numbers.iter().map(|n| ((n - min) /\
    \ (max - min)) * (len - 1.0)).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let number_range = max - min;\n    let unit_range = 1.0 - 0.0;\n    numbers.iter().map(|number|\
    \ (number - min) * unit_range / number_range).collect()", "    let min_val = numbers.iter().cloned().fold(0.0/0.0,\
    \ f64::min);\n    let max_val = numbers.iter().cloned().fold(0.0/0.0, f64::max);\n\
    \    let diff = max_val - min_val;\n    if diff > 0.0 {\n        numbers.iter().map(|x|\
    \ (*x - min_val) / diff).collect()\n    } else {\n        numbers\n    }", " \
    \   assert!(numbers.len() >= 2);\n    let mut result = numbers.clone();\n    let\
    \ max = *result.iter().max().unwrap();\n    let min = *result.iter().min().unwrap();\n\
    \    let max_min = max - min;\n    for i in 0..result.len() {\n        result[i]\
    \ = (result[i] - min) / max_min;\n    }\n    result", "    let max_value = numbers.iter().cloned().fold(0.0\
    \ / 0.0, f64::max);\n    let min_value = numbers.iter().cloned().fold(0.0 / 0.0,\
    \ f64::min);\n    numbers.iter().map(|&x| (x - min_value) / (max_value - min_value)).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|&x| (x - min) / (max - min)).collect()", "    let mut\
    \ scaled = numbers.clone();\n    let min = scaled.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = scaled.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let scaler = |x: f64| (x - min) / (max - min);\n    scaled.iter_mut().for_each(|x|\
    \ *x = scaler(*x));\n    scaled", "    assert!(numbers.len() >= 2);\n    let max\
    \ = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min =\
    \ numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let span = max - min;\n   \
    \ numbers.iter().map(|num| (num - min) / span).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let numbers = numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect();\n    numbers", "    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    numbers.iter().map(|x| (*x - min) / (max - min)).collect()", "    let min_number\
    \ = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    let range = max_number - min_number;\n    numbers.iter().map(|x| (x - min_number)\
    \ / range).collect()", "    let mut max = numbers[0];\n    let mut min = numbers[0];\n\
    \    for number in numbers.iter() {\n        if *number > max {\n            max\
    \ = *number;\n        }\n        if *number < min {\n            min = *number;\n\
    \        }\n    }\n    let mut rescaled = Vec::new();\n    for number in numbers.iter()\
    \ {\n        rescaled.push((number - min) / (max - min));\n    }\n    rescaled",
  "    let length = numbers.len();\n    let (mut min, mut max) = (numbers[0], numbers[0]);\n\
    \    for i in 1..length {\n        if numbers[i] < min {\n            min = numbers[i];\n\
    \        }\n        if numbers[i] > max {\n            max = numbers[i];\n   \
    \     }\n    }\n    let mut result = Vec::with_capacity(length);\n    for i in\
    \ 0..length {\n        result.push((numbers[i] - min) / (max - min));\n    }\n\
    \    result", "    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    let mut min = numbers[0];\n    for i in 0..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        if numbers[i] < min\
    \ {\n            min = numbers[i];\n        }\n    }\n    for i in 0..numbers.len()\
    \ {\n        result.push((numbers[i] - min) / (max - min));\n    }\n    result",
  "    assert!(numbers.len() >= 2);\n    let min = numbers.iter().cloned().fold(numbers[0],\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(numbers[0], f64::max);\n\
    \    let delta = max - min;\n    numbers.iter().map(|x| (x - min) / delta).collect()",
  "    let min_val = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let\
    \ max_val = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min_val) / (max_val - min_val)).collect()", "    let (min, max) = min_max(&numbers);\n\
    \    let len = numbers.len();\n    let mut result = vec![0.0; len];\n    for i\
    \ in 0..len {\n        result[i] = (numbers[i] - min) / (max - min);\n    }\n\
    \    result", "    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let scaling_factor\
    \ = 1.0 / (max - min);\n    let translation_factor = -min;\n    numbers.iter().map(|number|\
    \ (number + translation_factor) * scaling_factor).collect()", "    let n = numbers.len();\n\
    \    let mut f = numbers.clone();\n    let min = f.iter().fold(1e20, |s, &x| cmp::min(s,\
    \ x));\n    let max = f.iter().fold(-1e20, |s, &x| cmp::max(s, x));\n    for i\
    \ in 0..n {\n        f[i] = (f[i] - min) / (max - min);\n    }\n    f", "    let\
    \ min_value = numbers.iter().cloned().fold(1000000f64, f64::min);\n    let max_value\
    \ = numbers.iter().cloned().fold(-1000000f64, f64::max);\n    let spread = max_value\
    \ - min_value;\n    numbers.iter().map(|n| (n - min_value) / spread).collect()",
  "    if numbers.len() < 2 {\n        panic!(\"Cannot scale less than two numbers\"\
    );\n    }\n\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \n    numbers.iter().map(|number| (number - min) / (max - min)).collect()", " \
    \   let max = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n    let range = max -\
    \ min;\n    if range == 0.0 {\n        vec![0.0; numbers.len()]\n    } else {\n\
    \        numbers.iter().map(|&x| (x - min) / range).collect()\n    }", "    let\
    \ min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN,\
    \ f64::max);\n    let range = max - min;\n    numbers.iter().map(|n| (n - min)\
    \ / range).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let len\
    \ = numbers.len();\n    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    let range = max - min;\n    if range ==\
    \ 0.0 {\n        vec![0.0; len]\n    } else {\n        numbers.iter().map(|&number|\
    \ (number - min) / range).collect()\n    }", "    let (min, max) = (numbers.iter().min().unwrap(),\
    \ numbers.iter().max().unwrap());\n    numbers.iter().map(|x| (x - min) / (max\
    \ - min)).collect()", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    numbers.iter().map(|n| (n - min) / (max\
    \ - min)).collect()", "    assert!(numbers.len() >= 2);\n    let mut result =\
    \ Vec::with_capacity(numbers.len());\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    for n in numbers {\n        if max == min {\n            result.push(0.0);\n\
    \        } else {\n            result.push((n - min) / (max - min));\n       \
    \ }\n    }\n    result", "    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    if max != min {\n        numbers.iter().map(|n|\
    \ (n - min) / (max - min)).collect()\n    } else {\n        numbers\n    }", " \
    \   let mut scaled_list = numbers.clone();\n    let (min, max) = find_min_max(&scaled_list);\n\
    \    scaled_list.iter_mut().for_each(|x| {\n        *x = (*x - min) / (max - min);\n\
    \    });\n    scaled_list", "    let minimum = numbers.iter().min().unwrap();\n\
    \    let maximum = numbers.iter().max().unwrap();\n    numbers.iter().map(|n|\
    \ (n - minimum) / (maximum - minimum)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (*x\
    \ - min) / (max - min)).collect()", "    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let factor = 1.0 / (max - min);\n    numbers.iter().map(|x| factor * (x -\
    \ min)).collect()", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    let numbers = numbers.iter().map(|n| *n\
    \ * (1.0 / (*max - *min)) - *min).collect();\n    numbers", "    let scale = 1.0\
    \ / (numbers.iter().max().unwrap() - numbers.iter().min().unwrap());\n    numbers.iter().map(|x|\
    \ (x - numbers.iter().min().unwrap()) * scale).collect()", "    let smallest =\
    \ *numbers.iter().min().unwrap();\n    let largest = *numbers.iter().max().unwrap();\n\
    \    let diff = largest - smallest;\n    numbers.iter().map(|&x| (x - smallest)\
    \ / diff).collect()", "    if numbers.len() < 2 {\n        panic!(\"Cannot rescale\
    \ a list containing less than two elements\");\n    }\n\n    let max = numbers.iter().cloned().fold(std::f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(std::f64::INFINITY, f64::min);\n\
    \n    numbers\n        .iter()\n        .map(|&x| (x - min) / (max - min))\n \
    \       .collect()", "    let max_val = numbers.iter().fold(f64::NEG_INFINITY,\
    \ |acc, &x| {\n        acc.max(x)\n    });\n    let min_val = numbers.iter().fold(f64::INFINITY,\
    \ |acc, &x| {\n        acc.min(x)\n    });\n    let range = max_val - min_val;\n\
    \    if range == 0.0 {\n        // already unit value, just return it\n      \
    \  return numbers\n    }\n    numbers.iter().map(|x| (*x - min_val) / range).collect()",
  "    let max_val = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let min_val = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n  \
    \  let scaling_factor = (max_val - min_val).recip();\n    numbers.iter().map(|x|\
    \ (x - min_val) * scaling_factor).collect()", "    let max = numbers.iter().fold(numbers[0],\
    \ |acc, val| acc.max(*val));\n    let min = numbers.iter().fold(numbers[0], |acc,\
    \ val| acc.min(*val));\n    numbers.iter().map(|x| (*x - min) / (max - min)).collect()",
  "    let (min, max) = get_min_max(numbers);\n    numbers.iter().map(|number| (number\
    \ - min) / (max - min)).collect()", "    let mut out = Vec::with_capacity(numbers.len());\n\
    \    let max = numbers.iter().cloned().fold(0.0 / 0.0, f64::max);\n    let min\
    \ = numbers.iter().cloned().fold(0.0 / 0.0, f64::min);\n    for num in numbers\
    \ {\n        out.push((num - min) / (max - min));\n    }\n    out", "    let mut\
    \ numbers_copy = numbers.clone();\n    numbers_copy.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \    numbers_copy.iter().map(|&x| (x - numbers_copy[0]) / (numbers_copy[numbers_copy.len()\
    \ - 1] - numbers_copy[0])).collect()", "    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let max = numbers.iter().fold(f64::NEG_INFINITY, |acc, x| acc.max(*x));\n \
    \   let min = numbers.iter().fold(f64::INFINITY, |acc, x| acc.min(*x));\n    let\
    \ diff = max - min;\n    numbers.iter().map(|x| {\n        if diff > 0.0 {\n \
    \           (*x - min) / diff\n        } else {\n            0.0\n        }\n\
    \    }).collect()", "    let mut numbers = numbers;\n    let numbers_len = numbers.len();\n\
    \    assert!(numbers_len >= 2);\n\n    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n\
    \n    let smallest = numbers[0];\n    let largest = numbers[numbers_len - 1];\n\
    \n    let scale = largest - smallest;\n\n    numbers.iter().map(|n| (n - smallest)\
    \ / scale).collect()", "    if numbers.len() == 0 {\n        return vec![];\n\
    \    }\n\n    let min = numbers.iter().fold(f64::MAX, |x, y| x.min(*y));\n   \
    \ let max = numbers.iter().fold(f64::MIN, |x, y| x.max(*y));\n\n    numbers.iter().map(|&x|\
    \ (x - min) / (max - min)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|n| n -\
    \ min).map(|n| n / (max - min)).collect()", "    assert!(numbers.len() >= 2);\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    let range = if range == 0.0 { 1.0 } else { range\
    \ };\n    let offset = *min;\n    numbers.iter().map(|number| (number - offset)\
    \ / range).collect()", "    let (min, max) = numbers.iter().fold((numbers[0],\
    \ numbers[0]), |(min, max), &num| {\n        (min.min(num), max.max(num))\n  \
    \  });\n    let (mut min, mut max) = (min, max);\n    if max == min {\n      \
    \  max = min + 1.0;\n    }\n    // apply transform\n    numbers.iter().map(|&num|\
    \ {\n        (num - min) / (max - min)\n    }).collect()", "    assert!(numbers.len()\
    \ >= 2);\n    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    assert!(max > min);\n    let factor = 1.0 / (max - min);\n    let add = -min;\n\
    \    let offset = add * factor;\n    let scaled: Vec<f64> = numbers.iter().map(|n|\
    \ (*n * factor) + offset).collect();\n    assert!(scaled.iter().all(|n| n >= &0.0));\n\
    \    assert!(scaled.iter().all(|n| n <= &1.0));\n    scaled", "    let (min, max)\
    \ = find_min_max(&numbers);\n    let a = 1.0 / (max - min);\n    let b = -a *\
    \ min;\n    numbers.iter().map(|x| a * x + b).collect()", "    let mut numbers\
    \ = numbers;\n    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    numbers\
    \ = numbers.iter().map(|&x| (x - min) / (max - min)).collect();\n    numbers",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let (mut min, mut max) = (numbers[0], numbers[0]);\n    for number in numbers.iter()\
    \ {\n        if *number < min {\n            min = *number;\n        }\n     \
    \   if *number > max {\n            max = *number;\n        }\n    }\n    let\
    \ (min, max) = (min, max);\n    let scale = 1.0 / (max - min);\n    numbers.iter().map(|number|\
    \ (number - min) * scale).collect()", "    let min_number = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max_number = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let diff = max_number - min_number;\n    let coeff = 1.0 / diff;\n\
    \    let mut scaled_numbers = Vec::new();\n    for n in numbers {\n        scaled_numbers.push((n\
    \ - min_number) * coeff);\n    }\n    scaled_numbers", "    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    let range = max - min;\n    numbers.iter().map(|&x| (x - min) / range).collect()",
  "    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|n| (n -\
    \ min) / (max - min)).collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let max = *numbers.iter().max().unwrap();\n    let min = *numbers.iter().min().unwrap();\n\
    \    for number in numbers {\n        result.push((number - min) / (max - min));\n\
    \    }\n    result", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    let denom = max - min;\n    let mut output\
    \ = Vec::with_capacity(numbers.len());\n    for number in numbers {\n        output.push((number\
    \ - min) / denom);\n    }\n    output", "    let mut numbers = numbers;\n    let\
    \ max = numbers.iter().max().unwrap();\n    let min = numbers.iter().min().unwrap();\n\
    \    let width = max - min;\n    for n in numbers.iter_mut() {\n        *n = (n\
    \ - min) / width;\n    }\n    numbers", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let scale = 1.0 / (max - min);\n\
    \    let mut result = Vec::new();\n    for number in numbers {\n        result.push((number\
    \ - min) * scale);\n    }\n    result", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    // println!(\"min = {}\", min);\n    // println!(\"max = {}\", max);\n  \
    \  numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    let mut result\
    \ = numbers.clone();\n    let min = *result.iter().min().unwrap();\n    let max\
    \ = *result.iter().max().unwrap();\n    for n in result.iter_mut() {\n       \
    \ *n = (*n - min) / (max - min);\n    }\n    result", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()", "    // Get the\
    \ range of the numbers\n    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    let range = max - min;\n\n    // Scale\
    \ the numbers so that the minimum is 0 and the maximum is 1\n    numbers.iter().map(|n|\
    \ (n - min) / range).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  numbers.iter().map(|x| (x - min) / range).collect()", "    let max = numbers.iter().fold(f64::NEG_INFINITY,\
    \ |cur_max, x| cur_max.max(*x));\n    let min = numbers.iter().fold(f64::INFINITY,\
    \ |cur_min, x| cur_min.min(*x));\n    let scale = max - min;\n    numbers.iter().map(|n|\
    \ (n - min) / scale).collect()", "    let mut rescaled_numbers = Vec::new();\n\
    \    let (smallest, largest) = \n        match numbers.iter().minmax() {\n   \
    \         MinMaxResult::MinMax(smallest, largest) => (smallest, largest),\n  \
    \          _ => panic!(\"This will never happen\"),\n        };\n    let length\
    \ = largest - smallest;\n    for number in numbers {\n        rescaled_numbers.push((number\
    \ - smallest) / length);\n    }\n    rescaled_numbers", "    let (min, max) =\
    \ get_min_max(&numbers);\n    numbers.iter().map(|n| (n - min) / (max - min)).collect()",
  "    // find the max & min values\n    let mut max = numbers[0];\n    let mut min\
    \ = numbers[0];\n    for number in numbers.iter() {\n        if *number > max\
    \ {\n            max = *number;\n        }\n        if *number < min {\n     \
    \       min = *number;\n        }\n    }\n\n    let length = max - min;\n\n  \
    \  // rescale them all\n    numbers.iter().map(|x| (*x - min) / length).collect()",
  "    // Find the smallest and largest numbers\n    let smallest = numbers.iter().fold(f64::MAX,\
    \ |acc, &x| acc.min(x));\n    let largest = numbers.iter().fold(f64::MIN, |acc,\
    \ &x| acc.max(x));\n\n    // Compute the scale & offset we need to apply\n   \
    \ let scale = 1.0 / (largest - smallest);\n    let offset = -smallest;\n\n   \
    \ // Return the scaled list\n    numbers.iter().map(|&x| (x + offset) * scale).collect()",
  "    // Find smallest and largest in the list of numbers\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    // Apply linear transform\
    \ to all elements in the list\n    numbers.iter().map(|x| (x - min) / (max - min)).collect()",
  "    let max = numbers.iter().fold(f64::NEG_INFINITY, |m, &n| m.max(n));\n    let\
    \ min = numbers.iter().fold(f64::INFINITY, |m, &n| m.min(n));\n    let scale =\
    \ max - min;\n    let offset = min;\n    numbers.iter().map(|&x| (x - offset)\
    \ / scale).collect()", "    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| ((x - min)\
    \ / (max - min))).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    let diff = max - min;\n    let mut rescaled = numbers.iter().cloned().map(|x|\
    \ (x - min) / diff).collect::<Vec<f64>>();\n    rescaled.reverse();\n    rescaled",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let minmax_diff = max - min;\n    numbers.iter().map(|x| (x - min) / minmax_diff).collect()",
  "    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()", "    let (min, max) = get_min_max(&numbers);\n\
    \    if max - min > 0.0 {\n        numbers.iter().map(|&x| (x - min) / (max -\
    \ min)).collect()\n    } else {\n        numbers\n    }", "    let smallest =\
    \ *numbers.iter().min().unwrap();\n    let largest = *numbers.iter().max().unwrap();\n\
    \    let scale = largest - smallest;\n    if scale == 0.0 {\n        // Prevent\
    \ division by zero\n        vec![0.0; numbers.len()]\n    } else {\n        numbers.iter().map(|x|\
    \ (x - smallest) / scale).collect()\n    }", "    let mut numbers = numbers;\n\
    \    numbers.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    let min = numbers[0];\n\
    \    let max = numbers[numbers.len() - 1];\n    let diff = max - min;\n    let\
    \ l = numbers.len();\n    let mut result = Vec::with_capacity(l);\n    for (i,\
    \ value) in numbers.iter().enumerate() {\n        result.push((value - min) /\
    \ diff);\n    }\n    result", "    assert!(numbers.len() >= 2);\n    let max =\
    \ numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let range = max - min;\n    numbers.iter().map(|x| (*x - min)\
    \ / range).collect()", "    // TODO: this should be done inplace, to avoid making\
    \ unnecessary copies\n    let min = numbers.iter().cloned().fold(numbers[0], f64::min);\n\
    \    let max = numbers.iter().cloned().fold(numbers[0], f64::max);\n    let diff\
    \ = max - min;\n    numbers.iter().map(|n| (n - min) / diff).collect()", "   \
    \ let mut rescaled_numbers = numbers.clone();\n    let mut largest = rescaled_numbers[0];\n\
    \    let mut smallest = rescaled_numbers[0];\n    let mut index = 0;\n    while\
    \ index < rescaled_numbers.len() {\n        let number = rescaled_numbers[index];\n\
    \        if number > largest {\n            largest = number;\n        }\n   \
    \     if number < smallest {\n            smallest = number;\n        }\n    \
    \    index += 1;\n    }\n    let scale = 1.0 / (largest - smallest);\n    index\
    \ = 0;\n    while index < rescaled_numbers.len() {\n        rescaled_numbers[index]\
    \ = (rescaled_numbers[index] - smallest) * scale;\n        index += 1;\n    }\n\
    \    rescaled_numbers", "    let min = numbers.iter().min().unwrap();\n    let\
    \ max = numbers.iter().max().unwrap();\n    numbers.iter().map(|&n| (n - min)\
    \ / (max - min)).collect()", "    let (min, max) = find_min_max(&numbers);\n \
    \   apply_linear_transform(&numbers, min, max)", "    let mut numbers_iter = numbers.into_iter();\n\
    \    let min = numbers_iter.clone().min().unwrap();\n    let max = numbers_iter.max().unwrap();\n\
    \    if max - min < 0.001 {\n        vec![0.5; numbers.len()]\n    } else {\n\
    \        numbers.into_iter().map(|x| (x - min) / (max - min)).collect()\n    }",
  "    assert!(numbers.len() >= 2);\n    let (min, max) = numbers.iter().fold((f64::MAX,\
    \ f64::MIN), |(a, b), &x| {\n        (a.min(x), b.max(x))\n    });\n    numbers.iter().map(|x|\
    \ (*x - min) / (max - min)).collect()", "    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    numbers.iter().map(|n| (*n\
    \ - min) / (max - min)).collect()", "    assert!(numbers.len() >= 2);\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|number| {\n        if max - min <= 0.0 {\n          \
    \  return 0.0;\n        }\n        (number - min) / (max - min)\n    }).collect()",
  "    let m = numbers.iter().min().unwrap();\n    let M = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - m) / (M - m)).collect()", "    let lowest = numbers.iter().min().unwrap();\n\
    \    let highest = numbers.iter().max().unwrap();\n    numbers.iter().map(|x|\
    \ (x - lowest) / (highest - lowest)).collect()", "    let mut result = numbers.clone();\n\
    \    let max = result.iter().max().unwrap();\n    let min = result.iter().min().unwrap();\n\
    \    let delta = *max - *min;\n    for i in 0..result.len() {\n        result[i]\
    \ = (result[i] - *min) / delta;\n    }\n    result", "    let smallest = numbers.iter().fold(f64::MAX,\
    \ |m, &n| m.min(n));\n    let largest = numbers.iter().fold(f64::MIN, |m, &n|\
    \ m.max(n));\n    let denominator = largest - smallest;\n    let mut result =\
    \ Vec::with_capacity(numbers.len());\n    for n in numbers {\n        let transformed\
    \ = (n - smallest) / denominator;\n        result.push(transformed);\n    }\n\
    \    result", "    assert!(numbers.len() >= 2);\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|n| (n -\
    \ min) / (max - min)).collect()", "    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let range = max - min;\n    numbers.iter().map(|n| (n - min) / range).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|x| (x - min) / (max - min)).collect()", "    // TODO\
    \ refactor to get rid of copy\n    let mut res = Vec::new();\n    let mut smallest_num\
    \ = numbers[0];\n    let mut largest_num = numbers[0];\n    for number in numbers.iter()\
    \ {\n        if number < &smallest_num {\n            smallest_num = *number;\n\
    \        }\n        if number > &largest_num {\n            largest_num = *number;\n\
    \        }\n    }\n    let range = largest_num - smallest_num;\n    for number\
    \ in numbers.iter() {\n        let x = (number - &smallest_num) / &range;\n  \
    \      res.push(x);\n    }\n    res", "    let num_numbers = numbers.len();\n\
    \    let mut rescaled_numbers = Vec::with_capacity(num_numbers);\n\n    // Find\
    \ min and max value of the input vector\n    let mut max_value = numbers[0];\n\
    \    let mut min_value = numbers[0];\n    for &x in numbers.iter() {\n       \
    \ if x > max_value {\n            max_value = x;\n        }\n        if x < min_value\
    \ {\n            min_value = x;\n        }\n    }\n\n    // Rescale the input\
    \ vector to [0; 1]\n    for x in numbers.iter() {\n        let scaled_x = (x -\
    \ min_value) / (max_value - min_value);\n        rescaled_numbers.push(scaled_x);\n\
    \    }\n\n    rescaled_numbers", "    let smallest = numbers.iter().min().unwrap();\n\
    \    let largest = numbers.iter().max().unwrap();\n    let scale = largest - smallest;\n\
    \    let shift = *smallest;\n    let mut rescaled_list = numbers.clone();\n  \
    \  rescaled_list.iter_mut().for_each(|x| *x = (*x - shift) / scale);\n    rescaled_list",
  "    let mut min_value = f64::MAX;\n    let mut max_value = f64::MIN;\n\n    for\
    \ n in numbers.iter() {\n        if *n < min_value {\n            min_value =\
    \ *n;\n        }\n\n        if *n > max_value {\n            max_value = *n;\n\
    \        }\n    }\n\n    let mut result = Vec::new();\n\n    for n in numbers.iter()\
    \ {\n        result.push((*n - min_value) / (max_value - min_value));\n    }\n\
    \n    result", "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()", "    // for each\
    \ of the inputs we want to transform it to x and then return the result\n    numbers\n\
    \        .iter()\n        .map(|x| rescale_to_unit_single(*x, numbers.as_slice()))\n\
    \        .collect()", "    let mut v = numbers.clone();\n    let min = v.iter().min().unwrap();\n\
    \    let max = v.iter().max().unwrap();\n    let divisor = max - min;\n    v.iter_mut().for_each(|x|\
    \ *x = (*x - min) / divisor);\n    v", "    let mut rescaled = numbers.clone();\n\
    \    let min_number = rescaled.iter().min().unwrap();\n    let max_number = rescaled.iter().max().unwrap();\n\
    \    let mut range = max_number - min_number;\n    if range == 0.0 {\n       \
    \ range = 1.0;\n    }\n    for i in 0..rescaled.len() {\n        rescaled[i] =\
    \ (rescaled[i] - min_number) / range;\n    }\n    rescaled", "    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    let range = max - min;\n    let scale = if range == 0.0 {\n        1.0\n\
    \    } else {\n        1.0 / range\n    };\n    numbers.iter().map(|x| (x - min)\
    \ * scale).collect()", "    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let range\
    \ = max - min;\n    let mut list = Vec::new();\n    for num in numbers {\n   \
    \     list.push((num - min) / range);\n    }\n    list", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|n| (*n\
    \ - min) / (max - min)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let abs_diff = (max - min).abs();\n\
    \    numbers.iter().map(|x| (x - min) / abs_diff).collect()", "    if numbers.len()\
    \ < 2 {\n        println!(\"At least two numbers must be provided\");\n      \
    \  panic!(\"Not enough numbers\");\n    }\n\n    let min_x = numbers.iter().min().unwrap();\n\
    \    let max_x = numbers.iter().max().unwrap();\n\n    let c = 1.0 / (max_x -\
    \ min_x);\n    let b = -min_x * c;\n\n    numbers.iter().map(|x| c * x + b).collect()",
  "    let num_min = numbers.iter().cloned().fold(numbers[0], f64::min);\n    let\
    \ num_max = numbers.iter().cloned().fold(numbers[0], f64::max);\n    let scale\
    \ = (num_max - num_min).recip();\n    let offset = -num_min;\n    numbers.iter().map(|&x|\
    \ (x + offset) * scale).collect()", "    let numbers_max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let numbers_min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let scale = numbers_max - numbers_min;\n    let shift = numbers_min;\n\
    \    numbers.iter().map(|x| (x - shift) / scale).collect()", "    let (min, max)\
    \ = (numbers.iter().min().unwrap(), numbers.iter().max().unwrap());\n    let f\
    \ = 1.0 / (max - min);\n    numbers.iter().map(|x| f * (x - min)).collect()",
  "    let mut scale_factor = 1.0;\n    let max = numbers.iter().max_by(|x, y| x.partial_cmp(y).unwrap()).unwrap();\n\
    \    let min = numbers.iter().min_by(|x, y| x.partial_cmp(y).unwrap()).unwrap();\n\
    \    scale_factor = 1.0 / (*max - *min);\n    let mut rescaled = numbers.clone();\n\
    \    rescaled.iter_mut().for_each(|x| *x = (x - min) * scale_factor);\n    rescaled",
  "    if numbers.len() < 2 {\n        panic!(\"at least two numbers are required\
    \ to rescale the list\")\n    }\n\n    let min_value = numbers.iter().min().unwrap();\n\
    \    let max_value = numbers.iter().max().unwrap();\n\n    let domain = max_value\
    \ - min_value;\n\n    numbers.iter().map(|n| {\n        (n - min_value) / domain\n\
    \    }).collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let delta = max - min;\n    for n in numbers {\n        result.push((n -\
    \ min) / delta);\n    }\n    result", "    let mut result = Vec::new();\n    let\
    \ mut max_number = 0.0;\n    let mut min_number = 1000000.0;\n\n    for num in\
    \ numbers {\n        if num > max_number {\n            max_number = num;\n  \
    \      }\n        if num < min_number {\n            min_number = num;\n     \
    \   }\n    }\n\n    let slope = 1.0 / (max_number - min_number);\n    let offset\
    \ = -min_number;\n\n    for num in numbers {\n        result.push(slope * (num\
    \ + offset));\n    }\n\n    result", "    if numbers.len() < 2 {\n        panic!(\"\
    Only works with lists of at least two elements\");\n    }\n\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n\n    if min == max {\n       \
    \ return numbers.iter().map(|&number| 1.0).collect();\n    }\n\n    numbers.iter().map(|&number|\
    \ (number - min) / (max - min)).collect()", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|value| (value - min) / (max - min)).collect()", "   \
    \ let mut numbers = numbers;\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    for n in numbers.iter_mut() {\n        *n = (*n - min) / (max - min);\n \
    \   }\n    numbers", "    let min = *numbers.iter().min().unwrap();\n    let max\
    \ = *numbers.iter().max().unwrap();\n    let range = max - min;\n    numbers.iter().map(|&x|\
    \ (x - min) / range).collect()", "    let max = numbers.iter().cloned().fold(0./0.,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(0./0., f64::min);\n \
    \   let denominator = max - min;\n    numbers.iter().map(|x| (x - min) / denominator).collect()",
  "    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n    let max =\
    \ numbers.iter().cloned().fold(f64::MIN, f64::max);\n    let factor = 1.0 / (max\
    \ - min);\n    let offset = -min;\n    numbers.iter().map(|x| (x + offset) * factor).collect()",
  "    if numbers.len() < 2 {\n        panic!(\"Cannot rescale less than two numbers\"\
    );\n    }\n\n    let minimum = numbers.iter().min().unwrap();\n    let maximum\
    \ = numbers.iter().max().unwrap();\n\n    let mut rescaled = Vec::new();\n   \
    \ for n in numbers {\n        let scaled = (n - minimum) / (maximum - minimum);\n\
    \        rescaled.push(scaled);\n    }\n\n    rescaled", "    let min = *numbers.iter().min().unwrap();\n\
    \    let max = *numbers.iter().max().unwrap();\n    let delta = max - min;\n \
    \   numbers.iter().map(|&x| (x - min) / delta).collect()", "    let min = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let scale = max - min;\n    numbers.iter().map(|n| (*n - min) / scale).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let mut output: Vec<f64> = Vec::new();\n    for number in numbers {\n   \
    \     output.push((number - min) / (max - min));\n    }\n    output", "    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    if max - min > 0.0 {\n        numbers.iter().map(|n| (n - min) / (max - min)).collect()\n\
    \    } else {\n        numbers\n    }", "    let mut result = numbers.clone();\n\
    \    let min = result.iter().min().unwrap();\n    let max = result.iter().max().unwrap();\n\
    \    for x in result.iter_mut() {\n        *x = (*x - min) / (max - min);\n  \
    \  }\n    result", "    let min = numbers.iter().cloned().fold(0.0/0.0, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(0.0/0.0, f64::max);\n    if max ==\
    \ min {\n        vec![1.0; numbers.len()]\n    } else {\n        numbers.iter().map(|x|\
    \ (x - min) / (max - min)).collect()\n    }", "    // Find largest and smallest\
    \ element of the list\n    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]),\
    \ |acc, x| {\n        (acc.0.min(*x), acc.1.max(*x))\n    });\n\n    // Apply\
    \ the transformation\n    numbers.iter().map(|x| (*x - min) / (max - min)).collect()",
  "    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let max\
    \ = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let scale\
    \ = 1.0 / (max - min);\n    numbers.iter().map(|x| scale * (x - min)).collect()",
  "    // TODO: test that we have at least two elements\n    let smallest = numbers.iter().min().unwrap();\n\
    \    let largest = numbers.iter().max().unwrap();\n    numbers.iter().map(|n|\
    \ (*n - smallest) / (largest - smallest)).collect()", "    let (min, max) = min_max(&numbers);\n\
    \    let change = max - min;\n    if change == 0.0 {\n        numbers\n    } else\
    \ {\n        numbers.iter().map(|num| (num - min) / change).collect()\n    }",
  "    let mut numbers = numbers;\n    let minimum = numbers.iter().cloned().fold(std::f64::MAX,\
    \ f64::min);\n    let maximum = numbers.iter().cloned().fold(std::f64::MIN, f64::max);\n\
    \    let diff = maximum - minimum;\n    numbers.iter_mut().for_each(|x| *x = (*x\
    \ - minimum) / diff);\n    numbers", "    let max_number = numbers.iter().fold(0.0,\
    \ |max, n| n.max(max));\n    let min_number = numbers.iter().fold(std::f64::MAX,\
    \ |min, n| n.min(min));\n    let range = max_number - min_number;\n    let denominator\
    \ = range;\n    numbers.iter().map(|n| (*n - min_number) / denominator).collect()",
  "    let mut numbers = numbers;\n    let largest = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let smallest = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let diff = largest - smallest;\n    if diff == 0.0 {\n        let diff =\
    \ largest;\n        numbers = numbers.iter().map(|x| *x / diff).collect();\n \
    \   } else {\n        numbers = numbers.iter().map(|x| (*x - smallest) / diff).collect();\n\
    \    }\n    numbers", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let (mut max, mut min) = (numbers[0], numbers[0]);\n    for number in numbers\
    \ {\n        if number > max {\n            max = number;\n        }\n       \
    \ if number < min {\n            min = number;\n        }\n    }\n    let range\
    \ = max - min;\n    for number in numbers {\n        result.push((number - min)\
    \ / range);\n    }\n    result", "    assert!(numbers.len() >= 2);\n    let min_max\
    \ = [numbers.iter().min_by(|a, b| a.partial_cmp(b).unwrap()).unwrap(),\n     \
    \   numbers.iter().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap()];\n    //\
    \ given list of numbers in some range, compute new numbers, such that smallest\
    \ number\n    // is 0 and the largest is 1\n    numbers.iter().map(|x| (x - min_max[0])\
    \ / (min_max[1] - min_max[0])).collect()", "    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (*x - min) / range).collect()",
  "    assert!(numbers.len() >= 2);\n    let mut result = numbers.clone();\n    let\
    \ min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    for x in result.iter_mut() {\n        *x = (*x - min) / (max - min);\n  \
    \  }\n    result", "    let (min, max) = min_max(numbers.clone());\n    numbers.iter().map(|n|\
    \ ((n - min) / (max - min))).collect()", "    let min = numbers.iter().cloned().fold(f64::MAX,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n\
    \    let delta = max - min;\n    numbers.iter().map(|n| (n - min) / delta).collect()",
  "    let max = numbers.iter().fold(std::f64::NEG_INFINITY, |a, b| a.max(*b));\n\
    \    let min = numbers.iter().fold(std::f64::INFINITY, |a, b| a.min(*b));\n  \
    \  let difference = max - min;\n    numbers.iter().map(|number| (*number - min)\
    \ / difference).collect()", "    let smallest = numbers.iter().fold(f64::MAX,\
    \ |a, &b| a.min(b));\n    let largest = numbers.iter().fold(f64::MIN, |a, &b|\
    \ a.max(b));\n    let scale = largest - smallest;\n    return numbers.iter().map(|&x|\
    \ (x - smallest) / scale).collect();", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    numbers.iter().map(|x| (x -\
    \ min) / (max - min)).collect()", "    let largest = numbers.iter().cloned().fold(f64::NEG_INFINITY,\
    \ f64::max);\n    let smallest = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n\
    \    let range = largest - smallest;\n    return numbers.iter().map(|x| (x - smallest)\
    \ / range).collect();", "    let min = numbers.iter().cloned().fold(f64::INFINITY,\
    \ f64::min);\n    let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n\
    \    numbers.iter().map(|n| (n - min) / (max - min)).collect()", "    let min\
    \ = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let range = max - min;\n    numbers.iter().map(|x| (x - min) / range).collect()",
  "    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]), |(a, b), &c|\
    \ {\n        if c < a {\n            (c, b)\n        } else if c > b {\n     \
    \       (a, c)\n        } else {\n            (a, b)\n        }\n    });\n   \
    \ let range = max - min;\n    numbers.iter().map(|&x| (x - min) / range).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let slope = 1.0 / (max - min);\n    let mut res = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        res.push((number - min) * slope);\n    }\n\
    \    res", "    // small helper, that returns smallest and largest element in\
    \ one step\n    let (min, max) = numbers.iter().fold((numbers[0], numbers[0]),\
    \ |(min, max), &x| {\n        (f64::min(min, x), f64::max(max, x))\n    });\n\n\
    \    // do the actual rescaling\n    numbers.iter().map(|&x| (x - min) / (max\
    \ - min)).collect()", "    let min = numbers.iter().cloned().fold(f64::MAX, f64::min);\n\
    \    let max = numbers.iter().cloned().fold(f64::MIN, f64::max);\n    numbers.iter().map(|n|\
    \ (n - min) / (max - min)).collect()", "    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let mut result = Vec::new();\n\
    \    for x in numbers {\n        let y = (x - min) / (max - min);\n        result.push(y);\n\
    \    }\n    result", "    let min = numbers.iter().min().unwrap();\n    let max\
    \ = numbers.iter().max().unwrap();\n    let diff = max - min;\n    numbers.iter().map(|x|\
    \ (x - min) / diff).collect()", "    assert!(numbers.len() >= 2);\n    let mut\
    \ output: Vec<f64> = numbers.clone();\n    let min = numbers.iter().min().unwrap();\n\
    \    let max = numbers.iter().max().unwrap();\n    let range = max - min;\n  \
    \  output.iter_mut().for_each(|n| *n = (*n - min) / range);\n    output", "  \
    \  let max = numbers.iter().cloned().fold(f64::NEG_INFINITY, f64::max);\n    let\
    \ min = numbers.iter().cloned().fold(f64::INFINITY, f64::min);\n    let difference\
    \ = max - min;\n    numbers.iter().map(|&n| (n - min) / difference).collect()",
  "    let min_number = numbers.iter().min().unwrap();\n    let max_number = numbers.iter().max().unwrap();\n\
    \    numbers.iter().map(|number| (number - min_number) / (max_number - min_number)).collect()",
  "    let min = numbers.iter().min().unwrap();\n    let max = numbers.iter().max().unwrap();\n\
    \    let span = max - min;\n    if span < 1.0e-9 {\n        // This is a bit hacky.\
    \ It's designed for the case where the numbers are all\n        // close enough\
    \ to each other that the min and max are equal. In that case,\n        // the\
    \ span would be zero, and the loop below would divide by zero.\n        // So\
    \ instead, the loop below is bypassed and the rescaling is done manually.\n  \
    \      let mid = (min + max) / 2.0;\n        numbers.iter().map(|&x| (x - mid)\
    \ / mid).collect()\n    } else {\n        numbers.iter().map(|&x| (x - min) /\
    \ span).collect()\n    }"]
stop_tokens:
- "\n}"
