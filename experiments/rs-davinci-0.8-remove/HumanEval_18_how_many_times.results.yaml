language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let n = string.len();\n    let m = substring.len();\n\
    \    let mut count = 0;\n    let mut i = 0;\n    while i <= n - m {\n        if\
    \ &string[i..i + m] == substring {\n            count += 1;\n            i +=\
    \ m;\n        } else {\n            i += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgpt5g7yu.rs:7:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821619
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // a tricky way to convert a string to a slice (the\
    \ result is a borrow)\n    let string_slice = string.as_str();\n    let mut count\
    \ = 0;\n    let mut start_pos = 0;\n    while let Some(pos) = string_slice[start_pos..].find(&substring)\
    \ {\n        start_pos += pos + 1;\n        count += 1;\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string = string.as_bytes();\n    let substring =\
    \ substring.as_bytes();\n    let mut count = 0;\n    let mut i = 0;\n    let mut\
    \ length = 0;\n    let mut check = true;\n    while i < string.len() {\n     \
    \   let mut j = 0;\n        while i + j < string.len() && j < substring.len()\
    \ && string[i + j] == substring[j] {\n            j += 1;\n        }\n       \
    \ if j == substring.len() {\n            count += 1;\n            if check {\n\
    \                length = substring.len();\n                check = false;\n \
    \           }\n            i += length;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsrawknfd.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let sublength = substring.len();\n  let mut times = 0;\n\
    \  let mut index = 0;\n  let mut start = 0;\n  let mut end = 0;\n  loop {\n  \
    \  if index > string.len() {\n      break;\n    }\n\n    start = string.find(&substring[..]).unwrap_or(string.len());\n\
    \    end = start + sublength;\n    if start < string.len() {\n      times += 1;\n\
    \    }\n\n    index = end;\n    string = string[index..].to_string();\n  }\n\n\
    \  times\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `start` is never read\n --> /tmp/tmpcxnhiugd.rs:6:11\n\
    \  |\n6 |   let mut start = 0;\n  |           ^^^^^\n  |\n  = note: `#[warn(unused_assignments)]`\
    \ on by default\n  = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `end` is never read\n --> /tmp/tmpcxnhiugd.rs:7:11\n  |\n\
    7 |   let mut end = 0;\n  |           ^^^\n  |\n  = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `string`\n\
    \  --> /tmp/tmpcxnhiugd.rs:20:5\n   |\n2  | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                   ------ help: consider\
    \ making this binding mutable: `mut string`\n...\n20 |     string = string[index..].to_string();\n\
    \   |     ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to\
    \ previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut last_index = 0;\n  \
    \  let mut substring_len = substring.len();\n    let mut string_len = string.len();\n\
    \    let mut string_chars = string.chars();\n    let mut substring_chars = substring.chars();\n\
    \    let mut string_iter = string_chars.clone();\n    let mut substring_iter =\
    \ substring_chars.clone();\n    while last_index != string_len {\n        string_iter.next();\n\
    \        substring_iter.next();\n        if string_iter.eq(substring_iter) {\n\
    \            count += 1;\n            last_index += substring_len;\n         \
    \   string_iter = string_chars.clone();\n            string_iter.nth(last_index);\n\
    \            substring_iter = substring_chars.clone();\n        }\n    }\n   \
    \ count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmp6xzv1l3p.rs:5:9\n\
    \  |\n5 |     let mut substring_len = substring.len();\n  |         ----^^^^^^^^^^^^^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/tmp6xzv1l3p.rs:6:9\n\
    \  |\n6 |     let mut string_len = string.len();\n  |         ----^^^^^^^^^^\n\
    \  |         |\n  |         help: remove this `mut`\n\nwarning: variable does\
    \ not need to be mutable\n --> /tmp/tmp6xzv1l3p.rs:7:9\n  |\n7 |     let mut string_chars\
    \ = string.chars();\n  |         ----^^^^^^^^^^^^\n  |         |\n  |        \
    \ help: remove this `mut`\n\nwarning: variable does not need to be mutable\n -->\
    \ /tmp/tmp6xzv1l3p.rs:8:9\n  |\n8 |     let mut substring_chars = substring.chars();\n\
    \  |         ----^^^^^^^^^^^^^^^\n  |         |\n  |         help: remove this\
    \ `mut`\n\nerror[E0382]: borrow of moved value: `string_iter`\n    --> /tmp/tmp6xzv1l3p.rs:12:9\n\
    \     |\n9    |     let mut string_iter = string_chars.clone();\n     |      \
    \   --------------- move occurs because `string_iter` has type `Chars<'_>`, which\
    \ does not implement the `Copy` trait\n...\n12   |         string_iter.next();\n\
    \     |         ^^^^^^^^^^^ value borrowed here after move\n13   |         substring_iter.next();\n\
    14   |         if string_iter.eq(substring_iter) {\n     |                   \
    \     ------------------ `string_iter` moved due to this method call, in previous\
    \ iteration of loop\n...\n17   |             string_iter = string_chars.clone();\n\
    \     |             ---------------------------------- this reinitialization might\
    \ get skipped\n     |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `string_iter`\n\nerror[E0382]: borrow of moved value: `substring_iter`\n\
    \  --> /tmp/tmp6xzv1l3p.rs:13:9\n   |\n10 |     let mut substring_iter = substring_chars.clone();\n\
    \   |         ------------------ move occurs because `substring_iter` has type\
    \ `Chars<'_>`, which does not implement the `Copy` trait\n...\n13 |         substring_iter.next();\n\
    \   |         ^"
  stdout: ''
  timestamp: 1659821619
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut result = 0;\n    let mut prev_occurence = -1;\n\
    \    let mut index: isize = 0;\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    while index >= 0 {\n        index = string.find(&substring);\n\
    \        if index != None {\n            index = index.unwrap() as isize;\n  \
    \          if index >= prev_occurence + substring_len as isize {\n           \
    \     result += 1;\n                prev_occurence = index;\n            }\n \
    \           string = string[index as usize + substring_len..string_len].to_string();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplvi5afl3.rs:9:17\n  |\n9 |\
    \         index = string.find(&substring);\n  |                 ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n  |\n  = note: expected type `isize`\n\
    \             found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmplvi5afl3.rs:10:21\n   |\n10 |         if index != None {\n   | \
    \                    ^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<_>`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmplvi5afl3.rs:11:27\n   |\n11 |             index = index.unwrap() as\
    \ isize;\n   |                           ^^^^^^ method not found in `isize`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        if &string[index..index + substring.len()] ==\
    \ substring {\n            count += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmp4ikt80mq.rs:6:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let chars_string = string.chars().collect::<Vec<char>>();\n\
    \    let chars_substring = substring.chars().collect::<Vec<char>>();\n    let\
    \ mut number_of_times = 0;\n    let mut i = 0;\n    let mut j = 0;\n    loop {\n\
    \        if i >= chars_string.len() {\n            break;\n        }\n       \
    \ if chars_string[i] == chars_substring[j] {\n            j += 1;\n          \
    \  if j == chars_substring.len() {\n                number_of_times += 1;\n  \
    \              j = 0;\n            }\n        } else {\n            j = 0;\n \
    \       }\n        i += 1;\n    }\n    number_of_times\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmput5gmarb.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut is_substring = false;\n\
    \    let mut last_match_index = 0;\n    let substring_len = substring.len();\n\
    \    let string_len = string.len();\n    let mut string_iter = string.chars();\n\
    \    let mut substring_iter = substring.chars();\n    for _ in 0..substring_len\
    \ {\n        if substring_iter.next() == string_iter.next() {\n            is_substring\
    \ = true;\n        } else {\n            is_substring = false;\n            break;\n\
    \        }\n    }\n    if is_substring {\n        count += 1;\n        last_match_index\
    \ = string_len - substring_len;\n    }\n    for i in substring_len..string_len\
    \ {\n        if is_substring {\n            string_iter.next();\n            if\
    \ substring_iter.next() == string_iter.next() {\n                is_substring\
    \ = true;\n                last_match_index = i;\n            } else {\n     \
    \           is_substring = false;\n            }\n        } else {\n         \
    \   if last_match_index + substring_len < string_len {\n                for _\
    \ in last_match_index + 1..last_match_index + substring_len + 1 {\n          \
    \          string_iter.next();\n                }\n                if substring_iter.next()\
    \ == string_iter.next() {\n                    is_substring = true;\n        \
    \            last_match_index = i;\n                } else {\n               \
    \     is_substring = false;\n                }\n            }\n        }\n   \
    \     if is_substring {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpvcx0owye.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut result = 0;\n    let mut last_index = 0;\n \
    \   let substring_len = substring.len();\n    while let Some(index) = string[last_index..].find(&substring)\
    \ {\n        last_index += index + substring_len;\n        result += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpyuedziq2.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut how_many = 0;\n    let mut index = 0;\n    while\
    \ index != -1 {\n        index = string.find(&substring).unwrap_or(-1);\n    \
    \    if index != -1 {\n            how_many += 1;\n            let mut new_string\
    \ = String::from(&string[index + substring.len()..]);\n            new_string.push_str(string.as_str());\n\
    \            string = new_string;\n        }\n    }\n    how_many\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n --> /tmp/tmpqh5_wo_z.rs:6:51\n\
    \  |\n6 |         index = string.find(&substring).unwrap_or(-1);\n  |        \
    \                                           ^^\n  |                          \
    \                         |\n  |                                             \
    \      cannot apply unary operator `-`\n  |                                  \
    \                 help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \  |\n  = note: unsigned values cannot be negated\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n --> /tmp/tmpqh5_wo_z.rs:5:20\n  |\n5 |     while\
    \ index != -1 {\n  |                    ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \ --> /tmp/tmpqh5_wo_z.rs:7:21\n  |\n7 |         if index != -1 {\n  |       \
    \              ^^\n  |                     |\n  |                     cannot apply\
    \ unary operator `-`\n  |                     help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() > string.len() {\n        return\
    \ 0;\n    }\n\n    let mut total_found: isize = 0;\n    let string_chars: Vec<char>\
    \ = string.chars().collect();\n    let substring_chars: Vec<char> = substring.chars().collect();\n\
    \n    let mut index: usize = 0;\n    while index < string.len() {\n        let\
    \ mut count: usize = 0;\n        while index + count < string.len() && count <\
    \ substring.len() && string_chars[index + count] == substring_chars[count] {\n\
    \            count += 1;\n        }\n\n        if count == substring.len() {\n\
    \            total_found += 1;\n            index += count;\n        } else {\n\
    \            index += 1;\n        }\n    }\n\n    total_found\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpnv5i2gq2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start_index = 0;\n \
    \   let substring_len = substring.len();\n    while let Some(index) = string[start_index..].find(&substring)\
    \ {\n        count += 1;\n        start_index = index + substring_len;\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821624
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let length_of_substring = substring.len();\n    let\
    \ length_of_string = string.len();\n    let mut count = 0;\n    let mut start\
    \ = 0;\n    while start + length_of_substring <= length_of_string {\n        if\
    \ string[start..(start + length_of_substring)] == substring {\n            count\
    \ += 1;\n            start += length_of_substring;\n        } else {\n       \
    \     start += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbgn_avos.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut s = 0;\n    let mut e = 0;\n    let mut i =\
    \ 0;\n    while i < string.len() - substring.len() + 1 {\n        s = i;\n   \
    \     e = i + substring.len();\n        if string[s..e] == substring {\n     \
    \       i += substring.len();\n        } else {\n            i += 1;\n       \
    \ }\n    }\n    i as isize - string.len() as isize + substring.len() as isize\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgpn9fer4.rs:6:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() == 0 {\n        return 0;\n    }\n\
    \    let sublen = substring.len();\n    let mut count = 0;\n    let length = string.len();\n\
    \    let mut last_index = 0;\n    let mut i = 0;\n    while i < length {\n   \
    \     if &string[i..i + sublen] == substring {\n            last_index = i + sublen;\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmp4b8drdfj.rs:12:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ string_len = string.len();\n    let substring_len = substring.len();\n    while\
    \ index < string_len {\n        if string[index..index + substring_len] == substring\
    \ {\n            count += 1;\n            index += substring_len;\n        } else\
    \ {\n            index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmptc6h5rye.rs:8:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821619
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut number = 0;\n    let mut index = 0;\n    let\
    \ string = &string[..];\n    let substring = &substring[..];\n    let mut length\
    \ = substring.len();\n    let mut times = string.len() - length + 1;\n    for\
    \ i in 0..times {\n        if string[i..length] == substring {\n            number\
    \ += 1;\n            length += 1;\n            times += 1;\n        } else {\n\
    \            length += 1;\n        }\n    }\n    number\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp2hx07tbr.rs:10:30\n\
    \   |\n10 |         if string[i..length] == substring {\n   |                \
    \              ^^ no implementation for `str == &str`\n   |\n   = help: the trait\
    \ `PartialEq<&str>` is not implemented for `str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if !string.contains(&substring) {\n        return 0;\n\
    \    }\n\n    let count = string.matches(&substring).count();\n    let mut curr_count\
    \ = 0;\n    let mut min_count = 0;\n    let mut max_count = 0;\n    let mut saved_count\
    \ = 0;\n    let mut saved_string = \"\".to_string();\n    let mut saved_substring\
    \ = \"\".to_string();\n\n    for i in 1..count {\n        curr_count = i;\n  \
    \      min_count = string.matches(&substring).nth(i as usize - 1).unwrap().len();\n\
    \        max_count = string.matches(&substring).nth(i as usize).unwrap().len();\n\
    \        saved_count = 0;\n        saved_string = \"\".to_string();\n        saved_substring\
    \ = \"\".to_string();\n\n        while min_count != max_count {\n            if\
    \ min_count > max_count {\n                min_count -= 1;\n                saved_count\
    \ += 1;\n                saved_string = string[0..string.len() - saved_count].to_string();\n\
    \                saved_substring = substring[0..substring.len() - saved_count].to_string();\n\
    \            } else {\n                max_count -= 1;\n                saved_count\
    \ += 1;\n                saved_string = string[0..string.len() - saved_count].to_string();\n\
    \                saved_substring = substring[0..substring.len() - saved_count].to_string();\n\
    \            }\n        }\n\n        if saved_string.matches(&saved_substring).count()\
    \ == count {\n            curr_count += saved_count as isize;\n        }\n   \
    \ }\n\n    count as isize - curr_count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpix2cle0q.rs:38:27\n   |\n\
    38 |             curr_count += saved_count as isize;\n   |                   \
    \        ^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmpix2cle0q.rs:38:24\n   |\n\
    38 |             curr_count += saved_count as isize;\n   |                   \
    \     ^^ no implementation for `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>`\
    \ is not implemented for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpix2cle0q.rs:42:22\n\
    \   |\n42 |     count as isize - curr_count\n   |                      ^^^^^^^^^^\
    \ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from\
    \ `isize`\n  --> /tmp/tmpix2cle0q.rs:42:20\n   |\n42 |     count as isize - curr_count\n\
    \   |                    ^ no implementation for `isize - usize`\n   |\n   = help:\
    \ the trait `Sub<usize>` is not implemented for `isize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut total = 0;\n    let mut found = string.find(&substring);\n\
    \    while found.is_some() {\n        total += 1;\n        found = string[found.unwrap()\
    \ + 1..].find(&substring);\n    }\n    total\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821624
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let mut index = 0;\n  let mut count = 0;\n  let (s_len,\
    \ sub_len) = (string.len(), substring.len());\n  if s_len < sub_len {\n    return\
    \ 0;\n  }\n  while index + sub_len <= s_len {\n    if string[index..index + sub_len]\
    \ == substring {\n      count += 1;\n      index += sub_len;\n    } else {\n \
    \     index += 1;\n    }\n  }\n  count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprfosihjs.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821619
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut n_times = 0;\n    for i in 0..string.len() {\n\
    \        if substring.len() > string.len() - i {\n            break;\n       \
    \ }\n        if string[i..i + substring.len()] == substring {\n            n_times\
    \ += 1;\n        }\n    }\n    n_times\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string = string.as_bytes();\n    let substring =\
    \ substring.as_bytes();\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut found;\n    while index < string.len() {\n        found = true;\n      \
    \  for sub_index in 0..substring.len() {\n            if string[index + sub_index]\
    \ != substring[sub_index] {\n                found = false;\n                break;\n\
    \            }\n        }\n        if found {\n            count += 1;\n     \
    \       index += substring.len();\n        } else {\n            index += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmp697luus2.rs:11:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821619
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string_len {\n        if &string[i..i + substring_len] == substring {\n  \
    \          count += 1;\n            i += substring_len;\n        } else {\n  \
    \          i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmpvw6pkgrd.rs:8:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut times = 0;\n    let mut pos = 0;\n    let string_len\
    \ = string.len();\n    let substring_len = substring.len();\n    while pos <=\
    \ string_len - substring_len {\n        if string[pos..pos + substring_len] ==\
    \ substring {\n            times += 1;\n            pos += substring_len;\n  \
    \      } else {\n            pos += 1;\n        }\n    }\n    times\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpsddhk2xm.rs:7:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let substring_length = substring.len();\n    if substring_length\
    \ > string.len() {\n        return 0;\n    }\n    let string_bytes = string.as_bytes();\n\
    \    let substring_bytes = substring.as_bytes();\n    let mut count = 0;\n   \
    \ let mut begin = 0;\n    while begin + substring_length <= string.len() {\n \
    \       if &string_bytes[begin..begin + substring_length] == substring_bytes {\n\
    \            count += 1;\n            begin += substring_length;\n        } else\
    \ {\n            begin += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3mv5ur4z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let n = string.len();\n    let\
    \ m = substring.len();\n    for i in 0..(n - m + 1) {\n        if &string[i..(i\
    \ + m)] == substring {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8zulfcvk.rs:6:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let len = substring.len();\n    if len == 0 {\n    \
    \    return 0;\n    }\n    let string = string.into_bytes();\n    let mut count\
    \ = 0;\n    let mut substring_counter = 0;\n    for ch in string {\n        if\
    \ ch == substring.as_bytes()[substring_counter] {\n            substring_counter\
    \ += 1;\n            if substring_counter == len {\n                count += 1;\n\
    \                substring_counter = 0;\n            }\n        } else {\n   \
    \         substring_counter = 0;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplsf6wdud.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let mut occurrences = 0;\n  let mut position = 0;\n  let\
    \ substring_length = substring.len();\n  let mut string_iterator = string.chars();\n\
    \  let mut substring_iterator = substring.chars();\n  loop {\n    let mut substring_found\
    \ = true;\n    for c in substring_iterator.by_ref() {\n      let string_character\
    \ = string_iterator.nth(position);\n      if string_character.is_none() {\n  \
    \      break;\n      }\n      if c != string_character.unwrap() {\n        substring_found\
    \ = false;\n        break;\n      }\n    }\n    if substring_found {\n      occurrences\
    \ += 1;\n      position += substring_length - 1;\n    } else {\n      position\
    \ += 1;\n    }\n    if position > string.len() {\n      break;\n    }\n  }\n \
    \ occurrences\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821625
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_len = string.len();\n\
    \    let mut substring_len = substring.len();\n    let mut start_index = 0;\n\
    \    let mut end_index = substring_len;\n    if string_len == 0 || substring_len\
    \ == 0 {\n        return 0;\n    }\n    if string_len < substring_len {\n    \
    \    let temp = string;\n        string = substring;\n        substring = temp;\n\
    \        string_len = string.len();\n        substring_len = substring.len();\n\
    \    }\n    while end_index <= string_len {\n        if string[start_index..end_index]\
    \ == substring {\n            count += 1;\n            start_index += 1;\n   \
    \         end_index += 1;\n        } else {\n            start_index += 1;\n \
    \           end_index += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n \
    \   let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `substring_len` is never read\n  --> /tmp/tmpozrucdi4.rs:16:9\n\
    \   |\n16 |         substring_len = substring.len();\n   |         ^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nerror[E0384]: cannot assign to immutable\
    \ argument `string`\n  --> /tmp/tmpozrucdi4.rs:13:9\n   |\n2  | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n   |                   ------ help: consider\
    \ making this binding mutable: `mut string`\n...\n13 |         string = substring;\n\
    \   |         ^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot\
    \ assign to immutable argument `substring`\n  --> /tmp/tmpozrucdi4.rs:14:9\n \
    \  |\n2  | fn how_many_times(string: String, substring: String) -> isize {\n \
    \  |                                   --------- help: consider making this binding\
    \ mutable: `mut substring`\n...\n14 |         substring = temp;\n   |        \
    \ ^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut last_pos = 0;\n    loop\
    \ {\n        let next_pos = string.find(&substring, last_pos);\n        if next_pos.is_none()\
    \ {\n            break;\n        } else {\n            count += 1;\n         \
    \   last_pos = next_pos.unwrap() + 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp3zl7l_oh.rs:6:31\n     |\n6    |         let next_pos = string.find(&substring,\
    \ last_pos);\n     |                               ^^^^ ----------  -------- supplied\
    \ 2 arguments\n     |                               |\n     |                \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut i = 0;\n    let mut count = 0;\n    while i\
    \ + substring.len() <= string.len() {\n        if string[i..i + substring.len()]\
    \ == substring {\n            count += 1;\n            i += substring.len();\n\
    \        } else {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvcd8d2mv.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    return count_overlapping_substr(string, substring);\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_overlapping_substr` in this scope\n\
    \ --> /tmp/tmpke4z3v9c.rs:3:12\n  |\n3 |     return count_overlapping_substr(string,\
    \ substring);\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        match string[index..].find(&substring) {\n \
    \           Some(i) => {\n                count += 1;\n                index +=\
    \ i + substring.len();\n            }\n            None => break,\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpuzqoty2b.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let mut offset = 0;\n  let mut counter = 0;\n  while let\
    \ Some(match_location) = string[offset..].find(&substring) {\n    counter += 1;\n\
    \    offset += match_location + substring.len();\n  }\n  counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4b_xx2lc.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut number_of_occurrences = 0;\n    let mut counter\
    \ = 0;\n    let mut substring_len = substring.len();\n    let chars = string.chars();\n\
    \    while counter < chars.len() {\n        let current_char = chars.nth(counter).unwrap();\n\
    \        let current_char_as_str = current_char.to_string();\n        if current_char_as_str\
    \ == substring.chars().nth(0).unwrap().to_string() {\n            if &string[counter..counter\
    \ + substring_len] == substring {\n                number_of_occurrences += 1;\n\
    \                counter += substring_len;\n            } else {\n           \
    \     counter += 1;\n            }\n        } else {\n            counter += 1;\n\
    \        }\n    }\n    number_of_occurrences\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n --> /tmp/tmpwk_ho4m7.rs:7:27\n  |\n7 |     while counter < chars.len()\
    \ {\n  |                           ^^^ method not found in `Chars<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut len = string.len();\n    let mut count = 0;\n\
    \    while let Some(pos) = string.find(&substring) {\n        string = string[pos\
    \ + substring.len()..].to_string();\n        count += 1;\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `len`\n --> /tmp/tmp9ftmszls.rs:3:13\n  |\n3\
    \ |     let mut len = string.len();\n  |             ^^^ help: if this is intentional,\
    \ prefix it with an underscore: `_len`\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n --> /tmp/tmp9ftmszls.rs:3:9\n\
    \  |\n3 |     let mut len = string.len();\n  |         ----^^^\n  |         |\n\
    \  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on\
    \ by default\n\nerror[E0384]: cannot assign to immutable argument `string`\n -->\
    \ /tmp/tmp9ftmszls.rs:6:9\n  |\n2 | fn how_many_times(string: String, substring:\
    \ String) -> isize {\n  |                   ------ help: consider making this\
    \ binding mutable: `mut string`\n...\n6 |         string = string[pos + substring.len()..].to_string();\n\
    \  |         ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let count = string.matches(&substring).count();\n  \
    \  count as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpc8tjhag_.rs:11:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut times = 0;\n    let substring_len = substring.len();\n\
    \    for i in 0..string.len() - substring_len + 1 {\n        if &string[i..i +\
    \ substring_len] == substring {\n            times += 1;\n        }\n    }\n \
    \   times\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpshea__uy.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // Edge cases\n    if string.len() < substring.len()\
    \ {\n        return 0;\n    }\n    if string.len() == substring.len() {\n    \
    \    if string == substring {\n            return 1;\n        } else {\n     \
    \       return 0;\n        }\n    }\n\n    let mut count = 0;\n    let mut index\
    \ = 0;\n    let substring_len = substring.len();\n    let len = string.len();\n\
    \    let string_chars: Vec<char> = string.chars().collect();\n    let substring_chars:\
    \ Vec<char> = substring.chars().collect();\n\n    while index < len {\n      \
    \  if string_chars[index] == substring_chars[0] {\n            let mut should_break\
    \ = false;\n            for i in 1..substring_len {\n                if index\
    \ + i >= len {\n                    should_break = true;\n                   \
    \ break;\n                }\n\n                if string_chars[index + i] != substring_chars[i]\
    \ {\n                    should_break = true;\n                    break;\n  \
    \              }\n            }\n\n            if should_break {\n           \
    \     index += 1;\n                continue;\n            }\n\n            count\
    \ += 1;\n            index += substring_len;\n        } else {\n            index\
    \ += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpdpge2u14.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut number_of_substrings = 0;\n    let substring_length\
    \ = substring.len();\n    let mut search_space = string.clone();\n    while let\
    \ Some(index) = search_space.find(&substring) {\n        let (_, remaining) =\
    \ search_space.split_at(index + substring_length);\n        search_space = remaining.to_string();\n\
    \        number_of_substrings += 1;\n    }\n    number_of_substrings\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1zhaycse.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string_len {\n        let m: usize = i + substring_len;\n        let sliced_str\
    \ = &string[i..m];\n        if sliced_str == substring {\n            count +=\
    \ 1;\n            i += substring_len;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmppeb35d12.rs:9:27

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let index = string.find(&substring);\n    if index.is_none()\
    \ {\n        return 0;\n    }\n    let index = index.unwrap();\n    1 + how_many_times(string[index\
    \ + substring.len()..].to_string(), substring)\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3f83jipl.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut n = 0;\n    for index in 0..(string.len() -\
    \ substring.len() + 1) {\n        if string[index..(index + substring.len())]\
    \ == substring {\n            n += 1;\n        }\n    }\n    n\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvyg9ur4b.rs:4:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // Check the right length\n    if substring.len() >\
    \ string.len() {\n        return 0;\n    }\n\n    // Split the string\n    let\
    \ string_split: Vec<char> = string.chars().collect();\n    let substring_split:\
    \ Vec<char> = substring.chars().collect();\n\n    // Count the amount of times\
    \ the substring appears\n    let mut counter: isize = 0;\n    for i in 0..(string.len()\
    \ - substring.len() + 1) {\n        let slice: Vec<char> = string_split[i..(i\
    \ + substring.len())].to_vec();\n        if slice == substring_split {\n     \
    \       counter += 1;\n        }\n    }\n\n    counter\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut index = 0;\n    let\
    \ (string_len, substring_len) = (string.len(), substring.len());\n    loop {\n\
    \        match string[index..].find(&substring) {\n            Some(pos) => {\n\
    \                counter += 1;\n                index += pos + substring_len;\n\
    \            }\n            None => break,\n        }\n    }\n    counter\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpaiyi_13b.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string = string.as_bytes();\n    let substring =\
    \ substring.as_bytes();\n    let substring_len = substring.len();\n    let mut\
    \ string_index = 0;\n    let mut times = 0;\n    while string_index + substring_len\
    \ <= string.len() {\n        if string[string_index..string_index + substring_len]\
    \ == substring {\n            times += 1;\n            string_index += substring_len;\n\
    \        } else {\n            string_index += 1;\n        }\n    }\n    times\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `[u8]` with `&[u8]`\n --> /tmp/tmp68c2gdh2.rs:9:63\n\
    \  |\n9 |         if string[string_index..string_index + substring_len] == substring\
    \ {\n  |                                                               ^^ no implementation\
    \ for `[u8] == &[u8]`\n  |\n  = help: the trait `PartialEq<&[u8]>` is not implemented\
    \ for `[u8]`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let substring_length = substring.len();\n\
    \    let string_length = string.len();\n    let mut start = 0;\n    while let\
    \ Some(index) = string[start..].find(&substring) {\n        count += 1;\n    \
    \    start = index + substring_length;\n        if start >= string_length {\n\
    \            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821625
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut number_of_times = 0;\n    let mut index = 0;\n\
    \    while index + substring.len() <= string.len() {\n        let start = index;\n\
    \        let end = index + substring.len();\n        if string[start..end] ==\
    \ substring {\n            number_of_times += 1;\n            index += substring.len();\n\
    \        } else {\n            index += 1;\n        }\n    }\n    number_of_times\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpuvk3p0pa.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let slice = &string[..];\n \
    \   let mut total_length = 0;\n    for _ in 0..slice.len() {\n        if let Some(index)\
    \ = slice.find(&substring) {\n            count += 1;\n            total_length\
    \ += index;\n            let new_slice = &slice[index + substring.len()..];\n\
    \            if new_slice.len() > 0 {\n                return count + how_many_times(new_slice.to_string(),\
    \ substring);\n            }\n        } else {\n            break;\n        }\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `4`', /tmp/tmpkrqnf624.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // implemented using regular expressions\n    let mut\
    \ found = 0;\n    let re = Regex::new(&substring).unwrap();\n    for _ in re.find_iter(&string)\
    \ {\n        found += 1;\n    }\n    found\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpja5enhgz.rs:5:14\n\
    \  |\n5 |     let re = Regex::new(&substring).unwrap();\n  |              ^^^^^\
    \ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    let string\
    \ = string.into_bytes();\n    let substring = substring.into_bytes();\n    let\
    \ substring_len = substring.len();\n    let string_len = string.len();\n    loop\
    \ {\n        if pos + substring_len > string_len {\n            break;\n     \
    \   }\n        if string[pos..pos + substring_len] == substring {\n          \
    \  count += 1;\n            pos += substring_len;\n        } else {\n        \
    \    pos += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9wz_uefg.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let input_len = string.len();\n    let sub_len = substring.len();\n\
    \    let mut index = 0;\n    let mut count = 0;\n    let mut prev_index = 0;\n\
    \    while index < input_len {\n        if (index + sub_len) > input_len {\n \
    \           return count;\n        }\n        let sub_string = string.chars().nth(index..(index\
    \ + sub_len)).collect::<String>();\n        if sub_string == substring {\n   \
    \         count += 1;\n            prev_index = index;\n            index = index\
    \ + sub_len;\n        } else {\n            index = prev_index + 1;\n        }\n\
    \    }\n    return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2g3uharb.rs:12:45\n   |\n\
    12 |         let sub_string = string.chars().nth(index..(index + sub_len)).collect::<String>();\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found struct `std::ops::Range`\n   |\n   = note: expected type `usize`\n\
    \            found struct `std::ops::Range<usize>`\n\nerror[E0599]: the method\
    \ `collect` exists for enum `Option<char>`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmp2g3uharb.rs:12:71\n    |\n12  |           let sub_string = string.chars().nth(index..(index\
    \ + sub_len)).collect::<String>();\n    |                                    \
    \                                     ^^^^^^^ method cannot be called on `Option<char>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Option<char>: Iterator`\n            which\
    \ is required by `&mut Option<char>: Iterator`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        match string[index..].find(&substring) {\n \
    \           Some(idx) => {\n                index += idx + substring.len();\n\
    \                count += 1;\n            }\n            None => break,\n    \
    \    }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp08txcrdd.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let n = string.len();\n    let k = substring.len();\n\
    \    if k == 0 {\n        return 0;\n    }\n    let mut result = 0;\n    for i\
    \ in 0..n-k+1 {\n        let substr = string[i..i+k].to_string();\n        if\
    \ substr == substring {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8u4o4n41.rs:9:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let len = substring.len();\n\
    \    for i in 0..=string.len() - len {\n        if &string[i..(i + len)] == substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp7zeb7_vb.rs:5:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut i = 0;\n    let mut count = 0;\n    let mut\
    \ substr_iter = substring.chars();\n    let mut substr_head = substr_iter.next();\n\
    \    for ch in string.chars() {\n        if ch == substr_head.unwrap() {\n   \
    \         i += 1;\n            substr_head = substr_iter.next();\n           \
    \ if substr_head == None {\n                substr_iter = substring.chars();\n\
    \                substr_head = substr_iter.next();\n                count += 1;\n\
    \            }\n        } else {\n            substr_iter = substring.chars();\n\
    \            substr_head = substr_iter.next();\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp948cj0m3.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let mut result = 0;\n  let mut start_from = 0;\n  while\
    \ let Some(position) = string[start_from..].find(&substring) {\n    start_from\
    \ += position + 1;\n    result += 1;\n  }\n  result\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821620
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // Note: we could use 'count' here, but then we need\
    \ to convert `isize` to `usize` so\n    //       we can index. It is easier to\
    \ use 'fold'.\n    string.as_bytes().windows(substring.len()).fold(0, |acc, bytes|\
    \ {\n        if bytes == substring.as_bytes() {\n            acc + 1\n       \
    \ } else {\n            acc\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    let mut occurences: isize = 0;\n    let mut index =\
    \ 0;\n    for _ in 0..(string_len - substring_len + 1) {\n        let sub_string\
    \ = string.get(index..(index + substring_len)).unwrap();\n        if sub_string\
    \ == substring {\n            occurences += 1;\n        }\n        index += 1;\n\
    \    }\n    occurences\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmprtd6nqqk.rs:7:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_length = string.len();\n    let substring_length\
    \ = substring.len();\n    let mut times = 0;\n    let mut pos = 0;\n    let mut\
    \ from = 0;\n    while pos < string_length {\n        let new_pos = match string[from..].find(&substring)\
    \ {\n            Some(p) => p,\n            None => break,\n        };\n     \
    \   pos += new_pos;\n        if pos >= string_length {\n            break;\n \
    \       }\n        pos += substring_length;\n        from = pos;\n        times\
    \ += 1;\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpeamas921.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ let Some(i) = string[index..].find(&substring) {\n        count += 1;\n    \
    \    index = index + i + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string = string.as_bytes();\n    let substring =\
    \ substring.as_bytes();\n    let slen = string.len();\n    let mut count = 0;\n\
    \    let mut found = false;\n    let mut i = 0;\n    while i < slen {\n      \
    \  let mut j = 0;\n        while j < substring.len() && string[i + j] == substring[j]\
    \ {\n            j += 1;\n        }\n        if j == substring.len() {\n     \
    \       count += 1;\n            i += j;\n            found = true;\n        }\
    \ else {\n            if found {\n                found = false;\n           \
    \     i -= 1;\n            }\n            i += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmp1bbil7c7.rs:11:38

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let string_chars: Vec<char>\
    \ = string.chars().collect();\n    let substring_chars: Vec<char> = substring.chars().collect();\n\
    \    for i in 0..string_chars.len() {\n        if string_chars[i] == substring_chars[0]\
    \ {\n            let string_substring = string_chars[i..substring_chars.len()+i].iter().collect::<String>();\n\
    \            if string_substring == substring {\n                count += 1;\n\
    \            }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''range end index 11 out of range for slice
    of length 9'', /tmp/tmpjwxf7m5p.rs:8:36

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if string.len() < substring.len() {\n        return\
    \ 0;\n    }\n\n    let mut count = 0;\n    let mut offset = 0;\n    while offset\
    \ <= string.len() - substring.len() {\n        let found = &string[offset..(offset\
    \ + substring.len())];\n        if found == substring {\n            count +=\
    \ 1;\n            offset += substring.len();\n        } else {\n            offset\
    \ += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpckbxxyoh.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut string_length = string.len();\n    let substring_length\
    \ = substring.len();\n    let mut count = 0;\n    let mut last_end_index = 0;\n\
    \    loop {\n        if let Some(index) = string.find(&substring) {\n        \
    \    if index == last_end_index {\n                count += 1;\n            }\n\
    \            last_end_index = index + substring_length;\n            string =\
    \ string[index + substring_length..].to_string();\n        } else {\n        \
    \    break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `string_length`\n --> /tmp/tmpyy1p9qkg.rs:3:13\n\
    \  |\n3 |     let mut string_length = string.len();\n  |             ^^^^^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_string_length`\n\
    \  |\n  = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable\
    \ does not need to be mutable\n --> /tmp/tmpyy1p9qkg.rs:3:9\n  |\n3 |     let\
    \ mut string_length = string.len();\n  |         ----^^^^^^^^^^^^^\n  |      \
    \   |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0384]: cannot assign to immutable argument `string`\n\
    \  --> /tmp/tmpyy1p9qkg.rs:13:13\n   |\n2  | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n   |                   ------ help: consider\
    \ making this binding mutable: `mut string`\n...\n13 |             string = string[index\
    \ + substring_length..].to_string();\n   |             ^^^^^^ cannot assign to\
    \ immutable argument\n\nerror: aborting due to previous error; 2 warnings emitted\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() > string.len() {\n        return\
    \ 0;\n    }\n\n    let mut has_found = false;\n    let mut found_times = 0;\n\
    \    let mut count = 0;\n    let mut str_iter = string.chars();\n    let mut sub_iter\
    \ = substring.chars();\n\n    loop {\n        if let Some(c) = str_iter.next()\
    \ {\n            if c == sub_iter.next().unwrap() {\n                if !has_found\
    \ {\n                    has_found = true;\n                    count = 0;\n \
    \               }\n\n                count += 1;\n\n                if count ==\
    \ substring.len() {\n                    found_times += 1;\n                 \
    \   has_found = false;\n                }\n            } else {\n            \
    \    if has_found {\n                    str_iter = string.chars();\n        \
    \            sub_iter = substring.chars();\n                    has_found = false;\n\
    \                }\n            }\n        } else {\n            break;\n    \
    \    }\n    }\n\n    found_times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpzpb7e2td.rs:15:37

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut pos = 0;\n    let\
    \ string_length = string.len();\n    let substring_length = substring.len();\n\
    \    if substring_length <= string_length {\n        while pos <= string_length\
    \ - substring_length {\n            if string[pos..pos + substring_length] ==\
    \ substring {\n                counter += 1;\n                pos += substring_length;\n\
    \            } else {\n                pos += 1;\n            }\n        }\n \
    \   }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp2wa86ec2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if string.len() < substring.len() {\n        return\
    \ 0;\n    }\n\n    let char_vec: Vec<char> = string.chars().collect();\n    let\
    \ substring_vec: Vec<char> = substring.chars().collect();\n\n    let mut count\
    \ = 0;\n    let mut idx = 0;\n    while idx < char_vec.len() {\n        // find\
    \ the index of the first character of substring\n        if char_vec[idx] == substring_vec[0]\
    \ {\n            // compare each character of string and substring\n         \
    \   let mut match_flag = true;\n            for i in 0..substring_vec.len() {\n\
    \                if char_vec[idx + i] != substring_vec[i] {\n                \
    \    match_flag = false;\n                    break;\n                }\n    \
    \        }\n            if match_flag {\n                // if match then increase\
    \ count\n                count += 1;\n                // and jump to the next\
    \ position of the last character of substring\n                idx += substring_vec.len()\
    \ - 1;\n            }\n        }\n        idx += 1;\n    }\n\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmpne_9z77s.rs:18:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut string = string;\n    let mut count = 0;\n \
    \   while let Some(pos) = string.find(&substring) {\n        count += 1;\n   \
    \     string = string[pos + substring.len()..].to_string();\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpwjq_k6s6.rs:16:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_bytes = string.into_bytes();\n    let substring_bytes\
    \ = substring.into_bytes();\n    let mut count = 0;\n    let mut i = 0;\n    while\
    \ i < string_bytes.len() {\n        let mut found = false;\n        let mut j\
    \ = 0;\n        while j < substring_bytes.len() {\n            if string_bytes[i\
    \ + j] == substring_bytes[j] {\n                found = true;\n            } else\
    \ {\n                found = false;\n                break;\n            }\n \
    \           j += 1;\n        }\n        if found {\n            count += 1;\n\
    \            i += j;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmpjefovv_x.rs:11:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for i in 0..(string.len() -\
    \ substring.len() + 1) {\n        let slice = &string[i..(i + substring.len())];\n\
    \        if substring == slice {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp59gmfe8c.rs:4:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut times = 0;\n    let mut string_index = 0;\n\
    \    let mut substring_index = 0;\n    let mut string_chars = string.chars();\n\
    \    let mut substring_chars = substring.chars();\n    let mut curr_char = string_chars.next();\n\
    \    let mut curr_substring_char = substring_chars.next();\n    loop {\n     \
    \   if substring_index == substring.len() {\n            times += 1;\n       \
    \     substring_index = 0;\n            curr_substring_char = substring_chars.next();\n\
    \        }\n        if string_index == string.len() {\n            break;\n  \
    \      }\n        if curr_char == curr_substring_char {\n            substring_index\
    \ += 1;\n            curr_substring_char = substring_chars.next();\n        }\
    \ else {\n            substring_index = 0;\n            curr_substring_char =\
    \ substring_chars.next();\n        }\n        string_index += 1;\n        curr_char\
    \ = string_chars.next();\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp6ugucjyu.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    while i\
    \ < string.len() {\n        if let Some(j) = string[i..].find(&substring) {\n\
    \            count += 1;\n            i += j + substring.len();\n        } else\
    \ {\n            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz8kr733f.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    while\
    \ pos + substring.len() <= string.len() {\n        if &string[pos..pos + substring.len()]\
    \ == substring {\n            count += 1;\n            pos += substring.len();\n\
    \        } else {\n            pos += 1;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmprx8m05eb.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let len_substring = substring.len();\n\
    \    let mut index = 0;\n    while let Some(pos) = string[index..].find(&substring)\
    \ {\n        count += 1;\n        index += pos + len_substring;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpfjp7sx2z.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if string.len() < substring.len() {\n        return\
    \ 0;\n    }\n\n    let mut prev = 0;\n    let mut index = string.find(&substring);\n\
    \    let mut count = 0;\n\n    while index.is_some() {\n        prev = index.unwrap()\
    \ + substring.len();\n        index = string.find(&substring);\n        count\
    \ += 1;\n    }\n\n    return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821626
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut number_of_times = 0;\n    for i in 0..(string.len()\
    \ - substring.len() + 1) {\n        if string[i..i + substring.len()] == substring\
    \ {\n            number_of_times += 1;\n        }\n    }\n    number_of_times\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpuh4izmm2.rs:4:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let len_string = string.len();\n    let len_substring\
    \ = substring.len();\n    let mut counter = 0;\n    let mut start = 0;\n    while\
    \ start + len_substring < len_string {\n        let slice = &string[start..(start\
    \ + len_substring)];\n        if slice == substring {\n            counter +=\
    \ 1;\n            start += len_substring;\n        } else {\n            start\
    \ += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmp0tictmwm.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    if string_len == 0 || substring_len == 0 || string_len\
    \ < substring_len {\n        return 0;\n    }\n    let mut counter = 0;\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    loop {\n        if i == string_len {\n \
    \           break;\n        }\n        let char = string.chars().nth(i).unwrap();\n\
    \        if char == substring.chars().nth(j).unwrap() {\n            j += 1;\n\
    \            if j == substring_len {\n                counter += 1;\n        \
    \        j = 0;\n            }\n        } else {\n            j = 0;\n       \
    \ }\n        i += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgczsf4o3.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let needle_length = substring.len();\n    let haystack_length\
    \ = string.len();\n    let needle = &substring[..];\n    let haystack = &string[..];\n\
    \    let mut times = 0;\n    for start in 0..(haystack_length - needle_length\
    \ + 1) {\n        if &haystack[start..(start + needle_length)] == needle {\n \
    \           times += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8xcdo2gc.rs:8:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut occurences = 0;\n    let mut current_index =\
    \ 0;\n    let mut rest = string;\n    let len = substring.len();\n    while current_index\
    \ != -1 {\n        current_index = rest.find(&substring).unwrap_or(-1);\n    \
    \    if current_index == -1 {\n            break;\n        }\n        occurences\
    \ += 1;\n        rest = rest[current_index + len..].to_string();\n    }\n    occurences\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n --> /tmp/tmp9so2jrvk.rs:8:57\n\
    \  |\n8 |         current_index = rest.find(&substring).unwrap_or(-1);\n  |  \
    \                                                       ^^\n  |              \
    \                                           |\n  |                           \
    \                              cannot apply unary operator `-`\n  |          \
    \                                               help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp9so2jrvk.rs:7:28\n\
    \  |\n7 |     while current_index != -1 {\n  |                            ^^ the\
    \ trait `Neg` is not implemented for `usize`\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n --> /tmp/tmp9so2jrvk.rs:9:29\n  |\n9 |      \
    \   if current_index == -1 {\n  |                             ^^\n  |        \
    \                     |\n  |                             cannot apply unary operator\
    \ `-`\n  |                             help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821620
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut total = 0;\n    let mut index = 0;\n    let\
    \ mut string = string;\n    for _ in 0..string.len() {\n        index = string.find(&substring).unwrap_or(string.len());\n\
    \        total += 1;\n        if index + substring.len() < string.len() {\n  \
    \          string = string[index + substring.len()..].to_string();\n        }\
    \ else {\n            break;\n        }\n    }\n    total\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3`,\n right: `4`', /tmp/tmpnigr4by0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut res = 0;\n    let mut index = 0;\n    let mut\
    \ cursor = 0;\n    let str_len = string.len();\n    let sub_len = substring.len();\n\
    \    let string = string.as_bytes();\n    let substring = substring.as_bytes();\n\
    \    while index < str_len {\n        if string[index] == substring[cursor] {\n\
    \            if cursor == sub_len - 1 {\n                res += 1;\n         \
    \       cursor = 0;\n            } else {\n                cursor += 1;\n    \
    \        }\n        } else {\n            cursor = 0;\n        }\n        index\
    \ += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp9c51opeq.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if string.len() < substring.len() {\n        return\
    \ 0;\n    }\n\n    let mut count = 0;\n    let mut i = 0;\n    while i <= string.len()\
    \ - substring.len() {\n        if &string[i..i + substring.len()] == substring\
    \ {\n            count += 1;\n            i += substring.len();\n        } else\
    \ {\n            i += 1;\n        }\n    }\n\n    count\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp_0w8e8wi.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() == 0 {\n        return string.len()\
    \ as isize;\n    }\n    let mut result = 0;\n    let mut previous_occurrences\
    \ = Vec::new();\n    let mut next_occurrences = Vec::new();\n    let mut current_string\
    \ = string.clone();\n    while current_string.len() >= substring.len() {\n   \
    \     let next_index = current_string.find(&substring);\n        if next_index.is_none()\
    \ {\n            break;\n        }\n        result += 1;\n        previous_occurrences.push(next_index.unwrap()\
    \ as isize);\n        let next_index = next_index.unwrap() + substring.len();\n\
    \        next_occurrences.push(next_index as isize);\n        current_string =\
    \ current_string[next_index..].to_string();\n    }\n    let mut current_index\
    \ = 0;\n    while current_index < previous_occurrences.len() {\n        let current_previous_occurrence\
    \ = previous_occurrences[current_index];\n        let current_next_occurrence\
    \ = next_occurrences[current_index];\n        let mut current_previous_occurrence_index\
    \ = current_index + 1;\n        while current_previous_occurrence_index < previous_occurrences.len()\
    \ {\n            let next_previous_occurrence = previous_occurrences[current_previous_occurrence_index];\n\
    \            if next_previous_occurrence < current_next_occurrence {\n       \
    \         result -= 1;\n                break;\n            }\n            current_previous_occurrence_index\
    \ += 1;\n        }\n        current_index += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpk2ahsrnj.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let (m, n) = (string.len(), substring.len());\n    let\
    \ mut string_char_vec: Vec<char> = string.chars().collect();\n    let mut substring_char_vec:\
    \ Vec<char> = substring.chars().collect();\n    let mut count = 0;\n    if m >=\
    \ n {\n        for i in 0..m - n + 1 {\n            let mut k = 0;\n         \
    \   while k < n {\n                if string_char_vec[i + k] != substring_char_vec[k]\
    \ {\n                    break;\n                }\n                k += 1;\n\
    \            }\n            if k == n {\n                count += 1;\n       \
    \     }\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut occurrences = 0;\n    let n = string.len();\n\
    \    let m = substring.len();\n    for i in 0..(n - m + 1) {\n        let mut\
    \ j = 0;\n        while j < m && string.chars().nth(i + j).unwrap() == substring.chars().nth(j).unwrap()\
    \ {\n            j += 1;\n        }\n        if j == m {\n            occurrences\
    \ += 1;\n        }\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp7fpgin32.rs:6:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut prev_i = 0;\n    let\
    \ mut i = string.find(&substring);\n    while i.is_some() {\n        count +=\
    \ 1;\n        prev_i = i.unwrap() + 1;\n        i = string[prev_i..].find(&substring);\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821626
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let string_len = string.len();\n  let substring_len =\
    \ substring.len();\n  let mut cnt = 0;\n  for index in 0..string_len {\n    let\
    \ mut str_index = index;\n    let mut sub_index = 0;\n    while string.chars().nth(str_index)\
    \ == substring.chars().nth(sub_index) {\n      str_index += 1;\n      sub_index\
    \ += 1;\n      if sub_index == substring_len {\n        cnt += 1;\n        break;\n\
    \      }\n    }\n  }\n  cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    loop {\n\
    \        let index = match string[pos..].find(&substring) {\n            Some(x)\
    \ => x,\n            None => break,\n        };\n        pos += index + substring.len();\n\
    \        count += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpd78t_ea6.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let length = substring.len();\n    let mut count = 0;\n\
    \    for i in 0..string.len() - length + 1 {\n        let s = &string[i..i + length];\n\
    \        if s == substring {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpmp3il0z8.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut remaining = &string[..];\n\
    \    let mut i = remaining.find(&substring);\n    while i.is_some() {\n      \
    \  count += 1;\n        let (first, rest) = remaining.split_at(i.unwrap());\n\
    \        remaining = &rest[substring.len()..];\n        i = remaining.find(&substring);\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpopuy1y7k.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    loop\
    \ {\n        match string[index..].find(&substring) {\n            Some(index_found)\
    \ => {\n                count += 1;\n                index += index_found + 1;\n\
    \            }\n            None => break,\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821621
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut index = 0;\n    while\
    \ index != -1 {\n        index = string[index..].find(&substring).unwrap_or(-1);\n\
    \        if index == -1 {\n            break;\n        }\n        counter += 1;\n\
    \        index += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp8wun8hf1.rs:5:20\n\
    \  |\n5 |     while index != -1 {\n  |                    ^^ the trait `Neg` is\
    \ not implemented for `usize`\n\nerror[E0600]: cannot apply unary operator `-`\
    \ to type `usize`\n --> /tmp/tmp8wun8hf1.rs:6:60\n  |\n6 |         index = string[index..].find(&substring).unwrap_or(-1);\n\
    \  |                                                            ^^\n  |      \
    \                                                      |\n  |                \
    \                                            cannot apply unary operator `-`\n\
    \  |                                                            help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n  |\n  = note: unsigned\
    \ values cannot be negated\n\nerror[E0600]: cannot apply unary operator `-` to\
    \ type `usize`\n --> /tmp/tmp8wun8hf1.rs:7:21\n  |\n7 |         if index == -1\
    \ {\n  |                     ^^\n  |                     |\n  |              \
    \       cannot apply unary operator `-`\n  |                     help: you may\
    \ have meant the maximum value of `usize`: `usize::MAX`\n  |\n  = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0600.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() > string.len() {\n        return\
    \ 0;\n    }\n\n    let mut chars: Vec<_> = string.chars().collect();\n    let\
    \ substring_chars: Vec<_> = substring.chars().collect();\n    let mut occurrences\
    \ = 0;\n\n    let mut i = 0;\n    while i < chars.len() {\n        if chars[i]\
    \ == substring_chars[0] {\n            let mut ok = true;\n            for j in\
    \ 0..substring_chars.len() {\n                if chars[i + j] != substring_chars[j]\
    \ {\n                    ok = false;\n                    break;\n           \
    \     }\n            }\n            if ok {\n                occurrences += 1;\n\
    \                i += substring_chars.len();\n            } else {\n         \
    \       i += 1;\n            }\n        } else {\n            i += 1;\n      \
    \  }\n    }\n\n    occurrences\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmpmute9mby.rs:16:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start = 0;\n    let\
    \ mut window = string.clone();\n    let string_bytes = string.as_bytes();\n  \
    \  let substring_bytes = substring.as_bytes();\n    let mut start_found = false;\n\
    \    while !start_found {\n        if let Some(pos) = window.find(substring.as_str())\
    \ {\n            count += 1;\n            start += pos + substring.len();\n  \
    \          window = String::from_utf8(string_bytes[start..].to_vec()).unwrap();\n\
    \        } else {\n            start_found = true;\n        }\n    }\n    return\
    \ count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz812225c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut total_matches = 0;\n    let mut i = 0;\n   \
    \ while i + substring.len() <= string.len() {\n        let haystack = &string[i..];\n\
    \        if let Some(start) = haystack.find(&substring) {\n            total_matches\
    \ += 1;\n            i += start + substring.len();\n        } else {\n       \
    \     break;\n        }\n    }\n    total_matches\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpw1avmh6r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut i = 0;\n    let (string, substring) = (string.as_bytes(),\
    \ substring.as_bytes());\n    while i + substring.len() <= string.len() {\n  \
    \      if &string[i..i + substring.len()] == substring {\n            count +=\
    \ 1;\n            i += substring.len();\n        } else {\n            i += 1;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1gj4jziq.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut times = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    for i in 0..(string_len - substring_len\
    \ + 1) {\n        if string[i..(i + substring_len)] == substring {\n         \
    \   times += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpxc9omj8g.rs:6:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string = string.into_bytes();\n    let substring\
    \ = substring.into_bytes();\n    let mut max_index = string.len() - substring.len();\n\
    \    let mut times = 0;\n    for i in 0..max_index {\n        if string[i] ==\
    \ substring[0] {\n            let mut match_found = true;\n            for j in\
    \ 0..substring.len() {\n                if string[i + j] != substring[j] {\n \
    \                   match_found = false;\n                    break;\n       \
    \         }\n            }\n            if match_found {\n                times\
    \ += 1;\n            }\n        }\n    }\n    times\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp8ti9j3mw.rs:5:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let length = substring.len();\n    let count = string.match_indices(&substring).count();\n\
    \    count as isize - 1 + string.len() as isize - count as isize * length as isize\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-1`,\n right: `0`', /tmp/tmplxxhw_q6.rs:10:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let len = substring.len();\n    let slen = string.len();\n\
    \    if len > slen {\n        return 0;\n    }\n    let mut result = 0;\n    let\
    \ mut i = 0;\n    loop {\n        let start = i;\n        let end = start + len;\n\
    \        if end > slen {\n            break;\n        }\n        let sub = &string[start..end];\n\
    \        if sub == substring {\n            result += 1;\n        }\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let str_len = string.len();\n    let sub_len = substring.len();\n\
    \    let mut result = 0;\n    for i in 0..str_len {\n        if &string[i..(i\
    \ + sub_len)] == substring {\n            result += 1;\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmp58poy8k7.rs:7:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_vec: Vec<char> = string.chars().collect();\n\
    \    let substring_vec: Vec<char> = substring.chars().collect();\n    let mut\
    \ times = 0;\n    let mut index = 0;\n    while index < string_vec.len() - substring_vec.len()\
    \ + 1 {\n        if &string_vec[index..index + substring_vec.len()] == &substring_vec[..]\
    \ {\n            times += 1;\n            index += substring_vec.len();\n    \
    \    } else {\n            index += 1;\n        }\n    }\n    times\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpvv68n_q2.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut search_start = 0;\n\
    \    while search_start < string.len() {\n        let target = &string[search_start..];\n\
    \        if let Some(index) = target.find(&substring) {\n            search_start\
    \ += index + substring.len();\n            count += 1;\n        } else {\n   \
    \         break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpqd6svj7i.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let sub_len = substring.len();\n\
    \    for i in 0..(string.len() - sub_len + 1) {\n        if string[i..i + sub_len]\
    \ == substring {\n            count += 1;\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp54nkhrpc.rs:5:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let s: Vec<char> = string.chars().collect();\n    let t: Vec<char>\
    \ = substring.chars().collect();\n    let n = s.len();\n    let m = t.len();\n\
    \    while i < n {\n        if s[i] == t[j] {\n            i += 1;\n         \
    \   j += 1;\n            if j == m {\n                count += 1;\n          \
    \      j = 0;\n            }\n        } else {\n            i = i - j + 1;\n \
    \           j = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpnsk8_f4g.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut from = 0;\n    let length\
    \ = substring.len();\n    while let Some(pos) = string[from..].find(&substring)\
    \ {\n        count += 1;\n        from += pos + length;\n    }\n    count\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3is37gqt.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut result = 0;\n    let strlen = string.len();\n\
    \    let substrlen = substring.len();\n    let mut j: usize = 0;\n    while j\
    \ < strlen - substrlen + 1 {\n        if string[j..j + substrlen] == substring\
    \ {\n            result += 1;\n            j += substrlen;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpwrcvd46l.rs:7:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut amount = 0;\n    let mut index = 0;\n    while\
    \ let Some(found_index) = string[index..].find(&substring) {\n        index +=\
    \ found_index + 1;\n        amount += 1;\n    }\n    amount\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821621
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let haystack = string.as_bytes();\n    let needle =\
    \ substring.as_bytes();\n    let size = needle.len();\n    let mut result = 0;\n\
    \    for pos in 0..(haystack.len() - size + 1) {\n        if haystack[pos..(pos\
    \ + size)] == needle {\n            result += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `[u8]` with `&[u8]`\n --> /tmp/tmp07bg57rv.rs:8:40\n\
    \  |\n8 |         if haystack[pos..(pos + size)] == needle {\n  |            \
    \                            ^^ no implementation for `[u8] == &[u8]`\n  |\n \
    \ = help: the trait `PartialEq<&[u8]>` is not implemented for `[u8]`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut current_shift = 0;\n    let mut count = 0;\n\
    \    while &string[current_shift..] != \"\" {\n        if &string[current_shift..].starts_with(&substring)\
    \ {\n            count += 1;\n            current_shift += substring.len();\n\
    \        } else {\n            current_shift += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9pcph4_x.rs:6:12\n  |\n6 |\
    \         if &string[current_shift..].starts_with(&substring) {\n  |         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `&bool`\n\
    \  |\nhelp: consider removing the borrow\n  |\n6 -         if &string[current_shift..].starts_with(&substring)\
    \ {\n6 +         if string[current_shift..].starts_with(&substring) {\n  | \n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut times = 0;\n    let mut cnt = 0;\n    for c\
    \ in string.chars() {\n        if c == substring.chars().nth(cnt).unwrap() {\n\
    \            cnt += 1;\n            if cnt == substring.len() {\n            \
    \    times += 1;\n                cnt = 0;\n            }\n        } else {\n\
    \            cnt = 0;\n        }\n    }\n    times\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpf7a1vfo2.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut number_found = 0;\n    let mut mutable_string\
    \ = string.clone();\n    while mutable_string.contains(&substring) {\n       \
    \ number_found += 1;\n        mutable_string = mutable_string[substring.len()..mutable_string.len()].to_string();\n\
    \    }\n    number_found\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmpfb16unpr.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if string.len() < substring.len() {\n        return\
    \ 0;\n    }\n\n    let mut counter = 0;\n    let mut current_index = 0;\n    let\
    \ mut previous_index = 0;\n\n    let string_copy = string.clone();\n    let substr_copy\
    \ = substring.clone();\n\n    while current_index < string.len() {\n        current_index\
    \ = string_copy[previous_index..].find(&substr_copy).unwrap_or_else(|| string.len());\n\
    \        if current_index != string.len() {\n            previous_index = current_index\
    \ + 1;\n            counter += 1;\n        }\n    }\n\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821626
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ string_vec: Vec<&str> = string.split(&substring).collect();\n    while index\
    \ < string_vec.len() {\n        count += 1;\n        index += 1;\n    }\n    count\
    \ - 1\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpn67hrh0l.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let (substring_len, string_len) = (substring.len(),\
    \ string.len());\n    let mut count = 0;\n    let mut i = 0;\n    while i + substring_len\
    \ <= string_len {\n        let mut found = true;\n        for j in 0..substring_len\
    \ {\n            if string.as_bytes()[i + j] != substring.as_bytes()[j] {\n  \
    \              found = false;\n                break;\n            }\n       \
    \ }\n        if found {\n            count += 1;\n            i += substring_len;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbnwb96mz.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  return (string.len() - substring.len() + 1) as isize;\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpco25twmo.rs:3:11

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let len = substring.len();\n    let mut cnt = 0;\n \
    \   for window in string.as_str().chars().collect::<Vec<char>>().windows(len)\
    \ {\n        if substring == window.iter().collect::<String>() {\n           \
    \ cnt += 1;\n        }\n    }\n    cnt\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pos = 0;\n    let substring_length\
    \ = substring.len();\n    let string_length = string.len();\n    let mut string_part\
    \ = string.clone();\n    let mut string_part_length = string_part.len();\n   \
    \ loop {\n        if string_part_length < substring_length {\n            break;\n\
    \        }\n        let pos = string_part.find(&substring);\n        if pos.is_none()\
    \ {\n            break;\n        }\n        let pos = pos.unwrap();\n        count\
    \ += 1;\n        string_part = string_part[pos + substring_length..].to_string();\n\
    \        string_part_length = string_part.len();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsvdq2ayq.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let mut count = 0;\n  let mut i = 0;\n  while i < string.len()\
    \ {\n    if i + substring.len() > string.len() {\n      break;\n    }\n    if\
    \ string[i..(i + substring.len())] == substring {\n      count += 1;\n      i\
    \ += substring.len();\n    } else {\n      i += 1;\n    }\n  }\n  count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp7d62byd8.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut occurrences = 0;\n    let string_size = string.len();\n\
    \    let substring_size = substring.len();\n    let mut offset = 0;\n    while\
    \ offset < string_size {\n        let end = offset + substring_size;\n       \
    \ let string_slice = &string[offset..end];\n        if string_slice == substring\
    \ {\n            occurrences += 1;\n            offset += substring_size;\n  \
    \      } else {\n            offset += 1;\n        }\n    }\n    occurrences\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmpl9iycpaj.rs:9:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start_search_pos = 0;\n\
    \    while start_search_pos < string.len() {\n        if let Some(found_pos) =\
    \ string[start_search_pos..].find(&substring) {\n            count += 1;\n   \
    \         start_search_pos += found_pos + substring.len();\n        } else {\n\
    \            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmps5uo8b8k.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let string_chars: Vec<char>\
    \ = string.chars().collect();\n    let substring_chars: Vec<char> = substring.chars().collect();\n\
    \    let mut i = 0;\n    while i < string_chars.len() - substring_chars.len()\
    \ + 1 {\n        if string_chars[i] == substring_chars[0] {\n            if string_chars[i..i\
    \ + substring_chars.len()] == substring_chars {\n                count += 1;\n\
    \                i += substring_chars.len();\n            } else {\n         \
    \       i += 1;\n            }\n        } else {\n            i += 1;\n      \
    \  }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp428__j_5.rs:7:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_length = string.len();\n    let substring_length\
    \ = substring.len();\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string_length {\n        if let Some(i) = string[index..].find(&substring)\
    \ {\n            count += 1;\n            index += i + substring_length;\n   \
    \     } else {\n            break;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4u6mtnpp.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821621
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut current_idx = 0;\n \
    \   let string_len = string.len();\n    let substring_len = substring.len();\n\
    \    let substring_vector: Vec<char> = substring.chars().collect();\n    let mut\
    \ string_vector: Vec<char> = string.chars().collect();\n    for i in 0..substring_len\
    \ {\n        let current_substring_char = substring_vector[i];\n        for j\
    \ in current_idx..string_len {\n            let current_string_char = string_vector[j];\n\
    \            if current_substring_char == current_string_char {\n            \
    \    string_vector[j] = '0';\n                count += 1;\n                current_idx\
    \ = j + 1;\n                break;\n            }\n        }\n    }\n    count\
    \ as isize\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmpngq7c42t.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let string_chars: Vec<char> = string.chars().collect();\n    let\
    \ substring_chars: Vec<char> = substring.chars().collect();\n    while i < string.len()\
    \ && j < substring.len() {\n        if string_chars[i] == substring_chars[j] {\n\
    \            j += 1;\n        } else {\n            j = 0;\n        }\n      \
    \  i += 1;\n        if j == substring.len() {\n            count += 1;\n     \
    \       j = 0;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpbn7pkpfs.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut times = 0;\n    let mut position = 0;\n    while\
    \ position < string.len() {\n        let start = string.get(position..).unwrap();\n\
    \        if start.contains(&substring) {\n            position += start.find(&substring).unwrap()\
    \ + substring.len();\n            times += 1;\n        } else {\n            position\
    \ += 1;\n        }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmplytnrivm.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut occurance_count = 0;\n    let mut last_char_found_at\
    \ = 0;\n    for (i, current_char) in string.chars().enumerate() {\n        if\
    \ current_char == substring.chars().nth(0).unwrap() {\n            if &string[i..i\
    \ + substring.len()] == substring {\n                occurance_count += 1;\n \
    \               last_char_found_at = i + substring.len();\n            }\n   \
    \     }\n    }\n    occurance_count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 11 is out of bounds of `cacacacac`'',
    /tmp/tmppi547chp.rs:7:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut start_index = 0;\n \
    \   let len = substring.len();\n    let string = string.as_str();\n    let substring\
    \ = substring.as_str();\n    while start_index < string.len() {\n        let index\
    \ = match string[start_index..].find(substring) {\n            Some(index) =>\
    \ index,\n            None => break,\n        };\n        count += 1;\n      \
    \  start_index += index + len;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5oqzhbau.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut times = 0;\n    for start in 0..string.len()\
    \ {\n        if &string[start..] == substring {\n            times += 1;\n   \
    \     }\n    }\n    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `4`', /tmp/tmp9mcspm7g.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut number_of_occurrences = 0;\n    let mut string_it\
    \ = string.chars();\n    let mut first_char = string_it.next();\n    let mut last_char\
    \ = string_it.next_back();\n    let mut length = 1;\n    let mut array = substring.chars().collect::<Vec<char>>();\n\
    \    while first_char != last_char {\n        if first_char.unwrap() == array[0]\
    \ {\n            number_of_occurrences += 1;\n        }\n        first_char =\
    \ string_it.next();\n        length += 1;\n    }\n    if first_char.unwrap() ==\
    \ array[0] {\n        number_of_occurrences += 1;\n    }\n    number_of_occurrences\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpditc9gks.rs:16:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    for (index, _) in string.match_indices(&substring)\
    \ {\n        counter += 1;\n        let suffix = &string[index + substring.len()..];\n\
    \        if let Some(_) = suffix.find(&substring) {\n            counter += how_many_times(suffix.to_string(),\
    \ substring);\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `substring`\n --> /tmp/tmp2d2lss2c.rs:6:38\n\
    \  |\n2 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                   --------- move occurs because `substring`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n6 |     \
    \    let suffix = &string[index + substring.len()..];\n  |                   \
    \                   ^^^^^^^^^ value borrowed here after move\n7 |         if let\
    \ Some(_) = suffix.find(&substring) {\n8 |             counter += how_many_times(suffix.to_string(),\
    \ substring);\n  |                                                           ---------\
    \ value moved here, in previous iteration of loop\n\nerror[E0505]: cannot move\
    \ out of `substring` because it is borrowed\n --> /tmp/tmp2d2lss2c.rs:8:59\n \
    \ |\n4 |     for (index, _) in string.match_indices(&substring) {\n  |       \
    \                                     ---------- borrow of `substring` occurs\
    \ here\n...\n8 |             counter += how_many_times(suffix.to_string(), substring);\n\
    \  |                                                           ^^^^^^^^^ move\
    \ out of `substring` occurs here\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0382, E0505.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut pos = 0;\n    let mut count = 0;\n    let mut\
    \ string = string;\n    let substring_len = substring.len();\n    let mut end_pos\
    \ = string.len() - substring_len;\n    let substring = substring.into_bytes();\n\
    \    while pos <= end_pos {\n        let sub_bytes = &string.as_bytes()[pos..(pos\
    \ + substring_len)];\n        if sub_bytes == &substring[..] {\n            count\
    \ += 1;\n            pos += substring_len;\n        } else {\n            pos\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpuxvoka_o.rs:7:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // Check if the string and substring are the same\n\
    \    if string == substring {\n        return 1;\n    }\n\n    // Check if the\
    \ substring is smaller than the string\n    if string.len() < substring.len()\
    \ {\n        return 0;\n    }\n\n    // Rust strings are basically vectors with\
    \ each item being a UTF-8 code point\n    // So iterating through the string is\
    \ actually iterating through each code point\n\n    // Create a vector with the\
    \ bytes of the substring\n    let sub_vec: Vec<u8> = substring.into_bytes();\n\
    \n    // Create an iterator that will go through the original string\n    let\
    \ mut iterator = string.into_bytes().windows(sub_vec.len());\n\n    // Now iterate\
    \ through the iterator\n    let mut count = 0;\n    for item in iterator {\n \
    \       // Check if the substring and the current position in the string are the\
    \ same\n        if item == sub_vec {\n            count += 1;\n        }\n   \
    \ }\n\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp1vs9codq.rs:20:9\n\
    \   |\n20 |     let mut iterator = string.into_bytes().windows(sub_vec.len());\n\
    \   |         ----^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0716]: temporary\
    \ value dropped while borrowed\n  --> /tmp/tmp1vs9codq.rs:20:24\n   |\n20 |  \
    \   let mut iterator = string.into_bytes().windows(sub_vec.len());\n   |     \
    \                   ^^^^^^^^^^^^^^^^^^^                       - temporary value\
    \ is freed at the end of this statement\n   |                        |\n   | \
    \                       creates a temporary which is freed while still in use\n\
    ...\n24 |     for item in iterator {\n   |                 -------- borrow later\
    \ used here\n   |\n   = note: consider using a `let` binding to create a longer\
    \ lived value\n\nerror: aborting due to previous error; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0716`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_length = string.len();\n    let substring_length\
    \ = substring.len();\n    let mut idx = 0;\n    let mut occurrences = 0;\n   \
    \ while idx + substring_length <= string_length {\n        let possible_occurrence\
    \ = &string[idx..idx + substring_length];\n        if possible_occurrence == substring\
    \ {\n            occurrences += 1;\n            idx += substring_length;\n   \
    \     } else {\n            idx += 1;\n        }\n    }\n    occurrences\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpww0qyh0k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let mut count = 0;\n  let mut current_position = 0;\n\
    \  let mut position;\n  let substring_length = substring.len();\n  let string_length\
    \ = string.len();\n  let substring_characters: Vec<char> = substring.chars().collect();\n\
    \  let string_characters: Vec<char> = string.chars().collect();\n\n  loop {\n\
    \    position = string.find(&substring, current_position);\n    if position.is_none()\
    \ {\n      break;\n    }\n\n    if position.unwrap() == string_length - substring_length\
    \ {\n      break;\n    }\n\n    count += 1;\n    current_position = position.unwrap()\
    \ + 1;\n  }\n\n  let mut i = 0;\n  while i < string_length {\n    let mut j =\
    \ 0;\n    while j < substring_length {\n      if substring_characters[j] == string_characters[i]\
    \ {\n        if j == substring_length - 1 {\n          count += 1;\n        }\
    \ else {\n          i += 1;\n          j += 1;\n        }\n      } else {\n  \
    \      break;\n      }\n    }\n    i += 1;\n  }\n\n  count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp_7c007b5.rs:12:23\n     |\n12   |     position = string.find(&substring,\
    \ current_position);\n     |                       ^^^^ ----------  ----------------\
    \ supplied 2 arguments\n     |                       |\n     |               \
    \        expected 1 argument\n     |\nnote: associated function defined here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    string.match_indices(&substring).map(|(p, _)| (p as\
    \ isize) + 1).collect::<Vec<isize>>()\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpam03buoh.rs:3:5\n  |\n2 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n3 |     string.match_indices(&substring).map(|(p, _)| (p as\
    \ isize) + 1).collect::<Vec<isize>>()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n  |\n  = note: expected type `isize`\n\
    \           found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if string.len() < substring.len() {\n        return\
    \ 0;\n    }\n\n    let mut times: isize = 0;\n    let mut substring_index: usize\
    \ = 0;\n    let mut string_index: usize = 0;\n\n    while string_index < string.len()\
    \ {\n        if string.chars().nth(string_index) == substring.chars().nth(substring_index)\
    \ {\n            if substring_index + 1 == substring.len() {\n               \
    \ times += 1;\n                substring_index = 0;\n            } else {\n  \
    \              substring_index += 1;\n            }\n        } else {\n      \
    \      substring_index = 0;\n        }\n\n        string_index += 1;\n    }\n\n\
    \    times\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpug5goyoe.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n  let string_as_bytes = string.as_bytes();\n  let sub_string_as_bytes\
    \ = substring.as_bytes();\n  let mut counter = 0;\n  let mut current_index = 0;\n\
    \  let mut last_index = 0;\n  while current_index < string_as_bytes.len() {\n\
    \    if string_as_bytes[current_index] == sub_string_as_bytes[last_index] {\n\
    \      last_index += 1;\n      if last_index == sub_string_as_bytes.len() {\n\
    \        counter += 1;\n        last_index = 0;\n      }\n    } else {\n     \
    \ last_index = 0;\n    }\n    current_index += 1;\n  }\n  counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpf023baji.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut result = 0;\n    let mut next_index = 0;\n \
    \   let target_substring = substring.as_str();\n    let target_string = string.as_str();\n\
    \    loop {\n        match target_string.find(target_substring) {\n          \
    \  Some(index) => {\n                result += 1;\n                next_index\
    \ = index + substring.len();\n            }\n            None => break,\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821627
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut occurrences = 0;\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n    let mut index = 0;\n    let mut\
    \ last_match = 0;\n    loop {\n        if index + substring_len > string_len {\n\
    \            break;\n        }\n        let sub = string.get(index..(index + substring_len)).unwrap();\n\
    \        if sub == substring {\n            occurrences += 1;\n            last_match\
    \ = index;\n        }\n        index += substring_len;\n        if index < last_match\
    \ + substring_len {\n            index = last_match + substring_len;\n       \
    \ }\n    }\n    occurrences\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp5o90a744.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut occurences = 0;\n    let string = string.chars().collect::<Vec<char>>();\n\
    \    let substring = substring.chars().collect::<Vec<char>>();\n    let (substring_len,\
    \ string_len) = (substring.len(), string.len());\n    let mut i = 0;\n    while\
    \ i < string_len {\n        let mut j = 0;\n        while j < substring_len &&\
    \ i < string_len && string[i] == substring[j] {\n            i += 1;\n       \
    \     j += 1;\n        }\n        if j == substring_len {\n            occurences\
    \ += 1;\n        }\n        i -= j - 1;\n        i += 1;\n    }\n    occurences\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpkd16uhn3.rs:17:14

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let n = string.len();\n    let k = substring.len();\n\
    \    let mut counter = 0;\n    let mut i = 0;\n    while i < n - k + 1 {\n   \
    \     if string[i..i + k] == substring {\n            counter += 1;\n        \
    \    i += k;\n        } else {\n            i += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpl80x9inn.rs:7:15

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let len = substring.len();\n    let mut count = 0;\n\
    \    let mut pos = 0;\n    while let Some(i) = string[pos..].find(&substring)\
    \ {\n        count += 1;\n        pos += i + len;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp567vynhj.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let string = string.into_bytes();\n\
    \    let substring = substring.into_bytes();\n    for i in 0..string.len() {\n\
    \        if &string[i..i + substring.len()] == &substring[..] {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''range end index 10 out of range for slice
    of length 9'', /tmp/tmp0cs795n1.rs:7:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let len = substring.len();\n\
    \    for i in 0..string.len() - len + 1 {\n        if string[i..i + len] == substring\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmps18zmjt6.rs:5:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut last_occurrence = 0;\n\
    \    while last_occurrence < string.len() - substring.len() {\n        if string[last_occurrence..substring.len()].contains(&substring)\
    \ {\n            count += 1;\n            last_occurrence += substring.len();\n\
    \        } else {\n            last_occurrence += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpnsioh0el.rs:5:29

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    assert!(string.len() >= substring.len());\n    let mut\
    \ count = 0;\n    let mut start_index = 0;\n    let mut index;\n    loop {\n \
    \       index = string[start_index..].find(&substring);\n        if index.is_none()\
    \ {\n            break;\n        }\n        count += 1;\n        let i = index.unwrap();\n\
    \        start_index += i + substring.len();\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: string.len() >= substring.len()'',
    /tmp/tmprcusv_wx.rs:3:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let s: Vec<char> = string.chars().collect();\n\
    \    let n = s.len();\n    let sub: Vec<char> = substring.chars().collect();\n\
    \    let m = sub.len();\n    for i in 0..n {\n        if s[i] == sub[0] {\n  \
    \          if m == 1 {\n                count += 1;\n            } else {\n  \
    \              let mut j = 1;\n                while j < m && s[i + j] == sub[j]\
    \ {\n                    j += 1;\n                }\n                if j == m\
    \ {\n                    count += 1;\n                }\n            }\n     \
    \   }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmpc5zc7sj7.rs:14:32

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let s_split: Vec<&str> = string.split(&substring).collect();\n\
    \    let mut count = 0;\n    if s_split.len() > 1 {\n        count = s_split.len()\
    \ - 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpkuwlfm88.rs:8:12\n  |\n2 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n...\n8 |     return count;\n  |            ^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n8 |     return count.try_into().unwrap();\n\
    \  |            ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string = string.as_bytes();\n    let substring =\
    \ substring.as_bytes();\n    let mut count = 0;\n    let mut index = 0;\n    while\
    \ index < string.len() {\n        let mut matched = true;\n        for x in 0..substring.len()\
    \ {\n            if index + x >= string.len() || string[index + x] != substring[x]\
    \ {\n                matched = false;\n                break;\n            }\n\
    \        }\n        if matched {\n            count += 1;\n            index +=\
    \ substring.len();\n        } else {\n            index += 1;\n        }\n   \
    \ }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpph8ebr6a.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut pos = 0;\n    let mut cnt = 0;\n    while pos < string.len() {\n\
    \        let idx = string[pos..].find(&substring);\n        if idx.is_none() {\n\
    \            break;\n        }\n        pos += idx.unwrap();\n        cnt += 1;\n\
    \        pos += 1;\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut curr_pos = 0;\n    let\
    \ sub_len = substring.len();\n    while curr_pos < string.len() {\n        let\
    \ mut tmp_pos = string[curr_pos..].find(&substring);\n        if tmp_pos.is_none()\
    \ {\n            break;\n        } else {\n            count += 1;\n         \
    \   tmp_pos = tmp_pos.unwrap();\n            curr_pos += tmp_pos + sub_len;\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7rrhfc2c.rs:12:23\n   |\n\
    12 |             tmp_pos = tmp_pos.unwrap();\n   |                       ^^^^^^^^^^^^^^^^\n\
    \   |                       |\n   |                       expected enum `Option`,\
    \ found `usize`\n   |                       help: try using a variant of the expected\
    \ enum: `Some(tmp_pos.unwrap())`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\n\nerror[E0369]: cannot add `usize` to `Option<usize>`\n\
    \  --> /tmp/tmp7rrhfc2c.rs:13:33\n   |\n13 |             curr_pos += tmp_pos +\
    \ sub_len;\n   |                         ------- ^ ------- usize\n   |       \
    \                  |\n   |                         Option<usize>\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n    let mut found = 0;\n    let mut index = 0;\n    while\
    \ index < string_len {\n        let curr_string = &string[index..];\n        let\
    \ found_index = curr_string.find(&substring);\n        match found_index {\n \
    \           Some(x) => {\n                index += x + substring_len;\n      \
    \          found += 1;\n            }\n            None => break,\n        }\n\
    \    }\n    found\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpskgn33u7.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let s = string.as_bytes();\n\
    \    let t = substring.as_bytes();\n    for i in 0..s.len() {\n        if s[i]\
    \ == t[0] {\n            let mut found = true;\n            for j in 0..t.len()\
    \ {\n                if t[j] != s[i + j] {\n                    found = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ found {\n                count += 1;\n            }\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmp6qoe1m6v.rs:10:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut i = 0;\n    let string_bytes\
    \ = string.as_bytes();\n    let substring_bytes = substring.as_bytes();\n    let\
    \ str_len = string_bytes.len();\n    let sub_len = substring_bytes.len();\n  \
    \  while i < str_len {\n        //println!(\"checking at {}\", i);\n        if\
    \ str_len < sub_len + i {\n            break;\n        }\n        let slice =\
    \ &string_bytes[i..sub_len + i];\n        if slice == substring_bytes {\n    \
    \        //println!(\"found one\");\n            count += 1;\n            i +=\
    \ sub_len;\n        } else {\n            i += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpppg59avn.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut pointer = 0;\n    let\
    \ mut len_string = string.len();\n    let len_substring = substring.len();\n \
    \   while pointer < len_string {\n        if string[pointer..].starts_with(&substring)\
    \ {\n            count += 1;\n            pointer += len_substring;\n        }\
    \ else {\n            pointer += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpnb0z1iox.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut start = 0;\n    let\
    \ mut chars = string.chars();\n    while start < string.len() {\n        match\
    \ chars.nth(start) {\n            Some(character) => {\n                let next_position\
    \ = string.find(character, start);\n                match next_position {\n  \
    \                  Some(next_position) => {\n                        if next_position\
    \ > start {\n                            counter += 1;\n                     \
    \       start = next_position;\n                        }\n                  \
    \  }\n                    None => {\n                        start = string.len();\n\
    \                    }\n                }\n            }\n            None =>\
    \ {\n                return counter;\n            }\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpcmuq5b1d.rs:9:44\n     |\n9    |                 let next_position\
    \ = string.find(character, start);\n     |                                   \
    \         ^^^^ ---------  ----- supplied 2 arguments\n     |                 \
    \                           |\n     |                                        \
    \    expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut j = 0;\n    let start_string:\
    \ Vec<char> = string.chars().collect();\n    let start_substring: Vec<char> =\
    \ substring.chars().collect();\n    while j < string.len() {\n        let mut\
    \ i = 0;\n        while i < substring.len() && j < string.len() && start_string[j]\
    \ == start_substring[i] {\n            i += 1;\n            j += 1;\n        }\n\
    \        if i == substring.len() {\n            count += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpob54qsh7.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut how_many: isize = 0;\n    let size = substring.len();\n\
    \    let string = string.as_bytes();\n    let substring = substring.as_bytes();\n\
    \    for i in 0..string.len() - size + 1 {\n        let is_there = string[i..i\
    \ + size] == substring;\n        if is_there {\n            how_many += 1;\n \
    \       }\n    }\n    how_many\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `[u8]` with `&[u8]`\n --> /tmp/tmp75rm3pt0.rs:8:44\n\
    \  |\n8 |         let is_there = string[i..i + size] == substring;\n  |      \
    \                                      ^^ no implementation for `[u8] == &[u8]`\n\
    \  |\n  = help: the trait `PartialEq<&[u8]>` is not implemented for `[u8]`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let string = string.into_bytes();\n\
    \    let substring = substring.into_bytes();\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut start = 0;\n    while i < string.len() {\n        if string[i]\
    \ == substring[j] {\n            if j == 0 {\n                start = i;\n   \
    \         }\n            j += 1;\n            if j == substring.len() {\n    \
    \            count += 1;\n                j = 0;\n                i = start +\
    \ 1;\n            } else {\n                i += 1;\n            }\n        }\
    \ else {\n            j = 0;\n            i += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // Clone the inputs to modify them.\n    let mut string\
    \ = string.clone();\n    let mut substring = substring.clone();\n\n    // Get\
    \ the length of the inputs.\n    let string_len = string.len();\n    let substring_len\
    \ = substring.len();\n\n    // If the substring is empty return the length of\
    \ the string.\n    if substring_len == 0 {\n        return string_len as isize;\n\
    \    }\n\n    // Create the result variable.\n    let mut res = 0;\n\n    // While\
    \ we can find the substring.\n    while let Some(pos) = string.find(&substring)\
    \ {\n        // Update the result.\n        res += 1;\n\n        // Remove the\
    \ letters from the string.\n        string.remove(pos);\n        string.remove(pos);\n\
    \    }\n\n    // Return the result.\n    res\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''cannot remove a char from the end of a string'',
    /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/string.rs:1252:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // String indexing starts at 0.\n    let mut start_index\
    \ = 0;\n    let mut count = 0;\n\n    while start_index < string.len() {\n   \
    \     if let Some(index) = string[start_index..].find(&substring) {\n        \
    \    count += 1;\n            start_index += index + substring.len();\n      \
    \  } else {\n            break;\n        }\n    }\n\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgwzbagd3.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_vec: Vec<_> = string.split('').collect();\n\
    \    let substring_vec: Vec<_> = substring.split('').collect();\n    let mut index:\
    \ isize = 0;\n    let mut result: isize = 0;\n    while index < string_vec.len()\
    \ {\n        for i in 0..substring_vec.len() {\n            if string_vec[index+i]\
    \ != substring_vec[i] {\n                break;\n            }\n            if\
    \ i == substring_vec.len()-1 {\n                result += 1;\n            }\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: empty character literal\n --> /tmp/tmp8ct0jxvc.rs:3:44\n  |\n3 |\
    \     let string_vec: Vec<_> = string.split('').collect();\n  |              \
    \                              ^ empty character literal\n\nerror: empty character\
    \ literal\n --> /tmp/tmp8ct0jxvc.rs:4:50\n  |\n4 |     let substring_vec: Vec<_>\
    \ = substring.split('').collect();\n  |                                      \
    \            ^ empty character literal\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmp8ct0jxvc.rs:7:19\n  |\n7 |     while index < string_vec.len() {\n  |\
    \                   ^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n  |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n  |\n7 |     while index < string_vec.len().try_into().unwrap() {\n  |\
    \                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp8ct0jxvc.rs:9:33\n  |\n9 |             if string_vec[index+i]\
    \ != substring_vec[i] {\n  |                                 ^ expected `isize`,\
    \ found `usize`\n\nerror[E0277]: cannot add `usize` to `isize`\n --> /tmp/tmp8ct0jxvc.rs:9:32\n\
    \  |\n9 |             if string_vec[index+i] != substring_vec[i] {\n  |      \
    \                          ^ no implementation for `isize + usize`\n  |\n  = help:\
    \ the trait `Add<usize>` is not implemented for `isize`\n\nerror[E0277]: the type\
    \ `[&str]` cannot be indexed by `isize`\n --> /tmp/tmp8ct0jxvc.rs:9:16\n  |\n\
    9 |             if string_vec[index+i] != substring_vec[i] {\n  |            \
    \    ^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \  |\n  = help: the trait `SliceIndex<[&str]>` is not implemented for `isize`\n\
    \  = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<&str>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut result = 0;\n    let mut start = 0;\n    let\
    \ sublen = substring.len();\n    let strlen = string.len();\n    while start +\
    \ sublen <= strlen {\n        if &string[start..start + sublen] == substring {\n\
    \            result += 1;\n            start += sublen;\n        } else {\n  \
    \          start += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpz3x8sq8i.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ mut previous_index = 0;\n    while index < string.len() {\n        match string[index..].find(&substring)\
    \ {\n            Some(i) => {\n                count += 1;\n                previous_index\
    \ = index;\n                index += i + substring.len();\n            }\n   \
    \         None => break,\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp1dnq5h72.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for i in 0..string.len() {\n\
    \        if i + substring.len() > string.len() {\n            break;\n       \
    \ }\n        if &string[i..i + substring.len()] == substring {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_chars: Vec<char> = string.chars().collect();\n\
    \    let substring_chars: Vec<char> = substring.chars().collect();\n    let mut\
    \ count = 0;\n    for i in 0..(string_chars.len() - substring_chars.len() + 1)\
    \ {\n        let mut is_substring = true;\n        for j in 0..substring_chars.len()\
    \ {\n            if string_chars[i + j] != substring_chars[j] {\n            \
    \    is_substring = false;\n                break;\n            }\n        }\n\
    \        if is_substring {\n            count += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgjc3ljac.rs:6:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    assert!(string.len() >= substring.len());\n    let mut\
    \ matches = 0;\n    let string = string.as_bytes();\n    let substring = substring.as_bytes();\n\
    \    let slen = string.len();\n    let sslen = substring.len();\n    for offset\
    \ in 0..slen - sslen + 1 {\n        let mut matches_here = true;\n        for\
    \ i in 0..sslen {\n            if string[offset + i] != substring[i] {\n     \
    \           matches_here = false;\n                break;\n            }\n   \
    \     }\n        if matches_here {\n            matches += 1;\n        }\n   \
    \ }\n    matches\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: string.len() >= substring.len()'',
    /tmp/tmpo_q6hryy.rs:3:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821622
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut i = 0;\n    let r\
    \ = Regex::new(&substring).unwrap();\n    for x in r.find_iter(&string) {\n  \
    \      counter += 1;\n        i = x.end();\n    }\n    if i != 0 {\n        counter\
    \ += how_many_times(string[i..].to_string(), substring);\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpz8rpp9m4.rs:5:13\n\
    \  |\n5 |     let r = Regex::new(&substring).unwrap();\n  |             ^^^^^\
    \ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let substring_len = substring.len();\n    let mut\
    \ index = 0;\n    while index < string.len() {\n        let res = string[index..].find(&substring);\n\
    \        if res.is_none() {\n            break;\n        }\n        count += 1;\n\
    \        index += res.unwrap() + substring_len;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp4oqa0orj.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ len = substring.len();\n    loop {\n        match string[index..].find(&substring)\
    \ {\n            Some(found) => {\n                count += 1;\n             \
    \   index += found + len;\n            }\n            None => break,\n       \
    \ }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpezc8kw45.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let s = string.as_bytes();\n    let sub = substring.as_bytes();\n\
    \    let s_len = s.len();\n    let sub_len = sub.len();\n    let mut count = 0;\n\
    \    let mut i = 0;\n    while i < s_len {\n        let mut j = 0;\n        while\
    \ j < sub_len && s[i + j] == sub[j] {\n            j += 1;\n        }\n      \
    \  if j == sub_len {\n            count += 1;\n            i += sub_len;\n   \
    \     } else {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 9 but the
    index is 9'', /tmp/tmpz8uzm9ap.rs:11:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821623
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let index = 0;\n    while let\
    \ Some(i) = string[index..].find(&substring) {\n        count += 1;\n        index\
    \ = i + 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `index`\n --> /tmp/tmpktx0q756.rs:7:9\n\
    \  |\n4 |     let index = 0;\n  |         -----\n  |         |\n  |         first\
    \ assignment to `index`\n  |         help: consider making this binding mutable:\
    \ `mut index`\n...\n7 |         index = i + 1;\n  |         ^^^^^^^^^^^^^ cannot\
    \ assign twice to immutable variable\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659821622
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string_vec: Vec<char> = string.chars().collect();\n\
    \    let substring_vec: Vec<char> = substring.chars().collect();\n    let mut\
    \ occurrences = 0;\n    let mut index = 0;\n    while index < string_vec.len()\
    \ - substring_vec.len() + 1 {\n        let mut i = 0;\n        while i < substring_vec.len()\
    \ && string_vec[index + i] == substring_vec[i] {\n            i += 1;\n      \
    \  }\n        if i == substring_vec.len() {\n            occurrences += 1;\n \
    \           index += i;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    occurrences\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpw65qepcv.rs:7:19

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821623
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let len = substring.len();\n    let mut counter = 0;\n\
    \    for (i, c) in string.char_indices() {\n        if string[i..].starts_with(&substring)\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let size = substring.len();\n    let mut count = 0;\n\
    \    let mut i = 0;\n    while i < string.len() {\n        if &string[i..i+size]\
    \ == substring {\n            count += 1;\n            i += size;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 10 is out of bounds of `cacacacac`'',
    /tmp/tmpr6v4xoky.rs:7:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821623
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut idx = 0;\n    while\
    \ let Some(index) = string[idx..].find(&substring) {\n        counter += 1;\n\
    \        idx += index + 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821623
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let string = &string;\n    let substring = &substring;\n\
    \    let mut result = 0;\n    let mut pos = 0;\n    let sub_len = substring.len();\n\
    \    let str_len = string.len();\n    while pos < str_len {\n        let temp\
    \ = string.find(substring);\n        if temp == None {\n            break;\n \
    \       }\n        let temp = temp.unwrap();\n        result += 1;\n        pos\
    \ = temp + sub_len;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821628
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut pattern = substring.clone();\n    let mut count\
    \ = 0;\n    while pattern.len() <= string.len() {\n        if string.contains(&pattern)\
    \ {\n            count += 1;\n        }\n        pattern = pattern.chars().skip(1).collect();\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n   \
    \ assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821628
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let len = substring.len();\n    let mut index = 0;\n\
    \    let mut counts = 0;\n    while let Some(i) = string[index..].find(&substring)\
    \ {\n        counts += 1;\n        index += i + len;\n    }\n    counts\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpsyengpdb.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut cursor = 0;\n    let\
    \ string_length = string.len();\n    let substring_length = substring.len();\n\
    \    let mut string_bytes = string.into_bytes();\n    let substring_bytes = substring.into_bytes();\n\
    \    loop {\n        let found = string_bytes[cursor..].find(&substring_bytes);\n\
    \        if found.is_none() {\n            break;\n        }\n        count +=\
    \ 1;\n        cursor += found.unwrap() + substring_length;\n        if cursor\
    \ >= string_length {\n            break;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find` found for slice `[u8]` in the current\
    \ scope\n  --> /tmp/tmp9kgdjdmt.rs:10:44\n   |\n10 |         let found = string_bytes[cursor..].find(&substring_bytes);\n\
    \   |                                            ^^^^ method not found in `[u8]`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut offset = 0;\n    let\
    \ mut offset_string = 0;\n    let substring_len = substring.len();\n    let string_len\
    \ = string.len();\n    let string_slice = &string[offset_string..string_len];\n\
    \    for i in 0..string_len {\n        let c = string_slice.chars().nth(i).unwrap();\n\
    \        if c == substring.chars().nth(offset).unwrap() {\n            if offset\
    \ == substring_len - 1 {\n                count += 1;\n                offset\
    \ = 0;\n            } else {\n                offset += 1;\n            }\n  \
    \      } else {\n            offset = 0;\n        }\n    }\n    count\n}\n\nfn\
    \ main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpvjvehnsb.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let length = substring.len();\n    let mut result =\
    \ 0;\n    let mut offset = 0;\n    while length + offset <= string.len() {\n \
    \       if &string[offset..length + offset] == substring {\n            result\
    \ += 1;\n        }\n        offset += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821623
- exit_code: -1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut ret = 0;\n    let mut pos = string.find(&substring);\n\
    \    while pos.is_some() {\n        ret += 1;\n        let pos_next = pos.unwrap()\
    \ + substring.len();\n        if pos_next >= string.len() {\n            break;\n\
    \        }\n        pos = string.find(&substring);\n    }\n    ret\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659821628
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut found_times = 0;\n    let mut start_index =\
    \ 0;\n    let mut end_index = substring.len();\n    let string_len = string.len();\n\
    \    let substring_len = substring.len();\n\n    while end_index <= string_len\
    \ {\n        let temp_string = string.get(start_index..end_index).unwrap();\n\
    \        if temp_string == substring {\n            found_times += 1;\n      \
    \      start_index += substring_len;\n            end_index += substring_len;\n\
    \        } else {\n            start_index += 1;\n            end_index += 1;\n\
    \        }\n    }\n\n    found_times\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpm6llytfx.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    //KMP\n    let mut occurrences = 0;\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut fl = vec![0; substring.len()];\n    let\
    \ mut substring = substring.into_bytes();\n    let string = string.into_bytes();\n\
    \    fail(substring.clone(), &mut fl);\n    while i < string.len() {\n       \
    \ if substring[j] == string[i] {\n            i += 1;\n            j += 1;\n \
    \       }\n        if j == substring.len() {\n            occurrences += 1;\n\
    \            j = fl[j - 1];\n        } else if i < string.len() && substring[j]\
    \ != string[i] {\n            if j != 0 {\n                j = fl[j - 1];\n  \
    \          } else {\n                i += 1;\n            }\n        }\n    }\n\
    \    occurrences\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `fail` in this scope\n  --> /tmp/tmpqbe0um5w.rs:10:5\n\
    \   |\n10 |     fail(substring.clone(), &mut fl);\n   |     ^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut index = 0;\n    let\
    \ sub_len = substring.len();\n    let str_len = string.len();\n    while index\
    \ < str_len {\n        if let Some(x) = string[index..].find(&substring) {\n \
    \           index += x + sub_len;\n            count += 1;\n        } else {\n\
    \            break;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpb5vryi9s.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let (string, substring) = (string.as_bytes(), substring.as_bytes());\n\
    \    let (length, substr_length) = (string.len(), substring.len());\n    let mut\
    \ overlap = vec![0; substr_length];\n    overlap[0] = -1;\n    let mut i = 0;\n\
    \    let mut j = -1;\n    while i < substr_length {\n        while j >= 0 && substring[i]\
    \ != substring[j] {\n            j = overlap[j as usize];\n        }\n       \
    \ i += 1;\n        j += 1;\n        overlap[i] = j;\n    }\n    let mut occurances\
    \ = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < length {\n     \
    \   while j >= 0 && string[i] != substring[j] {\n            j = overlap[j as\
    \ usize];\n        }\n        i += 1;\n        j += 1;\n        if j == substr_length\
    \ {\n            occurances += 1;\n            j = overlap[j as usize];\n    \
    \    }\n    }\n    occurances\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpkd3ssw42.rs:8:17\n\
    \  |\n8 |     let mut j = -1;\n  |                 ^^ the trait `Neg` is not implemented\
    \ for `usize`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \ --> /tmp/tmpkd3ssw42.rs:6:18\n  |\n6 |     overlap[0] = -1;\n  |           \
    \       ^^ the trait `Neg` is not implemented for `usize`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut current_index = 0;\n\
    \    while current_index < string.len() {\n        if string[current_index..].starts_with(&substring)\
    \ {\n            count += 1;\n            current_index += substring.len();\n\
    \        } else {\n            current_index += 1;\n        }\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpt6uzhcgg.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut found_times = 0;\n    let mut index = 0;\n \
    \   loop {\n        index = string.find(substring.as_str(), index).unwrap_or(-1);\n\
    \        if index == -1 {\n            break;\n        }\n        found_times\
    \ += 1;\n        index += 1;\n    }\n    found_times\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpk3x6bqjo.rs:6:24\n     |\n6    |         index = string.find(substring.as_str(),\
    \ index).unwrap_or(-1);\n     |                        ^^^^ ------------------\
    \  ----- supplied 2 arguments\n     |                        |\n     |       \
    \                 expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n -->\
    \ /tmp/tmpk3x6bqjo.rs:6:66\n  |\n6 |         index = string.find(substring.as_str(),\
    \ index).unwrap_or(-1);\n  |                                                 \
    \                 ^^\n  |                                                    \
    \              |\n  |                                                        \
    \          cannot apply unary operator `-`\n  |                              \
    \                                    help: you may have meant the maximum value\
    \ of `usize`: `usize::MAX`\n  |\n  = note: unsigned values cannot be negated\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n --> /tmp/tmpk3x6bqjo.rs:7:21\n\
    \  |\n7 |         if index == -1 {\n  |                     ^^\n  |          \
    \           |\n  |                     cannot apply unary operator `-`\n  |  \
    \                   help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \  |\n  = note: unsigned values cannot be negated\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0600.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 0
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut index = 0;\n    let\
    \ string_chars: Vec<char> = string.chars().collect();\n    let substring_chars:\
    \ Vec<char> = substring.chars().collect();\n    for _ in 0..string.len() {\n \
    \       let idx = string[index..].find(&substring);\n        match idx {\n   \
    \         Some(i) => {\n                counter += 1;\n                index +=\
    \ i + 1;\n            }\n            None => break,\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    if substring.len() == 0 {\n        return -1;\n    }\n\
    \    let s: Vec<char> = string.chars().collect();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut count = 0;\n    let mut found = false;\n    while i\
    \ < s.len() {\n        if s[i] == substring.chars().nth(j).unwrap() {\n      \
    \      if j == 0 {\n                found = true;\n            }\n           \
    \ j += 1;\n            if j == substring.len() {\n                count += 1;\n\
    \                j = 0;\n                found = false;\n            }\n     \
    \   } else {\n            if found {\n                j = 0;\n               \
    \ found = false;\n            }\n        }\n        i += 1;\n    }\n    return\
    \ count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp202fl55v.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let sub_len = substring.len();\n    let str_len = string.len();\n\
    \    let mut result = 0;\n    for i in 0..(str_len - sub_len + 1) {\n        if\
    \ string[i..i + sub_len] == substring {\n            result += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = how_many_times;\n  \
    \  assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpdol003id.rs:6:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut string_current = String::from(string.as_str());\n\
    \    loop {\n        match string_current.find(substring.as_str()) {\n       \
    \     Some(v) => {\n                count += 1;\n                string_current\
    \ = string_current[v + substring.len()..].to_string();\n            }\n      \
    \      None => break,\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpgqw897pr.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    // Replace all instances of the substring with something\
    \ that can't be found in the original string.\n    let mut modified_string = string.clone();\n\
    \    modified_string = modified_string.replace(&substring, \"*****\");\n\n   \
    \ // Count the number of instances of the substring and return it.\n    let string_length\
    \ = modified_string.len() as isize;\n    let substring_length = substring.len()\
    \ as isize;\n    (string_length - substring_length + 1) / 5\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmpw3uiowhr.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut counter = 0;\n    let mut string_iterator =\
    \ string.chars();\n    let mut substring_iterator = substring.chars();\n    loop\
    \ {\n        match string_iterator.next() {\n            Some(c) => {\n      \
    \          if c == substring_iterator.next().unwrap() {\n                    if\
    \ substring_iterator.clone().next() == None {\n                        counter\
    \ += 1;\n                        substring_iterator = substring.chars();\n   \
    \                 }\n                } else {\n                    substring_iterator\
    \ = substring.chars();\n                }\n            }\n            None =>\
    \ break,\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate =\
    \ how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `4`', /tmp/tmp3ejikpyt.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659821623
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\nfn how_many_times(string: String, substring:\
    \ String) -> isize {\n    let mut count = 0;\n    for i in 0..(string.len() -\
    \ substring.len() + 1) {\n        if &string[i..(i + substring.len())] == substring\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpffm01qk7.rs:4:18

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659821623
