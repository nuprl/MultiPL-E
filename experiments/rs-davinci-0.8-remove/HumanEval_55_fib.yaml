name: HumanEval_55_fib
language: rs
prompt: "/// Return n-th Fibonacci number.\nfn fib(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = fib;\n    assert_eq!(candidate(10),\
  \ 55);\n    assert_eq!(candidate(1), 1);\n    assert_eq!(candidate(8), 21);\n  \
  \  assert_eq!(candidate(11), 89);\n    assert_eq!(candidate(12), 144);\n}\n"
completions: ["    let mut f1 = 0;\n    let mut f2 = 1;\n    let mut sum = 0;\n  \
    \  for _ in 0..n {\n        sum = f1 + f2;\n        f1 = f2;\n        f2 = sum;\n\
    \    }\n    sum", "    let mut prev_prev = 0;\n    let mut prev = 1;\n    let\
    \ mut curr = 1;\n    for _ in 2..(n + 1) {\n        curr = prev + prev_prev;\n\
    \        prev_prev = prev;\n        prev = curr;\n    }\n    curr", "    if n\
    \ < 2 {\n        return n;\n    }\n    fib(n - 1) + fib(n - 2)", "    let mut\
    \ a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let c = a + b;\n  \
    \      a = b;\n        b = c;\n    }\n    a", "    match n {\n        0 => 1,\n\
    \        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n ==\
    \ 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n \
    \   let mut a = 0;\n    let mut b = 1;\n    for _ in 2..n + 1 {\n        let c\
    \ = a + b;\n        a = b;\n        b = c;\n    }\n    b", "    match n {\n  \
    \      0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }",
  "    match n {\n        0 => 0,\n        1 => 1,\n        n => fib(n - 1) + fib(n\
    \ - 2),\n    }", "    if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n\
    \        return 1;\n    }\n    let mut x = 0;\n    let mut y = 1;\n    for _ in\
    \ 2..=n {\n        let z = x + y;\n        x = y;\n        y = z;\n    }\n   \
    \ y", "    let mut f0 = 0;\n    let mut f1 = 1;\n    for _ in 0..n {\n       \
    \ let f2 = f0 + f1;\n        f0 = f1;\n        f1 = f2;\n    }\n    f0", "   \
    \ let sqrt5 = 5f64.sqrt();\n    let phi = (1f64 + sqrt5) / 2f64;\n    let psi\
    \ = (1f64 - sqrt5) / 2f64;\n    ((phi.powi(n) - psi.powi(n)) / sqrt5).round()\
    \ as isize", "    if n < 1 {\n        panic!(\"Fibonacci is only defined for n\
    \ > 0\");\n    } else if n == 1 || n == 2 {\n        1\n    } else {\n       \
    \ fib(n - 1) + fib(n - 2)\n    }", "    let mut i = 0;\n    let mut j = 1;\n \
    \   for _ in 0..n {\n        let tmp = i + j;\n        i = j;\n        j = tmp;\n\
    \    }\n    return i;", "  if n < 2 { return n; }\n  fib(n - 1) + fib(n - 2)",
  "    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n \
    \       fib(n - 1) + fib(n - 2)\n    }", "    if n == 0 {\n        return 0;\n\
    \    } else if n == 1 {\n        return 1;\n    } else {\n        return fib(n\
    \ - 1) + fib(n - 2);\n    }", '    fib_iter(1, 0, n)', "    let mut curr = 0;\n\
    \    let mut next = 1;\n    for _ in 0..n {\n        let tmp = curr;\n       \
    \ curr = next;\n        next = tmp + next;\n    }\n    curr", "    if n == 0 {\
    \ return 0; }\n    if n == 1 { return 1; }\n    return fib(n - 1) + fib(n - 2);",
  "    if n == 0 {\n        return 0;\n    } else if n == 1 {\n        return 1;\n\
    \    } else {\n        return fib(n - 1) + fib(n - 2);\n    }", "    if n == 0\
    \ {\n        return 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n   \
    \ return fib(n - 1) + fib(n - 2);", "    match n {\n        0 => 0,\n        1\
    \ => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n == 0 {\n   \
    \     return 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    return\
    \ fib(n - 1) + fib(n - 2);", "    if n < 2 {\n        n\n    } else {\n      \
    \  fib(n - 1) + fib(n - 2)\n    }", "    match n {\n        0 => 0,\n        1\
    \ => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }", "  let mut fib_num = 0;\n\
    \  let mut prev_fib_num = 1;\n  for _ in 0..n {\n    let temp = fib_num;\n   \
    \ fib_num = fib_num + prev_fib_num;\n    prev_fib_num = temp;\n  }\n  return fib_num;",
  "    match n {\n        0 | 1 => n,\n        n => fib(n - 1) + fib(n - 2),\n   \
    \ }", "  let mut a = 0;\n  let mut b = 1;\n  for _ in 0..n {\n    let c = a +\
    \ b;\n    a = b;\n    b = c;\n  }\n  a", "    if n == 0 {\n        return 0;\n\
    \    }\n    if n == 1 {\n        return 1;\n    }\n    return fib(n - 1) + fib(n\
    \ - 2);", "    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n   \
    \ } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    let mut fib = vec![0,\
    \ 1];\n    for i in 2..n + 1 {\n        fib.push(fib[i as usize - 1] + fib[i as\
    \ usize - 2]);\n    }\n    fib[n as usize]", "    //\n    // Make sure to use\
    \ the form of closure that captures its parameters by reference.\n    //\n   \
    \ let fib_ptr = &mut |n: isize| -> isize {\n        //\n        // Create mutable\
    \ variables and initialize them to default value.\n        //\n        let mut\
    \ fib_n_minus_2 = Box::new(0);\n        let mut fib_n_minus_1 = Box::new(1);\n\
    \        let mut fib_n = Box::new(0);\n\n        //\n        // If number is less\
    \ than 1 then return 0.\n        //\n        if n < 1 {\n            return *fib_n;\n\
    \        }\n\n        //\n        // Initialize variables so they can be used\
    \ below.\n        //\n        *fib_n_minus_2 = 0;\n        *fib_n_minus_1 = 1;\n\
    \n        //\n        // Calculate Fibonacci number.\n        //\n        for\
    \ _i in 1..n {\n            *fib_n = *fib_n_minus_2 + *fib_n_minus_1;\n      \
    \      *fib_n_minus_2 = *fib_n_minus_1;\n            *fib_n_minus_1 = *fib_n;\n\
    \        }\n\n        //\n        // Return calculated Fibonacci number.\n   \
    \     //\n        *fib_n\n    };\n\n    //\n    // Invoke the closure with the\
    \ passed number.\n    //\n    fib_ptr(n)", "    match n {\n        0 | 1 => n,\n\
    \        n => fib(n - 1) + fib(n - 2),\n    }", "    if n == 0 {\n        return\
    \ 0;\n    } else if n == 1 {\n        return 1;\n    } else {\n        return\
    \ fib(n - 1) + fib(n - 2);\n    }", "    let mut a = 0;\n    let mut b = 1;\n\
    \    for _ in 0..n {\n        let tmp = a;\n        a = b;\n        b = tmp +\
    \ b;\n    }\n    a", "    let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n\
    \ {\n        let c = a + b;\n        a = b;\n        b = c;\n    }\n    a", " \
    \   if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1;\n\
    \    }\n    fib(n - 1) + fib(n - 2)", "    match n {\n        0 => 0,\n      \
    \  1 => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }", "    let mut f0 = 0;\n\
    \    let mut f1 = 1;\n    let mut f = 0;\n    for _ in 0..n {\n        f = f0\
    \ + f1;\n        f0 = f1;\n        f1 = f;\n    }\n    f", "    match n {\n  \
    \      0 => 1,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }",
  "  if n < 2 {\n    return n;\n  }\n  let mut a = 0;\n  let mut b = 1;\n  for _ in\
    \ 0..n {\n    let tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return a;", " \
    \   if n < 2 { return n; }\n    fib(n - 1) + fib(n - 2)", "    match n {\n   \
    \     0 | 1 => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }", "    let mut\
    \ f = vec![0, 1];\n    for i in 2..=n {\n        f.push(f[i - 1] + f[i - 2]);\n\
    \    }\n    f[n as usize]", "    // Fast exponentiation algorithm.\n    fn pow(m:\
    \ &Matrix2x2, n: isize) -> Matrix2x2 {\n        let mut r = Matrix2x2::new(1,\
    \ 0, 0, 1);\n        let mut p = m.clone();\n        let mut b = n;\n        while\
    \ b > 0 {\n            if b % 2 == 1 {\n                r = r * p;\n         \
    \   }\n            p = p * p;\n            b >>= 1;\n        }\n        r\n  \
    \  }\n\n    if n < 0 {\n        panic!(\"Negative input {}\", n);\n    }\n   \
    \ pow(&Matrix2x2::new(1, 1, 1, 0), n).m[0][1]", "    let n = n as u32;\n    if\
    \ n < 2 {\n        n as isize\n    } else {\n        fib(n - 1) + fib(n - 2)\n\
    \    }", "    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    }\
    \ else {\n        fib(n - 1) + fib(n - 2)\n    }", "  match n {\n    0 => 0,\n\
    \    1 => 1,\n    _ => fib(n - 1) + fib(n - 2),\n  }", "    let mut a = 0;\n \
    \   let mut b = 1;\n    for _ in 0..n {\n        let c = a + b;\n        a = b;\n\
    \        b = c;\n    }\n    a", "    if n < 2 {\n        return n;\n    }\n  \
    \  fib(n - 1) + fib(n - 2)", "    match n {\n        0 => 0,\n        1 => 1,\n\
    \        n => fib(n - 1) + fib(n - 2),\n    }", "    let mut f0 = 0;\n    let\
    \ mut f1 = 1;\n    for _ in 0..n {\n        let f2 = f0 + f1;\n        f0 = f1;\n\
    \        f1 = f2;\n    }\n    f0", "    if n == 0 {\n        return 0;\n    }\n\
    \    if n == 1 {\n        return 1;\n    }\n    fib(n - 1) + fib(n - 2)", "  \
    \  if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n \
    \       fib(n - 1) + fib(n - 2)\n    }", "    // F(n) = F(n-1) + F(n-2)\n    if\
    \ n < 2 {\n        return n;\n    }\n    fib(n - 1) + fib(n - 2)", "    let mut\
    \ prev_prev: isize = 0;\n    let mut prev: isize = 1;\n    let mut current: isize\
    \ = 0;\n    for _ in 1..n {\n        current = prev_prev + prev;\n        prev_prev\
    \ = prev;\n        prev = current;\n    }\n    return current;", "    match n\
    \ {\n        0 => 0,\n        1 => 1,\n        n => fib(n - 1) + fib(n - 2),\n\
    \    }", "    let mut i = 0;\n    let mut j = 1;\n    for _ in 0..n {\n      \
    \  let t = i + j;\n        i = j;\n        j = t;\n    }\n    i", "    if n <\
    \ 2 {\n        n\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }", "   \
    \ if n < 0 {\n        panic!(\"n must be zero or positive\");\n    }\n    match\
    \ n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n\
    \    }", "    let mut f0 = 0;\n    let mut f1 = 1;\n    for _ in 0..n {\n    \
    \    let f2 = f0 + f1;\n        f0 = f1;\n        f1 = f2;\n    }\n    f0", " \
    \   // TODO: Solve without recursion\n    if n == 0 {\n        return 0;\n   \
    \ } else if n == 1 {\n        return 1;\n    } else {\n        return fib(n -\
    \ 1) + fib(n - 2);\n    }", "    if n < 2 {\n        return n;\n    }\n\n    fib(n\
    \ - 1) + fib(n - 2)", "    match n {\n        0 => 0,\n        1 => 1,\n     \
    \   _ => fib(n - 1) + fib(n - 2),\n    }", "    if n == 0 {\n        return 0;\n\
    \    } else if n == 1 {\n        return 1;\n    } else {\n        return fib(n\
    \ - 1) + fib(n - 2);\n    }", "    if n < 2 {\n        return n;\n    }\n\n  \
    \  fib(n - 1) + fib(n - 2)", "    if n < 2 {\n        return n;\n    }\n    return\
    \ fib(n - 1) + fib(n - 2);", "    if n == 0 {\n        return 0;\n    } else if\
    \ n == 1 {\n        return 1;\n    } else {\n        return fib(n - 1) + fib(n\
    \ - 2);\n    }", "    if n == 0 {\n        return 0;\n    } else if n == 1 {\n\
    \        return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n  \
    \  }", "    if n < 2 {\n        return n;\n    }\n    fib(n - 1) + fib(n - 2)",
  "    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n\
    \ - 2),\n    }", "    match n {\n        0 | 1 => n,\n        n => fib(n - 1)\
    \ + fib(n - 2),\n    }", "    if n == 0 {\n        0\n    } else if n == 1 {\n\
    \        1\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    match\
    \ n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n\
    \    }", "    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    }\
    \ else {\n        fib(n - 1) + fib(n - 2)\n    }", "    if n < 2 {\n        return\
    \ n;\n    }\n    fib(n - 1) + fib(n - 2)", "    if n == 0 { return 0; }\n    if\
    \ n == 1 { return 1; }\n    fib(n - 1) + fib(n - 2)", "    match n {\n       \
    \ 0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", " \
    \   let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let c = a\
    \ + b;\n        a = b;\n        b = c;\n    }\n    a", "    if n == 0 {\n    \
    \    0\n    } else if n == 1 {\n        1\n    } else {\n        fib(n - 1) +\
    \ fib(n - 2)\n    }", "    match n {\n        0 => 0,\n        1 => 1,\n     \
    \   n => fib(n - 1) + fib(n - 2),\n    }", "    if n < 2 {\n        return n;\n\
    \    }\n\n    let mut prev_prev = 0;\n    let mut prev = 1;\n    let mut current\
    \ = 0;\n\n    for _ in 2..=n {\n        current = prev + prev_prev;\n        prev_prev\
    \ = prev;\n        prev = current;\n    }\n\n    current", "    if n == 0 {\n\
    \        return 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    return\
    \ fib(n - 1) + fib(n - 2);", "    match n {\n        0 => 1,\n        1 => 1,\n\
    \        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n < 2 {\n        n\n \
    \   } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    let mut fib_n1 = 0;\n\
    \    let mut fib_n2 = 1;\n    let mut fib_n = 0;\n    for _ in 0..n {\n      \
    \  fib_n = fib_n1 + fib_n2;\n        fib_n1 = fib_n2;\n        fib_n2 = fib_n;\n\
    \    }\n    fib_n", "    if n < 0 {\n        panic!(\"Fibonacci number is not\
    \ defined for negative indices\");\n    }\n    let mut first = 0;\n    let mut\
    \ second = 1;\n    for _ in 0..n {\n        let tmp = first;\n        first =\
    \ second;\n        second = tmp + second;\n    }\n    first", "    if n == 0 {\n\
    \        return 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    fib(n\
    \ - 1) + fib(n - 2)", "    match n {\n        0 => 0,\n        1 => 1,\n     \
    \   _ => fib(n - 1) + fib(n - 2),\n    }", "    if n == 0 {\n        0\n    }\
    \ else if n == 1 {\n        1\n    } else {\n        fib(n - 1) + fib(n - 2)\n\
    \    }", "    match n {\n        0 => 1,\n        1 => 1,\n        _ => fib(n\
    \ - 1) + fib(n - 2),\n    }", "    match n {\n        0 => 1,\n        1 => 1,\n\
    \        n => fib(n - 1) + fib(n - 2),\n    }", "    if n < 2 {\n        n\n \
    \   } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    let mut a = 0;\n \
    \   let mut b = 1;\n    for _ in 0..n {\n        let tmp = a;\n        a = b;\n\
    \        b = tmp + b;\n    }\n    a", "    if n < 2 {\n        return n;\n   \
    \ }\n    return fib(n - 1) + fib(n - 2);", "  match n {\n    0 => 0,\n    1 =>\
    \ 1,\n    _ => fib(n - 1) + fib(n - 2),\n  }", "    // Base cases\n    if n ==\
    \ 0 {\n        return 0;\n    } else if n == 1 {\n        return 1;\n    }\n \
    \   // Recursive case\n    return fib(n - 1) + fib(n - 2);", "    if n == 0 {\n\
    \        0\n    } else if n == 1 {\n        1\n    } else {\n        fib(n - 1)\
    \ + fib(n - 2)\n    }", "    if n < 2 {\n        return n;\n    }\n    let mut\
    \ f0 = 0;\n    let mut f1 = 1;\n    for _ in 2..n + 1 {\n        let f2 = f0 +\
    \ f1;\n        f0 = f1;\n        f1 = f2;\n    }\n    f1", "    match n {\n  \
    \      0 => 0,\n        1 => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }",
  "  if n == 0 {\n    return 0;\n  }\n  let mut a = 0;\n  let mut b = 1;\n  for _\
    \ in 0..n-1 {\n    let c = a + b;\n    a = b;\n    b = c;\n  }\n  return b;",
  "    if n < 2 {\n        n\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }",
  "    if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1;\n\
    \    }\n    return fib(n - 1) + fib(n - 2);", "  let mut a = 0;\n  let mut b =\
    \ 1;\n  let mut tmp = 0;\n  for _ in 0..n {\n    tmp = a;\n    a = b;\n    b =\
    \ tmp + b;\n  }\n  a", "    if n < 2 {\n        n\n    } else {\n        fib(n\
    \ - 1) + fib(n - 2)\n    }", "    let mut a = 0;\n    let mut b = 1;\n    for\
    \ _ in 0..n {\n        let c = a + b;\n        a = b;\n        b = c;\n    }\n\
    \    a", "    let mut fib_n_2 = 0;\n    let mut fib_n_1 = 1;\n    let mut sum\
    \ = 0;\n    for _ in 1..n {\n        sum = fib_n_1 + fib_n_2;\n        fib_n_2\
    \ = fib_n_1;\n        fib_n_1 = sum;\n    }\n    sum", "    match n {\n      \
    \  0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", " \
    \   if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1;\n\
    \    }\n    fib(n - 1) + fib(n - 2)", "    match n {\n        0 => 0,\n      \
    \  1 => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }", "    let mut a = 0;\n\
    \    let mut b = 1;\n    for _ in 0..n {\n        let c = a + b;\n        a =\
    \ b;\n        b = c;\n    }\n    a", "    if n < 2 {\n        n\n    } else {\n\
    \        fib(n - 1) + fib(n - 2)\n    }", "    if n == 0 {\n        return 0;\n\
    \    } else if n == 1 {\n        return 1;\n    }\n    fib(n - 1) + fib(n - 2)",
  "    match n {\n        0 => 1,\n        1 => 1,\n        _ => fib(n - 1) + fib(n\
    \ - 2),\n    }", "  if n < 2 {\n    n\n  } else {\n    fib(n - 1) + fib(n - 2)\n\
    \  }", "    match n {\n        0 => 0,\n        1 => 1,\n        n => fib(n -\
    \ 1) + fib(n - 2),\n    }", "    let mut a = 0;\n    let mut b = 1;\n    for _\
    \ in 0..n {\n        let c = a + b;\n        a = b;\n        b = c;\n    }\n \
    \   a", "  if n < 2 { return n }\n  fib(n - 1) + fib(n - 2)", "    match n {\n\
    \        1 | 2 => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }", "    let\
    \ mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let c = a + b;\n\
    \        a = b;\n        b = c;\n    }\n    a", "    if n == 0 {\n        0\n\
    \    } else if n == 1 {\n        1\n    } else {\n        fib(n - 1) + fib(n -\
    \ 2)\n    }", "    match n {\n        0 => 1,\n        1 => 1,\n        _ => fib(n\
    \ - 1) + fib(n - 2),\n    }", "    if n < 2 {\n        n\n    } else {\n     \
    \   fib(n - 1) + fib(n - 2)\n    }", "    match n {\n        0 => 0,\n       \
    \ 1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    let mut a = 0;\n\
    \    let mut b = 1;\n    for _ in 0..n {\n        let c = a + b;\n        a =\
    \ b;\n        b = c;\n    }\n    a", '    fib_tco(n, 0, 1)', "    let mut fib1\
    \ = 0;\n    let mut fib2 = 1;\n    for _ in 0..n {\n        let fib = fib1 + fib2;\n\
    \        fib1 = fib2;\n        fib2 = fib;\n    }\n    fib1", '    fib2(1, 0,
    n)', "    if n < 2 {\n        return n;\n    }\n\n    let mut a = 0;\n    let\
    \ mut b = 1;\n    for _ in 2..n {\n        let t = a + b;\n        a = b;\n  \
    \      b = t;\n    }\n    b", "    match n {\n        0 => 0,\n        1 => 1,\n\
    \        _ => fib(n - 1) + fib(n - 2),\n    }", "    match n {\n        0 | 1\
    \ => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "  let mut a = 0;\n  let\
    \ mut b = 1;\n  for _ in 0..n {\n    let c = a + b;\n    a = b;\n    b = c;\n\
    \  }\n  a", "    match n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n\
    \ - 1) + fib(n - 2),\n    }", "    let mut fib_n_2 = 0;\n    let mut fib_n_1 =\
    \ 1;\n    let mut fib_n = 1;\n    for _ in 2..(n + 1) {\n        fib_n = fib_n_1\
    \ + fib_n_2;\n        fib_n_2 = fib_n_1;\n        fib_n_1 = fib_n;\n    }\n  \
    \  fib_n", "    if n == 0 {\n        return 0;\n    } else if n == 1 {\n     \
    \   return 1;\n    } else {\n        return fib(n - 1) + fib(n - 2);\n    }",
  "    let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let tmp =\
    \ a;\n        a = b;\n        b = tmp + b;\n    }\n    a", "    if n == 0 {\n\
    \        return 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    fib(n\
    \ - 1) + fib(n - 2)", "    if n == 0 {\n        return 0;\n    }\n    if n ==\
    \ 1 {\n        return 1;\n    }\n    fib(n - 1) + fib(n - 2)", "    let mut x\
    \ = (0, 1);\n    for _ in 0..n {\n        x = (x.1, x.0 + x.1);\n    }\n    x.0",
  "    if n < 0 {\n        panic!(\"n < 0\");\n    }\n    if n == 0 {\n        return\
    \ 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    let mut a = 0;\n \
    \   let mut b = 1;\n    for _ in 0..n - 1 {\n        let c = a + b;\n        a\
    \ = b;\n        b = c;\n    }\n    b", "    match n {\n        0 => 0,\n     \
    \   1 => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }", "  if n == 0 {\n \
    \   return 0;\n  }\n  if n == 1 {\n    return 1;\n  }\n  return fib(n - 1) + fib(n\
    \ - 2);", "    let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n     \
    \   let temp = a;\n        a = b;\n        b = temp + b;\n    }\n    a", "   \
    \ let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let tmp = a;\n\
    \        a = b;\n        b = tmp + b;\n    }\n    a", "    if n == 0 { return\
    \ 0; }\n    if n == 1 { return 1; }\n    return fib(n - 1) + fib(n - 2);", " \
    \   let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n        let c = a\
    \ + b;\n        a = b;\n        b = c;\n    }\n    a", "    if n < 2 {\n     \
    \   return n;\n    }\n    return fib(n - 1) + fib(n - 2);", "    if n < 0 {\n\
    \        panic!(\"Can't calculate Fibonacci number with negative index.\");\n\
    \    }\n\n    if n < 2 {\n        return n;\n    }\n\n    return fib(n - 1) +\
    \ fib(n - 2);", "    let mut a = 0;\n    let mut b = 1;\n    for _ in 0..n {\n\
    \        let c = a + b;\n        a = b;\n        b = c;\n    }\n    a", "  let\
    \ mut r: isize = 0;\n  let mut p: isize = 1;\n  for _ in 0..n {\n    r = r + p;\n\
    \    p = r - p;\n  }\n  r", "    if n < 1 {\n        0\n    } else if n == 1 {\n\
    \        1\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    match\
    \ n {\n        0 => 0,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n\
    \    }", "    match n {\n        0 => 0,\n        1 => 1,\n        n => fib(n\
    \ - 1) + fib(n - 2),\n    }", "    match n {\n        0 => 0,\n        1 => 1,\n\
    \        n => fib(n - 1) + fib(n - 2),\n    }", "    if n < 2 {\n        n\n \
    \   } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    let mut a = 0;\n \
    \   let mut b = 1;\n    for _ in 0..n {\n        let c = a + b;\n        a = b;\n\
    \        b = c;\n    }\n    a", "    match n {\n        0 => 1,\n        1 =>\
    \ 1,\n        n => fib(n - 1) + fib(n - 2),\n    }", "    if n == 0 {\n      \
    \  return 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    fib(n - 1)\
    \ + fib(n - 2)", "  if n == 0 {\n    return 0;\n  }\n  let mut prev = 0;\n  let\
    \ mut curr = 1;\n  for _ in 1..n {\n    let tmp = curr;\n    curr = prev + curr;\n\
    \    prev = tmp;\n  }\n  curr", "    match n {\n        0 => 0,\n        1 =>\
    \ 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "  if n < 2 {\n    n\n  }\
    \ else {\n    fib(n - 1) + fib(n - 2)\n  }", "    let mut a = 0;\n    let mut\
    \ b = 1;\n    for _ in 0..n {\n        let c = a + b;\n        a = b;\n      \
    \  b = c;\n    }\n    a", "    if n < 0 {\n        panic!(\"Negative fibonacci\
    \ is not defined\")\n    }\n    let mut a = 0;\n    let mut b = 1;\n    for _\
    \ in 0..n {\n        let c = a + b;\n        a = b;\n        b = c;\n    }\n \
    \   a", "    if n < 2 {\n        return n;\n    }\n\n    fib(n - 1) + fib(n -\
    \ 2)", "    match n {\n        0 | 1 => 1,\n        n => fib(n - 1) + fib(n -\
    \ 2),\n    }", "    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n\
    \    } else {\n        fib(n - 1) + fib(n - 2)\n    }", "    match n {\n     \
    \   0 => 1,\n        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", " \
    \   if n < 2 {\n        return n;\n    }\n    fib(n - 1) + fib(n - 2)", "    if\
    \ n < 2 {\n        return n;\n    }\n\n    let mut res = 0;\n    let mut a = 0;\n\
    \    let mut b = 1;\n\n    for _ in 0..n {\n        res = a + b;\n        a =\
    \ b;\n        b = res;\n    }\n\n    res", "    match n {\n        0 => 0,\n \
    \       1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    let mut prev\
    \ = 0;\n    let mut curr = 1;\n    let mut next = 0;\n    for _ in 0..n {\n  \
    \      next = prev + curr;\n        prev = curr;\n        curr = next;\n    }\n\
    \    prev", "    if n < 2 {\n        return n;\n    }\n    return fib(n - 1) +\
    \ fib(n - 2);", "    if n < 2 {\n        return n;\n    }\n\n    let mut f1 =\
    \ 0;\n    let mut f2 = 1;\n    let mut fib = f1 + f2;\n\n    for _ in 2..n {\n\
    \        f1 = f2;\n        f2 = fib;\n        fib = f1 + f2;\n    }\n\n    fib",
  "    match n {\n        0 => 1,\n        1 => 1,\n        _ => fib(n - 1) + fib(n\
    \ - 2),\n    }", "    if n < 2 {\n        return n;\n    }\n\n    fib(n - 1) +\
    \ fib(n - 2)", "    match n {\n        0 => 0,\n        1 => 1,\n        _ =>\
    \ fib(n - 1) + fib(n - 2),\n    }", "    let mut a = 0;\n    let mut b = 1;\n\
    \    for _ in 0..n {\n        let tmp = a;\n        a = b;\n        b = tmp +\
    \ b;\n    }\n    return a;", "    match n {\n        0 => 1,\n        1 => 1,\n\
    \        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n < 2 {\n        return\
    \ n;\n    }\n    fib(n - 1) + fib(n - 2)", "    if n < 2 {\n        n\n    } else\
    \ {\n        fib(n - 1) + fib(n - 2)\n    }", "    match n {\n        0 => 0,\n\
    \        1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n < 0\
    \ {\n        panic!(\"negative argument\")\n    }\n    if n == 0 {\n        0\n\
    \    } else if n == 1 {\n        1\n    } else {\n        fib(n - 1) + fib(n -\
    \ 2)\n    }", "    let mut last: isize = 0;\n    let mut prev: isize = 1;\n  \
    \  let mut x: isize = 0;\n    for _ in 1..n {\n        x = last + prev;\n    \
    \    last = prev;\n        prev = x;\n    }\n    x", "  let mut f0 = 0;\n  let\
    \ mut f1 = 1;\n  for _ in 0..n {\n    let f2 = f0 + f1;\n    f0 = f1;\n    f1\
    \ = f2;\n  }\n  f0", "    match n {\n        0 => 1,\n        1 => 1,\n      \
    \  _ => fib(n - 1) + fib(n - 2),\n    }", "    match n {\n        0 => 0,\n  \
    \      1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n < 0 {\n\
    \        panic!(\"{}\", n);\n    }\n    let mut a = 0;\n    let mut b = 1;\n \
    \   for _ in 0..n {\n        let t = a + b;\n        a = b;\n        b = t;\n\
    \    }\n    a", "    let mut a = 0;\n    let mut b = 1;\n    for _ in 1..n {\n\
    \        let tmp = a + b;\n        a = b;\n        b = tmp;\n    }\n    a", " \
    \   if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n\
    \        fib(n - 1) + fib(n - 2)\n    }", "    let mut a = 0;\n    let mut b =\
    \ 1;\n    for _ in 0..n {\n        let c = a + b;\n        a = b;\n        b =\
    \ c;\n    }\n    a", "    match n {\n        0 => 0,\n        1 => 1,\n      \
    \  _ => fib(n - 1) + fib(n - 2),\n    }", "    match n {\n        0 => 1,\n  \
    \      1 => 1,\n        _ => fib(n - 1) + fib(n - 2),\n    }", "    if n == 0\
    \ {\n        return 0;\n    } else if n == 1 {\n        return 1;\n    }\n   \
    \ return fib(n - 1) + fib(n - 2);", "    if n == 0 {\n        0\n    } else if\
    \ n == 1 {\n        1\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }",
  "    match n {\n        0 => 1,\n        1 => 1,\n        x => fib(x - 1) + fib(x\
    \ - 2),\n    }", "    match n {\n        0 => 0,\n        1 => 1,\n        _ =>\
    \ fib(n - 1) + fib(n - 2),\n    }", "  // let &mut (ref mut i, ref mut acc) =\
    \ &mut (n, 0);\n  // let &mut (ref mut i, ref mut acc) = &mut (n, 1);\n  let mut\
    \ i = n;\n  let mut acc = 0;\n  while i > 0 {\n    let mut tmp = acc;\n    acc\
    \ = acc + i;\n    i = i - 1;\n    i = tmp;\n  }\n  return acc;", "    if n < 2\
    \ {\n        return n;\n    }\n    return fib(n - 1) + fib(n - 2);", "    if n\
    \ == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n       \
    \ fib(n - 1) + fib(n - 2)\n    }", "    let mut n0 = 0;\n    let mut n1 = 1;\n\
    \    for _ in 0..n {\n        let next = n0 + n1;\n        n0 = n1;\n        n1\
    \ = next;\n    }\n    n0"]
stop_tokens:
- "\n}"
