language: rs
name: HumanEval_112_reverse_delete
results:
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let c = c.chars().collect::<HashSet<_>>();\n\
    \    let s = s.chars().filter(|&x| !c.contains(&x)).collect::<String>();\n   \
    \ (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpb0hgoesn.rs:8:33\n\
    \  |\n8 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let reversed_string = s.chars().rev().collect::<String>();\n\
    \    let filtered_string = reversed_string.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    (filtered_string, filtered_string == s)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `filtered_string`\n  --> /tmp/tmpp4ylue0d.rs:10:23\n\
    \   |\n9  |     let filtered_string = reversed_string.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         --------------- move occurs because `filtered_string` has type `String`,\
    \ which does not implement the `Copy` trait\n10 |     (filtered_string, filtered_string\
    \ == s)\n   |      ---------------  ^^^^^^^^^^^^^^^ value borrowed here after\
    \ move\n   |      |\n   |      value moved here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res: String = String::new();\n\
    \    let mut v: Vec<_> = s.chars().collect();\n    let mut n: usize = v.len();\n\
    \    let mut c_chars: Vec<_> = c.chars().collect();\n    let c_set: HashSet<_>\
    \ = c_chars.drain(..).collect();\n    //println!(\"{:?}\",c_set);\n    for i in\
    \ 0..n {\n        if !c_set.contains(&v[i]) {\n            res.push(v[i]);\n \
    \       }\n    }\n    let res_string: String = res.clone();\n    let mut v: Vec<_>\
    \ = res.chars().collect();\n    let mut n: usize = v.len();\n    for i in 0..n/2\
    \ {\n        if v[i] != v[n-i-1] {\n            return (res_string, false);\n\
    \        }\n    }\n    (res_string, true)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpiu44zljl.rs:12:16\n\
    \   |\n12 |     let c_set: HashSet<_> = c_chars.drain(..).collect();\n   |   \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.into_bytes().into_iter().filter(|&x|\
    \ !c.contains(x as char)).collect(), false)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `u8`\n --> /tmp/tmpq_cclf6y.rs:8:69\n  |\n8 |     (s.into_bytes().into_iter().filter(|&x|\
    \ !c.contains(x as char)).collect(), false)\n  |                             \
    \                                        ^^^^^^^ value of type `String` cannot\
    \ be built from `std::iter::Iterator<Item=u8>`\n  |\n  = help: the trait `FromIterator<u8>`\
    \ is not implemented for `String`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let p = res.chars().rev().collect::<String>()\
    \ == res;\n    (res, p)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut removed = 0;\n    for ch in s.chars() {\n        if !c.contains(ch)\
    \ {\n            result.push(ch);\n        } else {\n            removed += 1;\n\
    \        }\n    }\n    if removed == 0 {\n        return (result, true);\n   \
    \ }\n    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmphxz29bv1.rs:20:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n20 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    let c_chars: Vec<char> = c.chars().collect();\n    chars.retain(|&e| !c_chars.contains(&e));\n\
    \    let mut s_rev = chars.clone();\n    s_rev.reverse();\n    (chars.into_iter().collect(),\
    \ s_rev == chars)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n   \
    \ assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `chars`\n   --> /tmp/tmpx7u4hcjv.rs:13:44\n\
    \    |\n8   |     let mut chars: Vec<char> = s.chars().collect();\n    |     \
    \    --------- move occurs because `chars` has type `Vec<char>`, which does not\
    \ implement the `Copy` trait\n...\n13  |     (chars.into_iter().collect(), s_rev\
    \ == chars)\n    |            -----------                     ^^^^^ value borrowed\
    \ here after move\n    |            |\n    |            `chars` moved due to this\
    \ method call\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `chars`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let s_len = s.len();\n    let\
    \ s_half = s_len / 2;\n    let mut result = String::new();\n    let mut s_idx\
    \ = 0;\n    let mut c_idx = 0;\n    let mut found = false;\n    let mut is_palindrome\
    \ = true;\n    while s_idx < s_len && c_idx < c.len() {\n        if s[s_idx] !=\
    \ c[c_idx] {\n            result.push(s[s_idx]);\n            s_idx += 1;\n  \
    \      } else {\n            found = true;\n            s_idx += 1;\n        }\n\
    \        if found {\n            c_idx += 1;\n            found = false;\n   \
    \     }\n    }\n    while s_idx < s_len {\n        result.push(s[s_idx]);\n  \
    \      s_idx += 1;\n    }\n    if s_len % 2 == 0 {\n        for i in 0..s_half\
    \ {\n            if result.chars().nth(i) != result.chars().nth(s_len - i - 1)\
    \ {\n                is_palindrome = false;\n                break;\n        \
    \    }\n        }\n    } else {\n        for i in 0..s_half {\n            if\
    \ result.chars().nth(i) != result.chars().nth(s_len - i - 1) {\n             \
    \   is_palindrome = false;\n                break;\n            }\n        }\n\
    \    }\n    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"cdedcba\", false)`,\n right: `(\"cdedc\", true)`', /tmp/tmpk317446m.rs:56:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = s;\n    for c in\
    \ c.chars() {\n        result = result.replace(c, \"\");\n    }\n    let is_palindrome\
    \ = result.chars().eq(result.chars().rev());\n    (result, is_palindrome)\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut index = 0;\n    let\
    \ mut last_index = 0;\n    while index < s.len() {\n        if c.contains(&s[index])\
    \ {\n            s.remove(index);\n            if index != 0 {\n             \
    \   index -= 1;\n            }\n        } else {\n            index += 1;\n  \
    \          last_index = index;\n        }\n    }\n    (s[..last_index].iter().collect(),\
    \ s.iter().eq(s.iter().rev()))\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut str: String = String::new();\n\
    \    let mut is_palindrome: bool = true;\n    for i in s.chars() {\n        if\
    \ !c.contains(i) {\n            str.push(i);\n        }\n    }\n    let l: usize\
    \ = str.len();\n    for i in 0..l / 2 {\n        if str.chars().nth(i) != str.chars().nth(l\
    \ - i - 1) {\n            is_palindrome = false;\n            break;\n       \
    \ }\n    }\n    (str, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|x| !c.contains(*x))\n            .collect::<String>(),\n        s.chars()\n\
    \            .filter(|x| !c.contains(*x))\n            .collect::<String>()\n\
    \            .eq_ignore_ascii_case(&s.chars().filter(|x| !c.contains(*x)).rev().collect::<String>()),\n\
    \    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let c = c.chars().collect::<HashSet<_>>();\n\
    \    s.retain(|x| !c.contains(&x));\n    (s, s.is_empty() || s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpbzmtogte.rs:9:33\n\
    \  |\n9 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|n| !c.contains(n));\n\
    \    (s.iter().collect(), s.iter().eq(s.iter().rev()))\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut _s = s.clone();\n    for\
    \ i in c.chars() {\n        _s = _s.replace(i, \"\");\n    }\n    (_s, _s == _s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `_s`\n  --> /tmp/tmpf0g15dob.rs:12:10\n\
    \   |\n8  |     let mut _s = s.clone();\n   |         ------ move occurs because\
    \ `_s` has type `String`, which does not implement the `Copy` trait\n...\n12 |\
    \     (_s, _s == _s.chars().rev().collect::<String>())\n   |      --  ^^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result: String = String::new();\n\
    \    for character in s.chars() {\n        if !c.contains(character) {\n     \
    \       result.push(character);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpmg25tm85.rs:14:14\n\
    \   |\n8  |     let mut result: String = String::new();\n   |         ----------\
    \ move occurs because `result` has type `String`, which does not implement the\
    \ `Copy` trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let valid_chars = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let string_len = valid_chars.len();\n\
    \    let mut valid_chars = valid_chars.chars().collect::<Vec<char>>();\n    let\
    \ is_palindrome = (0..string_len / 2).all(|x| valid_chars[x] == valid_chars[string_len\
    \ - x - 1]);\n    valid_chars.shrink_to_fit();\n    (valid_chars.into_iter().collect(),\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut r = s.clone();\n    r.retain(|x|\
    \ !c.contains(x));\n    (r, r == r.chars().rev().collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `r`\n  --> /tmp/tmp3andptoo.rs:10:9\n\
    \   |\n8  |     let mut r = s.clone();\n   |         ----- move occurs because\
    \ `r` has type `String`, which does not implement the `Copy` trait\n9  |     r.retain(|x|\
    \ !c.contains(x));\n10 |     (r, r == r.chars().rev().collect::<String>())\n \
    \  |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut out: String = String::new();\n\
    \    let mut last: String = String::new();\n    for mut ch in s.chars() {\n  \
    \      if !c.contains(ch) {\n            out.push(ch);\n            last.push(ch);\n\
    \        }\n    }\n    last.pop();\n    (out, &out == &last.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpzbdxmg40.rs:10:9\n\
    \   |\n10 |     for mut ch in s.chars() {\n   |         ----^^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `out`\n  --> /tmp/tmpzbdxmg40.rs:17:11\n\
    \   |\n8  |     let mut out: String = String::new();\n   |         ------- move\
    \ occurs because `out` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (out, &out == &last.chars().rev().collect::<String>())\n\
    \   |      ---  ^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let letters: Vec<char> = s.chars().filter(|x|\
    \ !c.contains(x)).collect();\n    let result = letters.iter().collect::<String>();\n\
    \    let palindrome = letters.iter().eq(letters.iter().rev());\n    (result, palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpvymnwqvl.rs:8:63\n\
    \  |\n8 |     let letters: Vec<char> = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \  |                                                               ^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n  = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n  = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result: String = s;\n  \
    \  for x in c.chars() {\n        result = result.chars().filter(|&ch| ch != x).collect();\n\
    \    }\n    (result, result == result.chars().rev().collect())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpm0p0tx3x.rs:12:21\n\
    \   |\n12 |     (result, result == result.chars().rev().collect())\n   |     \
    \                ^^ cannot infer type\n   |\n   = note: cannot satisfy `String:\
    \ PartialEq<_>`\nhelp: consider specifying the type argument in the method call\n\
    \   |\n12 |     (result, result == result.chars().rev().collect::<B>())\n   |\
    \                                                    +++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    s.retain(|&i| !c.contains(i));\n    (s.iter().collect(), s.iter().eq(s.iter().rev()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut chars = s.chars();\n    while let Some(i) = chars.next() {\n    \
    \    if !c.contains(i) {\n            result.push(i);\n        }\n    }\n    let\
    \ reversed = String::from(result.chars().rev().collect::<String>());\n    (result,\
    \ result == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmplkw9buml.rs:16:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n16 |     (result, result == reversed)\n   |      ------  ^^^^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let res = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n --> /tmp/tmp6049s7tj.rs:9:11\n\
    \  |\n8 |     let res = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         --- move occurs because `res` has type `String`, which does not implement\
    \ the `Copy` trait\n9 |     (res, res == res.chars().rev().collect::<String>())\n\
    \  |      ---  ^^^ value borrowed here after move\n  |      |\n  |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result: String = String::new();\n\
    \    let mut is_palindrome: bool = true;\n    for ch in s.chars() {\n        if\
    \ !c.contains(ch) {\n            result.push(ch);\n        }\n    }\n    let s_len\
    \ = result.len();\n    for i in 0..s_len / 2 {\n        if result.chars().nth(i)\
    \ != result.chars().nth(s_len - i - 1) {\n            is_palindrome = false;\n\
    \            break;\n        }\n    }\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result: String = s;\n  \
    \  for d in c.chars() {\n        result = result.replace(d, \"\");\n    }\n  \
    \  (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp8uz4zhgm.rs:12:14\n\
    \   |\n8  |     let mut result: String = s;\n   |         ---------- move occurs\
    \ because `result` has type `String`, which does not implement the `Copy` trait\n\
    ...\n12 |     (result, result == result.chars().rev().collect::<String>())\n \
    \  |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |   \
    \   value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for c in s.chars() {\n        if !c.is_whitespace() && !c.is_ascii_punctuation()\
    \ && !c.is_control() && !c.is_ascii_digit() && !c.is_ascii_alphanumeric() {\n\
    \            res.push(c);\n        }\n    }\n    let res = res.replace(|c: char|\
    \ c.is_alphanumeric(), \"\");\n    (res, res.eq_ignore_ascii_case(&res.chars().rev().collect::<String>()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `c`\n --> /tmp/tmpi3wr0nv1.rs:7:30\n  |\n7 |\
    \ fn reverse_delete(s: String, c: String) -> (String, bool) {\n  |           \
    \                   ^ help: if this is intentional, prefix it with an underscore:\
    \ `_c`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `res`\n    --> /tmp/tmpi3wr0nv1.rs:15:11\n     |\n14\
    \   |     let res = res.replace(|c: char| c.is_alphanumeric(), \"\");\n     |\
    \         --- move occurs because `res` has type `String`, which does not implement\
    \ the `Copy` trait\n15   |     (res, res.eq_ignore_ascii_case(&res.chars().rev().collect::<String>()))\n\
    \     |      ---  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n     |      |\n     |      value moved here\n\
    \     |\n     = note: borrow occurs due to deref coercion to `str`\nnote: deref\
    \ defined here\n\nerror: aborting due to previous error; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let f = |s: char| {\n        c.find(s).is_none()\n\
    \    };\n    let s: String = s.chars().filter(f).collect();\n    let b = s.chars().zip(s.chars().rev()).all(|(a,\
    \ b)| a == b);\n    (s, b)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0631]: type mismatch in closure arguments\n  --> /tmp/tmpqljj268k.rs:11:38\n\
    \   |\n8  |     let f = |s: char| {\n   |             --------- found signature\
    \ of `fn(char) -> _`\n...\n11 |     let s: String = s.chars().filter(f).collect();\n\
    \   |                                      ^ expected signature of `for<'r> fn(&'r\
    \ char) -> _`\n\nerror[E0599]: the method `collect` exists for struct `Filter<Chars<'_>,\
    \ [closure@/tmp/tmpqljj268k.rs:8:13: 10:6]>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpqljj268k.rs:11:41\n   |\n8  |       let f = |s: char| {\n   | \
    \              ---------\n   |               |\n   |               doesn't satisfy\
    \ `<_ as FnOnce<(&char,)>>::Output = bool`\n   |               doesn't satisfy\
    \ `_: FnMut<(&char,)>`\n...\n11 |       let s: String = s.chars().filter(f).collect();\n\
    \   |                                           ^^^^^^^ method cannot be called\
    \ on `Filter<Chars<'_>, [closure@/tmp/tmpqljj268k.rs:8:13: 10:6]>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<[closure@/tmp/tmpqljj268k.rs:8:13: 10:6] as FnOnce<(&char,)>>::Output\
    \ = bool`\n           which is required by `Filter<Chars<'_>, [closure@/tmp/tmpqljj268k.rs:8:13:\
    \ 10:6]>: Iterator`\n           `[closure@/tmp/tmpqljj268k.rs:8:13: 10:6]: FnMut<(&char,)>`\n\
    \           which is required by `Filter<Chars<'_>, [closure@/tmp/tmpqljj268k.rs:8:13:\
    \ 10:6]>: Iterator`\n           `Filter<Chars<'_>, [closure@/tmp/tmpqljj268k.rs:8:13:\
    \ 10:6]>: Iterator`\n           which is required by `&mut Filter<Chars<'_>, [closure@/tmp/tmpqljj268k.rs:8:13:\
    \ 10:6]>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0631.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let c: Vec<char> = c.chars().collect();\n\
    \    let s: Vec<char> = s.chars().filter(|&x| !c.contains(&x)).collect();\n  \
    \  let s_rev: Vec<char> = s.iter().rev().map(|&x| x).collect();\n    (s.iter().cloned().collect(),\
    \ s == s_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let new_s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    (new_s, is_palindrome(&new_s))\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n -->\
    \ /tmp/tmpkhmz93np.rs:9:13\n  |\n9 |     (new_s, is_palindrome(&new_s))\n  | \
    \            ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp_su29ggc.rs:8:46\n\
    \  |\n8 |     let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                              ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let is_palindrome = s.chars().zip(s.chars().rev()).all(|(l,\
    \ r)| l == r);\n    let s: String = s.chars().filter(|&x| !c.contains(x)).collect();\n\
    \    (s, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"abba\", false)`,\n right: `(\"abba\", true)`', /tmp/tmpods3vyk2.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let mut reversed_result = String::new();\n    for ch in\
    \ result.chars().rev() {\n        reversed_result.push(ch);\n    }\n    (result,\
    \ result == reversed_result)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpplax006r.rs:18:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n18 |     (result, result == reversed_result)\n   |      ------ \
    \ ^^^^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut r: String = String::new();\n\
    \    for b in s.bytes() {\n        if !c.contains(char::from(b)) {\n         \
    \   r.push(char::from(b));\n        }\n    }\n    (r, r == r.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `r`\n  --> /tmp/tmpuryq2n3e.rs:14:9\n\
    \   |\n8  |     let mut r: String = String::new();\n   |         ----- move occurs\
    \ because `r` has type `String`, which does not implement the `Copy` trait\n...\n\
    14 |     (r, r == r.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmph1dsgock.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let str = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    let rev_str = str.chars().rev().collect::<String>();\n    (str, str == rev_str)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpe5oq64av.rs:8:48\n\
    \  |\n8 |     let str = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut r: String = s.chars().filter(|x|\
    \ !c.contains(x)).collect();\n    (r, r == r.chars().rev().collect())\n}\n\nfn\
    \ main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpoamdgc5q.rs:8:58\n\
    \  |\n8 |     let mut r: String = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \  |                                                          ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c in c.chars()\
    \ {\n        s = s.replace(c, \"\");\n    }\n    let l = s.len();\n    let mut\
    \ half = l / 2;\n    if l % 2 == 1 {\n        half += 1;\n    }\n    let left\
    \ = &s[..half];\n    let right = &s[l - half..];\n    (left.to_string(), left\
    \ == right.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"bc\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmpp79rgmoh.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmph1dsgock.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let is_palindrome = {\n        let\
    \ iter = s.chars();\n        iter.eq(iter.rev())\n    };\n    (\n        s.chars()\n\
    \            .filter(|&ch| !c.contains(ch))\n            .collect::<String>(),\n\
    \        is_palindrome,\n    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `iter`\n  --> /tmp/tmp0m2rqlis.rs:10:17\n\
    \   |\n9  |         let iter = s.chars();\n   |             ---- move occurs because\
    \ `iter` has type `Chars<'_>`, which does not implement the `Copy` trait\n10 |\
    \         iter.eq(iter.rev())\n   |         ----    ^^^^ value used here after\
    \ move\n   |         |\n   |         value moved here\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut removed = String::from(\"\
    \");\n    let mut is_palindrome = true;\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    for x in chars.clone() {\n        if !c.contains(x) {\n            removed.push(x);\n\
    \        }\n    }\n    chars.reverse();\n    for (i, x) in chars.iter().enumerate()\
    \ {\n        if !c.contains(x) {\n            if x != &removed.chars().nth(i).unwrap()\
    \ {\n                is_palindrome = false;\n                break;\n        \
    \    }\n        }\n    }\n    (removed, is_palindrome)\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpik7qm8_3.rs:18:24\n\
    \   |\n18 |         if !c.contains(x) {\n   |                        ^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut arr: Vec<_> = s.chars().collect();\n\
    \    let mut ptr = 0;\n    for i in 0..arr.len() {\n        if !c.contains(arr[i])\
    \ {\n            arr[ptr] = arr[i];\n            ptr += 1;\n        }\n    }\n\
    \    arr.truncate(ptr);\n    let left = &arr[..ptr / 2];\n    let right = &arr[ptr\
    \ - ptr / 2..];\n    (\n        arr.iter().collect(),\n        left.iter().eq(right.iter().rev()),\n\
    \    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|ch| !c.contains(*ch)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n --> /tmp/tmpb9v1ye3i.rs:9:9\n\
    \  |\n8 |     let s = s.chars().filter(|ch| !c.contains(*ch)).collect::<String>();\n\
    \  |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n9 |     (s, s == s.chars().rev().collect::<String>())\n  |\
    \      -  ^ value borrowed here after move\n  |      |\n  |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut chars = s.chars();\n    while let Some(ch) = chars.next() {\n   \
    \     if !c.contains(ch) {\n            result.push(ch);\n        }\n    }\n \
    \   (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp6zm7n596.rs:15:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n15 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res: String = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            res.push(ch);\n\
    \        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpbgnxudtk.rs:14:11\n\
    \   |\n8  |     let mut res: String = String::new();\n   |         ------- move\
    \ occurs because `res` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (res, res == res.chars().rev().collect::<String>())\n \
    \  |      ---  ^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<Vec<_>>();\n    let mut v = s.clone();\n    for\
    \ (i, x) in s.iter().enumerate() {\n        if c.contains(x) {\n            v.remove(i);\n\
    \        }\n    }\n    (v.iter().collect(), v == v.iter().rev().collect())\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpty8dvskk.rs:16:28\n\
    \   |\n16 |     (v.iter().collect(), v == v.iter().rev().collect())\n   |    \
    \                        ^^ cannot infer type\n   |\n   = note: cannot satisfy\
    \ `Vec<char>: PartialEq<_>`\nhelp: consider specifying the type argument in the\
    \ method call\n   |\n16 |     (v.iter().collect(), v == v.iter().rev().collect::<B>())\n\
    \   |                                                     +++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let chars: HashSet<char> = c.chars().collect();\n\
    \    let mut filtered: String = s.chars().filter(|x| !chars.contains(x)).collect();\n\
    \    let is_palindrome = filtered == filtered.chars().rev().collect::<String>();\n\
    \    (filtered, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmp6y6pvvsk.rs:8:16\n\
    \  |\n8 |     let chars: HashSet<char> = c.chars().collect();\n  |           \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let c: HashSet<char> = c.chars().collect();\n\
    \    let s: String = s.chars().filter(|x| !c.contains(x)).collect();\n    (s,\
    \ s.eq_ignore_ascii_case(&s.chars().rev().collect::<String>()))\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmprmh5lunb.rs:8:12\n\
    \  |\n8 |     let c: HashSet<char> = c.chars().collect();\n  |            ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.chars().filter(|x| !c.contains(x)).collect::<String>(),\
    \ s.chars().filter(|x| !c.contains(x)).eq(s.chars().filter(|x| !c.contains(x)).rev()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpav1_1ios.rs:8:39\n\
    \  |\n8 |     (s.chars().filter(|x| !c.contains(x)).collect::<String>(), s.chars().filter(|x|\
    \ !c.contains(x)).eq(s.chars().filter(|x| !c.contains(x...\n  |              \
    \                         ^ expected an `Fn<(char,)>` closure, found `char`\n\
    \  |\n  = help: the trait `Fn<(char,)>` is not implemented for `char`\n  = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \  = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n -->\
    \ /tmp/tmpav1_1ios.rs:8:97\n  |\n8 | ...ring>(), s.chars().filter(|x| !c.contains(x)).eq(s.chars().filter(|x|\
    \ !c.contains(x)).rev()))\n  |                                              ^\
    \ expected an `Fn<(char,)>` closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n  = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n  = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpav1_1ios.rs:8:137\n  |\n\
    8 | ...s(x)).eq(s.chars().filter(|x| !c.contains(x)).rev()))\n  |            \
    \                                  ^ expected an `Fn<(char,)>` closure, found\
    \ `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut str = s.clone();\n    let\
    \ mut del = Vec::new();\n    for i in 0..str.len() {\n        for j in 0..c.len()\
    \ {\n            if str.chars().nth(i).unwrap() == c.chars().nth(j).unwrap() {\n\
    \                del.push(i);\n            }\n        }\n    }\n    del.reverse();\n\
    \    for i in del {\n        str.remove(i);\n    }\n    let mut s: String = String::new();\n\
    \    for i in 0..str.len() {\n        s.push(str.chars().nth(i).unwrap());\n \
    \   }\n    (s, is_palindrome(s))\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp_nl4blut.rs:25:9\n   |\n25 |     (s, is_palindrome(s))\n   |       \
    \  ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp_su29ggc.rs:8:46\n\
    \  |\n8 |     let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                              ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let chars = c.chars().collect::<Vec<char>>();\n    for ch in s.chars() {\n\
    \        if !chars.contains(&ch) {\n            result.push(ch);\n        }\n\
    \    }\n    let ans = result.clone();\n    ans.chars().eq(result.chars().rev())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo8a65u70.rs:16:5\n   |\n\
    7  | fn reverse_delete(s: String, c: String) -> (String, bool) {\n   |       \
    \                                     -------------- expected `(String, bool)`\
    \ because of return type\n...\n16 |     ans.chars().eq(result.chars().rev())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found `bool`\n\
    \   |\n   = note: expected tuple `(String, bool)`\n               found type `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let filtered_s: String = s.chars().filter(|&x|\
    \ !c.contains(x)).collect();\n    (filtered_s, filtered_s == filtered_s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `filtered_s`\n --> /tmp/tmpr2y5uz79.rs:9:18\n\
    \  |\n8 |     let filtered_s: String = s.chars().filter(|&x| !c.contains(x)).collect();\n\
    \  |         ---------- move occurs because `filtered_s` has type `String`, which\
    \ does not implement the `Copy` trait\n9 |     (filtered_s, filtered_s == filtered_s.chars().rev().collect::<String>())\n\
    \  |      ----------  ^^^^^^^^^^ value borrowed here after move\n  |      |\n\
    \  |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s_chars: Vec<char> = s.chars().collect();\n\
    \    let mut unique_s_chars: Vec<char> = Vec::new();\n    let c_chars: Vec<char>\
    \ = c.chars().collect();\n    let mut i = 0;\n    let mut j = 0;\n    while i\
    \ < s_chars.len() {\n        if !c_chars.contains(&s_chars[i]) {\n           \
    \ unique_s_chars.push(s_chars[i]);\n        }\n        i += 1;\n    }\n    let\
    \ mut unique_s_chars_reversed: Vec<char> = Vec::new();\n    while j < unique_s_chars.len()\
    \ {\n        unique_s_chars_reversed.push(unique_s_chars[unique_s_chars.len()\
    \ - 1 - j]);\n        j += 1;\n    }\n    if unique_s_chars == unique_s_chars_reversed\
    \ {\n        return (unique_s_chars.into_iter().collect(), true);\n    } else\
    \ {\n        return (unique_s_chars.into_iter().collect(), false);\n    }\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut filtered_s = s.clone();\n\
    \    for char in c.chars() {\n        filtered_s = filtered_s.chars().filter(|x|\
    \ x != &char).collect();\n    }\n    let is_palindrome = filtered_s.clone() ==\
    \ filtered_s.chars().rev().collect();\n    (filtered_s, is_palindrome)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpz_fxqu5_.rs:12:44\n\
    \   |\n12 |     let is_palindrome = filtered_s.clone() == filtered_s.chars().rev().collect();\n\
    \   |                                            ^^ cannot infer type\n   |\n\
    \   = note: cannot satisfy `String: PartialEq<_>`\nhelp: consider specifying the\
    \ type argument in the method call\n   |\n12 |     let is_palindrome = filtered_s.clone()\
    \ == filtered_s.chars().rev().collect::<B>();\n   |                          \
    \                                                     +++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    return (result, result == result.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmprw_tbvc6.rs:14:21\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     return (result, result == result.chars().rev().collect::<String>());\n\
    \   |             ------  ^^^^^^ value borrowed here after move\n   |        \
    \     |\n   |             value moved here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let c = c.chars().collect::<HashSet<_>>();\n\
    \    let s = s.chars().filter(|&s| !c.contains(&s)).collect::<String>();\n   \
    \ (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpfd286pso.rs:8:33\n\
    \  |\n8 |     let c = c.chars().collect::<HashSet<_>>();\n  |                \
    \                 ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut ret = String::new();\n \
    \   for i in s.chars() {\n        if !c.contains(i) {\n            ret.push(i);\n\
    \        }\n    }\n    return (ret, ret == ret.chars().rev().collect::<String>());\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `ret`\n  --> /tmp/tmpwrbzz4on.rs:14:18\n\
    \   |\n8  |     let mut ret = String::new();\n   |         ------- move occurs\
    \ because `ret` has type `String`, which does not implement the `Copy` trait\n\
    ...\n14 |     return (ret, ret == ret.chars().rev().collect::<String>());\n  \
    \ |             ---  ^^^ value borrowed here after move\n   |             |\n\
    \   |             value moved here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let clean_s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let result = clean_s.chars().zip(clean_s.chars().rev()).all(|(a,\
    \ b)| a == b);\n    (clean_s, result)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmphb950fa3.rs:8:52\n\
    \  |\n8 |     let clean_s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                    ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.replace(&c, \"\"), s.replace(&c,\
    \ \"\").eq_ignore_ascii_case(&s.replace(&c, \"\").chars().rev().collect::<String>()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"abcde\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmp9x0mm7sv.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut reversed = String::new();\n    let mut s_chars = s.chars();\n   \
    \ let mut c_chars = c.chars();\n    let mut s_string = String::new();\n    let\
    \ mut c_string = String::new();\n    for i in s_chars {\n        s_string.push(i);\n\
    \    }\n    for i in c_chars {\n        c_string.push(i);\n    }\n    let mut\
    \ test_counter = 0;\n    for _i in 0..s_string.len() {\n        if test_counter\
    \ == 0 {\n            for _j in 0..c_string.len() {\n                if s_string.pop().unwrap()\
    \ == c_string.pop().unwrap() {\n                    test_counter += 1;\n     \
    \           }\n            }\n        }\n    }\n    let mut s_chars = s.chars();\n\
    \    for i in s_chars {\n        result.push(i);\n    }\n    if test_counter ==\
    \ 0 {\n        (result, true)\n    } else {\n        (result, false)\n    }\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"abcde\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmpuyazc0tx.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for c in s.chars() {\n        if !c.is_alphanumeric() {\n            continue;\n\
    \        }\n        if !c.is_lowercase() || !c.is_uppercase() {\n            continue;\n\
    \        }\n        if c.is_digit(10) || c.is_whitespace() {\n            continue;\n\
    \        }\n        res.push(c);\n    }\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `c`\n --> /tmp/tmptixuhtq6.rs:7:30\n  |\n7 |\
    \ fn reverse_delete(s: String, c: String) -> (String, bool) {\n  |           \
    \                   ^ help: if this is intentional, prefix it with an underscore:\
    \ `_c`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `res`\n  --> /tmp/tmptixuhtq6.rs:21:11\n   |\n8  |  \
    \   let mut res = String::new();\n   |         ------- move occurs because `res`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n21 |    \
    \ (res, res == res.chars().rev().collect::<String>())\n   |      ---  ^^^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for c in s.chars() {\n        if !c.is_ascii_digit() && !c.is_ascii_alphabetic()\
    \ {\n            continue;\n        }\n        if !c.is_ascii_alphabetic() {\n\
    \            res.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            res.push(c);\n        }\n    }\n    let mut r =\
    \ String::new();\n    for c in res.chars() {\n        if !c.is_ascii_digit() &&\
    \ !c.is_ascii_alphabetic() {\n            continue;\n        }\n        if !c.is_ascii_alphabetic()\
    \ {\n            r.push(c.to_lowercase().to_string().chars().next().unwrap());\n\
    \        } else {\n            r.push(c);\n        }\n    }\n    (r, res == r.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `c`\n --> /tmp/tmpd2reag3m.rs:7:30\n  |\n7 |\
    \ fn reverse_delete(s: String, c: String) -> (String, bool) {\n  |           \
    \                   ^ help: if this is intentional, prefix it with an underscore:\
    \ `_c`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `r`\n    --> /tmp/tmpd2reag3m.rs:30:16\n     |\n19  \
    \ |     let mut r = String::new();\n     |         ----- move occurs because `r`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n30   |  \
    \   (r, res == r.chars().rev().collect::<String>())\n     |      -         ^^^^^^^^^\
    \ value borrowed here after move\n     |      |\n     |      value moved here\n\
    \     |\n     = note: borrow occurs due to deref coercion to `str`\nnote: deref\
    \ defined here\n\nerror: aborting due to previous error; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    s.retain(|ch| !c.contains(ch));\n    let s = s.iter().collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp8txgr8dv.rs:9:31\n\
    \  |\n9 |     s.retain(|ch| !c.contains(ch));\n  |                           \
    \    ^^ expected an `Fn<(char,)>` closure, found `char`\n  |\n  = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n  = note: required because of the\
    \ requirements on the impl of `FnOnce<(char,)>` for `&char`\n  = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let s_len = s.len();\n    let\
    \ c_len = c.len();\n    let mut t = String::new();\n    let mut count = 0;\n \
    \   for i in 0..s_len {\n        let mut flag = false;\n        for j in 0..c_len\
    \ {\n            if s[i] == c[j] {\n                flag = true;\n           \
    \     break;\n            }\n        }\n        if !flag {\n            t.push(s[i]);\n\
    \            count += 1;\n        }\n    }\n    let mut t_vec: Vec<char> = t.chars().collect();\n\
    \    let mut is_palindrome = true;\n    for i in 0..count / 2 {\n        if t_vec[i]\
    \ != t_vec[count - i - 1] {\n            is_palindrome = false;\n            break;\n\
    \        }\n    }\n    (t, is_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let is_palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s_vec: Vec<char> = s.chars().collect();\n\
    \    let c_vec: Vec<char> = c.chars().collect();\n    let mut tmp_vec: Vec<char>\
    \ = Vec::new();\n    let mut index = 0;\n    while index < s_vec.len() {\n   \
    \     if c_vec.contains(&s_vec[index]) {\n            s_vec.remove(index);\n \
    \       } else {\n            index += 1;\n        }\n    }\n    for i in 0..s_vec.len()\
    \ {\n        tmp_vec.push(s_vec[s_vec.len() - i - 1]);\n    }\n    (s_vec.into_iter().collect(),\
    \ s_vec == tmp_vec)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n \
    \   assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s_vec`\n   --> /tmp/tmpvv00f3hc.rs:22:35\n\
    \    |\n8   |     let mut s_vec: Vec<char> = s.chars().collect();\n    |     \
    \    --------- move occurs because `s_vec` has type `Vec<char>`, which does not\
    \ implement the `Copy` trait\n...\n22  |     (s_vec.into_iter().collect(), s_vec\
    \ == tmp_vec)\n    |            -----------            ^^^^^ value borrowed here\
    \ after move\n    |            |\n    |            `s_vec` moved due to this method\
    \ call\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `s_vec`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|x| !c.contains(*x))\n            .collect::<String>(),\n        s.chars()\n\
    \            .filter(|x| !c.contains(*x))\n            .collect::<String>()\n\
    \            .chars()\n            .eq(s.chars().filter(|x| !c.contains(*x)).rev()),\n\
    \    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.into_bytes();\n  \
    \  s.retain(|a| !c.contains(char::from(a)));\n    (String::from_utf8(s).unwrap(),\
    \ is_palindrome(&s))\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpji4xoom2.rs:10:37\n   |\n10 |     (String::from_utf8(s).unwrap(), is_palindrome(&s))\n\
    \   |                                     ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the trait bound `char: From<&u8>` is not satisfied\n   --> /tmp/tmpji4xoom2.rs:9:30\n\
    \    |\n9   |     s.retain(|a| !c.contains(char::from(a)));\n    |           \
    \                   ^^^^^^^^^^ the trait `From<&u8>` is not implemented for `char`\n\
    \    |\n    = help: the following implementations were found:\n              <char\
    \ as From<u8>>\nnote: required by `from`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let chars: HashSet<char> = c.chars().collect();\n\
    \    let result = s.chars().filter(|&x| !chars.contains(&x)).collect::<String>();\n\
    \    (result, result == result.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpru69xibv.rs:8:16\n\
    \  |\n8 |     let chars: HashSet<char> = c.chars().collect();\n  |           \
    \     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n\
    \  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let reverse = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let is_palindrome = reverse == reverse.chars().rev().collect::<String>();\n\
    \    (reverse, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n --> /tmp/tmpj8s7n50a.rs:9:9\n\
    \  |\n8 |     let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n9 |     (s, s == s.chars().rev().collect::<String>())\n  |\
    \      -  ^ value borrowed here after move\n  |      |\n  |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    //\n    let mut s_ = s;\n    for\
    \ v in c.chars() {\n        s_ = s_.replace(v, \"\");\n    }\n    (s_, s_ == s_.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s_`\n  --> /tmp/tmp0wr9dzhc.rs:13:10\n\
    \   |\n9  |     let mut s_ = s;\n   |         ------ move occurs because `s_`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n13 |    \
    \ (s_, s_ == s_.chars().rev().collect::<String>())\n   |      --  ^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for letter in s.chars() {\n        if !c.contains(letter) {\n           \
    \ result.push(letter);\n        }\n    }\n    (result, is_palindrome(&result))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpmxiif6_g.rs:14:14\n   |\n14 |     (result, is_palindrome(&result))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let result = s.chars().filter(|ch|\
    \ !c.contains(*ch)).collect::<String>();\n    let palindrome = result.chars().eq(result.chars().rev());\n\
    \    (result, palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().collect::<Vec<_>>();\n\
    \    let c = c.chars().collect::<Vec<_>>();\n    let mut res = String::new();\n\
    \    for char in s {\n        if !c.contains(&char) {\n            res.push(char);\n\
    \        }\n    }\n    let is_palindrome = res.chars().eq(res.chars().rev());\n\
    \    (res, is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let mut c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        let mut delete = false;\n        for letter in c.iter()\
    \ {\n            if s[i] == *letter {\n                delete = true;\n      \
    \          break;\n            }\n        }\n        if delete {\n           \
    \ s.remove(i);\n        } else {\n            i += 1;\n        }\n    }\n    let\
    \ s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmpjqsmh_vt.rs:9:9\n\
    \  |\n9 |     let mut c: Vec<char> = c.chars().collect();\n  |         ----^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `s` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpjqsmh_vt.rs:20:13\n   |\n8  |     let s: Vec<char>\
    \ = s.chars().collect();\n   |         - help: consider changing this to be mutable:\
    \ `mut s`\n...\n20 |             s.remove(i);\n   |             ^ cannot borrow\
    \ as mutable\n\nerror[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpjqsmh_vt.rs:26:9\n\
    \   |\n25 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    26 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0382, E0596.\nFor more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.clone();\n    for\
    \ c in c.chars() {\n        s = s.replace(c, \"\");\n    }\n    s = s.replace(\"\
    \ \", \"\");\n    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmplcym9ob7.rs:13:9\n\
    \   |\n8  |     let mut s = s.clone();\n   |         ----- move occurs because\
    \ `s` has type `String`, which does not implement the `Copy` trait\n...\n13 |\
    \     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut t = String::new();\n   \
    \ let mut u = String::new();\n    for x in s.chars() {\n        if !c.contains(x)\
    \ {\n            t.push(x);\n            u.insert(0, x);\n        }\n    }\n \
    \   (t, t == u)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `t`\n  --> /tmp/tmpkb_gu6xg.rs:16:9\n\
    \   |\n8  |     let mut t = String::new();\n   |         ----- move occurs because\
    \ `t` has type `String`, which does not implement the `Copy` trait\n...\n16 |\
    \     (t, t == u)\n   |      -  ^ value borrowed here after move\n   |      |\n\
    \   |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for i in s.chars() {\n        if !c.contains(i) {\n            res.push(i);\n\
    \        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpnltty6cv.rs:14:11\n\
    \   |\n8  |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n14 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut deleted = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            deleted.push(ch);\n\
    \        }\n    }\n    let palindrome = deleted.chars().rev().collect::<String>()\
    \ == deleted;\n    (deleted, palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    let mut new_s: String = \"\".to_string();\n    let mut check_palindrome:\
    \ bool = true;\n    let mut i: usize = 0;\n    while i < chars.len() {\n     \
    \   if c.contains(chars[i]) {\n            chars.remove(i);\n        } else {\n\
    \            new_s.push(chars[i]);\n            i += 1;\n        }\n    }\n  \
    \  if new_s.len() > 1 {\n        let mut j: usize = 0;\n        let mut k: usize\
    \ = new_s.len() - 1;\n        while j < k {\n            if new_s.chars().nth(j)\
    \ != new_s.chars().nth(k) {\n                check_palindrome = false;\n     \
    \           break;\n            }\n            j += 1;\n            k -= 1;\n\
    \        }\n    }\n    (new_s, check_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let chars_to_remove: HashSet<char>\
    \ = c.into_iter().collect();\n    let s: String = s.into_iter().filter(|&x| !chars_to_remove.contains(&x)).collect();\n\
    \    let s: Vec<char> = s.chars().collect();\n    let is_palindrome = s.iter().zip(s.iter().rev()).all(|(a,\
    \ b)| a == b);\n    (s.into_iter().collect(), is_palindrome)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpdcgwzwqh.rs:10:26\n\
    \   |\n10 |     let chars_to_remove: HashSet<char> = c.into_iter().collect();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.chars().fold(String::new(), |mut\
    \ acc, ch| {\n        if !c.contains(ch) {\n            acc.push(ch);\n      \
    \  }\n        acc\n    }), true)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"bcd\", true)`,\n right: `(\"bcd\", false)`', /tmp/tmpeu5tdn7b.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|&c| !c.is_whitespace())\n            .filter(|&c| !c.is_digit(10))\n\
    \            .filter(|&c| !c.is_uppercase())\n            .filter(|&c| !c.is_lowercase())\n\
    \            .collect::<String>(),\n        true,\n    )\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"\", true)`,\n right: `(\"bcd\", false)`', /tmp/tmpi_2dnmkc.rs:21:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for _ in 0..c.len()\
    \ {\n        s = s.replace(c.chars().next().unwrap(), \"\");\n    }\n    let s\
    \ = s.chars().collect::<Vec<char>>();\n    let res = (s.iter().collect::<String>(),\
    \ s == s.iter().rev().collect::<Vec<&char>>());\n    res\n}\n\nfn main() {\n \
    \   let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `char` with `&char`\n  --> /tmp/tmpzs0eik6g.rs:13:48\n\
    \   |\n13 |     let res = (s.iter().collect::<String>(), s == s.iter().rev().collect::<Vec<&char>>());\n\
    \   |                                                ^^ no implementation for\
    \ `char == &char`\n   |\n   = help: the trait `PartialEq<&char>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `PartialEq<Vec<&char>>`\
    \ for `Vec<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp_su29ggc.rs:8:46\n\
    \  |\n8 |     let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                              ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp_su29ggc.rs:8:46\n\
    \  |\n8 |     let s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                              ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut chars\
    \ = c.chars().collect::<Vec<_>>();\n    chars.sort();\n    s.retain(|x| !chars.binary_search(&x).is_ok());\n\
    \    let mut s2 = s.clone();\n    s2.make_ascii_lowercase();\n    let s2 = s2.chars().collect::<Vec<_>>();\n\
    \    let b = s2.iter().zip(s2.iter().rev()).all(|(a, b)| a == b);\n    (s, b)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for x in s.chars() {\n        if !c.contains(x) {\n            result.push(x);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpzh7wb6re.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut filtered_str = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            filtered_str.push(ch);\n\
    \        }\n    }\n    let palindrome_check = filtered_str.chars().zip(filtered_str.chars().rev()).all(|(a,\
    \ b)| a == b);\n    (filtered_str, palindrome_check)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    let mut counter = 0;\n    while counter < c.len() {\n        let mut\
    \ j = 0;\n        let mut buffer = String::new();\n        while j < s.len() {\n\
    \            if s.chars().nth(j).unwrap() != c.chars().nth(counter).unwrap() {\n\
    \                buffer.push(s.chars().nth(j).unwrap());\n            }\n    \
    \        j += 1;\n        }\n        s = buffer;\n        counter += 1;\n    }\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmprldrif0s.rs:9:9\n\
    \  |\n9 |     let mut c = c;\n  |         ----^\n  |         |\n  |         help:\
    \ remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `s`\n  --> /tmp/tmprldrif0s.rs:23:9\n   |\n8  |     let\
    \ mut s = s;\n   |         ----- move occurs because `s` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n23 |     (s, s == s.chars().rev().collect::<String>())\n\
    \   |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|c_s| !c.contains(c_s)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp7ut_8dhe.rs:8:48\n\
    \  |\n8 |     let s = s.chars().filter(|c_s| !c.contains(c_s)).collect::<String>();\n\
    \  |                                                ^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    let result_string = result.clone();\n    let is_palindrome\
    \ = result == result.chars().rev().collect::<String>();\n    (result_string, is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.to_lowercase();\n    let\
    \ c = c.to_lowercase();\n    let mut filtered_s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \    filtered_s.make_ascii_lowercase();\n    (filtered_s, is_palindrome(&filtered_s))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpwpw7dw1m.rs:12:18\n   |\n12 |     (filtered_s, is_palindrome(&filtered_s))\n\
    \   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ expected a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpwpw7dw1m.rs:10:59\n\
    \   |\n10 |     let mut filtered_s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \   |                                                           ^ expected an\
    \ `Fn<(char,)>` closure, found `char`\n   |\n   = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n   = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n   = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.into_bytes();\n    let\
    \ c = c.into_bytes();\n    let mut res = Vec::new();\n    for i in s {\n     \
    \   if !c.contains(&i) {\n            res.push(i);\n        }\n    }\n    (\n\
    \        String::from_utf8(res).unwrap(),\n        res == res.iter().rev().cloned().collect::<Vec<u8>>(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmp0qtg97sx.rs:18:9\n\
    \   |\n10 |     let mut res = Vec::new();\n   |         ------- move occurs because\
    \ `res` has type `Vec<u8>`, which does not implement the `Copy` trait\n...\n17\
    \ |         String::from_utf8(res).unwrap(),\n   |                           ---\
    \ value moved here\n18 |         res == res.iter().rev().cloned().collect::<Vec<u8>>(),\n\
    \   |         ^^^ value borrowed here after move\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut chars: Vec<char> = s.chars().collect();\n\
    \    let mut chars_c: Vec<char> = c.chars().collect();\n    let mut output = String::new();\n\
    \    let mut count = 0;\n    for i in 0..chars.len() {\n        for j in 0..chars_c.len()\
    \ {\n            if chars[i] == chars_c[j] {\n                count += 1;\n  \
    \          }\n        }\n        if count == 0 {\n            output.push(chars[i]);\n\
    \        }\n        count = 0;\n    }\n    (output, is_palindrome(output))\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpvx4xz3r3.rs:23:14\n   |\n23 |     (output, is_palindrome(output))\n\
    \   |              ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let m: HashMap<char, bool> = c.chars().map(|x|\
    \ (x, true)).collect();\n    let s: String = s.chars().filter(|x| !m.contains_key(x)).collect();\n\
    \    let mut s1 = s.clone();\n    s1.make_ascii_lowercase();\n    (s, s1 == s1.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n --> /tmp/tmp34pbaaie.rs:8:12\n\
    \  |\n8 |     let m: HashMap<char, bool> = c.chars().map(|x| (x, true)).collect();\n\
    \  |            ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for cc in c.chars()\
    \ {\n        s = s.chars().filter(|x| x != &cc).collect();\n    }\n    (s, is_palindrome(&s))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpjttz6tl3.rs:12:9\n   |\n12 |     (s, is_palindrome(&s))\n   |      \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|&x| !c.contains(x))\n            .collect::<String>(),\n        is_palindrome(&s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>()),\n    )\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpllyomhms.rs:12:9\n   |\n12 |         is_palindrome(&s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>()),\n   |         ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.chars().filter(|&x| !c.contains(x)).collect(),\n\
    \     s.chars().filter(|&x| !c.contains(x)).eq(s.chars().filter(|&x| !c.contains(x)).rev()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut t: String = s.chars().filter(|x|\
    \ !c.contains(x)).collect();\n    let r = t.clone();\n    t.make_ascii_lowercase();\n\
    \    (r, t == t.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp07ppd_re.rs:8:58\n\
    \  |\n8 |     let mut t: String = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \  |                                                          ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res: String = s.chars().filter(|x|\
    \ !c.contains(x)).collect();\n    let mut ans = true;\n    for i in 0..res.len()\
    \ / 2 {\n        if res.pop().unwrap() != res.remove(i) {\n            ans = false;\n\
    \            break;\n        }\n    }\n    (res, ans)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpn664m8zs.rs:8:60\n\
    \  |\n8 |     let mut res: String = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \  |                                                            ^ expected an\
    \ `Fn<(char,)>` closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n  = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n  = note: required because of\
    \ the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    // your code here\n    let mut new_s\
    \ = String::new();\n    for x in s.chars() {\n        if !c.contains(x) {\n  \
    \          new_s.push(x);\n        }\n    }\n    (new_s, new_s == new_s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `new_s`\n  --> /tmp/tmpgawokoz1.rs:15:13\n\
    \   |\n9  |     let mut new_s = String::new();\n   |         --------- move occurs\
    \ because `new_s` has type `String`, which does not implement the `Copy` trait\n\
    ...\n15 |     (new_s, new_s == new_s.chars().rev().collect::<String>())\n   |\
    \      -----  ^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut result: Vec<char> =\
    \ Vec::new();\n    let mut is_palindrome = true;\n    for i in 0..s.len() {\n\
    \        if !c.contains(&s[i]) {\n            result.push(s[i]);\n        }\n\
    \    }\n    for i in 0..result.len() / 2 {\n        if result[i] != result[result.len()\
    \ - i - 1] {\n            is_palindrome = false;\n            break;\n       \
    \ }\n    }\n    let result: String = result.into_iter().collect();\n    (result,\
    \ is_palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let len = s.len();\n    for\
    \ i in 0..len {\n        if c.contains(&s[i]) {\n            s.remove(i);\n  \
    \      }\n    }\n    let result: String = s.into_iter().collect();\n    let palindrome\
    \ = result.chars().rev().eq(result.chars());\n    (result, palindrome)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 4'', /tmp/tmpad05i1g0.rs:12:24

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = s.clone();\n    for\
    \ sym in c.chars() {\n        res = res.chars().filter(|&x| x != sym).collect();\n\
    \    }\n    (res, res == res.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpsgwn0luh.rs:12:11\n\
    \   |\n8  |     let mut res = s.clone();\n   |         ------- move occurs because\
    \ `res` has type `String`, which does not implement the `Copy` trait\n...\n12\
    \ |     (res, res == res.chars().rev().collect::<String>())\n   |      ---  ^^^\
    \ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut res = String::new();\n\
    \    for x in s {\n        if !c.contains(&x) {\n            res.push(x);\n  \
    \      }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpcbq3n1gq.rs:16:11\n\
    \   |\n10 |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n16 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|x| !c.contains(*x))\n            .collect::<String>(),\n        s.chars()\n\
    \            .filter(|x| !c.contains(*x))\n            .collect::<String>()\n\
    \            .chars()\n            .eq(s.chars().filter(|x| !c.contains(*x)).rev()),\n\
    \    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let c: Vec<char>\
    \ = c.chars().collect();\n    for x in c {\n        s = s.replace(x, \"\");\n\
    \    }\n    let reversed = s.chars().rev().collect::<String>();\n    (s, s ==\
    \ reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmp06e4yjrl.rs:14:9\n\
    \   |\n8  |     let mut s = s;\n   |         ----- move occurs because `s` has\
    \ type `String`, which does not implement the `Copy` trait\n...\n14 |     (s,\
    \ s == reversed)\n   |      -  ^ value borrowed here after move\n   |      |\n\
    \   |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut reverse = s.clone();\n \
    \   reverse.clear();\n    for i in s.chars() {\n        if !c.contains(i) {\n\
    \            reverse.push(i);\n        }\n    }\n    (reverse, reverse == reverse.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `reverse`\n  --> /tmp/tmp3x63kljw.rs:15:15\n\
    \   |\n8  |     let mut reverse = s.clone();\n   |         ----------- move occurs\
    \ because `reverse` has type `String`, which does not implement the `Copy` trait\n\
    ...\n15 |     (reverse, reverse == reverse.chars().rev().collect::<String>())\n\
    \   |      -------  ^^^^^^^ value borrowed here after move\n   |      |\n   |\
    \      value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut string = s.clone();\n  \
    \  let chars: Vec<char> = c.chars().collect();\n    let mut removed = 0;\n   \
    \ let length = string.len();\n    while removed < length {\n        let to_remove\
    \ = string.chars().skip(removed).take(1).collect::<String>();\n        if chars.contains(&to_remove.chars().next().unwrap())\
    \ {\n            string.replace_range(removed..(removed + 1), \"\");\n       \
    \ } else {\n            removed += 1;\n        }\n    }\n    let mut reverse =\
    \ string.clone();\n    reverse.chars().rev().collect::<String>();\n    (string,\
    \ string == reverse)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpfepdlnz5.rs:20:9\n\
    \   |\n20 |     let mut reverse = string.clone();\n   |         ----^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `string`\n  --> /tmp/tmpfepdlnz5.rs:22:14\n\
    \   |\n8  |     let mut string = s.clone();\n   |         ---------- move occurs\
    \ because `string` has type `String`, which does not implement the `Copy` trait\n\
    ...\n22 |     (string, string == reverse)\n   |      ------  ^^^^^^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for letter in s.chars() {\n        if !c.contains(letter) {\n           \
    \ result.push(letter);\n        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmp45cvw9ap.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let (s1, s2) = s.split_at(s.len()/2);\n\
    \    let s_rev = s2.chars().rev().collect::<String>();\n    let res = s1.to_string()\
    \ + &s_rev;\n    let filtered = res.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    (filtered, filtered == filtered.chars().rev().collect::<String>())\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `filtered`\n  --> /tmp/tmp4r33mmt6.rs:12:16\n\
    \   |\n11 |     let filtered = res.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \   |         -------- move occurs because `filtered` has type `String`, which\
    \ does not implement the `Copy` trait\n12 |     (filtered, filtered == filtered.chars().rev().collect::<String>())\n\
    \   |      --------  ^^^^^^^^ value borrowed here after move\n   |      |\n  \
    \ |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    for &ch in c.chars() {\n        s.retain(|x| x != ch);\n    }\n    let s\
    \ = s.iter().collect::<String>();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpzdrolryq.rs:9:9\n  |\n9 |\
    \     for &ch in c.chars() {\n  |         ^^^    --------- this expression has\
    \ type `char`\n  |         |\n  |         expected `char`, found reference\n \
    \ |\n  = note:   expected type `char`\n          found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    result.chars().rev().enumerate().all(|(index,\
    \ ch)| ch == result.chars().nth(index).unwrap())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpm1sha021.rs:8:55\n\
    \  |\n8 |     let mut result = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                       ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpm1sha021.rs:9:5\n\
    \  |\n7 | fn reverse_delete(s: String, c: String) -> (String, bool) {\n  |   \
    \                                         -------------- expected `(String, bool)`\
    \ because of return type\n8 |     let mut result = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    9 |     result.chars().rev().enumerate().all(|(index, ch)| ch == result.chars().nth(index).unwrap())\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found `bool`\n  |\n  = note: expected tuple `(String, bool)`\n\
    \              found type `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<_> = s.chars().filter(|x|\
    \ !c.contains(x)).collect();\n    let s = s.iter().collect::<String>();\n    (s,\
    \ s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpf2n6os3f.rs:8:54\n\
    \  |\n8 |     let s: Vec<_> = s.chars().filter(|x| !c.contains(x)).collect();\n\
    \  |                                                      ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    s.retain(|x| !c.contains(x));\n    let len = s.len();\n    for i in 0..len/2\
    \ {\n        if s[i] != s[len-i-1] {\n            return (s.into_iter().collect(),\
    \ false);\n        }\n    }\n    (s.into_iter().collect(), true)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp_jhyr0xf.rs:9:30\n\
    \  |\n9 |     s.retain(|x| !c.contains(x));\n  |                             \
    \ ^ expected an `Fn<(char,)>` closure, found `char`\n  |\n  = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n  = note: required because of the\
    \ requirements on the impl of `FnOnce<(char,)>` for `&char`\n  = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let mut c: Vec<char> = c.chars().collect();\n    let mut answer: String =\
    \ String::new();\n    c.iter().for_each(|&x| {\n        s.retain(|&y| x != y);\n\
    \    });\n    s.iter().for_each(|&x| {\n        answer.push(x);\n    });\n   \
    \ (answer, answer == answer.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmp9g83qvy2.rs:9:9\n\
    \  |\n9 |     let mut c: Vec<char> = c.chars().collect();\n  |         ----^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `answer`\n  --> /tmp/tmp9g83qvy2.rs:17:14\n\
    \   |\n10 |     let mut answer: String = String::new();\n   |         ----------\
    \ move occurs because `answer` has type `String`, which does not implement the\
    \ `Copy` trait\n...\n17 |     (answer, answer == answer.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut t: Vec<char> = Vec::new();\n\
    \    for i in s {\n        if !c.contains(&i) {\n            t.push(i);\n    \
    \    }\n    }\n    let t_rev: Vec<char> = t.iter().rev().map(|&x| x).collect();\n\
    \    let is_palindrome = t.eq(&t_rev);\n    (t.into_iter().collect(), is_palindrome)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let (_, s) = s.chars().fold((0,\
    \ String::new()), |(mut i, mut acc), l| {\n        i += if c.contains(l) { 1 }\
    \ else { 0 };\n        if i % 2 == 0 {\n            acc.push(l);\n        }\n\
    \        (i, acc)\n    });\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpicfq6tsy.rs:15:9\n\
    \   |\n8  |     let (_, s) = s.chars().fold((0, String::new()), |(mut i, mut acc),\
    \ l| {\n   |             - move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n...\n15 |     (s, s == s.chars().rev().collect::<String>())\n\
    \   |      -  ^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut filtered = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    (filtered.clone(), filtered == filtered.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpczqzpd6x.rs:8:57\n\
    \  |\n8 |     let mut filtered = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                         ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let clean_s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let is_palindrome = clean_s.chars().zip(clean_s.chars().rev()).all(|(a,\
    \ b)| a == b);\n    (clean_s, is_palindrome)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmp9rwsj6fs.rs:8:52\n\
    \  |\n8 |     let clean_s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                    ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    if s.chars().count() <= 1 {\n  \
    \      return (s, true);\n    }\n    let mut chars = s.chars().collect::<Vec<char>>();\n\
    \    let mut chars_clone = chars.clone();\n    let c_chars = c.chars().collect::<Vec<char>>();\n\
    \    for char in c_chars {\n        chars.retain(|&x| x != char);\n    }\n   \
    \ for i in 0..chars.len() {\n        if chars[i] != chars[chars.len() - 1 - i]\
    \ {\n            return (chars_clone.into_iter().collect(), false);\n        }\n\
    \    }\n    (chars.into_iter().collect(), true)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"abcde\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmpepohwcoj.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut removed = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            removed.push(ch);\n\
    \        }\n    }\n    (removed, removed == removed.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `removed`\n  --> /tmp/tmp6_k05v3n.rs:14:15\n\
    \   |\n8  |     let mut removed = String::new();\n   |         ----------- move\
    \ occurs because `removed` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (removed, removed == removed.chars().rev().collect::<String>())\n\
    \   |      -------  ^^^^^^^ value borrowed here after move\n   |      |\n   |\
    \      value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut v: Vec<char> = Vec::new();\n\
    \    for i in s {\n        if !c.contains(&i) {\n            v.push(i);\n    \
    \    }\n    }\n    let mut reverse = v.clone();\n    reverse.reverse();\n    if\
    \ v == reverse {\n        (v.into_iter().collect(), true)\n    } else {\n    \
    \    (v.into_iter().collect(), false)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    for &ch in c.chars() {\n        s.retain(|&x| x != ch);\n    }\n    (s.iter().cloned().collect(),\
    \ s == s.iter().rev().cloned().collect())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpcn8hzjim.rs:9:9\n  |\n9 |\
    \     for &ch in c.chars() {\n  |         ^^^    --------- this expression has\
    \ type `char`\n  |         |\n  |         expected `char`, found reference\n \
    \ |\n  = note:   expected type `char`\n          found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut news = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    news.chars().rev().zip(news.chars()).all(|(x,\
    \ y)| x == y)\n        && (news.chars().count() > 0)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmplbji0vg6.rs:8:53\n\
    \  |\n8 |     let mut news = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                     ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplbji0vg6.rs:9:5\n\
    \   |\n7  |   fn reverse_delete(s: String, c: String) -> (String, bool) {\n  \
    \ |                                              -------------- expected `(String,\
    \ bool)` because of return type\n8  |       let mut news = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n9  | /     news.chars().rev().zip(news.chars()).all(|(x,\
    \ y)| x == y)\n10 | |         && (news.chars().count() > 0)\n   | |_____________________________________^\
    \ expected tuple, found `bool`\n   |\n   = note: expected tuple `(String, bool)`\n\
    \               found type `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|x| !c.contains(*x))\n            .collect::<String>(),\n        s.chars()\n\
    \            .filter(|x| !c.contains(*x))\n            .eq(s.chars().filter(|x|\
    \ !c.contains(*x)).rev()),\n    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpljmf51f3.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut s_copy = s.clone();\n    let\
    \ mut res = s.chars().rev().collect::<String>();\n    (s_copy, res == s)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpm9uhzivy.rs:8:50\n\
    \  |\n8 |     let mut s = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                  ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpljmf51f3.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut result: Vec<char> =\
    \ Vec::new();\n    for i in s {\n        if !c.contains(&i) {\n            result.push(i);\n\
    \        }\n    }\n    let s: String = result.into_iter().collect();\n    (s,\
    \ s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpvpeelfup.rs:17:9\n\
    \   |\n16 |     let s: String = result.into_iter().collect();\n   |         -\
    \ move occurs because `s` has type `String`, which does not implement the `Copy`\
    \ trait\n17 |     (s, s == s.chars().rev().collect::<String>())\n   |      - \
    \ ^ value borrowed here after move\n   |      |\n   |      value moved here\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            result.push(ch);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpljmf51f3.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n --> /tmp/tmpj8s7n50a.rs:9:9\n\
    \  |\n8 |     let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n9 |     (s, s == s.chars().rev().collect::<String>())\n  |\
    \      -  ^ value borrowed here after move\n  |      |\n  |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    // your code\n    let mut s_vec:\
    \ Vec<char> = s.chars().collect();\n    let mut c_vec: Vec<char> = c.chars().collect();\n\
    \    let mut counter = 0;\n    for i in 0..s_vec.len() {\n        for j in 0..c_vec.len()\
    \ {\n            if s_vec[i] == c_vec[j] {\n                s_vec.remove(i);\n\
    \                counter += 1;\n            }\n        }\n    }\n    let mut res\
    \ = String::new();\n    for i in 0..s_vec.len() {\n        res.push(s_vec[i]);\n\
    \    }\n    let reversed = res.chars().rev().collect::<String>();\n    if res\
    \ == reversed {\n        (res, true)\n    } else {\n        (res, false)\n   \
    \ }\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 4'', /tmp/tmp5hdps15l.rs:14:16

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut r = String::new();\n   \
    \ for ch in s.chars() {\n        if !c.contains(ch) {\n            r.push(ch);\n\
    \        }\n    }\n    let r: String = r.chars().rev().collect();\n    (r, r ==\
    \ s)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `r`\n  --> /tmp/tmp69i1ptx2.rs:15:9\n\
    \   |\n14 |     let r: String = r.chars().rev().collect();\n   |         - move\
    \ occurs because `r` has type `String`, which does not implement the `Copy` trait\n\
    15 |     (r, r == s)\n   |      -  ^ value borrowed here after move\n   |    \
    \  |\n   |      value moved here\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.chars().filter(|x| !c.contains(x)).collect::<String>(),\n\
    \     s.chars().filter(|x| !c.contains(x)).collect::<String>() == s.chars().filter(|x|\
    \ !c.contains(x)).rev().collect::<String>())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpu48y2cw5.rs:8:39\n\
    \  |\n8 |     (s.chars().filter(|x| !c.contains(x)).collect::<String>(),\n  |\
    \                                       ^ expected an `Fn<(char,)>` closure, found\
    \ `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \ --> /tmp/tmpu48y2cw5.rs:9:39\n  |\n9 |      s.chars().filter(|x| !c.contains(x)).collect::<String>()\
    \ == s.chars().filter(|x| !c.contains(x)).rev().collect::<String>())\n  |    \
    \                                   ^ expected an `Fn<(char,)>` closure, found\
    \ `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented for `char`\n\
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror[E0277]: expected a `Fn<(char,)>` closure, found `char`\n\
    \ --> /tmp/tmpu48y2cw5.rs:9:99\n  |\n9 |      s.chars().filter(|x| !c.contains(x)).collect::<String>()\
    \ == s.chars().filter(|x| !c.contains(x)).rev().collect::<String>())\n  |    \
    \                                                                            \
    \                   ^ expected an `Fn<(char,)>` closure, found `char`\n  |\n \
    \ = help: the trait `Fn<(char,)>` is not implemented for `char`\n  = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \ = note: required because of the requirements on the impl of `Pattern<'_>` for\
    \ `&char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    // check if c contains only 1 character\n\
    \    // if yes, we can use the simpler algorithm\n    if c.len() == 1 {\n    \
    \    let r = s.chars().filter(|&x| x != c.chars().next().unwrap()).collect::<String>();\n\
    \        return (r, r == r.chars().rev().collect::<String>());\n    }\n\n    //\
    \ collect chars from c into a hash set\n    let mut set = HashSet::new();\n  \
    \  for ch in c.chars() {\n        set.insert(ch);\n    }\n\n    // remove chars\
    \ from s\n    let mut r = String::new();\n    for ch in s.chars() {\n        if\
    \ !set.contains(&ch) {\n            r.push(ch);\n        }\n    }\n\n    // check\
    \ for palindrome\n    (r, r == r.chars().rev().collect::<String>())\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5kbhdgja.rs:16:19\n   |\n16 |     let mut set = HashSet::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n --> /tmp/tmpj8s7n50a.rs:9:9\n\
    \  |\n8 |     let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n9 |     (s, s == s.chars().rev().collect::<String>())\n  |\
    \      -  ^ value borrowed here after move\n  |      |\n  |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = s;\n    for a in c.chars()\
    \ {\n        res = res.replace(a, \"\");\n    }\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpo322olel.rs:12:11\n\
    \   |\n8  |     let mut res = s;\n   |         ------- move occurs because `res`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n12 |    \
    \ (res, res == res.chars().rev().collect::<String>())\n   |      ---  ^^^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for c in s.chars() {\n        if !c.is_whitespace() && !c.is_control() &&\
    \ !c.is_alphanumeric() {\n            res.push(c);\n        }\n    }\n    res\
    \ = res.to_lowercase();\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `c`\n --> /tmp/tmpi8mhxwb3.rs:7:30\n  |\n7 |\
    \ fn reverse_delete(s: String, c: String) -> (String, bool) {\n  |           \
    \                   ^ help: if this is intentional, prefix it with an underscore:\
    \ `_c`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\nerror[E0382]:\
    \ borrow of moved value: `res`\n  --> /tmp/tmpi8mhxwb3.rs:15:11\n   |\n8  |  \
    \   let mut res = String::new();\n   |         ------- move occurs because `res`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n15 |    \
    \ (res, res == res.chars().rev().collect::<String>())\n   |      ---  ^^^ value\
    \ borrowed here after move\n   |      |\n   |      value moved here\n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let palindrome = s.replace(|c: char|\
    \ c.is_alphanumeric(), \"\").chars().zip(s.replace(|c: char| c.is_alphanumeric(),\
    \ \"\").chars().rev()).all(|(c1, c2)| c1 == c2);\n    (s.replace(|c: char| c.is_alphanumeric(),\
    \ \"\"), palindrome)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"\", true)`,\n right: `(\"bcd\", false)`', /tmp/tmpcz0p_lw6.rs:14:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|v| !c.contains(*v))\n            .collect::<String>(),\n        s.chars()\n\
    \            .filter(|v| !c.contains(*v))\n            .collect::<String>()\n\
    \            .eq_ignore_ascii_case(\n                s.chars()\n             \
    \       .filter(|v| !c.contains(*v))\n                    .rev()\n           \
    \         .collect::<String>(),\n            ),\n    )\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj_3lloqg.rs:16:17\n   |\n\
    16 | /                 s.chars()\n17 | |                     .filter(|v| !c.contains(*v))\n\
    18 | |                     .rev()\n19 | |                     .collect::<String>(),\n\
    \   | |________________________________________^ expected `&str`, found struct\
    \ `String`\n   |\nhelp: consider borrowing here\n   |\n16 ~                 &s.chars()\n\
    17 +                     .filter(|v| !c.contains(*v))\n18 +                  \
    \   .rev()\n19 ~                     .collect::<String>(),\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    let mut check = true;\n    for i in s.chars() {\n        if !c.contains(i)\
    \ {\n            result.push(i);\n        }\n    }\n    for i in 0..result.len()\
    \ / 2 {\n        if result.chars().nth(i) != result.chars().nth(result.len() -\
    \ i - 1) {\n            check = false;\n            break;\n        }\n    }\n\
    \    (result, check)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let check = res.clone().chars().rev().collect::<String>()\
    \ == res;\n    (res, check)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpczalnnnj.rs:8:52\n\
    \  |\n8 |     let mut res = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                    ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let c: HashSet<char> = c.chars().collect();\n\
    \    let mut chars: Vec<char> = s.chars().collect();\n    let mut i = 0;\n   \
    \ while i < chars.len() {\n        if c.contains(&chars[i]) {\n            chars.remove(i);\n\
    \        } else {\n            i += 1;\n        }\n    }\n    let rev: String\
    \ = chars.iter().rev().collect();\n    (String::from_iter(chars), rev == chars)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpzsh63w3d.rs:8:12\n\
    \  |\n8 |     let c: HashSet<char> = c.chars().collect();\n  |            ^^^^^^^\
    \ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 |\
    \ use std::collections::HashSet;\n  |\n\nerror[E0599]: no function or associated\
    \ item named `from_iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpzsh63w3d.rs:19:14\n   |\n19 |     (String::from_iter(chars), rev ==\
    \ chars)\n   |              ^^^^^^^^^ function or associated item not found in\
    \ `String`\n   |\n   = help: items from traits can only be used if the trait is\
    \ in scope\nhelp: the following trait is implemented but not in scope; perhaps\
    \ add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there\
    \ is an associated function with a similar name\n   |\n19 |     (String::from_utf8(chars),\
    \ rev == chars)\n   |              ~~~~~~~~~\n\nerror[E0277]: can't compare `String`\
    \ with `Vec<char>`\n  --> /tmp/tmpzsh63w3d.rs:19:36\n   |\n19 |     (String::from_iter(chars),\
    \ rev == chars)\n   |                                    ^^ no implementation\
    \ for `String == Vec<char>`\n   |\n   = help: the trait `PartialEq<Vec<char>>`\
    \ is not implemented for `String`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0412, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut answer: String = s.chars().filter(|&x|\
    \ !c.contains(x)).collect();\n    answer.make_ascii_lowercase();\n    (answer,\
    \ answer == answer.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `answer`\n  --> /tmp/tmp5pclbj9r.rs:10:14\n\
    \   |\n8  |     let mut answer: String = s.chars().filter(|&x| !c.contains(x)).collect();\n\
    \   |         ---------- move occurs because `answer` has type `String`, which\
    \ does not implement the `Copy` trait\n9  |     answer.make_ascii_lowercase();\n\
    10 |     (answer, answer == answer.chars().rev().collect::<String>())\n   |  \
    \    ------  ^^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|&c| !c.is_whitespace())\n            .filter(|&c| !c.is_alphanumeric())\n\
    \            .collect::<String>(),\n        false,\n    )\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmp6qqcpb_e.rs:19:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    let mut reversed = result.chars().rev().collect::<String>();\n\
    \    let is_palindrome = result == reversed;\n    result.make_ascii_lowercase();\n\
    \    reversed.make_ascii_lowercase();\n    (result, is_palindrome)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpiu3euq4z.rs:8:55\n\
    \  |\n8 |     let mut result = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                       ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let t: Vec<char> = s.iter().filter(|x|\
    \ !c.contains(x)).collect();\n    (t.iter().collect(), t == t.iter().rev().collect())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<char>` cannot be built from an iterator\
    \ over elements of type `&char`\n  --> /tmp/tmp7gm8u3de.rs:10:60\n   |\n10 | \
    \    let t: Vec<char> = s.iter().filter(|x| !c.contains(x)).collect();\n   | \
    \                                                           ^^^^^^^ value of type\
    \ `Vec<char>` cannot be built from `std::iter::Iterator<Item=&char>`\n   |\n \
    \  = help: the trait `FromIterator<&char>` is not implemented for `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (\n        s.chars()\n         \
    \   .filter(|&x| !c.contains(x))\n            .collect::<String>(),\n        s.chars()\n\
    \            .filter(|&x| !c.contains(x))\n            .eq(s.chars().filter(|&x|\
    \ !c.contains(x)).rev()),\n    )\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let r_s = s.chars().filter(|&x|\
    \ !c.contains(x)).collect::<String>();\n    let r_t = r_s.clone().chars().rev().collect::<String>();\n\
    \    let result = r_s == r_t;\n    (r_s, result)\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut filtered_string = String::new();\n\
    \    for i in s.chars() {\n        if !c.contains(i) {\n            filtered_string.push(i);\n\
    \        }\n    }\n    let mut reversed_string = String::new();\n    for i in\
    \ filtered_string.chars().rev() {\n        reversed_string.push(i);\n    }\n \
    \   let result = filtered_string == reversed_string;\n    (filtered_string, result)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut r: String = s.chars().filter(|&a|\
    \ !c.contains(a)).collect();\n    let p = r.chars().eq(r.chars().rev());\n   \
    \ (r, p)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s_chars: Vec<char> = s.chars().collect();\n\
    \    let mut c_chars: Vec<char> = c.chars().collect();\n    s_chars.retain(|i|\
    \ !c_chars.contains(i));\n    let mut s_chars_rev = s_chars.clone();\n    s_chars_rev.reverse();\n\
    \    (s_chars.into_iter().collect(), s_chars == s_chars_rev)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n --> /tmp/tmp9tdk20zr.rs:9:9\n\
    \  |\n9 |     let mut c_chars: Vec<char> = c.chars().collect();\n  |         ----^^^^^^^\n\
    \  |         |\n  |         help: remove this `mut`\n  |\n  = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `s_chars`\n   --> /tmp/tmp9tdk20zr.rs:13:37\n\
    \    |\n8   |     let mut s_chars: Vec<char> = s.chars().collect();\n    |   \
    \      ----------- move occurs because `s_chars` has type `Vec<char>`, which does\
    \ not implement the `Copy` trait\n...\n13  |     (s_chars.into_iter().collect(),\
    \ s_chars == s_chars_rev)\n    |              -----------            ^^^^^^^ value\
    \ borrowed here after move\n    |              |\n    |              `s_chars`\
    \ moved due to this method call\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `s_chars`\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut new_s: Vec<char> = vec![];\n\
    \    for x in s {\n        if !c.contains(&x) {\n            new_s.push(x);\n\
    \        }\n    }\n    let test = new_s.iter().eq(new_s.iter().rev());\n    let\
    \ rev: String = new_s.iter().rev().collect();\n    (rev, test)\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"dcb\", false)`,\n right: `(\"bcd\", false)`', /tmp/tmpec_zhbo6.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut c = c.chars().collect::<HashSet<_>>();\n\
    \    let mut r = String::new();\n    for ch in s.chars() {\n        if !c.contains(&ch)\
    \ {\n            r.push(ch);\n        }\n    }\n    (r, r == r.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpgpv80oyb.rs:8:37\n\
    \  |\n8 |     let mut c = c.chars().collect::<HashSet<_>>();\n  |            \
    \                         ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.chars().filter(|&ch| !c.contains(ch)).collect(),\n\
    \     s.chars().filter(|&ch| !c.contains(ch)).eq(s.chars().filter(|&ch| !c.contains(ch)).rev()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut char_vec: Vec<char> = s.chars().collect();\n\
    \    for x in c.chars() {\n        char_vec.retain(|&y| y != x);\n    }\n    (char_vec.iter().collect(),\
    \ char_vec.iter().eq(char_vec.iter().rev()))\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    let mut c =\
    \ c;\n    for i in c.chars() {\n        s = s.replace(i, \"\");\n    }\n    let\
    \ b = s.chars().rev().collect::<String>() == s;\n    (s, b)\n}\n\nfn main() {\n\
    \    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut r = String::new();\n   \
    \ for cc in s.chars() {\n        if !c.contains(cc) {\n            r.push(cc);\n\
    \        }\n    }\n    r = r.chars().rev().collect();\n    (r, r == s)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `r`\n  --> /tmp/tmpn8enmgm2.rs:15:9\n\
    \   |\n8  |     let mut r = String::new();\n   |         ----- move occurs because\
    \ `r` has type `String`, which does not implement the `Copy` trait\n...\n15 |\
    \     (r, r == s)\n   |      -  ^ value borrowed here after move\n   |      |\n\
    \   |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for &b in s.as_bytes() {\n        if !c.contains(char::from(b)) {\n      \
    \      res.push(char::from(b));\n        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmphublyh3a.rs:14:11\n\
    \   |\n8  |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n14 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut filtered = s.chars().filter(|x|\
    \ !c.contains(x)).collect::<String>();\n    filtered = filtered.chars().rev().collect::<String>();\n\
    \    (filtered, filtered == s)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpwbgk27du.rs:8:57\n\
    \  |\n8 |     let mut filtered = s.chars().filter(|x| !c.contains(x)).collect::<String>();\n\
    \  |                                                         ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n  |\n  = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n  = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for x in s.chars() {\n        if !c.contains(x) {\n            res.push(x);\n\
    \        }\n    }\n    let res_str = res.as_str();\n    let pal = res_str == res_str.chars().rev().collect::<String>();\n\
    \    (res, pal)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for i in s.chars() {\n        if !c.contains(i) {\n            result.push(i);\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpjtz4wvah.rs:14:14\n\
    \   |\n8  |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n14 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822478
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let len = s.len();\n    let c: HashSet<char>\
    \ = c.chars().collect();\n    let mut s: Vec<char> = s.chars().filter(|c| !c.is_whitespace()).collect();\n\
    \    s.retain(|c| !c.is_whitespace());\n    s.retain(|c| !c.is_control());\n \
    \   s.retain(|c| !c.is_digit(10));\n    s.retain(|c| !c.is_lowercase());\n   \
    \ s.retain(|c| !c.is_uppercase());\n    s.retain(|c| !c.is_alphabetic());\n  \
    \  s.retain(|c| !c.is_alphanumeric());\n    s.retain(|c| !c.is_ascii());\n   \
    \ s.retain(|c| !c.is_ascii_alphabetic());\n    s.retain(|c| !c.is_ascii_digit());\n\
    \    s.retain(|c| !c.is_ascii_graphic());\n    s.retain(|c| !c.is_ascii_lowercase());\n\
    \    s.retain(|c| !c.is_ascii_uppercase());\n    s.retain(|c| !c.is_ascii_whitespace());\n\
    \    s.retain(|c| !c.is_digit(10));\n    s.retain(|c| !c.is_digit(16));\n    s.retain(|c|\
    \ !c.is_whitespace());\n    s.retain(|c| !c.is_alphabetic());\n    s.retain(|c|\
    \ !c.is_alphanumeric());\n    s.retain(|c| !c.is_lowercase());\n    s.retain(|c|\
    \ !c.is_uppercase());\n    s.retain(|c| !c.is_numeric());\n    s.retain(|c| !c.is_graphic());\n\
    \    s.\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp6iv08pc1.rs:35:1\n   |\n35\
    \ | }\n   | ^\n\nerror[E0412]: cannot find type `HashSet` in this scope\n -->\
    \ /tmp/tmp6iv08pc1.rs:9:12\n  |\n9 |     let c: HashSet<char> = c.chars().collect();\n\
    \  |            ^^^^^^^ not found in this scope\n  |\nhelp: consider importing\
    \ this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0599]: no\
    \ method named `is_graphic` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmp6iv08pc1.rs:33:21\n   |\n33 |     s.retain(|c| !c.is_graphic());\n\
    \   |                     ^^^^^^^^^^ method not found in `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6iv08pc1.rs:34:5\n   |\n7  | fn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n   |                               \
    \             -------------- expected `(String, bool)` because of return type\n\
    ...\n34 |     s.\n   |     ^ expected tuple, found struct `Vec`\n   |\n   = note:\
    \ expected tuple `(String, bool)`\n             found struct `Vec<char>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0412, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut res = String::new();\n\
    \    for i in 0..s.len() {\n        if !c.contains(&s[i]) {\n            res.push(s[i]);\n\
    \        }\n    }\n    let res = res.chars().rev().collect::<String>();\n    (res,\
    \ res == s.iter().collect::<String>())\n}\n\nfn main() {\n    let candidate =\
    \ reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpai5a8jhm.rs:17:11\n\
    \   |\n16 |     let res = res.chars().rev().collect::<String>();\n   |       \
    \  --- move occurs because `res` has type `String`, which does not implement the\
    \ `Copy` trait\n17 |     (res, res == s.iter().collect::<String>())\n   |    \
    \  ---  ^^^ value borrowed here after move\n   |      |\n   |      value moved\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for s in s.chars() {\n        if !c.contains(s) {\n            res.push(s);\n\
    \        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpufyhpdoo.rs:14:11\n\
    \   |\n8  |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n14 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = s;\n    for c in\
    \ c.chars() {\n        result = result.replace(c, \"\");\n    }\n    (result,\
    \ result == result.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmphupgzcrs.rs:12:14\n\
    \   |\n8  |     let mut result = s;\n   |         ---------- move occurs because\
    \ `result` has type `String`, which does not implement the `Copy` trait\n...\n\
    12 |     (result, result == result.chars().rev().collect::<String>())\n   |  \
    \    ------  ^^^^^^ value borrowed here after move\n   |      |\n   |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    (s.chars().filter(|&x| !c.contains(x)).collect(),\
    \ true)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"bcd\", true)`,\n right: `(\"bcd\", false)`', /tmp/tmpg7p6hxn2.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    for i in c {\n        s.retain(|&x|\
    \ x != i);\n    }\n    let mut reversed: Vec<char> = s.clone();\n    reversed.reverse();\n\
    \    let pal: bool = reversed == s;\n    (s.into_iter().collect(), pal)\n}\n\n\
    fn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut r = s.chars().collect::<Vec<char>>();\n\
    \    r.retain(|x| !c.contains(x));\n    (r.iter().collect(), r.iter().eq(r.iter().rev()))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n --> /tmp/tmpz1kb_aaz.rs:9:30\n\
    \  |\n9 |     r.retain(|x| !c.contains(x));\n  |                             \
    \ ^ expected an `Fn<(char,)>` closure, found `char`\n  |\n  = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n  = note: required because of the\
    \ requirements on the impl of `FnOnce<(char,)>` for `&char`\n  = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut char_map = vec![0; 257];\n\
    \    for ch in c.chars() {\n        char_map[ch as usize] = 1;\n    }\n    let\
    \ mut to_delete = vec![];\n    for (i, ch) in s.chars().enumerate() {\n      \
    \  if char_map[ch as usize] == 1 {\n            to_delete.push(i);\n        }\n\
    \    }\n    let mut result = String::new();\n    let mut to_delete_iter = to_delete.iter();\n\
    \    let mut to_delete_val = to_delete_iter.next();\n    for (i, ch) in s.chars().enumerate()\
    \ {\n        if to_delete_val.is_none() || i != *to_delete_val.unwrap() {\n  \
    \          result.push(ch);\n        } else {\n            to_delete_val = to_delete_iter.next();\n\
    \        }\n    }\n    (result, result == result.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result`\n  --> /tmp/tmpaqx4ii37.rs:28:14\n\
    \   |\n18 |     let mut result = String::new();\n   |         ---------- move\
    \ occurs because `result` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n28 |     (result, result == result.chars().rev().collect::<String>())\n\
    \   |      ------  ^^^^^^ value borrowed here after move\n   |      |\n   |  \
    \    value moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    // TODO\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmpj9u2rcqk.rs:9:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s;\n    for c_char in\
    \ c.chars() {\n        s = s.replace(c_char, \"\");\n    }\n    (s, is_palindrome(&s))\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmp8roigkpq.rs:12:9\n   |\n12 |     (s, is_palindrome(&s))\n   |      \
    \   ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut i = 0;\n    let mut\
    \ j = s.len() - 1;\n    while i < j {\n        if c.contains(&s[i]) {\n      \
    \      i += 1;\n        } else if c.contains(&s[j]) {\n            j -= 1;\n \
    \       } else if s[i] != s[j] {\n            return (s[i..j + 1].iter().collect(),\
    \ false);\n        } else {\n            i += 1;\n            j -= 1;\n      \
    \  }\n    }\n    (s[i..j + 1].iter().collect(), true)\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(\"abcdef\", false)`,\n right: `(\"acdef\", false)`', /tmp/tmpggnad10w.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!();\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmph1dsgock.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res: String = String::new();\n\
    \    let chars = c.chars().collect::<Vec<char>>();\n    for i in s.chars() {\n\
    \        if !chars.contains(&i) {\n            res.push(i);\n        }\n    }\n\
    \    let mut rev = res.clone();\n    rev.chars().rev();\n    (res, res == rev)\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpz6ljve65.rs:15:9\n\
    \   |\n15 |     let mut rev = res.clone();\n   |         ----^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpz6ljve65.rs:17:11\n\
    \   |\n8  |     let mut res: String = String::new();\n   |         ------- move\
    \ occurs because `res` has type `String`, which does not implement the `Copy`\
    \ trait\n...\n17 |     (res, res == rev)\n   |      ---  ^^^ value borrowed here\
    \ after move\n   |      |\n   |      value moved here\n\nerror: aborting due to\
    \ previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut res = String::new();\n \
    \   for ch in s.chars() {\n        if !c.contains(ch) {\n            res.push(ch);\n\
    \        }\n    }\n    (res, res == res.chars().rev().collect::<String>())\n}\n\
    \nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n  --> /tmp/tmpr_7x53eu.rs:14:11\n\
    \   |\n8  |     let mut res = String::new();\n   |         ------- move occurs\
    \ because `res` has type `String`, which does not implement the `Copy` trait\n\
    ...\n14 |     (res, res == res.chars().rev().collect::<String>())\n   |      ---\
    \  ^^^ value borrowed here after move\n   |      |\n   |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s = s.chars().collect::<Vec<_>>();\n\
    \    let mut c = c.chars().collect::<Vec<_>>();\n    s.retain(|s| !c.contains(s));\n\
    \    (s.iter().collect(), s.iter().rev().eq(s.iter()))\n}\n\nfn main() {\n   \
    \ let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let remove = |s: &String, c: &String|\
    \ {\n        let mut chars = c.chars();\n        s.chars().filter(|i| chars.find(|&j|\
    \ j == *i).is_none()).collect()\n    };\n    let reversed = remove(&s, &c);\n\
    \    let s_rev = reversed.chars().rev().collect::<String>();\n    (reversed, s_rev\
    \ == reversed)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for the closure `fn(&String, &String)\
    \ -> _`\n  --> /tmp/tmpm4f2z2sc.rs:13:17\n   |\n13 |     let s_rev = reversed.chars().rev().collect::<String>();\n\
    \   |                 ^^^^^^^^ cannot infer type\n   |\n   = note: type must be\
    \ known at this point\nhelp: give this closure an explicit return type without\
    \ `_` placeholders\n   |\n8  |     let remove = |s: &String, c: &String| -> _\
    \ {\n   |                                           ++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    let mut filtered: Vec<char>\
    \ = s.clone().into_iter().filter(|x| !c.contains(x)).collect();\n    filtered.reverse();\n\
    \    let s: String = s.into_iter().filter(|x| !c.contains(x)).collect();\n   \
    \ (s, s == filtered.into_iter().collect())\n}\n\nfn main() {\n    let candidate\
    \ = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"\
    ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmpzx9dldph.rs:13:11\n\
    \   |\n13 |     (s, s == filtered.into_iter().collect())\n   |           ^^ cannot\
    \ infer type\n   |\n   = note: cannot satisfy `String: PartialEq<_>`\nhelp: consider\
    \ specifying the type argument in the method call\n   |\n13 |     (s, s == filtered.into_iter().collect::<B>())\n\
    \   |                                          +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s_chars: Vec<char> = s.chars().collect();\n\
    \    let c_chars: Vec<char> = c.chars().collect();\n    let mut result_str = String::new();\n\
    \    for char in s_chars {\n        if !c_chars.contains(&char) {\n          \
    \  result_str.push(char);\n        }\n    }\n    let mut result_str_chars: Vec<char>\
    \ = result_str.chars().collect();\n    result_str_chars.reverse();\n    let result_str_rev:\
    \ String = result_str_chars.into_iter().collect();\n    (result_str, result_str\
    \ == result_str_rev)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `result_str`\n  --> /tmp/tmpxt76x0ws.rs:19:18\n\
    \   |\n10 |     let mut result_str = String::new();\n   |         --------------\
    \ move occurs because `result_str` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n19 |     (result_str, result_str == result_str_rev)\n\
    \   |      ----------  ^^^^^^^^^^ value borrowed here after move\n   |      |\n\
    \   |      value moved here\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 0
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut deleted_string = String::new();\n\
    \    for ch in s.chars() {\n        if !c.contains(ch) {\n            deleted_string.push(ch);\n\
    \        }\n    }\n    let result = deleted_string == deleted_string.chars().rev().collect::<String>();\n\
    \    (deleted_string, result)\n}\n\nfn main() {\n    let candidate = reverse_delete;\n\
    \    assert_eq!(candidate(String::from(\"abcde\"), String::from(\"ae\")), (String::from(\"\
    bcd\"), false));\n    assert_eq!(candidate(String::from(\"abcdef\"), String::from(\"\
    b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659822479
- exit_code: 101
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    unimplemented!()\n}\n\nfn main()\
    \ {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''not implemented'', /tmp/tmphm90th73.rs:8:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659822477
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut result = String::new();\n\
    \    for symbol in s.chars() {\n        if !c.contains(symbol) {\n           \
    \ result.push(symbol);\n        }\n    }\n    return (result, is_palindrome(&result));\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindrome` in this scope\n  -->\
    \ /tmp/tmpb65ptxnz.rs:14:21\n   |\n14 |     return (result, is_palindrome(&result));\n\
    \   |                     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let res = s.chars().filter(|&s|\
    \ !c.contains(s)).collect::<String>();\n    (res, res == res.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n --> /tmp/tmp3uzxzbx7.rs:9:11\n\
    \  |\n8 |     let res = s.chars().filter(|&s| !c.contains(s)).collect::<String>();\n\
    \  |         --- move occurs because `res` has type `String`, which does not implement\
    \ the `Copy` trait\n9 |     (res, res == res.chars().rev().collect::<String>())\n\
    \  |      ---  ^^^ value borrowed here after move\n  |      |\n  |      value\
    \ moved here\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    let c: Vec<char> = c.chars().collect();\n    s.retain(|&x| !c.contains(&x));\n\
    \    let s: String = s.into_iter().collect();\n    (s, s == s.chars().rev().collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"\
    abcde\"), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n  --> /tmp/tmpauzvhnjk.rs:12:9\n\
    \   |\n11 |     let s: String = s.into_iter().collect();\n   |         - move\
    \ occurs because `s` has type `String`, which does not implement the `Copy` trait\n\
    12 |     (s, s == s.chars().rev().collect::<String>())\n   |      -  ^ value borrowed\
    \ here after move\n   |      |\n   |      value moved here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659822479
- exit_code: 1
  program: "/// Task\n/// We are given two strings s and c, you have to deleted all\
    \ the characters in s that are equal to any character in c\n/// then check if\
    \ the result string is palindrome.\n/// A string is called palindrome if it reads\
    \ the same backward as forward.\n/// You should return a tuple containing the\
    \ result string and True/False for the check.\n/// Example\nfn reverse_delete(s:\
    \ String, c: String) -> (String, bool) {\n    let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \    (s, s == s.chars().rev().collect::<String>())\n}\n\nfn main() {\n    let\
    \ candidate = reverse_delete;\n    assert_eq!(candidate(String::from(\"abcde\"\
    ), String::from(\"ae\")), (String::from(\"bcd\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdef\"), String::from(\"b\")), (String::from(\"acdef\"), false));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"ab\")), (String::from(\"cdedc\"), true));\n    assert_eq!(candidate(String::from(\"\
    dwik\"), String::from(\"w\")), (String::from(\"dik\"), false));\n    assert_eq!(candidate(String::from(\"\
    a\"), String::from(\"a\")), (String::from(\"\"), true));\n    assert_eq!(candidate(String::from(\"\
    abcdedcba\"), String::from(\"\")), (String::from(\"abcdedcba\"), true));\n   \
    \ assert_eq!(candidate(String::from(\"abcdedcba\"), String::from(\"v\")), (String::from(\"\
    abcdedcba\"), true));\n    assert_eq!(candidate(String::from(\"vabba\"), String::from(\"\
    v\")), (String::from(\"abba\"), true));\n    assert_eq!(candidate(String::from(\"\
    mamma\"), String::from(\"mia\")), (String::from(\"\"), true));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `s`\n --> /tmp/tmpj8s7n50a.rs:9:9\n\
    \  |\n8 |     let s = s.chars().filter(|&x| !c.contains(x)).collect::<String>();\n\
    \  |         - move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n9 |     (s, s == s.chars().rev().collect::<String>())\n  |\
    \      -  ^ value borrowed here after move\n  |      |\n  |      value moved here\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659822477
