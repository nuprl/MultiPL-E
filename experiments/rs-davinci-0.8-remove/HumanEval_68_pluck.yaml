name: HumanEval_68_pluck
language: rs
prompt: "/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Constraints:\n/// * 1 <= nodes.length <= 10000\n/// * 0 <= node.value\n\
  fn pluck(arr: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = pluck;\n    assert_eq!(candidate(vec![4,\
  \ 2, 3]), vec![2, 1]);\n    assert_eq!(candidate(vec![1, 2, 3]), vec![2, 1]);\n\
  \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5,\
  \ 0, 3, 0, 4, 2]), vec![0, 1]);\n    assert_eq!(candidate(vec![1, 2, 3, 0, 5, 3]),\
  \ vec![0, 3]);\n    assert_eq!(candidate(vec![5, 4, 8, 4, 8]), vec![4, 1]);\n  \
  \  assert_eq!(candidate(vec![7, 6, 7, 1]), vec![6, 1]);\n    assert_eq!(candidate(vec![7,\
  \ 9, 7, 1]), Vec::<isize>::new());\n}\n"
completions: ["    let mut even_arr: Vec<isize> = arr.iter().filter(|&x| x % 2 ==\
    \ 0).cloned().collect();\n    even_arr.sort();\n    if even_arr.len() > 0 {\n\
    \        vec![even_arr[0], arr.iter().position(|&x| x == even_arr[0]).unwrap()\
    \ as isize]\n    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut min = arr.get(0).unwrap_or(&0).clone();\n    for\
    \ i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            evens.push(arr[i]);\n\
    \            if arr[i] < min {\n                min = arr[i];\n            }\n\
    \        }\n    }\n    if evens.len() == 0 {\n        vec![]\n    } else {\n \
    \       vec![min, evens.iter().position(|&x| x == min).unwrap() as isize]\n  \
    \  }", "    let mut min_even = std::isize::MAX;\n    let mut min_even_idx = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < min_even {\n            min_even = val;\n            min_even_idx = idx as\
    \ isize;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_even_idx]", "    let mut smallest_even\
    \ = std::isize::MAX;\n    let mut smallest_even_index = std::isize::MAX;\n   \
    \ for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 && v < &smallest_even\
    \ {\n            smallest_even = *v;\n            smallest_even_index = i as isize;\n\
    \        }\n    }\n    if smallest_even == std::isize::MAX {\n        vec![]\n\
    \    } else {\n        vec![smallest_even, smallest_even_index]\n    }", "   \
    \ // Your code here!\n    vec![]", "    let mut lowest = None;\n    let mut lowest_idx\
    \ = None;\n    for (idx, val) in arr.iter().enumerate() {\n        if *val % 2\
    \ == 0 {\n            match lowest {\n                None => {\n            \
    \        lowest = Some(*val);\n                    lowest_idx = Some(idx);\n \
    \               }\n                Some(v) => {\n                    if v > *val\
    \ {\n                        lowest = Some(*val);\n                        lowest_idx\
    \ = Some(idx);\n                    }\n                }\n            }\n    \
    \    }\n    }\n    match lowest_idx {\n        None => vec![],\n        Some(i)\
    \ => vec![lowest.unwrap(), i as isize],\n    }", "    let evens: Vec<isize> =\
    \ arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let min = evens.iter().min().unwrap();\n\
    \    let min_index = arr.iter().position(|x| x == min).unwrap();\n    vec![*min,\
    \ min_index as isize]", "    if arr.is_empty() {\n        return vec![];\n   \
    \ }\n    // TODO:\n    vec![]", "    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut smallest = arr[0];\n    let mut smallest_index = 0;\n    for\
    \ (i, item) in arr.iter().enumerate() {\n        if *item % 2 == 0 && *item <\
    \ smallest {\n            smallest = *item;\n            smallest_index = i;\n\
    \        }\n    }\n    if smallest % 2 == 0 {\n        vec![smallest, smallest_index\
    \ as isize]\n    } else {\n        vec![]\n    }", "    // let mut result = vec![];\n\
    \    // let mut evens = vec![];\n    // for (idx, val) in arr.iter().enumerate()\
    \ {\n    //     if *val % 2 == 0 {\n    //         evens.push((idx, *val));\n\
    \    //     }\n    // }\n    // evens.sort_by(|a, b| a.1.cmp(&b.1));\n    // match\
    \ evens.first() {\n    //     Some(val) => result.push(val.1),\n    //     None\
    \ => return vec![],\n    // }\n    // match evens.first() {\n    //     Some(val)\
    \ => result.push(val.0 as isize),\n    //     None => return vec![],\n    // }\n\
    \    // result\n    let mut result = vec![];\n    let mut evens = vec![];\n  \
    \  for (idx, val) in arr.iter().enumerate() {\n        if *val % 2 == 0 {\n  \
    \          evens.push((idx, *val));\n        }\n    }\n    evens.sort_by(|a, b|\
    \ a.1.cmp(&b.1));\n    match evens.first() {\n        Some(val) => result.push(val.1),\n\
    \        None => return vec![],\n    }\n    match evens.first() {\n        Some(val)\
    \ => result.push(val.0 as isize),\n        None => return vec![],\n    }\n   \
    \ result", "    // pluck() is implemented in rust/src/bin/exercism/pluck.rs\n\
    \    unimplemented!()", "    if arr.is_empty() {\n        return vec![];\n   \
    \ }\n    let mut even = vec![];\n    for (i, &item) in arr.iter().enumerate()\
    \ {\n        if item % 2 == 0 {\n            even.push((item, i as isize));\n\
    \        }\n    }\n    if even.is_empty() {\n        return vec![];\n    }\n \
    \   even.sort_by(|a, b| {\n        a.0.cmp(&b.0)\n            .then_with(|| a.1.cmp(&b.1))\n\
    \    });\n    let (value, index) = even[0];\n    vec![value, index]", "    if\
    \ arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_index = std::isize::MAX;\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < &min_even {\n            min_even = *v;\n  \
    \          min_index = i as isize;\n        }\n    }\n    if min_even == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![min_even, min_index]", "    let mut\
    \ even_vec: Vec<isize> = Vec::new();\n    for i in 0..arr.len() {\n        if\
    \ arr[i]%2 == 0 {\n            even_vec.push(arr[i]);\n        }\n    }\n    if\
    \ even_vec.len() == 0 {\n        vec![]\n    } else {\n        let mut min_even\
    \ = even_vec[0];\n        let mut min_index = 0;\n        for i in 0..even_vec.len()\
    \ {\n            if even_vec[i] < min_even {\n                min_even = even_vec[i];\n\
    \                min_index = i;\n            }\n        }\n        vec![min_even,\
    \ min_index as isize]\n    }", "    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut min_i = None;\n    let mut min_v = None;\n    for (i, x) in\
    \ arr.iter().enumerate() {\n        if x % 2 == 0 {\n            if min_v.is_none()\
    \ || *x < min_v.unwrap() {\n                min_v = Some(*x);\n              \
    \  min_i = Some(i);\n            }\n        }\n    }\n    if min_v.is_none() {\n\
    \        return vec![];\n    }\n    return vec![min_v.unwrap(), min_i.unwrap()\
    \ as isize];", "    let (mut best_even, mut best_idx) = (None, None);\n    for\
    \ (idx, &v) in arr.iter().enumerate() {\n        if v % 2 == 0 {\n           \
    \ if best_even.is_none() || v < best_even.unwrap() {\n                best_even\
    \ = Some(v);\n                best_idx = Some(idx);\n            }\n        }\n\
    \    }\n    match (best_even, best_idx) {\n        (Some(v), Some(idx)) => vec![v,\
    \ idx as isize],\n        _ => vec![],\n    }", "    // the standard library provides\
    \ a min_by_key() function which takes a key, and then an iterator.\n    // the\
    \ key is how the min value is determined, and it can be a closure.\n    // in\
    \ this case, the key is determining the min by the tuple (value, index)\n\n  \
    \  // the challenge here is determining the \"type\" of arr\n    // I think we\
    \ could statically assert that arr is a vector of isize,\n    // but then we'd\
    \ need to convert that to an iterator and that might not be easy\n    // we could\
    \ write an iterator for it, but that seems like overkill\n    // we can also work\
    \ with &arr and then use .iter()\n    // the end result is the same (or at least\
    \ it should be)\n\n    // let mut it = arr.iter();\n\n    // arr.iter().min_by_key(|&x|\
    \ (x, 0))\n\n    // .min_by_key(|&x| (x % 2, x, 0))\n    // first, we want to\
    \ filter so that we only get even values\n    // then we want to take the min\
    \ of those\n\n    // we need the index of the min value, but min_by_key only lets\
    \ us specify 1 tuple of key\n    // so we need to pass in a tuple that also contains\
    \ the index\n\n    let mut it = arr.iter();\n    let (mut evens, mut odds): (Vec<isize>,\
    \ Vec<isize>) = (vec![], vec![]);\n\n    // let evens = vec![];\n    // let odds\
    \ = vec![];\n\n    for i in it {\n        if i % 2 == 0 {\n            evens.push(*i);\n\
    \        } else {\n            odds.push(*i);\n        }\n    }\n\n    if evens.len()\
    \ != 0 {\n        // let evens_tuple = evens.iter().map(|x| (x,0)).collect();\n\
    \        // let evens_tuple = evens.iter().map(|x| (x,0)).collect();\n       \
    \ let min_even_index = evens.iter().fold(0, |a, &b| std::cmp::min(a, b));\n  \
    \      vec![min_even_index]", "    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut plucked_node: isize = -1;\n    let mut min_even: isize = std::isize::MAX;\n\
    \    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 && arr[i] < min_even\
    \ {\n            min_even = arr[i];\n            plucked_node = i as isize;\n\
    \        }\n    }\n    if plucked_node == -1 {\n        return vec![];\n    }\n\
    \    vec![min_even, plucked_node]", "    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut smallest_even_value: isize = 10001;\n    let mut smallest_even_index:\
    \ usize = 0;\n    for (i, v) in arr.iter().enumerate() {\n        if *v > 0 &&\
    \ *v % 2 == 0 && *v < smallest_even_value {\n            smallest_even_value =\
    \ *v;\n            smallest_even_index = i;\n        }\n    }\n    if smallest_even_value\
    \ == 10001 {\n        return vec![];\n    }\n    vec![smallest_even_value, smallest_even_index\
    \ as isize]", "    arr.iter()\n        .enumerate()\n        .filter(|&(_, &x)|\
    \ x % 2 == 0)\n        .min_by_key(|&(_, x)| x)\n        .map(|(index, &x)| vec![x,\
    \ index as isize])\n        .unwrap_or_else(|| vec![])", "    let even_node_indices:\
    \ Vec<usize> = arr\n        .iter()\n        .enumerate()\n        .filter(|(_,\
    \ &x)| x % 2 == 0)\n        .map(|(i, _)| i)\n        .collect();\n    let valid_indices\
    \ = if even_node_indices.is_empty() {\n        vec![]\n    } else {\n        even_node_indices\n\
    \    };\n    // find min value\n    let min_value: isize = arr\n        .iter()\n\
    \        .enumerate()\n        .filter(|&(i, _)| valid_indices.contains(&i))\n\
    \        .map(|(_, x)| *x)\n        .min()\n        .unwrap();\n    // find min\
    \ index\n    let min_index: usize = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|&(i, _)| valid_indices.contains(&i))\n        .map(|(i, x)|\
    \ (i, x))\n        .filter(|(_, x)| *x == min_value)\n        .map(|(i, _)| i)\n\
    \        .min()\n        .unwrap();\n    vec![min_value, min_index as isize]",
  "    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut result = vec![];\n\
    \    let mut min_even = std::isize::MAX;\n    let mut min_even_i = 0;\n    for\
    \ (i, x) in arr.iter().enumerate() {\n        if (x % 2) == 0 {\n            if\
    \ *x < min_even {\n                min_even = *x;\n                min_even_i\
    \ = i;\n            }\n        }\n    }\n    if min_even == std::isize::MAX {\n\
    \        return vec![];\n    }\n    result.push(min_even);\n    result.push(min_even_i\
    \ as isize);\n    result", "    let mut result = Vec::new();\n    let mut min\
    \ = 100000000;\n    let mut index = 0;\n    for (i, el) in arr.iter().enumerate()\
    \ {\n        if *el % 2 == 0 && *el < min {\n            min = *el;\n        \
    \    index = i;\n        }\n    }\n    if min == 100000000 {\n        return result;\n\
    \    }\n    result.push(min);\n    result.push(index as isize);\n    result",
  '    unimplemented!();', "    if arr.len() > 10000 {\n        return vec![];\n \
    \   }\n    let mut evens: Vec<(isize, usize)> = arr.iter().enumerate().filter(|&(idx,\
    \ val)| {\n        val % 2 == 0\n    }).collect();\n    evens.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    if evens.len() == 0 {\n        return vec![];\n    }\n    let idx = evens[0].1;\n\
    \    let val = arr[idx];\n    vec![val, idx as isize]", '    unimplemented!()',
  "    if arr.len() == 0 {\n        return vec![];\n    }\n    let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n    evens.sort();\n\
    \    let index = arr.iter().position(|x| x == evens[0]).unwrap();\n    vec![evens[0],\
    \ index as isize]", "    if arr.len() == 0 {\n        vec![]\n    } else {\n \
    \       let mut min = 10_000_001;\n        let mut result = vec![-1, -1];\n  \
    \      for (i, &n) in arr.iter().enumerate() {\n            if n < min && n >\
    \ 0 && n % 2 == 0 {\n                min = n;\n                result = vec![n,\
    \ i as isize];\n            }\n        }\n        if result[0] == -1 {\n     \
    \       vec![]\n        } else {\n            result\n        }\n    }", "   \
    \ let mut res = vec![];\n    let mut curr_min = isize::max_value();\n    let mut\
    \ curr_idx = -1;\n    for (idx, n) in arr.iter().enumerate() {\n        if n %\
    \ 2 == 0 && n < &curr_min {\n            curr_min = *n;\n            curr_idx\
    \ = idx as isize;\n        }\n    }\n    if curr_idx != -1 {\n        res.push(curr_min);\n\
    \        res.push(curr_idx);\n    }\n    res", "    // NOTE: you can use 0 isize\
    \ as a sentinel value or use Option<isize>\n    let mut smallest = isize::max_value();\n\
    \    let mut smallest_idx = isize::max_value();\n    for (idx, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < smallest {\n            smallest = x;\n    \
    \        smallest_idx = idx as isize;\n        }\n    }\n    if smallest != isize::max_value()\
    \ {\n        vec![smallest, smallest_idx]\n    } else {\n        vec![]\n    }",
  "    // set up min and min_index of even element\n    let mut min = std::isize::MAX;\n\
    \    let mut min_index = std::isize::MAX;\n    // loop through array\n    for\
    \ (index, value) in arr.iter().enumerate() {\n        // if the current value\
    \ is even and less than the current min\n        if value % 2 == 0 && value <\
    \ &min {\n            // set min and min_index to the current value and index\n\
    \            min = *value;\n            min_index = index as isize;\n        }\n\
    \    }\n    // return the min and its index as a vector\n    if min == std::isize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![min, min_index]\n    }", "   \
    \ let mut smallest = None;\n    let mut smallest_index = 0;\n    for (index, v)\
    \ in arr.iter().enumerate() {\n        if *v % 2 == 0 {\n            if smallest.is_none()\
    \ || *v < smallest.unwrap() {\n                smallest = Some(*v);\n        \
    \        smallest_index = index;\n            }\n        }\n    }\n    match smallest\
    \ {\n        Some(n) => vec![n, smallest_index as isize],\n        None => vec![],\n\
    \    }", "    // if the array is empty, return an empty vector\n    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n\n    // create a vector to store all the\
    \ even numbers in the array\n    let mut even_numbers: Vec<isize> = vec![];\n\n\
    \    // iterate through the array and store all the even numbers in the vector\n\
    \    for (i, e) in arr.iter().enumerate() {\n        if e % 2 == 0 {\n       \
    \     even_numbers.push(*e);\n        }\n    }\n\n    // if there are no even\
    \ numbers return an empty vector\n    if even_numbers.is_empty() {\n        return\
    \ vec![];\n    }\n\n    // find the smallest even number in the array\n    let\
    \ smallest_even_number = even_numbers.iter().min().unwrap();\n\n    // iterate\
    \ through the original array and find the index of the smallest even number\n\
    \    for (i, e) in arr.iter().enumerate() {\n        if e == smallest_even_number\
    \ {\n            return vec![*e, i as isize];\n        }\n    }\n\n    // if no\
    \ even numbers are found, return an empty vector\n    vec![]", "    let mut min\
    \ = arr.iter().filter(|x| x % 2 == 0).min();\n    match min {\n        Some(x)\
    \ => vec![x, *arr.iter().position(|y| *y == *x).unwrap() as isize],\n        None\
    \ => vec![],\n    }", "    let mut smallest_even = isize::max_value();\n    let\
    \ mut index_of_smallest_even = usize::max_value();\n    for (i, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &smallest_even {\n            smallest_even\
    \ = *value;\n            index_of_smallest_even = i;\n        }\n    }\n    if\
    \ smallest_even == isize::max_value() {\n        vec![]\n    } else {\n      \
    \  vec![smallest_even, index_of_smallest_even as isize]\n    }", "    let mut\
    \ smallest_even_pos = -1;\n    let mut smallest_even_val = -1;\n    for (pos,\
    \ &val) in arr.iter().enumerate() {\n        if val % 2 == 0 {\n            if\
    \ smallest_even_val == -1 || val < smallest_even_val {\n                smallest_even_val\
    \ = val;\n                smallest_even_pos = pos as isize;\n            }\n \
    \       }\n    }\n    if smallest_even_pos == -1 {\n        return vec![];\n \
    \   }\n    vec![smallest_even_val, smallest_even_pos]", "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut even_idx = -1;\n    let mut even_val\
    \ = std::isize::MAX;\n    for i in 0..arr.len() {\n        if arr[i] >= 0 && arr[i]\
    \ % 2 == 0 && arr[i] < even_val {\n            even_idx = i as isize;\n      \
    \      even_val = arr[i];\n        }\n    }\n    if even_idx < 0 {\n        return\
    \ vec![];\n    }\n    vec![even_val, even_idx]", "    let mut acc = arr.iter().enumerate().filter(|(_,\
    \ &x)| x % 2 == 0);\n    let min = acc.clone().map(|(_, &x)| x).min();\n    match\
    \ min {\n        Some(min) => acc.filter(|(_, &x)| x == min).map(|(x, _)| x as\
    \ isize).min().unwrap_or(0),\n        None => 0,\n    }", "    let mut smallest_even_value:\
    \ Option<isize> = None;\n    let mut smallest_even_index: Option<usize> = None;\n\
    \    for (i, value) in arr.iter().enumerate() {\n        if *value % 2 == 0 {\n\
    \            match smallest_even_value {\n                Some(v) => {\n     \
    \               if *value < v {\n                        smallest_even_value =\
    \ Some(*value);\n                        smallest_even_index = Some(i);\n    \
    \                }\n                }\n                None => {\n           \
    \         smallest_even_value = Some(*value);\n                    smallest_even_index\
    \ = Some(i);\n                }\n            }\n        }\n    }\n    match (smallest_even_value,\
    \ smallest_even_index) {\n        (Some(value), Some(index)) => vec![value, index\
    \ as isize],\n        _ => vec![],\n    }", "    let mut arr = arr;\n    arr.sort();\n\
    \    arr.dedup();\n    arr.into_iter()\n        .filter(|x| x % 2 == 0)\n    \
    \    .take(1)\n        .map(|x| x as isize)\n        .collect()", "    // The\
    \ idea is to recursively go over the array and find the smallest even value.\n\
    \    // The function takes 2 arguments:\n    // * arr: current branch of the tree\n\
    \    // * index: current index in the array\n    // The function returns:\n  \
    \  // * [value, index] if there is an even value in the branch\n    // * [0, 0]\
    \ if the branch is empty (we return 0 and 0 because we want a reference to a vector)\n\
    \    // The following code is an approach in which we don't use a reference and\
    \ thus return a vector\n    fn helper(arr: Vec<isize>, index: usize) -> Vec<isize>\
    \ {\n        let len = arr.len();\n        if len == 0 {\n            return vec![0,\
    \ 0];\n        }\n        let result = arr.iter().fold(vec![std::i64::MAX, 0],\
    \ |acc, &x| {\n            if x % 2 == 0 && x < acc[0] {\n                vec![x\
    \ as i64, index]\n            } else {\n                acc\n            }\n \
    \       });\n        // we don't need to check all the elements of the tree\n\
    \        // (we could do this, but it would require another helper function)\n\
    \        // so we just skip every second element and check only the branches\n\
    \        for i in 0..len {\n            if i % 2 == 0 {\n                let branch\
    \ = helper(arr[i..].to_vec(), index + i);\n                if branch[0] < result[0]\
    \ {\n                    return branch;\n                }\n            }\n  \
    \      }\n        result\n    }\n    // a helper function to convert a vector\
    \ of i64 to a vector of isize\n    fn convert(arr: Vec<i64>) -> Vec<isize> {\n\
    \        arr.iter().map(|&x| x as isize).collect()\n    }\n    convert(helper(arr,\
    \ 0))", "    let mut result = Vec::new();\n    let mut min_even_value: isize =\
    \ std::isize::MAX;\n    let mut min_even_index: usize = 0;\n    let mut i: usize\
    \ = 0;\n    for n in arr {\n        if n >= 0 && n % 2 == 0 && n < min_even_value\
    \ {\n            min_even_value = n;\n            min_even_index = i;\n      \
    \  }\n        i += 1;\n    }\n    if min_even_value != std::isize::MAX {\n   \
    \     result.push(min_even_value);\n        result.push(min_even_index as isize);\n\
    \    }\n    result", "    let mut r = arr.iter().enumerate().skip_while(|(_, &n)|\
    \ n % 2 != 0).min_by_key(|(_, &n)| n);\n    r.map(|(i, &n)| vec![n, i as isize]).unwrap_or(vec![])",
  "    let mut even = None;\n    let mut lowest_index = std::usize::MAX;\n    for\
    \ (i, x) in arr.iter().enumerate() {\n        if let Some(even_val) = even {\n\
    \            if x % 2 == 0 && x < &even_val {\n                even = Some(*x);\n\
    \                lowest_index = i;\n            }\n        } else if x % 2 ==\
    \ 0 {\n            even = Some(*x);\n            lowest_index = i;\n        }\n\
    \    }\n    match even {\n        Some(val) => vec![val, lowest_index as isize],\n\
    \        None => vec![],\n    }", "    arr.iter()\n        .enumerate()\n    \
    \    .filter(|(_, n)| n.is_even())\n        .min_by_key(|(_, n)| n)\n        .map(|(i,\
    \ v)| vec![*v, i as isize])\n        .unwrap_or_else(|| vec![])", "    let mut\
    \ smallest_idx = std::usize::MAX;\n    let mut smallest_val = std::isize::MAX;\n\
    \    for (idx, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < smallest_val {\n            smallest_idx = idx;\n            smallest_val\
    \ = val;\n        }\n    }\n    if smallest_idx == std::usize::MAX {\n       \
    \ vec![]\n    } else {\n        vec![smallest_val, smallest_idx as isize]\n  \
    \  }", "    arr.iter()\n        .enumerate()\n        .filter(|(_, &n)| n % 2\
    \ == 0)\n        .min_by_key(|&(_, n)| n)\n        .map(|(i, &n)| vec![n, i as\
    \ isize])\n        .unwrap_or_else(|| vec![])", "    if arr.len() > 10000 {\n\
    \        panic!(\"invalid length\");\n    }\n    let arr: Vec<_> = arr.into_iter().enumerate().filter(|(_,\
    \ v)| *v % 2 == 0).collect();\n    match arr.len() {\n        0 => vec![],\n \
    \       1 => vec![arr[0].1, arr[0].0 as isize],\n        _ => {\n            let\
    \ (min_pos, min_value) = arr.iter().fold((0, arr[0].1), |(pos, min), (p, v)| {\n\
    \                if *v < min {\n                    (*p, *v)\n               \
    \ } else {\n                    (pos, min)\n                }\n            });\n\
    \            vec![min_value, min_pos as isize]\n        }\n    }", "    arr.iter()\n\
    \        .filter(|n| n % 2 == 0)\n        .min()\n        .map(|n| vec![*n, arr.iter().position(|&x|\
    \ x == *n).unwrap() as isize])\n        .unwrap_or(vec![])", "    let mut evens:\
    \ Vec<isize> = arr.iter().filter(|x| (x & 1) == 0).cloned().collect();\n    evens.sort();\n\
    \    match evens.first() {\n        Some(x) => {\n            let index = arr.iter().position(|&i|\
    \ i == *x).unwrap();\n            vec![*x, index as isize]\n        }\n      \
    \  None => vec![],\n    }", "    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut evens: Vec<isize> = arr.into_iter().filter(|x| x % 2 == 0).collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let smalest_even = evens[0];\n    match arr.iter().position(|x| *x == smalest_even)\
    \ {\n        Some(p) => vec![smalest_even, p as isize],\n        None => vec![],\n\
    \    }", "    let mut evens: Vec<isize> = Vec::new();\n    let mut index: usize\
    \ = 0;\n    for n in arr {\n        if n % 2 == 0 {\n            evens.push(n);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let mut smallest = evens[0];\n    for i in 0..evens.len() {\n        if evens[i]\
    \ < smallest {\n            smallest = evens[i];\n            index = i;\n   \
    \     }\n    }\n    vec![smallest, index as isize]", "    fn pluck_h(arr: &[isize],\
    \ r: &mut Vec<isize>) {\n        if arr.is_empty() {\n            return;\n  \
    \      }\n\n        if arr[0] % 2 == 0 {\n            if r.is_empty() || arr[0]\
    \ < r[0] {\n                r.clear();\n                r.push(arr[0]);\n    \
    \            r.push(0);\n            }\n        }\n\n        for i in 1..arr.len()\
    \ {\n            pluck_h(&arr[i..], r);\n            if !r.is_empty() {\n    \
    \            r[1] += i as isize;\n            }\n        }\n    }\n\n    let mut\
    \ r = Vec::new();\n    pluck_h(&arr, &mut r);\n    r", "    let mut even_nodes:\
    \ Vec<(isize, usize)> = vec![];\n    for (i, n) in arr.iter().enumerate() {\n\
    \        if n % 2 == 0 {\n            even_nodes.push((*n, i));\n        }\n \
    \   }\n    even_nodes.sort();\n    match even_nodes.first() {\n        Some(n)\
    \ => vec![n.0, n.1 as isize],\n        None => vec![],\n    }", "    let mut evens:\
    \ Vec<(isize, usize)> = Vec::new();\n    for (index, elem) in arr.iter().enumerate()\
    \ {\n        if *elem % 2 == 0 {\n            evens.push((*elem, index));\n  \
    \      }\n    }\n    evens.sort();\n    match evens.first() {\n        Some(pair)\
    \ => vec![pair.0, pair.1 as isize],\n        None => vec![],\n    }", "    let\
    \ mut evens: Vec<isize> = arr.iter().filter(|&n| n % 2 == 0).map(|&n| n).collect();\n\
    \    let mut smallest_idx = 0;\n    if evens.len() > 0 {\n        evens.sort();\n\
    \        let smallest = evens[0];\n        smallest_idx = arr.iter().position(|&n|\
    \ n == smallest).unwrap() as isize;\n    }\n    vec![evens[0], smallest_idx]",
  "    let mut i: isize = 0;\n    let mut j: isize = 0;\n    let mut small_val: isize\
    \ = -1;\n    for x in &arr {\n        if x % 2 == 0 {\n            if small_val\
    \ == -1 {\n                small_val = *x;\n                j = i;\n         \
    \   } else if *x < small_val {\n                small_val = *x;\n            \
    \    j = i;\n            }\n        }\n        i += 1;\n    }\n    if small_val\
    \ == -1 {\n        return vec![];\n    }\n    vec![small_val, j]", "    let mut\
    \ min = std::isize::MAX;\n    let mut min_index = arr.len();\n    let mut node\
    \ = 0;\n    let mut i = 0;\n    for el in arr {\n        if el % 2 == 0 && el\
    \ < min {\n            min = el;\n            min_index = i;\n            node\
    \ = el;\n        }\n        i += 1;\n    }\n    if min != std::isize::MAX {\n\
    \        vec![node, min_index as isize]\n    } else {\n        vec![]\n    }",
  "    if arr.is_empty() {\n        return vec![];\n    }\n    let mut smallest_value\
    \ = isize::max_value();\n    let mut smallest_index = isize::max_value();\n  \
    \  for (i, v) in arr.iter().enumerate() {\n        if *v % 2 == 0 && *v < smallest_value\
    \ {\n            smallest_value = *v;\n            smallest_index = i as isize;\n\
    \        }\n    }\n    if smallest_value == isize::max_value() {\n        return\
    \ vec![];\n    }\n    vec![smallest_value, smallest_index]", "    let mut even_smallest:\
    \ Option<isize> = None;\n    let mut even_smallest_index: Option<usize> = None;\n\
    \    for (i, v) in arr.iter().enumerate() {\n        if v % 2 == 0 {\n       \
    \     if even_smallest.is_none() {\n                even_smallest = Some(*v);\n\
    \                even_smallest_index = Some(i);\n            } else if *v < even_smallest.unwrap()\
    \ {\n                even_smallest = Some(*v);\n                even_smallest_index\
    \ = Some(i);\n            }\n        }\n    }\n    match (even_smallest, even_smallest_index)\
    \ {\n        (Some(v), Some(i)) => vec![v, i as isize],\n        (_, _) => vec![],\n\
    \    }", "    let mut evens: Vec<isize> = arr.iter().filter(|x| x % 2 == 0).collect();\n\
    \    evens.sort();\n    evens.dedup();\n    if evens.is_empty() {\n        Vec::new()\n\
    \    } else {\n        let even = evens[0];\n        let mut result: Vec<isize>\
    \ = Vec::new();\n        for i in 0..arr.len() {\n            if arr[i] == even\
    \ {\n                result.push(even);\n                result.push(i as isize);\n\
    \                break;\n            }\n        }\n        result\n    }", " \
    \   if arr.is_empty() {\n        vec![]\n    } else {\n        let mut output:\
    \ Vec<isize> = vec![arr[0], 0];\n        for (i, &val) in arr.iter().enumerate()\
    \ {\n            if val % 2 == 0 && val < output[0] {\n                output[0]\
    \ = val;\n                output[1] = i as isize;\n            }\n        }\n\
    \        if output[0] % 2 != 0 {\n            vec![]\n        } else {\n     \
    \       output\n        }\n    }", "    let mut min_even: Option<isize> = None;\n\
    \    let mut min_even_i: Option<usize> = None;\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 {\n            if min_even.is_none() || x < min_even.unwrap()\
    \ {\n                min_even = Some(*x);\n                min_even_i = Some(i);\n\
    \            }\n        }\n    }\n    match (min_even, min_even_i) {\n       \
    \ (Some(m), Some(mi)) => vec![m, mi as isize],\n        _ => vec![],\n    }",
  "    let mut evens: Vec<(isize, usize)> = arr\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x % 2 == 0)\n        .collect();\n    evens.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    evens.first().map(|x| vec![x.0 as isize, x.1 as isize]).unwrap_or(vec![])",
  "    arr.iter()\n        .enumerate()\n        .filter(|(_, x)| x % 2 == 0)\n  \
    \      .min_by_key(|(_, x)| *x)\n        .map(|(i, x)| vec![*x, i as isize])\n\
    \        .unwrap_or_else(|| vec![])", "    arr.iter()\n        .enumerate()\n\
    \        .filter(|&(_, &x)| x % 2 == 0)\n        .min_by_key(|&(_, x)| x)\n  \
    \      .map(|(i, &v)| vec![v, i as isize])\n        .unwrap_or_else(|| vec![])",
  "    let mut min_idx = -1;\n    let mut min_val = -1;\n    for (idx, val) in arr.iter().enumerate()\
    \ {\n        if min_idx == -1 && *val % 2 == 0 {\n            min_idx = idx;\n\
    \            min_val = *val;\n        } else if min_idx != -1 && *val % 2 == 0\
    \ && *val < min_val {\n            min_idx = idx;\n            min_val = *val;\n\
    \        }\n    }\n    if min_idx == -1 {\n        vec![]\n    } else {\n    \
    \    vec![min_val, min_idx as isize]\n    }", "    if arr.is_empty() {\n     \
    \   return vec![];\n    }\n    let m = arr.iter().cloned().filter(|x| x % 2 ==\
    \ 0).fold(10001, |acc, el| std::cmp::min(acc, el));\n    if m == 10001 {\n   \
    \     return vec![];\n    }\n    let idx = arr.iter().position(|x| x == &m).unwrap();\n\
    \    vec![m, idx as isize]", "    let mut evens: Vec<isize> = Vec::new();\n  \
    \  for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            evens.push(arr[i]);\n\
    \        }\n    }\n    evens.sort();\n    let min_even = if evens.len() > 0 {\
    \ evens[0] } else { 0 };\n    let mut indices: Vec<usize> = Vec::new();\n    for\
    \ i in 0..arr.len() {\n        if arr[i] == min_even {\n            indices.push(i);\n\
    \        }\n    }\n    let min_index = indices[0];\n    vec![min_even, min_index\
    \ as isize]", "    let mut res = vec![];\n    if arr.is_empty() {\n        return\
    \ res;\n    }\n    let mut min = std::isize::MAX;\n    let mut min_idx = std::isize::MAX;\n\
    \    for (idx, elem) in arr.iter().enumerate() {\n        if elem % 2 == 0 &&\
    \ elem < &min {\n            min = *elem;\n            min_idx = idx as isize;\n\
    \        }\n    }\n    if min == std::isize::MAX {\n        return res;\n    }\n\
    \    res.push(min);\n    res.push(min_idx);\n    res", "    // Find the first\
    \ even number and its index\n    let mut res: Option<(isize, usize)> = None;\n\
    \    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n       \
    \     res = Some((*n, i));\n            break;\n        }\n    }\n    if let Some((n,\
    \ _)) = res {\n        // If we found an even number, find the smallest one\n\
    \        for (i, num) in arr.iter().enumerate() {\n            if num % 2 == 0\
    \ && num < &n {\n                res = Some((*num, i));\n            }\n     \
    \   }\n    }\n    // Transform the result into a Vec<isize>\n    match res {\n\
    \        Some((n, i)) => vec![n, i as isize],\n        None => vec![],\n    }",
  "    arr.iter()\n        .enumerate()\n        .filter(|(_, v)| v.rem_euclid(2)\
    \ == 0)\n        .min_by_key(|(_, v)| v)\n        .map(|(i, v)| vec![*v, i as\
    \ isize])\n        .unwrap_or_else(|| vec![])", "    if arr.is_empty() {\n   \
    \     return vec![];\n    }\n    let mut smallest_even = None;\n    let mut smallest_even_idx\
    \ = None;\n    for (idx, &node) in arr.iter().enumerate() {\n        if node %\
    \ 2 == 0 {\n            match smallest_even {\n                None => {\n   \
    \                 smallest_even = Some(node);\n                    smallest_even_idx\
    \ = Some(idx);\n                }\n                Some(ev) => {\n           \
    \         if node < ev {\n                        smallest_even = Some(node);\n\
    \                        smallest_even_idx = Some(idx);\n                    }\n\
    \                }\n            }\n        }\n    }\n    match smallest_even {\n\
    \        None => vec![],\n        Some(ev) => vec![ev, smallest_even_idx.unwrap()\
    \ as isize],\n    }", "    arr.iter()\n        .position(|&x| x % 2 == 0)\n  \
    \      .map(|ix| vec![arr[ix], ix as isize])\n        .unwrap_or_else(|| vec![])",
  "    let mut idx: usize = 0;\n    let mut plucked: Vec<isize> = vec![];\n    let\
    \ mut min: isize = std::isize::MAX;\n    for (i, &x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < min {\n            min = x;\n            idx\
    \ = i;\n        }\n    }\n    if min != std::isize::MAX {\n        plucked.push(min);\n\
    \        plucked.push(idx as isize);\n    }\n    plucked", "    let mut arr =\
    \ arr;\n    let mut min = -1;\n    let mut min_idx = -1;\n    for (idx, &node)\
    \ in arr.iter().enumerate() {\n        if node % 2 == 0 {\n            if min\
    \ == -1 || node < min {\n                min = node;\n                min_idx\
    \ = idx as isize;\n            }\n        }\n    }\n    if min == -1 {\n     \
    \   return vec![];\n    }\n    return vec![min, min_idx];", "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut evens: Vec<isize> = vec![];\n\
    \    let mut odds: Vec<isize> = vec![];\n    let mut ans: Vec<isize> = vec![];\n\
    \    for x in arr {\n        if x % 2 == 0 {\n            evens.push(x);\n   \
    \     } else {\n            odds.push(x);\n        }\n    }\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min_even = evens[0];\n    let\
    \ mut index = 0;\n    for i in 0..evens.len() {\n        if evens[i] < min_even\
    \ {\n            min_even = evens[i];\n            index = i;\n        }\n   \
    \ }\n    ans.push(min_even);\n    ans.push(index as isize);\n    ans", "    //\
    \ Your code here\n    if arr.len() == 0 {\n        return vec![];\n    }\n   \
    \ let mut evens: Vec<isize> = vec![];\n    let mut res: Vec<isize> = vec![];\n\
    \    for (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0\
    \ {\n            evens.push(*value);\n            res.push(index as isize);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min = evens.iter().min().unwrap();\n    let mut min_indices: Vec<isize>\
    \ = vec![];\n    for (index, &value) in evens.iter().enumerate() {\n        if\
    \ value == *min {\n            min_indices.push(index as isize);\n        }\n\
    \    }\n    let min_index = min_indices.iter().min().unwrap();\n    let mut result:\
    \ Vec<isize> = vec![];\n    result.push(*min);\n    result.push(res[*min_index\
    \ as usize]);\n    result", "    let mut smallest_even = None;\n    let mut smallest_even_idx\
    \ = None;\n    let mut idx = 0;\n    for item in arr {\n        if item % 2 ==\
    \ 0 {\n            match smallest_even {\n                None => {\n        \
    \            smallest_even = Some(item);\n                    smallest_even_idx\
    \ = Some(idx);\n                }\n                Some(x) => {\n            \
    \        if item < x {\n                        smallest_even = Some(item);\n\
    \                        smallest_even_idx = Some(idx);\n                    }\n\
    \                }\n            }\n        }\n        idx += 1;\n    }\n    match\
    \ smallest_even {\n        None => vec![],\n        Some(x) => vec![x, smallest_even_idx.unwrap()\
    \ as isize],\n    }", "    let mut n = 0;\n    let mut i = 0;\n    for (index,\
    \ value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n          \
    \  if n == 0 || value < &n {\n                n = *value;\n                i =\
    \ index;\n            }\n        }\n    }\n    vec![n, i as isize]", "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut even_values: Vec<isize> = arr\n\
    \        .iter()\n        .cloned()\n        .filter(|x| x % 2 == 0)\n       \
    \ .collect();\n    even_values.sort();\n    even_values.dedup();\n    let min_even\
    \ = even_values.first().copied().unwrap_or_default();\n    let min_even_idx =\
    \ arr.iter().position(|&x| x == min_even).unwrap_or_default();\n    vec![min_even,\
    \ min_even_idx as isize]", "    let mut min = 10001;\n    let mut min_idx = 10001;\n\
    \    for (idx, &i) in arr.iter().enumerate() {\n        if i % 2 == 0 && i < min\
    \ {\n            min = i;\n            min_idx = idx;\n        }\n    }\n    if\
    \ min < 10001 {\n        vec![min, min_idx as isize]\n    } else {\n        vec![]\n\
    \    }", "    let mut even_smallest = vec![];\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            if even_smallest.is_empty() {\n    \
    \            even_smallest = vec![*v, i as isize];\n            } else if *v <\
    \ even_smallest[0] {\n                even_smallest = vec![*v, i as isize];\n\
    \            }\n        }\n    }\n    even_smallest", "    if arr.is_empty() {\n\
    \        return vec![];\n    }\n    let mut even_values: Vec<isize> = vec![];\n\
    \    let mut even_value_indexes: Vec<usize> = vec![];\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 {\n            even_values.push(v);\n            even_value_indexes.push(i);\n\
    \        }\n    }\n    if even_values.is_empty() {\n        return vec![];\n \
    \   }\n    let mut smallest_even_value = even_values[0];\n    let mut smallest_even_value_index\
    \ = even_value_indexes[0];\n    for (i, &v) in even_values.iter().enumerate()\
    \ {\n        if v < smallest_even_value {\n            smallest_even_value = v;\n\
    \            smallest_even_value_index = even_value_indexes[i];\n        }\n \
    \   }\n    vec![smallest_even_value, smallest_even_value_index as isize]", " \
    \   let mut evens: Vec<&isize> = arr.iter().filter(|&x| x % 2 == 0).collect();\n\
    \    evens.sort();\n    let res = if evens.is_empty() {\n        vec![]\n    }\
    \ else {\n        let smallest_even = evens[0];\n        let index = arr.iter().position(|&x|\
    \ x == *smallest_even).unwrap();\n        vec![*smallest_even, index as isize]\n\
    \    };\n    res", "    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut plucked = vec![];\n    let mut smallest_even_value = std::isize::MAX;\n\
    \    let mut smallest_even_index = std::isize::MAX;\n    for (i, num) in arr.iter().enumerate()\
    \ {\n        if num % 2 == 0 && num < &smallest_even_value {\n            smallest_even_value\
    \ = *num;\n            smallest_even_index = i as isize;\n        }\n    }\n \
    \   if smallest_even_value == std::isize::MAX {\n        return vec![];\n    }\n\
    \    plucked.push(smallest_even_value);\n    plucked.push(smallest_even_index);\n\
    \    plucked", "    if arr.is_empty() {\n        vec![]\n    } else {\n      \
    \  let mut min_even = None;\n        let mut min_even_index = None;\n        for\
    \ (index, &val) in arr.iter().enumerate() {\n            if val % 2 == 0 {\n \
    \               if min_even.is_none() || val < min_even.unwrap() {\n         \
    \           min_even = Some(val);\n                    min_even_index = Some(index);\n\
    \                }\n            }\n        }\n        match (min_even, min_even_index)\
    \ {\n            (Some(min_even), Some(min_even_index)) => vec![min_even, min_even_index\
    \ as isize],\n            _ => vec![],\n        }\n    }", "    let mut evens:\
    \ Vec<(isize, usize)> = arr\n        .iter()\n        .enumerate()\n        .filter(|&(_,\
    \ v)| v % 2 == 0)\n        .collect();\n    evens.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    match evens.first() {\n        Some(e) => vec![e.0 as isize, e.1 as isize],\n\
    \        None => vec![],\n    }", "    if arr.is_empty() {\n        return vec![];\n\
    \    }\n    let mut res = (arr[0], 0);\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v == 0 {\n            return vec![0, i as isize];\n        }\n\
    \        if v % 2 == 0 && v < res.0 {\n            res = (v, i as isize);\n  \
    \      }\n    }\n    if res.0 % 2 == 0 {\n        vec![res.0, res.1]\n    } else\
    \ {\n        vec![]\n    }", "    let mut even_nodes: Vec<(isize, usize)> = Vec::new();\n\
    \    let mut even_index: usize = std::usize::MAX;\n    let mut even_val: isize\
    \ = std::isize::MAX;\n    for (index, element) in arr.iter().enumerate() {\n \
    \       if is_even(*element) {\n            even_nodes.push((*element, index));\n\
    \        }\n    }\n    if even_nodes.len() == 0 {\n        return vec![];\n  \
    \  } else {\n        even_nodes.sort_by(|a, b| a.0.cmp(&b.0));\n        even_val\
    \ = even_nodes[0].0;\n        even_index = even_nodes[0].1;\n        for node\
    \ in even_nodes {\n            if node.0 == even_val {\n                if node.1\
    \ < even_index {\n                    even_index = node.1;\n                }\n\
    \            }\n        }\n    }\n    vec![even_val, even_index as isize]", " \
    \   let mut sml_val: isize = 0;\n    let mut idx: usize = 0;\n    let mut valid:\
    \ bool = false;\n    for (i, &v) in arr.iter().enumerate() {\n        if v % 2\
    \ == 0 {\n            if valid == false {\n                sml_val = v;\n    \
    \            idx = i;\n                valid = true;\n            } else if v\
    \ < sml_val {\n                sml_val = v;\n                idx = i;\n      \
    \      }\n        }\n    }\n    if valid {\n        vec![sml_val, idx as isize]\n\
    \    } else {\n        vec![]\n    }", "    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut filtered: Vec<isize> = arr.into_iter().filter(|x|\
    \ x % 2 == 0).collect();\n    filtered.sort();\n    if filtered.is_empty() {\n\
    \        return vec![];\n    }\n    let first_even = filtered[0];\n    let mut\
    \ result: Vec<isize> = vec![];\n    for (i, e) in arr.iter().enumerate() {\n \
    \       if *e == first_even {\n            result.push(*e);\n            result.push(i\
    \ as isize);\n            break;\n        }\n    }\n    result", "    // Your\
    \ code here!\n    let mut evens: Vec<isize> = vec![];\n    let mut idx: Vec<usize>\
    \ = vec![];\n    for (i, item) in arr.iter().enumerate() {\n        if item %\
    \ 2 == 0 {\n            evens.push(*item);\n            idx.push(i);\n       \
    \ }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n    let\
    \ mut smallest = evens[0];\n    let mut i = 0;\n    for (j, item) in evens.iter().enumerate()\
    \ {\n        if item < &smallest {\n            smallest = *item;\n          \
    \  i = j;\n        }\n    }\n    vec![smallest, idx[i] as isize]", "    let evens:\
    \ Vec<isize> = arr.into_iter().filter(|&n| n % 2 == 0).collect();\n    let index:\
    \ isize = arr.iter().position(|&n| n == evens[0]).unwrap() as isize;\n    vec![evens[0],\
    \ index]", "    let mut cur_val = 0;\n    let mut cur_idx = 0;\n    let mut result\
    \ = Vec::with_capacity(2);\n    for (idx, val) in arr.iter().enumerate() {\n \
    \       if *val % 2 == 0 {\n            if cur_val == 0 || *val < cur_val {\n\
    \                cur_val = *val;\n                cur_idx = idx;\n           \
    \ }\n        }\n    }\n    if cur_val == 0 {\n        return result;\n    } else\
    \ {\n        result.push(cur_val);\n        result.push(cur_idx as isize);\n \
    \       return result;\n    }", "    let mut min = isize::max_value();\n    let\
    \ mut idx = arr.len();\n    for (i, v) in arr.iter().enumerate() {\n        if\
    \ v % 2 == 0 && v < &min {\n            min = *v;\n            idx = i;\n    \
    \    }\n    }\n    match idx {\n        x if x < arr.len() => vec![min, x as isize],\n\
    \        _ => vec![],\n    }", "    let mut result = vec![];\n    for (index,\
    \ value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n          \
    \  if result.is_empty() {\n                result = vec![*value, index as isize];\n\
    \            } else if *value < result[0] {\n                result = vec![*value,\
    \ index as isize];\n            }\n        }\n    }\n    result", "    if arr.len()\
    \ == 0 {\n        return vec![];\n    }\n    let mut sorted = arr.clone();\n \
    \   sorted.sort();\n    let evens: Vec<&isize> = sorted.iter().filter(|&x| x %\
    \ 2 == 0).collect();\n    let first_even: &isize = evens.first().unwrap();\n \
    \   let mut min_index: usize = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ == *first_even {\n            min_index = i;\n            break;\n        }\n\
    \    }\n    vec![*first_even, min_index as isize]", "    if arr.is_empty() {\n\
    \        return vec![];\n    }\n    let mut smallest = std::isize::MAX;\n    let\
    \ mut smallest_index = -1;\n    for (i, x) in arr.iter().enumerate() {\n     \
    \   if *x % 2 == 0 && *x < smallest {\n            smallest = *x;\n          \
    \  smallest_index = i as isize;\n        }\n    }\n    if smallest == std::isize::MAX\
    \ {\n        return vec![];\n    }\n    vec![smallest, smallest_index]", "   \
    \ let mut smallest_index = std::usize::MAX;\n    let mut smallest_value = std::isize::MAX;\n\
    \    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 ==\
    \ 0 && value < smallest_value {\n            smallest_value = value;\n       \
    \     smallest_index = index;\n        }\n    }\n    if smallest_index == std::usize::MAX\
    \ {\n        vec![]\n    } else {\n        vec![smallest_value, smallest_index\
    \ as isize]\n    }", "    let mut result = vec![];\n    let mut min = 999999999;\n\
    \    for i in 0..arr.len() {\n        if arr[i] > 0 && arr[i] % 2 == 0 && arr[i]\
    \ < min {\n            min = arr[i];\n            result = vec![min, i as isize];\n\
    \        }\n    }\n    result", "    if arr.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut evens: Vec<isize> = vec![];\n    let mut idx = 0;\n    for\
    \ i in arr {\n        if i % 2 == 0 {\n            evens.push(i);\n        }\n\
    \        idx += 1;\n    }\n    if evens.len() == 0 {\n        return vec![];\n\
    \    }\n    evens.sort();\n    let mut min = evens[0];\n    let mut min_idx =\
    \ 0;\n    let mut idx = 0;\n    for i in arr {\n        if i == min {\n      \
    \      min_idx = idx;\n            break;\n        }\n        idx += 1;\n    }\n\
    \    vec![min, min_idx as isize]", "    let mut min = isize::max_value();\n  \
    \  let mut res = vec![];\n    for i in 0..arr.len() {\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min {\n            min = arr[i];\n            res = vec![min,\
    \ i as isize];\n        }\n    }\n    res", "    let mut smallest = None;\n  \
    \  let mut index = None;\n    for (i, v) in arr.iter().enumerate() {\n       \
    \ if *v % 2 == 0 {\n            if let Some(smallest_value) = smallest {\n   \
    \             if *v < smallest_value {\n                    smallest = Some(*v);\n\
    \                    index = Some(i);\n                }\n            } else {\n\
    \                smallest = Some(*v);\n                index = Some(i);\n    \
    \        }\n        }\n    }\n    if let Some(smallest_value) = smallest {\n \
    \       if let Some(i) = index {\n            return vec![smallest_value, i as\
    \ isize];\n        }\n    }\n    vec![]", "    let mut even_nums: Vec<(isize,\
    \ usize)> = Vec::new();\n    for (index, number) in arr.iter().enumerate() {\n\
    \        if number % 2 == 0 {\n            even_nums.push((*number, index));\n\
    \        }\n    }\n    even_nums.sort();\n    if even_nums.len() > 0 {\n     \
    \   let smallest_even = even_nums[0];\n        vec![smallest_even.0, smallest_even.1\
    \ as isize]\n    } else {\n        vec![]\n    }", "    let mut best = (std::isize::MAX,\
    \ std::isize::MAX);\n    for (i, x) in arr.iter().enumerate() {\n        if *x\
    \ % 2 == 0 && x < &best.0 {\n            best = (*x, i as isize);\n        }\n\
    \    }\n    if best.0 == std::isize::MAX {\n        vec![]\n    } else {\n   \
    \     vec![best.0, best.1]\n    }", "    let mut smallest_even = None;\n    let\
    \ mut smallest_even_index = None;\n    for (i, &v) in arr.iter().enumerate() {\n\
    \        if v % 2 == 0 {\n            match smallest_even {\n                None\
    \ => {\n                    smallest_even = Some(v);\n                    smallest_even_index\
    \ = Some(i);\n                }\n                Some(smallest) => {\n       \
    \             if v < smallest {\n                        smallest_even = Some(v);\n\
    \                        smallest_even_index = Some(i);\n                    }\n\
    \                }\n            }\n        }\n    }\n    if let Some(even) = smallest_even\
    \ {\n        if let Some(i) = smallest_even_index {\n            return vec![even,\
    \ i as isize];\n        }\n    }\n    vec![]", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n \
    \           evens.push(arr[i]);\n        }\n    }\n    if evens.len() == 0 {\n\
    \        return vec![];\n    }\n    evens.sort();\n    let mut min_even = evens[0];\n\
    \    let mut min_index = 0;\n    for i in 0..arr.len() {\n        if arr[i] ==\
    \ min_even {\n            min_index = i;\n            break;\n        }\n    }\n\
    \    vec![min_even, min_index as isize]", "    if arr.is_empty() {\n        return\
    \ vec![];\n    }\n    let mut smallest_even_value = std::isize::MAX;\n    let\
    \ mut smallest_even_index = 0;\n    for (i, item) in arr.iter().enumerate() {\n\
    \        if item % 2 == 0 && item < &smallest_even_value {\n            smallest_even_value\
    \ = *item;\n            smallest_even_index = i;\n        }\n    }\n    if smallest_even_value\
    \ == std::isize::MAX {\n        return vec![];\n    }\n    vec![smallest_even_value,\
    \ smallest_even_index as isize]", "    let mut min = std::isize::MAX;\n    let\
    \ mut min_index = -1;\n    for (index, value) in arr.iter().enumerate() {\n  \
    \      if value % 2 == 0 && value < &min {\n            min = *value;\n      \
    \      min_index = index as isize;\n        }\n    }\n    if min_index == -1 {\n\
    \        return vec![];\n    }\n    vec![min, min_index]", "    if arr.len() ==\
    \ 0 {\n        return vec![];\n    }\n    let mut min = None;\n    let mut min_i\
    \ = None;\n    for (i, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n\
    \            if min.is_none() || *n < min.unwrap() {\n                min = Some(*n);\n\
    \                min_i = Some(i as isize);\n            }\n        }\n    }\n\
    \    if min.is_none() {\n        return vec![];\n    }\n    vec![min.unwrap(),\
    \ min_i.unwrap()]", "    let mut result = vec![];\n    let mut index = 0;\n  \
    \  let mut min = std::isize::MAX;\n    for (i, x) in arr.iter().enumerate() {\n\
    \        if x % 2 == 0 && x < &min {\n            min = *x;\n            index\
    \ = i;\n        }\n    }\n    if min != std::isize::MAX {\n        result.push(min);\n\
    \        result.push(index as isize);\n    }\n    result", "    let mut plucked\
    \ = None;\n    let mut min_even = isize::max_value();\n    for (i, &v) in arr.iter().enumerate()\
    \ {\n        if v % 2 == 0 && v < min_even {\n            min_even = v;\n    \
    \        plucked = Some(i);\n        }\n    }\n    if let Some(i) = plucked {\n\
    \        vec![min_even, i as isize]\n    } else {\n        vec![]\n    }", " \
    \   let mut arr = arr;\n    let mut ret: Vec<isize> = vec![];\n    let mut smallest\
    \ = std::isize::MAX;\n    let mut idx = std::isize::MAX;\n    arr.iter().enumerate().for_each(|(i,\
    \ a)| {\n        if a % 2 == 0 && a < &smallest {\n            smallest = *a;\n\
    \            idx = i as isize;\n        }\n    });\n    if smallest == std::isize::MAX\
    \ {\n        return ret;\n    }\n    ret.push(smallest);\n    ret.push(idx);\n\
    \    ret", "    // go through the array and find the first even number\n    for\
    \ (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0 {\n  \
    \          return vec![*value, index as isize];\n        }\n    }\n    return\
    \ vec![];", "    // your code goes here\n    let mut v: Vec<isize> = Vec::new();\n\
    \    for i in 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            v.push(arr[i]);\n\
    \        }\n    }\n    if v.len() == 0 {\n        return Vec::new();\n    }\n\
    \    v.sort();\n    let mut r: Vec<isize> = Vec::new();\n    r.push(v[0]);\n \
    \   let mut idx = 0;\n    for i in 0..arr.len() {\n        if arr[i] == v[0] {\n\
    \            idx = i;\n            break;\n        }\n    }\n    r.push(idx as\
    \ isize);\n    r", "    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut evens: Vec<isize> = arr.iter().filter(|&x| x % 2 == 0).cloned().collect();\n\
    \    evens.sort();\n    if evens.is_empty() {\n        return vec![];\n    }\n\
    \    let smallest_even = evens[0];\n    let mut indices: Vec<usize> = arr.iter().enumerate().filter(|&(_,\
    \ x)| x == &smallest_even).map(|(i, _)| i).collect();\n    indices.sort();\n \
    \   let smallest_index = indices[0];\n    vec![smallest_even, smallest_index as\
    \ isize]", "    let evens: Vec<_> = arr.iter().enumerate().filter(|(_, x)| x %\
    \ 2 == 0).collect();\n    if evens.is_empty() {\n        vec![]\n    } else {\n\
    \        evens.iter().min_by_key(|(_, x)| x).unwrap().to_vec()\n    }", "    let\
    \ mut smallest_even = std::isize::MAX;\n    let mut smallest_even_index = std::isize::MAX;\n\
    \    for (index, &value) in arr.iter().enumerate() {\n        if value % 2 ==\
    \ 0 && value < smallest_even {\n            smallest_even = value;\n         \
    \   smallest_even_index = index as isize;\n        }\n    }\n    if smallest_even\
    \ == std::isize::MAX {\n        return vec![];\n    }\n    vec![smallest_even,\
    \ smallest_even_index]", "    if arr.len() == 0 {\n        return vec![];\n  \
    \  }\n    let mut smallest = isize::max_value();\n    let mut smallest_index =\
    \ isize::max_value();\n    for (i, n) in arr.iter().enumerate() {\n        if\
    \ n % 2 == 0 && n < &smallest {\n            smallest = *n;\n            smallest_index\
    \ = i as isize;\n        }\n    }\n    if smallest == isize::max_value() {\n \
    \       return vec![];\n    }\n    vec![smallest, smallest_index]", "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut smallest_index = arr.len();\n\
    \    let mut smallest_even = 0;\n    for i in 0..arr.len() {\n        if arr[i]\
    \ % 2 == 0 {\n            if smallest_even == 0 || arr[i] < smallest_even {\n\
    \                smallest_even = arr[i];\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    if smallest_even == 0 {\n        return\
    \ vec![];\n    }\n    vec![smallest_even, smallest_index as isize]", "    // let\
    \ mut res = Vec::new();\n    // let mut smallest_even = -1;\n    // let mut smallest_even_idx\
    \ = -1;\n    // for (idx, x) in arr.iter().enumerate() {\n    //     if *x % 2\
    \ == 0 {\n    //         if smallest_even == -1 || *x < smallest_even {\n    //\
    \             smallest_even = *x;\n    //             smallest_even_idx = idx\
    \ as isize;\n    //         }\n    //     }\n    // }\n    // if smallest_even\
    \ != -1 {\n    //     res.push(smallest_even);\n    //     res.push(smallest_even_idx);\n\
    \    // }\n    // res\n    arr.iter()\n        .enumerate()\n        .filter(|(_,\
    \ x)| x % 2 == 0)\n        .min_by_key(|(_, x)| *x)\n        .map(|(idx, &x)|\
    \ vec![x, idx as isize])\n        .unwrap_or_else(|| vec![])", "    let mut even_nodes:\
    \ Vec<isize> = Vec::new();\n    let mut even_indexes: Vec<usize> = Vec::new();\n\
    \    let mut even_counter = 0;\n    for (i, val) in arr.iter().enumerate() {\n\
    \        if val % 2 == 0 {\n            even_nodes.push(*val);\n            even_indexes.push(i);\n\
    \            even_counter += 1;\n        }\n    }\n    if even_counter == 0 {\n\
    \        return vec![];\n    }\n    let mut min_node = even_nodes[0];\n    let\
    \ mut min_index = even_indexes[0];\n    for (i, val) in even_nodes.iter().enumerate()\
    \ {\n        if *val < min_node {\n            min_node = *val;\n            min_index\
    \ = even_indexes[i];\n        }\n    }\n    vec![min_node, min_index as isize]",
  "    let mut even_vals: Vec<isize> = Vec::new();\n    for (i, v) in arr.iter().enumerate()\
    \ {\n        if *v % 2 == 0 {\n            even_vals.push(v.clone());\n      \
    \      even_vals.push(i as isize);\n        }\n    }\n    even_vals.sort();\n\
    \    return even_vals;", "    // First we need to find the smallest even number.\n\
    \    // This can be done by iterating through the array.\n    // * If a number\
    \ is even, check if it is less than the smallest even number.\n    // * If it\
    \ is, it becomes the new smallest even number.\n    // * If a number is odd, ignore\
    \ it.\n    // * If no even numbers are found, return an empty vec.\n    // * If\
    \ the array is empty, return an empty vec.\n    //\n    // Next we need to find\
    \ the smallest even number's index.\n    // This can be done by iterating through\
    \ the array.\n    // * If a number is equal to the smallest even number, check\
    \ if it's index is less than the smallest index.\n    // * If it is, it becomes\
    \ the new smallest index.\n    // * If a number is not equal to the smallest even\
    \ number, ignore it.\n    // * If no even numbers are found, return an empty vec.\n\
    \    // * If the array is empty, return an empty vec.\n    //\n    // Return the\
    \ smallest even number and its index in a vector.\n    let mut smallest_even_num\
    \ = 0;\n    let mut smallest_even_index = 0;\n    let mut is_first_smallest_even_num\
    \ = true;\n    let mut is_first_smallest_even_index = true;\n    let mut has_found_even_num\
    \ = false;\n    let mut is_current_index_smallest_even_index = false;\n\n    for\
    \ (index, number) in arr.iter().enumerate() {\n        if number % 2 == 0 {\n\
    \            has_found_even_num = true;\n            if is_first_smallest_even_num\
    \ {\n                smallest_even_num = *number;\n                is_first_smallest_even_num\
    \ = false;\n            } else if *number < smallest_even_num {\n            \
    \    smallest_even_num = *number;\n            }\n            if *number == smallest_even_num\
    \ {\n                is_current_index_smallest_even_index = true;\n          \
    \  }\n        }\n        if is_current_index_smallest_even_index {\n         \
    \   if is_first_smallest_even_index", "    if arr.is_empty() {\n        vec![]\n\
    \    } else {\n        let mut evens: Vec<isize> = arr.iter().enumerate().filter(|&(_,\
    \ n)| n % 2 == 0).map(|(i, n)| n).collect();\n        evens.sort();\n        let\
    \ min = evens[0];\n        let idx = arr.iter().position(|&n| n == min).unwrap();\n\
    \        vec![min, idx as isize]\n    }", "    let mut smallest_even = <isize>::max_value();\n\
    \    let mut smallest_index = <usize>::max_value();\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 && value < &smallest_even\
    \ {\n            smallest_even = *value;\n            smallest_index = index;\n\
    \        }\n    }\n    if smallest_even == <isize>::max_value() {\n        return\
    \ vec![];\n    } else {\n        return vec![smallest_even, smallest_index as\
    \ isize];\n    }", "    let mut min_index = -1;\n    let mut min_value = isize::max_value();\n\
    \    for (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0\
    \ && value < &min_value {\n            min_index = index as isize;\n         \
    \   min_value = *value;\n        }\n    }\n    if min_index < 0 {\n        return\
    \ vec![];\n    }\n    vec![min_value, min_index]", "    let even_indexes: Vec<usize>\
    \ = (0..arr.len())\n        .filter(|i| arr[*i] % 2 == 0)\n        .collect();\n\
    \    if even_indexes.is_empty() {\n        return vec![];\n    }\n    let mut\
    \ smallest_index = even_indexes[0];\n    let mut smallest_value = arr[smallest_index];\n\
    \    for i in &even_indexes {\n        if arr[*i] < smallest_value {\n       \
    \     smallest_index = *i;\n            smallest_value = arr[*i];\n        }\n\
    \    }\n    vec![smallest_value, smallest_index as isize]", "    arr.iter()\n\
    \        .enumerate()\n        .filter(|&(_, x)| x % 2 == 0)\n        .fold(\n\
    \            None,\n            |m, (i, x)| match m {\n                None =>\
    \ Some((*x, i)),\n                Some((mx, _)) if *x < mx => Some((*x, i)),\n\
    \                _ => m,\n            },\n        )\n        .map(|(x, i)| vec![x,\
    \ i as isize])\n        .unwrap_or_else(|| vec![])", "    let mut even = 10000;\n\
    \    let mut even_idx = None;\n    for (idx, v) in arr.iter().enumerate() {\n\
    \        if *v < even && *v % 2 == 0 {\n            even = *v;\n            even_idx\
    \ = Some(idx);\n        }\n    }\n    match even_idx {\n        Some(idx) => vec![even,\
    \ idx as isize],\n        None => vec![],\n    }", "    let mut evens: Vec<isize>\
    \ = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n    if evens.is_empty()\
    \ {\n        return vec![];\n    }\n    evens.sort();\n    let min_even = evens[0];\n\
    \    let pos = arr.iter().position(|x| x == &min_even).unwrap();\n    vec![min_even,\
    \ pos as isize]", "    let min_even = arr.iter().filter(|&x| x % 2 == 0).min();\n\
    \    match min_even {\n        Some(min) => arr.iter().enumerate().find(|&(_,\
    \ x)| x == min).map(|(i, &v)| vec![v, i as isize]).unwrap_or(vec![]),\n      \
    \  None => vec![],\n    }", "    if arr.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut evens: Vec<isize> = vec![];\n    let mut odds: Vec<isize>\
    \ = vec![];\n    for (i, &n) in arr.iter().enumerate() {\n        if n % 2 ==\
    \ 0 {\n            evens.push(n);\n        } else {\n            odds.push(n);\n\
    \        }\n    }\n    if evens.len() == 0 {\n        return vec![];\n    }\n\
    \    let min_even = evens.iter().fold(isize::max_value(), |a, &b| a.min(b));\n\
    \    let mut min_even_i = -1;\n    for (i, &n) in arr.iter().enumerate() {\n \
    \       if n == min_even {\n            min_even_i = i as isize;\n           \
    \ break;\n        }\n    }\n    vec![min_even, min_even_i]", "    // Your code\
    \ here!\n    let mut evens: Vec<isize> = Vec::new();\n    let mut min = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    for (idx, elem) in arr.iter().enumerate()\
    \ {\n        if elem % 2 == 0 {\n            evens.push(*elem);\n            if\
    \ elem < &min {\n                min = *elem;\n                min_idx = idx as\
    \ isize;\n            }\n        }\n    }\n    let mut ret = Vec::new();\n   \
    \ if evens.len() > 0 {\n        ret.push(min);\n        ret.push(min_idx);\n \
    \   }\n    ret", "    let min = arr.iter().filter(|x| x % 2 == 0).min();\n   \
    \ match min {\n        Some(x) => vec![*x, arr.iter().position(|y| y == x).unwrap()\
    \ as isize],\n        None => vec![],\n    }", "    let mut smallest_index = 0;\n\
    \    let mut smallest_value = arr[0];\n    for (index, node) in arr.iter().enumerate()\
    \ {\n        if node % 2 == 0 && node < &smallest_value {\n            smallest_index\
    \ = index;\n            smallest_value = *node;\n        }\n    }\n    if smallest_value\
    \ == arr[0] {\n        return vec![];\n    }\n    vec![smallest_value, smallest_index\
    \ as isize]", "    arr.iter()\n        .enumerate()\n        .filter(|&(_, &v)|\
    \ v % 2 == 0)\n        .min_by_key(|&(_, v)| v)\n        .map(|(i, v)| vec![*v,\
    \ i as isize])\n        .unwrap_or_else(|| vec![])", "    let mut res = Vec::new();\n\
    \    if arr.is_empty() {\n        return res;\n    }\n    let mut min_value =\
    \ 99999;\n    let mut min_index = std::usize::MAX;\n    for (index, value) in\
    \ arr.iter().enumerate() {\n        if value % 2 == 0 && value < &min_value {\n\
    \            min_value = *value;\n            min_index = index;\n        }\n\
    \    }\n    if min_index == std::usize::MAX {\n        return res;\n    }\n  \
    \  res.push(min_value);\n    res.push(min_index as isize);\n    res", "    if\
    \ arr.is_empty() {\n        return vec![];\n    }\n    let mut min_even = std::isize::MAX;\n\
    \    let mut min_even_index = std::isize::MAX;\n    for (index, node) in arr.iter().enumerate()\
    \ {\n        if node.rem_euclid(2) == 0 && node < &min_even {\n            min_even\
    \ = *node;\n            min_even_index = index as isize;\n        }\n    }\n \
    \   if min_even == std::isize::MAX {\n        return vec![];\n    }\n    vec![min_even,\
    \ min_even_index]", "    let mut smallest_even = std::isize::MAX;\n    let mut\
    \ smallest_index = std::isize::MAX;\n    let mut index = 0;\n    for num in arr\
    \ {\n        if num % 2 == 0 && num < smallest_even {\n            smallest_even\
    \ = num;\n            smallest_index = index;\n        }\n        index += 1;\n\
    \    }\n    if smallest_even == std::isize::MAX {\n        vec![]\n    } else\
    \ {\n        vec![smallest_even, smallest_index]\n    }", "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut smallest_even = std::isize::MAX;\n\
    \    let mut smallest_index = 0;\n    for (index, value) in arr.iter().enumerate()\
    \ {\n        if value % 2 == 0 && value < &smallest_even {\n            smallest_even\
    \ = *value;\n            smallest_index = index;\n        }\n    }\n    if smallest_even\
    \ == std::isize::MAX {\n        return vec![];\n    }\n    vec![smallest_even,\
    \ smallest_index as isize]", "    let mut smallest_even_value: Option<isize> =\
    \ None;\n    let mut smallest_even_value_index: Option<usize> = None;\n    for\
    \ (i, node) in arr.iter().enumerate() {\n        if *node % 2 == 0 {\n       \
    \     match smallest_even_value {\n                Some(val) => {\n          \
    \          if val > *node {\n                        smallest_even_value = Some(*node);\n\
    \                        smallest_even_value_index = Some(i);\n              \
    \      }\n                }\n                None => {\n                    smallest_even_value\
    \ = Some(*node);\n                    smallest_even_value_index = Some(i);\n \
    \               }\n            }\n        }\n    }\n    match smallest_even_value\
    \ {\n        Some(val) => vec![val, smallest_even_value_index.unwrap() as isize],\n\
    \        None => vec![],\n    }", "    // 0) iterate over the array, get the smallest\
    \ value\n    // 1) iterate over the array again and check the value with the smallest\
    \ one\n    // 2) if it is even and smaller, then return it\n    // 3) if it is\
    \ not even, then return nothing\n    // 4) if it is even and not smaller, then\
    \ continue with the next one\n    // 5) if there are no evens in the array, then\
    \ return 0\n    // 6) if there are no evens, but there are some that are smaller,\
    \ then return the smallest\n\n    let mut evens = Vec::new();\n    let mut smallest\
    \ = isize::max_value();\n    for (i, v) in arr.iter().enumerate() {\n        if\
    \ v & 1 == 0 {\n            if v < &smallest {\n                evens.clear();\n\
    \                evens.push(i);\n                smallest = *v;\n            }\
    \ else if v == &smallest {\n                evens.push(i);\n            }\n  \
    \      }\n    }\n\n    if evens.is_empty() {\n        return vec![];\n    }\n\n\
    \    vec![smallest, evens[0] as isize]", '    unimplemented!();', "    // create\
    \ a list of all evens and then sort it\n    // but only sort it by index if there\
    \ are multiple evens with the same value\n    let mut arr_evens: Vec<(isize, usize)>\
    \ = Vec::new();\n    for (i, n) in arr.iter().enumerate() {\n        if *n % 2\
    \ == 0 {\n            arr_evens.push((*n, i));\n        }\n    }\n    arr_evens.sort_by(|a,\
    \ b| (a.0, a.1).cmp(&(b.0, b.1)));\n    if arr_evens.len() == 0 {\n        return\
    \ vec![];\n    }\n    vec![arr_evens[0].0, arr_evens[0].1 as isize]", "    if\
    \ arr.len() == 0 {\n        return vec![];\n    }\n    let mut evens: Vec<isize>\
    \ = vec![];\n    let mut indices: Vec<usize> = vec![];\n    for i in 0..arr.len()\
    \ {\n        if arr[i] % 2 == 0 {\n            evens.push(arr[i]);\n         \
    \   indices.push(i);\n        }\n    }\n    if evens.len() == 0 {\n        return\
    \ vec![];\n    }\n    let min_idx = argmin(&evens);\n    return vec![evens[min_idx],\
    \ indices[min_idx] as isize];", "    let mut result = vec![];\n    let mut index\
    \ = 0;\n    let mut i = 0;\n    let mut min = 2 * 10000;\n    for node in arr\
    \ {\n        if node < min && node % 2 == 0 {\n            min = node;\n     \
    \       index = i;\n        }\n        i += 1;\n    }\n    if min < 2 * 10000\
    \ {\n        result.push(min);\n        result.push(index as isize);\n    }\n\
    \    result", "    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut smallest_index = 0;\n    let mut smallest_even = arr[0];\n    for (i, val)\
    \ in arr.iter().enumerate() {\n        if val % 2 == 0 && val < &smallest_even\
    \ {\n            smallest_even = *val;\n            smallest_index = i;\n    \
    \    }\n    }\n    vec![smallest_even, smallest_index as isize]", "    let mut\
    \ smallest = 1000000;\n    let mut smallest_index = 1000000;\n    for (i, n) in\
    \ arr.iter().enumerate() {\n        if n % 2 == 0 && n < &smallest {\n       \
    \     smallest = *n;\n            smallest_index = i;\n        }\n    }\n    if\
    \ smallest == 1000000 {\n        vec![]\n    } else {\n        vec![smallest,\
    \ smallest_index as isize]\n    }", "    let mut even = 10000;\n    let mut index\
    \ = -1;\n    for (i, n) in arr.iter().enumerate() {\n        if *n % 2 == 0 &&\
    \ *n < even {\n            even = *n;\n            index = i as isize;\n     \
    \   }\n    }\n    if index == -1 {\n        vec![]\n    } else {\n        vec![even,\
    \ index]\n    }", "    let (min_even, index) = arr.iter().enumerate().filter(|(_,\
    \ &v)| v % 2 == 0).fold(\n        (std::isize::MAX, std::usize::MAX),\n      \
    \  |(acc_min, acc_index), (i, &v)| if v < acc_min { (v, i) } else { (acc_min,\
    \ acc_index) },\n    );\n    if min_even == std::isize::MAX {\n        Vec::new()\n\
    \    } else {\n        vec![min_even, index as isize]\n    }", "    arr.iter()\n\
    \        .enumerate()\n        .filter(|&(_, x)| x % 2 == 0)\n        .min_by_key(|&(_,\
    \ x)| x)\n        .map(|(i, x)| vec![*x, i as isize])\n        .unwrap_or(vec![])",
  "    if arr.len() < 1 {\n        return vec![];\n    }\n    if arr.len() == 1 {\n\
    \        if arr[0] % 2 == 0 {\n            return vec![arr[0], 0];\n        }\
    \ else {\n            return vec![];\n        }\n    }\n    let mut minimum =\
    \ i32::max_value();\n    let mut index = arr.len();\n    for (i, x) in arr.iter().enumerate()\
    \ {\n        if x % 2 == 0 && x < &minimum {\n            minimum = *x;\n    \
    \        index = i;\n        }\n    }\n    if minimum != i32::max_value() {\n\
    \        vec![minimum, index]\n    } else {\n        vec![]\n    }", "    let\
    \ mut plucked = vec![];\n    for i in 0..arr.len() {\n        if arr[i] == 0 {\n\
    \            plucked = vec![0, i as isize];\n            break;\n        } else\
    \ if arr[i] > 0 && arr[i] % 2 == 0 {\n            if plucked.is_empty() {\n  \
    \              plucked = vec![arr[i], i as isize];\n            } else if plucked[0]\
    \ == arr[i] {\n                if plucked[1] > i as isize {\n                \
    \    plucked = vec![arr[i], i as isize];\n                }\n            } else\
    \ if plucked[0] > arr[i] {\n                plucked = vec![arr[i], i as isize];\n\
    \            }\n        }\n    }\n    plucked", "    if arr.is_empty() {\n   \
    \     return vec![];\n    }\n    let mut arr = arr;\n    arr.sort();\n    let\
    \ mut res = arr[0];\n    let mut idx = 0;\n    for (i, item) in arr.iter().enumerate()\
    \ {\n        if item % 2 == 0 && *item < res {\n            res = *item;\n   \
    \         idx = i;\n        }\n    }\n    if res % 2 == 0 {\n        vec![res,\
    \ idx as isize]\n    } else {\n        vec![]\n    }", "    let mut evens: Vec<isize>\
    \ = Vec::new();\n    let mut pluck_idx: usize = arr.len();\n    for (idx, val)\
    \ in arr.iter().enumerate() {\n        if val % 2 == 0 {\n            evens.push(*val);\n\
    \            if idx < pluck_idx {\n                pluck_idx = idx;\n        \
    \    }\n        }\n    }\n    let mut min = *evens.iter().min().unwrap_or(&0);\n\
    \    if evens.len() > 0 {\n        min = *evens.iter().min().unwrap();\n    }\n\
    \    let min_even_idx = arr.iter().position(|&i| i == min).unwrap_or(pluck_idx);\n\
    \    return vec![arr[min_even_idx], min_even_idx as isize];", "    let mut result\
    \ = vec![];\n    let mut smallest_even = 10000;\n    let mut smallest_even_index\
    \ = 10000;\n    for (i, x) in arr.iter().enumerate() {\n        if smallest_even\
    \ > *x && *x % 2 == 0 {\n            smallest_even = *x;\n            smallest_even_index\
    \ = i;\n        }\n    }\n    if smallest_even == 10000 {\n        return result;\n\
    \    }\n    result.push(smallest_even);\n    result.push(smallest_even_index as\
    \ isize);\n    result", "    if arr.len() == 0 {\n        return vec![];\n   \
    \ }\n    let mut smallest_even_value = None;\n    let mut smallest_even_index\
    \ = None;\n    for (index, &value) in arr.iter().enumerate() {\n        if value\
    \ % 2 == 0 {\n            if smallest_even_value.is_none() || value < smallest_even_value.unwrap()\
    \ {\n                smallest_even_value = Some(value);\n                smallest_even_index\
    \ = Some(index);\n            }\n        }\n    }\n    smallest_even_value.map(|x|\
    \ vec![x, smallest_even_index.unwrap() as isize]).unwrap_or(vec![])", "    if\
    \ arr.is_empty() {\n        return vec![];\n    }\n    let min_even = arr.iter().filter(|x|\
    \ x % 2 == 0).min().unwrap();\n    let min_even_idx = arr.iter().position(|x|\
    \ x == min_even).unwrap();\n    vec![*min_even, min_even_idx as isize]", "   \
    \ let mut smallest_even = isize::max_value();\n    let mut smallest_even_i = 0;\n\
    \    for (i, &val) in arr.iter().enumerate() {\n        if val % 2 == 0 && val\
    \ < smallest_even {\n            smallest_even = val;\n            smallest_even_i\
    \ = i;\n        }\n    }\n    if smallest_even == isize::max_value() {\n     \
    \   vec![]\n    } else {\n        vec![smallest_even, smallest_even_i as isize]\n\
    \    }", "    let (ix, val) = arr.iter()\n        .enumerate()\n        .find(|(_,\
    \ n)| n.is_even())\n        .unwrap_or((0, &0));\n    vec![*val, ix as isize]",
  "    if arr.is_empty() {\n        return vec![];\n    }\n    let mut min = arr[0];\n\
    \    let mut index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n       \
    \ if x % 2 == 0 && x < min {\n            min = x;\n            index = i;\n \
    \       }\n    }\n    if min % 2 == 0 {\n        vec![min, index as isize]\n \
    \   } else {\n        vec![]\n    }", "    arr.iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x % 2 == 0)\n        .min_by_key(|(_, x)| x)\n     \
    \   .map(|(idx, x)| vec![*x, idx as isize])\n        .unwrap_or_else(|| vec![])",
  "    if arr.is_empty() {\n        return vec![];\n    }\n    let mut even_nums:\
    \ Vec<isize> = arr.iter().filter(|x| x % 2 == 0).cloned().collect();\n    even_nums.sort();\n\
    \    let smalest_value = even_nums[0];\n    let position = arr.iter().position(|x|\
    \ x == &smalest_value).unwrap();\n    vec![smalest_value, position as isize]",
  "    let mut evens: Vec<(isize, usize)> = Vec::new();\n    let mut odds: Vec<(isize,\
    \ usize)> = Vec::new();\n    for (i, el) in arr.iter().enumerate() {\n       \
    \ if el % 2 == 0 {\n            evens.push((*el, i));\n        } else {\n    \
    \        odds.push((*el, i));\n        }\n    }\n    if evens.len() == 0 {\n \
    \       Vec::new()\n    } else {\n        evens.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \        odds.sort_by(|a, b| a.0.cmp(&b.0));\n        let (min_odd, min_odd_index)\
    \ = odds.first().unwrap();\n        let (min_even, min_even_index) = evens.first().unwrap();\n\
    \        if min_odd < min_even {\n            vec![*min_odd, *min_odd_index as\
    \ isize]\n        } else {\n            vec![*min_even, *min_even_index as isize]\n\
    \        }\n    }", "    //let mut evens: Vec<isize> = Vec::new();\n    let mut\
    \ evens: Vec<isize> = arr.iter().filter(|&x| x % 2 == 0).collect();\n    evens.sort();\n\
    \    let mut result: Vec<isize> = Vec::new();\n    if evens.len() == 0 {\n   \
    \     return result;\n    } else {\n        result.push(evens[0]);\n        result.push(arr.iter().position(|&x|\
    \ x == evens[0]).unwrap() as isize);\n        return result;\n    }", "    let\
    \ mut result = vec![];\n    let mut min = isize::max_value();\n    for (i, &n)\
    \ in arr.iter().enumerate() {\n        if n % 2 == 0 && n < min {\n          \
    \  min = n;\n            result = vec![min, i as isize];\n        }\n    }\n \
    \   result", "    // get the smallest even index\n    let smallest_even_index\
    \ = arr.iter().position(|&n| n % 2 == 0);\n    if smallest_even_index.is_none()\
    \ {\n        return vec![];\n    }\n    // get the smallest even value\n    let\
    \ smallest_even_index = smallest_even_index.unwrap();\n    let smallest_even_value\
    \ = arr[smallest_even_index];\n    // get the smallest even index\n    let smallest_even_index\
    \ = arr.iter().rposition(|&n| n == smallest_even_value).unwrap();\n    // return\
    \ [value, index]\n    vec![smallest_even_value, smallest_even_index as isize]",
  "    let min_even = arr.iter().filter(|&x| *x % 2 == 0).min();\n    match min_even\
    \ {\n        Some(n) => vec![n, arr.iter().position(|&x| x == *n).unwrap() as\
    \ isize],\n        None => vec![],\n    }", "    if arr.is_empty() {\n       \
    \ return vec![];\n    }\n    let evens: Vec<&isize> = arr.iter().filter(|v| *v\
    \ % 2 == 0).collect();\n    if evens.is_empty() {\n        return vec![];\n  \
    \  }\n    let min_even = evens.iter().fold(isize::max_value(), |acc, val| {\n\
    \        if *val < acc {\n            *val\n        } else {\n            acc\n\
    \        }\n    });\n    let idx = arr.iter().position(|v| *v == min_even).unwrap();\n\
    \    vec![min_even, idx as isize]", "    let mut sorted = arr.iter().filter(|x|\
    \ x % 2 == 0).copied().collect::<Vec<isize>>();\n    sorted.sort();\n    sorted.get(0).cloned().into_iter().zip(Some(0)).chain(\n\
    \        sorted.iter().map(|x| arr.iter().position(|&y| y == *x).unwrap() as isize),\n\
    \    ).collect()", "    // get even values\n    let mut evens: Vec<isize> = arr.iter().filter(|&x|\
    \ x % 2 == 0).cloned().collect();\n    // sort\n    evens.sort();\n    // if there\
    \ are evens, return the result\n    match evens.first() {\n        Some(value)\
    \ => vec![*value, arr.iter().position(|&x| x == *value).unwrap() as isize],\n\
    \        None => vec![],\n    }", "    let mut small = isize::max_value();\n \
    \   let mut ind = -1;\n    for (i, x) in arr.iter().enumerate() {\n        if\
    \ x % 2 == 0 && x < &small {\n            small = *x;\n            ind = i as\
    \ isize;\n        }\n    }\n    if ind == -1 {\n        vec![]\n    } else {\n\
    \        vec![small, ind]\n    }", "    let mut result = vec![];\n    if arr.len()\
    \ == 0 {\n        return result;\n    }\n    let mut even = None;\n    for i in\
    \ 0..arr.len() {\n        if arr[i] % 2 == 0 {\n            match even {\n   \
    \             None => even = Some((arr[i], i)),\n                Some((a, _))\
    \ => {\n                    if arr[i] < a {\n                        even = Some((arr[i],\
    \ i));\n                    }\n                }\n            }\n        }\n \
    \   }\n    match even {\n        None => {\n            result\n        }\n  \
    \      Some((a, b)) => {\n            result.push(a);\n            result.push(b\
    \ as isize);\n            result\n        }\n    }", "    let mut r = Vec::<isize>::new();\n\
    \    if arr.len() == 0 {\n        return r;\n    }\n    let mut min = 10000000;\n\
    \    let mut min_i = -1;\n    for (i, x) in arr.iter().enumerate() {\n       \
    \ if x % 2 == 0 && x < &min {\n            min = *x;\n            min_i = i as\
    \ isize;\n        }\n    }\n    if min_i != -1 {\n        r.push(min);\n     \
    \   r.push(min_i);\n    }\n    r", "    // Your code here\n    vec![]", "    let\
    \ mut smallest = isize::max_value();\n    let mut index = usize::max_value();\n\
    \    for (idx, val) in arr.iter().enumerate() {\n        if (val & 1) == 0 &&\
    \ *val < smallest {\n            smallest = *val;\n            index = idx;\n\
    \        }\n    }\n    if smallest != isize::max_value() {\n        vec![smallest,\
    \ index as isize]\n    } else {\n        vec![]\n    }", "    let mut value =\
    \ None;\n    let mut index = None;\n    let mut current_index = 0;\n    for a\
    \ in arr {\n        if a % 2 == 0 {\n            if let Some(v) = value {\n  \
    \              if a < v {\n                    value = Some(a);\n            \
    \        index = Some(current_index);\n                }\n            } else {\n\
    \                value = Some(a);\n                index = Some(current_index);\n\
    \            }\n        }\n        current_index += 1;\n    }\n    if let Some(v)\
    \ = value {\n        if let Some(i) = index {\n            return vec![v, i];\n\
    \        }\n    }\n    vec![]", "    if arr.len() == 0 {\n        return vec![];\n\
    \    }\n    let mut min_even = std::isize::MAX;\n    let mut result = vec![];\n\
    \    for (index, value) in arr.iter().enumerate() {\n        if *value < min_even\
    \ && *value % 2 == 0 {\n            min_even = *value;\n            result = vec![min_even,\
    \ index as isize];\n        }\n    }\n    if min_even == std::isize::MAX {\n \
    \       return vec![];\n    }\n    result", "    // find the first even value\n\
    \    arr.iter()\n        .enumerate()\n        .find(|(i, val)| val % 2 == 0)\n\
    \        .map(|(i, val)| vec![*val, i as isize])\n        .unwrap_or(vec![])",
  "    let mut ev = std::isize::MAX;\n    let mut ind = std::isize::MAX;\n    for\
    \ (i, v) in arr.iter().enumerate() {\n        if *v % 2 == 0 && *v < ev {\n  \
    \          ev = *v;\n            ind = i as isize;\n        }\n    }\n    if ev\
    \ == std::isize::MAX {\n        return vec![];\n    }\n    vec![ev, ind]", " \
    \   let mut smallest_value = isize::max_value();\n    let mut smallest_index =\
    \ isize::max_value();\n    for (i, e) in arr.iter().enumerate() {\n        if\
    \ e % 2 == 0 && e < &smallest_value {\n            smallest_value = *e;\n    \
    \        smallest_index = i as isize;\n        }\n    }\n    if smallest_value\
    \ == isize::max_value() {\n        return vec![];\n    }\n    vec![smallest_value,\
    \ smallest_index]", "    let mut min_even = isize::max_value();\n    let mut min_even_index\
    \ = isize::max_value();\n    for (index, item) in arr.iter().enumerate() {\n \
    \       if item % 2 == 0 && item < &min_even {\n            min_even = *item;\n\
    \            min_even_index = index as isize;\n        }\n    }\n    if min_even_index\
    \ == isize::max_value() {\n        vec![]\n    } else {\n        vec![min_even,\
    \ min_even_index]\n    }", '    unimplemented!()', "    let min_even = arr.iter().filter(|x|\
    \ x % 2 == 0).min();\n    match min_even {\n        Some(x) => {\n           \
    \ let index = arr.iter().position(|&i| i == *x).unwrap();\n            vec![*x,\
    \ index as isize]\n        }\n        None => vec![],\n    }", "    let mut least_even:\
    \ Option<isize> = None;\n    let mut i: usize = 0;\n    let mut index: usize =\
    \ 0;\n    while i < arr.len() {\n        if arr[i] > 0 && arr[i] % 2 == 0 {\n\
    \            match least_even {\n                None => {\n                 \
    \   least_even = Some(arr[i]);\n                    index = i;\n             \
    \   }\n                Some(n) => {\n                    if arr[i] < n {\n   \
    \                     least_even = Some(arr[i]);\n                        index\
    \ = i;\n                    }\n                }\n            }\n        }\n \
    \       i += 1;\n    }\n    match least_even {\n        None => vec![],\n    \
    \    Some(n) => vec![n, index as isize],\n    }", "    let mut smallest_even_index\
    \ = std::usize::MAX;\n    let mut smallest_even_value = std::isize::MAX;\n   \
    \ for (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0 &&\
    \ value < &smallest_even_value {\n            smallest_even_index = index;\n \
    \           smallest_even_value = *value;\n        }\n    }\n    if smallest_even_index\
    \ == std::usize::MAX {\n        vec![]\n    } else {\n        vec![smallest_even_value,\
    \ smallest_even_index as isize]\n    }", "    let mut res = vec![];\n    for node\
    \ in arr {\n        if node % 2 == 0 {\n            res.push(node);\n        }\n\
    \    }\n    if res.is_empty() {\n        return vec![];\n    }\n    let mut min\
    \ = res[0];\n    let mut min_idx = 0;\n    for (idx, item) in res.iter().enumerate()\
    \ {\n        if *item < min {\n            min = *item;\n            min_idx =\
    \ idx;\n        }\n    }\n    vec![min, min_idx as isize]", "    let mut result\
    \ = Vec::new();\n    let mut evens = Vec::new();\n    for (index, val) in arr.iter().enumerate()\
    \ {\n        if val % 2 == 0 {\n            evens.push((val, index));\n      \
    \  }\n    }\n    evens.sort_by(|a, b| a.0.cmp(b.0));\n    if evens.len() > 0 {\n\
    \        result.push(evens[0].0);\n        result.push(evens[0].1 as isize);\n\
    \    }\n    result", "    let mut smallest = (arr.len() + 1, std::isize::MAX);\n\
    \    let mut index = -1;\n    for (i, n) in arr.iter().enumerate() {\n       \
    \ if n % 2 == 0 && n < &smallest.1 {\n            smallest = (i, *n);\n      \
    \      index = i;\n        }\n    }\n    if index == -1 {\n        vec![]\n  \
    \  } else {\n        vec![smallest.1, index as isize]\n    }", "    if arr.is_empty()\
    \ {\n        return vec![];\n    }\n    let mut min_index = 0;\n    let mut min_even\
    \ = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate() {\n        if n\
    \ % 2 == 0 && n < &min_even {\n            min_even = *n;\n            min_index\
    \ = i;\n        }\n    }\n    if min_even == std::isize::MAX {\n        return\
    \ vec![];\n    }\n    vec![min_even, min_index as isize]", "    if arr.len() <\
    \ 1 {\n        vec![]\n    } else {\n        let mut smallest_value = None;\n\
    \        let mut smallest_index = None;\n        for (i, n) in arr.iter().enumerate()\
    \ {\n            if n % 2 == 0 {\n                match smallest_value {\n   \
    \                 None => {\n                        smallest_value = Some(*n);\n\
    \                        smallest_index = Some(i);\n                    }\n  \
    \                  Some(x) => {\n                        if *n < x {\n       \
    \                     smallest_value = Some(*n);\n                           \
    \ smallest_index = Some(i);\n                        }\n                    }\n\
    \                }\n            }\n        }\n        match (smallest_value, smallest_index)\
    \ {\n            (Some(n), Some(i)) => vec![n, i as isize],\n            _ =>\
    \ vec![],\n        }\n    }", "    let mut result = vec![];\n    let mut smallest_even\
    \ = std::isize::MAX;\n    let mut smallest_even_index = std::isize::MAX;\n   \
    \ for (index, value) in arr.iter().enumerate() {\n        if value % 2 == 0 &&\
    \ value < &smallest_even {\n            smallest_even = *value;\n            smallest_even_index\
    \ = index as isize;\n        }\n    }\n    if smallest_even < std::isize::MAX\
    \ {\n        result.push(smallest_even);\n        result.push(smallest_even_index);\n\
    \    }\n    result", "    let mut smallest_even = std::isize::MAX;\n    let mut\
    \ index = std::isize::MAX;\n    for (i, n) in arr.iter().enumerate() {\n     \
    \   if *n > 0 && *n % 2 == 0 && *n < smallest_even {\n            smallest_even\
    \ = *n;\n            index = i as isize;\n        }\n    }\n    if smallest_even\
    \ == std::isize::MAX {\n        vec![]\n    } else {\n        vec![smallest_even,\
    \ index]\n    }", "    if arr.is_empty() {\n        return vec![];\n    }\n  \
    \  let mut vec = vec![];\n    for (i, node) in arr.iter().enumerate() {\n    \
    \    if node % 2 == 0 {\n            vec.push((*node, i as isize));\n        }\n\
    \    }\n    if vec.is_empty() {\n        return vec![];\n    }\n    vec.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    vec![vec[0].0, vec[0].1]", "    let mut i = 0;\n   \
    \ for (index, n) in arr.iter().enumerate() {\n        if n % 2 == 0 {\n      \
    \      if i == 0 || n < &arr[i - 1] {\n                i = index + 1;\n      \
    \      }\n        }\n    }\n    if i > 0 {\n        vec![arr[i - 1], i as isize]\n\
    \    } else {\n        vec![]\n    }", "    let mut min = isize::max_value();\n\
    \    let mut index = 0;\n    for (i, &x) in arr.iter().enumerate() {\n       \
    \ if x % 2 == 0 && x < min {\n            min = x;\n            index = i;\n \
    \       }\n    }\n    if min == isize::max_value() {\n        return vec![];\n\
    \    }\n    vec![min, index as isize]", "    let mut evens: Vec<(isize, usize)>\
    \ = arr\n        .iter()\n        .enumerate()\n        .filter(|(_i, v)| *v %\
    \ 2 == 0)\n        .collect();\n    evens.sort_by(|a, b| (a.0).cmp(&b.0));\n \
    \   match evens.first() {\n        Some(x) => vec![x.0 as isize, x.1 as isize],\n\
    \        None => vec![],\n    }", '    unimplemented!();']
stop_tokens:
- "\n}"
