name: HumanEval_9_rolling_max
language: rs
prompt: "/// From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n/// in the sequence.\nfn rolling_max(numbers: Vec<isize>)\
  \ -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()),\
  \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2,\
  \ 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3,\
  \ 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n"
completions: ["    let mut rolling_max = Vec::new();\n    let mut current_max = numbers[0];\n\
    \    rolling_max.push(current_max);\n\n    for i in 1..numbers.len() {\n     \
    \   current_max = std::cmp::max(current_max, numbers[i]);\n        rolling_max.push(current_max);\n\
    \    }\n\n    rolling_max", "    let mut max_found = numbers[0];\n    let mut\
    \ result = Vec::new();\n    result.push(max_found);\n\n    for &number in numbers.iter().skip(1)\
    \ {\n        max_found = max(max_found, number);\n        result.push(max_found);\n\
    \    }\n\n    result", "    if numbers.is_empty() {\n        return Vec::new();\n\
    \    }\n\n    let mut result = Vec::with_capacity(numbers.len());\n    let mut\
    \ max = numbers[0];\n    result.push(max);\n\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max {\n            max = numbers[i];\n        }\n   \
    \     result.push(max);\n    }\n\n    result", "    let mut maximums = Vec::with_capacity(numbers.len());\n\
    \    let mut max_element = numbers[0];\n    maximums.push(max_element);\n\n  \
    \  for i in 1..numbers.len() {\n        max_element = max(max_element, numbers[i]);\n\
    \        maximums.push(max_element);\n    }\n\n    maximums", "    let mut result\
    \ = Vec::new();\n    let mut current_max = numbers[0];\n    result.push(current_max);\n\
    \    for i in 1..numbers.len() {\n        current_max = if numbers[i] > current_max\
    \ {\n            numbers[i]\n        } else {\n            current_max\n     \
    \   };\n        result.push(current_max);\n    }\n    result", "    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n    let mut max_element = numbers[0];\n    rolling_max.push(max_element);\n\
    \n    for element in numbers[1..].iter() {\n        max_element = std::cmp::max(max_element,\
    \ *element);\n        rolling_max.push(max_element);\n    }\n\n    rolling_max",
  "    let mut result = Vec::new();\n    for window in numbers.windows(3) {\n    \
    \    result.push(*window.iter().max().unwrap());\n    }\n    result", "    numbers\n\
    \        .iter()\n        .scan(None, |state, &x| {\n            *state = match\
    \ *state {\n                None => Some(x),\n                Some(state) => Some(std::cmp::max(state,\
    \ x)),\n            };\n            Some(*state)\n        })\n        .collect()",
  "    if numbers.is_empty() {\n        return vec![];\n    }\n\n    let mut result\
    \ = vec![];\n    let mut current_max = numbers[0];\n    result.push(current_max);\n\
    \n    for i in 1..numbers.len() {\n        current_max = current_max.max(numbers[i]);\n\
    \        result.push(current_max);\n    }\n\n    result", "    let mut output\
    \ = Vec::new();\n    let mut current_max = numbers[0];\n    output.push(current_max);\n\
    \n    for &number in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ number);\n        output.push(current_max);\n    }\n\n    output", "    let\
    \ mut result = Vec::new();\n    let mut max = 0;\n    for n in numbers {\n   \
    \     max = n.max(max);\n        result.push(max);\n    }\n    result", "    let\
    \ mut max = 0;\n    let mut result = Vec::new();\n    for number in numbers {\n\
    \        if number > max {\n            max = number;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n\n    for i in 1..numbers.len() {\n        if numbers[i]\
    \ > max {\n            max = numbers[i];\n        }\n        result.push(max);\n\
    \    }\n\n    result", "    let mut stack = Vec::new();\n    let mut maxes = Vec::new();\n\
    \n    for &num in numbers.iter() {\n        while !stack.is_empty() && stack.last().unwrap()\
    \ < &num {\n            stack.pop();\n        }\n\n        stack.push(num);\n\
    \        maxes.push(stack.last().unwrap().clone());\n    }\n\n    maxes", "  \
    \  let mut max_so_far = numbers[0];\n    let mut result = vec![];\n    for number\
    \ in numbers {\n        if number > max_so_far {\n            max_so_far = number;\n\
    \        }\n        result.push(max_so_far);\n    }\n    result", "    let mut\
    \ max_numbers = vec![numbers[0]];\n    let mut max_value = numbers[0];\n\n   \
    \ for n in numbers.iter().skip(1) {\n        max_value = max_value.max(*n);\n\
    \        max_numbers.push(max_value);\n    }\n\n    max_numbers", "    let mut\
    \ rolling_max = Vec::new();\n    let mut current_max = numbers[0];\n    rolling_max.push(current_max);\n\
    \n    for n in numbers.iter().skip(1) {\n        if n > &current_max {\n     \
    \       current_max = *n;\n        }\n        rolling_max.push(current_max);\n\
    \    }\n\n    rolling_max", "    let mut rolling_max: Vec<isize> = Vec::new();\n\
    \    let mut maximum: isize = numbers[0];\n    rolling_max.push(maximum);\n\n\
    \    for number in numbers.iter().skip(1) {\n        maximum = if number > &maximum\
    \ {\n            *number\n        } else {\n            maximum\n        };\n\
    \        rolling_max.push(maximum);\n    }\n\n    rolling_max", "    let mut max_numbers\
    \ = Vec::with_capacity(numbers.len());\n    let mut max = isize::min_value();\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        max_numbers.push(max);\n\
    \    }\n    max_numbers", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    result.push(max);\n    for &n in numbers.iter().skip(1)\
    \ {\n        if n > max {\n            max = n;\n        }\n        result.push(max);\n\
    \    }\n    result", "    let mut max = numbers[0];\n    numbers\n        .iter()\n\
    \        .map(|&n| {\n            if n > max {\n                max = n;\n   \
    \         }\n            max\n        })\n        .collect()", "    numbers\n\
    \        .iter()\n        .scan(None, |state, &n| {\n            if state.is_none()\
    \ {\n                *state = Some(n);\n            } else {\n               \
    \ let state_val = state.unwrap();\n                if n > state_val {\n      \
    \              *state = Some(n);\n                }\n            }\n         \
    \   Some(*state.unwrap())\n        })\n        .collect()", "    let mut max =\
    \ std::isize::MIN;\n    let mut rolling_max: Vec<isize> = Vec::new();\n\n    for\
    \ n in numbers {\n        if n > max {\n            max = n;\n        }\n    \
    \    rolling_max.push(max);\n    }\n\n    rolling_max", "    let mut max = std::isize::MIN;\n\
    \    let mut result = Vec::new();\n    for n in numbers {\n        max = n.max(max);\n\
    \        result.push(max);\n    }\n    result", "    // final_sequence[i] = max(numbers[i],\
    \ .., numbers[numbers.len() - 1])\n    let mut final_sequence = Vec::with_capacity(numbers.len());\n\
    \    let mut result = numbers[numbers.len() - 1];\n    for _ in 0..numbers.len()\
    \ {\n        final_sequence.push(result);\n        result = result.max(numbers[final_sequence.len()\
    \ - 1]);\n    }\n    final_sequence.reverse();\n    final_sequence", "    let\
    \ mut max = std::isize::MIN;\n    let mut maxes = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        maxes.push(max);\n\
    \    }\n    maxes", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ n in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ *n);\n        result.push(current_max);\n    }\n    result", "    let mut result\
    \ = Vec::new();\n    let mut max = None;\n\n    for number in numbers {\n    \
    \    max = match max {\n            Some(candidate) => Some(if candidate > number\
    \ {\n                candidate\n            } else {\n                number\n\
    \            }),\n            None => Some(number),\n        };\n\n        result.push(max.unwrap());\n\
    \    }\n\n    result", "    let mut res = Vec::new();\n    let mut max = numbers[0];\n\
    \    res.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        res.push(max);\n    }\n    res", "    numbers\n        .iter()\n    \
    \    .scan(0, |acc, x| {\n            *acc = cmp::max(*acc, *x);\n           \
    \ Some(*acc)\n        })\n        .collect()", "    let mut max_element = numbers[0];\n\
    \    let mut output: Vec<isize> = Vec::new();\n    output.push(max_element);\n\
    \n    for n in numbers.iter().skip(1) {\n        if n > &max_element {\n     \
    \       max_element = *n;\n        }\n        output.push(max_element);\n    }\n\
    \n    output", "    let mut max: isize = numbers[0];\n    let mut rolling_max\
    \ = vec![max];\n\n    for x in numbers[1..].iter() {\n        if x > &max {\n\
    \            max = *x;\n        }\n        rolling_max.push(max);\n    }\n\n \
    \   rolling_max", "    let mut rolling_max = vec![];\n    let mut max_so_far =\
    \ None;\n\n    for number in numbers {\n        match max_so_far {\n         \
    \   Some(max) => {\n                rolling_max.push(max);\n                max_so_far\
    \ = Some(std::cmp::max(max, number));\n            }\n            None => {\n\
    \                rolling_max.push(number);\n                max_so_far = Some(number);\n\
    \            }\n        }\n    }\n\n    rolling_max", "    let mut max: isize\
    \ = numbers[0];\n    let mut rolling_max: Vec<isize> = Vec::new();\n    rolling_max.push(max);\n\
    \n    for n in numbers {\n        if n > max {\n            max = n;\n       \
    \ }\n        rolling_max.push(max);\n    }\n\n    rolling_max", "    let mut result\
    \ = Vec::new();\n    result.push(numbers[0]);\n    for &number in numbers.iter().skip(1)\
    \ {\n        result.push(std::cmp::max(result.last().unwrap(), &number));\n  \
    \  }\n    result", "    let mut results = Vec::new();\n    let mut max = numbers[0];\n\
    \    for i in 1..numbers.len() {\n        max = std::cmp::max(max, numbers[i]);\n\
    \        results.push(max);\n    }\n    results", "    numbers\n        .iter()\n\
    \        .scan(0, |acc, &x| {\n            *acc = if x > *acc { x } else { *acc\
    \ };\n            Some(*acc)\n        })\n        .collect()", "    numbers\n\
    \        .iter()\n        .enumerate()\n        .map(|(i, val)| {\n          \
    \  numbers[0..i + 1]\n                .iter()\n                .map(|n| *n)\n\
    \                .max()\n                .unwrap_or(*val)\n        })\n      \
    \  .collect()", "    let mut result = Vec::new();\n    let mut max = 0;\n    for\
    \ num in numbers {\n        max = std::cmp::max(max, num);\n        result.push(max);\n\
    \    }\n    result", "    numbers\n        .iter()\n        .scan(None, |rolling_max,\
    \ i| {\n            match rolling_max {\n                None => {\n         \
    \           *rolling_max = Some(*i);\n                    Some(*i)\n         \
    \       }\n                Some(max) => {\n                    if *i > max {\n\
    \                        *rolling_max = Some(*i);\n                    }\n   \
    \                 Some(max)\n                }\n            }\n        })\n  \
    \      .collect()", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n\n    for current in numbers {\n     \
    \   if current > max {\n            max = current;\n        }\n\n        result.push(max);\n\
    \    }\n\n    result", "    let mut rolling_max: Vec<isize> = Vec::new();\n  \
    \  for n in numbers {\n        if rolling_max.is_empty() {\n            rolling_max.push(n);\n\
    \        } else {\n            let last_max = rolling_max.last().unwrap();\n \
    \           if n > *last_max {\n                rolling_max.push(n);\n       \
    \     } else {\n                rolling_max.push(*last_max);\n            }\n\
    \        }\n    }\n    rolling_max", "    if numbers.is_empty() {\n        return\
    \ vec![];\n    }\n\n    let mut rolling_max_numbers = vec![numbers[0]];\n    let\
    \ mut current_max = numbers[0];\n\n    for i in 1..numbers.len() {\n        if\
    \ numbers[i] > current_max {\n            current_max = numbers[i];\n        }\n\
    \n        rolling_max_numbers.push(current_max);\n    }\n\n    rolling_max_numbers",
  "    let mut stack = Vec::new();\n    let mut res = Vec::new();\n\n    for number\
    \ in numbers {\n        // Dropping elements from the stack for which we have\
    \ a bigger element.\n        while let Some(el) = stack.last() {\n           \
    \ if *el < number {\n                stack.pop();\n            } else {\n    \
    \            break;\n            }\n        }\n\n        // Pushing current element\
    \ on the stack.\n        stack.push(number);\n\n        // Adding the current\
    \ maximum number to the result.\n        res.push(*stack.last().unwrap());\n \
    \   }\n\n    res", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_so_far = std::isize::MIN;\n\n    for number in numbers {\n  \
    \      max_so_far = max_so_far.max(number);\n        result.push(max_so_far);\n\
    \    }\n\n    result", "    let mut answer = Vec::with_capacity(numbers.len());\n\
    \    let mut max = numbers[0];\n    answer.push(max);\n    for i in 1..numbers.len()\
    \ {\n        max = std::cmp::max(max, numbers[i]);\n        answer.push(max);\n\
    \    }\n    answer", "    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |state, &x| {\n            if x > *state {\n                *state = x;\n  \
    \          }\n            Some(*state)\n        })\n        .collect()", "   \
    \ let mut max = 0;\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result", "    let mut i = 0;\n    let mut\
    \ max = 0;\n    let mut result = Vec::new();\n\n    while i < numbers.len() {\n\
    \        if numbers[i] > max {\n            max = numbers[i];\n        }\n\n \
    \       result.push(max);\n        i += 1;\n    }\n\n    result", "    let mut\
    \ max: isize = isize::min_value();\n    let mut result: Vec<isize> = Vec::new();\n\
    \n    for n in numbers {\n        if n > max {\n            max = n;\n       \
    \ }\n        result.push(max);\n    }\n\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for number in numbers {\n        max\
    \ = std::cmp::max(max, number);\n        result.push(max);\n    }\n    result",
  "    let mut max = numbers[0];\n    let mut rolling_max: Vec<isize> = vec![max];\n\
    \n    for number in numbers.iter().skip(1) {\n        max = cmp::max(max, *number);\n\
    \        rolling_max.push(max);\n    }\n\n    rolling_max", "    let mut result\
    \ = Vec::new();\n    let mut current_max = 0;\n    for number in numbers {\n \
    \       if number > current_max {\n            current_max = number;\n       \
    \ }\n        result.push(current_max);\n    }\n    result", "    let mut result\
    \ = Vec::new();\n    let mut max = isize::min_value();\n\n    for n in numbers\
    \ {\n        if n > max {\n            max = n;\n        }\n\n        result.push(max);\n\
    \    }\n\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut current_max = numbers[0];\n    result.push(current_max);\n    for\
    \ i in 1..numbers.len() {\n        current_max = std::cmp::max(current_max, numbers[i]);\n\
    \        result.push(current_max);\n    }\n    result", "    let mut max = std::isize::MIN;\n\
    \    let mut max_list = Vec::with_capacity(numbers.len());\n    for n in numbers\
    \ {\n        max = max.max(n);\n        max_list.push(max);\n    }\n    max_list",
  "    let mut rolling_max_list = Vec::new();\n    for n in numbers {\n        if\
    \ rolling_max_list.is_empty() {\n            rolling_max_list.push(n);\n     \
    \   } else {\n            rolling_max_list.push(cmp::max(rolling_max_list[rolling_max_list.len()\
    \ - 1], n));\n        }\n    }\n    rolling_max_list", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = isize::min_value();\n\n    for number in numbers {\n      \
    \  max = if number > max {\n            number\n        } else {\n           \
    \ max\n        };\n\n        result.push(max);\n    }\n\n    result", "    let\
    \ mut max_so_far = isize::min_value();\n    let mut result = Vec::new();\n\n \
    \   for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number;\n        }\n\n        result.push(max_so_far);\n    }\n\n    result",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let mut current_max\
    \ = isize::min_value();\n\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n\n        result.push(current_max);\n\
    \    }\n\n    result", "    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |state, &x| {\n            *state = std::cmp::max(*state, x);\n            Some(*state)\n\
    \        })\n        .collect()", "    let mut result = Vec::new();\n    let mut\
    \ maximum = std::isize::MIN;\n\n    for n in numbers {\n        maximum = std::cmp::max(maximum,\
    \ n);\n        result.push(maximum);\n    }\n\n    result", "    let mut numbers\
    \ = numbers;\n    let mut rolling_max = vec![];\n    rolling_max.push(numbers[0]);\n\
    \    numbers.remove(0);\n\n    for number in numbers {\n        let last_max =\
    \ rolling_max[rolling_max.len() - 1];\n        rolling_max.push(if number > last_max\
    \ { number } else { last_max });\n    }\n\n    rolling_max", "    let mut ret\
    \ = Vec::new();\n    let mut max = numbers[0];\n    ret.push(max);\n    for n\
    \ in numbers[1..].iter() {\n        if *n > max {\n            max = *n;\n   \
    \     }\n        ret.push(max);\n    }\n    ret", "    let mut max_list = Vec::new();\n\
    \    let mut curr_max = isize::min_value();\n\n    for number in numbers {\n \
    \       if number > curr_max {\n            curr_max = number;\n        }\n\n\
    \        max_list.push(curr_max);\n    }\n\n    max_list", "    let mut result\
    \ = Vec::new();\n    let mut max = isize::min_value();\n\n    for x in numbers\
    \ {\n        max = max.max(x);\n        result.push(max);\n    }\n\n    result",
  "    let mut result = Vec::new();\n    let mut maximum = std::isize::MIN;\n\n  \
    \  for n in numbers {\n        maximum = std::cmp::max(maximum, n);\n        result.push(maximum);\n\
    \    }\n\n    result", "    numbers\n        .iter()\n        .fold(Vec::new(),\
    \ |mut acc, &num| {\n            if acc.is_empty() {\n                acc.push(num);\n\
    \            } else {\n                acc.push(acc.last().unwrap().max(num));\n\
    \            }\n            acc\n        })", "    let mut max: Vec<isize> = Vec::new();\n\
    \    max.push(numbers[0]);\n    for i in 1..numbers.len() {\n        max.push(std::cmp::max(max[i\
    \ - 1], numbers[i]));\n    }\n    max", "    let mut stack = Vec::new();\n   \
    \ let mut result = Vec::new();\n\n    for number in numbers {\n        while !stack.is_empty()\
    \ && stack.last().unwrap() < &number {\n            stack.pop();\n        }\n\n\
    \        stack.push(number);\n        result.push(stack.last().unwrap().clone());\n\
    \    }\n\n    result", "    let mut rolling_max: Vec<isize> = Vec::new();\n  \
    \  let mut max = std::isize::MIN;\n    for i in 0..numbers.len() {\n        if\
    \ numbers[i] > max {\n            max = numbers[i];\n        }\n        rolling_max.push(max);\n\
    \    }\n    rolling_max", "    numbers\n        .into_iter()\n        .scan(None,\
    \ |max, current| {\n            *max = max.map(|m| std::cmp::max(m, current)).or(Some(current));\n\
    \            Some(*max.unwrap())\n        })\n        .collect()", "    let mut\
    \ rolling_max = Vec::with_capacity(numbers.len());\n    let mut current_max =\
    \ isize::min_value();\n\n    for number in numbers {\n        current_max = current_max.max(number);\n\
    \        rolling_max.push(current_max);\n    }\n\n    rolling_max", "    let mut\
    \ ret = Vec::new();\n    let mut max_element = isize::min_value();\n    for element\
    \ in numbers {\n        if element > max_element {\n            max_element =\
    \ element;\n        }\n        ret.push(max_element);\n    }\n    ret", "    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let mut current_max = 0;\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number;\n        }\n        result.push(current_max);\n    }\n    result",
  "    let mut max = numbers[0];\n    let mut result = Vec::new();\n    result.push(max);\n\
    \n    for i in 1..numbers.len() {\n        max = cmp::max(max, numbers[i]);\n\
    \        result.push(max);\n    }\n\n    result", "    let mut max = isize::min_value();\n\
    \    let mut result = Vec::new();\n\n    for number in numbers {\n        if number\
    \ > max {\n            max = number;\n        }\n\n        result.push(max);\n\
    \    }\n\n    result", "    let mut rolling_max = Vec::new();\n    let mut max_so_far\
    \ = std::isize::MIN;\n    for number in numbers {\n        max_so_far = std::cmp::max(max_so_far,\
    \ number);\n        rolling_max.push(max_so_far);\n    }\n    rolling_max", " \
    \   let mut rolling_max: Vec<isize> = Vec::new();\n    let mut max_val = std::isize::MIN;\n\
    \    for i in numbers {\n        if i > max_val {\n            max_val = i;\n\
    \        }\n        rolling_max.push(max_val);\n    }\n    rolling_max", "   \
    \ let mut result = Vec::new();\n    let mut max = numbers[0];\n    result.push(max);\n\
    \    for i in 1..numbers.len() {\n        max = std::cmp::max(max, numbers[i]);\n\
    \        result.push(max);\n    }\n    result", "    let mut max_numbers = Vec::new();\n\
    \    let mut max_number = numbers[0];\n    max_numbers.push(max_number);\n\n \
    \   for i in 1..numbers.len() {\n        max_number = max(max_number, numbers[i]);\n\
    \        max_numbers.push(max_number);\n    }\n\n    max_numbers", "    numbers\n\
    \        .iter()\n        .scan(None, |maximum, &n| {\n            *maximum =\
    \ maximum.map_or(Some(n), |maximum| Some(maximum.max(n)));\n            *maximum\n\
    \        })\n        .map(|o| o.unwrap())\n        .collect()", "    let mut result\
    \ = Vec::new();\n    let mut curr_max = std::isize::MIN;\n\n    for num in numbers\
    \ {\n        curr_max = std::cmp::max(curr_max, num);\n        result.push(curr_max);\n\
    \    }\n\n    result", "    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n\n    result", "    let mut max_value = std::isize::MIN;\n\
    \    let mut result = Vec::new();\n\n    for value in numbers {\n        if value\
    \ > max_value {\n            max_value = value;\n        }\n\n        result.push(max_value);\n\
    \    }\n\n    result", "    let mut current_max = 0;\n    let mut rolling_max:\
    \ Vec<isize> = Vec::new();\n\n    for n in numbers {\n        if n > current_max\
    \ {\n            current_max = n;\n        }\n        rolling_max.push(current_max);\n\
    \    }\n\n    rolling_max", "    let mut res = Vec::new();\n    let mut current_max\
    \ = numbers[0];\n    res.push(current_max);\n    for i in numbers.iter().skip(1)\
    \ {\n        current_max = std::cmp::max(current_max, *i);\n        res.push(current_max);\n\
    \    }\n    res", "    // Create a window of the size of given numbers vector,\
    \ which will slide from left to right\n    // along the vector.\n    let mut rolling_max\
    \ = numbers.iter().cloned().take(numbers.len()).collect::<Vec<isize>>();\n\n \
    \   for i in 1..numbers.len() {\n        let previous_value = rolling_max[i -\
    \ 1];\n        let current_value = numbers[i];\n\n        rolling_max[i] = std::cmp::max(previous_value,\
    \ current_value);\n    }\n\n    rolling_max", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for i in numbers {\n        if i > max\
    \ {\n            max = i;\n        }\n        result.push(max);\n    }\n    result",
  "    let mut rolling_max = Vec::new();\n    rolling_max.push(numbers[0]);\n\n  \
    \  let mut i = 1;\n    while i < numbers.len() {\n        rolling_max.push(std::cmp::max(rolling_max[i\
    \ - 1], numbers[i]));\n        i += 1;\n    }\n\n    rolling_max", "    // The\
    \ current maximum element\n    let mut max = isize::min_value();\n\n    numbers\n\
    \        .into_iter()\n        .map(|x| {\n            // If the current element\
    \ is greater than the current maximum element, update it\n            if x > max\
    \ {\n                max = x;\n            }\n\n            // Return the current\
    \ maximum element. Since `max` can't be `isize::min_value()`,\n            //\
    \ if the maximum is `isize::min_value()`, `x` can't be `isize::min_value()`, hence\n\
    \            // `x` must be greater than `max` and `max` is updated with `x`.\n\
    \            max\n        })\n        .collect()", "    let mut memo = vec![];\n\
    \    let mut max = 0;\n    for num in numbers {\n        if num > max {\n    \
    \        max = num;\n        }\n        memo.push(max);\n    }\n    memo", " \
    \   let mut max_values = vec![numbers[0]];\n    for (index, number) in numbers.iter().enumerate()\
    \ {\n        if index == 0 {\n            continue;\n        }\n        max_values.push(std::cmp::max(max_values[index\
    \ - 1], *number));\n    }\n    max_values", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        result.push(max);\n    }\n    result",
  "    let mut result = Vec::new();\n    let mut max = 0;\n    for (i, number) in\
    \ numbers.iter().enumerate() {\n        if *number > max {\n            max =\
    \ *number;\n        }\n        result.push(max);\n    }\n    result", "    let\
    \ mut max_so_far = isize::min_value();\n    let mut result = Vec::with_capacity(numbers.len());\n\
    \n    for number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number;\n        }\n\n        result.push(max_so_far);\n    }\n\n    result",
  "    let mut rolling_max: Vec<isize> = vec![];\n    let mut maximum = std::isize::MIN;\n\
    \    for &number in numbers.iter() {\n        maximum = std::cmp::max(maximum,\
    \ number);\n        rolling_max.push(maximum);\n    }\n    rolling_max", "   \
    \ let mut rolling_max: Vec<isize> = Vec::new();\n    let mut max = 0;\n    for\
    \ &num in numbers.iter() {\n        if num > max {\n            max = num;\n \
    \       }\n        rolling_max.push(max);\n    }\n    rolling_max", "    if numbers.is_empty()\
    \ {\n        return vec![];\n    }\n\n    let mut rolling_max = vec![numbers[0]];\n\
    \    let mut max = numbers[0];\n\n    for i in 1..numbers.len() {\n        max\
    \ = max.max(numbers[i]);\n        rolling_max.push(max);\n    }\n\n    rolling_max",
  "    let mut result = Vec::new();\n    let mut max = 0;\n    for n in numbers {\n\
    \        max = n.max(max);\n        result.push(max);\n    }\n    result", " \
    \   let mut max = numbers[0];\n    let mut rolling_max = vec![];\n    for &n in\
    \ numbers.iter() {\n        max = std::cmp::max(max, n);\n        rolling_max.push(max);\n\
    \    }\n    rolling_max", "    let mut max_vec = Vec::new();\n    let mut max_val\
    \ = *numbers.first().unwrap();\n    for num in numbers {\n        max_val = std::cmp::max(max_val,\
    \ num);\n        max_vec.push(max_val);\n    }\n    max_vec", "    let mut rolling_max\
    \ = Vec::new();\n    let mut current_max = 0;\n    for number in numbers {\n \
    \       current_max = std::cmp::max(current_max, number);\n        rolling_max.push(current_max);\n\
    \    }\n    rolling_max", "    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |max, &number| {\n            *max = std::cmp::max(*max, number);\n        \
    \    Some(*max)\n        })\n        .collect()", "    let mut result = Vec::new();\n\
    \    let mut curr_max = std::isize::MIN;\n\n    for &number in numbers.iter()\
    \ {\n        if number > curr_max {\n            curr_max = number;\n        }\n\
    \n        result.push(curr_max);\n    }\n\n    result", "    numbers\n       \
    \ .iter()\n        .scan(std::isize::MIN, |max, &n| {\n            if n > *max\
    \ {\n                *max = n;\n            }\n            Some(*max)\n      \
    \  })\n        .collect()", "    if numbers.is_empty() {\n        return vec![];\n\
    \    }\n\n    let mut max_numbers = vec![numbers[0]];\n    for i in 1..numbers.len()\
    \ {\n        max_numbers.push(max(max_numbers[i - 1], numbers[i]));\n    }\n\n\
    \    max_numbers", "    let len = numbers.len();\n    let mut result = Vec::with_capacity(len);\n\
    \    let mut max_so_far = isize::min_value();\n\n    for (i, number) in numbers.iter().enumerate()\
    \ {\n        max_so_far = max_so_far.max(*number);\n        if i == len - 1 {\n\
    \            result.push(max_so_far);\n        } else {\n            result.push(max_so_far);\n\
    \        }\n    }\n\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max_element = isize::min_value();\n\n    for &i in numbers.iter()\
    \ {\n        if i > max_element {\n            max_element = i;\n        }\n\n\
    \        result.push(max_element);\n    }\n\n    result", "    let mut max_values\
    \ = Vec::new();\n    let mut current_max = numbers[0];\n    max_values.push(current_max);\n\
    \n    for number in numbers.iter().skip(1) {\n        if *number > current_max\
    \ {\n            current_max = *number;\n        }\n        max_values.push(current_max);\n\
    \    }\n\n    max_values", "    let mut result = Vec::new();\n    let mut max\
    \ = numbers[0];\n    result.push(max);\n    for i in 1..numbers.len() {\n    \
    \    max = std::cmp::max(max, numbers[i]);\n        result.push(max);\n    }\n\
    \    result", "    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \n    for n in numbers {\n        max = max.max(n);\n        result.push(max);\n\
    \    }\n\n    result", "    let mut result = Vec::new();\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result", "    let mut running_max = 0;\n\
    \    let mut result = Vec::new();\n\n    for number in numbers {\n        running_max\
    \ = std::cmp::max(running_max, number);\n        result.push(running_max);\n \
    \   }\n\n    result", "    let mut output = Vec::new();\n    let mut max = numbers[0];\n\
    \    output.push(max);\n    for current in numbers.iter().skip(1) {\n        if\
    \ *current > max {\n            max = *current;\n        }\n        output.push(max);\n\
    \    }\n    output", "    let mut result = Vec::new();\n    let mut max = isize::min_value();\n\
    \n    for n in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n\n    result", "    numbers\n        .into_iter()\n        .fold(vec![],\
    \ |mut acc, x| {\n            if acc.is_empty() {\n                acc.push(x);\n\
    \            } else {\n                let previous_max = acc.last().unwrap();\n\
    \                acc.push(std::cmp::max(*previous_max, x));\n            }\n \
    \           acc\n        })", "    let mut result = Vec::new();\n    let mut max\
    \ = numbers[0];\n    result.push(max);\n    for n in numbers.iter().skip(1) {\n\
    \        max = std::cmp::max(max, *n);\n        result.push(max);\n    }\n   \
    \ result", "    let mut max_element = 0;\n    let mut result = Vec::new();\n\n\
    \    for number in numbers {\n        if number > max_element {\n            max_element\
    \ = number;\n        }\n\n        result.push(max_element);\n    }\n\n    result",
  "    let numbers_len = numbers.len();\n    let mut sequence: Vec<isize> = Vec::with_capacity(numbers_len);\n\
    \    for (index, number) in numbers.iter().enumerate() {\n        let mut max\
    \ = *number;\n        for i in index + 1..numbers_len {\n            if max <\
    \ numbers[i] {\n                max = numbers[i];\n            }\n        }\n\
    \        sequence.push(max);\n    }\n    sequence", "    let mut result = Vec::new();\n\
    \    let mut current_max = isize::min_value();\n\n    for number in numbers {\n\
    \        if number > current_max {\n            current_max = number;\n      \
    \  }\n\n        result.push(current_max);\n    }\n\n    result", "    let mut\
    \ current_max = numbers[0];\n    let mut result = Vec::new();\n    result.push(current_max);\n\
    \n    for number in numbers.iter().skip(1) {\n        current_max = isize::max(current_max,\
    \ *number);\n        result.push(current_max);\n    }\n\n    result", "    numbers\n\
    \        .iter()\n        .scan(0, |acc, x| {\n            *acc = std::cmp::max(*acc,\
    \ *x);\n            Some(*acc)\n        })\n        .collect()", "    let mut\
    \ rolling_max = Vec::new();\n    let mut max = std::isize::MIN;\n    for n in\
    \ numbers {\n        max = std::cmp::max(max, n);\n        rolling_max.push(max);\n\
    \    }\n    rolling_max", "    let mut maximums = Vec::new();\n    let mut max\
    \ = numbers[0];\n    for &number in numbers.iter() {\n        max = std::cmp::max(max,\
    \ number);\n        maximums.push(max);\n    }\n    maximums", "    let mut rolling_max\
    \ = Vec::new();\n    let mut current_max = std::isize::MIN;\n\n    for number\
    \ in numbers {\n        if number > current_max {\n            current_max = number;\n\
    \        }\n\n        rolling_max.push(current_max);\n    }\n\n    rolling_max",
  "    let mut rolling_max_values = Vec::new();\n    let mut current_max = std::isize::MIN;\n\
    \n    for number in numbers {\n        if number > current_max {\n           \
    \ current_max = number;\n        }\n\n        rolling_max_values.push(current_max);\n\
    \    }\n\n    rolling_max_values", "    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |state, &item| {\n            if item > *state {\n                *state = item;\n\
    \            }\n            Some(*state)\n        })\n        .collect()", " \
    \   let mut maximum = numbers[0];\n    let mut results = Vec::new();\n    for\
    \ number in numbers {\n        if number > maximum {\n            maximum = number;\n\
    \        }\n        results.push(maximum);\n    }\n    results", "    let mut\
    \ current_max = 0;\n    let mut results = Vec::new();\n\n    for number in numbers\
    \ {\n        if number > current_max {\n            current_max = number;\n  \
    \      }\n\n        results.push(current_max);\n    }\n\n    results", "    let\
    \ mut rolling_max = Vec::new();\n    rolling_max.push(numbers[0]);\n\n    for\
    \ index in 1..numbers.len() {\n        rolling_max.push(std::cmp::max(rolling_max[index\
    \ - 1], numbers[index]));\n    }\n\n    rolling_max", "    let mut current_max\
    \ = 0;\n    let mut result = Vec::new();\n\n    for number in numbers {\n    \
    \    if number > current_max {\n            current_max = number;\n        }\n\
    \n        result.push(current_max);\n    }\n\n    result", "    let mut rolling_max\
    \ = Vec::with_capacity(numbers.len());\n    let mut current_max = None;\n\n  \
    \  for number in numbers {\n        current_max = Some(current_max.map_or(number,\
    \ |max| max.max(number)));\n        rolling_max.push(current_max.unwrap());\n\
    \    }\n\n    rolling_max", "    let mut max_seen = std::isize::MIN;\n    let\
    \ mut result = Vec::new();\n    for number in numbers {\n        max_seen = std::cmp::max(max_seen,\
    \ number);\n        result.push(max_seen);\n    }\n    result", "    let mut max_elements\
    \ = Vec::with_capacity(numbers.len());\n    let mut max_element = std::isize::MIN;\n\
    \n    for number in numbers {\n        if number > max_element {\n           \
    \ max_element = number;\n        }\n\n        max_elements.push(max_element);\n\
    \    }\n\n    max_elements", "    numbers\n        .into_iter()\n        .scan(0,\
    \ |state, x| {\n            *state = std::cmp::max(*state, x);\n            Some(*state)\n\
    \        })\n        .collect()", "    let mut max = numbers[0];\n    numbers.iter().map(|&x|\
    \ {\n        if x > max {\n            max = x;\n        }\n        max\n    }).collect()",
  "    let mut result = Vec::new();\n    let mut largest = 0;\n    for x in numbers\
    \ {\n        largest = if x > largest { x } else { largest };\n        result.push(largest);\n\
    \    }\n    result", "    let mut max = numbers[0];\n    let mut result = Vec::new();\n\
    \    result.push(max);\n\n    for n in numbers.iter().skip(1) {\n        if n\
    \ > &max {\n            max = *n;\n        }\n        result.push(max);\n    }\n\
    \n    result", "    if numbers.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut max: isize = numbers[0];\n    let mut result: Vec<isize> = vec![max];\n\
    \n    for n in numbers.iter().skip(1) {\n        if n > &max {\n            max\
    \ = *n;\n        }\n        result.push(max);\n    }\n\n    result", "    let\
    \ mut result = Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n\
    \    result.push(max);\n    for i in 1..numbers.len() {\n        max = max.max(numbers[i]);\n\
    \        result.push(max);\n    }\n    result", "    let mut rolling_max: Vec<isize>\
    \ = Vec::new();\n    let mut current_max = numbers[0];\n    rolling_max.push(current_max);\n\
    \n    for i in 1..numbers.len() {\n        if numbers[i] > current_max {\n   \
    \         current_max = numbers[i];\n        }\n        rolling_max.push(current_max);\n\
    \    }\n\n    rolling_max", "    let mut max = numbers[0];\n    let mut result\
    \ = Vec::new();\n    result.push(max);\n\n    for i in 1..numbers.len() {\n  \
    \      if numbers[i] > max {\n            max = numbers[i];\n        }\n     \
    \   result.push(max);\n    }\n\n    result", "    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    let mut max_so_far = numbers[0];\n    rolling_max.push(max_so_far);\n\n \
    \   for i in 1..numbers.len() {\n        max_so_far = max(max_so_far, numbers[i]);\n\
    \        rolling_max.push(max_so_far);\n    }\n\n    rolling_max", "    let mut\
    \ max = std::isize::MIN;\n    let mut maxes = Vec::new();\n    for num in numbers\
    \ {\n        max = num.max(max);\n        maxes.push(max);\n    }\n    maxes",
  "    if numbers.is_empty() {\n        return Vec::new();\n    }\n\n    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    let mut current_max = numbers[0];\n\
    \    result.push(current_max);\n\n    for i in 1..numbers.len() {\n        if\
    \ numbers[i] > current_max {\n            current_max = numbers[i];\n        }\n\
    \        result.push(current_max);\n    }\n\n    result", "    let mut rolling_max\
    \ = Vec::new();\n    let mut tmp_max = numbers[0];\n    rolling_max.push(tmp_max);\n\
    \n    for i in 1..numbers.len() {\n        tmp_max = std::cmp::max(tmp_max, numbers[i]);\n\
    \        rolling_max.push(tmp_max);\n    }\n\n    rolling_max", "    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n    result.push(max);\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] > max {\n            max\
    \ = numbers[i];\n        }\n        result.push(max);\n    }\n    result", " \
    \   let mut max = numbers[0];\n    let mut result = Vec::new();\n    result.push(max);\n\
    \n    for index in 1..numbers.len() {\n        max = std::cmp::max(max, numbers[index]);\n\
    \        result.push(max);\n    }\n\n    result", "    let mut max = isize::min_value();\n\
    \    let mut result = Vec::with_capacity(numbers.len());\n\n    for i in numbers\
    \ {\n        if i > max {\n            max = i;\n        }\n        result.push(max);\n\
    \    }\n\n    result", "    let mut rolling_max: Vec<isize> = Vec::new();\n  \
    \  for number in numbers {\n        rolling_max.push(match rolling_max.last()\
    \ {\n            Some(max) => if *max > number { *max } else { number },\n   \
    \         None => number,\n        });\n    }\n    rolling_max", "    let mut\
    \ max = numbers[0];\n    let mut result = Vec::new();\n    result.push(max);\n\
    \n    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        result.push(max);\n    }\n\n    result", "    let mut result\
    \ = Vec::with_capacity(numbers.len());\n    let mut current_max = numbers[0];\n\
    \    result.push(current_max);\n    for &number in numbers.iter().skip(1) {\n\
    \        current_max = max(current_max, number);\n        result.push(current_max);\n\
    \    }\n    result", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut max = std::isize::MIN;\n    for i in 0..numbers.len() {\n       \
    \ max = if numbers[i] > max {\n            numbers[i]\n        } else {\n    \
    \        max\n        };\n        result.push(max);\n    }\n    result", "   \
    \ let mut current_max = numbers[0];\n    let mut result = Vec::new();\n    result.push(current_max);\n\
    \n    for &value in numbers.iter().skip(1) {\n        current_max = std::cmp::max(current_max,\
    \ value);\n        result.push(current_max);\n    }\n\n    result", "    let mut\
    \ max = numbers[0];\n    let mut result = Vec::new();\n    result.push(max);\n\
    \n    for &num in numbers.iter().skip(1) {\n        max = max.max(num);\n    \
    \    result.push(max);\n    }\n\n    result", "    let mut max = Vec::new();\n\
    \    for number in numbers {\n        let max_so_far = max.last().unwrap_or(&isize::min_value());\n\
    \        max.push(max(number, *max_so_far));\n    }\n    max", "    let mut result\
    \ = Vec::new();\n    let mut max = -1;\n    for num in numbers {\n        if num\
    \ > max {\n            max = num;\n        }\n        result.push(max);\n    }\n\
    \    result", "    numbers\n        .iter()\n        .scan(isize::min_value(),\
    \ |state, item| {\n            *state = cmp::max(*state, *item);\n           \
    \ Some(*state)\n        })\n        .collect()", "    let mut max = std::isize::MIN;\n\
    \    let mut result = Vec::new();\n    for number in numbers {\n        if number\
    \ > max {\n            max = number;\n        }\n        result.push(max);\n \
    \   }\n    result", "    let mut current_max = isize::min_value();\n    let mut\
    \ result = Vec::new();\n\n    for number in numbers {\n        if number > current_max\
    \ {\n            current_max = number;\n        }\n\n        result.push(current_max);\n\
    \    }\n\n    result", "    let mut max_elements = Vec::new();\n    let mut max_element\
    \ = numbers[0];\n    max_elements.push(max_element);\n\n    for number in numbers.iter().skip(1)\
    \ {\n        if number > &max_element {\n            max_element = *number;\n\
    \        }\n        max_elements.push(max_element);\n    }\n\n    max_elements",
  "    let mut maximums = Vec::with_capacity(numbers.len());\n    let mut max = numbers[0];\n\
    \    maximums.push(max);\n    for element in numbers.iter().skip(1) {\n      \
    \  max = max.max(*element);\n        maximums.push(max);\n    }\n    maximums",
  "    let mut max = 0;\n    let mut out = Vec::new();\n    for n in numbers {\n \
    \       if n > max {\n            max = n;\n        }\n        out.push(max);\n\
    \    }\n    out", "    if numbers.is_empty() {\n        return vec![];\n    }\n\
    \n    numbers\n        .iter()\n        .scan(numbers[0], |state, value| {\n \
    \           *state = std::cmp::max(*state, *value);\n            Some(*state)\n\
    \        })\n        .collect()", "    let mut max = 0;\n    let mut result =\
    \ Vec::with_capacity(numbers.len());\n    for n in numbers {\n        if n > max\
    \ {\n            max = n;\n        }\n        result.push(max);\n    }\n    result",
  "    let mut result = Vec::new();\n    for n in numbers {\n        if result.is_empty()\
    \ {\n            result.push(n);\n        } else {\n            result.push(std::cmp::max(result.last().unwrap(),\
    \ &n));\n        }\n    }\n    result", "    let mut rolling_maxes = Vec::with_capacity(numbers.len());\n\
    \    rolling_maxes.push(numbers[0]);\n\n    for i in 1..numbers.len() {\n    \
    \    rolling_maxes.push(rolling_maxes[i - 1].max(numbers[i]));\n    }\n\n    rolling_maxes",
  "    let mut results = Vec::with_capacity(numbers.len());\n    let mut max = isize::min_value();\n\
    \n    for item in numbers {\n        max = std::cmp::max(max, item);\n       \
    \ results.push(max);\n    }\n\n    results", "    let mut max: isize = 0;\n  \
    \  let mut result: Vec<isize> = Vec::new();\n\n    for number in numbers {\n \
    \       if number > max {\n            max = number;\n        }\n\n        result.push(max);\n\
    \    }\n\n    result", "    // TODO implement an actual method\n    numbers",
  "    let mut result = Vec::with_capacity(numbers.len());\n    let mut max_so_far\
    \ = numbers[0];\n    result.push(max_so_far);\n    for i in 1..numbers.len() {\n\
    \        if numbers[i] > max_so_far {\n            max_so_far = numbers[i];\n\
    \        }\n        result.push(max_so_far);\n    }\n    result", "    let mut\
    \ result = Vec::with_capacity(numbers.len());\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        max = n.max(max);\n        result.push(max);\n\
    \    }\n    result", "    numbers\n        .iter()\n        .scan(std::isize::MIN,\
    \ |max, &x| {\n            *max = std::cmp::max(*max, x);\n            Some(*max)\n\
    \        })\n        .collect()", "    let mut max = 0;\n    let mut values =\
    \ Vec::new();\n    for number in numbers {\n        max = isize::max(max, number);\n\
    \        values.push(max);\n    }\n    values", "    let mut result = Vec::new();\n\
    \    let mut max = std::isize::MIN;\n    for number in numbers {\n        max\
    \ = number.max(max);\n        result.push(max);\n    }\n    result", "    let\
    \ mut max_seen = isize::min_value();\n    let mut res = Vec::with_capacity(numbers.len());\n\
    \    for x in numbers {\n        max_seen = max(max_seen, x);\n        res.push(max_seen);\n\
    \    }\n    res", "    // TODO: Write your code here\n    unimplemented!();",
  "    let mut max_until_now = isize::min_value();\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \n    for number in numbers {\n        max_until_now = max(max_until_now, number);\n\
    \        rolling_max.push(max_until_now);\n    }\n\n    rolling_max", "    if\
    \ numbers.is_empty() {\n        return vec![];\n    }\n\n    numbers.iter().scan(numbers[0],\
    \ |state, x| {\n        *state = (*state).max(*x);\n        Some(*state)\n   \
    \ }).collect()", "    let mut rolling_max: Vec<isize> = Vec::new();\n    let mut\
    \ max_so_far = numbers[0];\n    rolling_max.push(max_so_far);\n\n    for n in\
    \ numbers.iter().skip(1) {\n        if n > &max_so_far {\n            max_so_far\
    \ = *n;\n        }\n        rolling_max.push(max_so_far);\n    }\n\n    rolling_max",
  "    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n    for n\
    \ in numbers {\n        max = std::cmp::max(max, n);\n        result.push(max);\n\
    \    }\n    result", "    let mut rolling_max: Vec<isize> = Vec::new();\n    let\
    \ mut max_value = isize::min_value();\n\n    for value in numbers {\n        if\
    \ value > max_value {\n            max_value = value;\n        }\n\n        rolling_max.push(max_value);\n\
    \    }\n\n    rolling_max", "    let mut result = Vec::with_capacity(numbers.len());\n\
    \    let mut rolling_max = numbers[0];\n    result.push(rolling_max);\n    for\
    \ n in numbers[1..].iter() {\n        if *n > rolling_max {\n            rolling_max\
    \ = *n;\n        }\n        result.push(rolling_max);\n    }\n    result", " \
    \   let mut ret = Vec::new();\n    let mut current_max = *numbers.get(0).unwrap();\n\
    \    for &n in numbers.iter() {\n        if n > current_max {\n            current_max\
    \ = n;\n        }\n        ret.push(current_max);\n    }\n    ret", "    let mut\
    \ ret = Vec::new();\n    let mut max_el = numbers[0];\n    ret.push(max_el);\n\
    \    for i in 1..numbers.len() {\n        if numbers[i] > max_el {\n         \
    \   max_el = numbers[i];\n        }\n        ret.push(max_el);\n    }\n    ret",
  "    let mut max_vec = Vec::new();\n    let mut current_max = isize::min_value();\n\
    \n    for number in numbers {\n        if number > current_max {\n           \
    \ current_max = number;\n        }\n\n        max_vec.push(current_max);\n   \
    \ }\n\n    max_vec", "    let mut result = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        if n > max {\n            max = n;\n        }\n\
    \        result.push(max);\n    }\n    result", "    let mut max_values = Vec::new();\n\
    \    let mut current_max = None;\n\n    for number in numbers {\n        current_max\
    \ = match current_max {\n            None => Some(number),\n            Some(current_max)\
    \ => Some(current_max.max(number)),\n        };\n\n        max_values.push(current_max.unwrap());\n\
    \    }\n\n    max_values", "    let mut result = Vec::new();\n    let mut max\
    \ = isize::min_value();\n\n    for n in numbers {\n        max = if n > max {\
    \ n } else { max };\n        result.push(max);\n    }\n\n    result", "    let\
    \ mut result = Vec::new();\n    let mut current_max = 0;\n    for num in numbers\
    \ {\n        current_max = cmp::max(current_max, num);\n        result.push(current_max);\n\
    \    }\n    result", "    if numbers.is_empty() {\n        return vec![];\n  \
    \  }\n\n    let mut max_numbers = Vec::with_capacity(numbers.len());\n    let\
    \ mut current_max = numbers[0];\n    max_numbers.push(current_max);\n\n    for\
    \ number in numbers.iter().skip(1) {\n        if number > &current_max {\n   \
    \         current_max = *number;\n        }\n        max_numbers.push(current_max);\n\
    \    }\n\n    max_numbers", "    let n = numbers.len();\n    let mut result =\
    \ Vec::with_capacity(n);\n    let mut max = numbers[0];\n    result.push(max);\n\
    \    for i in 1..n {\n        max = if numbers[i] > max {\n            numbers[i]\n\
    \        } else {\n            max\n        };\n        result.push(max);\n  \
    \  }\n    result", "    let mut out = Vec::new();\n    let mut max = std::isize::MIN;\n\
    \    for n in numbers {\n        max = std::cmp::max(max, n);\n        out.push(max);\n\
    \    }\n    out", "    numbers\n        .into_iter()\n        .scan(0, |state,\
    \ next| {\n            if next > *state {\n                *state = next;\n  \
    \          }\n            Some(*state)\n        })\n        .collect()", "   \
    \ let mut max = std::isize::MIN;\n    let mut max_sequence = Vec::new();\n   \
    \ for number in numbers {\n        max = number.max(max);\n        max_sequence.push(max);\n\
    \    }\n    max_sequence", "    let mut max = Vec::new();\n    max.push(numbers[0]);\n\
    \    for i in 1..numbers.len() {\n        let m = max[i - 1];\n        max.push(if\
    \ numbers[i] > m { numbers[i] } else { m });\n    }\n    max", "    let mut max\
    \ = std::isize::MIN;\n    let mut rolling_max = Vec::with_capacity(numbers.len());\n\
    \    for number in numbers {\n        if number > max {\n            max = number;\n\
    \        }\n        rolling_max.push(max);\n    }\n    rolling_max", "    let\
    \ mut rmax: Vec<isize> = Vec::new();\n    let mut local_max = isize::min_value();\n\
    \    for n in numbers {\n        local_max = local_max.max(n);\n        rmax.push(local_max);\n\
    \    }\n    rmax", "    let mut max_value = isize::min_value();\n    let mut result\
    \ = Vec::new();\n\n    for n in numbers {\n        max_value = std::cmp::max(max_value,\
    \ n);\n        result.push(max_value);\n    }\n\n    result"]
stop_tokens:
- "\n}"
